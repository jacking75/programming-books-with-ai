# workingBooks  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 15. 메모리 최적화
게임 서버에서 메모리 최적화는 성능과 안정성을 좌우하는 핵심 요소이다. 특히 대량의 동시 접속자를 처리해야 하는 환경에서는 효율적인 메모리 관리가 필수적이다. 이번 장에서는 Boost.Asio와 함께 사용할 수 있는 다양한 메모리 최적화 기법을 학습한다.
  
## 15.1 커스텀 할당자 구현

### 15.1.1 메모리 풀 기반 할당자
메모리 풀을 사용하면 동적 할당/해제의 오버헤드를 줄이고 메모리 단편화를 방지할 수 있다.

```cpp
#include <memory>
#include <vector>
#include <stack>
#include <mutex>
#include <cstddef>
#include <iostream>

template<typename T>
class MemoryPool
{
public:
    explicit MemoryPool(size_t initial_size = 1000)
        : block_size_(sizeof(T)), pool_size_(initial_size)
    {
        AllocatePool();
    }

    ~MemoryPool()
    {
        DeallocatePool();
    }

    T* Allocate()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        if (free_blocks_.empty())
        {
            ExpandPool();
        }
        
        void* ptr = free_blocks_.top();
        free_blocks_.pop();
        
        ++allocated_count_;
        return static_cast<T*>(ptr);
    }

    void Deallocate(T* ptr)
    {
        if (!ptr) return;
        
        std::lock_guard<std::mutex> lock(mutex_);
        free_blocks_.push(ptr);
        --allocated_count_;
    }

    size_t GetAllocatedCount() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return allocated_count_;
    }

    size_t GetPoolSize() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return pool_size_;
    }

    void PrintStatistics() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        std::cout << "Memory Pool Statistics:" << std::endl;
        std::cout << "- Pool size: " << pool_size_ << std::endl;
        std::cout << "- Allocated blocks: " << allocated_count_ << std::endl;
        std::cout << "- Free blocks: " << free_blocks_.size() << std::endl;
        std::cout << "- Block size: " << block_size_ << " bytes" << std::endl;
        std::cout << "- Total memory: " << (pool_size_ * block_size_) << " bytes" << std::endl;
    }

private:
    void AllocatePool()
    {
        size_t total_size = pool_size_ * block_size_;
        memory_blocks_.push_back(std::make_unique<char[]>(total_size));
        
        char* pool = memory_blocks_.back().get();
        for (size_t i = 0; i < pool_size_; ++i)
        {
            free_blocks_.push(pool + i * block_size_);
        }
    }

    void ExpandPool()
    {
        size_t old_size = pool_size_;
        pool_size_ *= 2; // 풀 크기를 2배로 확장
        
        std::cout << "Expanding memory pool from " << old_size 
                 << " to " << pool_size_ << " blocks" << std::endl;
        
        size_t new_blocks = pool_size_ - old_size;
        size_t total_size = new_blocks * block_size_;
        
        memory_blocks_.push_back(std::make_unique<char[]>(total_size));
        
        char* pool = memory_blocks_.back().get();
        for (size_t i = 0; i < new_blocks; ++i)
        {
            free_blocks_.push(pool + i * block_size_);
        }
    }

    void DeallocatePool()
    {
        memory_blocks_.clear();
        std::stack<void*> empty;
        free_blocks_.swap(empty);
    }

    size_t block_size_;
    size_t pool_size_;
    size_t allocated_count_ = 0;
    
    std::vector<std::unique_ptr<char[]>> memory_blocks_;
    std::stack<void*> free_blocks_;
    mutable std::mutex mutex_;
};

// STL 호환 할당자
template<typename T>
class PoolAllocator
{
public:
    using value_type = T;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;

    template<typename U>
    struct rebind
    {
        using other = PoolAllocator<U>;
    };

    explicit PoolAllocator(MemoryPool<T>& pool) : pool_(&pool) {}

    template<typename U>
    PoolAllocator(const PoolAllocator<U>& other) : pool_(other.pool_) {}

    pointer allocate(size_type n)
    {
        if (n != 1)
        {
            // 단일 객체만 지원
            throw std::bad_alloc();
        }
        return pool_->Allocate();
    }

    void deallocate(pointer p, size_type n)
    {
        pool_->Deallocate(p);
    }

    template<typename U, typename... Args>
    void construct(U* p, Args&&... args)
    {
        new(p) U(std::forward<Args>(args)...);
    }

    template<typename U>
    void destroy(U* p)
    {
        p->~U();
    }

    bool operator==(const PoolAllocator& other) const
    {
        return pool_ == other.pool_;
    }

    bool operator!=(const PoolAllocator& other) const
    {
        return !(*this == other);
    }

private:
    template<typename U>
    friend class PoolAllocator;
    
    MemoryPool<T>* pool_;
};

// 사용 예제
struct GamePacket
{
    uint32_t packet_id;
    uint32_t player_id;
    uint16_t packet_type;
    uint16_t data_size;
    char data[256];
    
    GamePacket() : packet_id(0), player_id(0), packet_type(0), data_size(0)
    {
        std::memset(data, 0, sizeof(data));
    }
};

void memory_pool_example()
{
    MemoryPool<GamePacket> packet_pool(100);
    
    std::cout << "Creating packets..." << std::endl;
    std::vector<GamePacket*> packets;
    
    // 패킷 할당
    for (int i = 0; i < 150; ++i) // 풀 크기보다 많이 할당하여 확장 테스트
    {
        GamePacket* packet = packet_pool.Allocate();
        packet->packet_id = i;
        packet->player_id = 1000 + i;
        packet->packet_type = i % 10;
        packets.push_back(packet);
    }
    
    packet_pool.PrintStatistics();
    
    // 패킷 해제
    for (auto packet : packets)
    {
        packet_pool.Deallocate(packet);
    }
    
    std::cout << "After deallocation:" << std::endl;
    packet_pool.PrintStatistics();
}
```
  

### 15.1.2 스택 할당자 구현
스택 기반 할당자는 빠른 할당/해제가 가능하며, 스코프 기반 메모리 관리에 유용하다.

```cpp
class StackAllocator
{
public:
    explicit StackAllocator(size_t size)
        : size_(size), top_(0)
    {
        memory_ = std::make_unique<char[]>(size);
        start_ = memory_.get();
    }

    ~StackAllocator() = default;

    void* Allocate(size_t size, size_t alignment = alignof(std::max_align_t))
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        // 정렬 조정
        size_t aligned_top = AlignUp(top_, alignment);
        
        if (aligned_top + size > size_)
        {
            throw std::bad_alloc();
        }
        
        void* ptr = start_ + aligned_top;
        top_ = aligned_top + size;
        
        ++allocation_count_;
        return ptr;
    }

    void Reset()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        top_ = 0;
        allocation_count_ = 0;
    }

    size_t GetUsedSize() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return top_;
    }

    size_t GetFreeSize() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return size_ - top_;
    }

    size_t GetAllocationCount() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return allocation_count_;
    }

    void PrintStatistics() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        std::cout << "Stack Allocator Statistics:" << std::endl;
        std::cout << "- Total size: " << size_ << " bytes" << std::endl;
        std::cout << "- Used size: " << top_ << " bytes" << std::endl;
        std::cout << "- Free size: " << (size_ - top_) << " bytes" << std::endl;
        std::cout << "- Allocation count: " << allocation_count_ << std::endl;
        std::cout << "- Usage: " << (static_cast<double>(top_) / size_ * 100.0) << "%" << std::endl;
    }

private:
    size_t AlignUp(size_t size, size_t alignment)
    {
        return (size + alignment - 1) & ~(alignment - 1);
    }

    std::unique_ptr<char[]> memory_;
    char* start_;
    size_t size_;
    size_t top_;
    size_t allocation_count_ = 0;
    mutable std::mutex mutex_;
};

// RAII 스타일 스택 할당자 마커
class StackMarker
{
public:
    explicit StackMarker(StackAllocator& allocator)
        : allocator_(allocator), marker_(allocator.GetUsedSize())
    {
    }

    ~StackMarker()
    {
        // 마커 지점으로 되돌리기 (실제로는 StackAllocator에 이 기능이 필요)
    }

private:
    StackAllocator& allocator_;
    size_t marker_;
};

template<typename T>
class StackAllocatorAdapter
{
public:
    using value_type = T;

    explicit StackAllocatorAdapter(StackAllocator& allocator)
        : allocator_(&allocator) {}

    template<typename U>
    StackAllocatorAdapter(const StackAllocatorAdapter<U>& other)
        : allocator_(other.allocator_) {}

    T* allocate(std::size_t n)
    {
        return static_cast<T*>(allocator_->Allocate(n * sizeof(T), alignof(T)));
    }

    void deallocate(T* p, std::size_t n)
    {
        // 스택 할당자는 개별 해제를 지원하지 않음
    }

    template<typename U>
    bool operator==(const StackAllocatorAdapter<U>& other) const
    {
        return allocator_ == other.allocator_;
    }

    template<typename U>
    bool operator!=(const StackAllocatorAdapter<U>& other) const
    {
        return !(*this == other);
    }

private:
    template<typename U>
    friend class StackAllocatorAdapter;
    
    StackAllocator* allocator_;
};

void stack_allocator_example()
{
    StackAllocator stack_alloc(1024 * 1024); // 1MB 스택
    
    std::cout << "Stack allocator test..." << std::endl;
    
    // 다양한 크기의 메모리 할당
    void* ptr1 = stack_alloc.Allocate(100);
    void* ptr2 = stack_alloc.Allocate(256);
    void* ptr3 = stack_alloc.Allocate(512);
    
    stack_alloc.PrintStatistics();
    
    // 스택 리셋
    stack_alloc.Reset();
    std::cout << "After reset:" << std::endl;
    stack_alloc.PrintStatistics();
}
```  
  
이 코드는 **게임 서버나 실시간 엔진에서 매우 자주 사용되는 "스택 기반 메모리 할당자(Stack Allocator)"의 구현 예제**이다.
`new` / `delete` 기반의 일반 힙 메모리보다 훨씬 빠르고 예측 가능한 할당을 제공하며,
특히 **프레임 단위 또는 스코프 단위로 생성 후 일괄 해제되는 객체**를 다룰 때 탁월하다.

#### 스택 기반 메모리 할당자의 개념

✅ 핵심 아이디어

스택 할당자는 말 그대로 “스택처럼 동작하는” 메모리 할당 방식이다.
즉, **메모리를 순서대로 쌓기만 하고**,
해제는 **전체를 한 번에 리셋(Reset)** 하는 구조다.

이를 통해 다음과 같은 특징을 가진다:

| 특징     | 설명                                          |
| ------ | ------------------------------------------- |
| 빠른 할당  | 단순히 포인터(top)를 증가시키는 연산만 수행                  |
| 빠른 해제  | 전체 스택을 한 번에 리셋                              |
| 예측 가능성 | 조각화(fragmentation)가 발생하지 않음                 |
| 제약     | 개별 해제(`free`) 불가능, LIFO 순서가 아님에도 전체 해제로 처리됨 |

#### 전체 구조 요약

```text
StackAllocator  → 메모리 풀 전체를 관리
   ├── Allocate(size, alignment)
   ├── Reset()
   ├── PrintStatistics()
   └── 내부 상태: start_, top_, size_, allocation_count_

StackMarker     → 특정 시점의 메모리 포인터를 저장하는 RAII 마커
StackAllocatorAdapter<T> → STL 컨테이너용 어댑터 (std::vector 등에서 사용 가능)
```

#### 메모리 다이어그램

```
메모리 풀 (1MB 예시)
+---------------------------------------------------------------+
|         사용 중 메모리         |       여유 공간 (free)        |
+---------------------------------------------------------------+
^                               ^
|                               |
start_                        start_ + top_

할당 시:
top_ ← top_ + size
해제 시:
top_ ← 0 (Reset)
```

#### `StackAllocator`

✅ 핵심 멤버

```cpp
std::unique_ptr<char[]> memory_;  // 실제 메모리 블록
char* start_;                     // 블록의 시작 주소
size_t size_;                     // 전체 크기
size_t top_;                      // 현재 스택 포인터
size_t allocation_count_;         // 할당 횟수 (디버깅용)
std::mutex mutex_;                // 스레드 안전 보장
```

* **`memory_`**: `new char[size]`로 확보한 전체 블록
* **`start_`**: 첫 바이트 주소
* **`top_`**: 현재 스택의 최상단 위치(다음 할당 위치)
* **`mutex_`**: 멀티스레드 환경에서의 동기화

✅ `Allocate(size, alignment)`

```cpp
void* Allocate(size_t size, size_t alignment = alignof(std::max_align_t))
{
    std::lock_guard<std::mutex> lock(mutex_);

    size_t aligned_top = AlignUp(top_, alignment);
    if (aligned_top + size > size_) throw std::bad_alloc();

    void* ptr = start_ + aligned_top;
    top_ = aligned_top + size;

    ++allocation_count_;
    return ptr;
}
```

1. **정렬 보정(AlignUp)**
   → 구조체나 SIMD 타입처럼 메모리 정렬이 필요한 경우 대응.

   ```cpp
   (size + alignment - 1) & ~(alignment - 1)
   ```

   즉, `alignment` 단위로 올림 정렬(예: 8바이트 정렬).

2. **포인터 계산**
   `ptr = start_ + aligned_top`

3. **top_ 이동**
   다음 할당 위치로 스택 포인터 이동

4. **빠른 O(1) 시간 할당**

✅ `Reset()`

```cpp
void Reset()
{
    std::lock_guard<std::mutex> lock(mutex_);
    top_ = 0;
    allocation_count_ = 0;
}
```

* 개별 해제가 불가능하므로, 전체를 한 번에 되돌림
* 보통 **프레임 끝**이나 **함수 종료 시점**에 호출됨

✅ `PrintStatistics()`

```cpp
void PrintStatistics() const
{
    std::cout << "- Total size: " << size_ << " bytes\n";
    std::cout << "- Used size: " << top_ << " bytes\n";
    std::cout << "- Free size: " << (size_ - top_) << " bytes\n";
    std::cout << "- Allocation count: " << allocation_count_ << "\n";
}
```

디버깅 및 성능 모니터링에 유용하다.
  

#### `StackMarker`

```cpp
class StackMarker
{
public:
    explicit StackMarker(StackAllocator& allocator)
        : allocator_(allocator), marker_(allocator.GetUsedSize()) {}

    ~StackMarker()
    {
        // 마커 지점으로 되돌리는 기능은 구현 필요
    }

private:
    StackAllocator& allocator_;
    size_t marker_;
};
```

* **RAII(Resource Acquisition Is Initialization)** 패턴
* 생성 시점에서 스택의 현재 상태(`marker_`)를 저장
* 소멸자에서 해당 시점으로 되돌릴 수 있다면, 스코프 단위의 자동 해제가 가능

즉, 다음과 같은 구조를 의도한 것이다:

```cpp
{
    StackMarker marker(stack_alloc);
    void* ptr1 = stack_alloc.Allocate(128);
    void* ptr2 = stack_alloc.Allocate(256);
} // marker 소멸 시 자동으로 top 복구 (현재는 미구현)
```
  

#### `StackAllocatorAdapter<T>`

```cpp
template<typename T>
class StackAllocatorAdapter
{
public:
    using value_type = T;
    explicit StackAllocatorAdapter(StackAllocator& allocator);
    
    T* allocate(std::size_t n) {
        return static_cast<T*>(allocator_->Allocate(n * sizeof(T), alignof(T)));
    }

    void deallocate(T*, std::size_t) { /* do nothing */ }
};
```

역할:

STL 컨테이너(`std::vector`, `std::unordered_map` 등)에
커스텀 메모리 할당자로 `StackAllocator`를 연결하기 위한 어댑터다.

```cpp
StackAllocator stack_alloc(1024 * 1024);
std::vector<int, StackAllocatorAdapter<int>> v(StackAllocatorAdapter<int>(stack_alloc));
```

이렇게 하면 `vector`가 내부 버퍼를 할당할 때 `StackAllocator`를 사용한다.


#### 동작 흐름

```mermaid  
graph TD
    A[StackAllocator 생성 (1MB)] --> B[Allocate(100)]
    B --> C[AlignUp(top_)]
    C --> D[메모리 포인터 계산 및 top_ 이동]
    D --> E[Allocate(256)]
    E --> F[Allocate(512)]
    F --> G[PrintStatistics()]
    G --> H[Reset()]
    H --> I[PrintStatistics()]
```

#### 실행 예시 출력

```
Stack allocator test...
Stack Allocator Statistics:
- Total size: 1048576 bytes
- Used size: 868 bytes
- Free size: 1047708 bytes
- Allocation count: 3
- Usage: 0.0828%

After reset:
Stack Allocator Statistics:
- Total size: 1048576 bytes
- Used size: 0 bytes
- Free size: 1048576 bytes
- Allocation count: 0
- Usage: 0%
```

#### 성능 및 사용 사례

| 항목      | 설명                                                   |
| ------- | ---------------------------------------------------- |
| 시간 복잡도  | `Allocate()`는 O(1)                                   |
| 해제 정책   | 전체 리셋(`Reset()`) 또는 마커 복원                            |
| 일반적 사용처 | 프레임 메모리, ECS(Entity Component System), 파티클, 경량 임시 버퍼 |
| 장점      | 빠름, 조각화 없음, 캐시 효율적                                   |
| 단점      | 개별 해제 불가능, 메모리 누수 방지를 위해 사용 패턴이 명확해야 함               |

#### 확장 아이디어
이 예제는 기본 형태지만 다음 기능을 추가하면 실전 엔진 수준의 품질로 확장할 수 있다.

| 기능                            | 설명                             |
| ----------------------------- | ------------------------------ |
| `FreeToMarker(marker)`        | `StackMarker`가 지정한 위치로 스택 되돌리기 |
| `Thread-local StackAllocator` | 각 스레드별 스택 메모리 관리               |
| `ScopedAllocator`             | 특정 스코프에서 자동 Reset 지원           |
| `Profiling 지원`                | 할당 크기, 평균/최대 사용량 추적            |

---

#### 요약
이 코드는 **고성능 실시간 시스템에서 메모리 효율을 높이기 위한 스택 기반 메모리 관리 기법의 기초 구현**이다.
Boost, Unreal, Unity 등 주요 엔진에서 공통적으로 사용하는 패턴이며,

* 빠른 할당/해제
* 단순한 구조
* 메모리 조각화 방지
* 스코프 단위 자동 관리(RAII 가능성)

을 모두 만족시키는 **엔진 수준 메모리 관리의 출발점**이라 할 수 있다.

  
### 15.1.3 슬랩 할당자 (Slab Allocator)
슬랩 할당자는 고정 크기 객체의 빠른 할당을 위해 설계된 할당자이다.

```cpp
template<typename T, size_t SlabSize = 64>
class SlabAllocator
{
private:
    struct Slab
    {
        alignas(T) char data[SlabSize * sizeof(T)];
        std::bitset<SlabSize> used_mask;
        size_t free_count = SlabSize;
        
        T* GetObject(size_t index)
        {
            return reinterpret_cast<T*>(data + index * sizeof(T));
        }
    };

public:
    SlabAllocator() = default;
    ~SlabAllocator()
    {
        Clear();
    }

    T* Allocate()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        // 사용 가능한 슬랩 찾기
        for (auto& slab : slabs_)
        {
            if (slab->free_count > 0)
            {
                return AllocateFromSlab(*slab);
            }
        }
        
        // 새 슬랩 생성
        auto new_slab = std::make_unique<Slab>();
        T* result = AllocateFromSlab(*new_slab);
        slabs_.push_back(std::move(new_slab));
        
        return result;
    }

    void Deallocate(T* ptr)
    {
        if (!ptr) return;
        
        std::lock_guard<std::mutex> lock(mutex_);
        
        for (auto& slab : slabs_)
        {
            char* slab_start = slab->data;
            char* slab_end = slab_start + SlabSize * sizeof(T);
            
            if (reinterpret_cast<char*>(ptr) >= slab_start && 
                reinterpret_cast<char*>(ptr) < slab_end)
            {
                size_t index = (reinterpret_cast<char*>(ptr) - slab_start) / sizeof(T);
                
                if (slab->used_mask[index])
                {
                    slab->used_mask[index] = false;
                    slab->free_count++;
                    
                    // 객체 소멸자 호출
                    ptr->~T();
                    
                    ++deallocated_count_;
                }
                break;
            }
        }
    }

    void Clear()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        // 모든 할당된 객체의 소멸자 호출
        for (auto& slab : slabs_)
        {
            for (size_t i = 0; i < SlabSize; ++i)
            {
                if (slab->used_mask[i])
                {
                    slab->GetObject(i)->~T();
                }
            }
        }
        
        slabs_.clear();
        allocated_count_ = 0;
        deallocated_count_ = 0;
    }

    size_t GetAllocatedCount() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return allocated_count_;
    }

    size_t GetSlabCount() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return slabs_.size();
    }

    void PrintStatistics() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        std::cout << "Slab Allocator Statistics:" << std::endl;
        std::cout << "- Slab count: " << slabs_.size() << std::endl;
        std::cout << "- Slab size: " << SlabSize << " objects" << std::endl;
        std::cout << "- Object size: " << sizeof(T) << " bytes" << std::endl;
        std::cout << "- Allocated objects: " << allocated_count_ << std::endl;
        std::cout << "- Deallocated objects: " << deallocated_count_ << std::endl;
        std::cout << "- Active objects: " << (allocated_count_ - deallocated_count_) << std::endl;
        
        size_t total_capacity = slabs_.size() * SlabSize;
        size_t used_capacity = allocated_count_ - deallocated_count_;
        std::cout << "- Capacity utilization: " 
                 << (total_capacity > 0 ? (static_cast<double>(used_capacity) / total_capacity * 100.0) : 0.0) 
                 << "%" << std::endl;
    }

private:
    T* AllocateFromSlab(Slab& slab)
    {
        for (size_t i = 0; i < SlabSize; ++i)
        {
            if (!slab.used_mask[i])
            {
                slab.used_mask[i] = true;
                slab.free_count--;
                ++allocated_count_;
                
                T* obj = slab.GetObject(i);
                new(obj) T(); // placement new로 객체 생성
                return obj;
            }
        }
        return nullptr; // 이론적으로 도달할 수 없음
    }

    std::vector<std::unique_ptr<Slab>> slabs_;
    size_t allocated_count_ = 0;
    size_t deallocated_count_ = 0;
    mutable std::mutex mutex_;
};

// 게임 오브젝트 예제
class GameObject
{
public:
    GameObject() : id_(next_id_++), position_{0.0f, 0.0f, 0.0f}, health_(100)
    {
        std::cout << "GameObject " << id_ << " created" << std::endl;
    }

    ~GameObject()
    {
        std::cout << "GameObject " << id_ << " destroyed" << std::endl;
    }

    uint32_t GetId() const { return id_; }
    void SetPosition(float x, float y, float z) { position_[0] = x; position_[1] = y; position_[2] = z; }

private:
    uint32_t id_;
    float position_[3];
    int health_;
    static std::atomic<uint32_t> next_id_;
};

std::atomic<uint32_t> GameObject::next_id_{1};

void slab_allocator_example()
{
    SlabAllocator<GameObject, 32> slab_alloc;
    
    std::cout << "Slab allocator test..." << std::endl;
    
    std::vector<GameObject*> objects;
    
    // 객체 할당
    for (int i = 0; i < 100; ++i)
    {
        GameObject* obj = slab_alloc.Allocate();
        obj->SetPosition(i, i * 2, i * 3);
        objects.push_back(obj);
    }
    
    slab_alloc.PrintStatistics();
    
    // 일부 객체 해제
    for (size_t i = 0; i < objects.size(); i += 2)
    {
        slab_alloc.Deallocate(objects[i]);
        objects[i] = nullptr;
    }
    
    std::cout << "After partial deallocation:" << std::endl;
    slab_alloc.PrintStatistics();
    
    // 나머지 객체 해제
    for (auto obj : objects)
    {
        if (obj)
        {
            slab_alloc.Deallocate(obj);
        }
    }
    
    std::cout << "After full deallocation:" << std::endl;
    slab_alloc.PrintStatistics();
}
```
  
</br>  
  

## 15.2 핸들러 메모리 풀링

### 15.2.1 Boost.Asio 핸들러 최적화
Boost.Asio의 핸들러 할당을 최적화하여 성능을 향상시킬 수 있다.

```cpp
#include <boost/asio.hpp>
#include <boost/asio/associated_allocator.hpp>

class HandlerMemoryPool
{
public:
    explicit HandlerMemoryPool(size_t block_size = 1024)
        : block_size_(block_size)
    {
    }

    void* Allocate(size_t size)
    {
        if (size > block_size_)
        {
            // 큰 할당은 일반 new 사용
            ++large_allocations_;
            return ::operator new(size);
        }

        std::lock_guard<std::mutex> lock(mutex_);
        
        if (free_blocks_.empty())
        {
            AllocateNewBlock();
        }

        void* ptr = free_blocks_.back();
        free_blocks_.pop_back();
        ++small_allocations_;
        
        return ptr;
    }

    void Deallocate(void* ptr, size_t size)
    {
        if (size > block_size_)
        {
            ::operator delete(ptr);
            --large_allocations_;
            return;
        }

        std::lock_guard<std::mutex> lock(mutex_);
        free_blocks_.push_back(ptr);
        --small_allocations_;
    }

    void PrintStatistics() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        std::cout << "Handler Memory Pool Statistics:" << std::endl;
        std::cout << "- Block size: " << block_size_ << " bytes" << std::endl;
        std::cout << "- Total blocks: " << total_blocks_ << std::endl;
        std::cout << "- Free blocks: " << free_blocks_.size() << std::endl;
        std::cout << "- Small allocations: " << small_allocations_ << std::endl;
        std::cout << "- Large allocations: " << large_allocations_ << std::endl;
    }

private:
    void AllocateNewBlock()
    {
        const size_t blocks_per_chunk = 64;
        char* chunk = new char[block_size_ * blocks_per_chunk];
        chunks_.push_back(std::unique_ptr<char[]>(chunk));
        
        for (size_t i = 0; i < blocks_per_chunk; ++i)
        {
            free_blocks_.push_back(chunk + i * block_size_);
        }
        
        total_blocks_ += blocks_per_chunk;
    }

    size_t block_size_;
    size_t total_blocks_ = 0;
    std::atomic<size_t> small_allocations_{0};
    std::atomic<size_t> large_allocations_{0};
    
    std::vector<std::unique_ptr<char[]>> chunks_;
    std::vector<void*> free_blocks_;
    mutable std::mutex mutex_;
};

class HandlerAllocator
{
public:
    explicit HandlerAllocator(HandlerMemoryPool& pool) : pool_(pool) {}

    template<typename T>
    T* allocate(size_t n)
    {
        return static_cast<T*>(pool_.Allocate(n * sizeof(T)));
    }

    template<typename T>
    void deallocate(T* p, size_t n)
    {
        pool_.Deallocate(p, n * sizeof(T));
    }

    friend bool operator==(const HandlerAllocator& a, const HandlerAllocator& b)
    {
        return &a.pool_ == &b.pool_;
    }

    friend bool operator!=(const HandlerAllocator& a, const HandlerAllocator& b)
    {
        return !(a == b);
    }

private:
    HandlerMemoryPool& pool_;
};

// 커스텀 할당자를 사용하는 핸들러
template<typename Handler>
class PooledHandler
{
public:
    using allocator_type = HandlerAllocator;

    PooledHandler(Handler handler, HandlerMemoryPool& pool)
        : handler_(std::move(handler)), allocator_(pool)
    {
    }

    allocator_type get_allocator() const noexcept
    {
        return allocator_;
    }

    template<typename... Args>
    void operator()(Args&&... args)
    {
        handler_(std::forward<Args>(args)...);
    }

private:
    Handler handler_;
    HandlerAllocator allocator_;
};

template<typename Handler>
PooledHandler<Handler> make_pooled_handler(Handler handler, HandlerMemoryPool& pool)
{
    return PooledHandler<Handler>(std::move(handler), pool);
}
```

### 15.2.2 세션별 핸들러 풀링
각 세션마다 독립적인 핸들러 풀을 관리하여 메모리 지역성을 향상시킬 수 있다.

```cpp
class Session : public std::enable_shared_from_this<Session>
{
public:
    Session(boost::asio::ip::tcp::socket socket)
        : socket_(std::move(socket)), handler_pool_(512) // 512바이트 블록
    {
    }

    void Start()
    {
        DoRead();
    }

private:
    void DoRead()
    {
        auto self = shared_from_this();
        
        // 커스텀 할당자를 사용하는 핸들러
        socket_.async_read_some(
            boost::asio::buffer(buffer_),
            make_pooled_handler(
                [this, self](const boost::system::error_code& ec, std::size_t length)
                {
                    if (!ec)
                    {
                        ProcessData(length);
                        DoRead();
                    }
                    else
                    {
                        std::cout << "Read error: " << ec.message() << std::endl;
                    }
                },
                handler_pool_
            )
        );
    }

    void ProcessData(std::size_t length)
    {
        // 데이터 처리 로직
        std::cout << "Processed " << length << " bytes" << std::endl;
        
        // Echo back
        DoWrite(length);
    }

    void DoWrite(std::size_t length)
    {
        auto self = shared_from_this();
        
        boost::asio::async_write(
            socket_,
            boost::asio::buffer(buffer_, length),
            make_pooled_handler(
                [this, self](const boost::system::error_code& ec, std::size_t)
                {
                    if (ec)
                    {
                        std::cout << "Write error: " << ec.message() << std::endl;
                    }
                },
                handler_pool_
            )
        );
    }

    boost::asio::ip::tcp::socket socket_;
    std::array<char, 1024> buffer_;
    HandlerMemoryPool handler_pool_;
};

class OptimizedServer
{
public:
    OptimizedServer(boost::asio::io_context& io_context, short port)
        : acceptor_(io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)),
          global_handler_pool_(1024)
    {
        StartAccept();
    }

    void PrintStatistics() const
    {
        global_handler_pool_.PrintStatistics();
    }

private:
    void StartAccept()
    {
        acceptor_.async_accept(
            make_pooled_handler(
                [this](const boost::system::error_code& ec, boost::asio::ip::tcp::socket socket)
                {
                    if (!ec)
                    {
                        std::make_shared<Session>(std::move(socket))->Start();
                    }
                    
                    StartAccept();
                },
                global_handler_pool_
            )
        );
    }

    boost::asio::ip::tcp::acceptor acceptor_;
    HandlerMemoryPool global_handler_pool_;
};

void handler_pooling_example()
{
    boost::asio::io_context io_context;
    OptimizedServer server(io_context, 12345);
    
    std::cout << "Optimized server started on port 12345" << std::endl;
    
    // 통계 출력 타이머
    boost::asio::steady_timer stats_timer(io_context);
    std::function<void()> print_stats = [&]()
    {
        server.PrintStatistics();
        stats_timer.expires_after(std::chrono::seconds(10));
        stats_timer.async_wait([&](const boost::system::error_code&) { print_stats(); });
    };
    print_stats();
    
    io_context.run();
}
```
  
</br>  
  

## 15.3 버퍼 관리 최적화

### 15.3.1 순환 버퍼 구현
순환 버퍼는 고정 크기 메모리를 효율적으로 사용할 수 있는 자료구조이다.

```cpp
template<typename T>
class CircularBuffer
{
public:
    explicit CircularBuffer(size_t capacity)
        : capacity_(capacity), size_(0), head_(0), tail_(0)
    {
        buffer_ = std::make_unique<T[]>(capacity_);
    }

    bool Push(const T& item)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        if (size_ == capacity_)
        {
            return false; // 버퍼 가득 찬 경우
        }

        buffer_[tail_] = item;
        tail_ = (tail_ + 1) % capacity_;
        ++size_;
        
        return true;
    }

    bool Push(T&& item)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        if (size_ == capacity_)
        {
            return false;
        }

        buffer_[tail_] = std::move(item);
        tail_ = (tail_ + 1) % capacity_;
        ++size_;
        
        return true;
    }

    bool Pop(T& item)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        if (size_ == 0)
        {
            return false; // 버퍼 비어있는 경우
        }

        item = std::move(buffer_[head_]);
        head_ = (head_ + 1) % capacity_;
        --size_;
        
        return true;
    }

    bool ForcePush(const T& item)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        buffer_[tail_] = item;
        tail_ = (tail_ + 1) % capacity_;
        
        if (size_ == capacity_)
        {
            // 오버라이트: head 포인터도 이동
            head_ = (head_ + 1) % capacity_;
        }
        else
        {
            ++size_;
        }
        
        return true;
    }

    size_t Size() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return size_;
    }

    size_t Capacity() const
    {
        return capacity_;
    }

    bool Empty() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return size_ == 0;
    }

    bool Full() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return size_ == capacity_;
    }

    void Clear()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        size_ = 0;
        head_ = 0;
        tail_ = 0;
    }

    // 연속된 메모리 영역에 데이터 읽기/쓰기
    size_t ReadData(T* dest, size_t count)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        size_t read_count = std::min(count, size_);
        size_t first_chunk = std::min(read_count, capacity_ - head_);
        size_t second_chunk = read_count - first_chunk;
        
        std::memcpy(dest, buffer_.get() + head_, first_chunk * sizeof(T));
        if (second_chunk > 0)
        {
            std::memcpy(dest + first_chunk, buffer_.get(), second_chunk * sizeof(T));
        }
        
        head_ = (head_ + read_count) % capacity_;
        size_ -= read_count;
        
        return read_count;
    }

    size_t WriteData(const T* src, size_t count)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        size_t write_count = std::min(count, capacity_ - size_);
        size_t first_chunk = std::min(write_count, capacity_ - tail_);
        size_t second_chunk = write_count - first_chunk;
        
        std::memcpy(buffer_.get() + tail_, src, first_chunk * sizeof(T));
        if (second_chunk > 0)
        {
            std::memcpy(buffer_.get(), src + first_chunk, second_chunk * sizeof(T));
        }
        
        tail_ = (tail_ + write_count) % capacity_;
        size_ += write_count;
        
        return write_count;
    }

private:
    std::unique_ptr<T[]> buffer_;
    size_t capacity_;
    size_t size_;
    size_t head_;
    size_t tail_;
    mutable std::mutex mutex_;
};

// 네트워크 버퍼 예제
class NetworkBuffer
{
public:
    explicit NetworkBuffer(size_t capacity = 8192)
        : buffer_(capacity)
    {
    }

    bool WritePacket(const std::vector<char>& packet)
    {
        if (packet.size() > buffer_.Capacity() - buffer_.Size())
        {
            return false; // 공간 부족
        }

        // 패킷 크기 먼저 쓰기
        uint32_t packet_size = static_cast<uint32_t>(packet.size());
        buffer_.WriteData(reinterpret_cast<const char*>(&packet_size), sizeof(packet_size));
        
        // 패킷 데이터 쓰기
        buffer_.WriteData(packet.data(), packet.size());
        
        return true;
    }

    bool ReadPacket(std::vector<char>& packet)
    {
        if (buffer_.Size() < sizeof(uint32_t))
        {
            return false; // 크기 정보가 없음
        }

        // 패킷 크기 읽기
        uint32_t packet_size;
        if (buffer_.ReadData(reinterpret_cast<char*>(&packet_size), sizeof(packet_size)) != sizeof(packet_size))
        {
            return false;
        }

        if (buffer_.Size() < packet_size)
        {
            // 패킷이 완전히 도착하지 않음 - 크기 정보 되돌리기
            // 실제 구현에서는 peek 기능이 필요
            return false;
        }

        // 패킷 데이터 읽기
        packet.resize(packet_size);
        size_t read_bytes = buffer_.ReadData(packet.data(), packet_size);
        
        return read_bytes == packet_size;
    }

    size_t GetBufferedSize() const
    {
        return buffer_.Size();
    }

    bool HasCompletePacket() const
    {
        if (buffer_.Size() < sizeof(uint32_t))
            return false;

        // 첫 번째 패킷의 크기 확인 (peek)
        // 실제로는 peek 기능이 구현되어야 함
        return true; // 간단화
    }

private:
    CircularBuffer<char> buffer_;
};

void circular_buffer_example()
{
    CircularBuffer<int> buffer(5);
    
    std::cout << "Circular buffer test..." << std::endl;
    
    // 데이터 추가
    for (int i = 1; i <= 7; ++i)
    {
        if (buffer.Push(i))
        {
            std::cout << "Pushed: " << i << std::endl;
        }
        else
        {
            std::cout << "Buffer full, cannot push: " << i << std::endl;
        }
    }
    
    std::cout << "Buffer size: " << buffer.Size() << std::endl;
    
    // 데이터 읽기
    int value;
    while (buffer.Pop(value))
    {
        std::cout << "Popped: " << value << std::endl;
    }
    
    // Force push 테스트 (오버라이트)
    std::cout << "Force push test..." << std::endl;
    for (int i = 10; i <= 20; ++i)
    {
        buffer.ForcePush(i);
        std::cout << "Force pushed: " << i << ", buffer size: " << buffer.Size() << std::endl;
    }
    
    // 모든 데이터 읽기
    while (buffer.Pop(value))
    {
        std::cout << "Final pop: " << value << std::endl;
    }
}
```

### 15.3.2 버퍼 풀 관리
여러 크기의 버퍼를 효율적으로 관리하는 버퍼 풀을 구현한다.

```cpp
class BufferPool
{
public:
    explicit BufferPool(const std::vector<size_t>& buffer_sizes)
    {
        for (size_t size : buffer_sizes)
        {
            pools_[size] = std::make_unique<MemoryPool<char>>(100); // 각 크기당 100개 버퍼
            buffer_sizes_.push_back(size);
        }
        
        std::sort(buffer_sizes_.begin(), buffer_sizes_.end());
    }

    std::unique_ptr<char[]> AcquireBuffer(size_t size)
    {
        // 요청된 크기보다 큰 가장 작은 버퍼 크기 찾기
        auto it = std::lower_bound(buffer_sizes_.begin(), buffer_sizes_.end(), size);
        
        if (it != buffer_sizes_.end())
        {
            size_t pool_size = *it;
            auto& pool = pools_[pool_size];
            
            std::lock_guard<std::mutex> lock(mutex_);
            
            char* buffer = pool->Allocate();
            if (buffer)
            {
                allocated_buffers_[buffer] = pool_size;
                return std::unique_ptr<char[]>(buffer);
            }
        }
        
        // 풀에서 할당 실패 시 일반 할당
        ++fallback_allocations_;
        return std::make_unique<char[]>(size);
    }

    void ReturnBuffer(std::unique_ptr<char[]> buffer)
    {
        char* raw_ptr = buffer.release();
        
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto it = allocated_buffers_.find(raw_ptr);
        if (it != allocated_buffers_.end())
        {
            size_t pool_size = it->second;
            pools_[pool_size]->Deallocate(raw_ptr);
            allocated_buffers_.erase(it);
        }
        else
        {
            // 일반 할당된 버퍼는 자동 해제
            delete[] raw_ptr;
            --fallback_allocations_;
        }
    }

    void PrintStatistics() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        std::cout << "Buffer Pool Statistics:" << std::endl;
        std::cout << "- Pool sizes: ";
        for (size_t size : buffer_sizes_)
        {
            std::cout << size << " ";
        }
        std::cout << std::endl;
        
        for (const auto& pair : pools_)
        {
            std::cout << "- Pool " << pair.first << " bytes: " 
                     << pair.second->GetAllocatedCount() << " allocated" << std::endl;
        }
        
        std::cout << "- Fallback allocations: " << fallback_allocations_ << std::endl;
        std::cout << "- Active buffers: " << allocated_buffers_.size() << std::endl;
    }

private:
    std::unordered_map<size_t, std::unique_ptr<MemoryPool<char>>> pools_;
    std::vector<size_t> buffer_sizes_;
    std::unordered_map<char*, size_t> allocated_buffers_;
    std::atomic<size_t> fallback_allocations_{0};
    mutable std::mutex mutex_;
};

// RAII 버퍼 래퍼
class ManagedBuffer
{
public:
    ManagedBuffer(std::unique_ptr<char[]> buffer, size_t size, BufferPool& pool)
        : buffer_(std::move(buffer)), size_(size), pool_(&pool)
    {
    }

    ~ManagedBuffer()
    {
        if (buffer_ && pool_)
        {
            pool_->ReturnBuffer(std::move(buffer_));
        }
    }

    // 이동 생성자
    ManagedBuffer(ManagedBuffer&& other) noexcept
        : buffer_(std::move(other.buffer_)), size_(other.size_), pool_(other.pool_)
    {
        other.pool_ = nullptr;
    }

    // 이동 대입 연산자
    ManagedBuffer& operator=(ManagedBuffer&& other) noexcept
    {
        if (this != &other)
        {
            if (buffer_ && pool_)
            {
                pool_->ReturnBuffer(std::move(buffer_));
            }
            
            buffer_ = std::move(other.buffer_);
            size_ = other.size_;
            pool_ = other.pool_;
            other.pool_ = nullptr;
        }
        return *this;
    }

    // 복사 생성자와 복사 대입 연산자 삭제
    ManagedBuffer(const ManagedBuffer&) = delete;
    ManagedBuffer& operator=(const ManagedBuffer&) = delete;

    char* Data() { return buffer_.get(); }
    const char* Data() const { return buffer_.get(); }
    size_t Size() const { return size_; }

    // 버퍼 소유권 해제
    std::unique_ptr<char[]> Release()
    {
        pool_ = nullptr;
        return std::move(buffer_);
    }

private:
    std::unique_ptr<char[]> buffer_;
    size_t size_;
    BufferPool* pool_;
};

class BufferManager
{
public:
    BufferManager()
        : buffer_pool_({64, 128, 256, 512, 1024, 2048, 4096, 8192})
    {
    }

    ManagedBuffer GetBuffer(size_t size)
    {
        auto buffer = buffer_pool_.AcquireBuffer(size);
        return ManagedBuffer(std::move(buffer), size, buffer_pool_);
    }

    void PrintStatistics() const
    {
        buffer_pool_.PrintStatistics();
    }

private:
    BufferPool buffer_pool_;
};

void buffer_pool_example()
{
    BufferManager buffer_manager;
    
    std::cout << "Buffer pool test..." << std::endl;
    
    std::vector<ManagedBuffer> buffers;
    
    // 다양한 크기의 버퍼 할당
    std::vector<size_t> sizes = {100, 300, 600, 1200, 2500, 5000};
    
    for (size_t size : sizes)
    {
        for (int i = 0; i < 10; ++i)
        {
            auto buffer = buffer_manager.GetBuffer(size);
            
            // 버퍼 사용 시뮬레이션
            std::memset(buffer.Data(), i, size);
            
            buffers.push_back(std::move(buffer));
        }
    }
    
    buffer_manager.PrintStatistics();
    
    // 일부 버퍼 해제
    buffers.erase(buffers.begin() + 10, buffers.begin() + 30);
    
    std::cout << "After partial release:" << std::endl;
    buffer_manager.PrintStatistics();
    
    // 모든 버퍼 해제
    buffers.clear();
    
    std::cout << "After full release:" << std::endl;
    buffer_manager.PrintStatistics();
}
```
  
</br>
   
## 15.4 메모리 누수 방지

### 15.4.1 스마트 포인터 활용
RAII 패턴과 스마트 포인터를 활용하여 메모리 누수를 방지한다.

```cpp
#include <memory>
#include <unordered_map>
#include <weak_ptr>

// 게임 오브젝트 관리자
class GameObjectManager
{
public:
    using GameObjectPtr = std::shared_ptr<GameObject>;
    using GameObjectWeakPtr = std::weak_ptr<GameObject>;

    GameObjectPtr CreateGameObject()
    {
        auto obj = std::make_shared<GameObject>();
        uint32_t id = obj->GetId();
        
        objects_[id] = obj;
        
        // 약한 참조로 정리 목록에 추가
        cleanup_list_.push_back(obj);
        
        std::cout << "Created GameObject " << id << std::endl;
        return obj;
    }

    GameObjectPtr GetGameObject(uint32_t id)
    {
        auto it = objects_.find(id);
        return (it != objects_.end()) ? it->second : nullptr;
    }

    void RemoveGameObject(uint32_t id)
    {
        auto it = objects_.find(id);
        if (it != objects_.end())
        {
            std::cout << "Removing GameObject " << id << std::endl;
            objects_.erase(it);
        }
    }

    void CleanupExpiredObjects()
    {
        cleanup_list_.erase(
            std::remove_if(cleanup_list_.begin(), cleanup_list_.end(),
                [this](const GameObjectWeakPtr& weak_obj)
                {
                    if (auto obj = weak_obj.lock())
                    {
                        // 객체가 여전히 존재하면 유지
                        return false;
                    }
                    else
                    {
                        // 객체가 소멸되었으면 정리
                        return true;
                    }
                }),
            cleanup_list_.end());
    }

    size_t GetObjectCount() const
    {
        return objects_.size();
    }

    void PrintStatistics() const
    {
        std::cout << "GameObjectManager Statistics:" << std::endl;
        std::cout << "- Active objects: " << objects_.size() << std::endl;
        std::cout << "- Cleanup list size: " << cleanup_list_.size() << std::endl;
        
        // 약한 참조 중 유효한 것 계산
        size_t valid_weak_refs = 0;
        for (const auto& weak_obj : cleanup_list_)
        {
            if (!weak_obj.expired())
                ++valid_weak_refs;
        }
        std::cout << "- Valid weak references: " << valid_weak_refs << std::endl;
    }

private:
    std::unordered_map<uint32_t, GameObjectPtr> objects_;
    std::vector<GameObjectWeakPtr> cleanup_list_;
};

// 리소스 관리자 (RAII 패턴)
template<typename Resource, typename Deleter = std::default_delete<Resource>>
class ResourceManager
{
public:
    using ResourcePtr = std::unique_ptr<Resource, Deleter>;

    class ResourceHandle
    {
    public:
        ResourceHandle() = default;
        
        ResourceHandle(ResourcePtr resource, ResourceManager& manager, uint32_t id)
            : resource_(std::move(resource)), manager_(&manager), id_(id)
        {
        }

        ~ResourceHandle()
        {
            if (resource_ && manager_)
            {
                manager_->ReturnResource(id_, std::move(resource_));
            }
        }

        // 이동 생성자
        ResourceHandle(ResourceHandle&& other) noexcept
            : resource_(std::move(other.resource_)), manager_(other.manager_), id_(other.id_)
        {
            other.manager_ = nullptr;
        }

        // 이동 대입 연산자
        ResourceHandle& operator=(ResourceHandle&& other) noexcept
        {
            if (this != &other)
            {
                if (resource_ && manager_)
                {
                    manager_->ReturnResource(id_, std::move(resource_));
                }
                
                resource_ = std::move(other.resource_);
                manager_ = other.manager_;
                id_ = other.id_;
                other.manager_ = nullptr;
            }
            return *this;
        }

        // 복사 금지
        ResourceHandle(const ResourceHandle&) = delete;
        ResourceHandle& operator=(const ResourceHandle&) = delete;

        Resource* Get() const { return resource_.get(); }
        Resource* operator->() const { return resource_.get(); }
        Resource& operator*() const { return *resource_; }
        bool IsValid() const { return resource_ != nullptr; }

    private:
        ResourcePtr resource_;
        ResourceManager* manager_ = nullptr;
        uint32_t id_ = 0;
    };

    template<typename... Args>
    ResourceHandle CreateResource(Args&&... args)
    {
        uint32_t id = next_id_++;
        auto resource = std::make_unique<Resource>(std::forward<Args>(args)...);
        
        std::cout << "Created resource " << id << std::endl;
        return ResourceHandle(std::move(resource), *this, id);
    }

    void PrintStatistics() const
    {
        std::cout << "ResourceManager Statistics:" << std::endl;
        std::cout << "- Next ID: " << next_id_ << std::endl;
        std::cout << "- Cached resources: " << resource_cache_.size() << std::endl;
    }

private:
    void ReturnResource(uint32_t id, ResourcePtr resource)
    {
        std::cout << "Returned resource " << id << std::endl;
        
        // 리소스를 캐시에 저장하여 재사용
        std::lock_guard<std::mutex> lock(cache_mutex_);
        if (resource_cache_.size() < max_cache_size_)
        {
            resource_cache_.push_back(std::move(resource));
        }
        // 캐시가 가득 찬 경우 자동 해제
    }

    std::atomic<uint32_t> next_id_{1};
    std::vector<ResourcePtr> resource_cache_;
    std::mutex cache_mutex_;
    static const size_t max_cache_size_ = 100;
    
    friend class ResourceHandle;
};

void smart_pointer_example()
{
    std::cout << "Smart pointer memory management test..." << std::endl;
    
    GameObjectManager obj_manager;
    ResourceManager<std::vector<int>> resource_manager;
    
    {
        // 게임 오브젝트 생성
        auto obj1 = obj_manager.CreateGameObject();
        auto obj2 = obj_manager.CreateGameObject();
        auto obj3 = obj_manager.CreateGameObject();
        
        obj_manager.PrintStatistics();
        
        // 리소스 생성
        {
            auto resource1 = resource_manager.CreateResource(1000, 42);
            auto resource2 = resource_manager.CreateResource(500, 24);
            
            resource_manager.PrintStatistics();
            
            // resource1, resource2는 스코프 종료 시 자동 해제
        }
        
        resource_manager.PrintStatistics();
        
        // 일부 객체 제거
        obj_manager.RemoveGameObject(obj2->GetId());
        
        // obj1, obj2, obj3는 스코프 종료 시 자동 해제
    }
    
    std::cout << "After scope exit:" << std::endl;
    obj_manager.PrintStatistics();
    obj_manager.CleanupExpiredObjects();
    obj_manager.PrintStatistics();
}
```

### 15.4.2 메모리 추적 시스템
메모리 할당을 추적하여 누수를 감지하는 시스템을 구현한다.

```cpp
#include <unordered_set>
#include <thread>
#include <stack>

class MemoryTracker
{
public:
    struct AllocationInfo
    {
        size_t size;
        const char* file;
        int line;
        std::thread::id thread_id;
        std::chrono::steady_clock::time_point timestamp;
        std::vector<void*> stack_trace; // 실제로는 스택 트레이스 구현 필요
    };

    static MemoryTracker& Instance()
    {
        static MemoryTracker instance;
        return instance;
    }

    void RecordAllocation(void* ptr, size_t size, const char* file, int line)
    {
        if (!tracking_enabled_)
            return;

        std::lock_guard<std::mutex> lock(mutex_);
        
        AllocationInfo info;
        info.size = size;
        info.file = file;
        info.line = line;
        info.thread_id = std::this_thread::get_id();
        info.timestamp = std::chrono::steady_clock::now();
        
        allocations_[ptr] = info;
        total_allocated_ += size;
        ++allocation_count_;
        
        if (allocation_count_ % 1000 == 0)
        {
            std::cout << "Memory tracking: " << allocation_count_ 
                     << " allocations, " << total_allocated_ << " bytes" << std::endl;
        }
    }

    void RecordDeallocation(void* ptr)
    {
        if (!tracking_enabled_ || !ptr)
            return;

        std::lock_guard<std::mutex> lock(mutex_);
        
        auto it = allocations_.find(ptr);
        if (it != allocations_.end())
        {
            total_allocated_ -= it->second.size;
            allocations_.erase(it);
            ++deallocation_count_;
        }
        else
        {
            ++invalid_deallocations_;
            std::cerr << "Warning: Deallocating untracked pointer " << ptr << std::endl;
        }
    }

    void PrintLeakReport() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        std::cout << "\n=== Memory Leak Report ===" << std::endl;
        std::cout << "Total allocations: " << allocation_count_ << std::endl;
        std::cout << "Total deallocations: " << deallocation_count_ << std::endl;
        std::cout << "Invalid deallocations: " << invalid_deallocations_ << std::endl;
        std::cout << "Leaked allocations: " << allocations_.size() << std::endl;
        std::cout << "Leaked bytes: " << total_allocated_ << std::endl;
        
        if (!allocations_.empty())
        {
            std::cout << "\nLeak details:" << std::endl;
            size_t count = 0;
            for (const auto& pair : allocations_)
            {
                const auto& info = pair.second;
                std::cout << "- " << pair.first << ": " << info.size 
                         << " bytes at " << info.file << ":" << info.line << std::endl;
                
                if (++count >= 10) // 최대 10개만 출력
                {
                    std::cout << "... and " << (allocations_.size() - count) << " more" << std::endl;
                    break;
                }
            }
        }
        std::cout << "========================\n" << std::endl;
    }

    void EnableTracking(bool enable = true)
    {
        tracking_enabled_ = enable;
    }

    bool IsTrackingEnabled() const
    {
        return tracking_enabled_;
    }

    void Clear()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        allocations_.clear();
        total_allocated_ = 0;
        allocation_count_ = 0;
        deallocation_count_ = 0;
        invalid_deallocations_ = 0;
    }

private:
    std::unordered_map<void*, AllocationInfo> allocations_;
    size_t total_allocated_ = 0;
    size_t allocation_count_ = 0;
    size_t deallocation_count_ = 0;
    size_t invalid_deallocations_ = 0;
    bool tracking_enabled_ = true;
    mutable std::mutex mutex_;
};

// 디버그 빌드에서만 추적하는 new/delete 오버로드
#ifdef _DEBUG
void* operator new(size_t size, const char* file, int line)
{
    void* ptr = std::malloc(size);
    if (ptr)
    {
        MemoryTracker::Instance().RecordAllocation(ptr, size, file, line);
    }
    return ptr;
}

void operator delete(void* ptr, const char* file, int line) noexcept
{
    MemoryTracker::Instance().RecordDeallocation(ptr);
    std::free(ptr);
}

void operator delete(void* ptr) noexcept
{
    MemoryTracker::Instance().RecordDeallocation(ptr);
    std::free(ptr);
}

#define TRACKED_NEW new(__FILE__, __LINE__)
#define TRACKED_DELETE delete

#else
#define TRACKED_NEW new
#define TRACKED_DELETE delete
#endif

// 자동 메모리 추적을 위한 클래스
class MemoryLeakDetector
{
public:
    MemoryLeakDetector()
    {
        MemoryTracker::Instance().EnableTracking(true);
        MemoryTracker::Instance().Clear();
        std::cout << "Memory leak detection started" << std::endl;
    }

    ~MemoryLeakDetector()
    {
        std::cout << "Memory leak detection finished" << std::endl;
        MemoryTracker::Instance().PrintLeakReport();
    }
};

// 테스트용 클래스
class TestClass
{
public:
    TestClass(size_t size) : data_(new char[size]), size_(size)
    {
        std::memset(data_, 0, size_);
    }

    ~TestClass()
    {
        delete[] data_;
    }

private:
    char* data_;
    size_t size_;
};

void memory_leak_detection_example()
{
    MemoryLeakDetector detector;
    
    std::cout << "Testing memory leak detection..." << std::endl;
    
    // 정상적인 할당/해제
    {
        auto obj1 = std::make_unique<TestClass>(1024);
        auto obj2 = std::make_unique<TestClass>(2048);
        // 스코프 종료 시 자동 해제
    }
    
    // 메모리 누수 시뮬레이션
    TestClass* leaked_obj = TRACKED_NEW TestClass(4096);
    char* leaked_array = TRACKED_NEW char[8192];
    
    // 의도적으로 해제하지 않음
    std::cout << "Created objects that will leak..." << std::endl;
    
    // detector 소멸자에서 누수 리포트 출력
}
```

### 15.4.3 약한 참조 기반 관찰자 패턴
순환 참조를 방지하는 안전한 관찰자 패턴을 구현한다.

```cpp
template<typename T>
class Observable
{
public:
    class Observer
    {
    public:
        virtual ~Observer() = default;
        virtual void OnNotify(const T& data) = 0;
    };

    void AddObserver(std::weak_ptr<Observer> observer)
    {
        std::lock_guard<std::mutex> lock(observers_mutex_);
        observers_.push_back(observer);
    }

    void RemoveObserver(std::shared_ptr<Observer> observer)
    {
        std::lock_guard<std::mutex> lock(observers_mutex_);
        
        observers_.erase(
            std::remove_if(observers_.begin(), observers_.end(),
                [&observer](const std::weak_ptr<Observer>& weak_obs)
                {
                    return weak_obs.lock() == observer;
                }),
            observers_.end());
    }

    void NotifyObservers(const T& data)
    {
        std::vector<std::shared_ptr<Observer>> active_observers;
        
        {
            std::lock_guard<std::mutex> lock(observers_mutex_);
            
            // 만료된 약한 참조 제거 및 활성 관찰자 수집
            observers_.erase(
                std::remove_if(observers_.begin(), observers_.end(),
                    [&active_observers](const std::weak_ptr<Observer>& weak_obs)
                    {
                        if (auto obs = weak_obs.lock())
                        {
                            active_observers.push_back(obs);
                            return false;
                        }
                        return true; // 만료된 참조 제거
                    }),
                observers_.end());
        }
        
        // 뮤텍스 없이 알림 전송 (데드락 방지)
        for (auto& observer : active_observers)
        {
            try
            {
                observer->OnNotify(data);
            }
            catch (const std::exception& e)
            {
                std::cerr << "Observer notification error: " << e.what() << std::endl;
            }
        }
    }

    size_t GetObserverCount() const
    {
        std::lock_guard<std::mutex> lock(observers_mutex_);
        return observers_.size();
    }

private:
    std::vector<std::weak_ptr<Observer>> observers_;
    mutable std::mutex observers_mutex_;
};

// 게임 이벤트 시스템 예제
struct GameEvent
{
    enum Type { PLAYER_JOINED, PLAYER_LEFT, PLAYER_MOVED, ITEM_PICKUP };
    
    Type type;
    uint32_t player_id;
    std::string data;
};

class GameEventSystem : public Observable<GameEvent>
{
public:
    void PlayerJoined(uint32_t player_id, const std::string& player_name)
    {
        GameEvent event{GameEvent::PLAYER_JOINED, player_id, player_name};
        NotifyObservers(event);
    }

    void PlayerLeft(uint32_t player_id)
    {
        GameEvent event{GameEvent::PLAYER_LEFT, player_id, ""};
        NotifyObservers(event);
    }

    void PlayerMoved(uint32_t player_id, const std::string& position)
    {
        GameEvent event{GameEvent::PLAYER_MOVED, player_id, position};
        NotifyObservers(event);
    }
};

class GameLogger : public Observable<GameEvent>::Observer
{
public:
    void OnNotify(const GameEvent& event) override
    {
        switch (event.type)
        {
        case GameEvent::PLAYER_JOINED:
            std::cout << "LOG: Player " << event.player_id 
                     << " (" << event.data << ") joined" << std::endl;
            break;
        case GameEvent::PLAYER_LEFT:
            std::cout << "LOG: Player " << event.player_id << " left" << std::endl;
            break;
        case GameEvent::PLAYER_MOVED:
            std::cout << "LOG: Player " << event.player_id 
                     << " moved to " << event.data << std::endl;
            break;
        default:
            break;
        }
    }
};

class GameStatistics : public Observable<GameEvent>::Observer
{
public:
    void OnNotify(const GameEvent& event) override
    {
        switch (event.type)
        {
        case GameEvent::PLAYER_JOINED:
            ++active_players_;
            std::cout << "STATS: Active players: " << active_players_ << std::endl;
            break;
        case GameEvent::PLAYER_LEFT:
            --active_players_;
            std::cout << "STATS: Active players: " << active_players_ << std::endl;
            break;
        default:
            break;
        }
    }

private:
    int active_players_ = 0;
};

void observer_pattern_example()
{
    std::cout << "Observer pattern memory safety test..." << std::endl;
    
    GameEventSystem event_system;
    
    {
        auto logger = std::make_shared<GameLogger>();
        auto stats = std::make_shared<GameStatistics>();
        
        // 관찰자 등록 (약한 참조로)
        event_system.AddObserver(logger);
        event_system.AddObserver(stats);
        
        std::cout << "Observers registered: " << event_system.GetObserverCount() << std::endl;
        
        // 이벤트 발생
        event_system.PlayerJoined(1001, "Alice");
        event_system.PlayerJoined(1002, "Bob");
        event_system.PlayerMoved(1001, "100,200,300");
        event_system.PlayerLeft(1002);
        
        std::cout << "Active observers: " << event_system.GetObserverCount() << std::endl;
        
        // 스코프 종료 시 logger, stats 자동 해제
    }
    
    std::cout << "After observer destruction:" << std::endl;
    
    // 만료된 관찰자들에게 알림 (자동으로 정리됨)
    event_system.PlayerJoined(1003, "Charlie");
    
    std::cout << "Observers after cleanup: " << event_system.GetObserverCount() << std::endl;
}
```
  
</br>
  

## 정리
이번 장에서는 게임 서버의 메모리 최적화를 위한 다양한 기법을 살펴보았다. 주요 내용을 요약하면:

1. **커스텀 할당자 구현**: 메모리 풀, 스택 할당자, 슬랩 할당자를 통해 동적 할당의 오버헤드를 줄이고 메모리 사용을 최적화했다.

2. **핸들러 메모리 풀링**: Boost.Asio 핸들러의 메모리 할당을 최적화하여 네트워크 성능을 향상시켰다.

3. **버퍼 관리 최적화**: 순환 버퍼와 버퍼 풀을 통해 네트워크 데이터 처리의 효율성을 높였다.

4. **메모리 누수 방지**: 스마트 포인터, 메모리 추적 시스템, 안전한 관찰자 패턴을 통해 메모리 누수를 방지하고 안전한 메모리 관리를 구현했다.

이러한 메모리 최적화 기법들은 대용량 게임 서버에서 안정적이고 효율적인 메모리 관리를 가능하게 하며, 서버의 성능과 안정성을 크게 향상시킬 수 있다. 다음 장에서는 패킷 처리, 연결 관리 등 고성능 서버 기법에 대해 학습하겠다.


