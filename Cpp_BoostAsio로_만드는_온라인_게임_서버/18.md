# workingBooks  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
   
# Chapter 18. 프로토콜 설계와 직렬화
효율적인 네트워크 통신을 위한 프로토콜 설계와 직렬화는 게임 서버 성능의 핵심 요소이다. 이번 장에서는 게임에 최적화된 프로토콜 설계 원칙부터 고정 길이 패킷 처리, Protocol Buffers 활용, 그리고 커스텀 직렬화 구현까지 다양한 기법을 학습한다.

## 18.1 게임 프로토콜 설계 원칙

### 18.1.1 프로토콜 설계 기본 원칙
게임 프로토콜 설계 시 고려해야 할 핵심 원칙들을 살펴보겠다.

```cpp
#include <boost/asio.hpp>
#include <cstdint>
#include <vector>
#include <string>
#include <chrono>
#include <unordered_map>

// 게임 프로토콜 기본 헤더
#pragma pack(push, 1)
struct GamePacketHeader
{
    uint16_t packet_size;      // 전체 패킷 크기 (헤더 포함)
    uint16_t packet_type;      // 패킷 타입 ID
    uint32_t sequence_number;  // 순서 번호 (신뢰성/중복 제거용)
    uint32_t timestamp;        // 타임스탬프 (지연 측정용)
    uint16_t checksum;         // 체크섬 (무결성 검증용)
    uint8_t  flags;           // 플래그 (압축, 암호화 등)
    uint8_t  reserved;        // 예약 필드

    // 기본 생성자
    GamePacketHeader()
        : packet_size(sizeof(GamePacketHeader)), packet_type(0), 
          sequence_number(0), timestamp(0), checksum(0), flags(0), reserved(0)
    {
    }

    // 패킷 타입과 데이터 크기로 초기화
    GamePacketHeader(uint16_t type, size_t data_size)
        : packet_size(sizeof(GamePacketHeader) + static_cast<uint16_t>(data_size)),
          packet_type(type), sequence_number(0), 
          timestamp(static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::milliseconds>(
              std::chrono::steady_clock::now().time_since_epoch()).count())),
          checksum(0), flags(0), reserved(0)
    {
    }

    // 체크섬 계산
    void CalculateChecksum(const uint8_t* data, size_t data_size)
    {
        uint32_t sum = 0;
        
        // 헤더 체크섬 (checksum 필드 제외)
        const uint8_t* header_ptr = reinterpret_cast<const uint8_t*>(this);
        for (size_t i = 0; i < offsetof(GamePacketHeader, checksum); ++i)
        {
            sum += header_ptr[i];
        }
        for (size_t i = offsetof(GamePacketHeader, checksum) + sizeof(checksum); 
             i < sizeof(GamePacketHeader); ++i)
        {
            sum += header_ptr[i];
        }
        
        // 데이터 체크섬
        for (size_t i = 0; i < data_size; ++i)
        {
            sum += data[i];
        }
        
        checksum = static_cast<uint16_t>(sum & 0xFFFF);
    }

    // 체크섬 검증
    bool VerifyChecksum(const uint8_t* data, size_t data_size) const
    {
        GamePacketHeader temp = *this;
        temp.checksum = 0;
        temp.CalculateChecksum(data, data_size);
        return temp.checksum == checksum;
    }
};
#pragma pack(pop)

// 패킷 타입 정의
enum class GamePacketType : uint16_t
{
    // 연결 관리
    CONNECT_REQUEST = 1,
    CONNECT_RESPONSE = 2,
    DISCONNECT = 3,
    PING = 4,
    PONG = 5,
    
    // 인증
    LOGIN_REQUEST = 10,
    LOGIN_RESPONSE = 11,
    LOGOUT = 12,
    
    // 플레이어 액션
    PLAYER_MOVE = 20,
    PLAYER_ATTACK = 21,
    PLAYER_SKILL = 22,
    PLAYER_CHAT = 23,
    
    // 게임 상태
    GAME_STATE_UPDATE = 30,
    PLAYER_JOIN = 31,
    PLAYER_LEAVE = 32,
    
    // 오류 처리
    ERROR_RESPONSE = 100,
    
    // 커스텀 범위 (1000~)
    CUSTOM_START = 1000
};

// 패킷 플래그
enum class PacketFlags : uint8_t
{
    NONE = 0x00,
    COMPRESSED = 0x01,
    ENCRYPTED = 0x02,
    FRAGMENTED = 0x04,
    RELIABLE = 0x08,
    PRIORITY_HIGH = 0x10,
    PRIORITY_LOW = 0x20
};

// 게임 패킷 기본 클래스
class GamePacket
{
public:
    GamePacket(GamePacketType type) : header_(static_cast<uint16_t>(type), 0) {}
    virtual ~GamePacket() = default;

    // 순수 가상 함수들
    virtual std::vector<uint8_t> Serialize() const = 0;
    virtual bool Deserialize(const std::vector<uint8_t>& data) = 0;
    virtual size_t GetDataSize() const = 0;

    // 헤더 접근자
    const GamePacketHeader& GetHeader() const { return header_; }
    GamePacketHeader& GetHeader() { return header_; }

    // 패킷 유효성 검사
    virtual bool IsValid() const { return true; }

    // 우선순위 설정
    void SetPriority(bool high_priority)
    {
        if (high_priority)
        {
            header_.flags |= static_cast<uint8_t>(PacketFlags::PRIORITY_HIGH);
            header_.flags &= ~static_cast<uint8_t>(PacketFlags::PRIORITY_LOW);
        }
        else
        {
            header_.flags |= static_cast<uint8_t>(PacketFlags::PRIORITY_LOW);
            header_.flags &= ~static_cast<uint8_t>(PacketFlags::PRIORITY_HIGH);
        }
    }

    // 신뢰성 설정
    void SetReliable(bool reliable)
    {
        if (reliable)
            header_.flags |= static_cast<uint8_t>(PacketFlags::RELIABLE);
        else
            header_.flags &= ~static_cast<uint8_t>(PacketFlags::RELIABLE);
    }

protected:
    GamePacketHeader header_;
};

// 프로토콜 버전 관리
class ProtocolVersion
{
public:
    static constexpr uint16_t MAJOR = 1;
    static constexpr uint16_t MINOR = 0;
    static constexpr uint16_t PATCH = 0;

    static uint32_t GetVersion()
    {
        return (static_cast<uint32_t>(MAJOR) << 16) | 
               (static_cast<uint32_t>(MINOR) << 8) | 
               static_cast<uint32_t>(PATCH);
    }

    static bool IsCompatible(uint32_t other_version)
    {
        uint16_t other_major = (other_version >> 16) & 0xFFFF;
        uint16_t other_minor = (other_version >> 8) & 0xFF;
        
        // 메이저 버전이 같고, 마이너 버전이 이하인 경우 호환
        return (other_major == MAJOR) && (other_minor <= MINOR);
    }

    static std::string GetVersionString()
    {
        return std::to_string(MAJOR) + "." + 
               std::to_string(MINOR) + "." + 
               std::to_string(PATCH);
    }
};

// 프로토콜 관리자
class ProtocolManager
{
public:
    // 패킷 생성 팩토리
    using PacketFactory = std::function<std::unique_ptr<GamePacket>()>;

    static ProtocolManager& Instance()
    {
        static ProtocolManager instance;
        return instance;
    }

    void RegisterPacketType(GamePacketType type, PacketFactory factory)
    {
        packet_factories_[type] = factory;
    }

    std::unique_ptr<GamePacket> CreatePacket(GamePacketType type)
    {
        auto it = packet_factories_.find(type);
        if (it != packet_factories_.end())
        {
            return it->second();
        }
        return nullptr;
    }

    bool IsValidPacketType(GamePacketType type) const
    {
        return packet_factories_.find(type) != packet_factories_.end();
    }

    void PrintRegisteredTypes() const
    {
        std::cout << "Registered packet types:" << std::endl;
        for (const auto& pair : packet_factories_)
        {
            std::cout << "- " << static_cast<uint16_t>(pair.first) << std::endl;
        }
    }

private:
    std::unordered_map<GamePacketType, PacketFactory> packet_factories_;
};

// 연결 요청 패킷 예제
class ConnectRequestPacket : public GamePacket
{
public:
    ConnectRequestPacket() : GamePacket(GamePacketType::CONNECT_REQUEST) {}

    std::string client_version;
    uint32_t client_id;
    std::string username;

    std::vector<uint8_t> Serialize() const override
    {
        std::vector<uint8_t> data;
        
        // 클라이언트 버전 길이 + 데이터
        uint16_t version_len = static_cast<uint16_t>(client_version.length());
        data.insert(data.end(), reinterpret_cast<const uint8_t*>(&version_len), 
                   reinterpret_cast<const uint8_t*>(&version_len) + sizeof(version_len));
        data.insert(data.end(), client_version.begin(), client_version.end());
        
        // 클라이언트 ID
        data.insert(data.end(), reinterpret_cast<const uint8_t*>(&client_id),
                   reinterpret_cast<const uint8_t*>(&client_id) + sizeof(client_id));
        
        // 사용자명 길이 + 데이터
        uint16_t username_len = static_cast<uint16_t>(username.length());
        data.insert(data.end(), reinterpret_cast<const uint8_t*>(&username_len),
                   reinterpret_cast<const uint8_t*>(&username_len) + sizeof(username_len));
        data.insert(data.end(), username.begin(), username.end());
        
        return data;
    }

    bool Deserialize(const std::vector<uint8_t>& data) override
    {
        if (data.size() < sizeof(uint16_t) + sizeof(uint32_t) + sizeof(uint16_t))
            return false;

        size_t offset = 0;
        
        // 클라이언트 버전
        uint16_t version_len;
        std::memcpy(&version_len, data.data() + offset, sizeof(version_len));
        offset += sizeof(version_len);
        
        if (offset + version_len > data.size())
            return false;
            
        client_version.assign(data.begin() + offset, data.begin() + offset + version_len);
        offset += version_len;
        
        // 클라이언트 ID
        std::memcpy(&client_id, data.data() + offset, sizeof(client_id));
        offset += sizeof(client_id);
        
        // 사용자명
        uint16_t username_len;
        std::memcpy(&username_len, data.data() + offset, sizeof(username_len));
        offset += sizeof(username_len);
        
        if (offset + username_len > data.size())
            return false;
            
        username.assign(data.begin() + offset, data.begin() + offset + username_len);
        
        return true;
    }

    size_t GetDataSize() const override
    {
        return sizeof(uint16_t) + client_version.length() + 
               sizeof(uint32_t) + 
               sizeof(uint16_t) + username.length();
    }

    bool IsValid() const override
    {
        return !client_version.empty() && !username.empty() && 
               username.length() <= 32; // 사용자명 길이 제한
    }
};

void protocol_design_example()
{
    std::cout << "Protocol Design Example" << std::endl;
    std::cout << "Protocol Version: " << ProtocolVersion::GetVersionString() << std::endl;
    
    // 프로토콜 매니저에 패킷 타입 등록
    auto& protocol_mgr = ProtocolManager::Instance();
    protocol_mgr.RegisterPacketType(GamePacketType::CONNECT_REQUEST, 
        []() { return std::make_unique<ConnectRequestPacket>(); });
    
    // 연결 요청 패킷 생성 및 테스트
    auto connect_packet = std::make_unique<ConnectRequestPacket>();
    connect_packet->client_version = ProtocolVersion::GetVersionString();
    connect_packet->client_id = 12345;
    connect_packet->username = "testuser";
    connect_packet->SetPriority(true);
    connect_packet->SetReliable(true);
    
    if (connect_packet->IsValid())
    {
        auto serialized = connect_packet->Serialize();
        std::cout << "Serialized packet size: " << serialized.size() << " bytes" << std::endl;
        
        // 헤더 업데이트
        connect_packet->GetHeader().packet_size = 
            sizeof(GamePacketHeader) + static_cast<uint16_t>(serialized.size());
        connect_packet->GetHeader().CalculateChecksum(serialized.data(), serialized.size());
        
        std::cout << "Total packet size: " << connect_packet->GetHeader().packet_size << " bytes" << std::endl;
        std::cout << "Checksum: 0x" << std::hex << connect_packet->GetHeader().checksum << std::dec << std::endl;
        
        // 역직렬화 테스트
        auto test_packet = std::make_unique<ConnectRequestPacket>();
        if (test_packet->Deserialize(serialized))
        {
            std::cout << "Deserialization successful:" << std::endl;
            std::cout << "- Client version: " << test_packet->client_version << std::endl;
            std::cout << "- Client ID: " << test_packet->client_id << std::endl;
            std::cout << "- Username: " << test_packet->username << std::endl;
        }
    }
    
    protocol_mgr.PrintRegisteredTypes();
}
```

### 19.1.2 패킷 압축과 최적화
네트워크 대역폭 절약을 위한 패킷 압축 기법을 구현한다.  

```cpp
#include <zlib.h>
#include <algorithm>

// 압축 유틸리티
class CompressionUtils
{
public:
    // zlib을 사용한 압축
    static std::vector<uint8_t> Compress(const std::vector<uint8_t>& data, int level = Z_DEFAULT_COMPRESSION)
    {
        if (data.empty())
            return {};

        z_stream zs;
        memset(&zs, 0, sizeof(zs));

        if (deflateInit(&zs, level) != Z_OK)
            throw std::runtime_error("deflateInit failed");

        zs.next_in = const_cast<Bytef*>(data.data());
        zs.avail_in = static_cast<uInt>(data.size());

        int ret;
        std::vector<uint8_t> compressed_data;
        std::array<uint8_t, 32768> temp_buffer;

        do {
            zs.next_out = temp_buffer.data();
            zs.avail_out = static_cast<uInt>(temp_buffer.size());

            ret = deflate(&zs, Z_FINISH);

            if (compressed_data.size() < zs.total_out) {
                compressed_data.insert(compressed_data.end(),
                                     temp_buffer.begin(),
                                     temp_buffer.begin() + zs.total_out - compressed_data.size());
            }
        } while (ret == Z_OK);

        deflateEnd(&zs);

        if (ret != Z_STREAM_END)
            throw std::runtime_error("Exception during zlib compression");

        return compressed_data;
    }

    // zlib을 사용한 압축 해제
    static std::vector<uint8_t> Decompress(const std::vector<uint8_t>& compressed_data)
    {
        if (compressed_data.empty())
            return {};

        z_stream zs;
        memset(&zs, 0, sizeof(zs));

        if (inflateInit(&zs) != Z_OK)
            throw std::runtime_error("inflateInit failed");

        zs.next_in = const_cast<Bytef*>(compressed_data.data());
        zs.avail_in = static_cast<uInt>(compressed_data.size());

        int ret;
        std::vector<uint8_t> decompressed_data;
        std::array<uint8_t, 32768> temp_buffer;

        do {
            zs.next_out = temp_buffer.data();
            zs.avail_out = static_cast<uInt>(temp_buffer.size());

            ret = inflate(&zs, 0);

            if (decompressed_data.size() < zs.total_out) {
                decompressed_data.insert(decompressed_data.end(),
                                       temp_buffer.begin(),
                                       temp_buffer.begin() + zs.total_out - decompressed_data.size());
            }
        } while (ret == Z_OK);

        inflateEnd(&zs);

        if (ret != Z_STREAM_END)
            throw std::runtime_error("Exception during zlib decompression");

        return decompressed_data;
    }

    // 압축률 계산
    static double CalculateCompressionRatio(size_t original_size, size_t compressed_size)
    {
        if (original_size == 0)
            return 0.0;
        return static_cast<double>(compressed_size) / original_size;
    }

    // 압축 여부 결정 (임계값 기준)
    static bool ShouldCompress(const std::vector<uint8_t>& data, size_t threshold = 128)
    {
        return data.size() >= threshold;
    }
};

// 압축 가능한 패킷 클래스
class CompressiblePacket : public GamePacket
{
public:
    CompressiblePacket(GamePacketType type) : GamePacket(type), compression_threshold_(128) {}

    // 압축 임계값 설정
    void SetCompressionThreshold(size_t threshold) { compression_threshold_ = threshold; }

    // 패킷 직렬화 (압축 포함)
    std::vector<uint8_t> SerializeWithCompression() const
    {
        auto raw_data = Serialize();
        
        if (CompressionUtils::ShouldCompress(raw_data, compression_threshold_))
        {
            try
            {
                auto compressed_data = CompressionUtils::Compress(raw_data);
                
                // 압축률이 좋은 경우에만 압축 사용
                if (CompressionUtils::CalculateCompressionRatio(raw_data.size(), compressed_data.size()) < 0.9)
                {
                    header_.flags |= static_cast<uint8_t>(PacketFlags::COMPRESSED);
                    
                    // 원본 크기 정보 추가 (압축 해제 시 필요)
                    std::vector<uint8_t> result;
                    uint32_t original_size = static_cast<uint32_t>(raw_data.size());
                    result.insert(result.end(), reinterpret_cast<const uint8_t*>(&original_size),
                                 reinterpret_cast<const uint8_t*>(&original_size) + sizeof(original_size));
                    result.insert(result.end(), compressed_data.begin(), compressed_data.end());
                    
                    std::cout << "Packet compressed: " << raw_data.size() << " -> " 
                             << compressed_data.size() << " bytes (" 
                             << (CompressionUtils::CalculateCompressionRatio(raw_data.size(), compressed_data.size()) * 100.0) 
                             << "%)" << std::endl;
                    
                    return result;
                }
            }
            catch (const std::exception& e)
            {
                std::cerr << "Compression failed: " << e.what() << std::endl;
            }
        }
        
        // 압축하지 않는 경우
        header_.flags &= ~static_cast<uint8_t>(PacketFlags::COMPRESSED);
        return raw_data;
    }

    // 패킷 역직렬화 (압축 해제 포함)
    bool DeserializeWithDecompression(const std::vector<uint8_t>& data)
    {
        if (header_.flags & static_cast<uint8_t>(PacketFlags::COMPRESSED))
        {
            if (data.size() < sizeof(uint32_t))
                return false;

            // 원본 크기 읽기
            uint32_t original_size;
            std::memcpy(&original_size, data.data(), sizeof(original_size));
            
            // 압축된 데이터 추출
            std::vector<uint8_t> compressed_data(data.begin() + sizeof(uint32_t), data.end());
            
            try
            {
                auto decompressed_data = CompressionUtils::Decompress(compressed_data);
                
                if (decompressed_data.size() != original_size)
                {
                    std::cerr << "Decompression size mismatch" << std::endl;
                    return false;
                }
                
                return Deserialize(decompressed_data);
            }
            catch (const std::exception& e)
            {
                std::cerr << "Decompression failed: " << e.what() << std::endl;
                return false;
            }
        }
        else
        {
            return Deserialize(data);
        }
    }

protected:
    size_t compression_threshold_;
};

// 대용량 데이터 패킷 예제
class GameStatePacket : public CompressiblePacket
{
public:
    GameStatePacket() : CompressiblePacket(GamePacketType::GAME_STATE_UPDATE) {}

    struct PlayerInfo
    {
        uint32_t player_id;
        float x, y, z;
        uint16_t health;
        uint16_t mana;
        uint8_t level;
        uint8_t status;
    };

    std::vector<PlayerInfo> players;
    std::string world_state; // JSON이나 다른 형태의 월드 상태 데이터

    std::vector<uint8_t> Serialize() const override
    {
        std::vector<uint8_t> data;
        
        // 플레이어 수
        uint32_t player_count = static_cast<uint32_t>(players.size());
        data.insert(data.end(), reinterpret_cast<const uint8_t*>(&player_count),
                   reinterpret_cast<const uint8_t*>(&player_count) + sizeof(player_count));
        
        // 플레이어 데이터
        for (const auto& player : players)
        {
            data.insert(data.end(), reinterpret_cast<const uint8_t*>(&player),
                       reinterpret_cast<const uint8_t*>(&player) + sizeof(player));
        }
        
        // 월드 상태 길이 + 데이터
        uint32_t world_state_len = static_cast<uint32_t>(world_state.length());
        data.insert(data.end(), reinterpret_cast<const uint8_t*>(&world_state_len),
                   reinterpret_cast<const uint8_t*>(&world_state_len) + sizeof(world_state_len));
        data.insert(data.end(), world_state.begin(), world_state.end());
        
        return data;
    }

    bool Deserialize(const std::vector<uint8_t>& data) override
    {
        if (data.size() < sizeof(uint32_t))
            return false;

        size_t offset = 0;
        
        // 플레이어 수
        uint32_t player_count;
        std::memcpy(&player_count, data.data() + offset, sizeof(player_count));
        offset += sizeof(player_count);
        
        // 플레이어 데이터
        players.clear();
        players.reserve(player_count);
        
        for (uint32_t i = 0; i < player_count; ++i)
        {
            if (offset + sizeof(PlayerInfo) > data.size())
                return false;
                
            PlayerInfo player;
            std::memcpy(&player, data.data() + offset, sizeof(player));
            offset += sizeof(player);
            players.push_back(player);
        }
        
        // 월드 상태
        if (offset + sizeof(uint32_t) > data.size())
            return false;
            
        uint32_t world_state_len;
        std::memcpy(&world_state_len, data.data() + offset, sizeof(world_state_len));
        offset += sizeof(world_state_len);
        
        if (offset + world_state_len > data.size())
            return false;
            
        world_state.assign(data.begin() + offset, data.begin() + offset + world_state_len);
        
        return true;
    }

    size_t GetDataSize() const override
    {
        return sizeof(uint32_t) + (players.size() * sizeof(PlayerInfo)) + 
               sizeof(uint32_t) + world_state.length();
    }
};

void compression_example()
{
    std::cout << "Packet Compression Example" << std::endl;
    
    // 대용량 게임 상태 패킷 생성
    GameStatePacket state_packet;
    
    // 많은 플레이어 데이터 추가
    for (uint32_t i = 1; i <= 100; ++i)
    {
        GameStatePacket::PlayerInfo player;
        player.player_id = i;
        player.x = static_cast<float>(i * 10);
        player.y = static_cast<float>(i * 5);
        player.z = 0.0f;
        player.health = 100;
        player.mana = 50;
        player.level = static_cast<uint8_t>(i % 50 + 1);
        player.status = 1; // active
        
        state_packet.players.push_back(player);
    }
    
    // 반복적인 JSON 데이터 (압축에 유리)
    state_packet.world_state = R"({"weather":"sunny","time":"day","events":[{"type":"spawn","location":[100,200]},{"type":"spawn","location":[150,250]}]})";
    for (int i = 0; i < 20; ++i) // 반복하여 압축률 높이기
    {
        state_packet.world_state += state_packet.world_state;
    }
    
    std::cout << "Original data size: " << state_packet.GetDataSize() << " bytes" << std::endl;
    
    // 압축 임계값 설정
    state_packet.SetCompressionThreshold(500);
    
    // 압축 직렬화
    auto compressed_data = state_packet.SerializeWithCompression();
    std::cout << "Compressed data size: " << compressed_data.size() << " bytes" << std::endl;
    
    // 역직렬화 테스트
    GameStatePacket test_packet;
    test_packet.GetHeader().flags = state_packet.GetHeader().flags; // 압축 플래그 복사
    
    if (test_packet.DeserializeWithDecompression(compressed_data))
    {
        std::cout << "Decompression successful" << std::endl;
        std::cout << "Players count: " << test_packet.players.size() << std::endl;
        std::cout << "World state length: " << test_packet.world_state.length() << std::endl;
    }
    else
    {
        std::cout << "Decompression failed" << std::endl;
    }
}
```

## 18.2 고정 길이 패킷 처리

### 18.2.1 고정 길이 패킷 설계
실시간 게임에서 자주 사용되는 고정 길이 패킷 시스템을 구현한다.

```cpp
// 고정 길이 패킷 기본 클래스
template<size_t PacketSize>
class FixedSizePacket
{
public:
    static constexpr size_t PACKET_SIZE = PacketSize;
    static constexpr size_t DATA_SIZE = PacketSize - sizeof(GamePacketHeader);

    FixedSizePacket(GamePacketType type)
    {
        static_assert(PacketSize >= sizeof(GamePacketHeader), 
                     "Packet size must be at least header size");
        
        memset(&data_, 0, sizeof(data_));
        header_.packet_type = static_cast<uint16_t>(type);
        header_.packet_size = PACKET_SIZE;
    }

    const GamePacketHeader& GetHeader() const { return header_; }
    GamePacketHeader& GetHeader() { return header_; }

    // 전체 패킷 데이터 접근
    const uint8_t* GetPacketData() const 
    { 
        return reinterpret_cast<const uint8_t*>(this); 
    }

    uint8_t* GetPacketData() 
    { 
        return reinterpret_cast<uint8_t*>(this); 
    }

    // 데이터 부분만 접근
    const uint8_t* GetData() const { return data_; }
    uint8_t* GetData() { return data_; }

    // 체크섬 계산 및 검증
    void UpdateChecksum()
    {
        header_.CalculateChecksum(data_, DATA_SIZE);
    }

    bool VerifyChecksum() const
    {
        return header_.VerifyChecksum(data_, DATA_SIZE);
    }

protected:
    GamePacketHeader header_;
    uint8_t data_[DATA_SIZE];
};

// 플레이어 이동 패킷 (32바이트 고정)
#pragma pack(push, 1)
class PlayerMovePacket : public FixedSizePacket<32>
{
public:
    PlayerMovePacket() : FixedSizePacket(GamePacketType::PLAYER_MOVE)
    {
        memset(&move_data_, 0, sizeof(move_data_));
    }

    struct MoveData
    {
        uint32_t player_id;
        float x, y, z;           // 위치
        float velocity_x, velocity_y, velocity_z; // 속도
        uint16_t direction;      // 방향 (0-360도)
        uint8_t move_type;       // 이동 타입 (걷기, 뛰기, 점프 등)
        uint8_t flags;           // 추가 플래그
    } move_data_;

    static_assert(sizeof(MoveData) <= DATA_SIZE, "MoveData too large for packet");

    // 접근자 메서드들
    void SetPlayerData(uint32_t player_id, float x, float y, float z)
    {
        move_data_.player_id = player_id;
        move_data_.x = x;
        move_data_.y = y;
        move_data_.z = z;
    }

    void SetVelocity(float vx, float vy, float vz)
    {
        move_data_.velocity_x = vx;
        move_data_.velocity_y = vy;
        move_data_.velocity_z = vz;
    }

    void SetDirection(uint16_t direction)
    {
        move_data_.direction = direction % 360;
    }

    void SetMoveType(uint8_t move_type)
    {
        move_data_.move_type = move_type;
    }

    // 데이터 복사
    void CopyFrom(const MoveData& data)
    {
        move_data_ = data;
        std::memcpy(data_, &move_data_, sizeof(move_data_));
    }

    void CopyTo(MoveData& data) const
    {
        std::memcpy(&data, data_, sizeof(MoveData));
    }

    // 유효성 검사
    bool IsValid() const
    {
        return move_data_.player_id > 0 &&
               std::isfinite(move_data_.x) && std::isfinite(move_data_.y) && std::isfinite(move_data_.z) &&
               move_data_.direction < 360;
    }
};
#pragma pack(pop)

// 플레이어 공격 패킷 (24바이트 고정)
#pragma pack(push, 1)
class PlayerAttackPacket : public FixedSizePacket<24>
{
public:
    PlayerAttackPacket() : FixedSizePacket(GamePacketType::PLAYER_ATTACK)
    {
        memset(&attack_data_, 0, sizeof(attack_data_));
    }

    struct AttackData
    {
        uint32_t attacker_id;
        uint32_t target_id;
        uint16_t skill_id;
        uint16_t damage;
        float target_x, target_y; // 타겟 위치
    } attack_data_;

    static_assert(sizeof(AttackData) <= DATA_SIZE, "AttackData too large for packet");

    void SetAttackData(uint32_t attacker, uint32_t target, uint16_t skill, uint16_t damage)
    {
        attack_data_.attacker_id = attacker;
        attack_data_.target_id = target;
        attack_data_.skill_id = skill;
        attack_data_.damage = damage;
        std::memcpy(data_, &attack_data_, sizeof(attack_data_));
    }

    void SetTargetPosition(float x, float y)
    {
        attack_data_.target_x = x;
        attack_data_.target_y = y;
        std::memcpy(data_, &attack_data_, sizeof(attack_data_));
    }

    void GetAttackData(AttackData& data) const
    {
        std::memcpy(&data, data_, sizeof(AttackData));
    }

    bool IsValid() const
    {
        AttackData data;
        GetAttackData(data);
        return data.attacker_id > 0 && data.skill_id > 0 && data.damage > 0;
    }
};
#pragma pack(pop)

// 고정 길이 패킷 처리기
class FixedPacketProcessor
{
public:
    FixedPacketProcessor() = default;

    // 패킷 타입별 처리 함수 등록
    template<typename PacketType>
    void RegisterHandler(std::function<void(const PacketType&)> handler)
    {
        static_assert(std::is_base_of_v<FixedSizePacket<PacketType::PACKET_SIZE>, PacketType>,
                     "PacketType must inherit from FixedSizePacket");

        GamePacketType type = static_cast<GamePacketType>(PacketType{}.GetHeader().packet_type);
        
        handlers_[type] = [handler](const uint8_t* data, size_t size)
        {
            if (size == PacketType::PACKET_SIZE)
            {
                const PacketType* packet = reinterpret_cast<const PacketType*>(data);
                if (packet->VerifyChecksum() && packet->IsValid())
                {
                    handler(*packet);
                }
                else
                {
                    std::cerr << "Invalid packet received" << std::endl;
                }
            }
            else
            {
                std::cerr << "Size mismatch for packet type " << static_cast<int>(type) << std::endl;
            }
        };
    }

    // 패킷 처리
    void ProcessPacket(const uint8_t* data, size_t size)
    {
        if (size < sizeof(GamePacketHeader))
        {
            std::cerr << "Packet too small" << std::endl;
            return;
        }

        const GamePacketHeader* header = reinterpret_cast<const GamePacketHeader*>(data);
        GamePacketType type = static_cast<GamePacketType>(header->packet_type);

        auto it = handlers_.find(type);
        if (it != handlers_.end())
        {
            it->second(data, size);
        }
        else
        {
            std::cerr << "No handler for packet type: " << static_cast<int>(type) << std::endl;
        }
    }

    // 배치 처리
    void ProcessPacketBatch(const std::vector<std::vector<uint8_t>>& packets)
    {
        for (const auto& packet_data : packets)
        {
            ProcessPacket(packet_data.data(), packet_data.size());
        }
    }

private:
    using PacketHandler = std::function<void(const uint8_t*, size_t)>;
    std::unordered_map<GamePacketType, PacketHandler> handlers_;
};

// 고정 길이 패킷 버퍼
class FixedPacketBuffer
{
public:
    explicit FixedPacketBuffer(size_t max_packets = 1000)
        : max_packets_(max_packets)
    {
    }

    template<typename PacketType>
    bool AddPacket(const PacketType& packet)
    {
        static_assert(std::is_base_of_v<FixedSizePacket<PacketType::PACKET_SIZE>, PacketType>,
                     "PacketType must inherit from FixedSizePacket");

        std::lock_guard<std::mutex> lock(buffer_mutex_);
        
        if (packet_buffers_.size() >= max_packets_)
        {
            return false; // 버퍼 가득 참
        }

        std::vector<uint8_t> packet_data(PacketType::PACKET_SIZE);
        std::memcpy(packet_data.data(), packet.GetPacketData(), PacketType::PACKET_SIZE);
        
        packet_buffers_.push_back(std::move(packet_data));
        return true;
    }

    std::vector<std::vector<uint8_t>> FlushPackets()
    {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        
        std::vector<std::vector<uint8_t>> result;
        result.swap(packet_buffers_);
        
        return result;
    }

    size_t GetPacketCount() const
    {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        return packet_buffers_.size();
    }

    bool IsFull() const
    {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        return packet_buffers_.size() >= max_packets_;
    }

private:
    std::vector<std::vector<uint8_t>> packet_buffers_;
    size_t max_packets_;
    mutable std::mutex buffer_mutex_;
};

void fixed_packet_example()
{
    std::cout << "Fixed Size Packet Example" << std::endl;
    
    // 패킷 처리기 설정
    FixedPacketProcessor processor;
    
    // 이동 패킷 핸들러 등록
    processor.RegisterHandler<PlayerMovePacket>([](const PlayerMovePacket& packet)
    {
        PlayerMovePacket::MoveData move_data;
        packet.CopyTo(move_data);
        
        std::cout << "Player " << move_data.player_id << " moved to (" 
                 << move_data.x << ", " << move_data.y << ", " << move_data.z << ")" << std::endl;
    });
    
    // 공격 패킷 핸들러 등록
    processor.RegisterHandler<PlayerAttackPacket>([](const PlayerAttackPacket& packet)
    {
        PlayerAttackPacket::AttackData attack_data;
        packet.GetAttackData(attack_data);
        
        std::cout << "Player " << attack_data.attacker_id << " attacked " 
                 << attack_data.target_id << " with skill " << attack_data.skill_id 
                 << " for " << attack_data.damage << " damage" << std::endl;
    });
    
    // 패킷 생성 및 테스트
    FixedPacketBuffer packet_buffer;
    
    // 이동 패킷
    PlayerMovePacket move_packet;
    move_packet.SetPlayerData(12345, 100.5f, 200.3f, 0.0f);
    move_packet.SetVelocity(5.0f, 0.0f, 0.0f);
    move_packet.SetDirection(90);
    move_packet.SetMoveType(1); // 걷기
    move_packet.UpdateChecksum();
    
    packet_buffer.AddPacket(move_packet);
    
    // 공격 패킷
    PlayerAttackPacket attack_packet;
    attack_packet.SetAttackData(12345, 67890, 101, 150);
    attack_packet.SetTargetPosition(120.0f, 180.0f);
    attack_packet.UpdateChecksum();
    
    packet_buffer.AddPacket(attack_packet);
    
    // 배치 처리
    auto packets = packet_buffer.FlushPackets();
    processor.ProcessPacketBatch(packets);
    
    std::cout << "Processed " << packets.size() << " packets" << std::endl;
    std::cout << "Move packet size: " << PlayerMovePacket::PACKET_SIZE << " bytes" << std::endl;
    std::cout << "Attack packet size: " << PlayerAttackPacket::PACKET_SIZE << " bytes" << std::endl;
}
```

### 18.2.2 고정 길이 패킷 최적화
메모리 정렬과 비트 패킹을 통한 고정 길이 패킷 최적화를 구현한다.

```cpp
// 비트 필드를 활용한 최적화된 패킷
#pragma pack(push, 1)
class OptimizedPlayerStatePacket : public FixedSizePacket<16>
{
public:
    OptimizedPlayerStatePacket() : FixedSizePacket(GamePacketType::PLAYER_MOVE)
    {
        memset(&state_data_, 0, sizeof(state_data_));
    }

    struct StateData
    {
        uint32_t player_id;
        
        // 위치를 16비트 정수로 압축 (0.1 단위)
        uint16_t x_compressed;     // -3276.8 ~ 3276.7 범위
        uint16_t y_compressed;     // -3276.8 ~ 3276.7 범위
        
        // 비트 필드로 공간 절약
        uint16_t direction : 9;    // 0-511 (360도를 512로 분할)
        uint16_t health_percent : 7; // 0-100% (0-127)
        
        uint8_t level;             // 레벨 (1-255)
        
        // 상태 플래그들을 비트로 압축
        uint8_t is_moving : 1;
        uint8_t is_attacking : 1;
        uint8_t is_dead : 1;
        uint8_t is_invisible : 1;
        uint8_t move_type : 2;     // 0=걷기, 1=뛰기, 2=점프, 3=텔레포트
        uint8_t reserved : 2;      // 예약된 비트
        
    } state_data_;

    static_assert(sizeof(StateData) <= DATA_SIZE, "StateData too large for packet");

    // 위치 설정 (실제 좌표를 압축)
    void SetPosition(float x, float y)
    {
        // -3276.8 ~ 3276.7 범위로 제한하고 0.1 단위로 압축
        x = std::clamp(x, -3276.8f, 3276.7f);
        y = std::clamp(y, -3276.8f, 3276.7f);
        
        state_data_.x_compressed = static_cast<uint16_t>((x + 3276.8f) * 10.0f);
        state_data_.y_compressed = static_cast<uint16_t>((y + 3276.8f) * 10.0f);
        
        UpdateData();
    }

    // 압축된 위치 읽기
    void GetPosition(float& x, float& y) const
    {
        x = (static_cast<float>(state_data_.x_compressed) / 10.0f) - 3276.8f;
        y = (static_cast<float>(state_data_.y_compressed) / 10.0f) - 3276.8f;
    }

    // 방향 설정 (0-360도를 0-511로 변환)
    void SetDirection(float degrees)
    {
        degrees = fmod(degrees, 360.0f);
        if (degrees < 0) degrees += 360.0f;
        
        state_data_.direction = static_cast<uint16_t>((degrees / 360.0f) * 511.0f);
        UpdateData();
    }

    // 방향 읽기
    float GetDirection() const
    {
        return (static_cast<float>(state_data_.direction) / 511.0f) * 360.0f;
    }

    // 체력 퍼센트 설정
    void SetHealthPercent(uint8_t percent)
    {
        state_data_.health_percent = std::min(percent, static_cast<uint8_t>(100));
        UpdateData();
    }

    uint8_t GetHealthPercent() const
    {
        return static_cast<uint8_t>(state_data_.health_percent);
    }

    // 상태 플래그 설정
    void SetMoving(bool moving) { state_data_.is_moving = moving ? 1 : 0; UpdateData(); }
    void SetAttacking(bool attacking) { state_data_.is_attacking = attacking ? 1 : 0; UpdateData(); }
    void SetDead(bool dead) { state_data_.is_dead = dead ? 1 : 0; UpdateData(); }
    void SetInvisible(bool invisible) { state_data_.is_invisible = invisible ? 1 : 0; UpdateData(); }
    void SetMoveType(uint8_t type) { state_data_.move_type = type & 0x3; UpdateData(); }

    // 상태 플래그 읽기
    bool IsMoving() const { return state_data_.is_moving != 0; }
    bool IsAttacking() const { return state_data_.is_attacking != 0; }
    bool IsDead() const { return state_data_.is_dead != 0; }
    bool IsInvisible() const { return state_data_.is_invisible != 0; }
    uint8_t GetMoveType() const { return state_data_.move_type; }

    // 플레이어 ID 설정/읽기
    void SetPlayerId(uint32_t id) { state_data_.player_id = id; UpdateData(); }
    uint32_t GetPlayerId() const { return state_data_.player_id; }

    // 레벨 설정/읽기
    void SetLevel(uint8_t level) { state_data_.level = level; UpdateData(); }
    uint8_t GetLevel() const { return state_data_.level; }

    bool IsValid() const override
    {
        return state_data_.player_id > 0 && 
               state_data_.level > 0 && 
               state_data_.health_percent <= 100;
    }

private:
    void UpdateData()
    {
        std::memcpy(data_, &state_data_, sizeof(state_data_));
    }
};
#pragma pack(pop)

// 델타 압축을 사용한 패킷
class DeltaCompressedPacket : public FixedSizePacket<32>
{
public:
    DeltaCompressedPacket() : FixedSizePacket(GamePacketType::GAME_STATE_UPDATE) {}

    struct DeltaData
    {
        uint32_t base_sequence;    // 기준 시퀀스 번호
        
        // 델타 값들 (이전 상태와의 차이)
        int16_t delta_x;           // 위치 변화 (-32768 ~ 32767)
        int16_t delta_y;
        int16_t delta_health;      // 체력 변화
        int16_t delta_mana;        // 마나 변화
        
        // 변경된 필드를 나타내는 비트마스크
        uint16_t changed_fields;   // 각 비트가 특정 필드의 변경 여부
        
        // 추가 데이터 (변경된 필드에 따라 다름)
        uint8_t additional_data[12];
        
    } delta_data_;

    static_assert(sizeof(DeltaData) <= DATA_SIZE, "DeltaData too large for packet");

    enum ChangeFlags : uint16_t
    {
        POS_X_CHANGED = 0x0001,
        POS_Y_CHANGED = 0x0002,
        HEALTH_CHANGED = 0x0004,
        MANA_CHANGED = 0x0008,
        LEVEL_CHANGED = 0x0010,
        STATUS_CHANGED = 0x0020,
        EQUIPMENT_CHANGED = 0x0040,
        SKILL_CHANGED = 0x0080
    };

    void SetBaseline(uint32_t sequence) 
    { 
        delta_data_.base_sequence = sequence; 
        delta_data_.changed_fields = 0;
        UpdateData();
    }

    void SetPositionDelta(int16_t dx, int16_t dy)
    {
        if (dx != 0)
        {
            delta_data_.delta_x = dx;
            delta_data_.changed_fields |= POS_X_CHANGED;
        }
        if (dy != 0)
        {
            delta_data_.delta_y = dy;
            delta_data_.changed_fields |= POS_Y_CHANGED;
        }
        UpdateData();
    }

    void SetHealthDelta(int16_t delta_health)
    {
        if (delta_health != 0)
        {
            delta_data_.delta_health = delta_health;
            delta_data_.changed_fields |= HEALTH_CHANGED;
        }
        UpdateData();
    }

    void SetManaDelta(int16_t delta_mana)
    {
        if (delta_mana != 0)
        {
            delta_data_.delta_mana = delta_mana;
            delta_data_.changed_fields |= MANA_CHANGED;
        }
        UpdateData();
    }

    // 변경 여부 확인
    bool HasPositionChange() const { return delta_data_.changed_fields & (POS_X_CHANGED | POS_Y_CHANGED); }
    bool HasHealthChange() const { return delta_data_.changed_fields & HEALTH_CHANGED; }
    bool HasManaChange() const { return delta_data_.changed_fields & MANA_CHANGED; }

    // 델타 값 읽기
    void GetPositionDelta(int16_t& dx, int16_t& dy) const
    {
        dx = (delta_data_.changed_fields & POS_X_CHANGED) ? delta_data_.delta_x : 0;
        dy = (delta_data_.changed_fields & POS_Y_CHANGED) ? delta_data_.delta_y : 0;
    }

    int16_t GetHealthDelta() const
    {
        return (delta_data_.changed_fields & HEALTH_CHANGED) ? delta_data_.delta_health : 0;
    }

    int16_t GetManaDelta() const
    {
        return (delta_data_.changed_fields & MANA_CHANGED) ? delta_data_.delta_mana : 0;
    }

    uint32_t GetBaseSequence() const { return delta_data_.base_sequence; }
    uint16_t GetChangedFields() const { return delta_data_.changed_fields; }

private:
    void UpdateData()
    {
        std::memcpy(data_, &delta_data_, sizeof(delta_data_));
    }
};

// 패킷 압축률 분석기
class PacketCompressionAnalyzer
{
public:
    struct CompressionStats
    {
        size_t original_packets = 0;
        size_t compressed_packets = 0;
        size_t total_original_bytes = 0;
        size_t total_compressed_bytes = 0;
        double average_compression_ratio = 0.0;
    };

    void AnalyzePacket(size_t original_size, size_t compressed_size)
    {
        std::lock_guard<std::mutex> lock(stats_mutex_);
        
        stats_.original_packets++;
        stats_.total_original_bytes += original_size;
        
        if (compressed_size < original_size)
        {
            stats_.compressed_packets++;
        }
        
        stats_.total_compressed_bytes += compressed_size;
        
        if (stats_.total_original_bytes > 0)
        {
            stats_.average_compression_ratio = 
                static_cast<double>(stats_.total_compressed_bytes) / stats_.total_original_bytes;
        }
    }

    CompressionStats GetStats() const
    {
        std::lock_guard<std::mutex> lock(stats_mutex_);
        return stats_;
    }

    void PrintStats() const
    {
        auto stats = GetStats();
        
        std::cout << "\n=== Packet Compression Analysis ===" << std::endl;
        std::cout << "Original packets: " << stats.original_packets << std::endl;
        std::cout << "Compressed packets: " << stats.compressed_packets << std::endl;
        std::cout << "Compression rate: " << (static_cast<double>(stats.compressed_packets) / stats.original_packets * 100.0) << "%" << std::endl;
        std::cout << "Total original bytes: " << stats.total_original_bytes << std::endl;
        std::cout << "Total compressed bytes: " << stats.total_compressed_bytes << std::endl;
        std::cout << "Overall compression ratio: " << (stats.average_compression_ratio * 100.0) << "%" << std::endl;
        std::cout << "Bytes saved: " << (stats.total_original_bytes - stats.total_compressed_bytes) << std::endl;
        std::cout << "====================================" << std::endl;
    }

    void Reset()
    {
        std::lock_guard<std::mutex> lock(stats_mutex_);
        stats_ = CompressionStats{};
    }

private:
    CompressionStats stats_;
    mutable std::mutex stats_mutex_;
};

void packet_optimization_example()
{
    std::cout << "Packet Optimization Example" << std::endl;
    
    PacketCompressionAnalyzer analyzer;
    
    // 최적화된 플레이어 상태 패킷 테스트
    std::cout << "\n--- Optimized Player State Packet ---" << std::endl;
    
    OptimizedPlayerStatePacket opt_packet;
    opt_packet.SetPlayerId(12345);
    opt_packet.SetPosition(123.4f, -567.8f);
    opt_packet.SetDirection(45.5f);
    opt_packet.SetHealthPercent(85);
    opt_packet.SetLevel(25);
    opt_packet.SetMoving(true);
    opt_packet.SetAttacking(false);
    opt_packet.SetMoveType(1); // 뛰기
    opt_packet.UpdateChecksum();
    
    std::cout << "Packet size: " << OptimizedPlayerStatePacket::PACKET_SIZE << " bytes" << std::endl;
    std::cout << "Player ID: " << opt_packet.GetPlayerId() << std::endl;
    
    float x, y;
    opt_packet.GetPosition(x, y);
    std::cout << "Position: (" << x << ", " << y << ")" << std::endl;
    std::cout << "Direction: " << opt_packet.GetDirection() << " degrees" << std::endl;
    std::cout << "Health: " << static_cast<int>(opt_packet.GetHealthPercent()) << "%" << std::endl;
    std::cout << "Level: " << static_cast<int>(opt_packet.GetLevel()) << std::endl;
    std::cout << "Moving: " << (opt_packet.IsMoving() ? "Yes" : "No") << std::endl;
    std::cout << "Move type: " << static_cast<int>(opt_packet.GetMoveType()) << std::endl;
    
    // 델타 압축 패킷 테스트
    std::cout << "\n--- Delta Compressed Packet ---" << std::endl;
    
    DeltaCompressedPacket delta_packet;
    delta_packet.SetBaseline(1000);
    delta_packet.SetPositionDelta(5, -3);
    delta_packet.SetHealthDelta(-10);
    delta_packet.SetManaDelta(5);
    delta_packet.UpdateChecksum();
    
    std::cout << "Packet size: " << DeltaCompressedPacket::PACKET_SIZE << " bytes" << std::endl;
    std::cout << "Base sequence: " << delta_packet.GetBaseSequence() << std::endl;
    std::cout << "Has position change: " << (delta_packet.HasPositionChange() ? "Yes" : "No") << std::endl;
    std::cout << "Has health change: " << (delta_packet.HasHealthChange() ? "Yes" : "No") << std::endl;
    
    int16_t dx, dy;
    delta_packet.GetPositionDelta(dx, dy);
    std::cout << "Position delta: (" << dx << ", " << dy << ")" << std::endl;
    std::cout << "Health delta: " << delta_packet.GetHealthDelta() << std::endl;
    std::cout << "Mana delta: " << delta_packet.GetManaDelta() << std::endl;
    
    // 압축률 분석
    size_t uncompressed_size = 64; // 가상의 비압축 크기
    analyzer.AnalyzePacket(uncompressed_size, OptimizedPlayerStatePacket::PACKET_SIZE);
    analyzer.AnalyzePacket(uncompressed_size, DeltaCompressedPacket::PACKET_SIZE);
    
    analyzer.PrintStats();
}
```

## 18.3 커스텀 직렬화 구현

### 18.3.1 고성능 바이너리 직렬화
게임에 최적화된 커스텀 직렬화 시스템을 구현한다.

```cpp
#include <type_traits>
#include <array>

// 직렬화 traits
template<typename T>
struct is_trivially_serializable : std::false_type {};

// 기본 타입들은 trivially serializable
template<> struct is_trivially_serializable<uint8_t> : std::true_type {};
template<> struct is_trivially_serializable<uint16_t> : std::true_type {};
template<> struct is_trivially_serializable<uint32_t> : std::true_type {};
template<> struct is_trivially_serializable<uint64_t> : std::true_type {};
template<> struct is_trivially_serializable<int8_t> : std::true_type {};
template<> struct is_trivially_serializable<int16_t> : std::true_type {};
template<> struct is_trivially_serializable<int32_t> : std::true_type {};
template<> struct is_trivially_serializable<int64_t> : std::true_type {};
template<> struct is_trivially_serializable<float> : std::true_type {};
template<> struct is_trivially_serializable<double> : std::true_type {};

// 엔디안 변환 유틸리티
class EndianUtils
{
public:
    static bool IsLittleEndian()
    {
        uint32_t test = 1;
        return *reinterpret_cast<uint8_t*>(&test) == 1;
    }

    template<typename T>
    static T SwapBytes(T value)
    {
        if constexpr (sizeof(T) == 1)
        {
            return value;
        }
        else if constexpr (sizeof(T) == 2)
        {
            return ((value & 0xFF) << 8) | ((value >> 8) & 0xFF);
        }
        else if constexpr (sizeof(T) == 4)
        {
            return ((value & 0xFF) << 24) | 
                   (((value >> 8) & 0xFF) << 16) | 
                   (((value >> 16) & 0xFF) << 8) | 
                   ((value >> 24) & 0xFF);
        }
        else if constexpr (sizeof(T) == 8)
        {
            return ((value & 0xFF) << 56) | 
                   (((value >> 8) & 0xFF) << 48) | 
                   (((value >> 16) & 0xFF) << 40) | 
                   (((value >> 24) & 0xFF) << 32) | 
                   (((value >> 32) & 0xFF) << 24) | 
                   (((value >> 40) & 0xFF) << 16) | 
                   (((value >> 48) & 0xFF) << 8) | 
                   ((value >> 56) & 0xFF);
        }
        else
        {
            static_assert(sizeof(T) <= 8, "Unsupported type size for byte swapping");
        }
    }

    template<typename T>
    static T ToNetworkOrder(T value)
    {
        if (IsLittleEndian())
            return SwapBytes(value);
        return value;
    }

    template<typename T>
    static T FromNetworkOrder(T value)
    {
        if (IsLittleEndian())
            return SwapBytes(value);
        return value;
    }
};

// 바이너리 Writer
class BinaryWriter
{
public:
    explicit BinaryWriter(bool use_network_order = true)
        : use_network_order_(use_network_order)
    {
    }

    // 기본 타입 쓰기
    template<typename T>
    void Write(const T& value)
    {
        if constexpr (is_trivially_serializable<T>::value)
        {
            T network_value = use_network_order_ ? EndianUtils::ToNetworkOrder(value) : value;
            const uint8_t* bytes = reinterpret_cast<const uint8_t*>(&network_value);
            buffer_.insert(buffer_.end(), bytes, bytes + sizeof(T));
        }
        else
        {
            static_assert(is_trivially_serializable<T>::value, 
                         "Type must be trivially serializable or provide custom serialization");
        }
    }

    // 문자열 쓰기 (길이 + 데이터)
    void WriteString(const std::string& str)
    {
        Write(static_cast<uint32_t>(str.length()));
        buffer_.insert(buffer_.end(), str.begin(), str.end());
    }

    // 벡터 쓰기 (trivially serializable 타입용)
    template<typename T>
    void WriteVector(const std::vector<T>& vec)
    {
        static_assert(is_trivially_serializable<T>::value, 
                     "Vector element type must be trivially serializable");
        
        Write(static_cast<uint32_t>(vec.size()));
        for (const auto& item : vec)
        {
            Write(item);
        }
    }

    // 배열 쓰기
    template<typename T, size_t N>
    void WriteArray(const std::array<T, N>& arr)
    {
        static_assert(is_trivially_serializable<T>::value, 
                     "Array element type must be trivially serializable");
        
        for (const auto& item : arr)
        {
            Write(item);
        }
    }

    // 원시 바이트 쓰기
    void WriteBytes(const uint8_t* data, size_t size)
    {
        buffer_.insert(buffer_.end(), data, data + size);
    }

    void WriteBytes(const std::vector<uint8_t>& data)
    {
        buffer_.insert(buffer_.end(), data.begin(), data.end());
    }

    // 결과 가져오기
    const std::vector<uint8_t>& GetBuffer() const { return buffer_; }
    std::vector<uint8_t> MoveBuffer() { return std::move(buffer_); }
    
    size_t Size() const { return buffer_.size(); }
    void Clear() { buffer_.clear(); }

    // 특정 위치에 값 쓰기 (헤더 업데이트 등에 사용)
    template<typename T>
    void WriteAt(size_t position, const T& value)
    {
        if (position + sizeof(T) > buffer_.size())
            throw std::out_of_range("Write position out of range");

        T network_value = use_network_order_ ? EndianUtils::ToNetworkOrder(value) : value;
        std::memcpy(buffer_.data() + position, &network_value, sizeof(T));
    }

private:
    std::vector<uint8_t> buffer_;
    bool use_network_order_;
};

// 바이너리 Reader
class BinaryReader
{
public:
    explicit BinaryReader(const std::vector<uint8_t>& data, bool use_network_order = true)
        : data_(data), position_(0), use_network_order_(use_network_order)
    {
    }

    // 기본 타입 읽기
    template<typename T>
    bool Read(T& value)
    {
        if constexpr (is_trivially_serializable<T>::value)
        {
            if (position_ + sizeof(T) > data_.size())
                return false;

            std::memcpy(&value, data_.data() + position_, sizeof(T));
            if (use_network_order_)
                value = EndianUtils::FromNetworkOrder(value);
            
            position_ += sizeof(T);
            return true;
        }
        else
        {
            static_assert(is_trivially_serializable<T>::value, 
                         "Type must be trivially serializable or provide custom serialization");
        }
    }

    // 문자열 읽기
    bool ReadString(std::string& str)
    {
        uint32_t length;
        if (!Read(length))
            return false;

        if (position_ + length > data_.size())
            return false;

        str.assign(data_.begin() + position_, data_.begin() + position_ + length);
        position_ += length;
        return true;
    }

    // 벡터 읽기
    template<typename T>
    bool ReadVector(std::vector<T>& vec)
    {
        static_assert(is_trivially_serializable<T>::value, 
                     "Vector element type must be trivially serializable");

        uint32_t size;
        if (!Read(size))
            return false;

        if (size > 1000000) // 합리적인 크기 제한
            return false;

        vec.clear();
        vec.reserve(size);

        for (uint32_t i = 0; i < size; ++i)
        {
            T item;
            if (!Read(item))
                return false;
            vec.push_back(item);
        }

        return true;
    }

    // 배열 읽기
    template<typename T, size_t N>
    bool ReadArray(std::array<T, N>& arr)
    {
        static_assert(is_trivially_serializable<T>::value, 
                     "Array element type must be trivially serializable");

        for (size_t i = 0; i < N; ++i)
        {
            if (!Read(arr[i]))
                return false;
        }
        return true;
    }

    // 원시 바이트 읽기
    bool ReadBytes(uint8_t* buffer, size_t size)
    {
        if (position_ + size > data_.size())
            return false;

        std::memcpy(buffer, data_.data() + position_, size);
        position_ += size;
        return true;
    }

    bool ReadBytes(std::vector<uint8_t>& buffer, size_t size)
    {
        if (position_ + size > data_.size())
            return false;

        buffer.assign(data_.begin() + position_, data_.begin() + position_ + size);
        position_ += size;
        return true;
    }

    // 상태 확인
    bool AtEnd() const { return position_ >= data_.size(); }
    size_t Position() const { return position_; }
    size_t Size() const { return data_.size(); }
    size_t Remaining() const { return data_.size() - position_; }

    // 위치 이동
    bool Seek(size_t position)
    {
        if (position > data_.size())
            return false;
        position_ = position;
        return true;
    }

    void Skip(size_t bytes)
    {
        position_ = std::min(position_ + bytes, data_.size());
    }

private:
    const std::vector<uint8_t>& data_;
    size_t position_;
    bool use_network_order_;
};

// 직렬화 가능한 클래스를 위한 인터페이스
class ISerializable
{
public:
    virtual ~ISerializable() = default;
    virtual void Serialize(BinaryWriter& writer) const = 0;
    virtual bool Deserialize(BinaryReader& reader) = 0;
    virtual size_t GetSerializedSize() const = 0;
};

// 게임 엔티티 예제
class GameEntity : public ISerializable
{
public:
    uint32_t entity_id = 0;
    std::string name;
    float position[3] = {0.0f, 0.0f, 0.0f};
    uint16_t health = 100;
    uint16_t max_health = 100;
    uint8_t level = 1;
    std::vector<uint32_t> inventory;
    std::array<uint32_t, 4> equipment = {0, 0, 0, 0}; // 무기, 방어구, 액세서리 등

    void Serialize(BinaryWriter& writer) const override
    {
        writer.Write(entity_id);
        writer.WriteString(name);
        writer.WriteArray(std::array<float, 3>{position[0], position[1], position[2]});
        writer.Write(health);
        writer.Write(max_health);
        writer.Write(level);
        writer.WriteVector(inventory);
        writer.WriteArray(equipment);
    }

    bool Deserialize(BinaryReader& reader) override
    {
        if (!reader.Read(entity_id)) return false;
        if (!reader.ReadString(name)) return false;
        
        std::array<float, 3> pos_array;
        if (!reader.ReadArray(pos_array)) return false;
        position[0] = pos_array[0];
        position[1] = pos_array[1];
        position[2] = pos_array[2];
        
        if (!reader.Read(health)) return false;
        if (!reader.Read(max_health)) return false;
        if (!reader.Read(level)) return false;
        if (!reader.ReadVector(inventory)) return false;
        if (!reader.ReadArray(equipment)) return false;

        return true;
    }

    size_t GetSerializedSize() const override
    {
        size_t size = 0;
        size += sizeof(entity_id);
        size += sizeof(uint32_t) + name.length(); // 문자열 길이 + 데이터
        size += sizeof(position);
        size += sizeof(health);
        size += sizeof(max_health);
        size += sizeof(level);
        size += sizeof(uint32_t) + (inventory.size() * sizeof(uint32_t)); // 벡터 크기 + 데이터
        size += sizeof(equipment);
        return size;
    }

    void SetPosition(float x, float y, float z)
    {
        position[0] = x;
        position[1] = y;
        position[2] = z;
    }

    void AddToInventory(uint32_t item_id)
    {
        inventory.push_back(item_id);
    }

    void SetEquipment(size_t slot, uint32_t item_id)
    {
        if (slot < equipment.size())
            equipment[slot] = item_id;
    }
};

// 커스텀 직렬화 패킷
class CustomSerializationPacket : public GamePacket
{
public:
    CustomSerializationPacket() : GamePacket(GamePacketType::CUSTOM_START) {}

    std::vector<GameEntity> entities;
    uint32_t map_id = 0;
    std::string map_name;
    uint64_t timestamp = 0;

    std::vector<uint8_t> Serialize() const override
    {
        BinaryWriter writer;

        writer.Write(map_id);
        writer.WriteString(map_name);
        writer.Write(timestamp);

        // 엔티티 수
        writer.Write(static_cast<uint32_t>(entities.size()));

        // 각 엔티티 직렬화
        for (const auto& entity : entities)
        {
            entity.Serialize(writer);
        }

        return writer.MoveBuffer();
    }

    bool Deserialize(const std::vector<uint8_t>& data) override
    {
        BinaryReader reader(data);

        if (!reader.Read(map_id)) return false;
        if (!reader.ReadString(map_name)) return false;
        if (!reader.Read(timestamp)) return false;

        uint32_t entity_count;
        if (!reader.Read(entity_count)) return false;

        if (entity_count > 10000) // 합리적인 제한
            return false;

        entities.clear();
        entities.reserve(entity_count);

        for (uint32_t i = 0; i < entity_count; ++i)
        {
            GameEntity entity;
            if (!entity.Deserialize(reader))
                return false;
            entities.push_back(std::move(entity));
        }

        return true;
    }

    size_t GetDataSize() const override
    {
        size_t size = 0;
        size += sizeof(map_id);
        size += sizeof(uint32_t) + map_name.length();
        size += sizeof(timestamp);
        size += sizeof(uint32_t); // 엔티티 수

        for (const auto& entity : entities)
        {
            size += entity.GetSerializedSize();
        }

        return size;
    }

    bool IsValid() const override
    {
        return map_id > 0 && !map_name.empty() && timestamp > 0;
    }
};

// 성능 벤치마크
class SerializationBenchmark
{
public:
    struct BenchmarkResult
    {
        size_t serialized_size = 0;
        std::chrono::microseconds serialize_time{0};
        std::chrono::microseconds deserialize_time{0};
        bool success = false;
    };

    static BenchmarkResult BenchmarkCustomSerialization(const CustomSerializationPacket& packet)
    {
        BenchmarkResult result;

        // 직렬화 벤치마크
        auto start_time = std::chrono::high_resolution_clock::now();
        auto serialized_data = packet.Serialize();
        auto end_time = std::chrono::high_resolution_clock::now();

        result.serialize_time = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
        result.serialized_size = serialized_data.size();

        // 역직렬화 벤치마크
        CustomSerializationPacket test_packet;
        start_time = std::chrono::high_resolution_clock::now();
        result.success = test_packet.Deserialize(serialized_data);
        end_time = std::chrono::high_resolution_clock::now();

        result.deserialize_time = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);

        return result;
    }

    static void RunBenchmarks()
    {
        std::cout << "\n=== Serialization Benchmarks ===" << std::endl;

        // 테스트 패킷 생성
        CustomSerializationPacket packet;
        packet.map_id = 12345;
        packet.map_name = "TestMap";
        packet.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();

        // 여러 엔티티 추가
        for (uint32_t i = 1; i <= 100; ++i)
        {
            GameEntity entity;
            entity.entity_id = i;
            entity.name = "Entity" + std::to_string(i);
            entity.SetPosition(i * 10.0f, i * 5.0f, 0.0f);
            entity.health = 90 + (i % 20);
            entity.max_health = 100;
            entity.level = 1 + (i % 50);

            // 인벤토리 아이템 추가
            for (uint32_t j = 0; j < (i % 5 + 1); ++j)
            {
                entity.AddToInventory(1000 + j);
            }

            // 장비 설정
            entity.SetEquipment(0, 2000 + (i % 10)); // 무기
            entity.SetEquipment(1, 3000 + (i % 5));  // 방어구

            packet.entities.push_back(std::move(entity));
        }

        // 벤치마크 실행
        auto result = BenchmarkCustomSerialization(packet);

        std::cout << "Custom Serialization Results:" << std::endl;
        std::cout << "- Success: " << (result.success ? "Yes" : "No") << std::endl;
        std::cout << "- Serialized size: " << result.serialized_size << " bytes" << std::endl;
        std::cout << "- Serialize time: " << result.serialize_time.count() << " μs" << std::endl;
        std::cout << "- Deserialize time: " << result.deserialize_time.count() << " μs" << std::endl;
        std::cout << "- Total time: " << (result.serialize_time + result.deserialize_time).count() << " μs" << std::endl;
        std::cout << "- Throughput: " << (static_cast<double>(result.serialized_size) / 
                                         (result.serialize_time.count() / 1000000.0) / (1024 * 1024)) 
                 << " MB/s" << std::endl;

        // 엔티티당 평균 크기
        if (!packet.entities.empty())
        {
            double avg_entity_size = static_cast<double>(result.serialized_size) / packet.entities.size();
            std::cout << "- Average entity size: " << avg_entity_size << " bytes" << std::endl;
        }

        std::cout << "=================================" << std::endl;
    }
};

void custom_serialization_example()
{
    std::cout << "Custom Serialization Example" << std::endl;

    // 엔디안 테스트
    std::cout << "System is " << (EndianUtils::IsLittleEndian() ? "Little" : "Big") << " Endian" << std::endl;

    // 기본 직렬화 테스트
    BinaryWriter writer;
    writer.Write<uint32_t>(0x12345678);
    writer.Write<float>(3.14159f);
    writer.WriteString("Hello, World!");
    
    std::vector<uint16_t> test_vector = {100, 200, 300, 400, 500};
    writer.WriteVector(test_vector);

    auto data = writer.GetBuffer();
    std::cout << "Serialized " << data.size() << " bytes" << std::endl;

    // 역직렬화 테스트
    BinaryReader reader(data);
    
    uint32_t test_uint;
    float test_float;
    std::string test_string;
    std::vector<uint16_t> test_vector_read;

    if (reader.Read(test_uint) && 
        reader.Read(test_float) && 
        reader.ReadString(test_string) && 
        reader.ReadVector(test_vector_read))
    {
        std::cout << "Deserialization successful:" << std::endl;
        std::cout << "- uint32: 0x" << std::hex << test_uint << std::dec << std::endl;
        std::cout << "- float: " << test_float << std::endl;
        std::cout << "- string: " << test_string << std::endl;
        std::cout << "- vector size: " << test_vector_read.size() << std::endl;
    }

    // 복잡한 객체 직렬화 테스트
    GameEntity entity;
    entity.entity_id = 12345;
    entity.name = "TestEntity";
    entity.SetPosition(100.5f, 200.3f, 50.0f);
    entity.health = 85;
    entity.max_health = 100;
    entity.level = 25;
    entity.AddToInventory(1001);
    entity.AddToInventory(1002);
    entity.AddToInventory(1003);
    entity.SetEquipment(0, 2001); // 무기
    entity.SetEquipment(1, 3001); // 방어구

    BinaryWriter entity_writer;
    entity.Serialize(entity_writer);
    auto entity_data = entity_writer.GetBuffer();

    std::cout << "Entity serialized to " << entity_data.size() << " bytes" << std::endl;
    std::cout << "Estimated size: " << entity.GetSerializedSize() << " bytes" << std::endl;

    // 엔티티 역직렬화
    BinaryReader entity_reader(entity_data);
    GameEntity deserialized_entity;
    
    if (deserialized_entity.Deserialize(entity_reader))
    {
        std::cout << "Entity deserialization successful:" << std::endl;
        std::cout << "- ID: " << deserialized_entity.entity_id << std::endl;
        std::cout << "- Name: " << deserialized_entity.name << std::endl;
        std::cout << "- Position: (" << deserialized_entity.position[0] 
                 << ", " << deserialized_entity.position[1] 
                 << ", " << deserialized_entity.position[2] << ")" << std::endl;
        std::cout << "- Health: " << deserialized_entity.health << "/" << deserialized_entity.max_health << std::endl;
        std::cout << "- Level: " << static_cast<int>(deserialized_entity.level) << std::endl;
        std::cout << "- Inventory items: " << deserialized_entity.inventory.size() << std::endl;
    }

    // 성능 벤치마크 실행
    SerializationBenchmark::RunBenchmarks();
}
```
  

## 정리
이번 장에서는 게임 서버를 위한 효율적인 프로토콜 설계와 직렬화 기법들을 상세히 살펴보았다. 주요 내용을 요약하면:

1. **게임 프로토콜 설계 원칙**: 체크섬 검증, 버전 관리, 패킷 타입 시스템, 그리고 압축 기법을 포함한 견고한 프로토콜 기반을 구축했다.

2. **고정 길이 패킷 처리**: 실시간 게임에 최적화된 고정 길이 패킷 시스템과 비트 패킹, 델타 압축을 통한 최적화 기법을 구현했다.

3. **커스텀 직렬화 구현**: 게임에 특화된 고성능 바이너리 직렬화 시스템을 구현하고, 엔디안 처리와 성능 벤치마크를 통해 최적화했다.

이러한 프로토콜 설계와 직렬화 기법들을 적절히 선택하고 조합하면 네트워크 대역폭을 절약하고 처리 성능을 향상시킬 수 있다. 다음 장에서는 게임 서버의 보안과 안정성을 확보하는 방법에 대해 학습하겠다.


   