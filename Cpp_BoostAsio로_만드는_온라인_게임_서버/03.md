# C++ Boost.Asioë¡œ ë§Œë“œëŠ” ì˜¨ë¼ì¸ ê²Œì„ ì„œë²„
ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ
- **ë„êµ¬**: Windows Performance Toolkit, Intel VTune (ì„ íƒì‚¬í•­)

-----   

# Chapter 3. ë™ê¸° ë°©ì‹ ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°
ì´ ì¥ì—ì„œëŠ” Boost.Asioë¥¼ ì‚¬ìš©í•œ ë™ê¸° ë°©ì‹ ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì˜ ê¸°ì´ˆë¥¼ í•™ìŠµí•œë‹¤. ë™ê¸° ë°©ì‹ì€ ë¹„ë™ê¸° ë°©ì‹ë³´ë‹¤ ì´í•´í•˜ê¸° ì‰½ê³ , ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì˜ ê¸°ë³¸ ê°œë…ì„ ìµíˆê¸°ì— ì í•©í•˜ë‹¤. ì‹¤ì œ ì˜ˆì œë¥¼ í†µí•´ TCP ì†Œì¼“ í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ì„ ë§ˆìŠ¤í„°í•´ë³´ê² ë‹¤.
  

## 3.1 ê°„ë‹¨í•œ Echo ì„œë²„/í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„

### 3.1.1 Echo ì„œë²„ë€?
Echo ì„œë²„ëŠ” í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ë°›ì€ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ ë‹¤ì‹œ ì „ì†¡í•˜ëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ë„¤íŠ¸ì›Œí¬ ì„œë²„ì´ë‹¤. ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì„ í•™ìŠµí•  ë•Œ ì „í†µì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ì˜ˆì œë¡œ, ë‹¤ìŒê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤:  
  
- í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½
- í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ë‚¸ ë©”ì‹œì§€ ìˆ˜ì‹ 
- ë°›ì€ ë©”ì‹œì§€ë¥¼ ê·¸ëŒ€ë¡œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡
- ì—°ê²° ê´€ë¦¬ ë° ì¢…ë£Œ ì²˜ë¦¬

### 3.1.2 ë™ê¸° ë°©ì‹ TCP Echo ì„œë²„ êµ¬í˜„
ë¨¼ì € ê°€ì¥ ê¸°ë³¸ì ì¸ ë™ê¸° ë°©ì‹ Echo ì„œë²„ë¥¼ êµ¬í˜„í•´ë³´ê² ë‹¤.

**SynchronousEchoServer.cpp:**

```cpp
#include <iostream>
#include <string>
#include <array>
#include <format>
#include <boost/asio.hpp>

using namespace boost::asio;
using ip::tcp;

const char SERVER_IP[] = "127.0.0.1";
const unsigned short PORT_NUMBER = 31352;

class SynchronousEchoServer 
{
private:
    io_context io_context_;
    tcp::acceptor acceptor_;
    
public:
    SynchronousEchoServer(unsigned short port) 
        : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port)) 
    {
        std::cout << std::format("Echo ì„œë²„ê°€ í¬íŠ¸ {}ì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.\n", port);
    }
    
    void run() 
    {
        try 
        {
            while (true) 
            {
                // í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ê¸°ë‹¤ë¦¼ (ë¸”ë¡œí‚¹)
                tcp::socket socket(io_context_);
                acceptor_.accept(socket);
                
                std::cout << "í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤: " 
                         << socket.remote_endpoint() << std::endl;
                
                handle_client(std::move(socket));
            }
        } 
        catch (std::exception& e) 
        {
            std::cerr << "ì„œë²„ ì˜¤ë¥˜: " << e.what() << std::endl;
        }
    }
    
private:
    void handle_client(tcp::socket socket) 
    {
        try 
        {
            while (true) 
            {
                std::array<char, 1024> buffer;
                buffer.fill(0);
                
                // ë°ì´í„° ìˆ˜ì‹  (ë¸”ë¡œí‚¹)
                boost::system::error_code error;
                size_t length = socket.read_some(boost::asio::buffer(buffer), error);
                
                if (error == boost::asio::error::eof) {
                    std::cout << "í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ì„ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤." << std::endl;
                    break; // ì •ìƒì ì¸ ì—°ê²° ì¢…ë£Œ
                } else if (error) {
                    std::cout << std::format("ìˆ˜ì‹  ì˜¤ë¥˜: {} ({})\n", 
                                           error.message(), error.value());
                    break;
                }
                
                if (length > 0) {
                    std::string received_data(buffer.data(), length);
                    std::cout << std::format("ë°›ì€ ë©”ì‹œì§€ [{}ë°”ì´íŠ¸]: {}\n", 
                                           length, received_data);
                    
                    // Echo: ë°›ì€ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ ì „ì†¡ (ë¸”ë¡œí‚¹)
                    std::string echo_message = std::format("Echo: {}", received_data);
                    boost::system::error_code send_error;
                    
                    write(socket, boost::asio::buffer(echo_message), send_error);
                    
                    if (send_error) {
                        std::cout << std::format("ì†¡ì‹  ì˜¤ë¥˜: {} ({})\n", 
                                               send_error.message(), send_error.value());
                        break;
                    }
                    
                    std::cout << std::format("ì‘ë‹µ ì „ì†¡: {}\n", echo_message);
                }
            }
        } 
        catch (std::exception& e) 
        {
            std::cerr << "í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: " << e.what() << std::endl;
        }
        
        std::cout << "í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\n" << std::endl;
    }
};

int main() 
{
    try 
    {
        SynchronousEchoServer server(PORT_NUMBER);
        std::cout << "Echo ì„œë²„ ì‹¤í–‰ ì¤‘... (Ctrl+Cë¡œ ì¢…ë£Œ)\n" << std::endl;
        server.run();
    } 
    catch (std::exception& e) 
    {
        std::cerr << "ì„œë²„ ì‹œì‘ ì‹¤íŒ¨: " << e.what() << std::endl;
    }
    
    return 0;
}
```
  
#### `SynchronousEchoServer` í´ë˜ìŠ¤
ì´ í´ë˜ìŠ¤ê°€ ì„œë²„ì˜ í•µì‹¬ ë¡œì§ì„ ëª¨ë‘ ë‹´ê³  ìˆë‹¤.

##### ë©¤ë²„ ë³€ìˆ˜

```cpp
private:
    io_context io_context_;
    tcp::acceptor acceptor_;
```

  * `io_context_`: Boost.Asioì˜ ì‹¬ì¥ê³¼ ê°™ì€ ê°ì²´ì´ë‹¤. ìš´ì˜ì²´ì œì˜ I/O(ì…ì¶œë ¥) ì„œë¹„ìŠ¤ì™€ ìƒí˜¸ì‘ìš©í•˜ëŠ” ì—­í• ì„ í•˜ë©°, ëª¨ë“  I/O ì‘ì—…ì˜ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì œê³µí•œë‹¤.
  * `acceptor_`: í´ë¼ì´ì–¸íŠ¸ì˜ ì—°ê²° ìš”ì²­ì„ ìˆ˜ë½í•˜ëŠ” "ë¬¸ì§€ê¸°" ì—­í• ì„ í•œë‹¤. ì§€ì •ëœ í¬íŠ¸ì—ì„œ í´ë¼ì´ì–¸íŠ¸ì˜ ì ‘ì†ì„ ê¸°ë‹¤ë¦°ë‹¤.

##### ìƒì„±ì

```cpp
public:
    SynchronousEchoServer(unsigned short port)
        : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port))
    {
        std::cout << std::format("Echo ì„œë²„ê°€ í¬íŠ¸ {}ì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.\n", port);
    }
```

  * `acceptor_`ë¥¼ ì´ˆê¸°í™”í•œë‹¤. `tcp::endpoint(tcp::v4(), port)`ëŠ” "IPv4 í”„ë¡œí† ì½œì„ ì‚¬ìš©í•˜ì—¬ ì´ ì»´í“¨í„°ì˜ ëª¨ë“  ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ì—ì„œ `port` ë²ˆí˜¸ë¡œ ë“¤ì–´ì˜¤ëŠ” ì—°ê²°ì„ ë°›ê² ë‹¤"ëŠ” ì˜ë¯¸ì˜ ì£¼ì†Œ ì •ë³´ë¥¼ ìƒì„±í•œë‹¤.

##### `run()` ë©”ì†Œë“œ: ë©”ì¸ ì„œë²„ ë£¨í”„

```cpp
void run()
{
    try
    {
        while (true) // ë¬´í•œ ë£¨í”„ë¥¼ ëŒë©° í´ë¼ì´ì–¸íŠ¸ ì ‘ì†ì„ ê³„ì† ê¸°ë‹¤ë¦¼
        {
            // 1. í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ëŒ€ê¸° (ë¸”ë¡œí‚¹)
            tcp::socket socket(io_context_);
            acceptor_.accept(socket); // í´ë¼ì´ì–¸íŠ¸ê°€ ì ‘ì†í•  ë•Œê¹Œì§€ ì—¬ê¸°ì„œ ë©ˆì¶¤

            std::cout << "í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤: "
                      << socket.remote_endpoint() << std::endl;

            // 2. ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬
            handle_client(std::move(socket));
        }
    }
    catch (std::exception& e)
    {
        std::cerr << "ì„œë²„ ì˜¤ë¥˜: " << e.what() << std::endl;
    }
}
```

  * ì´ ë©”ì†Œë“œê°€ ì„œë²„ì˜ ì‹¤ì§ˆì ì¸ ì‹¤í–‰ì„ ë‹´ë‹¹í•œë‹¤.
  * `while (true)` ë£¨í”„ ì•ˆì—ì„œ í´ë¼ì´ì–¸íŠ¸ì˜ ì—°ê²°ì„ ê³„ì†í•´ì„œ ê¸°ë‹¤ë¦°ë‹¤.
  * `acceptor_.accept(socket)`: **ì´ ì½”ë“œì˜ í•µì‹¬ì ì¸ ë¸”ë¡œí‚¹ ë¶€ë¶„**ì´ë‹¤. í´ë¼ì´ì–¸íŠ¸ê°€ ì ‘ì†ì„ ì‹œë„í•  ë•Œê¹Œì§€ í”„ë¡œê·¸ë¨ì€ ì´ ë¼ì¸ì—ì„œ ì‹¤í–‰ì„ ë©ˆì¶”ê³  ëŒ€ê¸°í•œë‹¤. ì—°ê²°ì´ ì´ë£¨ì–´ì§€ë©´, í•´ë‹¹ í´ë¼ì´ì–¸íŠ¸ì™€ í†µì‹ í•  ìˆ˜ ìˆëŠ” `socket` ê°ì²´ê°€ ìƒì„±ëœë‹¤.
  * `handle_client(std::move(socket))`: í´ë¼ì´ì–¸íŠ¸ì™€ ì—°ê²°ëœ `socket`ì„ `handle_client` í•¨ìˆ˜ë¡œ ë„˜ê²¨ì„œ ì‹¤ì œ ë°ì´í„° í†µì‹ ì„ ì²˜ë¦¬í•˜ë„ë¡ í•œë‹¤. `std::move`ëŠ” ì†Œì¼“ ê°ì²´ì˜ ì†Œìœ ê¶Œì„ íš¨ìœ¨ì ìœ¼ë¡œ ì´ì „í•˜ê¸° ìœ„í•´ ì‚¬ìš©ëœë‹¤.

##### `handle_client()` ë©”ì†Œë“œ: í´ë¼ì´ì–¸íŠ¸ í†µì‹  ì²˜ë¦¬

```cpp
private:
    void handle_client(tcp::socket socket)
    {
        try
        {
            while (true) // í•œ í´ë¼ì´ì–¸íŠ¸ì™€ ê³„ì† í†µì‹ í•˜ê¸° ìœ„í•œ ë£¨í”„
            {
                std::array<char, 1024> buffer; // ë°ì´í„° ìˆ˜ì‹ ìš© ë²„í¼
                boost::system::error_code error;

                // 1. ë°ì´í„° ìˆ˜ì‹  (ë¸”ë¡œí‚¹)
                size_t length = socket.read_some(boost::asio::buffer(buffer), error);

                // 2. ì˜¤ë¥˜ ì²˜ë¦¬ (ì—°ê²° ì¢…ë£Œ ë“±)
                if (error == boost::asio::error::eof) {
                    std::cout << "í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ì„ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤." << std::endl;
                    break; // ì •ìƒ ì¢…ë£Œ
                } else if (error) {
                    throw boost::system::system_error(error); // ì˜ˆì™¸ ë°œìƒ
                }

                std::string received_data(buffer.data(), length);
                std::cout << "ë°›ì€ ë©”ì‹œì§€: " << received_data << std::endl;

                // 3. Echo: ë°›ì€ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ ì „ì†¡ (ë¸”ë¡œí‚¹)
                write(socket, boost::asio::buffer(received_data));
            }
        }
        catch (std::exception& e)
        {
            std::cerr << "í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: " << e.what() << std::endl;
        }
    }
```

  * `socket.read_some(...)`: **ë˜ ë‹¤ë¥¸ í•µì‹¬ ë¸”ë¡œí‚¹ ë¶€ë¶„**ì´ë‹¤. í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ë°ì´í„°ê°€ ë„ì°©í•  ë•Œê¹Œì§€ ì—¬ê¸°ì„œ ì‹¤í–‰ì„ ë©ˆì¶”ê³  ëŒ€ê¸°í•œë‹¤.
  * `error == boost::asio::error::eof`: í´ë¼ì´ì–¸íŠ¸ê°€ ì •ìƒì ìœ¼ë¡œ ì—°ê²°ì„ ëŠì—ˆì„ ë•Œ ë°œìƒí•˜ëŠ” íŠ¹ë³„í•œ "ì˜¤ë¥˜"ì´ë‹¤. ì´ ê²½ìš° ë£¨í”„ë¥¼ ë¹ ì ¸ë‚˜ê°€ í•¨ìˆ˜ë¥¼ ì¢…ë£Œí•œë‹¤.
  * `write(socket, ...)`: ìˆ˜ì‹ í•œ ë°ì´í„°ë¥¼ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë‹¤ì‹œ ë³´ë‚¸ë‹¤. ì´ ì‘ì—… ì—­ì‹œ ë°ì´í„° ì „ì†¡ì´ ì™„ë£Œë  ë•Œê¹Œì§€ **ë¸”ë¡œí‚¹**ëœë‹¤.

#### `main()` í•¨ìˆ˜

```cpp
int main()
{
    try
    {
        SynchronousEchoServer server(PORT_NUMBER);
        server.run(); // ì„œë²„ ì‹¤í–‰
    }
    catch (std::exception& e)
    {
        std::cerr << "ì„œë²„ ì‹œì‘ ì‹¤íŒ¨: " << e.what() << std::endl;
    }
    return 0;
}
```

  * í”„ë¡œê·¸ë¨ì˜ ì‹œì‘ì ì´ë‹¤.
  * `SynchronousEchoServer` ê°ì²´ë¥¼ ìƒì„±í•˜ê³  `run()` ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ ì„œë²„ë¥¼ ì‹œì‘í•œë‹¤.
  * `try-catch` ë¸”ë¡ìœ¼ë¡œ ì„œë²„ ì‹œì‘ ì‹œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜ˆì™¸(ì˜ˆ: í¬íŠ¸ê°€ ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ê²½ìš°)ë¥¼ ì²˜ë¦¬í•œë‹¤.


#### ë™ì‘ ìˆœì„œ ìš”ì•½
1.  `main` í•¨ìˆ˜ì—ì„œ `SynchronousEchoServer` ê°ì²´ë¥¼ ìƒì„±í•˜ê³ , ì„œë²„ëŠ” ì§€ì •ëœ í¬íŠ¸(`31352`)ì—ì„œ í´ë¼ì´ì–¸íŠ¸ì˜ ì—°ê²°ì„ ê¸°ë‹¤ë¦´ ì¤€ë¹„ë¥¼ í•œë‹¤.
2.  `run()` ë©”ì†Œë“œê°€ í˜¸ì¶œë˜ì–´ ë¬´í•œ ë£¨í”„ì— ì§„ì…í•œë‹¤.
3.  `acceptor_.accept(socket)`ì—ì„œ í´ë¼ì´ì–¸íŠ¸ê°€ ì ‘ì†í•  ë•Œê¹Œì§€ **ëŒ€ê¸° (ë¸”ë¡œí‚¹)**í•œë‹¤.
4.  í´ë¼ì´ì–¸íŠ¸ê°€ ì ‘ì†í•˜ë©´, `handle_client` í•¨ìˆ˜ê°€ í˜¸ì¶œëœë‹¤.
5.  `handle_client` í•¨ìˆ˜ ì•ˆì—ì„œ `socket.read_some()`ì„ í†µí•´ í´ë¼ì´ì–¸íŠ¸ê°€ ë°ì´í„°ë¥¼ ë³´ë‚¼ ë•Œê¹Œì§€ **ëŒ€ê¸° (ë¸”ë¡œí‚¹)**í•œë‹¤.
6.  ë°ì´í„°ë¥¼ ìˆ˜ì‹ í•˜ë©´ ì½˜ì†”ì— ì¶œë ¥í•˜ê³ , `write()`ë¥¼ í†µí•´ ë°›ì€ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë‹¤ì‹œ ì „ì†¡í•œë‹¤.
7.  í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ì„ ëŠê±°ë‚˜ ì˜¤ë¥˜ê°€ ë°œìƒí•  ë•Œê¹Œì§€ 5\~6ë²ˆ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.
8.  í´ë¼ì´ì–¸íŠ¸ì™€ì˜ ì—°ê²°ì´ ì¢…ë£Œë˜ë©´ `handle_client` í•¨ìˆ˜ê°€ ëë‚˜ê³ , `run` ë©”ì†Œë“œì˜ `while` ë£¨í”„ë¡œ ëŒì•„ê°€ ë‹¤ìŒ í´ë¼ì´ì–¸íŠ¸ì˜ ì ‘ì†ì„ ë‹¤ì‹œ ê¸°ë‹¤ë¦°ë‹¤.  
  

### 3.1.3 ë™ê¸° ë°©ì‹ TCP Echo í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
ì´ì œ ìœ„ ì„œë²„ì™€ í†µì‹ í•  í´ë¼ì´ì–¸íŠ¸ë¥¼ êµ¬í˜„í•´ë³´ê² ë‹¤.

**SynchronousEchoClient.cpp:**

```cpp
#include <iostream>
#include <string>
#include <array>
#include <format>
#include <boost/asio.hpp>

using namespace boost::asio;
using ip::tcp;

const char SERVER_IP[] = "127.0.0.1";
const unsigned short PORT_NUMBER = 31400;

class SynchronousEchoClient 
{
private:
    io_context io_context_;
    tcp::socket socket_;
    
public:
    SynchronousEchoClient() : socket_(io_context_) {}
    
    bool connect_to_server(const std::string& server_ip, unsigned short port) 
    {
        try 
        {
            // ì„œë²„ ì£¼ì†Œ ì„¤ì •
            tcp::endpoint server_endpoint(
                boost::asio::ip::make_address(server_ip), port);
            
            // ì„œë²„ì— ì—°ê²° (ë¸”ë¡œí‚¹)
            boost::system::error_code connect_error;
            socket_.connect(server_endpoint, connect_error);
            
            if (connect_error) 
            {
                std::cout << std::format("ì—°ê²° ì‹¤íŒ¨: {} ({})\n", 
                                       connect_error.message(), connect_error.value());
                return false;
            }
            
            std::cout << "ì„œë²„ì— ì„±ê³µì ìœ¼ë¡œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤: " 
                     << server_endpoint << std::endl;
            return true;
            
        } 
        catch (std::exception& e) 
        {
            std::cerr << "ì—°ê²° ì¤‘ ì˜ˆì™¸ ë°œìƒ: " << e.what() << std::endl;
            return false;
        }
    }
    
    void run_interactive_session() 
    {
        std::cout << "\n=== Echo í´ë¼ì´ì–¸íŠ¸ ì‹œì‘ ===\n";
        std::cout << "ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš” ('quit' ì…ë ¥ ì‹œ ì¢…ë£Œ):\n" << std::endl;
        
        std::string input;
        while (true) 
        {
            std::cout << "> ";
            std::getline(std::cin, input);
            
            if (input == "quit" || input == "exit") {
                std::cout << "í´ë¼ì´ì–¸íŠ¸ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤." << std::endl;
                break;
            }
            
            if (input.empty()) {
                continue;
            }
            
            if (!send_and_receive_message(input)) {
                std::cout << "í†µì‹  ì˜¤ë¥˜ë¡œ ì¸í•´ ì—°ê²°ì„ ì¢…ë£Œí•©ë‹ˆë‹¤." << std::endl;
                break;
            }
        }
    }
    
    void run_automatic_test() 
    {
        std::cout << "\n=== ìë™ í…ŒìŠ¤íŠ¸ ëª¨ë“œ ===\n" << std::endl;
        
        std::vector<std::string> test_messages = {
            "Hello, Server!",
            "Test message 1",
            "ê²Œì„ ì„œë²„ í…ŒìŠ¤íŠ¸",
            "123456789",
            "Special chars: !@#$%^&*()"
        };
        
        for (size_t i = 0; i < test_messages.size(); ++i) 
        {
            std::cout << std::format("í…ŒìŠ¤íŠ¸ {}/{}: {}\n", 
                                   i + 1, test_messages.size(), test_messages[i]);
            
            if (!send_and_receive_message(test_messages[i])) 
            {
                std::cout << "í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨!" << std::endl;
                break;
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        }
        
        std::cout << "ìë™ í…ŒìŠ¤íŠ¸ ì™„ë£Œ!" << std::endl;
    }
    
    void disconnect() 
    {
        if (socket_.is_open()) {
            boost::system::error_code error;
            socket_.close(error);
            
            if (!error) {
                std::cout << "ì„œë²„ì™€ì˜ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." << std::endl;
            }
        }
    }
    
private:
    bool send_and_receive_message(const std::string& message) 
    {
        try 
        {
            // ë©”ì‹œì§€ ì „ì†¡ (ë¸”ë¡œí‚¹)
            boost::system::error_code send_error;
            write(socket_, boost::asio::buffer(message), send_error);
            
            if (send_error) 
            {
                std::cout << std::format("ì „ì†¡ ì˜¤ë¥˜: {} ({})\n", 
                                       send_error.message(), send_error.value());
                return false;
            }
            
            std::cout << std::format("ì „ì†¡: {}\n", message);
            
            // ì‘ë‹µ ìˆ˜ì‹  (ë¸”ë¡œí‚¹)
            std::array<char, 1024> buffer;
            buffer.fill(0);
            
            boost::system::error_code receive_error;
            size_t reply_length = socket_.read_some(
                boost::asio::buffer(buffer), receive_error);
            
            if (receive_error == boost::asio::error::eof) {
                std::cout << "ì„œë²„ê°€ ì—°ê²°ì„ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤." << std::endl;
                return false;
            } else if (receive_error) {
                std::cout << std::format("ìˆ˜ì‹  ì˜¤ë¥˜: {} ({})\n", 
                                       receive_error.message(), receive_error.value());
                return false;
            }
            
            std::string reply(buffer.data(), reply_length);
            std::cout << std::format("ìˆ˜ì‹ : {}\n", reply);
            std::cout << std::endl;
            
            return true;
            
        } 
        catch (std::exception& e) 
        {
            std::cerr << "í†µì‹  ì¤‘ ì˜ˆì™¸ ë°œìƒ: " << e.what() << std::endl;
            return false;
        }
    }
};

int main(int argc, char* argv[]) 
{
    try 
    {
        SynchronousEchoClient client;
        
        // ì„œë²„ì— ì—°ê²°
        if (!client.connect_to_server(SERVER_IP, PORT_NUMBER)) {
            return 1;
        }
        
        // ì‹¤í–‰ ëª¨ë“œ ì„ íƒ
        bool auto_mode = false;
        if (argc > 1 && std::string(argv[1]) == "--auto") {
            auto_mode = true;
        }
        
        if (auto_mode) {
            client.run_automatic_test();
        } else {
            client.run_interactive_session();
        }
        
        client.disconnect();
        
    } 
    catch (std::exception& e) 
    {
        std::cerr << "í´ë¼ì´ì–¸íŠ¸ ì˜¤ë¥˜: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```
  
#### í—¤ë” íŒŒì¼ ë° ì „ì—­ ë³€ìˆ˜

```cpp
#include <iostream>
#include <string>
#include <array>
#include <format>
#include <boost/asio.hpp> // Boost.Asio ë¼ì´ë¸ŒëŸ¬ë¦¬

using namespace boost::asio;
using ip::tcp;

// ì ‘ì†í•  ì„œë²„ì˜ IP ì£¼ì†Œì™€ í¬íŠ¸ ë²ˆí˜¸
const char SERVER_IP[] = "127.0.0.1";
const unsigned short PORT_NUMBER = 31400; // ì„œë²„ì˜ í¬íŠ¸ì™€ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.
```

  * í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í¬í•¨í•˜ê³ , ì ‘ì† ëŒ€ìƒ ì„œë²„ì˜ ì£¼ì†Œ ì •ë³´ë¥¼ ìƒìˆ˜ë¡œ ì •ì˜í•œë‹¤.
 

#### `SynchronousEchoClient` í´ë˜ìŠ¤
í´ë¼ì´ì–¸íŠ¸ì˜ ëª¨ë“  ê¸°ëŠ¥ì´ ì´ í´ë˜ìŠ¤ ì•ˆì— êµ¬í˜„ë˜ì–´ ìˆë‹¤.

##### ë©¤ë²„ ë³€ìˆ˜ ë° ìƒì„±ì

```cpp
private:
    io_context io_context_;
    tcp::socket socket_;

public:
    SynchronousEchoClient() : socket_(io_context_) {}
```

  * `io_context_`: ì„œë²„ì™€ ë§ˆì°¬ê°€ì§€ë¡œ Asioì˜ í•µì‹¬ ê°ì²´ì´ë‹¤.
  * `socket_`: ì„œë²„ì™€ ì‹¤ì œë¡œ ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ëŠ” í†µì‹  ì±„ë„ ì—­í• ì„ í•˜ëŠ” ê°ì²´ì´ë‹¤.
  * ìƒì„±ìì—ì„œëŠ” `io_context_`ë¥¼ ì‚¬ìš©í•˜ì—¬ `socket_`ì„ ì´ˆê¸°í™”í•œë‹¤.
  
##### `connect_to_server()` ë©”ì†Œë“œ: ì„œë²„ ì—°ê²°

```cpp
bool connect_to_server(const std::string& server_ip, unsigned short port)
{
    try
    {
        // 1. ì„œë²„ ì£¼ì†Œ ì •ë³´(endpoint) ìƒì„±
        tcp::endpoint server_endpoint(
            boost::asio::ip::make_address(server_ip), port);

        // 2. ì„œë²„ì— ì—°ê²° ì‹œë„ (ë¸”ë¡œí‚¹)
        socket_.connect(server_endpoint);

        std::cout << "ì„œë²„ì— ì„±ê³µì ìœ¼ë¡œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤." << std::endl;
        return true;
    }
    catch (std::exception& e)
    {
        std::cerr << "ì—°ê²° ì‹¤íŒ¨: " << e.what() << std::endl;
        return false;
    }
}
```

  * `tcp::endpoint(...)`: ì ‘ì†í•  ì„œë²„ì˜ IP ì£¼ì†Œì™€ í¬íŠ¸ ë²ˆí˜¸ë¡œ "ëª©ì ì§€ ì£¼ì†Œ"ë¥¼ ë§Œë“ ë‹¤.
  * `socket_.connect(server_endpoint)`: **ì´ ì½”ë“œì˜ í•µì‹¬ì ì¸ ë¸”ë¡œí‚¹(blocking) ë¶€ë¶„**ì´ë‹¤. ì´ í•¨ìˆ˜ëŠ” ì„œë²„ì™€ì˜ ì—°ê²°ì´ ì„±ê³µí•˜ê±°ë‚˜ ì‹¤íŒ¨í•  ë•Œê¹Œì§€ ì‹¤í–‰ì„ ë©ˆì¶”ê³  ê¸°ë‹¤ë¦°ë‹¤.

##### `send_and_receive_message()` ë©”ì†Œë“œ: ë°ì´í„° ì†¡ìˆ˜ì‹ 

```cpp
private:
    bool send_and_receive_message(const std::string& message)
    {
        try
        {
            // 1. ë©”ì‹œì§€ ì „ì†¡ (ë¸”ë¡œí‚¹)
            write(socket_, boost::asio::buffer(message));
            std::cout << "ì „ì†¡: " << message << std::endl;

            // 2. ì‘ë‹µ ìˆ˜ì‹  (ë¸”ë¡œí‚¹)
            std::array<char, 1024> buffer;
            size_t reply_length = socket_.read_some(boost::asio::buffer(buffer));

            std::string reply(buffer.data(), reply_length);
            std::cout << "ìˆ˜ì‹ : " << reply << std::endl;

            return true;
        }
        // ... ì˜¤ë¥˜ ì²˜ë¦¬ ...
    }
```

  * `write(socket_, ...)`: ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë©”ì‹œì§€ë¥¼ ì„œë²„ë¡œ ì „ì†¡í•œë‹¤. ì „ì†¡ì´ ì™„ë£Œë  ë•Œê¹Œì§€ **ë¸”ë¡œí‚¹**ëœë‹¤.
  * `socket_.read_some(...)`: ì„œë²„ë¡œë¶€í„° ì‘ë‹µì´ ì˜¬ ë•Œê¹Œì§€ **ë¸”ë¡œí‚¹**ë˜ë©° ê¸°ë‹¤ë¦°ë‹¤. ì‘ë‹µì„ ë°›ìœ¼ë©´ `buffer`ì— ì €ì¥í•˜ê³ , ì½ì–´ì˜¨ ë°ì´í„°ì˜ ê¸¸ì´ë¥¼ ë°˜í™˜í•œë‹¤.

##### `run_...()` ë©”ì†Œë“œ: ë‘ ê°€ì§€ ì‹¤í–‰ ëª¨ë“œ

```cpp
void run_interactive_session() { /* ... ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬ ... */ }
void run_automatic_test() { /* ... ë¯¸ë¦¬ ì •ì˜ëœ ë©”ì‹œì§€ ì²˜ë¦¬ ... */ }
```

  * `run_interactive_session()`: `while` ë£¨í”„ë¥¼ ëŒë©° ì‚¬ìš©ìì—ê²Œ ì…ë ¥ì„ ë°›ê³ (`std::getline`), ì…ë ¥ë°›ì€ ë©”ì‹œì§€ë¥¼ `send_and_receive_message` í•¨ìˆ˜ë¡œ ë³´ë‚´ ì²˜ë¦¬í•œë‹¤. 'quit'ì„ ì…ë ¥í•˜ë©´ ì¢…ë£Œëœë‹¤.
  * `run_automatic_test()`: `std::vector`ì— ë¯¸ë¦¬ ì •ì˜ëœ í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ë“¤ì„ `for` ë£¨í”„ë¥¼ ëŒë©° ìˆœì°¨ì ìœ¼ë¡œ ì„œë²„ì— ì „ì†¡í•˜ê³  ì‘ë‹µì„ í™•ì¸í•œë‹¤.

##### `disconnect()` ë©”ì†Œë“œ: ì—°ê²° ì¢…ë£Œ

```cpp
void disconnect()
{
    if (socket_.is_open()) {
        socket_.close();
        std::cout << "ì„œë²„ì™€ì˜ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." << std::endl;
    }
}
```

  * ì†Œì¼“ì´ ì—´ë ¤ìˆëŠ”ì§€ í™•ì¸í•˜ê³ , ì—´ë ¤ìˆë‹¤ë©´ `close()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ì„œë²„ì™€ì˜ ì—°ê²°ì„ ì•ˆì „í•˜ê²Œ ì¢…ë£Œí•œë‹¤.

#### `main()` í•¨ìˆ˜

```cpp
int main(int argc, char* argv[])
{
    try
    {
        SynchronousEchoClient client;

        // 1. ì„œë²„ì— ì—°ê²°
        if (!client.connect_to_server(SERVER_IP, PORT_NUMBER)) {
            return 1; // ì—°ê²° ì‹¤íŒ¨ ì‹œ ì¢…ë£Œ
        }

        // 2. ì‹¤í–‰ ëª¨ë“œ ê²°ì •
        bool auto_mode = false;
        if (argc > 1 && std::string(argv[1]) == "--auto") {
            auto_mode = true;
        }

        // 3. ì„ íƒëœ ëª¨ë“œ ì‹¤í–‰
        if (auto_mode) {
            client.run_automatic_test();
        } else {
            client.run_interactive_session();
        }

        // 4. ì—°ê²° ì¢…ë£Œ
        client.disconnect();
    }
    // ... ì˜ˆì™¸ ì²˜ë¦¬ ...
}
```

  * í”„ë¡œê·¸ë¨ì˜ ì‹œì‘ì ì´ë‹¤.
  * `argc`, `argv`ëŠ” í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•  ë•Œ ì „ë‹¬í•˜ëŠ” ì¸ìì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í„°ë¯¸ë„ì—ì„œ `my_client.exe --auto`ì™€ ê°™ì´ ì‹¤í–‰í•˜ë©´, `--auto`ë¼ëŠ” ì¸ìë¥¼ ê°ì§€í•˜ì—¬ `auto_mode`ë¥¼ í™œì„±í™”í•œë‹¤.
  * í”„ë¡œê·¸ë¨ì€ **ì—°ê²° -\> í†µì‹  -\> ì—°ê²° ì¢…ë£Œ**ì˜ ëª…í™•í•œ ìˆœì„œë¡œ ë™ì‘í•œë‹¤.

#### ë™ì‘ ìˆœì„œ ìš”ì•½
1.  `main` í•¨ìˆ˜ì—ì„œ `SynchronousEchoClient` ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.
2.  `connect_to_server`ë¥¼ í˜¸ì¶œí•˜ì—¬ ì„œë²„ì— ì—°ê²°ì„ ì‹œë„í•œë‹¤. ì—°ê²°ì´ ì™„ë£Œë  ë•Œê¹Œì§€ **ëŒ€ê¸° (ë¸”ë¡œí‚¹)**í•œë‹¤.
3.  í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ `--auto` ì¸ìê°€ ìˆì—ˆëŠ”ì§€ í™•ì¸í•˜ì—¬ **ëŒ€í™”í˜• ëª¨ë“œ** ë˜ëŠ” **ìë™ í…ŒìŠ¤íŠ¸ ëª¨ë“œ**ë¥¼ ê²°ì •í•œë‹¤.
4.  ì„ íƒëœ ëª¨ë“œë¥¼ ì‹¤í–‰í•œë‹¤.
      * **ëŒ€í™”í˜• ëª¨ë“œ**: ì‚¬ìš©ì ì…ë ¥ì„ ê¸°ë‹¤ë¦°ë‹¤. ì‚¬ìš©ìê°€ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ê³  ì—”í„°ë¥¼ ì¹˜ë©´ `send_and_receive_message` í•¨ìˆ˜ê°€ í˜¸ì¶œëœë‹¤.
      * **ìë™ í…ŒìŠ¤íŠ¸ ëª¨ë“œ**: ë¯¸ë¦¬ ì •ì˜ëœ ë©”ì‹œì§€ë¥¼ ìˆœì„œëŒ€ë¡œ `send_and_receive_message` í•¨ìˆ˜ë¥¼ í†µí•´ ë³´ë‚¸ë‹¤.
5.  `send_and_receive_message` í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ,
      * ë©”ì‹œì§€ë¥¼ ì„œë²„ë¡œ ì „ì†¡í•˜ê³  ì™„ë£Œë  ë•Œê¹Œì§€ **ëŒ€ê¸° (ë¸”ë¡œí‚¹)**í•œë‹¤.
      * ì„œë²„ë¡œë¶€í„° ì‘ë‹µì´ ì˜¬ ë•Œê¹Œì§€ **ëŒ€ê¸° (ë¸”ë¡œí‚¹)**í•œë‹¤.
      * ë°›ì€ ì‘ë‹µì„ í™”ë©´ì— ì¶œë ¥í•œë‹¤.
6.  ë£¨í”„ê°€ ëë‚˜ë©´(ì‚¬ìš©ìê°€ 'quit'ì„ ì…ë ¥í•˜ê±°ë‚˜ í…ŒìŠ¤íŠ¸ê°€ ì™„ë£Œë˜ë©´) `disconnect` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì—°ê²°ì„ ì¢…ë£Œí•˜ê³  í”„ë¡œê·¸ë¨ì„ ë§ˆì¹œë‹¤.  
  
  
### 3.1.4 ì‹¤í–‰ ë° í…ŒìŠ¤íŠ¸

**1. ì„œë²„ ì‹¤í–‰:**
Visual Studioì—ì„œ ì„œë²„ í”„ë¡œì íŠ¸ë¥¼ ë¹Œë“œí•˜ê³  ì‹¤í–‰í•œë‹¤.

```
Echo ì„œë²„ê°€ í¬íŠ¸ 31400ì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.
Echo ì„œë²„ ì‹¤í–‰ ì¤‘... (Ctrl+Cë¡œ ì¢…ë£Œ)
```

**2. í´ë¼ì´ì–¸íŠ¸ ì‹¤í–‰:**

ìƒˆë¡œìš´ ì½˜ì†” ì°½ì—ì„œ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‹¤í–‰í•œë‹¤.

```
# ëŒ€í™”í˜• ëª¨ë“œ
> SynchronousEchoClient.exe

# ìë™ í…ŒìŠ¤íŠ¸ ëª¨ë“œ  
> SynchronousEchoClient.exe --auto
```

**3. ì‹¤í–‰ ê²°ê³¼:**

ì„œë²„ ì¸¡ ì¶œë ¥:
```
Echo ì„œë²„ê°€ í¬íŠ¸ 31400ì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.
Echo ì„œë²„ ì‹¤í–‰ ì¤‘... (Ctrl+Cë¡œ ì¢…ë£Œ)

í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤: 127.0.0.1:52341
ë°›ì€ ë©”ì‹œì§€ [13ë°”ì´íŠ¸]: Hello, Server!
ì‘ë‹µ ì „ì†¡: Echo: Hello, Server!
ë°›ì€ ë©”ì‹œì§€ [14ë°”ì´íŠ¸]: Test message 1
ì‘ë‹µ ì „ì†¡: Echo: Test message 1
í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ì„ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤.
```

í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì¶œë ¥:
```
ì„œë²„ì— ì„±ê³µì ìœ¼ë¡œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤: 127.0.0.1:31400

=== Echo í´ë¼ì´ì–¸íŠ¸ ì‹œì‘ ===
ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš” ('quit' ì…ë ¥ ì‹œ ì¢…ë£Œ):

> Hello, Server!
ì „ì†¡: Hello, Server!
ìˆ˜ì‹ : Echo: Hello, Server!

> Test message 1
ì „ì†¡: Test message 1
ìˆ˜ì‹ : Echo: Test message 1

> quit
í´ë¼ì´ì–¸íŠ¸ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.
ì„œë²„ì™€ì˜ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.
```
  
</br>     
</br>     


## 3.2 TCP ì†Œì¼“ í”„ë¡œê·¸ë˜ë° ê¸°ì´ˆ

### 3.2.1 TCP ì†Œì¼“ì˜ ê¸°ë³¸ ê°œë…
TCP(Transmission Control Protocol)ëŠ” ì—°ê²° ì§€í–¥ì ì´ê³  ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë°ì´í„° ì „ì†¡ì„ ì œê³µí•˜ëŠ” í”„ë¡œí† ì½œì´ë‹¤.

**TCPì˜ ì£¼ìš” íŠ¹ì§•:**
- **ì—°ê²° ì§€í–¥**: í†µì‹  ì „ì— ì—°ê²°ì„ ì„¤ì •í•´ì•¼ í•¨
- **ì‹ ë¢°ì„±**: ë°ì´í„° ì†ì‹¤, ì¤‘ë³µ, ìˆœì„œ ë°”ë€œì„ ë°©ì§€
- **íë¦„ ì œì–´**: ì†¡ì‹ ìì™€ ìˆ˜ì‹ ìì˜ ì²˜ë¦¬ ì†ë„ ì¡°ì ˆ
- **í˜¼ì¡ ì œì–´**: ë„¤íŠ¸ì›Œí¬ ìƒí™©ì— ë”°ë¥¸ ì „ì†¡ ì†ë„ ì¡°ì ˆ

```cpp
// TCP ì—°ê²°ì˜ ìƒëª…ì£¼ê¸°
class TCPConnectionLifecycle 
{
public:
    void demonstrate_tcp_lifecycle() 
    {
        std::cout << "=== TCP ì—°ê²° ìƒëª…ì£¼ê¸° ===\n" << std::endl;
        
        try 
        {
            io_context io_context;
            
            // 1. ì†Œì¼“ ìƒì„±
            tcp::socket socket(io_context);
            std::cout << "1. ì†Œì¼“ ìƒì„± ì™„ë£Œ" << std::endl;
            
            // 2. ì„œë²„ì— ì—°ê²° ì‹œë„
            tcp::endpoint server_endpoint(
                boost::asio::ip::make_address("127.0.0.1"), 31400);
            
            boost::system::error_code connect_error;
            socket.connect(server_endpoint, connect_error);
            
            if (connect_error) {
                std::cout << "2. ì—°ê²° ì‹¤íŒ¨: " << connect_error.message() << std::endl;
                return;
            }
            
            std::cout << "2. ì„œë²„ ì—°ê²° ì„±ê³µ" << std::endl;
            std::cout << "   ë¡œì»¬ ì£¼ì†Œ: " << socket.local_endpoint() << std::endl;
            std::cout << "   ì›ê²© ì£¼ì†Œ: " << socket.remote_endpoint() << std::endl;
            
            // 3. ë°ì´í„° ì „ì†¡
            std::string message = "Hello, TCP World!";
            write(socket, boost::asio::buffer(message));
            std::cout << "3. ë°ì´í„° ì „ì†¡: " << message << std::endl;
            
            // 4. ë°ì´í„° ìˆ˜ì‹ 
            std::array<char, 1024> buffer;
            size_t received_bytes = socket.read_some(boost::asio::buffer(buffer));
            std::string received_data(buffer.data(), received_bytes);
            std::cout << "4. ë°ì´í„° ìˆ˜ì‹ : " << received_data << std::endl;
            
            // 5. ì—°ê²° ì¢…ë£Œ (graceful shutdown)
            boost::system::error_code shutdown_error;
            socket.shutdown(tcp::socket::shutdown_both, shutdown_error);
            
            socket.close();
            std::cout << "5. ì—°ê²° ì •ìƒ ì¢…ë£Œ" << std::endl;
            
        } catch (std::exception& e) {
            std::cerr << "TCP ì—°ê²° ì¤‘ ì˜¤ë¥˜: " << e.what() << std::endl;
        }
    }
    
private:
    io_context io_context_;
};
```

### 3.2.2 ì†Œì¼“ ì˜µì…˜ê³¼ ì„¤ì •
TCP ì†Œì¼“ì˜ ë™ì‘ì„ ì„¸ë°€í•˜ê²Œ ì œì–´í•˜ê¸° ìœ„í•œ ë‹¤ì–‘í•œ ì˜µì…˜ë“¤ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.  

```cpp
// ì†Œì¼“ ì˜µì…˜ ì„¤ì • í´ë˜ìŠ¤
class SocketConfiguration 
{
public:
    static void configure_server_socket(tcp::acceptor& acceptor) 
    {
        std::cout << "=== ì„œë²„ ì†Œì¼“ ì„¤ì • ===\n" << std::endl;
        
        try 
        {
            // SO_REUSEADDR: ì£¼ì†Œ ì¬ì‚¬ìš© í—ˆìš© (ì„œë²„ ì¬ì‹œì‘ ì‹œ ìœ ìš©)
            acceptor.set_option(boost::asio::socket_base::reuse_address(true));
            std::cout << "âœ“ ì£¼ì†Œ ì¬ì‚¬ìš© í™œì„±í™”" << std::endl;
            
            // SO_KEEPALIVE: ì—°ê²° ìœ ì§€ í™•ì¸
            // acceptor.set_option(boost::asio::socket_base::keep_alive(true));
            // std::cout << "âœ“ Keep-Alive í™œì„±í™”" << std::endl;
            
        } catch (std::exception& e) {
            std::cerr << "ì„œë²„ ì†Œì¼“ ì„¤ì • ì˜¤ë¥˜: " << e.what() << std::endl;
        }
    }
    
    static void configure_client_socket(tcp::socket& socket) 
    {
        std::cout << "=== í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ ì„¤ì • ===\n" << std::endl;
        
        try 
        {
            // TCP_NODELAY: Nagle ì•Œê³ ë¦¬ì¦˜ ë¹„í™œì„±í™” (ì§€ì—° ìµœì†Œí™”)
            socket.set_option(boost::asio::ip::tcp::no_delay(true));
            std::cout << "âœ“ TCP No Delay í™œì„±í™” (Nagle ì•Œê³ ë¦¬ì¦˜ ë¹„í™œì„±í™”)" << std::endl;
            
            // SO_KEEPALIVE: ì—°ê²° ìƒíƒœ í™•ì¸
            socket.set_option(boost::asio::socket_base::keep_alive(true));
            std::cout << "âœ“ Keep-Alive í™œì„±í™”" << std::endl;
            
            // SO_RCVBUF: ìˆ˜ì‹  ë²„í¼ í¬ê¸° ì„¤ì •
            socket.set_option(boost::asio::socket_base::receive_buffer_size(65536));
            std::cout << "âœ“ ìˆ˜ì‹  ë²„í¼ í¬ê¸°: 64KB" << std::endl;
            
            // SO_SNDBUF: ì†¡ì‹  ë²„í¼ í¬ê¸° ì„¤ì •
            socket.set_option(boost::asio::socket_base::send_buffer_size(65536));
            std::cout << "âœ“ ì†¡ì‹  ë²„í¼ í¬ê¸°: 64KB" << std::endl;
            
            // SO_LINGER: ì†Œì¼“ ì¢…ë£Œ ì‹œ ëŒ€ê¸° ì‹œê°„ ì„¤ì •
            boost::asio::socket_base::linger linger_option(true, 0);
            socket.set_option(linger_option);
            std::cout << "âœ“ Linger ì„¤ì •: ì¦‰ì‹œ ì¢…ë£Œ" << std::endl;
            
        } 
        catch (std::exception& e) 
        {
            std::cerr << "í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ ì„¤ì • ì˜¤ë¥˜: " << e.what() << std::endl;
        }
    }
    
    static void print_socket_info(const tcp::socket& socket) 
    {
        std::cout << "\n=== ì†Œì¼“ ì •ë³´ ===\n" << std::endl;
        
        try 
        {
            if (socket.is_open()) 
            {
                std::cout << "ì†Œì¼“ ìƒíƒœ: ì—´ë¦¼" << std::endl;
                std::cout << "ë¡œì»¬ ì—”ë“œí¬ì¸íŠ¸: " << socket.local_endpoint() << std::endl;
                std::cout << "ì›ê²© ì—”ë“œí¬ì¸íŠ¸: " << socket.remote_endpoint() << std::endl;
                
                // ì˜µì…˜ ê°’ ì¡°íšŒ
                boost::asio::socket_base::receive_buffer_size rcv_buf_option;
                socket.get_option(rcv_buf_option);
                std::cout << "ìˆ˜ì‹  ë²„í¼ í¬ê¸°: " << rcv_buf_option.value() << " bytes" << std::endl;
                
                boost::asio::socket_base::send_buffer_size snd_buf_option;
                socket.get_option(snd_buf_option);
                std::cout << "ì†¡ì‹  ë²„í¼ í¬ê¸°: " << snd_buf_option.value() << " bytes" << std::endl;
                
            } 
            else 
            {
                std::cout << "ì†Œì¼“ ìƒíƒœ: ë‹«í˜" << std::endl;
            }
        } 
        catch (std::exception& e) 
        {
            std::cerr << "ì†Œì¼“ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜: " << e.what() << std::endl;
        }
    }
};
```

### 3.2.3 ì—ëŸ¬ ì²˜ë¦¬ì™€ ì˜ˆì™¸ ìƒí™©
ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” ë‹¤ì–‘í•œ ì˜¤ë¥˜ ìƒí™©ì„ ì ì ˆíˆ ì²˜ë¦¬í•´ì•¼ í•œë‹¤.  

```cpp
// í¬ê´„ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ ì˜ˆì œ
class ErrorHandlingExample 
{
public:
    void demonstrate_error_handling() 
    {
        std::cout << "=== ì—ëŸ¬ ì²˜ë¦¬ ë°ëª¨ ===\n" << std::endl;
        
        io_context io_context;
        tcp::socket socket(io_context);
        
        // 1. ì—°ê²° ì˜¤ë¥˜ ì²˜ë¦¬
        test_connection_errors(socket);
        
        // 2. ì†¡ìˆ˜ì‹  ì˜¤ë¥˜ ì²˜ë¦¬  
        test_io_errors(socket);
        
        // 3. íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬
        test_timeout_handling(socket);
    }
    
private:
    void test_connection_errors(tcp::socket& socket) 
    {
        std::cout << "1. ì—°ê²° ì˜¤ë¥˜ í…ŒìŠ¤íŠ¸\n" << std::endl;
        
        // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì„œë²„ì— ì—°ê²° ì‹œë„
        tcp::endpoint invalid_endpoint(
            boost::asio::ip::make_address("192.168.255.255"), 12345);
        
        boost::system::error_code error;
        socket.connect(invalid_endpoint, error);
        
        if (error) 
        {
            std::cout << "ì˜ˆìƒëœ ì—°ê²° ì˜¤ë¥˜ ë°œìƒ:" << std::endl;
            std::cout << "  ì˜¤ë¥˜ ì½”ë“œ: " << error.value() << std::endl;
            std::cout << "  ì˜¤ë¥˜ ë©”ì‹œì§€: " << error.message() << std::endl;
            std::cout << "  ì˜¤ë¥˜ ë²”ì£¼: " << error.category().name() << std::endl;
            
            // ì˜¤ë¥˜ ìœ í˜•ë³„ ì²˜ë¦¬
            if (error == boost::asio::error::connection_refused) {
                std::cout << "  â†’ ì—°ê²° ê±°ë¶€ë¨" << std::endl;
            } else if (error == boost::asio::error::host_unreachable) {
                std::cout << "  â†’ í˜¸ìŠ¤íŠ¸ì— ë„ë‹¬í•  ìˆ˜ ì—†ìŒ" << std::endl;
            } else if (error == boost::asio::error::timed_out) {
                std::cout << "  â†’ ì—°ê²° ì‹œê°„ ì´ˆê³¼" << std::endl;
            } else {
                std::cout << "  â†’ ê¸°íƒ€ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜" << std::endl;
            }
        }
        
        std::cout << std::endl;
    }
    
    void test_io_errors(tcp::socket& socket) 
    {
        std::cout << "2. I/O ì˜¤ë¥˜ í…ŒìŠ¤íŠ¸\n" << std::endl;
        
        if (!socket.is_open()) 
        {
            std::cout << "ì†Œì¼“ì´ ë‹«í˜€ìˆìŒ - I/O ì‘ì—… ì‹œë®¬ë ˆì´ì…˜\n" << std::endl;
            
            // ë‹«íŒ ì†Œì¼“ì— ì“°ê¸° ì‹œë„
            std::string message = "Test message";
            boost::system::error_code write_error;
            
            try 
            {
                write(socket, boost::asio::buffer(message), write_error);
            } 
            catch (std::exception& e) 
            {
                std::cout << "ì“°ê¸° ì˜ˆì™¸: " << e.what() << std::endl;
            }
            
            if (write_error) 
            {
                std::cout << "ì“°ê¸° ì˜¤ë¥˜: " << write_error.message() << std::endl;
            }
            
            // ë‹«íŒ ì†Œì¼“ì—ì„œ ì½ê¸° ì‹œë„
            std::array<char, 1024> buffer;
            boost::system::error_code read_error;
            
            try 
            {
                socket.read_some(boost::asio::buffer(buffer), read_error);
            } 
            catch (std::exception& e) 
            {
                std::cout << "ì½ê¸° ì˜ˆì™¸: " << e.what() << std::endl;
            }
            
            if (read_error) 
            {
                std::cout << "ì½ê¸° ì˜¤ë¥˜: " << read_error.message() << std::endl;
            }
        }
        
        std::cout << std::endl;
    }
    
    void test_timeout_handling(tcp::socket& socket) 
    {
        std::cout << "3. íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸\n" << std::endl;
        
        // ì‹¤ì œ íƒ€ì„ì•„ì›ƒ í…ŒìŠ¤íŠ¸ëŠ” ë³µì¡í•˜ë¯€ë¡œ ì‹œë®¬ë ˆì´ì…˜
        std::cout << "íƒ€ì„ì•„ì›ƒ ì‹œë‚˜ë¦¬ì˜¤:" << std::endl;
        std::cout << "  - ì½ê¸° íƒ€ì„ì•„ì›ƒ: 30ì´ˆ" << std::endl;
        std::cout << "  - ì“°ê¸° íƒ€ì„ì•„ì›ƒ: 10ì´ˆ" << std::endl;
        std::cout << "  - ì—°ê²° íƒ€ì„ì•„ì›ƒ: 5ì´ˆ" << std::endl;
        
        // Windowsì—ì„œ ì†Œì¼“ íƒ€ì„ì•„ì›ƒ ì„¤ì • ì˜ˆì œ
        #ifdef _WIN32
        if (socket.is_open()) 
        {
            try 
            {
                // ìˆ˜ì‹  íƒ€ì„ì•„ì›ƒ ì„¤ì • (ë°€ë¦¬ì´ˆ)
                DWORD recv_timeout = 30000; // 30ì´ˆ
                socket.set_option(boost::asio::detail::socket_option::integer<SOL_SOCKET, SO_RCVTIMEO>(recv_timeout));
                
                // ì†¡ì‹  íƒ€ì„ì•„ì›ƒ ì„¤ì •
                DWORD send_timeout = 10000; // 10ì´ˆ  
                socket.set_option(boost::asio::detail::socket_option::integer<SOL_SOCKET, SO_SNDTIMEO>(send_timeout));
                
                std::cout << "âœ“ ì†Œì¼“ íƒ€ì„ì•„ì›ƒ ì„¤ì • ì™„ë£Œ" << std::endl;
            } 
            catch (std::exception& e) 
            {
                std::cout << "íƒ€ì„ì•„ì›ƒ ì„¤ì • ì‹¤íŒ¨: " << e.what() << std::endl;
            }
        }
        #endif
        
        std::cout << std::endl;
    }
};
```

### 3.2.4 ë²„í¼ ê´€ë¦¬ì™€ ë°ì´í„° ì²˜ë¦¬
íš¨ìœ¨ì ì¸ ë²„í¼ ê´€ë¦¬ëŠ” ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ì´ë‹¤.

```cpp
// ë²„í¼ ê´€ë¦¬ í´ë˜ìŠ¤
class BufferManagement 
{
public:
    // ë‹¤ì–‘í•œ ë²„í¼ íƒ€ì… ì‚¬ìš© ì˜ˆì œ
    void demonstrate_buffer_types() 
    {
        std::cout << "=== ë²„í¼ íƒ€ì… ë°ëª¨ ===\n" << std::endl;
        
        // 1. std::array ë²„í¼
        std::array<char, 1024> array_buffer;
        auto array_asio_buffer = boost::asio::buffer(array_buffer);
        std::cout << "1. std::array ë²„í¼ í¬ê¸°: " << array_asio_buffer.size() << std::endl;
        
        // 2. std::vector ë²„í¼
        std::vector<char> vector_buffer(2048);
        auto vector_asio_buffer = boost::asio::buffer(vector_buffer);
        std::cout << "2. std::vector ë²„í¼ í¬ê¸°: " << vector_asio_buffer.size() << std::endl;
        
        // 3. std::string ë²„í¼
        std::string string_buffer = "Hello, Network World!";
        auto string_asio_buffer = boost::asio::buffer(string_buffer);
        std::cout << "3. std::string ë²„í¼ í¬ê¸°: " << string_asio_buffer.size() << std::endl;
        
        // 4. C ìŠ¤íƒ€ì¼ ë°°ì—´
        char c_array[512];
        auto c_array_asio_buffer = boost::asio::buffer(c_array, sizeof(c_array));
        std::cout << "4. C ë°°ì—´ ë²„í¼ í¬ê¸°: " << c_array_asio_buffer.size() << std::endl;
        
        // 5. ë™ì  ë²„í¼ (boost::asio::dynamic_buffer)
        std::string dynamic_string;
        auto dynamic_buffer = boost::asio::dynamic_buffer(dynamic_string);
        std::cout << "5. ë™ì  ë²„í¼ ì´ˆê¸° í¬ê¸°: " << dynamic_buffer.size() << std::endl;
        
        std::cout << std::endl;
    }
    
    // íŒ¨í‚· ê¸°ë°˜ ë°ì´í„° ì²˜ë¦¬
    void demonstrate_packet_processing() 
    {
        std::cout << "=== íŒ¨í‚· ì²˜ë¦¬ ë°ëª¨ ===\n" << std::endl;
        
        // ì‹œë®¬ë ˆì´ì…˜ëœ ë„¤íŠ¸ì›Œí¬ ë°ì´í„°
        std::string simulated_data = "HEADER1:Hello World!HEADER2:Game Data";
        
        BufferProcessor processor;
        processor.process_stream_data(simulated_data);
    }
    
private:
    class BufferProcessor 
    {
    private:
        std::string buffer_;
        static constexpr size_t HEADER_SIZE = 8; // "HEADER1:" ë“±
        
    public:
        void process_stream_data(const std::string& new_data) 
        {
            buffer_ += new_data;
            
            std::cout << "ìˆ˜ì‹  ë°ì´í„°: " << new_data << std::endl;
            std::cout << "ë²„í¼ ì „ì²´: " << buffer_ << std::endl;
            
            // íŒ¨í‚· ì¶”ì¶œ ì‹œë„
            while (try_extract_packet()) {
                // íŒ¨í‚· ì²˜ë¦¬ ì™„ë£Œ
            }
            
            std::cout << "ë‚¨ì€ ë²„í¼: " << buffer_ << std::endl;
            std::cout << std::endl;
        }
        
    private:
        bool try_extract_packet() 
        {
            if (buffer_.length() < HEADER_SIZE) {
                return false; // í—¤ë”ë„ ì—†ìŒ
            }
            
            // í—¤ë” íŒŒì‹± (ê°„ë‹¨í•œ ì˜ˆì œ)
            std::string header = buffer_.substr(0, HEADER_SIZE);
            
            if (header.substr(0, 6) == "HEADER") 
            {
                // íŒ¨í‚· ê¸¸ì´ ê²°ì • (ì‹¤ì œë¡œëŠ” í—¤ë”ì—ì„œ ì½ì–´ì˜´)
                size_t packet_length = 0;
                if (header == "HEADER1:") {
                    packet_length = HEADER_SIZE + 12; // "Hello World!"
                } else if (header == "HEADER2:") {
                    packet_length = HEADER_SIZE + 9;  // "Game Data"
                }
                
                if (buffer_.length() >= packet_length) 
                {
                    // ì™„ì „í•œ íŒ¨í‚· ì¶”ì¶œ
                    std::string packet = buffer_.substr(0, packet_length);
                    buffer_.erase(0, packet_length);
                    
                    std::string payload = packet.substr(HEADER_SIZE);
                    std::cout << "  â†’ íŒ¨í‚· ì²˜ë¦¬: " << header.substr(0, 7) 
                             << " ë°ì´í„°: " << payload << std::endl;
                    
                    return true; // ë” ë§ì€ íŒ¨í‚·ì´ ìˆì„ ìˆ˜ ìˆìŒ
                }
            }
            
            return false; // ì™„ì „í•œ íŒ¨í‚· ì—†ìŒ
        }
    };
};
```
    
ì´ ì½”ë“œëŠ” TCP/IPì™€ ê°™ì€ ìŠ¤íŠ¸ë¦¼(Stream) ê¸°ë°˜ í†µì‹ ì—ì„œ ë°œìƒí•˜ëŠ” **'ë°ì´í„° ê²½ê³„ ë¬¸ì œ'ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ íŒ¨í‚· íŒŒì„œ(Packet Parser)** ë˜ëŠ” **ë²„í¼ ì²˜ë¦¬ê¸°(Buffer Processor)** í´ë˜ìŠ¤ì´ë‹¤. ğŸ§  
  
ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ ë°ì´í„°ë¥¼ ë°›ì„ ë•Œ, ë³´ë‚¸ ìª½ì—ì„œ í•œ ë²ˆì— ë³´ëƒˆë‹¤ê³  í•´ì„œ ë°›ëŠ” ìª½ì—ì„œë„ í•œ ë²ˆì— ë°›ëŠ”ë‹¤ëŠ” ë³´ì¥ì´ ì—†ë‹¤. ë°ì´í„°ê°€ ì˜ë ¤ì„œ ì˜¤ê±°ë‚˜ ì—¬ëŸ¬ ê°œê°€ í•©ì³ì ¸ì„œ ì˜¬ ìˆ˜ ìˆì£ . ì´ ì½”ë“œëŠ” ì´ë ‡ê²Œ ì¡°ê°ë‚˜ê±°ë‚˜ ë¶™ì–´ì„œ ì˜¤ëŠ” ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ì˜ë¯¸ ìˆëŠ” ë‹¨ìœ„ì¸ **íŒ¨í‚·(Packet)**ìœ¼ë¡œ ì¬ì¡°ë¦½í•˜ëŠ” ì—­í• ì„ í•œë‹¤.  

#### ğŸ¤” ì™œ ì´ëŸ° ì½”ë“œê°€ í•„ìš”í•œê°€? (The Problem)
TCP í†µì‹ ì€ ë§ˆì¹˜ ë¬¼ì´ íë¥´ëŠ” íŒŒì´í”„ì™€ ê°™ë‹¤. ë°ì´í„°ë¥¼ ë³´ë‚´ë©´ íŒŒì´í”„ë¥¼ í†µí•´ ìˆœì„œëŠ” ë³´ì¥ë˜ì–´ ì „ë‹¬ë˜ì§€ë§Œ, ì–´ë””ì„œë¶€í„° ì–´ë””ê¹Œì§€ê°€ í•˜ë‚˜ì˜ ë©ì–´ë¦¬ì¸ì§€ëŠ” ì•Œë ¤ì£¼ì§€ ì•ŠëŠ”ë‹¤.  
  
ì˜ˆë¥¼ ë“¤ì–´, ì„œë²„ê°€ `"HEADER1:Hello World!"`ì™€ `"HEADER2:Game Data"`ë¼ëŠ” ë‘ ê°œì˜ ë©”ì‹œì§€ë¥¼ ì—°ë‹¬ì•„ ë³´ëƒˆì„ ë•Œ, í´ë¼ì´ì–¸íŠ¸ëŠ” ì•„ë˜ì™€ ê°™ì´ ë°ì´í„°ë¥¼ ë°›ì„ ìˆ˜ ìˆë‹¤.

  * **Case 1 (ë°ì´í„°ê°€ ì˜ë¦¼):** `"HEADER1:Hel"` -\> `"lo World!HEADER2:Game"` -\> `" Data"`
  * **Case 2 (ë°ì´í„°ê°€ í•©ì³ì§):** `"HEADER1:Hello World!HEADER2:Game Data"`
  * **Case 3 (í˜¼í•©):** `"HEADER1:Hello World!HEAD"` -\> `"ER2:Game Data"`

ì´ëŸ° ìƒí™©ì—ì„œ ì˜ë¯¸ ìˆëŠ” ë©”ì‹œì§€ë¥¼ ì •í™•íˆ êµ¬ë¶„í•´ë‚´ê¸° ìœ„í•´ `BufferProcessor` ê°™ì€ í´ë˜ìŠ¤ê°€ í•„ìš”í•˜ë‹¤.  
    
#### âš™ï¸ ì½”ë“œì˜ ë™ì‘ ë°©ì‹ (How it Works)
ì´ í´ë˜ìŠ¤ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê°„ë‹¨í•œ ê·œì¹™(í”„ë¡œí† ì½œ)ì„ ê¸°ë°˜ìœ¼ë¡œ ë™ì‘í•œë‹¤.
  
1.  ëª¨ë“  íŒ¨í‚·ì€ 8ë°”ì´íŠ¸ í¬ê¸°ì˜ **í—¤ë”(Header)**ë¡œ ì‹œì‘í•œë‹¤. (ì˜ˆ: `HEADER1:`, `HEADER2:`)
2.  í—¤ë”ì˜ ë‚´ìš©ì— ë”°ë¼ **íŒ¨í‚·ì˜ ì „ì²´ ê¸¸ì´**ê°€ ê²°ì •ëœë‹¤.
      * `HEADER1:`: ì „ì²´ ê¸¸ì´ 20 ë°”ì´íŠ¸ (í—¤ë” 8 + ë°ì´í„° 12)
      * `HEADER2:`: ì „ì²´ ê¸¸ì´ 17 ë°”ì´íŠ¸ (í—¤ë” 8 + ë°ì´í„° 9)

#### `process_stream_data(const std::string& new_data)`
ì´ í•¨ìˆ˜ëŠ” ë„¤íŠ¸ì›Œí¬ë¡œë¶€í„° ìƒˆë¡œìš´ ë°ì´í„° ì¡°ê°(`new_data`)ì´ ë„ì°©í•  ë•Œë§ˆë‹¤ í˜¸ì¶œëœë‹¤.

1.  **ë°ì´í„° ëˆ„ì :** ìƒˆë¡œ ë„ì°©í•œ ë°ì´í„°ë¥¼ ë‚´ë¶€ ë²„í¼(`buffer_`) ë’¤ì— ê³„ì† ì´ì–´ ë¶™ì¸ë‹¤.
    ```cpp
    buffer_ += new_data;
    ```
2.  **íŒ¨í‚· ì¶”ì¶œ ì‹œë„:** ë²„í¼ì— ì™„ì„±ëœ íŒ¨í‚·ì´ ìˆëŠ”ì§€ ë°˜ë³µì ìœ¼ë¡œ í™•ì¸í•˜ê³ , ìˆë‹¤ë©´ ì²˜ë¦¬í•œë‹¤.
    ```cpp
    while (try_extract_packet()) {
        // ë£¨í”„ë¥¼ ëŒë©´ì„œ ë²„í¼ì— ìˆëŠ” íŒ¨í‚·ì„ ëª¨ë‘ ì²˜ë¦¬
    }
    ```

#### `try_extract_packet()`
ì´ í•¨ìˆ˜ê°€ ì‹¤ì œ íŒ¨í‚·ì„ ë¶„ì„í•˜ê³  ì¶”ì¶œí•˜ëŠ” í•µì‹¬ ë¡œì§ì´ë‹¤.

1.  **í—¤ë” ê¸¸ì´ í™•ì¸:** ë²„í¼ì— ìµœì†Œí•œ í—¤ë” í¬ê¸°(8ë°”ì´íŠ¸)ë§Œí¼ì˜ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤. ì—†ìœ¼ë©´ ì•„ì§ íŒ¨í‚·ì„ ë§Œë“¤ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ `false`ë¥¼ ë°˜í™˜í•œë‹¤.
2.  **íŒ¨í‚· ê¸¸ì´ ê²°ì •:** í—¤ë”ë¥¼ ë¶„ì„í•˜ì—¬ ì´ íŒ¨í‚·ì˜ **ì „ì²´ ê¸¸ì´(`packet_length`)**ë¥¼ ì•Œì•„ë‚¸ë‹¤.
3.  **ì „ì²´ ê¸¸ì´ í™•ì¸:** í˜„ì¬ ë²„í¼ì— `packet_length` ë§Œí¼ì˜ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤. ë°ì´í„°ê°€ ë¶€ì¡±í•˜ë©´ ì•„ì§ íŒ¨í‚·ì´ ì™„ì„±ë˜ì§€ ì•Šì€ ê²ƒì´ë¯€ë¡œ `false`ë¥¼ ë°˜í™˜í•˜ê³  ë‹¤ìŒ ë°ì´í„°ë¥¼ ê¸°ë‹¤ë¦°ë‹¤.
4.  **íŒ¨í‚· ì¶”ì¶œ ë° ì²˜ë¦¬:** ë²„í¼ì— ì™„ì „í•œ íŒ¨í‚·ì´ ìˆë‹¤ë©´,
      * ë²„í¼ì˜ ë§¨ ì•ì—ì„œ `packet_length` ë§Œí¼ ë°ì´í„°ë¥¼ ì˜ë¼ë‚´ì–´ **ì™„ì „í•œ íŒ¨í‚·**ìœ¼ë¡œ ë§Œë“ ë‹¤.
      * ì²˜ë¦¬í•œ íŒ¨í‚· ë¶€ë¶„ì„ **ë²„í¼ì—ì„œ ì‚­ì œ**í•œë‹¤. (`buffer_.erase(...)`)
      * íŒ¨í‚·ì—ì„œ ìˆœìˆ˜ ë°ì´í„°(Payload) ë¶€ë¶„ì„ ì¶”ì¶œí•˜ì—¬ ì²˜ë¦¬ ë¡œì§ì„ ìˆ˜í–‰í•œë‹¤. (ì—¬ê¸°ì„œëŠ” í™”ë©´ì— ì¶œë ¥)
      * íŒ¨í‚· ì²˜ë¦¬ì— ì„±ê³µí–ˆìœ¼ë¯€ë¡œ `true`ë¥¼ ë°˜í™˜í•œë‹¤. `while` ë£¨í”„ëŠ” ì´ì–´ì„œ ë²„í¼ì— ë˜ ë‹¤ë¥¸ ì™„ì„±ëœ íŒ¨í‚·ì´ ìˆëŠ”ì§€ ë‹¤ì‹œ í™•ì¸í•œë‹¤.
  
#### âœ¨ í•µì‹¬ ìš”ì•½

  * **`buffer_` (ë²„í¼)**: ë°ì´í„° ì¡°ê°ë“¤ì„ ì„ì‹œë¡œ ì €ì¥í•˜ëŠ” ì°½ê³ ì´ë‹¤.
  * **`process_stream_data()` (ì…ê³  ë‹´ë‹¹)**: ì°½ê³ ì— ìƒˆë¡œìš´ ë°ì´í„° ì¡°ê°ë“¤ì„ ê³„ì† ë„£ëŠ” ì—­í• ì„ í•œë‹¤.
  * **`try_extract_packet()` (ì¡°ë¦½ ë° ì¶œê³  ë‹´ë‹¹)**: ì°½ê³ ì˜ ë°ì´í„°ë“¤ì„ ë³´ê³ , ì™„ì„±ëœ ì œí’ˆ(íŒ¨í‚·)ì´ ìˆìœ¼ë©´ ì¡°ë¦½í•´ì„œ êº¼ë‚´ê³ , ì°½ê³ ì—ì„œ í•´ë‹¹ ë¶€í’ˆë“¤ì„ ì œê±°í•œë‹¤.

ì´ ì½”ë“œëŠ” **ë„¤íŠ¸ì›Œí¬ ìŠ¤íŠ¸ë¦¼ ë°ì´í„°ë¥¼ ì•ˆì •ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ í•„ìˆ˜ì ì¸ ë¡œì§**ì„ ë³´ì—¬ì£¼ëŠ” í›Œë¥­í•œ ì˜ˆì œì´ë‹¤.      
  

</br>     
</br>       
    

## 3.3 ë™ê¸° ë°©ì‹ì˜ íŠ¹ì§•ê³¼ í•œê³„

### 3.3.1 ë™ê¸° ë°©ì‹ì˜ ì¥ì 
ë™ê¸° ë°©ì‹ ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì€ ë‹¤ìŒê³¼ ê°™ì€ ì¥ì ì„ ê°€ì§„ë‹¤:

```cpp
// ë™ê¸° ë°©ì‹ì˜ ì¥ì ì„ ë³´ì—¬ì£¼ëŠ” ì˜ˆì œ
class SynchronousAdvantages 
{
public:
    void demonstrate_simplicity() {
        std::cout << "=== ë™ê¸° ë°©ì‹ì˜ ì¥ì  ===\n" << std::endl;
        
        // 1. ì§ê´€ì ì´ê³  ì´í•´í•˜ê¸° ì‰¬ìš´ ì½”ë“œ
        simple_client_example();
        
        // 2. ìˆœì°¨ì  ì‹¤í–‰ìœ¼ë¡œ ì¸í•œ ë””ë²„ê¹… ìš©ì´ì„±
        debugging_friendly_example();
        
        // 3. ì—ëŸ¬ ì²˜ë¦¬ì˜ ëª…í™•ì„±
        clear_error_handling_example();
    }
    
private:
    void simple_client_example() 
    {
        std::cout << "1. ì½”ë“œì˜ ì§ê´€ì„±\n" << std::endl;
        
        std::cout << "ë™ê¸° ë°©ì‹ ì½”ë“œ:" << std::endl;
        std::cout << R"(
    // ì½ê¸° ì‰½ê³  ì´í•´í•˜ê¸° ì‰¬ìš´ ìˆœì°¨ì  ì½”ë“œ
    socket.connect(endpoint);           // 1. ì—°ê²°
    write(socket, buffer("Hello"));     // 2. ì „ì†¡  
    read(socket, response_buffer);      // 3. ìˆ˜ì‹ 
    socket.close();                     // 4. ì¢…ë£Œ
        )" << std::endl;
        
        try {
            io_context io_context;
            tcp::socket socket(io_context);
            
            // ì‹¤ì œ êµ¬í˜„ì€ ê°„ë‹¨í•˜ê³  ì§ê´€ì 
            tcp::endpoint endpoint(boost::asio::ip::make_address("127.0.0.1"), 31400);
            
            boost::system::error_code error;
            socket.connect(endpoint, error);
            
            if (!error) {
                std::string message = "Hello from sync client";
                write(socket, boost::asio::buffer(message), error);
                
                if (!error) {
                    std::array<char, 1024> response;
                    size_t len = socket.read_some(boost::asio::buffer(response), error);
                    
                    if (!error) {
                        std::cout << "ì‘ë‹µ: " << std::string(response.data(), len) << std::endl;
                    }
                }
                
                socket.close();
            }
        } catch (...) {
            std::cout << "ì—°ê²° ì‹¤íŒ¨ (ì˜ˆìƒë¨)" << std::endl;
        }
        
        std::cout << std::endl;
    }
    
    void debugging_friendly_example() 
    {
        std::cout << "2. ë””ë²„ê¹… ì¹œí™”ì \n" << std::endl;
        
        std::cout << "ë™ê¸° ë°©ì‹ì˜ ë””ë²„ê¹… ì¥ì :" << std::endl;
        std::cout << "  âœ“ ë‹¨ê³„ë³„ ì¤‘ë‹¨ì  ì„¤ì • ê°€ëŠ¥" << std::endl;
        std::cout << "  âœ“ ë³€ìˆ˜ ìƒíƒœ ì¶”ì  ìš©ì´" << std::endl;
        std::cout << "  âœ“ í˜¸ì¶œ ìŠ¤íƒ ì¶”ì  ê°„ë‹¨" << std::endl;
        std::cout << "  âœ“ ì‹¤í–‰ íë¦„ ì˜ˆì¸¡ ê°€ëŠ¥" << std::endl;
        
        // ë””ë²„ê¹…í•˜ê¸° ì‰¬ìš´ ì˜ˆì œ
        debug_example_function();
        
        std::cout << std::endl;
    }
    
    void debug_example_function() 
    {
        std::cout << "\në””ë²„ê¹… ì˜ˆì œ í•¨ìˆ˜:" << std::endl;
        
        int step = 1;
        std::cout << "Step " << step++ << ": í•¨ìˆ˜ ì‹œì‘" << std::endl;
        
        std::cout << "Step " << step++ << ": ë³€ìˆ˜ ì´ˆê¸°í™”" << std::endl;
        std::string data = "test data";
        
        std::cout << "Step " << step++ << ": ë°ì´í„° ì²˜ë¦¬" << std::endl;
        data = "processed: " + data;
        
        std::cout << "Step " << step++ << ": ê²°ê³¼ = " << data << std::endl;
        std::cout << "Step " << step++ << ": í•¨ìˆ˜ ì¢…ë£Œ" << std::endl;
    }
    
    void clear_error_handling_example() 
    {
        std::cout << "3. ëª…í™•í•œ ì—ëŸ¬ ì²˜ë¦¬\n" << std::endl;
        
        std::cout << "ë™ê¸° ë°©ì‹ì—ì„œëŠ” ê° ë‹¨ê³„ì˜ ì—ëŸ¬ë¥¼ ì¦‰ì‹œ í™•ì¸ ê°€ëŠ¥:" << std::endl;
        
        try {
            io_context io_context;
            tcp::socket socket(io_context);
            boost::system::error_code error;
            
            // 1ë‹¨ê³„: ì—°ê²°
            tcp::endpoint endpoint(boost::asio::ip::make_address("127.0.0.1"), 31400);
            socket.connect(endpoint, error);
            if (error) {
                std::cout << "  âœ— ì—°ê²° ì‹¤íŒ¨: " << error.message() << std::endl;
                return;
            }
            std::cout << "  âœ“ ì—°ê²° ì„±ê³µ" << std::endl;
            
            // 2ë‹¨ê³„: ë°ì´í„° ì „ì†¡
            std::string message = "test";
            write(socket, boost::asio::buffer(message), error);
            if (error) {
                std::cout << "  âœ— ì „ì†¡ ì‹¤íŒ¨: " << error.message() << std::endl;
                return;
            }
            std::cout << "  âœ“ ì „ì†¡ ì„±ê³µ" << std::endl;
            
            // 3ë‹¨ê³„: ì‘ë‹µ ìˆ˜ì‹ 
            std::array<char, 1024> buffer;
            socket.read_some(boost::asio::buffer(buffer), error);
            if (error && error != boost::asio::error::eof) {
                std::cout << "  âœ— ìˆ˜ì‹  ì‹¤íŒ¨: " << error.message() << std::endl;
                return;
            }
            std::cout << "  âœ“ ìˆ˜ì‹  ì„±ê³µ" << std::endl;
            
        } catch (...) {
            std::cout << "  âœ— ì—°ê²° ì‹¤íŒ¨ (ì„œë²„ ì—†ìŒ)" << std::endl;
        }
        
        std::cout << std::endl;
    }
    
private:
    io_context io_context_;
};
```

### 3.3.2 ë™ê¸° ë°©ì‹ì˜ í•œê³„
í•˜ì§€ë§Œ ë™ê¸° ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ì€ ì‹¬ê°í•œ í•œê³„ë¥¼ ê°€ì§„ë‹¤:

```cpp
// ë™ê¸° ë°©ì‹ì˜ í•œê³„ë¥¼ ë³´ì—¬ì£¼ëŠ” ì˜ˆì œ
class SynchronousLimitations 
{
public:
    void demonstrate_limitations() 
    {
        std::cout << "=== ë™ê¸° ë°©ì‹ì˜ í•œê³„ ===\n" << std::endl;
        
        // 1. í™•ì¥ì„± ë¬¸ì œ
        scalability_problem();
        
        // 2. ë¦¬ì†ŒìŠ¤ ë‚­ë¹„
        resource_waste_problem();
        
        // 3. ë¸”ë¡œí‚¹ ë¬¸ì œ
        blocking_problem();
    }
    
private:
    void scalability_problem() 
    {
        std::cout << "1. í™•ì¥ì„± ë¬¸ì œ\n" << std::endl;
        
        std::cout << "ë™ê¸° ë°©ì‹ì˜ í™•ì¥ì„± í•œê³„:" << std::endl;
        std::cout << "  â€¢ í´ë¼ì´ì–¸íŠ¸ 1ê°œ = ìŠ¤ë ˆë“œ 1ê°œ (ë˜ëŠ” í”„ë¡œì„¸ìŠ¤ 1ê°œ)" << std::endl;
        std::cout << "  â€¢ 1000ëª… ë™ì ‘ = 1000ê°œ ìŠ¤ë ˆë“œ í•„ìš”" << std::endl;
        std::cout << "  â€¢ ìŠ¤ë ˆë“œ ìƒì„±/ê´€ë¦¬ ì˜¤ë²„í—¤ë“œ ê¸‰ì¦" << std::endl;
        
        // ì‹œë®¬ë ˆì´ì…˜: ë‹¤ì¤‘ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬
        simulate_multi_client_overhead();
        
        std::cout << std::endl;
    }
    
    void simulate_multi_client_overhead() 
    {
        std::cout << "\në‹¤ì¤‘ í´ë¼ì´ì–¸íŠ¸ ì‹œë®¬ë ˆì´ì…˜:" << std::endl;
        
        struct ThreadInfo 
        {
            int client_id;
            size_t stack_size_mb;
            std::chrono::milliseconds creation_time;
        };
        
        std::vector<ThreadInfo> threads;
        
        auto start_time = std::chrono::steady_clock::now();
        
        // 100ê°œ ìŠ¤ë ˆë“œ ìƒì„± ì‹œë®¬ë ˆì´ì…˜
        for (int i = 1; i <= 100; ++i) 
        {
            auto creation_start = std::chrono::steady_clock::now();
            
            // ì‹¤ì œë¡œëŠ” std::threadë¥¼ ìƒì„±í•˜ì§€ë§Œ, ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            std::this_thread::sleep_for(std::chrono::microseconds(100)); // ìŠ¤ë ˆë“œ ìƒì„± ì§€ì—°
            
            auto creation_end = std::chrono::steady_clock::now();
            auto creation_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                creation_end - creation_start);
            
            threads.push_back({i, 8, creation_time}); // 8MB ìŠ¤íƒ
            
            if (i % 20 == 0) {
                std::cout << std::format("  {} ìŠ¤ë ˆë“œ ìƒì„±ë¨, ì´ ë©”ëª¨ë¦¬: {}MB\n", 
                                       i, i * 8);
            }
        }
        
        auto total_time = std::chrono::steady_clock::now() - start_time;
        std::cout << std::format("  ì´ ìƒì„± ì‹œê°„: {}ms\n", 
                               std::chrono::duration_cast<std::chrono::milliseconds>(total_time).count());
        std::cout << std::format("  ì´ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: {}MB\n", threads.size() * 8);
        std::cout << std::format("  ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ì˜¤ë²„í—¤ë“œ: ë§¤ìš° ë†’ìŒ\n");
    }
    
    void resource_waste_problem() 
    {
        std::cout << "2. ë¦¬ì†ŒìŠ¤ ë‚­ë¹„ ë¬¸ì œ\n" << std::endl;
        
        std::cout << "ë™ê¸° ë°©ì‹ì˜ ë¦¬ì†ŒìŠ¤ ë‚­ë¹„:" << std::endl;
        std::cout << "  â€¢ I/O ëŒ€ê¸° ì¤‘ CPU ìœ íœ´" << std::endl;
        std::cout << "  â€¢ ìŠ¤ë ˆë“œë‹¹ ìŠ¤íƒ ë©”ëª¨ë¦¬ ì ìœ " << std::endl;
        std::cout << "  â€¢ ë¶ˆí•„ìš”í•œ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­" << std::endl;
        
        demonstrate_cpu_waste();
        
        std::cout << std::endl;
    }
    
    void demonstrate_cpu_waste() 
    {
        std::cout << "\nCPU ë‚­ë¹„ ë°ëª¨:" << std::endl;
        
        auto start = std::chrono::steady_clock::now();
        
        // ì‹œë®¬ë ˆì´ì…˜: I/O ëŒ€ê¸° ì‹œê°„
        std::cout << "  [Thread 1] ë„¤íŠ¸ì›Œí¬ I/O ëŒ€ê¸° ì¤‘... (5ì´ˆ)" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // ì‹¤ì œëŠ” 5ì´ˆì§€ë§Œ ì§§ê²Œ
        
        std::cout << "  [Thread 2] ë””ìŠ¤í¬ I/O ëŒ€ê¸° ì¤‘... (3ì´ˆ)" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(60));
        
        std::cout << "  [Thread 3] ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ëŒ€ê¸° ì¤‘... (2ì´ˆ)" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(40));
        
        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << std::format("  â†’ CPU í™œìš©ë¥ : ë§¤ìš° ë‚®ìŒ (ëŒ€ë¶€ë¶„ ëŒ€ê¸°)\n");
        std::cout << std::format("  â†’ ì‹¤ì œ ì‘ì—… ì‹œê°„: {}ms\n", duration.count());
    }
    
    void blocking_problem() 
    {
        std::cout << "3. ë¸”ë¡œí‚¹ ë¬¸ì œ\n" << std::endl;
        
        std::cout << "ë™ê¸° ë°©ì‹ì˜ ë¸”ë¡œí‚¹ ì´ìŠˆ:" << std::endl;
        std::cout << "  â€¢ ëŠë¦° í´ë¼ì´ì–¸íŠ¸ê°€ ì „ì²´ ì„œë²„ ì˜í–¥" << std::endl;
        std::cout << "  â€¢ I/O ì™„ë£Œê¹Œì§€ ë‹¤ë¥¸ ì‘ì—… ë¶ˆê°€" << std::endl;
        std::cout << "  â€¢ ì‘ë‹µì„± ì €í•˜" << std::endl;
        
        demonstrate_blocking_issue();
        
        std::cout << std::endl;
    }
    
    void demonstrate_blocking_issue() 
    {
        std::cout << "\në¸”ë¡œí‚¹ ì´ìŠˆ ë°ëª¨:" << std::endl;
        
        // ì‹œë®¬ë ˆì´ì…˜: ë™ê¸° ì„œë²„ì˜ ë¸”ë¡œí‚¹ ë¬¸ì œ
        std::cout << "ì‹œë‚˜ë¦¬ì˜¤: í•œ ëª…ì˜ ëŠë¦° í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë²„ ì „ì²´ë¥¼ ì§€ì—°ì‹œí‚´" << std::endl;
        
        auto start = std::chrono::steady_clock::now();
        
        std::cout << "  [ì‹œê°„ 0ì´ˆ] í´ë¼ì´ì–¸íŠ¸ A ì—°ê²°" << std::endl;
        std::cout << "  [ì‹œê°„ 1ì´ˆ] í´ë¼ì´ì–¸íŠ¸ B ì—°ê²° ëŒ€ê¸° ì¤‘..." << std::endl;
        std::cout << "  [ì‹œê°„ 2ì´ˆ] í´ë¼ì´ì–¸íŠ¸ C ì—°ê²° ëŒ€ê¸° ì¤‘..." << std::endl;
        
        // í´ë¼ì´ì–¸íŠ¸ Aê°€ ëŠë¦° ì²˜ë¦¬ë¡œ ì¸í•´ ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ë“¤ì´ ëŒ€ê¸°
        std::cout << "  [ì‹œê°„ 3ì´ˆ] í´ë¼ì´ì–¸íŠ¸ A ëŠë¦° ìš”ì²­ ì²˜ë¦¬ ì¤‘... (5ì´ˆ ì†Œìš”)" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // ì‹¤ì œëŠ” 5ì´ˆ
        
        std::cout << "  [ì‹œê°„ 8ì´ˆ] í´ë¼ì´ì–¸íŠ¸ A ì²˜ë¦¬ ì™„ë£Œ" << std::endl;
        std::cout << "  [ì‹œê°„ 8ì´ˆ] í´ë¼ì´ì–¸íŠ¸ B ë“œë””ì–´ ì²˜ë¦¬ ì‹œì‘" << std::endl;
        std::cout << "  [ì‹œê°„ 8ì´ˆ] í´ë¼ì´ì–¸íŠ¸ CëŠ” ì—¬ì „íˆ ëŒ€ê¸° ì¤‘..." << std::endl;
        
        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << std::format("\n  ê²°ê³¼: ì „ì²´ ì‘ë‹µ ì‹œê°„ ì¦ê°€, ì‚¬ìš©ì ê²½í—˜ ì €í•˜\n");
        std::cout << std::format("  ì¸¡ì •ëœ ì§€ì—°: {}ms (ì‹¤ì œë¡œëŠ” ìˆ˜ ì´ˆ)\n", duration.count());
    }
};
```

### 3.3.3 ê²Œì„ ì„œë²„ì—ì„œì˜ ë™ê¸° ë°©ì‹ í•œê³„

#### 1) ì‹¤ì‹œê°„ì„± ë¬¸ì œ
ë™ê¸° ë°©ì‹ì€ í•œ ìš”ì²­ì´ ëë‚˜ì•¼ ë‹¤ìŒ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆì–´ ì§€ì—°ì´ ëˆ„ì ë˜ê¸° ì‰½ë‹¤. ì´ëŠ” ì¥ë¥´ë³„ ì‘ë‹µ ì‹œê°„ ëª©í‘œì™€ ì •ë©´ìœ¼ë¡œ ì¶©ëŒí•œë‹¤.

* ì¥ë¥´ë³„ ëŒ€ëµì  ëª©í‘œ ì§€ì—° ì‹œê°„ ì˜ˆì‹œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
  * FPS: ì•½ 16ms ì´í•˜(60 FPS í‹± ë£¨í”„ì™€ ë³´ì¡°ë¥¼ ë§ì¶”ê¸° ìœ„í•¨)ì´ë‹¤.
  * RTS: 50ms ì´í•˜ê°€ ê¶Œì¥ëœë‹¤.
  * MMORPG: 100ms ì´í•˜ë¥¼ ì§€í–¥í•œë‹¤.
* ë¬¸ì œì˜ ë³¸ì§ˆì€ â€œí—¤ë“œ-ì˜¤ë¸Œ-ë¼ì¸ ë¸”ë¡œí‚¹â€ì´ ë‹¤. ê°€ë²¼ìš´ ì´ë™ ìš”ì²­ì´ ìˆë”ë¼ë„, ê·¸ ì•ì— ë¬´ê±°ìš´ ìš”ì²­(ì˜ˆ: DB ì¡°íšŒ 50ms, ìŠ¤í‚¬ íŒì • 100ms)ì´ ìë¦¬í•˜ë©´ ì´ë™ ìš”ì²­ì´ ì¤„ ì„œì„œ ê¸°ë‹¤ë ¤ì•¼ í•œë‹¤.
* ì˜ˆì‹œ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ Move(5ms) â†’ Attack(50ms) â†’ Move(5ms) â†’ Cast Spell(100ms) â†’ Move(5ms)ë¥¼ ìˆœì°¨ ì²˜ë¦¬í•˜ë©´ ë§ˆì§€ë§‰ MoveëŠ” ì´ˆê¸° ì…ë ¥ ì‹œì ìœ¼ë¡œë¶€í„° ì´ 165ms ë’¤ì—ì•¼ ì™„ë£Œë˜ë©°, FPSë‚˜ RTSì˜ ì§€ì—° ì˜ˆì‚°ì„ í¬ê²Œ ì´ˆê³¼í•œë‹¤.
* ê²°ê³¼ì ìœ¼ë¡œ ì…ë ¥-ì‘ë‹µ ë£¨í”„ê°€ ëŠê¸°ê³ , í”¼í‚¹Â·ì—ì„Â·íŒ¨ë§ ê°™ì€ íƒ€ì´ë° ê¸°ë°˜ ìƒí˜¸ì‘ìš©ì˜ ì²´ê° í’ˆì§ˆì´ ê¸‰ê²©íˆ ë‚˜ë¹ ì§„ë‹¤.

##### ì¶”ê°€ë¡œ ê³ ë ¤í•  ì§€ì 
* ê¼¬ë¦¬ ì§€ì—°(tail latency) ì¦í­: ê·¹ì†Œìˆ˜ì˜ ëŠë¦° ìš”ì²­ì´ ì „ì²´ íŒŒì´í”„ë¼ì¸ì˜ í‰ê· ë¿ ì•„ë‹ˆë¼ P95/P99 ì§€ì—°ì„ ì•…í™”ì‹œì¼œ ì²´ê° í’ˆì§ˆì„ ë§ê°€ëœ¨ë¦°ë‹¤.
* íƒ€ì„ì•„ì›ƒÂ·ì¬ì‹œë„ í­ì¦: ëŠë¦° ë™ê¸° í˜¸ì¶œì´ ì—°ì‡„ íƒ€ì„ì•„ì›ƒì„ ìœ ë°œí•˜ê³ , ì¬ì‹œë„ê°€ ë˜ ì„œë²„ ë¶€í•˜ë¥¼ í‚¤ìš°ëŠ” ì•…ìˆœí™˜ì´ ìƒê¸´ë‹¤.
* í˜¼í•© ì‘ì—…ëŸ‰ì—ì„œì˜ ë¶ˆê³µì •ì„±: ê°€ë²¼ìš´ ì½ê¸°ì™€ ë¬´ê±°ìš´ ì“°ê¸°ê°€ ê°™ì€ íì— ì„ì´ë©´ ê°€ë²¼ìš´ ìš”ì²­ë„ ì¤„ê³§ ì§€ì—°ëœë‹¤.
  

#### 2) ë™ì‹œ ì ‘ì†ì(ë™ì ‘) ìˆ˜ ì œí•œ
ë™ê¸° ëª¨ë¸ì€ â€œìš”ì²­ 1ê±´ â†” ìŠ¤ë ˆë“œ 1ê°œâ€ ê°™ì€ ë§¤í•‘ì„ ìì£¼ ê°•ì œí•´ ë¦¬ì†ŒìŠ¤ íš¨ìœ¨ì´ ë–¨ì–´ì§„ë‹¤.
 
* ì˜ˆì‹œë¡œ ìµœëŒ€ ìŠ¤ë ˆë“œ ìˆ˜ê°€ 100/500/1000ì¸ ì„œë²„ì—ì„œ ìŠ¤ë ˆë“œë‹¹ 8MBë¥¼ ì¡ì•„ë„, ë™ì ‘ì´ ëŠ˜ìˆ˜ë¡ ë©”ëª¨ë¦¬ ìƒí•œê³¼ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ë¹„ìš©ì´ ë¹ ë¥´ê²Œ ì»¤ì§„ë‹¤.
* ìŠ¤ë ˆë“œ ìˆ˜ê°€ ëŠ˜ë©´ ë‹¤ìŒ ë¬¸ì œê°€ ëˆ„ì ëœë‹¤.  
  * ë©”ëª¨ë¦¬ ë‹¨í¸í™”ì™€ ìºì‹œ ë¯¸ìŠ¤ ì¦ê°€
  * ë¬¸ë§¥ ì „í™˜ ë¹„ìš© ì¦ê°€ë¡œ CPU ë‚­ë¹„
  * ë½ ê²½í•©(lock contention)ê³¼ ì»¤ë„ ìˆ˜ì¤€ ë™ê¸°í™” ë¹„ìš© ìƒìŠ¹
* ê²°êµ­ â€œìŠ¤ë ˆë“œë¥¼ ë” ë¶™ì´ë©´ ì„ í˜• í™•ì¥â€ì´ ì„±ë¦½í•˜ì§€ ì•Šê³ , íŠ¹ì • ì„ê³„ì¹˜ë¥¼ ë„˜ìœ¼ë©´ ì²˜ë¦¬ëŸ‰ì´ ì˜¤íˆë ¤ ë–¨ì–´ì§€ëŠ” ì—­ì „ í˜„ìƒì´ ë‚˜íƒ€ë‚  ìˆ˜ ìˆë‹¤.

##### ì¶”ê°€ë¡œ ê³ ë ¤í•  ì§€ì 
* ë¸”ë¡œí‚¹ I/O ì§‘ì•½ êµ¬ê°„ì—ì„œì˜ ì €ì„±ëŠ¥: ë„¤íŠ¸ì›Œí¬Â·ë””ìŠ¤í¬Â·DBê°€ ì ê¹ë§Œ ë§‰í˜€ë„ í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ë†€ê²Œ ë˜ë©°, ì´ëŠ” ì „ì²´ ì²˜ë¦¬ëŸ‰ì„ ê°‰ì•„ë¨¹ëŠ”ë‹¤.
* N+1 ì¿¼ë¦¬ ê°™ì€ ë¹„íš¨ìœ¨: ë™ê¸° íë¦„ì—ì„œ ë°˜ë³µ ì¡°íšŒê°€ ìˆ¨ì–´ ìˆìœ¼ë©´ ìš”ì²­ë‹¹ DB ë¼ìš´ë“œíŠ¸ë¦½ì´ í­ì¦í•´ ë™ì ‘ í•œê³„ê°€ ë” ë¹¨ë¦¬ ë„ë˜í•œë‹¤.
* ë¦¬ì†ŒìŠ¤ ìƒí•œ ì •ì±…ê³¼ì˜ ì¶©ëŒ: íŒŒì¼ ë””ìŠ¤í¬ë¦½í„°, ì»¤ë„¥ì…˜ í’€, í ê¸¸ì´ ë“± ìš´ì˜ì²´ì œÂ·ë¯¸ë“¤ì›¨ì–´ ìƒí•œì— ë¹¨ë¦¬ ë¶€ë”ªíŒë‹¤.
  
#### 3) ê²Œì„ ë£¨í”„ì™€ì˜ ì¶©ëŒ
ê²Œì„ ì„œë²„ëŠ” ì¼ì • ì£¼ê¸°(ì˜ˆ: 16ms)ë§ˆë‹¤ ìƒíƒœ ì—…ë°ì´íŠ¸, ë¬¼ë¦¬, AI, ë™ê¸°í™”ë¥¼ ìˆ˜í–‰í•´ì•¼ í•œ ë‹¤. ë™ê¸° ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ë‚˜ ì™¸ë¶€ í˜¸ì¶œì´ ë£¨í”„ ì•ˆì—ì„œ ë¸”ë¡œí‚¹ë˜ë©´ í”„ë ˆì„ì´ ë¯¸ë„ëŸ¬ì§€ë©° ëª©í‘œ FPSë¥¼ ë†“ì¹˜ê²Œ ëœë‹¤.

* ì˜ˆì‹œë¡œ í”„ë ˆì„ë‹¹ ê²Œì„ ë¡œì§ 5ms + ë™ê¸° ë„¤íŠ¸ì›Œí¬ I/O 20msê°€ ë“¤ì–´ê°€ë©´ í•œ í”„ë ˆì„ì— 25msê°€ ê±¸ë ¤ ëª©í‘œ 16msë¥¼ ì´ˆê³¼í•˜ê³ , í‰ê·  FPSê°€ 60 ì•„ë˜ë¡œ ë–¨ì–´ì ¸ â€œë²„ë²…ì„â€ì´ ë°œìƒí•œë‹¤.
* ë£¨í”„ ì‹œê°„ ì´ˆê³¼ê°€ ë°˜ë³µë˜ë©´ ìƒíƒœ ì¬ë™ê¸°í™” ë¹„ìš©ì´ ì»¤ì§€ê³ , ë³´ê°„/ë³´ì • ë¡œì§ì´ ê³¼ë„í•˜ê²Œ ê°œì…í•˜ì—¬ ìœ„ì¹˜ íŠ, íŒì • ë¶ˆì¼ì¹˜ ë“±ì˜ í˜„ìƒì´ ëŠ˜ì–´ë‚œë‹¤.

##### ì¶”ê°€ë¡œ ê³ ë ¤í•  ì§€ì 
* ë£¨í”„-ì™¸ë¶€ ì‘ì—… ë¶„ë¦¬ ì‹¤íŒ¨: í‹± ë£¨í”„ ì•ˆì—ì„œ ë¸”ë¡œí‚¹ RPCë¥¼ í˜¸ì¶œí•˜ë©´ í‹± ì§€ì—°ì´ ëˆ„ì ëœë‹¤.
* ìŠ¤íŒŒì´í¬ ëŒ€ì‘ ì·¨ì•½: GC ìŠ¤í†±Â·ë””ìŠ¤í¬ ì¼ì‹œ ì§€ì—°Â·ë¡œê·¸ í”ŒëŸ¬ì‹œ ê°™ì€ ìŠ¤íŒŒì´í¬ì— ë£¨í”„ê°€ ì¦‰ì‹œ ì˜í–¥ì„ ë°›ëŠ”ë‹¤.
* ë°±í”„ë ˆì…”(Backpressure) ë¶€ì¬: ìˆ˜ì‹  íê°€ ë¶ˆì–´ë‚˜ë„ ë™ê¸° ì²˜ë¦¬ì—¬ì„œ ì¦‰ê° ì¡°ì ˆÂ·ë“œë¡­Â·ìƒ˜í”Œë§ì´ ì–´ë µë‹¤.


#### ë™ê¸° ë°©ì‹ì˜ í•µì‹¬ ë³‘ëª©
í—¤ë“œ-ì˜¤ë¸Œ-ë¼ì¸ ë¸”ë¡œí‚¹ìœ¼ë¡œ ì¸í•œ ì§€ì—° ëˆ„ì , 2) ìŠ¤ë ˆë“œ/ë©”ëª¨ë¦¬/ë½ ê²½í•© ê¸°ë°˜ì˜ í™•ì¥ì„± í•œê³„, 3) í‹± ê¸°ë°˜ ê²Œì„ ë£¨í”„ì™€ì˜ êµ¬ì¡°ì  ì¶©ëŒì´ í•µì‹¬ ë³‘ëª©ì´ë‹¤.


#### ê¶Œì¥ ëŒ€ì‘ ì „ëµ(ê°œì„  ë°©í–¥)

##### ì•„í‚¤í…ì²˜ ì „í™˜
* ë¹„ë™ê¸°Â·ì´ë²¤íŠ¸ ë“œë¦¬ë¸ I/Oë¡œ ì „í™˜í•œë‹¤. epoll/kqueue ê¸°ë°˜ ë¦¬ì•¡í„° íŒ¨í„´, í˜¹ì€ IOCP ê¸°ë°˜ ì™„ì „ ë¹„ë™ê¸° ëª¨ë¸ì„ ì±„íƒí•œë‹¤.
* ë©”ì‹œì§€ ì§€í–¥/ì•¡í„° ëª¨ë¸ ë„ì…ì„ ê²€í† í•œë‹¤. ì„¸ì…˜ì´ë‚˜ ì—”í‹°í‹°ë¥¼ ì•¡í„°ë¡œ ëª¨ë¸ë§í•´ ê²©ë¦¬ì™€ ìš°ì„ ìˆœìœ„ë¥¼ í™•ë³´í•œë‹¤.
* ì½ê¸°-ì“°ê¸° ê²½ë¡œ ë¶„ë¦¬í•œë‹¤. ì½ê¸°ëŠ” ìºì‹œÂ·CQRSë¡œ ë‹¨ì¶•í•˜ê³ , ì“°ê¸°ëŠ” ë°°ì¹˜Â·ì €ë„ë§Â·ë¹„ë™ê¸° ì»¤ë°‹ìœ¼ë¡œ ê¼¬ë¦¬ ì§€ì—°ì„ ë‚®ì¶˜ë‹¤.

##### ì‹¤í–‰ ëª¨ë¸ ìµœì í™”
* í‹± ë£¨í”„ì™€ I/Oë¥¼ ë¶„ë¦¬í•œë‹¤. í‹± ìŠ¤ë ˆë“œëŠ” ìˆœìˆ˜ ê²Œì„ ë¡œì§ì— ì§‘ì¤‘í•˜ê³ , ë„¤íŠ¸ì›Œí¬Â·DBëŠ” ë¹„ë™ê¸° íŒŒì´í”„ë¼ì¸ê³¼ íë¡œ ì—°ê²°í•œë‹¤.
* ìš°ì„ ìˆœìœ„ íì™€ ê³µì •ì„± ì •ì±…ì„ ì ìš©í•œë‹¤. ê°€ë²¼ìš´ ìš”ì²­ì´ ë¬´ê±°ìš´ ìš”ì²­ì— ê°€ë ¤ì§€ì§€ ì•Šê²Œ SLO ê¸°ë°˜ ìŠ¤ì¼€ì¤„ë§ì„ ì ìš©í•œë‹¤.
* ë°±í”„ë ˆì…”Â·í ì œí•œÂ·ë“œë¡­ ì •ì±…ì„ ëª…ë¬¸í™”í•œë‹¤. ê³¼ë¶€í•˜ ì‹œ ë¹ ë¥´ê²Œ í˜‘ìƒ(ìŠ¬ë¡œìš° ëª¨ë“œ, ìƒ˜í”Œë§, ìŠ¤í‚¬ íŒì • ì§€ì—° ë³´ì • ë“±)í•˜ì—¬ ë¶•ê´´ë¥¼ ë°©ì§€í•œë‹¤.

##### ë°ì´í„° ê³„ì¸µ ìµœì í™”
* ìºì‹œ ê³„ì¸µì„ ì ê·¹ ì‚¬ìš©í•œë‹¤. ì„¸ì…˜Â·ì¸ë²¤í† ë¦¬Â·ì›”ë“œ ìŠ¤ëƒ…ìƒ·ì„ ë©”ëª¨ë¦¬ ìºì‹œì— ë‘ê³  ìºì‹œ ë¯¸ìŠ¤ë§Œ DBë¡œ ë³´ë‚¸ë‹¤.
* N+1 ì œê±°ì™€ ì¡°ì¸ ìµœì í™”, ë¹„ë™ê¸° íŒŒì´í”„ë¼ì´ë‹ì„ ì ìš©í•œë‹¤.
* ì„œí‚· ë¸Œë ˆì´ì»¤Â·íƒ€ì„ì•„ì›ƒÂ·ì¬ì‹œë„ ì§€ìˆ˜ ë°±ì˜¤í”„ë¥¼ í‘œì¤€í™”í•œë‹¤.

##### ìš´ì˜Â·ê´€ì¸¡
* P50/P95/P99 ì§€ì—°ê³¼ í ê¸¸ì´, ë“œë¡­ë¥ ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•œë‹¤.
* ë¶€í•˜ í…ŒìŠ¤íŠ¸ì—ì„œ â€œí˜¼í•© íŠ¸ë˜í”½â€ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ í¬í•¨í•´ í—¤ë“œ-ì˜¤ë¸Œ-ë¼ì¸ ë¸”ë¡œí‚¹ì„ ì¡°ê¸°ì— ë“œëŸ¬ë‚¸ë‹¤.
* ìŠ¬ë¡œìš° ìš”ì²­ ìƒ˜í”Œë§ê³¼ í”„ë¡œíŒŒì¼ë§ìœ¼ë¡œ í•«ìŠ¤íŒŸì„ ì§€ì†ì ìœ¼ë¡œ ì œê±°í•œë‹¤.

#### ê²°ë¡ 
ë™ê¸° ë°©ì‹ì€ ë‹¨ìˆœí•˜ë‹¤ëŠ” ì¥ì ì´ ìˆìœ¼ë‚˜, ì‹¤ì‹œê°„ ìƒí˜¸ì‘ìš©ê³¼ ëŒ€ê·œëª¨ ë™ì ‘, í‹± ê¸°ë°˜ ë£¨í”„ë¼ëŠ” ê²Œì„ ì„œë²„ íŠ¹ì„±ê³¼ ì˜ ë§ì§€ ì•Šë‹¤. ë¹„ë™ê¸° I/O, ì•¡í„° ëª¨ë¸, ë°±í”„ë ˆì…”, ìºì‹±Â·íŒŒì´í”„ë¼ì´ë‹ ë“±ìœ¼ë¡œ ì „í™˜í•´ì•¼ ì¥ë¥´ë³„ ì§€ì—° ì˜ˆì‚°ì„ ì§€í‚¤ê³ , ê¼¬ë¦¬ ì§€ì—°ì„ ë‚®ì¶”ë©°, ë™ì ‘ ì¦ê°€ì—ë„ ì•ˆì •ì ìœ¼ë¡œ í™•ì¥í•  ìˆ˜ ìˆë‹¤.
  
     
</br>     
</br>        
  

## 3.4 í•µì‹¬ API ì •ë¦¬
  
### 3.4.1 ì£¼ìš” í´ë˜ìŠ¤ì™€ ë„¤ì„ìŠ¤í˜ì´ìŠ¤

| êµ¬ë¶„            | ì£¼ìš” ë‚´ìš©                                                                                                                                  | ìƒì„¸ ì„¤ëª… / ì˜ˆì œ                             |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| **ë„¤ì„ìŠ¤í˜ì´ìŠ¤**    | `boost::asio`                                                                                                                          | ë¹„ë™ê¸° I/O í•µì‹¬ ë„¤ì„ìŠ¤í˜ì´ìŠ¤                      |
|               | `boost::asio::ip`                                                                                                                      | ë„¤íŠ¸ì›Œí¬ ê´€ë ¨ (address, tcp, udp)            |
|               | `boost::asio::error`                                                                                                                   | ì—ëŸ¬ ì½”ë“œ ì •ì˜ (`eof`, `connection_reset` ë“±) |
| **ë³„ì¹­(using)** | `using namespace boost::asio;`<br>`using boost::asio::ip::tcp;`<br>`using boost::asio::ip::udp;`<br>`using boost::system::error_code;` | ìì£¼ ì“°ëŠ” ì„ ì–¸ì„ ë‹¨ì¶•ì‹œí‚´                         |


#### í•µì‹¬ í´ë˜ìŠ¤

| í´ë˜ìŠ¤               | ì„¤ëª…                    | ì£¼ìš” ê¸°ëŠ¥ / ë©”ì„œë“œ                                                                                   |
| ----------------- | --------------------- | --------------------------------------------------------------------------------------------- |
| **io\_context**   | ë¹„ë™ê¸° ì‘ì—…ì˜ ì¤‘ì‹¬, ì´ë²¤íŠ¸ ë£¨í”„ ê´€ë¦¬ | - `run()`: ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰<br>- `poll()`: ëŒ€ê¸° ì¤‘ì¸ ì‘ì—… ì‹¤í–‰<br>- `stop()`: ì´ë²¤íŠ¸ ë£¨í”„ ì¤‘ë‹¨<br>- `post()`: ì‘ì—… ì¶”ê°€ |
| **tcp::endpoint** | ë„¤íŠ¸ì›Œí¬ ì£¼ì†Œ í‘œí˜„            | IP/Port ì¡°í•©                                                                                    |
| **tcp::acceptor** | ì„œë²„ ì†Œì¼“                 | í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½, í¬íŠ¸ ë°”ì¸ë”©                                                                           |
| **tcp::socket**   | í´ë¼ì´ì–¸íŠ¸/ì„œë²„ í†µì‹  ì†Œì¼“        | ë°ì´í„° ì†¡ìˆ˜ì‹ , ì—°ê²° ê´€ë¦¬                                                                                |
| **tcp::resolver** | ë„ë©”ì¸/IP ë³€í™˜             | í˜¸ìŠ¤íŠ¸ëª… â†’ IP, ì„œë¹„ìŠ¤ëª… â†’ í¬íŠ¸                                                                          |


#### ë²„í¼ ê´€ë ¨ API

| êµ¬ë¶„                                  | ì„¤ëª…                   | ì˜ˆì œ                                                                         |
| ----------------------------------- | -------------------- | -------------------------------------------------------------------------- |
| **mutable\_buffer / const\_buffer** | ë©”ëª¨ë¦¬ ì˜ì—­ ë˜í•‘, íƒ€ì… ì•ˆì „ì„± ë³´ì¥ | -                                                                          |
| **buffer()**                        | ë‹¤ì–‘í•œ ì»¨í…Œì´ë„ˆë¥¼ ë²„í¼ë¡œ ë³€í™˜     | `buffer(std::vector<char>)`                                                |
| **dynamic\_buffer()**               | ë™ì  í¬ê¸° ì¡°ì ˆ ê°€ëŠ¥ ë²„í¼       | `dynamic_buffer(std::string)`                                              |
| **ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜**                         | ë²„í¼ ì¡°ì‘ í•¨ìˆ˜             | - `buffer_size()` í¬ê¸° ê³„ì‚°<br>- `buffer_copy()` ë³µì‚¬<br>- `buffer_cast()` íƒ€ì… ë³€í™˜ |


#### ì—ëŸ¬ ì²˜ë¦¬ API

| êµ¬ë¶„      | ëŒ€í‘œ ì½”ë“œ                     | ì„¤ëª…              |
| ------- | ------------------------- | --------------- |
| ì •ìƒ ì¢…ë£Œ   | `boost::asio::error::eof` | ì—°ê²°ì´ ì •ìƒ ì¢…ë£Œë¨      |
| ì—°ê²° ê´€ë ¨   | `connection_reset`        | ì—°ê²°ì´ ê°•ì œë¡œ ëŠê¹€      |
|         | `connection_refused`      | ì—°ê²° ê±°ë¶€           |
| ë„¤íŠ¸ì›Œí¬ ê´€ë ¨ | `host_unreachable`        | í˜¸ìŠ¤íŠ¸ ë„ë‹¬ ë¶ˆê°€       |
|         | `network_unreachable`     | ë„¤íŠ¸ì›Œí¬ ë„ë‹¬ ë¶ˆê°€      |
| ê¸°íƒ€      | `timed_out`               | ì‘ì—… ì‹œê°„ ì´ˆê³¼        |
|         | `try_again`               | ì¬ì‹œë„ í•„ìš”          |
|         | `would_block`             | ë¸”ë¡œí‚¹ ë°œìƒ ê°€ëŠ¥ (ë¹„ë™ê¸°) |

**íŒ¨í„´**

1. `error_code`ë¡œ ì²˜ë¦¬ (ê¶Œì¥)
2. `try-catch` ì˜ˆì™¸ ì²˜ë¦¬


### 3.4.2 ë™ê¸° I/O í•¨ìˆ˜ ì •ë¦¬

#### ì—°ê²° ê´€ë ¨ í•¨ìˆ˜

| í•¨ìˆ˜                         | ì„¤ëª…                     |
| -------------------------- | ---------------------- |
| `acceptor.accept(socket)`  | ì„œë²„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½ (ë¸”ë¡œí‚¹) |
| `socket.connect(endpoint)` | í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë²„ì— ì—°ê²° (ë¸”ë¡œí‚¹)    |
| `socket.close()`           | ì†Œì¼“ ì—°ê²° ì¢…ë£Œ               |


#### ì½ê¸° í•¨ìˆ˜

| í•¨ìˆ˜                                  | ì„¤ëª…                              |
| ----------------------------------- | ------------------------------- |
| `socket.read_some(buffer)`          | ìµœì†Œ 1ë°”ì´íŠ¸ ì´ìƒ ì½ê¸°, ì‹¤ì œ ì½ì€ í¬ê¸° ë°˜í™˜      |
| `read(socket, buffer)`              | ë²„í¼ë¥¼ ì™„ì „íˆ ì±„ìš¸ ë•Œê¹Œì§€ ë¸”ë¡œí‚¹              |
| `read_until(stream, buffer, delim)` | êµ¬ë¶„ì(`\n`)ê¹Œì§€ ì½ê¸°, í…ìŠ¤íŠ¸ í”„ë¡œí† ì½œì— ì£¼ë¡œ ì‚¬ìš© |


#### ì“°ê¸° í•¨ìˆ˜

| í•¨ìˆ˜                          | ì„¤ëª…                     |
| --------------------------- | ---------------------- |
| `socket.write_some(buffer)` | ì¼ë¶€ ë°ì´í„° ì „ì†¡, ì‹¤ì œ ì „ì†¡ í¬ê¸° ë°˜í™˜ |
| `write(socket, buffer)`     | ì „ì²´ ë²„í¼ ì „ì†¡ ë³´ì¥ (ë¸”ë¡œí‚¹)      |
| `write(socket, buffers)`    | ë‹¤ì¤‘ ë²„í¼ ì „ì†¡ ê°€ëŠ¥            |


#### ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜

| í•¨ìˆ˜                          | ì„¤ëª…                                         |
| --------------------------- | ------------------------------------------ |
| `socket.is_open()`          | ì†Œì¼“ ì—´ë¦¼ ì—¬ë¶€ í™•ì¸                                |
| `socket.local_endpoint()`   | ë¡œì»¬ ì£¼ì†Œ ë°˜í™˜                                   |
| `socket.remote_endpoint()`  | ì›ê²© ì£¼ì†Œ ë°˜í™˜                                   |
| `socket.available()`        | ì¦‰ì‹œ ì½ì„ ìˆ˜ ìˆëŠ” ë°”ì´íŠ¸ ìˆ˜                           |
| `socket.set_option(option)` | ì†Œì¼“ ì˜µì…˜ ì„¤ì • (`TCP_NODELAY`, `SO_KEEPALIVE` ë“±) |

  
### 3.4.3 ì‹¤ìŠµ ì¢…í•© ì˜ˆì œ
ì§€ê¸ˆê¹Œì§€ í•™ìŠµí•œ ë‚´ìš©ì„ ì¢…í•©í•œ ì™„ì „í•œ ì˜ˆì œë¥¼ ë§Œë“¤ì–´ë³´ê² ë‹¤.

**ì¢…í•© ì‹¤ìŠµ: ê°„ë‹¨í•œ ì±„íŒ… ì„œë²„**

```cpp
// ë™ê¸° ë°©ì‹ ì±„íŒ… ì„œë²„ êµ¬í˜„
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <thread>
#include <mutex>
#include <format>
#include <boost/asio.hpp>

using namespace boost::asio;
using ip::tcp;

class SimpleChatServer 
{
private:
    io_context io_context_;
    tcp::acceptor acceptor_;
    std::vector<std::shared_ptr<std::thread>> client_threads_;
    std::mutex clients_mutex_;
    std::vector<std::shared_ptr<tcp::socket>> active_clients_;
    std::atomic<bool> server_running_{true};
    
public:
    SimpleChatServer(unsigned short port) 
        : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port)) 
        {
        std::cout << std::format("ì±„íŒ… ì„œë²„ê°€ í¬íŠ¸ {}ì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.\n", port);
    }
    
    ~SimpleChatServer() 
    {
        stop();
    }
    
    void run() 
    {
        std::cout << "ì±„íŒ… ì„œë²„ ì‹¤í–‰ ì¤‘... (Ctrl+Cë¡œ ì¢…ë£Œ)\n" << std::endl;
        
        try 
        {
            while (server_running_) 
            {
                auto client_socket = std::make_shared<tcp::socket>(io_context_);
                
                boost::system::error_code accept_error;
                acceptor_.accept(*client_socket, accept_error);
                
                if (accept_error) {
                    if (server_running_) {
                        std::cerr << "Accept ì˜¤ë¥˜: " << accept_error.message() << std::endl;
                    }
                    break;
                }
                
                std::cout << "ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°: " 
                         << client_socket->remote_endpoint() << std::endl;
                
                // í´ë¼ì´ì–¸íŠ¸ ëª©ë¡ì— ì¶”ê°€
                {
                    std::lock_guard<std::mutex> lock(clients_mutex_);
                    active_clients_.push_back(client_socket);
                }
                
                // ìƒˆ ìŠ¤ë ˆë“œì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬
                auto client_thread = std::make_shared<std::thread>(
                    &SimpleChatServer::handle_client, this, client_socket);
                
                client_threads_.push_back(client_thread);
                
                // ì¢…ë£Œëœ ìŠ¤ë ˆë“œ ì •ë¦¬
                cleanup_finished_threads();
            }
        } catch (std::exception& e) {
            std::cerr << "ì„œë²„ ì˜¤ë¥˜: " << e.what() << std::endl;
        }
    }
    
    void stop() 
    {
        server_running_ = false;
        
        // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ
        {
            std::lock_guard<std::mutex> lock(clients_mutex_);
            for (auto& client : active_clients_) {
                if (client->is_open()) {
                    boost::system::error_code ec;
                    client->close(ec);
                }
            }
            active_clients_.clear();
        }
        
        // acceptor ì¢…ë£Œ
        boost::system::error_code ec;
        acceptor_.close(ec);
        
        // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
        for (auto& thread : client_threads_) {
            if (thread->joinable()) {
                thread->join();
            }
        }
        client_threads_.clear();
        
        std::cout << "ì±„íŒ… ì„œë²„ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." << std::endl;
    }
    
private:
    void handle_client(std::shared_ptr<tcp::socket> client_socket) 
    {
        try 
        {
            std::string client_address = client_socket->remote_endpoint().address().to_string();
            std::cout << std::format("[{}] í´ë¼ì´ì–¸íŠ¸ í•¸ë“¤ëŸ¬ ì‹œì‘\n", client_address);
            
            // í™˜ì˜ ë©”ì‹œì§€ ì „ì†¡
            std::string welcome_msg = "ì±„íŒ… ì„œë²„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!\n";
            boost::system::error_code send_error;
            write(*client_socket, boost::asio::buffer(welcome_msg), send_error);
            
            if (send_error) {
                std::cout << std::format("[{}] í™˜ì˜ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨\n", client_address);
                return;
            }
            
            while (server_running_ && client_socket->is_open()) 
            {
                std::array<char, 1024> buffer;
                buffer.fill(0);
                
                boost::system::error_code receive_error;
                size_t length = client_socket->read_some(
                    boost::asio::buffer(buffer), receive_error);
                
                if (receive_error == boost::asio::error::eof) {
                    std::cout << std::format("[{}] í´ë¼ì´ì–¸íŠ¸ ì •ìƒ ì¢…ë£Œ\n", client_address);
                    break;
                } else if (receive_error) {
                    std::cout << std::format("[{}] ìˆ˜ì‹  ì˜¤ë¥˜: {}\n", 
                                           client_address, receive_error.message());
                    break;
                }
                
                if (length > 0) 
                {
                    std::string message(buffer.data(), length);
                    
                    // ì¤„ë°”ê¿ˆ ì œê±°
                    message.erase(std::remove(message.begin(), message.end(), '\n'), 
                                message.end());
                    message.erase(std::remove(message.begin(), message.end(), '\r'), 
                                message.end());
                    
                    if (!message.empty()) {
                        std::cout << std::format("[{}] ë©”ì‹œì§€: {}\n", client_address, message);
                        
                        // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
                        broadcast_message(client_address, message);
                    }
                }
            }
            
        } catch (std::exception& e) {
            std::cerr << "í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸: " << e.what() << std::endl;
        }
        
        // í´ë¼ì´ì–¸íŠ¸ ëª©ë¡ì—ì„œ ì œê±°
        remove_client(client_socket);
        
        std::string client_address = "ì•Œ ìˆ˜ ì—†ìŒ";
        try 
        {
            if (client_socket->is_open()) {
                client_address = client_socket->remote_endpoint().address().to_string();
            }
        } catch (...) {}
        
        std::cout << std::format("[{}] í´ë¼ì´ì–¸íŠ¸ í•¸ë“¤ëŸ¬ ì¢…ë£Œ\n", client_address);
    }
    
    void broadcast_message(const std::string& sender_address, const std::string& message) 
    {
        std::string broadcast_msg = std::format("[{}]: {}\n", sender_address, message);
        
        std::lock_guard<std::mutex> lock(clients_mutex_);
        
        auto it = active_clients_.begin();
        while (it != active_clients_.end()) 
        {
            auto client = *it;
            
            if (!client->is_open()) 
            {
                // ë‹«íŒ ì†Œì¼“ ì œê±°
                it = active_clients_.erase(it);
                continue;
            }
            
            boost::system::error_code send_error;
            write(*client, boost::asio::buffer(broadcast_msg), send_error);
            
            if (send_error) 
            {
                // ì „ì†¡ ì‹¤íŒ¨í•œ í´ë¼ì´ì–¸íŠ¸ ì œê±°
                boost::system::error_code close_error;
                client->close(close_error);
                it = active_clients_.erase(it);
            } 
            else 
            {
                ++it;
            }
        }
        
        std::cout << std::format("ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì™„ë£Œ: {} ({}ëª…ì—ê²Œ ì „ì†¡)\n", 
                               message, active_clients_.size());
    }
    
    void remove_client(std::shared_ptr<tcp::socket> client_socket) 
    {
        std::lock_guard<std::mutex> lock(clients_mutex_);
        
        active_clients_.erase(
            std::remove(active_clients_.begin(), active_clients_.end(), client_socket),
            active_clients_.end());
    }
    
    void cleanup_finished_threads() 
    {
        auto it = client_threads_.begin();
        while (it != client_threads_.end()) {
            // ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ë°©ë²•ì´ í•„ìš”)
            ++it;
        }
    }
};

// ë©”ì¸ í•¨ìˆ˜
int main() 
{
    try {
        SimpleChatServer server(8080);
        
        // Ctrl+C í•¸ë“¤ëŸ¬ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” signal handling í•„ìš”)
        server.run();
        
    } catch (std::exception& e) {
        std::cerr << "ì„œë²„ ì‹œì‘ ì‹¤íŒ¨: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```  
     
ì•„ë˜ëŠ” ì´ ì½”ë“œì— ëŒ€í•œ ì„¤ëª…ì´ë‹¤.  

#### 1. ì„œë²„ ì´ˆê¸°í™”

```cpp
io_context io_context_;
tcp::acceptor acceptor_;
```

* `io_context_`: Boost.Asioì˜ í•µì‹¬ ê°ì²´ë¡œ I/O ì‘ì—…ì„ ê´€ë¦¬í•œë‹¤.
* `tcp::acceptor`: í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ìˆ˜ë½í•˜ëŠ” ì„œë²„ ì†Œì¼“ì´ë‹¤.

```cpp
SimpleChatServer(unsigned short port) 
    : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port)) 
{
    std::cout << std::format("ì±„íŒ… ì„œë²„ê°€ í¬íŠ¸ {}ì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.\n", port);
}
```

* ìƒì„±ìì—ì„œ `acceptor_`ë¥¼ íŠ¹ì • í¬íŠ¸ì— ë°”ì¸ë”©í•˜ì—¬ ì„œë²„ ì†Œì¼“ì„ ì¤€ë¹„í•œë‹¤.


#### 2. í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½

```cpp
while (server_running_) {
    auto client_socket = std::make_shared<tcp::socket>(io_context_);
    acceptor_.accept(*client_socket, accept_error);
    ...
}
```

* ì„œë²„ëŠ” ë¬´í•œ ë£¨í”„ì—ì„œ ìƒˆë¡œìš´ í´ë¼ì´ì–¸íŠ¸ì˜ ì—°ê²°ì„ ê¸°ë‹¤ë¦°ë‹¤.
* ì—°ê²°ì´ ìˆ˜ë½ë˜ë©´ ìƒˆë¡œìš´ `tcp::socket`ì„ ìƒì„±í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ì™€ í†µì‹ í•  ì¤€ë¹„ë¥¼ í•œë‹¤.


#### 3. í´ë¼ì´ì–¸íŠ¸ ì „ìš© ìŠ¤ë ˆë“œ ì‹¤í–‰

```cpp
auto client_thread = std::make_shared<std::thread>(
    &SimpleChatServer::handle_client, this, client_socket);
client_threads_.push_back(client_thread);
```

* ìƒˆë¡œìš´ í´ë¼ì´ì–¸íŠ¸ë§ˆë‹¤ **ë³„ë„ì˜ ìŠ¤ë ˆë“œ**ë¥¼ ìƒì„±í•œë‹¤.
* ê° ìŠ¤ë ˆë“œì—ì„œëŠ” `handle_client` í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ì–´ í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•œë‹¤.


#### 4. í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ (í•¸ë“¤ëŸ¬)

```cpp
size_t length = client_socket->read_some(
    boost::asio::buffer(buffer), receive_error);
```

* í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ë°ì´í„°ë¥¼ **ë™ê¸° ë°©ì‹**ìœ¼ë¡œ ì½ëŠ”ë‹¤.
* ì½ê¸° ì‘ì—…ì€ ë¸”ë¡œí‚¹(blocking)ë˜ì–´ ë°ì´í„°ê°€ ë„ì°©í•  ë•Œê¹Œì§€ ëŒ€ê¸°í•œë‹¤.

```cpp
broadcast_message(client_address, message);
```

* í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ë‚¸ ë©”ì‹œì§€ë¥¼ ë°›ì•„ì„œ **ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸**í•œë‹¤.


#### 5. ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸

```cpp
for (auto& client : active_clients_) {
    write(*client, boost::asio::buffer(broadcast_msg), send_error);
}
```

* ì„œë²„ì— ì—°ê²°ëœ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ì— ë©”ì‹œì§€ë¥¼ ì „ì†¡í•œë‹¤.
* ì „ì†¡ì— ì‹¤íŒ¨í•œ í´ë¼ì´ì–¸íŠ¸ëŠ” ëª©ë¡ì—ì„œ ì œê±°í•œë‹¤.


#### 6. ì„œë²„ ì¢…ë£Œ

```cpp
void stop() {
    server_running_ = false;
    acceptor_.close(ec);
    ...
}
```

* `stop()`ì€ ì„œë²„ ì‹¤í–‰ì„ ì¤‘ë‹¨í•˜ê³  ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ê³¼ ìŠ¤ë ˆë“œë¥¼ ì •ë¦¬í•œë‹¤.
* ì•ˆì „í•œ ì¢…ë£Œë¥¼ ìœ„í•´ **ë®¤í…ìŠ¤ ë³´í˜¸**ë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ì‹œ ì ‘ê·¼ ë¬¸ì œë¥¼ ë°©ì§€í•œë‹¤.


#### 7. ë©”ì¸ í•¨ìˆ˜

```cpp
int main() 
{
    SimpleChatServer server(8080);
    server.run();
}
```

* í¬íŠ¸ 8080ì—ì„œ ì„œë²„ë¥¼ ì‹¤í–‰í•œë‹¤.
* `Ctrl+C`ë¥¼ í†µí•´ ì„œë²„ë¥¼ ì¤‘ë‹¨í•  ìˆ˜ ìˆë‹¤. (ì‹¤ì œ ì„œë¹„ìŠ¤ì—ì„œëŠ” `signal handling` í•„ìš”)

  
#### í•µì‹¬ ìš”ì•½

1. **Acceptor** â†’ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ëŒ€ê¸°
2. **Socket** â†’ í´ë¼ì´ì–¸íŠ¸ í†µì‹  ë‹´ë‹¹
3. **Thread per client** â†’ í´ë¼ì´ì–¸íŠ¸ë³„ ë…ë¦½ ì²˜ë¦¬
4. **Broadcast** â†’ ë°›ì€ ë©”ì‹œì§€ë¥¼ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì— ì „ì†¡
5. **Mutex ë³´í˜¸** â†’ ë‹¤ì¤‘ í´ë¼ì´ì–¸íŠ¸ ë™ì‹œì„± ì œì–´
6. **Graceful shutdown** â†’ ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ ì •ë¦¬ í›„ ì¢…ë£Œ



-----  
     
ì´ì œ ë™ê¸° ë°©ì‹ ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì˜ ê¸°ì´ˆë¥¼ ì™„ì „íˆ ì´í•´í–ˆë‹¤. ë‹¤ìŒ ì¥ì—ì„œëŠ” ë¹„ë™ê¸° ë°©ì‹ìœ¼ë¡œ ë„˜ì–´ê°€ì„œ í™•ì¥ ê°€ëŠ¥í•˜ê³  ê³ ì„±ëŠ¥ì¸ ê²Œì„ ì„œë²„ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•˜ê² ë‹¤.

**í•™ìŠµ ì •ë¦¬:**
- âœ… Echo ì„œë²„/í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
- âœ… TCP ì†Œì¼“ í”„ë¡œê·¸ë˜ë° ê¸°ì´ˆ ìŠµë“
- âœ… ë™ê¸° ë°©ì‹ì˜ ì¥ë‹¨ì  ì´í•´
- âœ… Boost.Asio í•µì‹¬ API ìˆ™ì§€
- âœ… ì‹¤ì „ ì±„íŒ… ì„œë²„ êµ¬í˜„

ë™ê¸° ë°©ì‹ì€ ì´í•´í•˜ê¸° ì‰½ê³  ë””ë²„ê¹…ì´ ìš©ì´í•˜ì§€ë§Œ, í™•ì¥ì„±ê³¼ ì„±ëŠ¥ ë©´ì—ì„œ í•œê³„ê°€ ìˆìŠµë‹ˆë‹¤. ì´ì œ ì´ëŸ¬í•œ í•œê³„ë¥¼ ê·¹ë³µí•˜ëŠ” ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ìœ¼ë¡œ ì§„í–‰í•´ë³´ê² ë‹¤.
 
  
  