# C++ Boost.Asio로 만드는 온라인 게임 서버
저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상
- **도구**: Windows Performance Toolkit, Intel VTune (선택사항)

-----   

# Chapter 3. 동기 방식 네트워크 프로그래밍
이 장에서는 Boost.Asio를 사용한 동기 방식 네트워크 프로그래밍의 기초를 학습한다. 동기 방식은 비동기 방식보다 이해하기 쉽고, 네트워크 프로그래밍의 기본 개념을 익히기에 적합하다. 실제 예제를 통해 TCP 소켓 프로그래밍의 핵심을 마스터해보겠다.
  

## 3.1 간단한 Echo 서버/클라이언트 구현

### 3.1.1 Echo 서버란?
Echo 서버는 클라이언트로부터 받은 데이터를 그대로 다시 전송하는 가장 기본적인 네트워크 서버이다. 네트워크 프로그래밍을 학습할 때 전통적으로 사용되는 예제로, 다음과 같은 기능을 제공한다:  
  
- 클라이언트 연결 수락
- 클라이언트가 보낸 메시지 수신
- 받은 메시지를 그대로 클라이언트에게 전송
- 연결 관리 및 종료 처리

### 3.1.2 동기 방식 TCP Echo 서버 구현
먼저 가장 기본적인 동기 방식 Echo 서버를 구현해보겠다.

**SynchronousEchoServer.cpp:**

```cpp
#include <iostream>
#include <string>
#include <array>
#include <format>
#include <boost/asio.hpp>

using namespace boost::asio;
using ip::tcp;

const char SERVER_IP[] = "127.0.0.1";
const unsigned short PORT_NUMBER = 31352;

class SynchronousEchoServer 
{
private:
    io_context io_context_;
    tcp::acceptor acceptor_;
    
public:
    SynchronousEchoServer(unsigned short port) 
        : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port)) 
    {
        std::cout << std::format("Echo 서버가 포트 {}에서 시작되었습니다.\n", port);
    }
    
    void run() 
    {
        try 
        {
            while (true) 
            {
                // 클라이언트 연결을 기다림 (블로킹)
                tcp::socket socket(io_context_);
                acceptor_.accept(socket);
                
                std::cout << "클라이언트가 연결되었습니다: " 
                         << socket.remote_endpoint() << std::endl;
                
                handle_client(std::move(socket));
            }
        } 
        catch (std::exception& e) 
        {
            std::cerr << "서버 오류: " << e.what() << std::endl;
        }
    }
    
private:
    void handle_client(tcp::socket socket) 
    {
        try 
        {
            while (true) 
            {
                std::array<char, 1024> buffer;
                buffer.fill(0);
                
                // 데이터 수신 (블로킹)
                boost::system::error_code error;
                size_t length = socket.read_some(boost::asio::buffer(buffer), error);
                
                if (error == boost::asio::error::eof) {
                    std::cout << "클라이언트가 연결을 종료했습니다." << std::endl;
                    break; // 정상적인 연결 종료
                } else if (error) {
                    std::cout << std::format("수신 오류: {} ({})\n", 
                                           error.message(), error.value());
                    break;
                }
                
                if (length > 0) {
                    std::string received_data(buffer.data(), length);
                    std::cout << std::format("받은 메시지 [{}바이트]: {}\n", 
                                           length, received_data);
                    
                    // Echo: 받은 데이터를 그대로 전송 (블로킹)
                    std::string echo_message = std::format("Echo: {}", received_data);
                    boost::system::error_code send_error;
                    
                    write(socket, boost::asio::buffer(echo_message), send_error);
                    
                    if (send_error) {
                        std::cout << std::format("송신 오류: {} ({})\n", 
                                               send_error.message(), send_error.value());
                        break;
                    }
                    
                    std::cout << std::format("응답 전송: {}\n", echo_message);
                }
            }
        } 
        catch (std::exception& e) 
        {
            std::cerr << "클라이언트 처리 중 오류: " << e.what() << std::endl;
        }
        
        std::cout << "클라이언트 연결이 종료되었습니다.\n" << std::endl;
    }
};

int main() 
{
    try 
    {
        SynchronousEchoServer server(PORT_NUMBER);
        std::cout << "Echo 서버 실행 중... (Ctrl+C로 종료)\n" << std::endl;
        server.run();
    } 
    catch (std::exception& e) 
    {
        std::cerr << "서버 시작 실패: " << e.what() << std::endl;
    }
    
    return 0;
}
```
  
#### `SynchronousEchoServer` 클래스
이 클래스가 서버의 핵심 로직을 모두 담고 있다.

##### 멤버 변수

```cpp
private:
    io_context io_context_;
    tcp::acceptor acceptor_;
```

  * `io_context_`: Boost.Asio의 심장과 같은 객체이다. 운영체제의 I/O(입출력) 서비스와 상호작용하는 역할을 하며, 모든 I/O 작업의 실행 컨텍스트를 제공한다.
  * `acceptor_`: 클라이언트의 연결 요청을 수락하는 "문지기" 역할을 한다. 지정된 포트에서 클라이언트의 접속을 기다린다.

##### 생성자

```cpp
public:
    SynchronousEchoServer(unsigned short port)
        : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port))
    {
        std::cout << std::format("Echo 서버가 포트 {}에서 시작되었습니다.\n", port);
    }
```

  * `acceptor_`를 초기화한다. `tcp::endpoint(tcp::v4(), port)`는 "IPv4 프로토콜을 사용하여 이 컴퓨터의 모든 네트워크 인터페이스에서 `port` 번호로 들어오는 연결을 받겠다"는 의미의 주소 정보를 생성한다.

##### `run()` 메소드: 메인 서버 루프

```cpp
void run()
{
    try
    {
        while (true) // 무한 루프를 돌며 클라이언트 접속을 계속 기다림
        {
            // 1. 클라이언트 연결 대기 (블로킹)
            tcp::socket socket(io_context_);
            acceptor_.accept(socket); // 클라이언트가 접속할 때까지 여기서 멈춤

            std::cout << "클라이언트가 연결되었습니다: "
                      << socket.remote_endpoint() << std::endl;

            // 2. 연결된 클라이언트 처리
            handle_client(std::move(socket));
        }
    }
    catch (std::exception& e)
    {
        std::cerr << "서버 오류: " << e.what() << std::endl;
    }
}
```

  * 이 메소드가 서버의 실질적인 실행을 담당한다.
  * `while (true)` 루프 안에서 클라이언트의 연결을 계속해서 기다린다.
  * `acceptor_.accept(socket)`: **이 코드의 핵심적인 블로킹 부분**이다. 클라이언트가 접속을 시도할 때까지 프로그램은 이 라인에서 실행을 멈추고 대기한다. 연결이 이루어지면, 해당 클라이언트와 통신할 수 있는 `socket` 객체가 생성된다.
  * `handle_client(std::move(socket))`: 클라이언트와 연결된 `socket`을 `handle_client` 함수로 넘겨서 실제 데이터 통신을 처리하도록 한다. `std::move`는 소켓 객체의 소유권을 효율적으로 이전하기 위해 사용된다.

##### `handle_client()` 메소드: 클라이언트 통신 처리

```cpp
private:
    void handle_client(tcp::socket socket)
    {
        try
        {
            while (true) // 한 클라이언트와 계속 통신하기 위한 루프
            {
                std::array<char, 1024> buffer; // 데이터 수신용 버퍼
                boost::system::error_code error;

                // 1. 데이터 수신 (블로킹)
                size_t length = socket.read_some(boost::asio::buffer(buffer), error);

                // 2. 오류 처리 (연결 종료 등)
                if (error == boost::asio::error::eof) {
                    std::cout << "클라이언트가 연결을 종료했습니다." << std::endl;
                    break; // 정상 종료
                } else if (error) {
                    throw boost::system::system_error(error); // 예외 발생
                }

                std::string received_data(buffer.data(), length);
                std::cout << "받은 메시지: " << received_data << std::endl;

                // 3. Echo: 받은 데이터를 그대로 전송 (블로킹)
                write(socket, boost::asio::buffer(received_data));
            }
        }
        catch (std::exception& e)
        {
            std::cerr << "클라이언트 처리 중 오류: " << e.what() << std::endl;
        }
    }
```

  * `socket.read_some(...)`: **또 다른 핵심 블로킹 부분**이다. 클라이언트로부터 데이터가 도착할 때까지 여기서 실행을 멈추고 대기한다.
  * `error == boost::asio::error::eof`: 클라이언트가 정상적으로 연결을 끊었을 때 발생하는 특별한 "오류"이다. 이 경우 루프를 빠져나가 함수를 종료한다.
  * `write(socket, ...)`: 수신한 데이터를 클라이언트에게 다시 보낸다. 이 작업 역시 데이터 전송이 완료될 때까지 **블로킹**된다.

#### `main()` 함수

```cpp
int main()
{
    try
    {
        SynchronousEchoServer server(PORT_NUMBER);
        server.run(); // 서버 실행
    }
    catch (std::exception& e)
    {
        std::cerr << "서버 시작 실패: " << e.what() << std::endl;
    }
    return 0;
}
```

  * 프로그램의 시작점이다.
  * `SynchronousEchoServer` 객체를 생성하고 `run()` 메소드를 호출하여 서버를 시작한다.
  * `try-catch` 블록으로 서버 시작 시 발생할 수 있는 예외(예: 포트가 이미 사용 중인 경우)를 처리한다.


#### 동작 순서 요약
1.  `main` 함수에서 `SynchronousEchoServer` 객체를 생성하고, 서버는 지정된 포트(`31352`)에서 클라이언트의 연결을 기다릴 준비를 한다.
2.  `run()` 메소드가 호출되어 무한 루프에 진입한다.
3.  `acceptor_.accept(socket)`에서 클라이언트가 접속할 때까지 **대기 (블로킹)**한다.
4.  클라이언트가 접속하면, `handle_client` 함수가 호출된다.
5.  `handle_client` 함수 안에서 `socket.read_some()`을 통해 클라이언트가 데이터를 보낼 때까지 **대기 (블로킹)**한다.
6.  데이터를 수신하면 콘솔에 출력하고, `write()`를 통해 받은 데이터를 그대로 클라이언트에게 다시 전송한다.
7.  클라이언트가 연결을 끊거나 오류가 발생할 때까지 5\~6번 과정을 반복한다.
8.  클라이언트와의 연결이 종료되면 `handle_client` 함수가 끝나고, `run` 메소드의 `while` 루프로 돌아가 다음 클라이언트의 접속을 다시 기다린다.  
  

### 3.1.3 동기 방식 TCP Echo 클라이언트 구현
이제 위 서버와 통신할 클라이언트를 구현해보겠다.

**SynchronousEchoClient.cpp:**

```cpp
#include <iostream>
#include <string>
#include <array>
#include <format>
#include <boost/asio.hpp>

using namespace boost::asio;
using ip::tcp;

const char SERVER_IP[] = "127.0.0.1";
const unsigned short PORT_NUMBER = 31400;

class SynchronousEchoClient 
{
private:
    io_context io_context_;
    tcp::socket socket_;
    
public:
    SynchronousEchoClient() : socket_(io_context_) {}
    
    bool connect_to_server(const std::string& server_ip, unsigned short port) 
    {
        try 
        {
            // 서버 주소 설정
            tcp::endpoint server_endpoint(
                boost::asio::ip::make_address(server_ip), port);
            
            // 서버에 연결 (블로킹)
            boost::system::error_code connect_error;
            socket_.connect(server_endpoint, connect_error);
            
            if (connect_error) 
            {
                std::cout << std::format("연결 실패: {} ({})\n", 
                                       connect_error.message(), connect_error.value());
                return false;
            }
            
            std::cout << "서버에 성공적으로 연결되었습니다: " 
                     << server_endpoint << std::endl;
            return true;
            
        } 
        catch (std::exception& e) 
        {
            std::cerr << "연결 중 예외 발생: " << e.what() << std::endl;
            return false;
        }
    }
    
    void run_interactive_session() 
    {
        std::cout << "\n=== Echo 클라이언트 시작 ===\n";
        std::cout << "메시지를 입력하세요 ('quit' 입력 시 종료):\n" << std::endl;
        
        std::string input;
        while (true) 
        {
            std::cout << "> ";
            std::getline(std::cin, input);
            
            if (input == "quit" || input == "exit") {
                std::cout << "클라이언트를 종료합니다." << std::endl;
                break;
            }
            
            if (input.empty()) {
                continue;
            }
            
            if (!send_and_receive_message(input)) {
                std::cout << "통신 오류로 인해 연결을 종료합니다." << std::endl;
                break;
            }
        }
    }
    
    void run_automatic_test() 
    {
        std::cout << "\n=== 자동 테스트 모드 ===\n" << std::endl;
        
        std::vector<std::string> test_messages = {
            "Hello, Server!",
            "Test message 1",
            "게임 서버 테스트",
            "123456789",
            "Special chars: !@#$%^&*()"
        };
        
        for (size_t i = 0; i < test_messages.size(); ++i) 
        {
            std::cout << std::format("테스트 {}/{}: {}\n", 
                                   i + 1, test_messages.size(), test_messages[i]);
            
            if (!send_and_receive_message(test_messages[i])) 
            {
                std::cout << "테스트 실패!" << std::endl;
                break;
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        }
        
        std::cout << "자동 테스트 완료!" << std::endl;
    }
    
    void disconnect() 
    {
        if (socket_.is_open()) {
            boost::system::error_code error;
            socket_.close(error);
            
            if (!error) {
                std::cout << "서버와의 연결이 종료되었습니다." << std::endl;
            }
        }
    }
    
private:
    bool send_and_receive_message(const std::string& message) 
    {
        try 
        {
            // 메시지 전송 (블로킹)
            boost::system::error_code send_error;
            write(socket_, boost::asio::buffer(message), send_error);
            
            if (send_error) 
            {
                std::cout << std::format("전송 오류: {} ({})\n", 
                                       send_error.message(), send_error.value());
                return false;
            }
            
            std::cout << std::format("전송: {}\n", message);
            
            // 응답 수신 (블로킹)
            std::array<char, 1024> buffer;
            buffer.fill(0);
            
            boost::system::error_code receive_error;
            size_t reply_length = socket_.read_some(
                boost::asio::buffer(buffer), receive_error);
            
            if (receive_error == boost::asio::error::eof) {
                std::cout << "서버가 연결을 종료했습니다." << std::endl;
                return false;
            } else if (receive_error) {
                std::cout << std::format("수신 오류: {} ({})\n", 
                                       receive_error.message(), receive_error.value());
                return false;
            }
            
            std::string reply(buffer.data(), reply_length);
            std::cout << std::format("수신: {}\n", reply);
            std::cout << std::endl;
            
            return true;
            
        } 
        catch (std::exception& e) 
        {
            std::cerr << "통신 중 예외 발생: " << e.what() << std::endl;
            return false;
        }
    }
};

int main(int argc, char* argv[]) 
{
    try 
    {
        SynchronousEchoClient client;
        
        // 서버에 연결
        if (!client.connect_to_server(SERVER_IP, PORT_NUMBER)) {
            return 1;
        }
        
        // 실행 모드 선택
        bool auto_mode = false;
        if (argc > 1 && std::string(argv[1]) == "--auto") {
            auto_mode = true;
        }
        
        if (auto_mode) {
            client.run_automatic_test();
        } else {
            client.run_interactive_session();
        }
        
        client.disconnect();
        
    } 
    catch (std::exception& e) 
    {
        std::cerr << "클라이언트 오류: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```
  
#### 헤더 파일 및 전역 변수

```cpp
#include <iostream>
#include <string>
#include <array>
#include <format>
#include <boost/asio.hpp> // Boost.Asio 라이브러리

using namespace boost::asio;
using ip::tcp;

// 접속할 서버의 IP 주소와 포트 번호
const char SERVER_IP[] = "127.0.0.1";
const unsigned short PORT_NUMBER = 31400; // 서버의 포트와 일치해야 합니다.
```

  * 필요한 라이브러리를 포함하고, 접속 대상 서버의 주소 정보를 상수로 정의한다.
 

#### `SynchronousEchoClient` 클래스
클라이언트의 모든 기능이 이 클래스 안에 구현되어 있다.

##### 멤버 변수 및 생성자

```cpp
private:
    io_context io_context_;
    tcp::socket socket_;

public:
    SynchronousEchoClient() : socket_(io_context_) {}
```

  * `io_context_`: 서버와 마찬가지로 Asio의 핵심 객체이다.
  * `socket_`: 서버와 실제로 데이터를 주고받는 통신 채널 역할을 하는 객체이다.
  * 생성자에서는 `io_context_`를 사용하여 `socket_`을 초기화한다.
  
##### `connect_to_server()` 메소드: 서버 연결

```cpp
bool connect_to_server(const std::string& server_ip, unsigned short port)
{
    try
    {
        // 1. 서버 주소 정보(endpoint) 생성
        tcp::endpoint server_endpoint(
            boost::asio::ip::make_address(server_ip), port);

        // 2. 서버에 연결 시도 (블로킹)
        socket_.connect(server_endpoint);

        std::cout << "서버에 성공적으로 연결되었습니다." << std::endl;
        return true;
    }
    catch (std::exception& e)
    {
        std::cerr << "연결 실패: " << e.what() << std::endl;
        return false;
    }
}
```

  * `tcp::endpoint(...)`: 접속할 서버의 IP 주소와 포트 번호로 "목적지 주소"를 만든다.
  * `socket_.connect(server_endpoint)`: **이 코드의 핵심적인 블로킹(blocking) 부분**이다. 이 함수는 서버와의 연결이 성공하거나 실패할 때까지 실행을 멈추고 기다린다.

##### `send_and_receive_message()` 메소드: 데이터 송수신

```cpp
private:
    bool send_and_receive_message(const std::string& message)
    {
        try
        {
            // 1. 메시지 전송 (블로킹)
            write(socket_, boost::asio::buffer(message));
            std::cout << "전송: " << message << std::endl;

            // 2. 응답 수신 (블로킹)
            std::array<char, 1024> buffer;
            size_t reply_length = socket_.read_some(boost::asio::buffer(buffer));

            std::string reply(buffer.data(), reply_length);
            std::cout << "수신: " << reply << std::endl;

            return true;
        }
        // ... 오류 처리 ...
    }
```

  * `write(socket_, ...)`: 사용자가 입력한 메시지를 서버로 전송한다. 전송이 완료될 때까지 **블로킹**된다.
  * `socket_.read_some(...)`: 서버로부터 응답이 올 때까지 **블로킹**되며 기다린다. 응답을 받으면 `buffer`에 저장하고, 읽어온 데이터의 길이를 반환한다.

##### `run_...()` 메소드: 두 가지 실행 모드

```cpp
void run_interactive_session() { /* ... 사용자 입력 처리 ... */ }
void run_automatic_test() { /* ... 미리 정의된 메시지 처리 ... */ }
```

  * `run_interactive_session()`: `while` 루프를 돌며 사용자에게 입력을 받고(`std::getline`), 입력받은 메시지를 `send_and_receive_message` 함수로 보내 처리한다. 'quit'을 입력하면 종료된다.
  * `run_automatic_test()`: `std::vector`에 미리 정의된 테스트 메시지들을 `for` 루프를 돌며 순차적으로 서버에 전송하고 응답을 확인한다.

##### `disconnect()` 메소드: 연결 종료

```cpp
void disconnect()
{
    if (socket_.is_open()) {
        socket_.close();
        std::cout << "서버와의 연결이 종료되었습니다." << std::endl;
    }
}
```

  * 소켓이 열려있는지 확인하고, 열려있다면 `close()`를 호출하여 서버와의 연결을 안전하게 종료한다.

#### `main()` 함수

```cpp
int main(int argc, char* argv[])
{
    try
    {
        SynchronousEchoClient client;

        // 1. 서버에 연결
        if (!client.connect_to_server(SERVER_IP, PORT_NUMBER)) {
            return 1; // 연결 실패 시 종료
        }

        // 2. 실행 모드 결정
        bool auto_mode = false;
        if (argc > 1 && std::string(argv[1]) == "--auto") {
            auto_mode = true;
        }

        // 3. 선택된 모드 실행
        if (auto_mode) {
            client.run_automatic_test();
        } else {
            client.run_interactive_session();
        }

        // 4. 연결 종료
        client.disconnect();
    }
    // ... 예외 처리 ...
}
```

  * 프로그램의 시작점이다.
  * `argc`, `argv`는 프로그램을 실행할 때 전달하는 인자이다. 예를 들어, 터미널에서 `my_client.exe --auto`와 같이 실행하면, `--auto`라는 인자를 감지하여 `auto_mode`를 활성화한다.
  * 프로그램은 **연결 -\> 통신 -\> 연결 종료**의 명확한 순서로 동작한다.

#### 동작 순서 요약
1.  `main` 함수에서 `SynchronousEchoClient` 객체를 생성한다.
2.  `connect_to_server`를 호출하여 서버에 연결을 시도한다. 연결이 완료될 때까지 **대기 (블로킹)**한다.
3.  프로그램 실행 시 `--auto` 인자가 있었는지 확인하여 **대화형 모드** 또는 **자동 테스트 모드**를 결정한다.
4.  선택된 모드를 실행한다.
      * **대화형 모드**: 사용자 입력을 기다린다. 사용자가 메시지를 입력하고 엔터를 치면 `send_and_receive_message` 함수가 호출된다.
      * **자동 테스트 모드**: 미리 정의된 메시지를 순서대로 `send_and_receive_message` 함수를 통해 보낸다.
5.  `send_and_receive_message` 함수 내부에서,
      * 메시지를 서버로 전송하고 완료될 때까지 **대기 (블로킹)**한다.
      * 서버로부터 응답이 올 때까지 **대기 (블로킹)**한다.
      * 받은 응답을 화면에 출력한다.
6.  루프가 끝나면(사용자가 'quit'을 입력하거나 테스트가 완료되면) `disconnect` 함수를 호출하여 연결을 종료하고 프로그램을 마친다.  
  
  
### 3.1.4 실행 및 테스트

**1. 서버 실행:**
Visual Studio에서 서버 프로젝트를 빌드하고 실행한다.

```
Echo 서버가 포트 31400에서 시작되었습니다.
Echo 서버 실행 중... (Ctrl+C로 종료)
```

**2. 클라이언트 실행:**

새로운 콘솔 창에서 클라이언트를 실행한다.

```
# 대화형 모드
> SynchronousEchoClient.exe

# 자동 테스트 모드  
> SynchronousEchoClient.exe --auto
```

**3. 실행 결과:**

서버 측 출력:
```
Echo 서버가 포트 31400에서 시작되었습니다.
Echo 서버 실행 중... (Ctrl+C로 종료)

클라이언트가 연결되었습니다: 127.0.0.1:52341
받은 메시지 [13바이트]: Hello, Server!
응답 전송: Echo: Hello, Server!
받은 메시지 [14바이트]: Test message 1
응답 전송: Echo: Test message 1
클라이언트가 연결을 종료했습니다.
```

클라이언트 측 출력:
```
서버에 성공적으로 연결되었습니다: 127.0.0.1:31400

=== Echo 클라이언트 시작 ===
메시지를 입력하세요 ('quit' 입력 시 종료):

> Hello, Server!
전송: Hello, Server!
수신: Echo: Hello, Server!

> Test message 1
전송: Test message 1
수신: Echo: Test message 1

> quit
클라이언트를 종료합니다.
서버와의 연결이 종료되었습니다.
```
  
</br>     
</br>     


## 3.2 TCP 소켓 프로그래밍 기초

### 3.2.1 TCP 소켓의 기본 개념
TCP(Transmission Control Protocol)는 연결 지향적이고 신뢰할 수 있는 데이터 전송을 제공하는 프로토콜이다.

**TCP의 주요 특징:**
- **연결 지향**: 통신 전에 연결을 설정해야 함
- **신뢰성**: 데이터 손실, 중복, 순서 바뀜을 방지
- **흐름 제어**: 송신자와 수신자의 처리 속도 조절
- **혼잡 제어**: 네트워크 상황에 따른 전송 속도 조절

```cpp
// TCP 연결의 생명주기
class TCPConnectionLifecycle 
{
public:
    void demonstrate_tcp_lifecycle() 
    {
        std::cout << "=== TCP 연결 생명주기 ===\n" << std::endl;
        
        try 
        {
            io_context io_context;
            
            // 1. 소켓 생성
            tcp::socket socket(io_context);
            std::cout << "1. 소켓 생성 완료" << std::endl;
            
            // 2. 서버에 연결 시도
            tcp::endpoint server_endpoint(
                boost::asio::ip::make_address("127.0.0.1"), 31400);
            
            boost::system::error_code connect_error;
            socket.connect(server_endpoint, connect_error);
            
            if (connect_error) {
                std::cout << "2. 연결 실패: " << connect_error.message() << std::endl;
                return;
            }
            
            std::cout << "2. 서버 연결 성공" << std::endl;
            std::cout << "   로컬 주소: " << socket.local_endpoint() << std::endl;
            std::cout << "   원격 주소: " << socket.remote_endpoint() << std::endl;
            
            // 3. 데이터 전송
            std::string message = "Hello, TCP World!";
            write(socket, boost::asio::buffer(message));
            std::cout << "3. 데이터 전송: " << message << std::endl;
            
            // 4. 데이터 수신
            std::array<char, 1024> buffer;
            size_t received_bytes = socket.read_some(boost::asio::buffer(buffer));
            std::string received_data(buffer.data(), received_bytes);
            std::cout << "4. 데이터 수신: " << received_data << std::endl;
            
            // 5. 연결 종료 (graceful shutdown)
            boost::system::error_code shutdown_error;
            socket.shutdown(tcp::socket::shutdown_both, shutdown_error);
            
            socket.close();
            std::cout << "5. 연결 정상 종료" << std::endl;
            
        } catch (std::exception& e) {
            std::cerr << "TCP 연결 중 오류: " << e.what() << std::endl;
        }
    }
    
private:
    io_context io_context_;
};
```

### 3.2.2 소켓 옵션과 설정
TCP 소켓의 동작을 세밀하게 제어하기 위한 다양한 옵션들을 설정할 수 있다.  

```cpp
// 소켓 옵션 설정 클래스
class SocketConfiguration 
{
public:
    static void configure_server_socket(tcp::acceptor& acceptor) 
    {
        std::cout << "=== 서버 소켓 설정 ===\n" << std::endl;
        
        try 
        {
            // SO_REUSEADDR: 주소 재사용 허용 (서버 재시작 시 유용)
            acceptor.set_option(boost::asio::socket_base::reuse_address(true));
            std::cout << "✓ 주소 재사용 활성화" << std::endl;
            
            // SO_KEEPALIVE: 연결 유지 확인
            // acceptor.set_option(boost::asio::socket_base::keep_alive(true));
            // std::cout << "✓ Keep-Alive 활성화" << std::endl;
            
        } catch (std::exception& e) {
            std::cerr << "서버 소켓 설정 오류: " << e.what() << std::endl;
        }
    }
    
    static void configure_client_socket(tcp::socket& socket) 
    {
        std::cout << "=== 클라이언트 소켓 설정 ===\n" << std::endl;
        
        try 
        {
            // TCP_NODELAY: Nagle 알고리즘 비활성화 (지연 최소화)
            socket.set_option(boost::asio::ip::tcp::no_delay(true));
            std::cout << "✓ TCP No Delay 활성화 (Nagle 알고리즘 비활성화)" << std::endl;
            
            // SO_KEEPALIVE: 연결 상태 확인
            socket.set_option(boost::asio::socket_base::keep_alive(true));
            std::cout << "✓ Keep-Alive 활성화" << std::endl;
            
            // SO_RCVBUF: 수신 버퍼 크기 설정
            socket.set_option(boost::asio::socket_base::receive_buffer_size(65536));
            std::cout << "✓ 수신 버퍼 크기: 64KB" << std::endl;
            
            // SO_SNDBUF: 송신 버퍼 크기 설정
            socket.set_option(boost::asio::socket_base::send_buffer_size(65536));
            std::cout << "✓ 송신 버퍼 크기: 64KB" << std::endl;
            
            // SO_LINGER: 소켓 종료 시 대기 시간 설정
            boost::asio::socket_base::linger linger_option(true, 0);
            socket.set_option(linger_option);
            std::cout << "✓ Linger 설정: 즉시 종료" << std::endl;
            
        } 
        catch (std::exception& e) 
        {
            std::cerr << "클라이언트 소켓 설정 오류: " << e.what() << std::endl;
        }
    }
    
    static void print_socket_info(const tcp::socket& socket) 
    {
        std::cout << "\n=== 소켓 정보 ===\n" << std::endl;
        
        try 
        {
            if (socket.is_open()) 
            {
                std::cout << "소켓 상태: 열림" << std::endl;
                std::cout << "로컬 엔드포인트: " << socket.local_endpoint() << std::endl;
                std::cout << "원격 엔드포인트: " << socket.remote_endpoint() << std::endl;
                
                // 옵션 값 조회
                boost::asio::socket_base::receive_buffer_size rcv_buf_option;
                socket.get_option(rcv_buf_option);
                std::cout << "수신 버퍼 크기: " << rcv_buf_option.value() << " bytes" << std::endl;
                
                boost::asio::socket_base::send_buffer_size snd_buf_option;
                socket.get_option(snd_buf_option);
                std::cout << "송신 버퍼 크기: " << snd_buf_option.value() << " bytes" << std::endl;
                
            } 
            else 
            {
                std::cout << "소켓 상태: 닫힘" << std::endl;
            }
        } 
        catch (std::exception& e) 
        {
            std::cerr << "소켓 정보 조회 오류: " << e.what() << std::endl;
        }
    }
};
```

### 3.2.3 에러 처리와 예외 상황
네트워크 프로그래밍에서는 다양한 오류 상황을 적절히 처리해야 한다.  

```cpp
// 포괄적인 에러 처리 예제
class ErrorHandlingExample 
{
public:
    void demonstrate_error_handling() 
    {
        std::cout << "=== 에러 처리 데모 ===\n" << std::endl;
        
        io_context io_context;
        tcp::socket socket(io_context);
        
        // 1. 연결 오류 처리
        test_connection_errors(socket);
        
        // 2. 송수신 오류 처리  
        test_io_errors(socket);
        
        // 3. 타임아웃 처리
        test_timeout_handling(socket);
    }
    
private:
    void test_connection_errors(tcp::socket& socket) 
    {
        std::cout << "1. 연결 오류 테스트\n" << std::endl;
        
        // 존재하지 않는 서버에 연결 시도
        tcp::endpoint invalid_endpoint(
            boost::asio::ip::make_address("192.168.255.255"), 12345);
        
        boost::system::error_code error;
        socket.connect(invalid_endpoint, error);
        
        if (error) 
        {
            std::cout << "예상된 연결 오류 발생:" << std::endl;
            std::cout << "  오류 코드: " << error.value() << std::endl;
            std::cout << "  오류 메시지: " << error.message() << std::endl;
            std::cout << "  오류 범주: " << error.category().name() << std::endl;
            
            // 오류 유형별 처리
            if (error == boost::asio::error::connection_refused) {
                std::cout << "  → 연결 거부됨" << std::endl;
            } else if (error == boost::asio::error::host_unreachable) {
                std::cout << "  → 호스트에 도달할 수 없음" << std::endl;
            } else if (error == boost::asio::error::timed_out) {
                std::cout << "  → 연결 시간 초과" << std::endl;
            } else {
                std::cout << "  → 기타 네트워크 오류" << std::endl;
            }
        }
        
        std::cout << std::endl;
    }
    
    void test_io_errors(tcp::socket& socket) 
    {
        std::cout << "2. I/O 오류 테스트\n" << std::endl;
        
        if (!socket.is_open()) 
        {
            std::cout << "소켓이 닫혀있음 - I/O 작업 시뮬레이션\n" << std::endl;
            
            // 닫힌 소켓에 쓰기 시도
            std::string message = "Test message";
            boost::system::error_code write_error;
            
            try 
            {
                write(socket, boost::asio::buffer(message), write_error);
            } 
            catch (std::exception& e) 
            {
                std::cout << "쓰기 예외: " << e.what() << std::endl;
            }
            
            if (write_error) 
            {
                std::cout << "쓰기 오류: " << write_error.message() << std::endl;
            }
            
            // 닫힌 소켓에서 읽기 시도
            std::array<char, 1024> buffer;
            boost::system::error_code read_error;
            
            try 
            {
                socket.read_some(boost::asio::buffer(buffer), read_error);
            } 
            catch (std::exception& e) 
            {
                std::cout << "읽기 예외: " << e.what() << std::endl;
            }
            
            if (read_error) 
            {
                std::cout << "읽기 오류: " << read_error.message() << std::endl;
            }
        }
        
        std::cout << std::endl;
    }
    
    void test_timeout_handling(tcp::socket& socket) 
    {
        std::cout << "3. 타임아웃 처리 테스트\n" << std::endl;
        
        // 실제 타임아웃 테스트는 복잡하므로 시뮬레이션
        std::cout << "타임아웃 시나리오:" << std::endl;
        std::cout << "  - 읽기 타임아웃: 30초" << std::endl;
        std::cout << "  - 쓰기 타임아웃: 10초" << std::endl;
        std::cout << "  - 연결 타임아웃: 5초" << std::endl;
        
        // Windows에서 소켓 타임아웃 설정 예제
        #ifdef _WIN32
        if (socket.is_open()) 
        {
            try 
            {
                // 수신 타임아웃 설정 (밀리초)
                DWORD recv_timeout = 30000; // 30초
                socket.set_option(boost::asio::detail::socket_option::integer<SOL_SOCKET, SO_RCVTIMEO>(recv_timeout));
                
                // 송신 타임아웃 설정
                DWORD send_timeout = 10000; // 10초  
                socket.set_option(boost::asio::detail::socket_option::integer<SOL_SOCKET, SO_SNDTIMEO>(send_timeout));
                
                std::cout << "✓ 소켓 타임아웃 설정 완료" << std::endl;
            } 
            catch (std::exception& e) 
            {
                std::cout << "타임아웃 설정 실패: " << e.what() << std::endl;
            }
        }
        #endif
        
        std::cout << std::endl;
    }
};
```

### 3.2.4 버퍼 관리와 데이터 처리
효율적인 버퍼 관리는 네트워크 프로그래밍의 핵심이다.

```cpp
// 버퍼 관리 클래스
class BufferManagement 
{
public:
    // 다양한 버퍼 타입 사용 예제
    void demonstrate_buffer_types() 
    {
        std::cout << "=== 버퍼 타입 데모 ===\n" << std::endl;
        
        // 1. std::array 버퍼
        std::array<char, 1024> array_buffer;
        auto array_asio_buffer = boost::asio::buffer(array_buffer);
        std::cout << "1. std::array 버퍼 크기: " << array_asio_buffer.size() << std::endl;
        
        // 2. std::vector 버퍼
        std::vector<char> vector_buffer(2048);
        auto vector_asio_buffer = boost::asio::buffer(vector_buffer);
        std::cout << "2. std::vector 버퍼 크기: " << vector_asio_buffer.size() << std::endl;
        
        // 3. std::string 버퍼
        std::string string_buffer = "Hello, Network World!";
        auto string_asio_buffer = boost::asio::buffer(string_buffer);
        std::cout << "3. std::string 버퍼 크기: " << string_asio_buffer.size() << std::endl;
        
        // 4. C 스타일 배열
        char c_array[512];
        auto c_array_asio_buffer = boost::asio::buffer(c_array, sizeof(c_array));
        std::cout << "4. C 배열 버퍼 크기: " << c_array_asio_buffer.size() << std::endl;
        
        // 5. 동적 버퍼 (boost::asio::dynamic_buffer)
        std::string dynamic_string;
        auto dynamic_buffer = boost::asio::dynamic_buffer(dynamic_string);
        std::cout << "5. 동적 버퍼 초기 크기: " << dynamic_buffer.size() << std::endl;
        
        std::cout << std::endl;
    }
    
    // 패킷 기반 데이터 처리
    void demonstrate_packet_processing() 
    {
        std::cout << "=== 패킷 처리 데모 ===\n" << std::endl;
        
        // 시뮬레이션된 네트워크 데이터
        std::string simulated_data = "HEADER1:Hello World!HEADER2:Game Data";
        
        BufferProcessor processor;
        processor.process_stream_data(simulated_data);
    }
    
private:
    class BufferProcessor 
    {
    private:
        std::string buffer_;
        static constexpr size_t HEADER_SIZE = 8; // "HEADER1:" 등
        
    public:
        void process_stream_data(const std::string& new_data) 
        {
            buffer_ += new_data;
            
            std::cout << "수신 데이터: " << new_data << std::endl;
            std::cout << "버퍼 전체: " << buffer_ << std::endl;
            
            // 패킷 추출 시도
            while (try_extract_packet()) {
                // 패킷 처리 완료
            }
            
            std::cout << "남은 버퍼: " << buffer_ << std::endl;
            std::cout << std::endl;
        }
        
    private:
        bool try_extract_packet() 
        {
            if (buffer_.length() < HEADER_SIZE) {
                return false; // 헤더도 없음
            }
            
            // 헤더 파싱 (간단한 예제)
            std::string header = buffer_.substr(0, HEADER_SIZE);
            
            if (header.substr(0, 6) == "HEADER") 
            {
                // 패킷 길이 결정 (실제로는 헤더에서 읽어옴)
                size_t packet_length = 0;
                if (header == "HEADER1:") {
                    packet_length = HEADER_SIZE + 12; // "Hello World!"
                } else if (header == "HEADER2:") {
                    packet_length = HEADER_SIZE + 9;  // "Game Data"
                }
                
                if (buffer_.length() >= packet_length) 
                {
                    // 완전한 패킷 추출
                    std::string packet = buffer_.substr(0, packet_length);
                    buffer_.erase(0, packet_length);
                    
                    std::string payload = packet.substr(HEADER_SIZE);
                    std::cout << "  → 패킷 처리: " << header.substr(0, 7) 
                             << " 데이터: " << payload << std::endl;
                    
                    return true; // 더 많은 패킷이 있을 수 있음
                }
            }
            
            return false; // 완전한 패킷 없음
        }
    };
};
```
    
이 코드는 TCP/IP와 같은 스트림(Stream) 기반 통신에서 발생하는 **'데이터 경계 문제'를 해결하기 위한 패킷 파서(Packet Parser)** 또는 **버퍼 처리기(Buffer Processor)** 클래스이다. 🧐  
  
네트워크를 통해 데이터를 받을 때, 보낸 쪽에서 한 번에 보냈다고 해서 받는 쪽에서도 한 번에 받는다는 보장이 없다. 데이터가 잘려서 오거나 여러 개가 합쳐져서 올 수 있죠. 이 코드는 이렇게 조각나거나 붙어서 오는 데이터 스트림을 의미 있는 단위인 **패킷(Packet)**으로 재조립하는 역할을 한다.  

#### 🤔 왜 이런 코드가 필요한가? (The Problem)
TCP 통신은 마치 물이 흐르는 파이프와 같다. 데이터를 보내면 파이프를 통해 순서는 보장되어 전달되지만, 어디서부터 어디까지가 하나의 덩어리인지는 알려주지 않는다.  
  
예를 들어, 서버가 `"HEADER1:Hello World!"`와 `"HEADER2:Game Data"`라는 두 개의 메시지를 연달아 보냈을 때, 클라이언트는 아래와 같이 데이터를 받을 수 있다.

  * **Case 1 (데이터가 잘림):** `"HEADER1:Hel"` -\> `"lo World!HEADER2:Game"` -\> `" Data"`
  * **Case 2 (데이터가 합쳐짐):** `"HEADER1:Hello World!HEADER2:Game Data"`
  * **Case 3 (혼합):** `"HEADER1:Hello World!HEAD"` -\> `"ER2:Game Data"`

이런 상황에서 의미 있는 메시지를 정확히 구분해내기 위해 `BufferProcessor` 같은 클래스가 필요하다.  
    
#### ⚙️ 코드의 동작 방식 (How it Works)
이 클래스는 다음과 같은 간단한 규칙(프로토콜)을 기반으로 동작한다.
  
1.  모든 패킷은 8바이트 크기의 **헤더(Header)**로 시작한다. (예: `HEADER1:`, `HEADER2:`)
2.  헤더의 내용에 따라 **패킷의 전체 길이**가 결정된다.
      * `HEADER1:`: 전체 길이 20 바이트 (헤더 8 + 데이터 12)
      * `HEADER2:`: 전체 길이 17 바이트 (헤더 8 + 데이터 9)

#### `process_stream_data(const std::string& new_data)`
이 함수는 네트워크로부터 새로운 데이터 조각(`new_data`)이 도착할 때마다 호출된다.

1.  **데이터 누적:** 새로 도착한 데이터를 내부 버퍼(`buffer_`) 뒤에 계속 이어 붙인다.
    ```cpp
    buffer_ += new_data;
    ```
2.  **패킷 추출 시도:** 버퍼에 완성된 패킷이 있는지 반복적으로 확인하고, 있다면 처리한다.
    ```cpp
    while (try_extract_packet()) {
        // 루프를 돌면서 버퍼에 있는 패킷을 모두 처리
    }
    ```

#### `try_extract_packet()`
이 함수가 실제 패킷을 분석하고 추출하는 핵심 로직이다.

1.  **헤더 길이 확인:** 버퍼에 최소한 헤더 크기(8바이트)만큼의 데이터가 있는지 확인한다. 없으면 아직 패킷을 만들 수 없으므로 `false`를 반환한다.
2.  **패킷 길이 결정:** 헤더를 분석하여 이 패킷의 **전체 길이(`packet_length`)**를 알아낸다.
3.  **전체 길이 확인:** 현재 버퍼에 `packet_length` 만큼의 데이터가 있는지 확인한다. 데이터가 부족하면 아직 패킷이 완성되지 않은 것이므로 `false`를 반환하고 다음 데이터를 기다린다.
4.  **패킷 추출 및 처리:** 버퍼에 완전한 패킷이 있다면,
      * 버퍼의 맨 앞에서 `packet_length` 만큼 데이터를 잘라내어 **완전한 패킷**으로 만든다.
      * 처리한 패킷 부분을 **버퍼에서 삭제**한다. (`buffer_.erase(...)`)
      * 패킷에서 순수 데이터(Payload) 부분을 추출하여 처리 로직을 수행한다. (여기서는 화면에 출력)
      * 패킷 처리에 성공했으므로 `true`를 반환한다. `while` 루프는 이어서 버퍼에 또 다른 완성된 패킷이 있는지 다시 확인한다.
  
#### ✨ 핵심 요약

  * **`buffer_` (버퍼)**: 데이터 조각들을 임시로 저장하는 창고이다.
  * **`process_stream_data()` (입고 담당)**: 창고에 새로운 데이터 조각들을 계속 넣는 역할을 한다.
  * **`try_extract_packet()` (조립 및 출고 담당)**: 창고의 데이터들을 보고, 완성된 제품(패킷)이 있으면 조립해서 꺼내고, 창고에서 해당 부품들을 제거한다.

이 코드는 **네트워크 스트림 데이터를 안정적으로 처리하기 위한 필수적인 로직**을 보여주는 훌륭한 예제이다.      
  

</br>     
</br>       
    

## 3.3 동기 방식의 특징과 한계

### 3.3.1 동기 방식의 장점
동기 방식 네트워크 프로그래밍은 다음과 같은 장점을 가진다:

```cpp
// 동기 방식의 장점을 보여주는 예제
class SynchronousAdvantages 
{
public:
    void demonstrate_simplicity() {
        std::cout << "=== 동기 방식의 장점 ===\n" << std::endl;
        
        // 1. 직관적이고 이해하기 쉬운 코드
        simple_client_example();
        
        // 2. 순차적 실행으로 인한 디버깅 용이성
        debugging_friendly_example();
        
        // 3. 에러 처리의 명확성
        clear_error_handling_example();
    }
    
private:
    void simple_client_example() 
    {
        std::cout << "1. 코드의 직관성\n" << std::endl;
        
        std::cout << "동기 방식 코드:" << std::endl;
        std::cout << R"(
    // 읽기 쉽고 이해하기 쉬운 순차적 코드
    socket.connect(endpoint);           // 1. 연결
    write(socket, buffer("Hello"));     // 2. 전송  
    read(socket, response_buffer);      // 3. 수신
    socket.close();                     // 4. 종료
        )" << std::endl;
        
        try {
            io_context io_context;
            tcp::socket socket(io_context);
            
            // 실제 구현은 간단하고 직관적
            tcp::endpoint endpoint(boost::asio::ip::make_address("127.0.0.1"), 31400);
            
            boost::system::error_code error;
            socket.connect(endpoint, error);
            
            if (!error) {
                std::string message = "Hello from sync client";
                write(socket, boost::asio::buffer(message), error);
                
                if (!error) {
                    std::array<char, 1024> response;
                    size_t len = socket.read_some(boost::asio::buffer(response), error);
                    
                    if (!error) {
                        std::cout << "응답: " << std::string(response.data(), len) << std::endl;
                    }
                }
                
                socket.close();
            }
        } catch (...) {
            std::cout << "연결 실패 (예상됨)" << std::endl;
        }
        
        std::cout << std::endl;
    }
    
    void debugging_friendly_example() 
    {
        std::cout << "2. 디버깅 친화적\n" << std::endl;
        
        std::cout << "동기 방식의 디버깅 장점:" << std::endl;
        std::cout << "  ✓ 단계별 중단점 설정 가능" << std::endl;
        std::cout << "  ✓ 변수 상태 추적 용이" << std::endl;
        std::cout << "  ✓ 호출 스택 추적 간단" << std::endl;
        std::cout << "  ✓ 실행 흐름 예측 가능" << std::endl;
        
        // 디버깅하기 쉬운 예제
        debug_example_function();
        
        std::cout << std::endl;
    }
    
    void debug_example_function() 
    {
        std::cout << "\n디버깅 예제 함수:" << std::endl;
        
        int step = 1;
        std::cout << "Step " << step++ << ": 함수 시작" << std::endl;
        
        std::cout << "Step " << step++ << ": 변수 초기화" << std::endl;
        std::string data = "test data";
        
        std::cout << "Step " << step++ << ": 데이터 처리" << std::endl;
        data = "processed: " + data;
        
        std::cout << "Step " << step++ << ": 결과 = " << data << std::endl;
        std::cout << "Step " << step++ << ": 함수 종료" << std::endl;
    }
    
    void clear_error_handling_example() 
    {
        std::cout << "3. 명확한 에러 처리\n" << std::endl;
        
        std::cout << "동기 방식에서는 각 단계의 에러를 즉시 확인 가능:" << std::endl;
        
        try {
            io_context io_context;
            tcp::socket socket(io_context);
            boost::system::error_code error;
            
            // 1단계: 연결
            tcp::endpoint endpoint(boost::asio::ip::make_address("127.0.0.1"), 31400);
            socket.connect(endpoint, error);
            if (error) {
                std::cout << "  ✗ 연결 실패: " << error.message() << std::endl;
                return;
            }
            std::cout << "  ✓ 연결 성공" << std::endl;
            
            // 2단계: 데이터 전송
            std::string message = "test";
            write(socket, boost::asio::buffer(message), error);
            if (error) {
                std::cout << "  ✗ 전송 실패: " << error.message() << std::endl;
                return;
            }
            std::cout << "  ✓ 전송 성공" << std::endl;
            
            // 3단계: 응답 수신
            std::array<char, 1024> buffer;
            socket.read_some(boost::asio::buffer(buffer), error);
            if (error && error != boost::asio::error::eof) {
                std::cout << "  ✗ 수신 실패: " << error.message() << std::endl;
                return;
            }
            std::cout << "  ✓ 수신 성공" << std::endl;
            
        } catch (...) {
            std::cout << "  ✗ 연결 실패 (서버 없음)" << std::endl;
        }
        
        std::cout << std::endl;
    }
    
private:
    io_context io_context_;
};
```

### 3.3.2 동기 방식의 한계
하지만 동기 방식은 다음과 같은 심각한 한계를 가진다:

```cpp
// 동기 방식의 한계를 보여주는 예제
class SynchronousLimitations 
{
public:
    void demonstrate_limitations() 
    {
        std::cout << "=== 동기 방식의 한계 ===\n" << std::endl;
        
        // 1. 확장성 문제
        scalability_problem();
        
        // 2. 리소스 낭비
        resource_waste_problem();
        
        // 3. 블로킹 문제
        blocking_problem();
    }
    
private:
    void scalability_problem() 
    {
        std::cout << "1. 확장성 문제\n" << std::endl;
        
        std::cout << "동기 방식의 확장성 한계:" << std::endl;
        std::cout << "  • 클라이언트 1개 = 스레드 1개 (또는 프로세스 1개)" << std::endl;
        std::cout << "  • 1000명 동접 = 1000개 스레드 필요" << std::endl;
        std::cout << "  • 스레드 생성/관리 오버헤드 급증" << std::endl;
        
        // 시뮬레이션: 다중 클라이언트 처리
        simulate_multi_client_overhead();
        
        std::cout << std::endl;
    }
    
    void simulate_multi_client_overhead() 
    {
        std::cout << "\n다중 클라이언트 시뮬레이션:" << std::endl;
        
        struct ThreadInfo 
        {
            int client_id;
            size_t stack_size_mb;
            std::chrono::milliseconds creation_time;
        };
        
        std::vector<ThreadInfo> threads;
        
        auto start_time = std::chrono::steady_clock::now();
        
        // 100개 스레드 생성 시뮬레이션
        for (int i = 1; i <= 100; ++i) 
        {
            auto creation_start = std::chrono::steady_clock::now();
            
            // 실제로는 std::thread를 생성하지만, 여기서는 시뮬레이션
            std::this_thread::sleep_for(std::chrono::microseconds(100)); // 스레드 생성 지연
            
            auto creation_end = std::chrono::steady_clock::now();
            auto creation_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                creation_end - creation_start);
            
            threads.push_back({i, 8, creation_time}); // 8MB 스택
            
            if (i % 20 == 0) {
                std::cout << std::format("  {} 스레드 생성됨, 총 메모리: {}MB\n", 
                                       i, i * 8);
            }
        }
        
        auto total_time = std::chrono::steady_clock::now() - start_time;
        std::cout << std::format("  총 생성 시간: {}ms\n", 
                               std::chrono::duration_cast<std::chrono::milliseconds>(total_time).count());
        std::cout << std::format("  총 메모리 사용량: {}MB\n", threads.size() * 8);
        std::cout << std::format("  컨텍스트 스위칭 오버헤드: 매우 높음\n");
    }
    
    void resource_waste_problem() 
    {
        std::cout << "2. 리소스 낭비 문제\n" << std::endl;
        
        std::cout << "동기 방식의 리소스 낭비:" << std::endl;
        std::cout << "  • I/O 대기 중 CPU 유휴" << std::endl;
        std::cout << "  • 스레드당 스택 메모리 점유" << std::endl;
        std::cout << "  • 불필요한 컨텍스트 스위칭" << std::endl;
        
        demonstrate_cpu_waste();
        
        std::cout << std::endl;
    }
    
    void demonstrate_cpu_waste() 
    {
        std::cout << "\nCPU 낭비 데모:" << std::endl;
        
        auto start = std::chrono::steady_clock::now();
        
        // 시뮬레이션: I/O 대기 시간
        std::cout << "  [Thread 1] 네트워크 I/O 대기 중... (5초)" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 실제는 5초지만 짧게
        
        std::cout << "  [Thread 2] 디스크 I/O 대기 중... (3초)" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(60));
        
        std::cout << "  [Thread 3] 데이터베이스 쿼리 대기 중... (2초)" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(40));
        
        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << std::format("  → CPU 활용률: 매우 낮음 (대부분 대기)\n");
        std::cout << std::format("  → 실제 작업 시간: {}ms\n", duration.count());
    }
    
    void blocking_problem() 
    {
        std::cout << "3. 블로킹 문제\n" << std::endl;
        
        std::cout << "동기 방식의 블로킹 이슈:" << std::endl;
        std::cout << "  • 느린 클라이언트가 전체 서버 영향" << std::endl;
        std::cout << "  • I/O 완료까지 다른 작업 불가" << std::endl;
        std::cout << "  • 응답성 저하" << std::endl;
        
        demonstrate_blocking_issue();
        
        std::cout << std::endl;
    }
    
    void demonstrate_blocking_issue() 
    {
        std::cout << "\n블로킹 이슈 데모:" << std::endl;
        
        // 시뮬레이션: 동기 서버의 블로킹 문제
        std::cout << "시나리오: 한 명의 느린 클라이언트가 서버 전체를 지연시킴" << std::endl;
        
        auto start = std::chrono::steady_clock::now();
        
        std::cout << "  [시간 0초] 클라이언트 A 연결" << std::endl;
        std::cout << "  [시간 1초] 클라이언트 B 연결 대기 중..." << std::endl;
        std::cout << "  [시간 2초] 클라이언트 C 연결 대기 중..." << std::endl;
        
        // 클라이언트 A가 느린 처리로 인해 다른 클라이언트들이 대기
        std::cout << "  [시간 3초] 클라이언트 A 느린 요청 처리 중... (5초 소요)" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 실제는 5초
        
        std::cout << "  [시간 8초] 클라이언트 A 처리 완료" << std::endl;
        std::cout << "  [시간 8초] 클라이언트 B 드디어 처리 시작" << std::endl;
        std::cout << "  [시간 8초] 클라이언트 C는 여전히 대기 중..." << std::endl;
        
        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << std::format("\n  결과: 전체 응답 시간 증가, 사용자 경험 저하\n");
        std::cout << std::format("  측정된 지연: {}ms (실제로는 수 초)\n", duration.count());
    }
};
```

### 3.3.3 게임 서버에서의 동기 방식 한계

#### 1) 실시간성 문제
동기 방식은 한 요청이 끝나야 다음 요청을 처리할 수 있어 지연이 누적되기 쉽다. 이는 장르별 응답 시간 목표와 정면으로 충돌한다.

* 장르별 대략적 목표 지연 시간 예시는 다음과 같다.
  * FPS: 약 16ms 이하(60 FPS 틱 루프와 보조를 맞추기 위함)이다.
  * RTS: 50ms 이하가 권장된다.
  * MMORPG: 100ms 이하를 지향한다.
* 문제의 본질은 “헤드-오브-라인 블로킹”이 다. 가벼운 이동 요청이 있더라도, 그 앞에 무거운 요청(예: DB 조회 50ms, 스킬 판정 100ms)이 자리하면 이동 요청이 줄 서서 기다려야 한다.
* 예시 시나리오에서 Move(5ms) → Attack(50ms) → Move(5ms) → Cast Spell(100ms) → Move(5ms)를 순차 처리하면 마지막 Move는 초기 입력 시점으로부터 총 165ms 뒤에야 완료되며, FPS나 RTS의 지연 예산을 크게 초과한다.
* 결과적으로 입력-응답 루프가 끊기고, 피킹·에임·패링 같은 타이밍 기반 상호작용의 체감 품질이 급격히 나빠진다.

##### 추가로 고려할 지점
* 꼬리 지연(tail latency) 증폭: 극소수의 느린 요청이 전체 파이프라인의 평균뿐 아니라 P95/P99 지연을 악화시켜 체감 품질을 망가뜨린다.
* 타임아웃·재시도 폭증: 느린 동기 호출이 연쇄 타임아웃을 유발하고, 재시도가 또 서버 부하를 키우는 악순환이 생긴다.
* 혼합 작업량에서의 불공정성: 가벼운 읽기와 무거운 쓰기가 같은 큐에 섞이면 가벼운 요청도 줄곧 지연된다.
  

#### 2) 동시 접속자(동접) 수 제한
동기 모델은 “요청 1건 ↔ 스레드 1개” 같은 매핑을 자주 강제해 리소스 효율이 떨어진다.
 
* 예시로 최대 스레드 수가 100/500/1000인 서버에서 스레드당 8MB를 잡아도, 동접이 늘수록 메모리 상한과 컨텍스트 스위칭 비용이 빠르게 커진다.
* 스레드 수가 늘면 다음 문제가 누적된다.  
  * 메모리 단편화와 캐시 미스 증가
  * 문맥 전환 비용 증가로 CPU 낭비
  * 락 경합(lock contention)과 커널 수준 동기화 비용 상승
* 결국 “스레드를 더 붙이면 선형 확장”이 성립하지 않고, 특정 임계치를 넘으면 처리량이 오히려 떨어지는 역전 현상이 나타날 수 있다.

##### 추가로 고려할 지점
* 블로킹 I/O 집약 구간에서의 저성능: 네트워크·디스크·DB가 잠깐만 막혀도 해당 스레드가 놀게 되며, 이는 전체 처리량을 갉아먹는다.
* N+1 쿼리 같은 비효율: 동기 흐름에서 반복 조회가 숨어 있으면 요청당 DB 라운드트립이 폭증해 동접 한계가 더 빨리 도래한다.
* 리소스 상한 정책과의 충돌: 파일 디스크립터, 커넥션 풀, 큐 길이 등 운영체제·미들웨어 상한에 빨리 부딪힌다.
  
#### 3) 게임 루프와의 충돌
게임 서버는 일정 주기(예: 16ms)마다 상태 업데이트, 물리, AI, 동기화를 수행해야 한 다. 동기 네트워크 처리나 외부 호출이 루프 안에서 블로킹되면 프레임이 미끄러지며 목표 FPS를 놓치게 된다.

* 예시로 프레임당 게임 로직 5ms + 동기 네트워크 I/O 20ms가 들어가면 한 프레임에 25ms가 걸려 목표 16ms를 초과하고, 평균 FPS가 60 아래로 떨어져 “버벅임”이 발생한다.
* 루프 시간 초과가 반복되면 상태 재동기화 비용이 커지고, 보간/보정 로직이 과도하게 개입하여 위치 튐, 판정 불일치 등의 현상이 늘어난다.

##### 추가로 고려할 지점
* 루프-외부 작업 분리 실패: 틱 루프 안에서 블로킹 RPC를 호출하면 틱 지연이 누적된다.
* 스파이크 대응 취약: GC 스톱·디스크 일시 지연·로그 플러시 같은 스파이크에 루프가 즉시 영향을 받는다.
* 백프레셔(Backpressure) 부재: 수신 큐가 불어나도 동기 처리여서 즉각 조절·드롭·샘플링이 어렵다.


#### 동기 방식의 핵심 병목
헤드-오브-라인 블로킹으로 인한 지연 누적, 2) 스레드/메모리/락 경합 기반의 확장성 한계, 3) 틱 기반 게임 루프와의 구조적 충돌이 핵심 병목이다.


#### 권장 대응 전략(개선 방향)

##### 아키텍처 전환
* 비동기·이벤트 드리븐 I/O로 전환한다. epoll/kqueue 기반 리액터 패턴, 혹은 IOCP 기반 완전 비동기 모델을 채택한다.
* 메시지 지향/액터 모델 도입을 검토한다. 세션이나 엔티티를 액터로 모델링해 격리와 우선순위를 확보한다.
* 읽기-쓰기 경로 분리한다. 읽기는 캐시·CQRS로 단축하고, 쓰기는 배치·저널링·비동기 커밋으로 꼬리 지연을 낮춘다.

##### 실행 모델 최적화
* 틱 루프와 I/O를 분리한다. 틱 스레드는 순수 게임 로직에 집중하고, 네트워크·DB는 비동기 파이프라인과 큐로 연결한다.
* 우선순위 큐와 공정성 정책을 적용한다. 가벼운 요청이 무거운 요청에 가려지지 않게 SLO 기반 스케줄링을 적용한다.
* 백프레셔·큐 제한·드롭 정책을 명문화한다. 과부하 시 빠르게 협상(슬로우 모드, 샘플링, 스킬 판정 지연 보정 등)하여 붕괴를 방지한다.

##### 데이터 계층 최적화
* 캐시 계층을 적극 사용한다. 세션·인벤토리·월드 스냅샷을 메모리 캐시에 두고 캐시 미스만 DB로 보낸다.
* N+1 제거와 조인 최적화, 비동기 파이프라이닝을 적용한다.
* 서킷 브레이커·타임아웃·재시도 지수 백오프를 표준화한다.

##### 운영·관측
* P50/P95/P99 지연과 큐 길이, 드롭률을 실시간으로 모니터링한다.
* 부하 테스트에서 “혼합 트래픽” 시나리오를 포함해 헤드-오브-라인 블로킹을 조기에 드러낸다.
* 슬로우 요청 샘플링과 프로파일링으로 핫스팟을 지속적으로 제거한다.

#### 결론
동기 방식은 단순하다는 장점이 있으나, 실시간 상호작용과 대규모 동접, 틱 기반 루프라는 게임 서버 특성과 잘 맞지 않다. 비동기 I/O, 액터 모델, 백프레셔, 캐싱·파이프라이닝 등으로 전환해야 장르별 지연 예산을 지키고, 꼬리 지연을 낮추며, 동접 증가에도 안정적으로 확장할 수 있다.
  
     
</br>     
</br>        
  

## 3.4 핵심 API 정리
  
### 3.4.1 주요 클래스와 네임스페이스

| 구분            | 주요 내용                                                                                                                                  | 상세 설명 / 예제                             |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| **네임스페이스**    | `boost::asio`                                                                                                                          | 비동기 I/O 핵심 네임스페이스                      |
|               | `boost::asio::ip`                                                                                                                      | 네트워크 관련 (address, tcp, udp)            |
|               | `boost::asio::error`                                                                                                                   | 에러 코드 정의 (`eof`, `connection_reset` 등) |
| **별칭(using)** | `using namespace boost::asio;`<br>`using boost::asio::ip::tcp;`<br>`using boost::asio::ip::udp;`<br>`using boost::system::error_code;` | 자주 쓰는 선언을 단축시킴                         |


#### 핵심 클래스

| 클래스               | 설명                    | 주요 기능 / 메서드                                                                                   |
| ----------------- | --------------------- | --------------------------------------------------------------------------------------------- |
| **io\_context**   | 비동기 작업의 중심, 이벤트 루프 관리 | - `run()`: 이벤트 루프 실행<br>- `poll()`: 대기 중인 작업 실행<br>- `stop()`: 이벤트 루프 중단<br>- `post()`: 작업 추가 |
| **tcp::endpoint** | 네트워크 주소 표현            | IP/Port 조합                                                                                    |
| **tcp::acceptor** | 서버 소켓                 | 클라이언트 연결 수락, 포트 바인딩                                                                           |
| **tcp::socket**   | 클라이언트/서버 통신 소켓        | 데이터 송수신, 연결 관리                                                                                |
| **tcp::resolver** | 도메인/IP 변환             | 호스트명 → IP, 서비스명 → 포트                                                                          |


#### 버퍼 관련 API

| 구분                                  | 설명                   | 예제                                                                         |
| ----------------------------------- | -------------------- | -------------------------------------------------------------------------- |
| **mutable\_buffer / const\_buffer** | 메모리 영역 래핑, 타입 안전성 보장 | -                                                                          |
| **buffer()**                        | 다양한 컨테이너를 버퍼로 변환     | `buffer(std::vector<char>)`                                                |
| **dynamic\_buffer()**               | 동적 크기 조절 가능 버퍼       | `dynamic_buffer(std::string)`                                              |
| **유틸리티 함수**                         | 버퍼 조작 함수             | - `buffer_size()` 크기 계산<br>- `buffer_copy()` 복사<br>- `buffer_cast()` 타입 변환 |


#### 에러 처리 API

| 구분      | 대표 코드                     | 설명              |
| ------- | ------------------------- | --------------- |
| 정상 종료   | `boost::asio::error::eof` | 연결이 정상 종료됨      |
| 연결 관련   | `connection_reset`        | 연결이 강제로 끊김      |
|         | `connection_refused`      | 연결 거부           |
| 네트워크 관련 | `host_unreachable`        | 호스트 도달 불가       |
|         | `network_unreachable`     | 네트워크 도달 불가      |
| 기타      | `timed_out`               | 작업 시간 초과        |
|         | `try_again`               | 재시도 필요          |
|         | `would_block`             | 블로킹 발생 가능 (비동기) |

**패턴**

1. `error_code`로 처리 (권장)
2. `try-catch` 예외 처리


### 3.4.2 동기 I/O 함수 정리

#### 연결 관련 함수

| 함수                         | 설명                     |
| -------------------------- | ---------------------- |
| `acceptor.accept(socket)`  | 서버에서 클라이언트 연결 수락 (블로킹) |
| `socket.connect(endpoint)` | 클라이언트가 서버에 연결 (블로킹)    |
| `socket.close()`           | 소켓 연결 종료               |


#### 읽기 함수

| 함수                                  | 설명                              |
| ----------------------------------- | ------------------------------- |
| `socket.read_some(buffer)`          | 최소 1바이트 이상 읽기, 실제 읽은 크기 반환      |
| `read(socket, buffer)`              | 버퍼를 완전히 채울 때까지 블로킹              |
| `read_until(stream, buffer, delim)` | 구분자(`\n`)까지 읽기, 텍스트 프로토콜에 주로 사용 |


#### 쓰기 함수

| 함수                          | 설명                     |
| --------------------------- | ---------------------- |
| `socket.write_some(buffer)` | 일부 데이터 전송, 실제 전송 크기 반환 |
| `write(socket, buffer)`     | 전체 버퍼 전송 보장 (블로킹)      |
| `write(socket, buffers)`    | 다중 버퍼 전송 가능            |


#### 유틸리티 함수

| 함수                          | 설명                                         |
| --------------------------- | ------------------------------------------ |
| `socket.is_open()`          | 소켓 열림 여부 확인                                |
| `socket.local_endpoint()`   | 로컬 주소 반환                                   |
| `socket.remote_endpoint()`  | 원격 주소 반환                                   |
| `socket.available()`        | 즉시 읽을 수 있는 바이트 수                           |
| `socket.set_option(option)` | 소켓 옵션 설정 (`TCP_NODELAY`, `SO_KEEPALIVE` 등) |

  
### 3.4.3 실습 종합 예제
지금까지 학습한 내용을 종합한 완전한 예제를 만들어보겠다.

**종합 실습: 간단한 채팅 서버**

```cpp
// 동기 방식 채팅 서버 구현
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <thread>
#include <mutex>
#include <format>
#include <boost/asio.hpp>

using namespace boost::asio;
using ip::tcp;

class SimpleChatServer 
{
private:
    io_context io_context_;
    tcp::acceptor acceptor_;
    std::vector<std::shared_ptr<std::thread>> client_threads_;
    std::mutex clients_mutex_;
    std::vector<std::shared_ptr<tcp::socket>> active_clients_;
    std::atomic<bool> server_running_{true};
    
public:
    SimpleChatServer(unsigned short port) 
        : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port)) 
        {
        std::cout << std::format("채팅 서버가 포트 {}에서 시작되었습니다.\n", port);
    }
    
    ~SimpleChatServer() 
    {
        stop();
    }
    
    void run() 
    {
        std::cout << "채팅 서버 실행 중... (Ctrl+C로 종료)\n" << std::endl;
        
        try 
        {
            while (server_running_) 
            {
                auto client_socket = std::make_shared<tcp::socket>(io_context_);
                
                boost::system::error_code accept_error;
                acceptor_.accept(*client_socket, accept_error);
                
                if (accept_error) {
                    if (server_running_) {
                        std::cerr << "Accept 오류: " << accept_error.message() << std::endl;
                    }
                    break;
                }
                
                std::cout << "새 클라이언트 연결: " 
                         << client_socket->remote_endpoint() << std::endl;
                
                // 클라이언트 목록에 추가
                {
                    std::lock_guard<std::mutex> lock(clients_mutex_);
                    active_clients_.push_back(client_socket);
                }
                
                // 새 스레드에서 클라이언트 처리
                auto client_thread = std::make_shared<std::thread>(
                    &SimpleChatServer::handle_client, this, client_socket);
                
                client_threads_.push_back(client_thread);
                
                // 종료된 스레드 정리
                cleanup_finished_threads();
            }
        } catch (std::exception& e) {
            std::cerr << "서버 오류: " << e.what() << std::endl;
        }
    }
    
    void stop() 
    {
        server_running_ = false;
        
        // 모든 클라이언트 연결 종료
        {
            std::lock_guard<std::mutex> lock(clients_mutex_);
            for (auto& client : active_clients_) {
                if (client->is_open()) {
                    boost::system::error_code ec;
                    client->close(ec);
                }
            }
            active_clients_.clear();
        }
        
        // acceptor 종료
        boost::system::error_code ec;
        acceptor_.close(ec);
        
        // 모든 클라이언트 스레드 종료 대기
        for (auto& thread : client_threads_) {
            if (thread->joinable()) {
                thread->join();
            }
        }
        client_threads_.clear();
        
        std::cout << "채팅 서버가 종료되었습니다." << std::endl;
    }
    
private:
    void handle_client(std::shared_ptr<tcp::socket> client_socket) 
    {
        try 
        {
            std::string client_address = client_socket->remote_endpoint().address().to_string();
            std::cout << std::format("[{}] 클라이언트 핸들러 시작\n", client_address);
            
            // 환영 메시지 전송
            std::string welcome_msg = "채팅 서버에 오신 것을 환영합니다!\n";
            boost::system::error_code send_error;
            write(*client_socket, boost::asio::buffer(welcome_msg), send_error);
            
            if (send_error) {
                std::cout << std::format("[{}] 환영 메시지 전송 실패\n", client_address);
                return;
            }
            
            while (server_running_ && client_socket->is_open()) 
            {
                std::array<char, 1024> buffer;
                buffer.fill(0);
                
                boost::system::error_code receive_error;
                size_t length = client_socket->read_some(
                    boost::asio::buffer(buffer), receive_error);
                
                if (receive_error == boost::asio::error::eof) {
                    std::cout << std::format("[{}] 클라이언트 정상 종료\n", client_address);
                    break;
                } else if (receive_error) {
                    std::cout << std::format("[{}] 수신 오류: {}\n", 
                                           client_address, receive_error.message());
                    break;
                }
                
                if (length > 0) 
                {
                    std::string message(buffer.data(), length);
                    
                    // 줄바꿈 제거
                    message.erase(std::remove(message.begin(), message.end(), '\n'), 
                                message.end());
                    message.erase(std::remove(message.begin(), message.end(), '\r'), 
                                message.end());
                    
                    if (!message.empty()) {
                        std::cout << std::format("[{}] 메시지: {}\n", client_address, message);
                        
                        // 모든 클라이언트에게 브로드캐스트
                        broadcast_message(client_address, message);
                    }
                }
            }
            
        } catch (std::exception& e) {
            std::cerr << "클라이언트 처리 중 예외: " << e.what() << std::endl;
        }
        
        // 클라이언트 목록에서 제거
        remove_client(client_socket);
        
        std::string client_address = "알 수 없음";
        try 
        {
            if (client_socket->is_open()) {
                client_address = client_socket->remote_endpoint().address().to_string();
            }
        } catch (...) {}
        
        std::cout << std::format("[{}] 클라이언트 핸들러 종료\n", client_address);
    }
    
    void broadcast_message(const std::string& sender_address, const std::string& message) 
    {
        std::string broadcast_msg = std::format("[{}]: {}\n", sender_address, message);
        
        std::lock_guard<std::mutex> lock(clients_mutex_);
        
        auto it = active_clients_.begin();
        while (it != active_clients_.end()) 
        {
            auto client = *it;
            
            if (!client->is_open()) 
            {
                // 닫힌 소켓 제거
                it = active_clients_.erase(it);
                continue;
            }
            
            boost::system::error_code send_error;
            write(*client, boost::asio::buffer(broadcast_msg), send_error);
            
            if (send_error) 
            {
                // 전송 실패한 클라이언트 제거
                boost::system::error_code close_error;
                client->close(close_error);
                it = active_clients_.erase(it);
            } 
            else 
            {
                ++it;
            }
        }
        
        std::cout << std::format("브로드캐스트 완료: {} ({}명에게 전송)\n", 
                               message, active_clients_.size());
    }
    
    void remove_client(std::shared_ptr<tcp::socket> client_socket) 
    {
        std::lock_guard<std::mutex> lock(clients_mutex_);
        
        active_clients_.erase(
            std::remove(active_clients_.begin(), active_clients_.end(), client_socket),
            active_clients_.end());
    }
    
    void cleanup_finished_threads() 
    {
        auto it = client_threads_.begin();
        while (it != client_threads_.end()) {
            // 스레드가 종료되었는지 확인 (실제로는 더 정교한 방법이 필요)
            ++it;
        }
    }
};

// 메인 함수
int main() 
{
    try {
        SimpleChatServer server(8080);
        
        // Ctrl+C 핸들러 (실제 구현에서는 signal handling 필요)
        server.run();
        
    } catch (std::exception& e) {
        std::cerr << "서버 시작 실패: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```  
     
아래는 이 코드에 대한 설명이다.  

#### 1. 서버 초기화

```cpp
io_context io_context_;
tcp::acceptor acceptor_;
```

* `io_context_`: Boost.Asio의 핵심 객체로 I/O 작업을 관리한다.
* `tcp::acceptor`: 클라이언트 연결을 수락하는 서버 소켓이다.

```cpp
SimpleChatServer(unsigned short port) 
    : acceptor_(io_context_, tcp::endpoint(tcp::v4(), port)) 
{
    std::cout << std::format("채팅 서버가 포트 {}에서 시작되었습니다.\n", port);
}
```

* 생성자에서 `acceptor_`를 특정 포트에 바인딩하여 서버 소켓을 준비한다.


#### 2. 클라이언트 연결 수락

```cpp
while (server_running_) {
    auto client_socket = std::make_shared<tcp::socket>(io_context_);
    acceptor_.accept(*client_socket, accept_error);
    ...
}
```

* 서버는 무한 루프에서 새로운 클라이언트의 연결을 기다린다.
* 연결이 수락되면 새로운 `tcp::socket`을 생성하여 클라이언트와 통신할 준비를 한다.


#### 3. 클라이언트 전용 스레드 실행

```cpp
auto client_thread = std::make_shared<std::thread>(
    &SimpleChatServer::handle_client, this, client_socket);
client_threads_.push_back(client_thread);
```

* 새로운 클라이언트마다 **별도의 스레드**를 생성한다.
* 각 스레드에서는 `handle_client` 함수가 실행되어 클라이언트 메시지를 처리한다.


#### 4. 클라이언트 처리 (핸들러)

```cpp
size_t length = client_socket->read_some(
    boost::asio::buffer(buffer), receive_error);
```

* 클라이언트로부터 데이터를 **동기 방식**으로 읽는다.
* 읽기 작업은 블로킹(blocking)되어 데이터가 도착할 때까지 대기한다.

```cpp
broadcast_message(client_address, message);
```

* 클라이언트가 보낸 메시지를 받아서 **모든 클라이언트에게 브로드캐스트**한다.


#### 5. 메시지 브로드캐스트

```cpp
for (auto& client : active_clients_) {
    write(*client, boost::asio::buffer(broadcast_msg), send_error);
}
```

* 서버에 연결된 모든 클라이언트 소켓에 메시지를 전송한다.
* 전송에 실패한 클라이언트는 목록에서 제거한다.


#### 6. 서버 종료

```cpp
void stop() {
    server_running_ = false;
    acceptor_.close(ec);
    ...
}
```

* `stop()`은 서버 실행을 중단하고 모든 클라이언트 소켓과 스레드를 정리한다.
* 안전한 종료를 위해 **뮤텍스 보호**를 사용하여 동시 접근 문제를 방지한다.


#### 7. 메인 함수

```cpp
int main() 
{
    SimpleChatServer server(8080);
    server.run();
}
```

* 포트 8080에서 서버를 실행한다.
* `Ctrl+C`를 통해 서버를 중단할 수 있다. (실제 서비스에서는 `signal handling` 필요)

  
#### 핵심 요약

1. **Acceptor** → 클라이언트 연결 대기
2. **Socket** → 클라이언트 통신 담당
3. **Thread per client** → 클라이언트별 독립 처리
4. **Broadcast** → 받은 메시지를 모든 클라이언트에 전송
5. **Mutex 보호** → 다중 클라이언트 동시성 제어
6. **Graceful shutdown** → 서버와 클라이언트 정리 후 종료



-----  
     
이제 동기 방식 네트워크 프로그래밍의 기초를 완전히 이해했다. 다음 장에서는 비동기 방식으로 넘어가서 확장 가능하고 고성능인 게임 서버를 구현하는 방법을 학습하겠다.

**학습 정리:**
- ✅ Echo 서버/클라이언트 구현
- ✅ TCP 소켓 프로그래밍 기초 습득
- ✅ 동기 방식의 장단점 이해
- ✅ Boost.Asio 핵심 API 숙지
- ✅ 실전 채팅 서버 구현

동기 방식은 이해하기 쉽고 디버깅이 용이하지만, 확장성과 성능 면에서 한계가 있습니다. 이제 이러한 한계를 극복하는 비동기 프로그래밍으로 진행해보겠다.
 
  
  