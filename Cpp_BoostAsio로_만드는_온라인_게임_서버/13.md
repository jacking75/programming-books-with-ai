# C++ Boost.Asio로 만드는 온라인 게임 서버
저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상
- **도구**: Windows Performance Toolkit, Intel VTune (선택사항)

-----   

# Chapter 13. 타이머와 스케줄링
게임 서버에서 타이머는 핵심적인 역할을 합니다. 주기적인 게임 로직 실행, 이벤트 스케줄링, 타임아웃 처리 등 다양한 용도로 활용됩니다. 이번 장에서는 Boost.Asio의 타이머 기능을 활용하여 효율적이고 정확한 게임 서버 스케줄링 시스템을 구현하는 방법을 학습합니다.

## 13.1 기본 타이머 사용법

### 13.1.1 steady_timer 기본 사용법
Boost.Asio에서 가장 많이 사용되는 타이머는 `steady_timer`입니다. 이는 단조 증가하는 시간을 기반으로 하여 시스템 시간 변경에 영향받지 않습니다.

```cpp
#include <boost/asio.hpp>
#include <boost/asio/steady_timer.hpp>
#include <iostream>
#include <chrono>
#include <functional>

class BasicTimerExample
{
public:
    BasicTimerExample(boost::asio::io_context& io_context)
        : timer_(io_context)
    {
    }

    void StartSimpleTimer()
    {
        std::cout << "Starting 3-second timer..." << std::endl;
        
        // 3초 후 만료되도록 설정
        timer_.expires_after(std::chrono::seconds(3));
        
        // 비동기 대기
        timer_.async_wait([this](const boost::system::error_code& error)
        {
            if (!error)
            {
                std::cout << "Timer expired!" << std::endl;
            }
            else
            {
                std::cout << "Timer error: " << error.message() << std::endl;
            }
        });
    }

    void StartAbsoluteTimer()
    {
        // 절대 시간으로 타이머 설정
        auto future_time = std::chrono::steady_clock::now() + std::chrono::seconds(5);
        timer_.expires_at(future_time);
        
        timer_.async_wait([](const boost::system::error_code& error)
        {
            if (!error)
            {
                std::cout << "Absolute timer expired!" << std::endl;
            }
        });
    }

    void CancelTimer()
    {
        size_t cancelled = timer_.cancel();
        std::cout << "Cancelled " << cancelled << " timer operations" << std::endl;
    }

private:
    boost::asio::steady_timer timer_;
};

// 사용 예제
void BasicTimerUsageExample()
{
    boost::asio::io_context io_context;
    BasicTimerExample example(io_context);
    
    example.StartSimpleTimer();
    
    // 2초 후 타이머 취소
    boost::asio::steady_timer cancel_timer(io_context);
    cancel_timer.expires_after(std::chrono::seconds(2));
    cancel_timer.async_wait([&example](const boost::system::error_code&)
    {
        example.CancelTimer();
    });
    
    io_context.run();
}
```

### 13.1.2 다양한 타이머 종류

```cpp
#include <boost/asio/high_resolution_timer.hpp>
#include <boost/asio/system_timer.hpp>

class TimerTypesExample
{
public:
    TimerTypesExample(boost::asio::io_context& io_context)
        : steady_timer_(io_context),
          high_res_timer_(io_context),
          system_timer_(io_context)
    {
    }

    void DemonstrateTimerTypes()
    {
        // 1. steady_timer - 단조 증가 시간, 시스템 시간 변경에 영향 없음
        steady_timer_.expires_after(std::chrono::milliseconds(100));
        steady_timer_.async_wait([](const boost::system::error_code& error)
        {
            if (!error)
                std::cout << "Steady timer: Precise timing" << std::endl;
        });

        // 2. high_resolution_timer - 가장 정밀한 타이머
        high_res_timer_.expires_after(std::chrono::microseconds(500));
        high_res_timer_.async_wait([](const boost::system::error_code& error)
        {
            if (!error)
                std::cout << "High resolution timer: Very precise" << std::endl;
        });

        // 3. system_timer - 시스템 시간 기반 (wall clock)
        system_timer_.expires_after(std::chrono::milliseconds(200));
        system_timer_.async_wait([](const boost::system::error_code& error)
        {
            if (!error)
                std::cout << "System timer: Wall clock based" << std::endl;
        });
    }

    void ComparePrecision()
    {
        auto start_time = std::chrono::high_resolution_clock::now();
        
        high_res_timer_.expires_after(std::chrono::microseconds(1000)); // 1ms
        high_res_timer_.async_wait([start_time](const boost::system::error_code& error)
        {
            if (!error)
            {
                auto end_time = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
                    end_time - start_time);
                
                std::cout << "Timer precision test: Expected 1000μs, Actual " 
                         << duration.count() << "μs" << std::endl;
            }
        });
    }

private:
    boost::asio::steady_timer steady_timer_;
    boost::asio::high_resolution_timer high_res_timer_;
    boost::asio::system_timer system_timer_;
};
```

### 13.1.3 타이머 오차 측정 및 보정

```cpp
class TimerAccuracyManager
{
public:
    TimerAccuracyManager(boost::asio::io_context& io_context)
        : timer_(io_context), measurement_count_(0), total_error_(0)
    {
    }

    void StartAccuracyTest(std::chrono::milliseconds target_interval, int test_count)
    {
        target_interval_ = target_interval;
        remaining_tests_ = test_count;
        measurement_count_ = 0;
        total_error_ = 0;
        
        last_expected_time_ = std::chrono::steady_clock::now() + target_interval;
        ScheduleAccuracyTest();
    }

    void GetAccuracyStats(double& avg_error_ms, double& max_error_ms) const
    {
        if (measurement_count_ > 0)
        {
            avg_error_ms = total_error_ / measurement_count_;
            max_error_ms = max_error_;
        }
        else
        {
            avg_error_ms = max_error_ms = 0.0;
        }
    }

private:
    void ScheduleAccuracyTest()
    {
        if (remaining_tests_ <= 0)
        {
            PrintAccuracyResults();
            return;
        }

        timer_.expires_at(last_expected_time_);
        timer_.async_wait([this](const boost::system::error_code& error)
        {
            if (!error)
            {
                MeasureAccuracy();
                
                last_expected_time_ += target_interval_;
                remaining_tests_--;
                ScheduleAccuracyTest();
            }
        });
    }

    void MeasureAccuracy()
    {
        auto actual_time = std::chrono::steady_clock::now();
        auto error_duration = actual_time - last_expected_time_;
        double error_ms = std::chrono::duration<double, std::milli>(error_duration).count();
        
        total_error_ += std::abs(error_ms);
        max_error_ = std::max(max_error_, std::abs(error_ms));
        measurement_count_++;
        
        std::cout << "Timer " << measurement_count_ 
                 << " error: " << error_ms << "ms" << std::endl;
    }

    void PrintAccuracyResults()
    {
        double avg_error, max_error;
        GetAccuracyStats(avg_error, max_error);
        
        std::cout << "\nTimer Accuracy Results:" << std::endl;
        std::cout << "Target interval: " << target_interval_.count() << "ms" << std::endl;
        std::cout << "Average error: " << avg_error << "ms" << std::endl;
        std::cout << "Maximum error: " << max_error << "ms" << std::endl;
        std::cout << "Total measurements: " << measurement_count_ << std::endl;
    }

    boost::asio::steady_timer timer_;
    std::chrono::milliseconds target_interval_;
    std::chrono::steady_clock::time_point last_expected_time_;
    int remaining_tests_;
    
    int measurement_count_;
    double total_error_;
    double max_error_ = 0.0;
};
```
  
</br>  


## 13.2 반복 타이머 구현

### 13.2.1 기본 반복 타이머

```cpp
class RepeatingTimer
{
public:
    using TimerCallback = std::function<void()>;

    RepeatingTimer(boost::asio::io_context& io_context)
        : timer_(io_context), is_running_(false)
    {
    }

    void Start(std::chrono::milliseconds interval, TimerCallback callback)
    {
        if (is_running_)
            return;

        interval_ = interval;
        callback_ = callback;
        is_running_ = true;
        
        ScheduleNext();
    }

    void Stop()
    {
        is_running_ = false;
        timer_.cancel();
    }

    bool IsRunning() const
    {
        return is_running_;
    }

    void ChangeInterval(std::chrono::milliseconds new_interval)
    {
        interval_ = new_interval;
        
        if (is_running_)
        {
            timer_.cancel();
            ScheduleNext();
        }
    }

private:
    void ScheduleNext()
    {
        if (!is_running_)
            return;

        timer_.expires_after(interval_);
        timer_.async_wait([this](const boost::system::error_code& error)
        {
            if (!error && is_running_)
            {
                try
                {
                    callback_();
                }
                catch (const std::exception& e)
                {
                    std::cerr << "Timer callback exception: " << e.what() << std::endl;
                }
                
                ScheduleNext();
            }
        });
    }

    boost::asio::steady_timer timer_;
    std::chrono::milliseconds interval_;
    TimerCallback callback_;
    bool is_running_;
};

// 사용 예제
void RepeatingTimerExample()
{
    boost::asio::io_context io_context;
    RepeatingTimer timer(io_context);
    
    int counter = 0;
    timer.Start(std::chrono::milliseconds(500), [&counter]()
    {
        std::cout << "Tick " << ++counter << std::endl;
        
        if (counter >= 10)
        {
            std::cout << "Stopping timer after 10 ticks" << std::endl;
            // timer.Stop(); // 실제로는 타이머 참조를 캡처해야 함
        }
    });
    
    io_context.run();
}
```

### 13.2.2 정밀한 간격 유지를 위한 개선된 반복 타이머

```cpp
class PreciseRepeatingTimer
{
public:
    using TimerCallback = std::function<void(int64_t tick_number)>;

    PreciseRepeatingTimer(boost::asio::io_context& io_context)
        : timer_(io_context), is_running_(false), tick_number_(0)
    {
    }

    void Start(std::chrono::microseconds interval, TimerCallback callback)
    {
        if (is_running_)
            return;

        interval_ = interval;
        callback_ = callback;
        is_running_ = true;
        tick_number_ = 0;
        
        start_time_ = std::chrono::steady_clock::now();
        next_tick_time_ = start_time_ + interval_;
        
        ScheduleNextPrecise();
    }

    void Stop()
    {
        is_running_ = false;
        timer_.cancel();
    }

    double GetAverageJitter() const
    {
        if (jitter_measurements_.empty())
            return 0.0;
            
        double sum = 0.0;
        for (double jitter : jitter_measurements_)
        {
            sum += jitter;
        }
        return sum / jitter_measurements_.size();
    }

    void PrintStatistics() const
    {
        std::cout << "Timer Statistics:" << std::endl;
        std::cout << "Total ticks: " << tick_number_ << std::endl;
        std::cout << "Average jitter: " << GetAverageJitter() << " ms" << std::endl;
        
        if (!jitter_measurements_.empty())
        {
            auto minmax = std::minmax_element(jitter_measurements_.begin(), 
                                            jitter_measurements_.end());
            std::cout << "Min jitter: " << *minmax.first << " ms" << std::endl;
            std::cout << "Max jitter: " << *minmax.second << " ms" << std::endl;
        }
    }

private:
    void ScheduleNextPrecise()
    {
        if (!is_running_)
            return;

        timer_.expires_at(next_tick_time_);
        timer_.async_wait([this](const boost::system::error_code& error)
        {
            if (!error && is_running_)
            {
                auto actual_time = std::chrono::steady_clock::now();
                
                // 지터 측정
                auto jitter = std::chrono::duration<double, std::milli>(
                    actual_time - next_tick_time_).count();
                jitter_measurements_.push_back(std::abs(jitter));
                
                // 최대 1000개의 측정값만 유지
                if (jitter_measurements_.size() > 1000)
                {
                    jitter_measurements_.erase(jitter_measurements_.begin());
                }
                
                tick_number_++;
                
                try
                {
                    callback_(tick_number_);
                }
                catch (const std::exception& e)
                {
                    std::cerr << "Timer callback exception: " << e.what() << std::endl;
                }
                
                // 다음 틱 시간 계산 (누적 오차 방지)
                next_tick_time_ += interval_;
                
                // 너무 많이 뒤처진 경우 리셋
                if (actual_time > next_tick_time_ + interval_ * 10)
                {
                    std::cout << "Timer reset due to excessive lag" << std::endl;
                    next_tick_time_ = actual_time + interval_;
                }
                
                ScheduleNextPrecise();
            }
        });
    }

    boost::asio::steady_timer timer_;
    std::chrono::microseconds interval_;
    TimerCallback callback_;
    bool is_running_;
    
    std::chrono::steady_clock::time_point start_time_;
    std::chrono::steady_clock::time_point next_tick_time_;
    int64_t tick_number_;
    
    std::vector<double> jitter_measurements_;
};
```

### 13.2.3 적응형 타이머 (서버 부하에 따른 조절)

```cpp
class AdaptiveTimer
{
public:
    using TimerCallback = std::function<bool()>; // false 반환 시 타이머 중지

    AdaptiveTimer(boost::asio::io_context& io_context)
        : timer_(io_context), is_running_(false), load_factor_(1.0)
    {
    }

    void Start(std::chrono::milliseconds base_interval, TimerCallback callback)
    {
        base_interval_ = base_interval;
        callback_ = callback;
        is_running_ = true;
        
        ScheduleAdaptive();
    }

    void UpdateLoadFactor(double load_factor)
    {
        // 부하 인자: 1.0 = 정상, > 1.0 = 과부하, < 1.0 = 여유
        load_factor_ = std::clamp(load_factor, 0.1, 5.0);
        
        std::cout << "Timer load factor updated: " << load_factor_ << std::endl;
    }

    void Stop()
    {
        is_running_ = false;
        timer_.cancel();
    }

private:
    void ScheduleAdaptive()
    {
        if (!is_running_)
            return;

        // 부하에 따라 간격 조정
        auto adjusted_interval = std::chrono::duration_cast<std::chrono::milliseconds>(
            base_interval_ * load_factor_);
        
        // 최소/최대 간격 제한
        adjusted_interval = std::max(adjusted_interval, std::chrono::milliseconds(10));
        adjusted_interval = std::min(adjusted_interval, std::chrono::milliseconds(5000));

        timer_.expires_after(adjusted_interval);
        timer_.async_wait([this](const boost::system::error_code& error)
        {
            if (!error && is_running_)
            {
                auto start_time = std::chrono::steady_clock::now();
                
                bool should_continue = true;
                try
                {
                    should_continue = callback_();
                }
                catch (const std::exception& e)
                {
                    std::cerr << "Adaptive timer callback exception: " << e.what() << std::endl;
                    should_continue = false;
                }
                
                auto end_time = std::chrono::steady_clock::now();
                auto execution_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                    end_time - start_time);
                
                // 실행 시간이 간격보다 긴 경우 부하 증가
                if (execution_time > base_interval_ / 2)
                {
                    UpdateLoadFactor(load_factor_ * 1.1);
                }
                else if (execution_time < base_interval_ / 10)
                {
                    UpdateLoadFactor(load_factor_ * 0.95);
                }
                
                if (should_continue)
                {
                    ScheduleAdaptive();
                }
                else
                {
                    is_running_ = false;
                }
            }
        });
    }

    boost::asio::steady_timer timer_;
    std::chrono::milliseconds base_interval_;
    TimerCallback callback_;
    bool is_running_;
    double load_factor_;
};
``` 
   
</br>  


## 13.3 타이머 취소와 관리

### 13.3.1 타이머 관리자 클래스

```cpp
class TimerManager
{
public:
    using TimerID = uint64_t;
    using TimerCallback = std::function<void(TimerID)>;

    TimerManager(boost::asio::io_context& io_context)
        : io_context_(io_context), next_timer_id_(1)
    {
    }

    TimerID CreateTimer(std::chrono::milliseconds delay, TimerCallback callback)
    {
        TimerID id = next_timer_id_++;
        
        auto timer_info = std::make_shared<TimerInfo>();
        timer_info->id = id;
        timer_info->timer = std::make_unique<boost::asio::steady_timer>(io_context_);
        timer_info->callback = callback;
        timer_info->is_repeating = false;
        
        timer_info->timer->expires_after(delay);
        timer_info->timer->async_wait([this, id](const boost::system::error_code& error)
        {
            HandleTimerExpiry(id, error);
        });
        
        std::lock_guard<std::mutex> lock(timers_mutex_);
        timers_[id] = timer_info;
        
        return id;
    }

    TimerID CreateRepeatingTimer(std::chrono::milliseconds interval, TimerCallback callback)
    {
        TimerID id = next_timer_id_++;
        
        auto timer_info = std::make_shared<TimerInfo>();
        timer_info->id = id;
        timer_info->timer = std::make_unique<boost::asio::steady_timer>(io_context_);
        timer_info->callback = callback;
        timer_info->is_repeating = true;
        timer_info->interval = interval;
        
        ScheduleRepeatingTimer(timer_info);
        
        std::lock_guard<std::mutex> lock(timers_mutex_);
        timers_[id] = timer_info;
        
        return id;
    }

    bool CancelTimer(TimerID timer_id)
    {
        std::lock_guard<std::mutex> lock(timers_mutex_);
        
        auto it = timers_.find(timer_id);
        if (it != timers_.end())
        {
            it->second->timer->cancel();
            timers_.erase(it);
            return true;
        }
        
        return false;
    }

    void CancelAllTimers()
    {
        std::lock_guard<std::mutex> lock(timers_mutex_);
        
        for (auto& pair : timers_)
        {
            pair.second->timer->cancel();
        }
        
        timers_.clear();
    }

    size_t GetActiveTimerCount() const
    {
        std::lock_guard<std::mutex> lock(timers_mutex_);
        return timers_.size();
    }

    std::vector<TimerID> GetActiveTimerIDs() const
    {
        std::lock_guard<std::mutex> lock(timers_mutex_);
        
        std::vector<TimerID> ids;
        ids.reserve(timers_.size());
        
        for (const auto& pair : timers_)
        {
            ids.push_back(pair.first);
        }
        
        return ids;
    }

private:
    struct TimerInfo
    {
        TimerID id;
        std::unique_ptr<boost::asio::steady_timer> timer;
        TimerCallback callback;
        bool is_repeating;
        std::chrono::milliseconds interval;
    };

    void HandleTimerExpiry(TimerID timer_id, const boost::system::error_code& error)
    {
        if (error == boost::asio::error::operation_aborted)
        {
            // 타이머가 취소됨
            return;
        }

        std::shared_ptr<TimerInfo> timer_info;
        {
            std::lock_guard<std::mutex> lock(timers_mutex_);
            auto it = timers_.find(timer_id);
            if (it != timers_.end())
            {
                timer_info = it->second;
                
                // 일회성 타이머는 제거
                if (!timer_info->is_repeating)
                {
                    timers_.erase(it);
                }
            }
        }

        if (timer_info)
        {
            try
            {
                timer_info->callback(timer_id);
            }
            catch (const std::exception& e)
            {
                std::cerr << "Timer callback exception for ID " << timer_id 
                         << ": " << e.what() << std::endl;
            }

            // 반복 타이머인 경우 다시 스케줄링
            if (timer_info->is_repeating)
            {
                ScheduleRepeatingTimer(timer_info);
            }
        }
    }

    void ScheduleRepeatingTimer(std::shared_ptr<TimerInfo> timer_info)
    {
        timer_info->timer->expires_after(timer_info->interval);
        timer_info->timer->async_wait([this, timer_id = timer_info->id]
                                     (const boost::system::error_code& error)
        {
            HandleTimerExpiry(timer_id, error);
        });
    }

    boost::asio::io_context& io_context_;
    std::atomic<TimerID> next_timer_id_;
    std::unordered_map<TimerID, std::shared_ptr<TimerInfo>> timers_;
    mutable std::mutex timers_mutex_;
};
```

### 13.3.2 타이머 그룹 관리

```cpp
class TimerGroup
{
public:
    TimerGroup(TimerManager& timer_manager, const std::string& name)
        : timer_manager_(timer_manager), name_(name)
    {
    }

    ~TimerGroup()
    {
        CancelAll();
    }

    TimerManager::TimerID AddTimer(std::chrono::milliseconds delay, 
                                  TimerManager::TimerCallback callback)
    {
        auto timer_id = timer_manager_.CreateTimer(delay, callback);
        
        std::lock_guard<std::mutex> lock(timers_mutex_);
        timers_.insert(timer_id);
        
        return timer_id;
    }

    TimerManager::TimerID AddRepeatingTimer(std::chrono::milliseconds interval,
                                           TimerManager::TimerCallback callback)
    {
        auto timer_id = timer_manager_.CreateRepeatingTimer(interval, callback);
        
        std::lock_guard<std::mutex> lock(timers_mutex_);
        timers_.insert(timer_id);
        
        return timer_id;
    }

    bool RemoveTimer(TimerManager::TimerID timer_id)
    {
        std::lock_guard<std::mutex> lock(timers_mutex_);
        
        if (timers_.erase(timer_id) > 0)
        {
            return timer_manager_.CancelTimer(timer_id);
        }
        
        return false;
    }

    void CancelAll()
    {
        std::lock_guard<std::mutex> lock(timers_mutex_);
        
        for (auto timer_id : timers_)
        {
            timer_manager_.CancelTimer(timer_id);
        }
        
        timers_.clear();
        std::cout << "Timer group '" << name_ << "' cancelled all timers" << std::endl;
    }

    size_t GetTimerCount() const
    {
        std::lock_guard<std::mutex> lock(timers_mutex_);
        return timers_.size();
    }

    const std::string& GetName() const
    {
        return name_;
    }

private:
    TimerManager& timer_manager_;
    std::string name_;
    std::unordered_set<TimerManager::TimerID> timers_;
    mutable std::mutex timers_mutex_;
};

// 사용 예제
void TimerGroupExample()
{
    boost::asio::io_context io_context;
    TimerManager timer_manager(io_context);
    
    // 플레이어별 타이머 그룹
    TimerGroup player_timers(timer_manager, "Player");
    TimerGroup system_timers(timer_manager, "System");
    
    // 플레이어 관련 타이머들
    player_timers.AddTimer(std::chrono::seconds(5), [](TimerManager::TimerID id)
    {
        std::cout << "Player skill cooldown expired (ID: " << id << ")" << std::endl;
    });
    
    player_timers.AddRepeatingTimer(std::chrono::seconds(1), [](TimerManager::TimerID id)
    {
        std::cout << "Player health regeneration (ID: " << id << ")" << std::endl;
        return true; // 계속 반복
    });
    
    // 시스템 관련 타이머들
    system_timers.AddRepeatingTimer(std::chrono::seconds(10), [](TimerManager::TimerID id)
    {
        std::cout << "System statistics update (ID: " << id << ")" << std::endl;
        return true;
    });
    
    // 5초 후 플레이어 타이머 그룹 전체 취소
    timer_manager.CreateTimer(std::chrono::seconds(5), [&player_timers](TimerManager::TimerID)
    {
        std::cout << "Cancelling all player timers..." << std::endl;
        player_timers.CancelAll();
    });
    
    io_context.run();
}
```

### 13.3.3 타이머 풀링과 재사용

```cpp
class TimerPool
{
public:
    TimerPool(boost::asio::io_context& io_context, size_t initial_size = 10)
        : io_context_(io_context)
    {
        // 초기 타이머 풀 생성
        for (size_t i = 0; i < initial_size; ++i)
        {
            available_timers_.push(std::make_unique<boost::asio::steady_timer>(io_context_));
        }
    }

    std::unique_ptr<boost::asio::steady_timer> AcquireTimer()
    {
        std::lock_guard<std::mutex> lock(pool_mutex_);
        
        if (!available_timers_.empty())
        {
            auto timer = std::move(available_timers_.top());
            available_timers_.pop();
            return timer;
        }
        
        // 풀이 비어있으면 새로 생성
        return std::make_unique<boost::asio::steady_timer>(io_context_);
    }

    void ReturnTimer(std::unique_ptr<boost::asio::steady_timer> timer)
    {
        if (!timer)
            return;

        // 타이머 상태 리셋
        boost::system::error_code ec;
        timer->cancel(ec);
        
        std::lock_guard<std::mutex> lock(pool_mutex_);
        
        // 풀 크기 제한
        if (available_timers_.size() < 50)
        {
            available_timers_.push(std::move(timer));
        }
        // 제한 초과 시 자동 소멸
    }

    size_t GetAvailableCount() const
    {
        std::lock_guard<std::mutex> lock(pool_mutex_);
        return available_timers_.size();
    }

private:
    boost::asio::io_context& io_context_;
    std::stack<std::unique_ptr<boost::asio::steady_timer>> available_timers_;
    mutable std::mutex pool_mutex_;
};

class PooledTimerManager
{
public:
    PooledTimerManager(boost::asio::io_context& io_context)
        : timer_pool_(io_context)
    {
    }

    void ScheduleOneShot(std::chrono::milliseconds delay, std::function<void()> callback)
    {
        auto timer = timer_pool_.AcquireTimer();
        auto timer_ptr = timer.get();
        
        timer->expires_after(delay);
        timer->async_wait([this, timer = std::move(timer), callback]
                         (const boost::system::error_code& error) mutable
        {
            if (!error)
            {
                try
                {
                    callback();
                }
                catch (const std::exception& e)
                {
                    std::cerr << "Pooled timer callback exception: " << e.what() << std::endl;
                }
            }
            
            // 타이머를 풀에 반환
            timer_pool_.ReturnTimer(std::move(timer));
        });
    }

    void PrintPoolStatistics() const
    {
        std::cout << "Timer pool available timers: " 
                 << timer_pool_.GetAvailableCount() << std::endl;
    }

private:
    TimerPool timer_pool_;
};
```
  
</br>   
  

## 13.4 게임 로직 스케줄링

### 13.4.1 게임 틱 시스템

```cpp
class GameTickSystem
{
public:
    static constexpr int TARGET_TPS = 30; // Ticks Per Second
    static constexpr std::chrono::microseconds TICK_DURATION{1000000 / TARGET_TPS};

    GameTickSystem(boost::asio::io_context& io_context)
        : timer_(io_context), is_running_(false), current_tick_(0)
    {
    }

    void Start()
    {
        if (is_running_)
            return;

        is_running_ = true;
        current_tick_ = 0;
        last_tick_time_ = std::chrono::steady_clock::now();
        next_tick_time_ = last_tick_time_ + TICK_DURATION;
        
        std::cout << "Game tick system started (Target: " << TARGET_TPS << " TPS)" << std::endl;
        ScheduleNextTick();
    }

    void Stop()
    {
        is_running_ = false;
        timer_.cancel();
        PrintTickStatistics();
    }

    void RegisterTickHandler(std::function<void(uint64_t)> handler)
    {
        tick_handlers_.push_back(handler);
    }

    uint64_t GetCurrentTick() const
    {
        return current_tick_;
    }

    double GetActualTPS() const
    {
        if (tick_times_.size() < 2)
            return 0.0;

        auto duration = tick_times_.back() - tick_times_.front();
        auto seconds = std::chrono::duration<double>(duration).count();
        return (tick_times_.size() - 1) / seconds;
    }

private:
    void ScheduleNextTick()
    {
        if (!is_running_)
            return;

        timer_.expires_at(next_tick_time_);
        timer_.async_wait([this](const boost::system::error_code& error)
        {
            if (!error && is_running_)
            {
                ProcessTick();
                
                current_tick_++;
                next_tick_time_ += TICK_DURATION;
                
                // 너무 뒤처진 경우 스킵
                auto now = std::chrono::steady_clock::now();
                if (now > next_tick_time_ + TICK_DURATION * 5)
                {
                    std::cout << "Warning: Tick system lagging, skipping to current time" << std::endl;
                    next_tick_time_ = now + TICK_DURATION;
                }
                
                ScheduleNextTick();
            }
        });
    }

    void ProcessTick()
    {
        auto tick_start = std::chrono::steady_clock::now();
        
        // 틱 시간 기록 (최근 100개만 유지)
        tick_times_.push_back(tick_start);
        if (tick_times_.size() > 100)
        {
            tick_times_.erase(tick_times_.begin());
        }

        // 모든 틱 핸들러 실행
        for (auto& handler : tick_handlers_)
        {
            try
            {
                handler(current_tick_);
            }
            catch (const std::exception& e)
            {
                std::cerr << "Tick handler exception: " << e.what() << std::endl;
            }
        }

        auto tick_end = std::chrono::steady_clock::now();
        auto tick_duration = std::chrono::duration_cast<std::chrono::microseconds>(
            tick_end - tick_start);

        // 성능 경고
        if (tick_duration > TICK_DURATION / 2)
        {
            std::cout << "Warning: Tick " << current_tick_ 
                     << " took " << tick_duration.count() << "μs (target: " 
                     << TICK_DURATION.count() << "μs)" << std::endl;
        }
    }

    void PrintTickStatistics()
    {
        std::cout << "\nTick System Statistics:" << std::endl;
        std::cout << "Total ticks: " << current_tick_ << std::endl;
        std::cout << "Target TPS: " << TARGET_TPS << std::endl;
        std::cout << "Actual TPS: " << GetActualTPS() << std::endl;
    }

    boost::asio::steady_timer timer_;
    bool is_running_;
    uint64_t current_tick_;
    
    std::chrono::steady_clock::time_point last_tick_time_;
    std::chrono::steady_clock::time_point next_tick_time_;
    
    std::vector<std::function<void(uint64_t)>> tick_handlers_;
    std::vector<std::chrono::steady_clock::time_point> tick_times_;
};
```

### 13.4.2 이벤트 스케줄러

```cpp
class GameEventScheduler
{
public:
    using EventID = uint64_t;
    using EventCallback = std::function<void(EventID)>;

    struct ScheduledEvent
    {
        EventID id;
        std::chrono::steady_clock::time_point execute_time;
        EventCallback callback;
        std::string description;
        bool is_repeating;
        std::chrono::milliseconds repeat_interval;
    };

    GameEventScheduler(boost::asio::io_context& io_context)
        : timer_(io_context), next_event_id_(1)
    {
        StartProcessing();
    }

    EventID ScheduleEvent(std::chrono::milliseconds delay, 
                         EventCallback callback,
                         const std::string& description = "")
    {
        EventID id = next_event_id_++;
        auto execute_time = std::chrono::steady_clock::now() + delay;
        
        ScheduledEvent event;
        event.id = id;
        event.execute_time = execute_time;
        event.callback = callback;
        event.description = description;
        event.is_repeating = false;
        
        std::lock_guard<std::mutex> lock(events_mutex_);
        events_.push(event);
        
        std::cout << "Event " << id << " scheduled: " << description << std::endl;
        return id;
    }

    EventID ScheduleRepeatingEvent(std::chrono::milliseconds initial_delay,
                                  std::chrono::milliseconds repeat_interval,
                                  EventCallback callback,
                                  const std::string& description = "")
    {
        EventID id = next_event_id_++;
        auto execute_time = std::chrono::steady_clock::now() + initial_delay;
        
        ScheduledEvent event;
        event.id = id;
        event.execute_time = execute_time;
        event.callback = callback;
        event.description = description;
        event.is_repeating = true;
        event.repeat_interval = repeat_interval;
        
        std::lock_guard<std::mutex> lock(events_mutex_);
        events_.push(event);
        
        std::cout << "Repeating event " << id << " scheduled: " << description << std::endl;
        return id;
    }

    bool CancelEvent(EventID event_id)
    {
        std::lock_guard<std::mutex> lock(events_mutex_);
        cancelled_events_.insert(event_id);
        return true; // 실제로는 취소 성공 여부를 반환해야 함
    }

    size_t GetPendingEventCount() const
    {
        std::lock_guard<std::mutex> lock(events_mutex_);
        return events_.size();
    }

private:
    struct EventComparator
    {
        bool operator()(const ScheduledEvent& a, const ScheduledEvent& b) const
        {
            return a.execute_time > b.execute_time; // 최소 힙을 위한 역순
        }
    };

    void StartProcessing()
    {
        timer_.expires_after(std::chrono::milliseconds(10));
        timer_.async_wait([this](const boost::system::error_code& error)
        {
            if (!error)
            {
                ProcessEvents();
                StartProcessing();
            }
        });
    }

    void ProcessEvents()
    {
        auto now = std::chrono::steady_clock::now();
        std::vector<ScheduledEvent> ready_events;
        
        {
            std::lock_guard<std::mutex> lock(events_mutex_);
            
            while (!events_.empty() && events_.top().execute_time <= now)
            {
                ready_events.push_back(events_.top());
                events_.pop();
            }
        }

        for (auto& event : ready_events)
        {
            // 취소된 이벤트 체크
            if (cancelled_events_.count(event.id) > 0)
            {
                cancelled_events_.erase(event.id);
                continue;
            }

            try
            {
                event.callback(event.id);
                std::cout << "Event " << event.id << " executed: " 
                         << event.description << std::endl;
            }
            catch (const std::exception& e)
            {
                std::cerr << "Event " << event.id << " callback exception: " 
                         << e.what() << std::endl;
            }

            // 반복 이벤트 재스케줄링
            if (event.is_repeating)
            {
                event.execute_time = now + event.repeat_interval;
                
                std::lock_guard<std::mutex> lock(events_mutex_);
                events_.push(event);
            }
        }
    }

    boost::asio::steady_timer timer_;
    std::atomic<EventID> next_event_id_;
    
    std::priority_queue<ScheduledEvent, std::vector<ScheduledEvent>, EventComparator> events_;
    std::unordered_set<EventID> cancelled_events_;
    mutable std::mutex events_mutex_;
};
```

### 13.4.3 게임 서버 통합 스케줄링 시스템

```cpp
class GameServerScheduler
{
public:
    GameServerScheduler(boost::asio::io_context& io_context)
        : tick_system_(io_context),
          event_scheduler_(io_context),
          timer_manager_(io_context)
    {
        SetupGameSystems();
    }

    void Start()
    {
        std::cout << "Starting game server scheduler..." << std::endl;
        tick_system_.Start();
    }

    void Stop()
    {
        std::cout << "Stopping game server scheduler..." << std::endl;
        tick_system_.Stop();
        timer_manager_.CancelAllTimers();
    }

    // 플레이어 관련 스케줄링
    void SchedulePlayerRespawn(uint32_t player_id, std::chrono::seconds delay)
    {
        event_scheduler_.ScheduleEvent(
            std::chrono::duration_cast<std::chrono::milliseconds>(delay),
            [this, player_id](GameEventScheduler::EventID)
            {
                RespawnPlayer(player_id);
            },
            "Player " + std::to_string(player_id) + " respawn"
        );
    }

    void ScheduleSkillCooldown(uint32_t player_id, uint32_t skill_id, std::chrono::seconds cooldown)
    {
        timer_manager_.CreateTimer(
            std::chrono::duration_cast<std::chrono::milliseconds>(cooldown),
            [this, player_id, skill_id](TimerManager::TimerID)
            {
                OnSkillCooldownComplete(player_id, skill_id);
            }
        );
    }

    // 아이템 관련 스케줄링
    void ScheduleItemSpawn(uint32_t item_type, float x, float y, float z, std::chrono::minutes delay)
    {
        event_scheduler_.ScheduleEvent(
            std::chrono::duration_cast<std::chrono::milliseconds>(delay),
            [this, item_type, x, y, z](GameEventScheduler::EventID)
            {
                SpawnItem(item_type, x, y, z);
            },
            "Item spawn: type " + std::to_string(item_type)
        );
    }

    // 버프/디버프 관리
    void ApplyTimedBuff(uint32_t player_id, uint32_t buff_id, std::chrono::seconds duration)
    {
        ApplyBuff(player_id, buff_id);
        
        timer_manager_.CreateTimer(
            std::chrono::duration_cast<std::chrono::milliseconds>(duration),
            [this, player_id, buff_id](TimerManager::TimerID)
            {
                RemoveBuff(player_id, buff_id);
            }
        );
    }

    // 이벤트 관리
    void StartTimedEvent(const std::string& event_name, std::chrono::minutes duration)
    {
        StartEvent(event_name);
        
        timer_manager_.CreateTimer(
            std::chrono::duration_cast<std::chrono::milliseconds>(duration),
            [this, event_name](TimerManager::TimerID)
            {
                EndEvent(event_name);
            }
        );
    }

    // 통계 출력
    void PrintSchedulerStatistics() const
    {
        std::cout << "\nScheduler Statistics:" << std::endl;
        std::cout << "Current tick: " << tick_system_.GetCurrentTick() << std::endl;
        std::cout << "Actual TPS: " << tick_system_.GetActualTPS() << std::endl;
        std::cout << "Active timers: " << timer_manager_.GetActiveTimerCount() << std::endl;
        std::cout << "Pending events: " << event_scheduler_.GetPendingEventCount() << std::endl;
    }

private:
    void SetupGameSystems()
    {
        // 게임 틱 핸들러 등록
        tick_system_.RegisterTickHandler([this](uint64_t tick)
        {
            UpdateGameLogic(tick);
        });

        // 주기적인 시스템 작업 스케줄링
        event_scheduler_.ScheduleRepeatingEvent(
            std::chrono::seconds(10),  // 초기 지연
            std::chrono::seconds(60),  // 1분마다 반복
            [this](GameEventScheduler::EventID)
            {
                PerformMaintenanceTasks();
            },
            "System maintenance"
        );

        // 플레이어 상태 업데이트
        event_scheduler_.ScheduleRepeatingEvent(
            std::chrono::seconds(1),
            std::chrono::seconds(5),   // 5초마다 반복
            [this](GameEventScheduler::EventID)
            {
                UpdatePlayerStates();
            },
            "Player state update"
        );
    }

    void UpdateGameLogic(uint64_t tick)
    {
        // 매 틱마다 실행되는 게임 로직
        if (tick % 30 == 0) // 1초마다 (30 TPS 기준)
        {
            ProcessAI();
            UpdatePhysics();
        }
        
        if (tick % 900 == 0) // 30초마다
        {
            SavePlayerData();
        }
    }

    void PerformMaintenanceTasks()
    {
        std::cout << "Performing maintenance tasks..." << std::endl;
        // 메모리 정리, 로그 정리 등
    }

    void UpdatePlayerStates()
    {
        std::cout << "Updating player states..." << std::endl;
        // 플레이어 상태 업데이트
    }

    void ProcessAI()
    {
        // AI 로직 처리
    }

    void UpdatePhysics()
    {
        // 물리 시뮬레이션
    }

    void SavePlayerData()
    {
        std::cout << "Saving player data..." << std::endl;
    }

    void RespawnPlayer(uint32_t player_id)
    {
        std::cout << "Respawning player " << player_id << std::endl;
    }

    void OnSkillCooldownComplete(uint32_t player_id, uint32_t skill_id)
    {
        std::cout << "Skill " << skill_id << " cooldown complete for player " << player_id << std::endl;
    }

    void SpawnItem(uint32_t item_type, float x, float y, float z)
    {
        std::cout << "Spawning item type " << item_type 
                 << " at (" << x << ", " << y << ", " << z << ")" << std::endl;
    }

    void ApplyBuff(uint32_t player_id, uint32_t buff_id)
    {
        std::cout << "Applying buff " << buff_id << " to player " << player_id << std::endl;
    }

    void RemoveBuff(uint32_t player_id, uint32_t buff_id)
    {
        std::cout << "Removing buff " << buff_id << " from player " << player_id << std::endl;
    }

    void StartEvent(const std::string& event_name)
    {
        std::cout << "Starting event: " << event_name << std::endl;
    }

    void EndEvent(const std::string& event_name)
    {
        std::cout << "Ending event: " << event_name << std::endl;
    }

    GameTickSystem tick_system_;
    GameEventScheduler event_scheduler_;
    TimerManager timer_manager_;
};

// 사용 예제
void GameServerSchedulerExample()
{
    boost::asio::io_context io_context;
    GameServerScheduler scheduler(io_context);
    
    scheduler.Start();
    
    // 게임 이벤트 스케줄링 예제
    scheduler.SchedulePlayerRespawn(1001, std::chrono::seconds(10));
    scheduler.ScheduleSkillCooldown(1001, 5, std::chrono::seconds(30));
    scheduler.ApplyTimedBuff(1001, 10, std::chrono::minutes(5));
    scheduler.StartTimedEvent("Double XP Weekend", std::chrono::hours(48));
    
    // 10초 후 통계 출력
    boost::asio::steady_timer stats_timer(io_context);
    stats_timer.expires_after(std::chrono::seconds(10));
    stats_timer.async_wait([&scheduler](const boost::system::error_code&)
    {
        scheduler.PrintSchedulerStatistics();
    });
    
    io_context.run();
}
```
  
</br>  
  

## 정리
이번 장에서는 Boost.Asio를 활용한 타이머와 스케줄링 시스템에 대해 상세히 살펴보았습니다. 주요 내용을 요약하면:

1. **기본 타이머 사용법**: `steady_timer`, `high_resolution_timer`, `system_timer`의 특성과 사용법을 학습하고, 타이머 정확도 측정 방법을 다뤘습니다.

2. **반복 타이머 구현**: 기본 반복 타이머부터 정밀한 간격 유지, 적응형 타이머까지 다양한 반복 타이머 구현 방법을 학습했습니다.

3. **타이머 취소와 관리**: 타이머 관리자, 타이머 그룹, 타이머 풀링을 통한 효율적인 타이머 관리 시스템을 구현했습니다.

4. **게임 로직 스케줄링**: 게임 틱 시스템, 이벤트 스케줄러, 통합 스케줄링 시스템을 통해 실제 게임 서버에서 활용할 수 있는 완전한 스케줄링 시스템을 구현했습니다.

이러한 타이머와 스케줄링 기법들은 게임 서버의 핵심 기능이며, 적절히 활용하면 정확하고 효율적인 게임 로직 처리가 가능합니다. 다음 장에서는 C++20 코루틴을 활용하여 더욱 직관적이고 효율적인 비동기 프로그래밍 방법을 학습하겠습니다.


 
  
  