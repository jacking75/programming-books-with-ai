# workingBooks  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
   
# Chapter 21. 모바일 게임 서버 구현
모바일 게임은 PC 기반 게임과는 다른 특성을 가지고 있어 서버 구현 시 이를 고려한 설계가 필요하다. 이번 장에서는 Boost.Asio를 활용하여 모바일 게임에 특화된 서버를 구현하는 방법을 살펴보겠다.

## 21.1 모바일 환경의 특성

### 21.1.1 네트워크 연결의 불안정성
모바일 환경에서는 네트워크 연결이 자주 끊어지고 재연결되는 특성이 있다. WiFi와 모바일 데이터 간의 전환, 터널이나 엘리베이터 등에서의 일시적인 연결 끊김이 빈번하게 발생한다.

```cpp
#include <boost/asio.hpp>
#include <boost/beast.hpp>
#include <chrono>
#include <memory>

class MobileConnectionManager {
private:
    boost::asio::io_context& io_context_;
    boost::asio::steady_timer reconnect_timer_;
    std::chrono::seconds timeout_duration_;
    
public:
    MobileConnectionManager(boost::asio::io_context& io_context) 
        : io_context_(io_context)
        , reconnect_timer_(io_context)
        , timeout_duration_(30) // 30초 타임아웃
    {}
    
    void handle_connection_loss() {
        // 연결 끊김 시 재연결 타이머 시작
        reconnect_timer_.expires_after(std::chrono::seconds(5));
        reconnect_timer_.async_wait([this](boost::system::error_code ec) {
            if (!ec) {
                attempt_reconnection();
            }
        });
    }
    
    void attempt_reconnection() {
        // 재연결 로직 구현
        std::cout << "Attempting to reconnect..." << std::endl;
    }
    
    void set_keep_alive_interval(std::chrono::seconds interval) {
        timeout_duration_ = interval;
    }
};
```

### 21.1.2 배터리 효율성 고려
모바일 기기는 배터리 수명이 중요하므로 불필요한 네트워크 통신을 최소화해야 한다. 서버에서는 효율적인 데이터 압축과 배치 처리를 통해 클라이언트의 배터리 소모를 줄일 수 있다.

```cpp
#include <zlib.h>
#include <vector>
#include <string>

class DataCompressionManager {
public:
    static std::vector<char> compress_data(const std::string& data) {
        std::vector<char> compressed_data;
        
        z_stream zs = {};
        if (deflateInit(&zs, Z_BEST_COMPRESSION) != Z_OK) {
            throw std::runtime_error("deflateInit failed");
        }
        
        zs.next_in = reinterpret_cast<Bytef*>(const_cast<char*>(data.data()));
        zs.avail_in = data.size();
        
        int ret;
        char outbuffer[32768];
        
        do {
            zs.next_out = reinterpret_cast<Bytef*>(outbuffer);
            zs.avail_out = sizeof(outbuffer);
            
            ret = deflate(&zs, Z_FINISH);
            
            if (compressed_data.size() < zs.total_out) {
                compressed_data.insert(
                    compressed_data.end(),
                    outbuffer,
                    outbuffer + zs.total_out - compressed_data.size()
                );
            }
        } while (ret == Z_OK);
        
        deflateEnd(&zs);
        
        if (ret != Z_STREAM_END) {
            throw std::runtime_error("Exception during compression");
        }
        
        return compressed_data;
    }
    
    static std::string decompress_data(const std::vector<char>& compressed_data) {
        z_stream zs = {};
        if (inflateInit(&zs) != Z_OK) {
            throw std::runtime_error("inflateInit failed");
        }
        
        zs.next_in = reinterpret_cast<Bytef*>(const_cast<char*>(compressed_data.data()));
        zs.avail_in = compressed_data.size();
        
        int ret;
        char outbuffer[32768];
        std::string decompressed_data;
        
        do {
            zs.next_out = reinterpret_cast<Bytef*>(outbuffer);
            zs.avail_out = sizeof(outbuffer);
            
            ret = inflate(&zs, 0);
            
            if (decompressed_data.size() < zs.total_out) {
                decompressed_data.append(
                    outbuffer,
                    zs.total_out - decompressed_data.size()
                );
            }
        } while (ret == Z_OK);
        
        inflateEnd(&zs);
        
        if (ret != Z_STREAM_END) {
            throw std::runtime_error("Exception during decompression");
        }
        
        return decompressed_data;
    }
};
```

### 21.1.3 다양한 디바이스 성능
모바일 기기는 성능 차이가 크므로 서버에서는 클라이언트의 성능에 따라 적응적으로 데이터 전송량을 조절해야 한다.

```cpp
struct DeviceProfile {
    enum class PerformanceLevel {
        LOW,
        MEDIUM,
        HIGH
    };
    
    PerformanceLevel performance_level;
    int max_concurrent_requests;
    int preferred_packet_size;
    bool supports_compression;
};

class AdaptiveDataManager {
private:
    std::unordered_map<std::string, DeviceProfile> device_profiles_;
    
public:
    void register_device(const std::string& device_id, const DeviceProfile& profile) {
        device_profiles_[device_id] = profile;
    }
    
    std::string prepare_data_for_device(const std::string& device_id, const std::string& raw_data) {
        auto it = device_profiles_.find(device_id);
        if (it == device_profiles_.end()) {
            return raw_data; // 기본 데이터 반환
        }
        
        const DeviceProfile& profile = it->second;
        
        std::string processed_data = raw_data;
        
        // 성능에 따른 데이터 조정
        switch (profile.performance_level) {
            case DeviceProfile::PerformanceLevel::LOW:
                processed_data = reduce_data_quality(processed_data);
                break;
            case DeviceProfile::PerformanceLevel::MEDIUM:
                processed_data = optimize_data_medium(processed_data);
                break;
            case DeviceProfile::PerformanceLevel::HIGH:
                // 고성능 기기는 원본 데이터 사용
                break;
        }
        
        // 압축 지원 여부에 따른 처리
        if (profile.supports_compression) {
            auto compressed = DataCompressionManager::compress_data(processed_data);
            // 압축 데이터를 문자열로 변환하는 로직 필요
        }
        
        return processed_data;
    }
    
private:
    std::string reduce_data_quality(const std::string& data) {
        // 저성능 기기용 데이터 품질 감소
        return data;
    }
    
    std::string optimize_data_medium(const std::string& data) {
        // 중간 성능 기기용 최적화
        return data;
    }
};
```
   
</br>  

## 21.2 HTTP/HTTPS 서버 구현
모바일 게임에서는 주로 HTTP/HTTPS 프로토콜을 사용한다. Boost.Beast를 활용하여 효율적인 HTTP 서버를 구현할 수 있다.

### 21.2.1 기본 HTTP 서버 구현

```cpp
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/version.hpp>
#include <boost/asio.hpp>
#include <chrono>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <memory>
#include <string>

namespace beast = boost::beast;
namespace http = beast::http;
namespace net = boost::asio;
using tcp = boost::asio::ip::tcp;

class HttpSession : public std::enable_shared_from_this<HttpSession> {
private:
    beast::tcp_stream stream_;
    beast::flat_buffer buffer_;
    http::request<http::string_body> req_;
    std::shared_ptr<void> res_;
    
public:
    explicit HttpSession(tcp::socket&& socket)
        : stream_(std::move(socket))
    {}
    
    void run() {
        net::dispatch(stream_.get_executor(),
                     beast::bind_front_handler(&HttpSession::do_read,
                                             shared_from_this()));
    }
    
    void do_read() {
        req_ = {};
        
        stream_.expires_after(std::chrono::seconds(30));
        
        http::async_read(stream_, buffer_, req_,
            beast::bind_front_handler(&HttpSession::on_read,
                                    shared_from_this()));
    }
    
    void on_read(beast::error_code ec, std::size_t bytes_transferred) {
        boost::ignore_unused(bytes_transferred);
        
        if (ec == http::error::end_of_stream) {
            return do_close();
        }
        
        if (ec) {
            std::cerr << "read error: " << ec.message() << std::endl;
            return;
        }
        
        handle_request();
    }
    
    void handle_request() {
        auto const bad_request = [&](beast::string_view why) {
            http::response<http::string_body> res{http::status::bad_request, req_.version()};
            res.set(http::field::server, "Mobile Game Server");
            res.set(http::field::content_type, "text/html");
            res.keep_alive(req_.keep_alive());
            res.body() = std::string(why);
            res.prepare_payload();
            return res;
        };
        
        auto const not_found = [&](beast::string_view target) {
            http::response<http::string_body> res{http::status::not_found, req_.version()};
            res.set(http::field::server, "Mobile Game Server");
            res.set(http::field::content_type, "text/html");
            res.keep_alive(req_.keep_alive());
            res.body() = "The resource '" + std::string(target) + "' was not found.";
            res.prepare_payload();
            return res;
        };
        
        auto const server_error = [&](beast::string_view what) {
            http::response<http::string_body> res{http::status::internal_server_error, req_.version()};
            res.set(http::field::server, "Mobile Game Server");
            res.set(http::field::content_type, "text/html");
            res.keep_alive(req_.keep_alive());
            res.body() = "An error occurred: '" + std::string(what) + "'";
            res.prepare_payload();
            return res;
        };
        
        // 요청 방법 확인
        if (req_.method() != http::verb::get &&
            req_.method() != http::verb::post) {
            return send(bad_request("Unknown HTTP-method"));
        }
        
        // 요청 경로에 따른 처리
        if (req_.target() == "/api/player/login") {
            return handle_login_request();
        } else if (req_.target() == "/api/player/status") {
            return handle_player_status_request();
        } else if (req_.target() == "/api/game/leaderboard") {
            return handle_leaderboard_request();
        } else {
            return send(not_found(req_.target()));
        }
    }
    
    void handle_login_request() {
        http::response<http::string_body> res{http::status::ok, req_.version()};
        res.set(http::field::server, "Mobile Game Server");
        res.set(http::field::content_type, "application/json");
        res.keep_alive(req_.keep_alive());
        
        // JSON 응답 생성
        res.body() = R"({
            "status": "success",
            "player_id": "12345",
            "session_token": "abcdef123456",
            "server_time": ")" + get_current_time() + R"("
        })";
        
        res.prepare_payload();
        send(std::move(res));
    }
    
    void handle_player_status_request() {
        http::response<http::string_body> res{http::status::ok, req_.version()};
        res.set(http::field::server, "Mobile Game Server");
        res.set(http::field::content_type, "application/json");
        res.keep_alive(req_.keep_alive());
        
        res.body() = R"({
            "player_id": "12345",
            "level": 25,
            "experience": 15432,
            "gold": 5000,
            "last_login": ")" + get_current_time() + R"("
        })";
        
        res.prepare_payload();
        send(std::move(res));
    }
    
    void handle_leaderboard_request() {
        http::response<http::string_body> res{http::status::ok, req_.version()};
        res.set(http::field::server, "Mobile Game Server");
        res.set(http::field::content_type, "application/json");
        res.keep_alive(req_.keep_alive());
        
        res.body() = R"({
            "leaderboard": [
                {"rank": 1, "player_name": "Player1", "score": 10000},
                {"rank": 2, "player_name": "Player2", "score": 9500},
                {"rank": 3, "player_name": "Player3", "score": 9000}
            ],
            "total_players": 1000
        })";
        
        res.prepare_payload();
        send(std::move(res));
    }
    
    template<bool isRequest, class Body, class Fields>
    void send(http::message<isRequest, Body, Fields>&& msg) {
        auto sp = std::make_shared<http::message<isRequest, Body, Fields>>(std::move(msg));
        res_ = sp;
        
        http::async_write(
            stream_,
            *sp,
            beast::bind_front_handler(&HttpSession::on_write,
                                    shared_from_this(),
                                    sp->need_eof()));
    }
    
    void on_write(bool close, beast::error_code ec, std::size_t bytes_transferred) {
        boost::ignore_unused(bytes_transferred);
        
        if (ec) {
            std::cerr << "write error: " << ec.message() << std::endl;
            return;
        }
        
        if (close) {
            return do_close();
        }
        
        res_ = nullptr;
        do_read();
    }
    
    void do_close() {
        beast::error_code ec;
        stream_.socket().shutdown(tcp::socket::shutdown_send, ec);
    }
    
private:
    std::string get_current_time() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
        return ss.str();
    }
};

class HttpServer {
private:
    net::io_context& ioc_;
    tcp::acceptor acceptor_;
    
public:
    HttpServer(net::io_context& ioc, tcp::endpoint endpoint)
        : ioc_(ioc)
        , acceptor_(ioc)
    {
        beast::error_code ec;
        
        acceptor_.open(endpoint.protocol(), ec);
        if (ec) {
            std::cerr << "open error: " << ec.message() << std::endl;
            return;
        }
        
        acceptor_.set_option(net::socket_base::reuse_address(true), ec);
        if (ec) {
            std::cerr << "set_option error: " << ec.message() << std::endl;
            return;
        }
        
        acceptor_.bind(endpoint, ec);
        if (ec) {
            std::cerr << "bind error: " << ec.message() << std::endl;
            return;
        }
        
        acceptor_.listen(net::socket_base::max_listen_connections, ec);
        if (ec) {
            std::cerr << "listen error: " << ec.message() << std::endl;
            return;
        }
    }
    
    void run() {
        do_accept();
    }
    
private:
    void do_accept() {
        acceptor_.async_accept(
            net::make_strand(ioc_),
            beast::bind_front_handler(&HttpServer::on_accept,
                                    shared_from_this()));
    }
    
    void on_accept(beast::error_code ec, tcp::socket socket) {
        if (ec) {
            std::cerr << "accept error: " << ec.message() << std::endl;
        } else {
            std::make_shared<HttpSession>(std::move(socket))->run();
        }
        
        do_accept();
    }
};
```

### 21.2.2 HTTPS 서버 구현
보안이 중요한 모바일 게임에서는 HTTPS를 사용해야 한다.

```cpp
#include <boost/beast/ssl.hpp>
#include <boost/asio/ssl.hpp>

namespace ssl = boost::asio::ssl;

class HttpsSession : public std::enable_shared_from_this<HttpsSession> {
private:
    beast::ssl_stream<beast::tcp_stream> stream_;
    beast::flat_buffer buffer_;
    http::request<http::string_body> req_;
    std::shared_ptr<void> res_;
    
public:
    explicit HttpsSession(tcp::socket&& socket, ssl::context& ctx)
        : stream_(std::move(socket), ctx)
    {}
    
    void run() {
        auto self = shared_from_this();
        
        stream_.async_handshake(
            ssl::stream_base::server,
            [self](beast::error_code ec) {
                if (!ec) {
                    self->do_read();
                } else {
                    std::cerr << "handshake error: " << ec.message() << std::endl;
                }
            });
    }
    
    void do_read() {
        req_ = {};
        
        stream_.expires_after(std::chrono::seconds(30));
        
        http::async_read(stream_, buffer_, req_,
            beast::bind_front_handler(&HttpsSession::on_read,
                                    shared_from_this()));
    }
    
    // 나머지 메서드들은 HttpSession과 동일하게 구현
    // ...
};

class HttpsServer {
private:
    net::io_context& ioc_;
    ssl::context& ctx_;
    tcp::acceptor acceptor_;
    
public:
    HttpsServer(net::io_context& ioc, ssl::context& ctx, tcp::endpoint endpoint)
        : ioc_(ioc)
        , ctx_(ctx)
        , acceptor_(ioc)
    {
        // acceptor 설정 코드는 HttpServer와 동일
        // ...
    }
    
    void run() {
        do_accept();
    }
    
private:
    void do_accept() {
        acceptor_.async_accept(
            net::make_strand(ioc_),
            [this](beast::error_code ec, tcp::socket socket) {
                if (!ec) {
                    std::make_shared<HttpsSession>(std::move(socket), ctx_)->run();
                }
                do_accept();
            });
    }
};
```
   
</br>  

## 21.3 RESTful API 설계
모바일 게임 서버에서는 RESTful API를 통해 클라이언트와 통신한다. 효율적인 API 설계와 구현 방법을 살펴보겠다.

### 21.3.1 API 라우터 구현

```cpp
#include <unordered_map>
#include <functional>
#include <regex>

class ApiRouter {
public:
    using HandlerFunction = std::function<http::response<http::string_body>(
        const http::request<http::string_body>&, 
        const std::unordered_map<std::string, std::string>&)>;
    
private:
    struct Route {
        std::regex pattern;
        HandlerFunction handler;
        http::verb method;
    };
    
    std::vector<Route> routes_;
    
public:
    void add_route(const std::string& pattern, http::verb method, HandlerFunction handler) {
        routes_.push_back({std::regex(pattern), handler, method});
    }
    
    http::response<http::string_body> handle_request(const http::request<http::string_body>& req) {
        std::string target = std::string(req.target());
        
        for (const auto& route : routes_) {
            if (route.method == req.method()) {
                std::smatch matches;
                if (std::regex_match(target, matches, route.pattern)) {
                    std::unordered_map<std::string, std::string> params;
                    
                    // URL 파라미터 추출
                    for (size_t i = 1; i < matches.size(); ++i) {
                        params["param" + std::to_string(i)] = matches[i].str();
                    }
                    
                    // 쿼리 파라미터 추출
                    extract_query_params(target, params);
                    
                    return route.handler(req, params);
                }
            }
        }
        
        // 404 응답
        http::response<http::string_body> res{http::status::not_found, req.version()};
        res.set(http::field::server, "Mobile Game Server");
        res.set(http::field::content_type, "application/json");
        res.body() = R"({"error": "Not Found"})";
        res.prepare_payload();
        return res;
    }
    
private:
    void extract_query_params(const std::string& url, 
                             std::unordered_map<std::string, std::string>& params) {
        size_t query_pos = url.find('?');
        if (query_pos == std::string::npos) return;
        
        std::string query = url.substr(query_pos + 1);
        std::stringstream ss(query);
        std::string pair;
        
        while (std::getline(ss, pair, '&')) {
            size_t eq_pos = pair.find('=');
            if (eq_pos != std::string::npos) {
                std::string key = pair.substr(0, eq_pos);
                std::string value = pair.substr(eq_pos + 1);
                params[key] = value;
            }
        }
    }
};

class GameApiHandlers {
private:
    std::unordered_map<std::string, PlayerData> player_database_;
    std::vector<LeaderboardEntry> leaderboard_;
    
public:
    http::response<http::string_body> handle_player_login(
        const http::request<http::string_body>& req,
        const std::unordered_map<std::string, std::string>& params) {
        
        // JSON 파싱 (실제로는 JSON 라이브러리 사용)
        std::string username = extract_json_field(req.body(), "username");
        std::string password = extract_json_field(req.body(), "password");
        
        // 인증 로직
        if (authenticate_player(username, password)) {
            std::string session_token = generate_session_token();
            
            http::response<http::string_body> res{http::status::ok, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = create_login_response(username, session_token);
            res.prepare_payload();
            return res;
        } else {
            http::response<http::string_body> res{http::status::unauthorized, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = R"({"error": "Invalid credentials"})";
            res.prepare_payload();
            return res;
        }
    }
    
    http::response<http::string_body> handle_player_profile(
        const http::request<http::string_body>& req,
        const std::unordered_map<std::string, std::string>& params) {
        
        auto player_id_it = params.find("param1"); // URL에서 추출된 플레이어 ID
        if (player_id_it == params.end()) {
            http::response<http::string_body> res{http::status::bad_request, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = R"({"error": "Player ID required"})";
            res.prepare_payload();
            return res;
        }
        
        std::string player_id = player_id_it->second;
        
        // 세션 토큰 검증
        std::string auth_header = std::string(req[http::field::authorization]);
        if (!validate_session_token(auth_header)) {
            http::response<http::string_body> res{http::status::unauthorized, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = R"({"error": "Invalid session"})";
            res.prepare_payload();
            return res;
        }
        
        // 플레이어 데이터 조회
        auto player_it = player_database_.find(player_id);
        if (player_it != player_database_.end()) {
            http::response<http::string_body> res{http::status::ok, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = serialize_player_data(player_it->second);
            res.prepare_payload();
            return res;
        } else {
            http::response<http::string_body> res{http::status::not_found, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = R"({"error": "Player not found"})";
            res.prepare_payload();
            return res;
        }
    }
    
    http::response<http::string_body> handle_game_action(
        const http::request<http::string_body>& req,
        const std::unordered_map<std::string, std::string>& params) {
        
        // 게임 액션 처리 (아이템 구매, 레벨업 등)
        std::string action_type = extract_json_field(req.body(), "action");
        std::string player_id = extract_json_field(req.body(), "player_id");
        
        // 비즈니스 로직 처리
        GameActionResult result = process_game_action(player_id, action_type, req.body());
        
        http::response<http::string_body> res{http::status::ok, req.version()};
        res.set(http::field::content_type, "application/json");
        res.body() = serialize_action_result(result);
        res.prepare_payload();
        return res;
    }
    
private:
    struct PlayerData {
        std::string player_id;
        std::string username;
        int level;
        int experience;
        int gold;
        std::vector<std::string> inventory;
    };
    
    struct LeaderboardEntry {
        std::string player_name;
        int score;
        int rank;
    };
    
    struct GameActionResult {
        bool success;
        std::string message;
        PlayerData updated_player_data;
    };
    
    bool authenticate_player(const std::string& username, const std::string& password) {
        // 실제 인증 로직 구현
        return username == "testuser" && password == "testpass";
    }
    
    std::string generate_session_token() {
        // 실제 토큰 생성 로직 구현
        return "session_" + std::to_string(std::time(nullptr));
    }
    
    bool validate_session_token(const std::string& auth_header) {
        // 세션 토큰 검증 로직
        return auth_header.find("Bearer session_") == 0;
    }
    
    std::string extract_json_field(const std::string& json, const std::string& field) {
        // 간단한 JSON 필드 추출 (실제로는 JSON 라이브러리 사용)
        size_t start = json.find("\"" + field + "\":");
        if (start == std::string::npos) return "";
        
        start = json.find("\"", start + field.length() + 3);
        if (start == std::string::npos) return "";
        
        size_t end = json.find("\"", start + 1);
        if (end == std::string::npos) return "";
        
        return json.substr(start + 1, end - start - 1);
    }
    
    std::string create_login_response(const std::string& username, const std::string& token) {
        return R"({
            "status": "success",
            "username": ")" + username + R"(",
            "session_token": ")" + token + R"(",
            "expires_in": 3600
        })";
    }
    
    std::string serialize_player_data(const PlayerData& data) {
        return R"({
            "player_id": ")" + data.player_id + R"(",
            "username": ")" + data.username + R"(",
            "level": )" + std::to_string(data.level) + R"(,
            "experience": )" + std::to_string(data.experience) + R"(,
            "gold": )" + std::to_string(data.gold) + R"(
        })";
    }
    
    GameActionResult process_game_action(const std::string& player_id, 
                                       const std::string& action, 
                                       const std::string& payload) {
        GameActionResult result;
        result.success = true;
        result.message = "Action processed successfully";
        
        // 실제 게임 로직 처리
        if (action == "level_up") {
            // 레벨업 처리
        } else if (action == "buy_item") {
            // 아이템 구매 처리
        }
        
        return result;
    }
    
    std::string serialize_action_result(const GameActionResult& result) {
        return R"({
            "success": )" + (result.success ? "true" : "false") + R"(,
            "message": ")" + result.message + R"("
        })";
    }
};
```

### 21.3.2 API 서버 통합

```cpp
class MobileGameApiServer {
private:
    net::io_context ioc_;
    ApiRouter router_;
    GameApiHandlers handlers_;
    std::unique_ptr<HttpServer> http_server_;
    std::unique_ptr<HttpsServer> https_server_;
    std::unique_ptr<ssl::context> ssl_ctx_;
    
public:
    MobileGameApiServer() {
        setup_routes();
        setup_ssl();
    }
    
    void setup_routes() {
        // 플레이어 관련 API
        router_.add_route("/api/player/login", http::verb::post,
            [this](const auto& req, const auto& params) {
                return handlers_.handle_player_login(req, params);
            });
            
        router_.add_route("/api/player/([^/]+)", http::verb::get,
            [this](const auto& req, const auto& params) {
                return handlers_.handle_player_profile(req, params);
            });
        
        // 게임 액션 API
        router_.add_route("/api/game/action", http::verb::post,
            [this](const auto& req, const auto& params) {
                return handlers_.handle_game_action(req, params);
            });
        
        // 리더보드 API
        router_.add_route("/api/leaderboard", http::verb::get,
            [this](const auto& req, const auto& params) {
                return handle_leaderboard_request(req, params);
            });
    }
    
    void setup_ssl() {
        ssl_ctx_ = std::make_unique<ssl::context>(ssl::context::tlsv12);
        
        ssl_ctx_->set_password_callback(
            [](std::size_t, ssl::context_base::password_purpose) {
                return "test"; // 실제로는 보안 설정 필요
            });
        
        ssl_ctx_->set_options(
            ssl::context::default_workarounds |
            ssl::context::no_sslv2 |
            ssl::context::single_dh_use);
        
        // 인증서 설정 (실제 환경에서는 실제 인증서 사용)
        ssl_ctx_->use_certificate_chain_file("server.crt");
        ssl_ctx_->use_private_key_file("server.key", ssl::context::pem);
        ssl_ctx_->use_tmp_dh_file("dh2048.pem");
    }
    
    void run(const std::string& address, unsigned short http_port, unsigned short https_port) {
        auto const addr = net::ip::make_address(address);
        
        // HTTP 서버 시작
        http_server_ = std::make_unique<HttpServer>(ioc_, tcp::endpoint{addr, http_port});
        http_server_->run();
        
        // HTTPS 서버 시작
        https_server_ = std::make_unique<HttpsServer>(ioc_, *ssl_ctx_, tcp::endpoint{addr, https_port});
        https_server_->run();
        
        std::cout << "Mobile Game Server running on:" << std::endl;
        std::cout << "HTTP:  " << address << ":" << http_port << std::endl;
        std::cout << "HTTPS: " << address << ":" << https_port << std::endl;
        
        ioc_.run();
    }
    
private:
    http::response<http::string_body> handle_leaderboard_request(
        const http::request<http::string_body>& req,
        const std::unordered_map<std::string, std::string>& params) {
        
        http::response<http::string_body> res{http::status::ok, req.version()};
        res.set(http::field::content_type, "application/json");
        
        // 페이지네이션 지원
        int page = 1;
        int limit = 10;
        
        auto page_it = params.find("page");
        if (page_it != params.end()) {
            page = std::stoi(page_it->second);
        }
        
        auto limit_it = params.find("limit");
        if (limit_it != params.end()) {
            limit = std::stoi(limit_it->second);
        }
        
        res.body() = generate_leaderboard_json(page, limit);
        res.prepare_payload();
        return res;
    }
    
    std::string generate_leaderboard_json(int page, int limit) {
        // 실제로는 데이터베이스에서 조회
        return R"({
            "page": )" + std::to_string(page) + R"(,
            "limit": )" + std::to_string(limit) + R"(,
            "total": 1000,
            "data": [
                {"rank": 1, "player": "Player1", "score": 10000},
                {"rank": 2, "player": "Player2", "score": 9500}
            ]
        })";
    }
};
```
   
</br>  

## 21.4 푸시 알림 시스템
모바일 게임에서는 플레이어 재참여를 위한 푸시 알림이 중요하다. 효율적인 푸시 알림 시스템을 구현해보겠다.

### 21.4.1 FCM(Firebase Cloud Messaging) 클라이언트 구현

```cpp
#include <boost/beast/http.hpp>
#include <boost/beast/ssl.hpp>
#include <boost/asio/ssl.hpp>
#include <nlohmann/json.hpp>

class FCMClient {
private:
    net::io_context& ioc_;
    ssl::context ctx_;
    std::string server_key_;
    std::string fcm_endpoint_;
    
public:
    FCMClient(net::io_context& ioc, const std::string& server_key)
        : ioc_(ioc)
        , ctx_(ssl::context::tlsv12_client)
        , server_key_(server_key)
        , fcm_endpoint_("fcm.googleapis.com")
    {
        ctx_.set_default_verify_paths();
        ctx_.set_verify_mode(ssl::verify_peer);
    }
    
    void send_notification(const std::string& device_token, 
                          const std::string& title,
                          const std::string& body,
                          const nlohmann::json& data = {}) {
        
        auto session = std::make_shared<FCMSession>(ioc_, ctx_, server_key_);
        session->send_notification(fcm_endpoint_, device_token, title, body, data);
    }
    
    void send_to_multiple_devices(const std::vector<std::string>& device_tokens,
                                 const std::string& title,
                                 const std::string& body,
                                 const nlohmann::json& data = {}) {
        
        // 배치 처리로 효율성 향상
        const size_t batch_size = 1000; // FCM 제한에 맞춰 조정
        
        for (size_t i = 0; i < device_tokens.size(); i += batch_size) {
            size_t end = std::min(i + batch_size, device_tokens.size());
            std::vector<std::string> batch(device_tokens.begin() + i, device_tokens.begin() + end);
            
            auto session = std::make_shared<FCMSession>(ioc_, ctx_, server_key_);
            session->send_multicast_notification(fcm_endpoint_, batch, title, body, data);
        }
    }
    
private:
    class FCMSession : public std::enable_shared_from_this<FCMSession> {
    private:
        beast::ssl_stream<beast::tcp_stream> stream_;
        beast::flat_buffer buffer_;
        http::request<http::string_body> req_;
        http::response<http::string_body> res_;
        std::string server_key_;
        
    public:
        FCMSession(net::io_context& ioc, ssl::context& ctx, const std::string& server_key)
            : stream_(ioc, ctx)
            , server_key_(server_key)
        {}
        
        void send_notification(const std::string& host,
                             const std::string& device_token,
                             const std::string& title,
                             const std::string& body,
                             const nlohmann::json& data) {
            
            nlohmann::json message = {
                {"to", device_token},
                {"notification", {
                    {"title", title},
                    {"body", body}
                }}
            };
            
            if (!data.empty()) {
                message["data"] = data;
            }
            
            send_fcm_request(host, message.dump());
        }
        
        void send_multicast_notification(const std::string& host,
                                       const std::vector<std::string>& device_tokens,
                                       const std::string& title,
                                       const std::string& body,
                                       const nlohmann::json& data) {
            
            nlohmann::json message = {
                {"registration_ids", device_tokens},
                {"notification", {
                    {"title", title},
                    {"body", body}
                }}
            };
            
            if (!data.empty()) {
                message["data"] = data;
            }
            
            send_fcm_request(host, message.dump());
        }
        
    private:
        void send_fcm_request(const std::string& host, const std::string& json_payload) {
            // 요청 설정
            req_.version(11);
            req_.method(http::verb::post);
            req_.target("/fcm/send");
            req_.set(http::field::host, host);
            req_.set(http::field::user_agent, "Mobile Game Server");
            req_.set(http::field::content_type, "application/json");
            req_.set(http::field::authorization, "key=" + server_key_);
            req_.body() = json_payload;
            req_.prepare_payload();
            
            // SSL 연결 시작
            auto resolver = std::make_shared<tcp::resolver>(stream_.get_executor());
            resolver->async_resolve(
                host, "443",
                [self = shared_from_this(), resolver](
                    beast::error_code ec, tcp::resolver::results_type results) {
                    if (!ec) {
                        self->on_resolve(results);
                    } else {
                        std::cerr << "resolve error: " << ec.message() << std::endl;
                    }
                });
        }
        
        void on_resolve(tcp::resolver::results_type results) {
            beast::get_lowest_layer(stream_).expires_after(std::chrono::seconds(30));
            
            beast::get_lowest_layer(stream_).async_connect(
                results,
                [self = shared_from_this()](
                    beast::error_code ec, tcp::resolver::results_type::endpoint_type) {
                    if (!ec) {
                        self->on_connect();
                    } else {
                        std::cerr << "connect error: " << ec.message() << std::endl;
                    }
                });
        }
        
        void on_connect() {
            stream_.async_handshake(
                ssl::stream_base::client,
                [self = shared_from_this()](beast::error_code ec) {
                    if (!ec) {
                        self->on_handshake();
                    } else {
                        std::cerr << "handshake error: " << ec.message() << std::endl;
                    }
                });
        }
        
        void on_handshake() {
            beast::get_lowest_layer(stream_).expires_after(std::chrono::seconds(30));
            
            http::async_write(stream_, req_,
                [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {
                    boost::ignore_unused(bytes_transferred);
                    if (!ec) {
                        self->on_write();
                    } else {
                        std::cerr << "write error: " << ec.message() << std::endl;
                    }
                });
        }
        
        void on_write() {
            http::async_read(stream_, buffer_, res_,
                [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {
                    boost::ignore_unused(bytes_transferred);
                    if (!ec) {
                        self->on_read();
                    } else {
                        std::cerr << "read error: " << ec.message() << std::endl;
                    }
                });
        }
        
        void on_read() {
            std::cout << "FCM Response: " << res_.body() << std::endl;
            
            // 연결 종료
            beast::error_code ec;
            stream_.shutdown(ec);
            if (ec == net::error::eof) {
                ec = {};
            }
            if (ec) {
                std::cerr << "shutdown error: " << ec.message() << std::endl;
            }
        }
    };
};
```

### 21.4.2 푸시 알림 스케줄러

```cpp
class PushNotificationScheduler {
private:
    net::io_context& ioc_;
    std::unique_ptr<FCMClient> fcm_client_;
    boost::asio::steady_timer scheduler_timer_;
    std::vector<ScheduledNotification> scheduled_notifications_;
    std::mutex notifications_mutex_;
    
public:
    struct ScheduledNotification {
        std::string notification_id;
        std::vector<std::string> device_tokens;
        std::string title;
        std::string body;
        nlohmann::json data;
        std::chrono::system_clock::time_point scheduled_time;
        bool sent;
    };
    
    PushNotificationScheduler(net::io_context& ioc, const std::string& fcm_server_key)
        : ioc_(ioc)
        , fcm_client_(std::make_unique<FCMClient>(ioc, fcm_server_key))
        , scheduler_timer_(ioc)
    {
        start_scheduler();
    }
    
    void schedule_notification(const std::string& notification_id,
                             const std::vector<std::string>& device_tokens,
                             const std::string& title,
                             const std::string& body,
                             const std::chrono::system_clock::time_point& send_time,
                             const nlohmann::json& data = {}) {
        
        std::lock_guard<std::mutex> lock(notifications_mutex_);
        
        ScheduledNotification notification;
        notification.notification_id = notification_id;
        notification.device_tokens = device_tokens;
        notification.title = title;
        notification.body = body;
        notification.data = data;
        notification.scheduled_time = send_time;
        notification.sent = false;
        
        scheduled_notifications_.push_back(notification);
        
        std::cout << "Scheduled notification: " << notification_id 
                  << " for " << device_tokens.size() << " devices" << std::endl;
    }
    
    void schedule_daily_reminder(const std::vector<std::string>& device_tokens,
                               int hour, int minute) {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        auto tm = *std::localtime(&time_t);
        
        tm.tm_hour = hour;
        tm.tm_min = minute;
        tm.tm_sec = 0;
        
        auto target_time = std::chrono::system_clock::from_time_t(std::mktime(&tm));
        
        // 만약 오늘 시간이 지났다면 다음 날로 설정
        if (target_time <= now) {
            target_time += std::chrono::hours(24);
        }
        
        schedule_notification(
            "daily_reminder_" + std::to_string(std::time(nullptr)),
            device_tokens,
            "Don't forget to play!",
            "Your daily rewards are waiting for you!",
            target_time,
            {{"type", "daily_reminder"}}
        );
    }
    
    void schedule_event_notification(const std::vector<std::string>& device_tokens,
                                   const std::string& event_name,
                                   const std::chrono::system_clock::time_point& event_start_time) {
        
        // 이벤트 시작 1시간 전 알림
        auto notification_time = event_start_time - std::chrono::hours(1);
        
        schedule_notification(
            "event_" + event_name,
            device_tokens,
            "Event Starting Soon!",
            event_name + " starts in 1 hour. Don't miss out!",
            notification_time,
            {{"type", "event_reminder"}, {"event_name", event_name}}
        );
    }
    
private:
    void start_scheduler() {
        schedule_next_check();
    }
    
    void schedule_next_check() {
        scheduler_timer_.expires_after(std::chrono::minutes(1)); // 1분마다 체크
        scheduler_timer_.async_wait([this](boost::system::error_code ec) {
            if (!ec) {
                check_and_send_notifications();
                schedule_next_check();
            }
        });
    }
    
    void check_and_send_notifications() {
        auto now = std::chrono::system_clock::now();
        std::lock_guard<std::mutex> lock(notifications_mutex_);
        
        for (auto& notification : scheduled_notifications_) {
            if (!notification.sent && notification.scheduled_time <= now) {
                send_notification(notification);
                notification.sent = true;
            }
        }
        
        // 전송된 알림들 정리
        scheduled_notifications_.erase(
            std::remove_if(scheduled_notifications_.begin(), scheduled_notifications_.end(),
                          [](const ScheduledNotification& n) { return n.sent; }),
            scheduled_notifications_.end());
    }
    
    void send_notification(const ScheduledNotification& notification) {
        std::cout << "Sending notification: " << notification.notification_id << std::endl;
        
        fcm_client_->send_to_multiple_devices(
            notification.device_tokens,
            notification.title,
            notification.body,
            notification.data
        );
    }
};
```

### 21.4.3 푸시 알림 관리 API

```cpp
class PushNotificationApiHandlers {
private:
    std::unique_ptr<PushNotificationScheduler> scheduler_;
    std::unordered_map<std::string, std::vector<std::string>> user_device_tokens_;
    
public:
    PushNotificationApiHandlers(net::io_context& ioc, const std::string& fcm_server_key)
        : scheduler_(std::make_unique<PushNotificationScheduler>(ioc, fcm_server_key))
    {}
    
    http::response<http::string_body> handle_register_device(
        const http::request<http::string_body>& req,
        const std::unordered_map<std::string, std::string>& params) {
        
        try {
            auto json_body = nlohmann::json::parse(req.body());
            std::string user_id = json_body["user_id"];
            std::string device_token = json_body["device_token"];
            
            // 디바이스 토큰 등록
            user_device_tokens_[user_id].push_back(device_token);
            
            http::response<http::string_body> res{http::status::ok, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = R"({"status": "success", "message": "Device registered"})";
            res.prepare_payload();
            return res;
            
        } catch (const std::exception& e) {
            http::response<http::string_body> res{http::status::bad_request, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = R"({"status": "error", "message": "Invalid request"})";
            res.prepare_payload();
            return res;
        }
    }
    
    http::response<http::string_body> handle_send_immediate_notification(
        const http::request<http::string_body>& req,
        const std::unordered_map<std::string, std::string>& params) {
        
        try {
            auto json_body = nlohmann::json::parse(req.body());
            std::string user_id = json_body["user_id"];
            std::string title = json_body["title"];
            std::string body = json_body["body"];
            
            auto it = user_device_tokens_.find(user_id);
            if (it != user_device_tokens_.end()) {
                scheduler_->schedule_notification(
                    "immediate_" + std::to_string(std::time(nullptr)),
                    it->second,
                    title,
                    body,
                    std::chrono::system_clock::now()
                );
                
                http::response<http::string_body> res{http::status::ok, req.version()};
                res.set(http::field::content_type, "application/json");
                res.body() = R"({"status": "success", "message": "Notification sent"})";
                res.prepare_payload();
                return res;
            } else {
                http::response<http::string_body> res{http::status::not_found, req.version()};
                res.set(http::field::content_type, "application/json");
                res.body() = R"({"status": "error", "message": "User not found"})";
                res.prepare_payload();
                return res;
            }
            
        } catch (const std::exception& e) {
            http::response<http::string_body> res{http::status::bad_request, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = R"({"status": "error", "message": "Invalid request"})";
            res.prepare_payload();
            return res;
        }
    }
    
    http::response<http::string_body> handle_schedule_notification(
        const http::request<http::string_body>& req,
        const std::unordered_map<std::string, std::string>& params) {
        
        try {
            auto json_body = nlohmann::json::parse(req.body());
            std::string user_id = json_body["user_id"];
            std::string title = json_body["title"];
            std::string body = json_body["body"];
            std::string schedule_time_str = json_body["schedule_time"]; // ISO 8601 형식
            
            // 시간 파싱 (실제로는 더 정교한 파싱 필요)
            auto schedule_time = parse_iso8601_time(schedule_time_str);
            
            auto it = user_device_tokens_.find(user_id);
            if (it != user_device_tokens_.end()) {
                scheduler_->schedule_notification(
                    "scheduled_" + std::to_string(std::time(nullptr)),
                    it->second,
                    title,
                    body,
                    schedule_time
                );
                
                http::response<http::string_body> res{http::status::ok, req.version()};
                res.set(http::field::content_type, "application/json");
                res.body() = R"({"status": "success", "message": "Notification scheduled"})";
                res.prepare_payload();
                return res;
            } else {
                http::response<http::string_body> res{http::status::not_found, req.version()};
                res.set(http::field::content_type, "application/json");
                res.body() = R"({"status": "error", "message": "User not found"})";
                res.prepare_payload();
                return res;
            }
            
        } catch (const std::exception& e) {
            http::response<http::string_body> res{http::status::bad_request, req.version()};
            res.set(http::field::content_type, "application/json");
            res.body() = R"({"status": "error", "message": "Invalid request"})";
            res.prepare_payload();
            return res;
        }
    }
    
private:
    std::chrono::system_clock::time_point parse_iso8601_time(const std::string& time_str) {
        // 간단한 ISO 8601 파싱 구현 (실제로는 더 정교한 라이브러리 사용)
        std::tm tm = {};
        std::istringstream ss(time_str);
        ss >> std::get_time(&tm, "%Y-%m-%dT%H:%M:%S");
        return std::chrono::system_clock::from_time_t(std::mktime(&tm));
    }
};
```
  
</br>   
    
이 장에서는 모바일 게임 서버의 특성을 고려한 구현 방법을 살펴보았다. 네트워크 연결의 불안정성, 배터리 효율성, 다양한 디바이스 성능 등 모바일 환경의 특성을 고려하여 HTTP/HTTPS 서버 구현, RESTful API 설계, 그리고 푸시 알림 시스템까지 포괄적으로 다루었다. 이러한 기법들을 활용하면 모바일 플랫폼에 최적화된 게임 서버를 구축할 수 있다.



   