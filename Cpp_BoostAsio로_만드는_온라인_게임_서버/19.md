# workingBooks  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
   
# Chapter 19. 보안과 안정성
온라인 게임 서버는 수많은 플레이어가 동시에 접속하며, 실시간으로 중요한 게임 데이터를 처리한다. 따라서 보안과 안정성은 게임 서버 개발에서 가장 중요한 요소 중 하나이다. 악의적인 공격자들은 게임 서버의 취약점을 악용하여 게임 밸런스를 파괴하거나 서비스를 마비시키려 한다. 이번 장에서는 Boost.Asio를 활용하여 보안이 강화된 안정적인 게임 서버를 구축하는 방법을 살펴보겠다.

## 19.1 네트워크 보안 기본

### 19.1.1 게임 서버 보안 위협 요소
게임 서버가 직면하는 주요 보안 위협을 이해하는 것이 보안 설계의 첫 번째 단계이다.

**패킷 스니핑과 변조**

네트워크를 통해 전송되는 패킷은 중간에 가로채거나 변조될 수 있다. 특히 게임에서 중요한 정보인 플레이어 위치, 아이템 정보, 경험치 등이 노출되면 게임의 공정성이 심각하게 훼손된다.

```cpp
// 취약한 패킷 구조 예시
struct PlayerMovePacket {
    uint32_t player_id;
    float x, y, z;           // 위치 정보가 평문으로 전송
    uint32_t experience;     // 경험치 정보가 노출
    uint32_t gold;          // 게임 재화 정보가 노출
};
```

**프로토콜 역공학**

공격자가 클라이언트-서버 간 통신 프로토콜을 분석하여 게임 로직을 파악하고 악용할 수 있다. 이를 통해 자동화된 봇을 제작하거나 게임 규칙을 우회하는 공격이 가능하다.

**재전송 공격 (Replay Attack)**

이전에 캡처한 패킷을 다시 전송하여 같은 행동을 반복 실행하는 공격이다. 예를 들어, 아이템 구매 패킷을 반복 전송하여 무료로 아이템을 획득하려는 시도가 있을 수 있다.

### 19.1.2 SSL/TLS 적용
Boost.Asio는 SSL/TLS를 통한 암호화 통신을 지원한다. 게임 서버에 SSL/TLS를 적용하는 방법을 살펴보겠다.

```cpp
#include <boost/asio.hpp>
#include <boost/asio/ssl.hpp>
#include <boost/beast.hpp>
#include <iostream>
#include <memory>

class SecureGameServer {
private:
    boost::asio::io_context io_context_;
    boost::asio::ssl::context ssl_context_;
    boost::asio::ip::tcp::acceptor acceptor_;
    
public:
    SecureGameServer(int port) 
        : ssl_context_(boost::asio::ssl::context::sslv23),
          acceptor_(io_context_, boost::asio::ip::tcp::endpoint(
              boost::asio::ip::tcp::v4(), port)) {
        
        // SSL 인증서 설정
        ssl_context_.set_options(
            boost::asio::ssl::context::default_workarounds |
            boost::asio::ssl::context::no_sslv2 |
            boost::asio::ssl::context::single_dh_use);
            
        ssl_context_.use_certificate_chain_file("server.crt");
        ssl_context_.use_private_key_file("server.key", 
            boost::asio::ssl::context::pem);
        ssl_context_.use_tmp_dh_file("dh2048.pem");
        
        start_accept();
    }
    
    void start_accept() {
        auto new_session = std::make_shared<SecureSession>(
            io_context_, ssl_context_);
            
        acceptor_.async_accept(new_session->socket().lowest_layer(),
            [this, new_session](boost::system::error_code ec) {
                if (!ec) {
                    new_session->start();
                }
                start_accept();
            });
    }
    
    void run() {
        io_context_.run();
    }
};

class SecureSession : public std::enable_shared_from_this<SecureSession> {
private:
    boost::asio::ssl::stream<boost::asio::ip::tcp::socket> ssl_socket_;
    std::array<char, 1024> buffer_;
    
public:
    SecureSession(boost::asio::io_context& io_context,
                  boost::asio::ssl::context& ssl_context)
        : ssl_socket_(io_context, ssl_context) {}
    
    boost::asio::ssl::stream<boost::asio::ip::tcp::socket>& socket() {
        return ssl_socket_;
    }
    
    void start() {
        // SSL 핸드셰이크 수행
        ssl_socket_.async_handshake(boost::asio::ssl::stream_base::server,
            [self = shared_from_this()](boost::system::error_code ec) {
                if (!ec) {
                    self->do_read();
                }
            });
    }
    
private:
    void do_read() {
        ssl_socket_.async_read_some(boost::asio::buffer(buffer_),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t length) {
                if (!ec) {
                    self->process_secure_data(self->buffer_.data(), length);
                    self->do_read();
                }
            });
    }
    
    void process_secure_data(const char* data, std::size_t length) {
        // 암호화된 데이터 처리
        std::cout << "Received secure data: " << length << " bytes" << std::endl;
        
        // 응답 전송
        std::string response = "Secure response";
        boost::asio::async_write(ssl_socket_, 
            boost::asio::buffer(response),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t /*length*/) {
                if (ec) {
                    std::cerr << "Write error: " << ec.message() << std::endl;
                }
            });
    }
};
```

### 19.1.3 클라이언트 인증 시스템
게임 서버에 접속하는 클라이언트의 신원을 확인하는 인증 시스템을 구현해보겠다.  

```cpp
#include <boost/asio.hpp>
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <unordered_map>
#include <chrono>
#include <string>

class AuthenticationManager {
private:
    struct SessionInfo {
        std::string user_id;
        std::chrono::steady_clock::time_point created_time;
        std::chrono::steady_clock::time_point last_activity;
        bool is_authenticated;
    };
    
    std::unordered_map<std::string, SessionInfo> sessions_;
    boost::uuids::random_generator uuid_generator_;
    std::chrono::minutes session_timeout_{30};
    
public:
    std::string create_session(const std::string& user_id) {
        // 새로운 세션 토큰 생성
        std::string session_token = boost::uuids::to_string(uuid_generator_());
        
        SessionInfo info;
        info.user_id = user_id;
        info.created_time = std::chrono::steady_clock::now();
        info.last_activity = info.created_time;
        info.is_authenticated = false;
        
        sessions_[session_token] = info;
        return session_token;
    }
    
    bool authenticate_session(const std::string& session_token, 
                             const std::string& password_hash) {
        auto it = sessions_.find(session_token);
        if (it == sessions_.end()) {
            return false;
        }
        
        // 세션 만료 확인
        auto now = std::chrono::steady_clock::now();
        if (now - it->second.created_time > session_timeout_) {
            sessions_.erase(it);
            return false;
        }
        
        // 패스워드 검증 (실제로는 데이터베이스와 연동)
        if (verify_password(it->second.user_id, password_hash)) {
            it->second.is_authenticated = true;
            it->second.last_activity = now;
            return true;
        }
        
        return false;
    }
    
    bool validate_session(const std::string& session_token) {
        auto it = sessions_.find(session_token);
        if (it == sessions_.end() || !it->second.is_authenticated) {
            return false;
        }
        
        auto now = std::chrono::steady_clock::now();
        if (now - it->second.last_activity > session_timeout_) {
            sessions_.erase(it);
            return false;
        }
        
        it->second.last_activity = now;
        return true;
    }
    
    void cleanup_expired_sessions() {
        auto now = std::chrono::steady_clock::now();
        
        for (auto it = sessions_.begin(); it != sessions_.end();) {
            if (now - it->second.last_activity > session_timeout_) {
                it = sessions_.erase(it);
            } else {
                ++it;
            }
        }
    }
    
private:
    bool verify_password(const std::string& user_id, 
                        const std::string& password_hash) {
        // 실제 구현에서는 데이터베이스에서 해시된 패스워드를 조회
        // 여기서는 단순화된 예시
        return password_hash == "expected_hash_for_" + user_id;
    }
};

// 인증된 게임 세션 관리
class AuthenticatedGameSession : public std::enable_shared_from_this<AuthenticatedGameSession> {
private:
    boost::asio::ip::tcp::socket socket_;
    AuthenticationManager& auth_manager_;
    std::string session_token_;
    std::array<char, 1024> buffer_;
    
public:
    AuthenticatedGameSession(boost::asio::ip::tcp::socket socket,
                            AuthenticationManager& auth_manager)
        : socket_(std::move(socket)), auth_manager_(auth_manager) {}
    
    void start() {
        do_read_auth();
    }
    
private:
    void do_read_auth() {
        // 인증 정보 수신
        socket_.async_read_some(boost::asio::buffer(buffer_),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t length) {
                if (!ec) {
                    self->process_authentication(self->buffer_.data(), length);
                }
            });
    }
    
    void process_authentication(const char* data, std::size_t length) {
        // 인증 패킷 파싱 (간단한 예시)
        std::string auth_data(data, length);
        size_t delimiter_pos = auth_data.find(':');
        
        if (delimiter_pos != std::string::npos) {
            session_token_ = auth_data.substr(0, delimiter_pos);
            std::string password_hash = auth_data.substr(delimiter_pos + 1);
            
            if (auth_manager_.authenticate_session(session_token_, password_hash)) {
                send_auth_success();
                start_game_communication();
            } else {
                send_auth_failure();
            }
        }
    }
    
    void send_auth_success() {
        std::string response = "AUTH_SUCCESS";
        boost::asio::async_write(socket_, boost::asio::buffer(response),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t /*length*/) {
                if (ec) {
                    std::cerr << "Auth success write error: " << ec.message() << std::endl;
                }
            });
    }
    
    void send_auth_failure() {
        std::string response = "AUTH_FAILED";
        boost::asio::async_write(socket_, boost::asio::buffer(response),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t /*length*/) {
                // 인증 실패 후 연결 종료
                self->socket_.close();
            });
    }
    
    void start_game_communication() {
        do_read_game_data();
    }
    
    void do_read_game_data() {
        socket_.async_read_some(boost::asio::buffer(buffer_),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t length) {
                if (!ec) {
                    // 세션 유효성 재확인
                    if (self->auth_manager_.validate_session(self->session_token_)) {
                        self->process_game_data(self->buffer_.data(), length);
                        self->do_read_game_data();
                    } else {
                        self->socket_.close();
                    }
                }
            });
    }
    
    void process_game_data(const char* data, std::size_t length) {
        // 인증된 클라이언트의 게임 데이터 처리
        std::cout << "Processing authenticated game data: " << length << " bytes" << std::endl;
    }
};
```

## 19.2 패킷 암호화

### 19.2.1 대칭키 암호화 구현
게임에서는 실시간성이 중요하므로 빠른 대칭키 암호화를 주로 사용한다. AES 암호화를 Boost.Asio와 함께 사용하는 방법을 살펴보겠다.

```cpp
#include <boost/asio.hpp>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <openssl/evp.h>
#include <vector>
#include <array>
#include <memory>

class PacketCrypto {
private:
    std::array<unsigned char, 32> aes_key_;  // AES-256 키
    std::array<unsigned char, 16> iv_;       // 초기화 벡터
    
public:
    PacketCrypto() {
        // 랜덤 키와 IV 생성
        if (RAND_bytes(aes_key_.data(), aes_key_.size()) != 1 ||
            RAND_bytes(iv_.data(), iv_.size()) != 1) {
            throw std::runtime_error("Failed to generate random key/IV");
        }
    }
    
    // 키 교환을 위한 생성자 (실제로는 키 교환 프로토콜 사용)
    PacketCrypto(const std::array<unsigned char, 32>& key,
                 const std::array<unsigned char, 16>& iv)
        : aes_key_(key), iv_(iv) {}
    
    std::vector<unsigned char> encrypt(const std::vector<unsigned char>& plaintext) {
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) {
            throw std::runtime_error("Failed to create cipher context");
        }
        
        // AES-256-CBC 초기화
        if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, 
                              aes_key_.data(), iv_.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to initialize encryption");
        }
        
        std::vector<unsigned char> ciphertext(plaintext.size() + AES_BLOCK_SIZE);
        int len;
        int ciphertext_len;
        
        // 암호화 수행
        if (EVP_EncryptUpdate(ctx, ciphertext.data(), &len, 
                             plaintext.data(), plaintext.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to encrypt data");
        }
        ciphertext_len = len;
        
        // 패딩 처리
        if (EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to finalize encryption");
        }
        ciphertext_len += len;
        
        EVP_CIPHER_CTX_free(ctx);
        ciphertext.resize(ciphertext_len);
        return ciphertext;
    }
    
    std::vector<unsigned char> decrypt(const std::vector<unsigned char>& ciphertext) {
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) {
            throw std::runtime_error("Failed to create cipher context");
        }
        
        // AES-256-CBC 초기화
        if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, 
                              aes_key_.data(), iv_.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to initialize decryption");
        }
        
        std::vector<unsigned char> plaintext(ciphertext.size());
        int len;
        int plaintext_len;
        
        // 복호화 수행
        if (EVP_DecryptUpdate(ctx, plaintext.data(), &len, 
                             ciphertext.data(), ciphertext.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to decrypt data");
        }
        plaintext_len = len;
        
        // 패딩 제거
        if (EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to finalize decryption");
        }
        plaintext_len += len;
        
        EVP_CIPHER_CTX_free(ctx);
        plaintext.resize(plaintext_len);
        return plaintext;
    }
    
    const std::array<unsigned char, 32>& get_key() const { return aes_key_; }
    const std::array<unsigned char, 16>& get_iv() const { return iv_; }
};

// 암호화된 게임 패킷 처리
class EncryptedGameSession : public std::enable_shared_from_this<EncryptedGameSession> {
private:
    boost::asio::ip::tcp::socket socket_;
    PacketCrypto crypto_;
    std::array<char, 2048> buffer_;
    
public:
    EncryptedGameSession(boost::asio::ip::tcp::socket socket)
        : socket_(std::move(socket)) {
        // 실제로는 키 교환 프로토콜을 통해 암호화 키 설정
        perform_key_exchange();
    }
    
    void start() {
        do_read();
    }
    
private:
    void perform_key_exchange() {
        // 간단화된 키 교환 (실제로는 Diffie-Hellman 등 사용)
        auto key = crypto_.get_key();
        auto iv = crypto_.get_iv();
        
        // 클라이언트에게 암호화 정보 전송 (실제로는 RSA 등으로 암호화)
        std::vector<unsigned char> key_data;
        key_data.insert(key_data.end(), key.begin(), key.end());
        key_data.insert(key_data.end(), iv.begin(), iv.end());
        
        boost::asio::async_write(socket_, boost::asio::buffer(key_data),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t /*length*/) {
                if (!ec) {
                    std::cout << "Key exchange completed" << std::endl;
                }
            });
    }
    
    void do_read() {
        socket_.async_read_some(boost::asio::buffer(buffer_),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t length) {
                if (!ec) {
                    self->process_encrypted_packet(self->buffer_.data(), length);
                    self->do_read();
                }
            });
    }
    
    void process_encrypted_packet(const char* data, std::size_t length) {
        try {
            // 암호화된 데이터를 복호화
            std::vector<unsigned char> encrypted_data(data, data + length);
            std::vector<unsigned char> decrypted_data = crypto_.decrypt(encrypted_data);
            
            // 복호화된 게임 패킷 처리
            process_game_packet(decrypted_data);
            
        } catch (const std::exception& e) {
            std::cerr << "Decryption error: " << e.what() << std::endl;
            socket_.close();
        }
    }
    
    void process_game_packet(const std::vector<unsigned char>& packet_data) {
        // 게임 패킷 처리 로직
        std::cout << "Processing decrypted game packet: " 
                  << packet_data.size() << " bytes" << std::endl;
        
        // 응답 패킷 생성 및 암호화 전송
        send_encrypted_response("Game response");
    }
    
    void send_encrypted_response(const std::string& response) {
        try {
            std::vector<unsigned char> plaintext(response.begin(), response.end());
            std::vector<unsigned char> encrypted_data = crypto_.encrypt(plaintext);
            
            boost::asio::async_write(socket_, boost::asio::buffer(encrypted_data),
                [self = shared_from_this()](boost::system::error_code ec, 
                                           std::size_t /*length*/) {
                    if (ec) {
                        std::cerr << "Encrypted write error: " << ec.message() << std::endl;
                    }
                });
                
        } catch (const std::exception& e) {
            std::cerr << "Encryption error: " << e.what() << std::endl;
        }
    }
};
```

### 19.2.2 메시지 무결성 검증
패킷이 전송 중에 변조되지 않았는지 확인하기 위해 HMAC을 사용한 무결성 검증을 구현해보겠다.

```cpp
#include <openssl/hmac.h>
#include <openssl/sha.h>
#include <array>
#include <vector>
#include <iomanip>
#include <sstream>

class MessageAuthenticator {
private:
    std::array<unsigned char, 32> hmac_key_;
    
public:
    MessageAuthenticator() {
        // HMAC 키 생성
        if (RAND_bytes(hmac_key_.data(), hmac_key_.size()) != 1) {
            throw std::runtime_error("Failed to generate HMAC key");
        }
    }
    
    MessageAuthenticator(const std::array<unsigned char, 32>& key)
        : hmac_key_(key) {}
    
    std::vector<unsigned char> generate_hmac(const std::vector<unsigned char>& data) {
        std::vector<unsigned char> hmac(SHA256_DIGEST_LENGTH);
        unsigned int hmac_len;
        
        if (!HMAC(EVP_sha256(), hmac_key_.data(), hmac_key_.size(),
                 data.data(), data.size(), hmac.data(), &hmac_len)) {
            throw std::runtime_error("Failed to generate HMAC");
        }
        
        hmac.resize(hmac_len);
        return hmac;
    }
    
    bool verify_hmac(const std::vector<unsigned char>& data,
                     const std::vector<unsigned char>& received_hmac) {
        auto calculated_hmac = generate_hmac(data);
        
        if (calculated_hmac.size() != received_hmac.size()) {
            return false;
        }
        
        // 타이밍 공격 방지를 위한 상수 시간 비교
        int result = 0;
        for (size_t i = 0; i < calculated_hmac.size(); ++i) {
            result |= calculated_hmac[i] ^ received_hmac[i];
        }
        
        return result == 0;
    }
    
    const std::array<unsigned char, 32>& get_key() const { return hmac_key_; }
};

// 암호화와 무결성 검증을 모두 적용한 게임 패킷
struct SecureGamePacket {
    uint32_t packet_id;
    uint32_t sequence_number;
    uint32_t data_length;
    std::vector<unsigned char> encrypted_data;
    std::vector<unsigned char> hmac;
    
    // 패킷 직렬화
    std::vector<unsigned char> serialize() const {
        std::vector<unsigned char> buffer;
        
        // 헤더 정보 추가
        buffer.resize(sizeof(packet_id) + sizeof(sequence_number) + sizeof(data_length));
        std::memcpy(buffer.data(), &packet_id, sizeof(packet_id));
        std::memcpy(buffer.data() + sizeof(packet_id), &sequence_number, sizeof(sequence_number));
        std::memcpy(buffer.data() + sizeof(packet_id) + sizeof(sequence_number), 
                   &data_length, sizeof(data_length));
        
        // 암호화된 데이터 추가
        buffer.insert(buffer.end(), encrypted_data.begin(), encrypted_data.end());
        
        // HMAC 추가
        buffer.insert(buffer.end(), hmac.begin(), hmac.end());
        
        return buffer;
    }
    
    // 패킷 역직렬화
    static SecureGamePacket deserialize(const std::vector<unsigned char>& buffer) {
        if (buffer.size() < sizeof(uint32_t) * 3 + SHA256_DIGEST_LENGTH) {
            throw std::runtime_error("Invalid packet size");
        }
        
        SecureGamePacket packet;
        size_t offset = 0;
        
        // 헤더 정보 읽기
        std::memcpy(&packet.packet_id, buffer.data() + offset, sizeof(packet.packet_id));
        offset += sizeof(packet.packet_id);
        
        std::memcpy(&packet.sequence_number, buffer.data() + offset, sizeof(packet.sequence_number));
        offset += sizeof(packet.sequence_number);
        
        std::memcpy(&packet.data_length, buffer.data() + offset, sizeof(packet.data_length));
        offset += sizeof(packet.data_length);
        
        // 암호화된 데이터 읽기
        if (buffer.size() < offset + packet.data_length + SHA256_DIGEST_LENGTH) {
            throw std::runtime_error("Invalid data length");
        }
        
        packet.encrypted_data.assign(buffer.begin() + offset, 
                                   buffer.begin() + offset + packet.data_length);
        offset += packet.data_length;
        
        // HMAC 읽기
        packet.hmac.assign(buffer.begin() + offset, 
                          buffer.begin() + offset + SHA256_DIGEST_LENGTH);
        
        return packet;
    }
};

class SecurePacketProcessor {
private:
    PacketCrypto crypto_;
    MessageAuthenticator authenticator_;
    uint32_t next_sequence_number_;
    std::unordered_map<uint32_t, uint32_t> client_sequences_;
    
public:
    SecurePacketProcessor() : next_sequence_number_(1) {}
    
    SecureGamePacket create_secure_packet(uint32_t packet_id, 
                                         const std::vector<unsigned char>& data) {
        SecureGamePacket packet;
        packet.packet_id = packet_id;
        packet.sequence_number = next_sequence_number_++;
        
        // 데이터 암호화
        packet.encrypted_data = crypto_.encrypt(data);
        packet.data_length = packet.encrypted_data.size();
        
        // HMAC 생성 (헤더 + 암호화된 데이터)
        std::vector<unsigned char> hmac_data;
        hmac_data.resize(sizeof(packet.packet_id) + sizeof(packet.sequence_number) + 
                        sizeof(packet.data_length));
        std::memcpy(hmac_data.data(), &packet.packet_id, sizeof(packet.packet_id));
        std::memcpy(hmac_data.data() + sizeof(packet.packet_id), 
                   &packet.sequence_number, sizeof(packet.sequence_number));
        std::memcpy(hmac_data.data() + sizeof(packet.packet_id) + sizeof(packet.sequence_number), 
                   &packet.data_length, sizeof(packet.data_length));
        hmac_data.insert(hmac_data.end(), packet.encrypted_data.begin(), packet.encrypted_data.end());
        
        packet.hmac = authenticator_.generate_hmac(hmac_data);
        
        return packet;
    }
    
    std::vector<unsigned char> process_secure_packet(const SecureGamePacket& packet, 
                                                    uint32_t client_id) {
        // 시퀀스 번호 검증 (재전송 공격 방지)
        auto it = client_sequences_.find(client_id);
        if (it != client_sequences_.end()) {
            if (packet.sequence_number <= it->second) {
                throw std::runtime_error("Invalid sequence number - possible replay attack");
            }
        }
        
        // HMAC 검증
        std::vector<unsigned char> hmac_data;
        hmac_data.resize(sizeof(packet.packet_id) + sizeof(packet.sequence_number) + 
                        sizeof(packet.data_length));
        std::memcpy(hmac_data.data(), &packet.packet_id, sizeof(packet.packet_id));
        std::memcpy(hmac_data.data() + sizeof(packet.packet_id), 
                   &packet.sequence_number, sizeof(packet.sequence_number));
        std::memcpy(hmac_data.data() + sizeof(packet.packet_id) + sizeof(packet.sequence_number), 
                   &packet.data_length, sizeof(packet.data_length));
        hmac_data.insert(hmac_data.end(), packet.encrypted_data.begin(), packet.encrypted_data.end());
        
        if (!authenticator_.verify_hmac(hmac_data, packet.hmac)) {
            throw std::runtime_error("HMAC verification failed - packet may be tampered");
        }
        
        // 데이터 복호화
        std::vector<unsigned char> decrypted_data = crypto_.decrypt(packet.encrypted_data);
        
        // 시퀀스 번호 업데이트
        client_sequences_[client_id] = packet.sequence_number;
        
        return decrypted_data;
    }
};
```

## 19.3 DDoS 방어 기법

### 19.3.1 연결 속도 제한
DDoS 공격을 방어하기 위해 클라이언트별 연결 속도를 제한하는 시스템을 구현해보겠다.

```cpp
#include <boost/asio.hpp>
#include <unordered_map>
#include <chrono>
#include <algorithm>
#include <deque>

class RateLimiter {
private:
    struct ClientInfo {
        std::deque<std::chrono::steady_clock::time_point> connection_times;
        std::deque<std::chrono::steady_clock::time_point> packet_times;
        std::chrono::steady_clock::time_point first_connection;
        uint32_t total_connections;
        bool is_blocked;
        std::chrono::steady_clock::time_point block_until;
    };
    
    std::unordered_map<std::string, ClientInfo> client_info_;
    std::chrono::seconds time_window_{60};  // 1분 윈도우
    uint32_t max_connections_per_window_{10};
    uint32_t max_packets_per_second_{100};
    std::chrono::minutes block_duration_{15};  // 15분 차단
    
public:
    bool allow_connection(const std::string& client_ip) {
        auto now = std::chrono::steady_clock::now();
        auto& info = client_info_[client_ip];
        
        // 차단 상태 확인
        if (info.is_blocked) {
            if (now >= info.block_until) {
                info.is_blocked = false;
                info.connection_times.clear();
                info.packet_times.clear();
            } else {
                return false;
            }
        }
        
        // 오래된 연결 기록 제거
        while (!info.connection_times.empty() && 
               now - info.connection_times.front() > time_window_) {
            info.connection_times.pop_front();
        }
        
        // 연결 제한 확인
        if (info.connection_times.size() >= max_connections_per_window_) {
            // 클라이언트 차단
            info.is_blocked = true;
            info.block_until = now + block_duration_;
            
            std::cout << "Client " << client_ip << " blocked for excessive connections" << std::endl;
            return false;
        }
        
        // 연결 허용
        info.connection_times.push_back(now);
        info.total_connections++;
        
        return true;
    }
    
    bool allow_packet(const std::string& client_ip) {
        auto now = std::chrono::steady_clock::now();
        auto it = client_info_.find(client_ip);
        
        if (it == client_info_.end()) {
            return false;  // 연결되지 않은 클라이언트
        }
        
        auto& info = it->second;
        
        // 차단 상태 확인
        if (info.is_blocked && now < info.block_until) {
            return false;
        }
        
        // 1초 이내의 패킷 수 확인
        auto one_second_ago = now - std::chrono::seconds(1);
        while (!info.packet_times.empty() && 
               info.packet_times.front() < one_second_ago) {
            info.packet_times.pop_front();
        }
        
        if (info.packet_times.size() >= max_packets_per_second_) {
            // 패킷 속도 제한 초과
            info.is_blocked = true;
            info.block_until = now + block_duration_;
            
            std::cout << "Client " << client_ip << " blocked for packet flooding" << std::endl;
            return false;
        }
        
        info.packet_times.push_back(now);
        return true;
    }
    
    void cleanup_old_records() {
        auto now = std::chrono::steady_clock::now();
        auto cleanup_threshold = now - std::chrono::hours(1);
        
        for (auto it = client_info_.begin(); it != client_info_.end();) {
            auto& info = it->second;
            
            // 차단 해제된 오래된 기록 정리
            if (!info.is_blocked && 
                (info.connection_times.empty() || 
                 info.connection_times.back() < cleanup_threshold)) {
                it = client_info_.erase(it);
            } else {
                ++it;
            }
        }
    }
    
    void get_statistics(std::string& stats) {
        auto now = std::chrono::steady_clock::now();
        uint32_t total_clients = client_info_.size();
        uint32_t blocked_clients = 0;
        uint32_t active_connections = 0;
        
        for (const auto& pair : client_info_) {
            if (pair.second.is_blocked && now < pair.second.block_until) {
                blocked_clients++;
            }
            if (!pair.second.connection_times.empty() && 
                now - pair.second.connection_times.back() < std::chrono::minutes(5)) {
                active_connections++;
            }
        }
        
        std::ostringstream oss;
        oss << "Total clients: " << total_clients << ", "
            << "Blocked: " << blocked_clients << ", "
            << "Active: " << active_connections;
        stats = oss.str();
    }
};

class DDoSProtectedServer {
private:
    boost::asio::io_context io_context_;
    boost::asio::ip::tcp::acceptor acceptor_;
    RateLimiter rate_limiter_;
    boost::asio::steady_timer cleanup_timer_;
    
public:
    DDoSProtectedServer(int port) 
        : acceptor_(io_context_, boost::asio::ip::tcp::endpoint(
              boost::asio::ip::tcp::v4(), port)),
          cleanup_timer_(io_context_) {
        start_accept();
        start_cleanup_timer();
    }
    
    void start_accept() {
        auto socket = std::make_shared<boost::asio::ip::tcp::socket>(io_context_);
        
        acceptor_.async_accept(*socket,
            [this, socket](boost::system::error_code ec) {
                if (!ec) {
                    handle_new_connection(socket);
                }
                start_accept();
            });
    }
    
    void handle_new_connection(std::shared_ptr<boost::asio::ip::tcp::socket> socket) {
        try {
            std::string client_ip = socket->remote_endpoint().address().to_string();
            
            if (rate_limiter_.allow_connection(client_ip)) {
                // 연결 허용
                auto session = std::make_shared<ProtectedGameSession>(
                    std::move(*socket), rate_limiter_, client_ip);
                session->start();
                
                std::cout << "Connection accepted from " << client_ip << std::endl;
            } else {
                // 연결 거부
                std::cout << "Connection rejected from " << client_ip << std::endl;
                socket->close();
            }
        } catch (const std::exception& e) {
            std::cerr << "Error handling new connection: " << e.what() << std::endl;
        }
    }
    
    void start_cleanup_timer() {
        cleanup_timer_.expires_after(std::chrono::minutes(5));
        cleanup_timer_.async_wait([this](boost::system::error_code ec) {
            if (!ec) {
                rate_limiter_.cleanup_old_records();
                
                std::string stats;
                rate_limiter_.get_statistics(stats);
                std::cout << "Rate limiter stats: " << stats << std::endl;
                
                start_cleanup_timer();
            }
        });
    }
    
    void run() {
        io_context_.run();
    }
};

class ProtectedGameSession : public std::enable_shared_from_this<ProtectedGameSession> {
private:
    boost::asio::ip::tcp::socket socket_;
    RateLimiter& rate_limiter_;
    std::string client_ip_;
    std::array<char, 1024> buffer_;
    
public:
    ProtectedGameSession(boost::asio::ip::tcp::socket socket,
                        RateLimiter& rate_limiter,
                        const std::string& client_ip)
        : socket_(std::move(socket)), rate_limiter_(rate_limiter), client_ip_(client_ip) {}
    
    void start() {
        do_read();
    }
    
private:
    void do_read() {
        socket_.async_read_some(boost::asio::buffer(buffer_),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t length) {
                if (!ec) {
                    if (self->rate_limiter_.allow_packet(self->client_ip_)) {
                        self->process_packet(self->buffer_.data(), length);
                        self->do_read();
                    } else {
                        std::cout << "Packet rate limit exceeded for " 
                                  << self->client_ip_ << std::endl;
                        self->socket_.close();
                    }
                }
            });
    }
    
    void process_packet(const char* data, std::size_t length) {
        // 패킷 처리 로직
        std::cout << "Processing packet from " << client_ip_ 
                  << ": " << length << " bytes" << std::endl;
        
        // 응답 전송
        std::string response = "Packet processed";
        boost::asio::async_write(socket_, boost::asio::buffer(response),
            [self = shared_from_this()](boost::system::error_code ec, 
                                       std::size_t /*length*/) {
                if (ec) {
                    std::cerr << "Write error: " << ec.message() << std::endl;
                }
            });
    }
};
```

### 19.3.2 SYN Flood 방어
SYN Flood 공격을 방어하기 위한 추가적인 보안 조치를 구현해보겠다.

```cpp
#include <boost/asio.hpp>
#include <unordered_set>
#include <random>

class SynFloodProtector {
private:
    struct PendingConnection {
        std::string client_ip;
        std::chrono::steady_clock::time_point timestamp;
        uint32_t syn_cookie;
    };
    
    std::unordered_map<std::string, std::vector<PendingConnection>> pending_connections_;
    std::chrono::seconds syn_timeout_{30};
    uint32_t max_pending_per_ip_{5};
    std::random_device rd_;
    std::mt19937 gen_;
    
public:
    SynFloodProtector() : gen_(rd_()) {}
    
    bool allow_syn(const std::string& client_ip) {
        auto now = std::chrono::steady_clock::now();
        auto& pending = pending_connections_[client_ip];
        
        // 만료된 연결 제거
        pending.erase(std::remove_if(pending.begin(), pending.end(),
            [now, this](const PendingConnection& conn) {
                return now - conn.timestamp > syn_timeout_;
            }), pending.end());
        
        // 대기 중인 연결 수 확인
        if (pending.size() >= max_pending_per_ip_) {
            std::cout << "SYN flood detected from " << client_ip << std::endl;
            return false;
        }
        
        // 새로운 대기 연결 추가
        PendingConnection new_conn;
        new_conn.client_ip = client_ip;
        new_conn.timestamp = now;
        new_conn.syn_cookie = gen_();
        
        pending.push_back(new_conn);
        return true;
    }
    
    bool validate_ack(const std::string& client_ip, uint32_t ack_cookie) {
        auto it = pending_connections_.find(client_ip);
        if (it == pending_connections_.end()) {
            return false;
        }
        
        auto& pending = it->second;
        auto found = std::find_if(pending.begin(), pending.end(),
            [ack_cookie](const PendingConnection& conn) {
                return conn.syn_cookie == ack_cookie;
            });
        
        if (found != pending.end()) {
            pending.erase(found);
            return true;
        }
        
        return false;
    }
    
    void cleanup_expired() {
        auto now = std::chrono::steady_clock::now();
        
        for (auto it = pending_connections_.begin(); it != pending_connections_.end();) {
            auto& pending = it->second;
            
            pending.erase(std::remove_if(pending.begin(), pending.end(),
                [now, this](const PendingConnection& conn) {
                    return now - conn.timestamp > syn_timeout_;
                }), pending.end());
            
            if (pending.empty()) {
                it = pending_connections_.erase(it);
            } else {
                ++it;
            }
        }
    }
};

// 연결 풀 관리
class ConnectionPool {
private:
    boost::asio::io_context& io_context_;
    std::vector<std::shared_ptr<boost::asio::ip::tcp::socket>> available_sockets_;
    std::unordered_set<std::shared_ptr<boost::asio::ip::tcp::socket>> active_sockets_;
    size_t max_pool_size_;
    size_t max_active_connections_;
    
public:
    ConnectionPool(boost::asio::io_context& io_context, 
                   size_t max_pool_size = 1000,
                   size_t max_active_connections = 10000)
        : io_context_(io_context), 
          max_pool_size_(max_pool_size),
          max_active_connections_(max_active_connections) {
        
        // 소켓 풀 사전 할당
        available_sockets_.reserve(max_pool_size_);
        for (size_t i = 0; i < max_pool_size_; ++i) {
            available_sockets_.push_back(
                std::make_shared<boost::asio::ip::tcp::socket>(io_context_));
        }
    }
    
    std::shared_ptr<boost::asio::ip::tcp::socket> acquire_socket() {
        if (active_sockets_.size() >= max_active_connections_) {
            return nullptr;  // 최대 연결 수 초과
        }
        
        std::shared_ptr<boost::asio::ip::tcp::socket> socket;
        
        if (!available_sockets_.empty()) {
            socket = available_sockets_.back();
            available_sockets_.pop_back();
        } else {
            socket = std::make_shared<boost::asio::ip::tcp::socket>(io_context_);
        }
        
        active_sockets_.insert(socket);
        return socket;
    }
    
    void release_socket(std::shared_ptr<boost::asio::ip::tcp::socket> socket) {
        active_sockets_.erase(socket);
        
        if (socket->is_open()) {
            boost::system::error_code ec;
            socket->close(ec);
        }
        
        if (available_sockets_.size() < max_pool_size_) {
            available_sockets_.push_back(socket);
        }
    }
    
    size_t active_connections() const { return active_sockets_.size(); }
    size_t available_sockets() const { return available_sockets_.size(); }
};
```

## 19.4 서버 안정성 확보

### 19.4.1 예외 처리와 로깅
서버의 안정성을 위해 체계적인 예외 처리와 로깅 시스템을 구현해보겠다.

```cpp
#include <boost/asio.hpp>
#include <boost/log/trivial.hpp>
#include <boost/log/core.hpp>
#include <boost/log/expressions.hpp>
#include <boost/log/sinks/text_file_backend.hpp>
#include <boost/log/utility/setup/file.hpp>
#include <boost/log/utility/setup/common_attributes.hpp>
#include <boost/log/sources/severity_logger.hpp>
#include <fstream>
#include <exception>

namespace logging = boost::log;
namespace src = boost::log::sources;
namespace sinks = boost::log::sinks;
namespace keywords = boost::log::keywords;

class GameServerLogger {
private:
    src::severity_logger<logging::trivial::severity_level> logger_;
    
public:
    GameServerLogger() {
        // 로그 파일 설정
        logging::add_file_log(
            keywords::file_name = "game_server_%N.log",
            keywords::rotation_size = 10 * 1024 * 1024,  // 10MB
            keywords::time_based_rotation = sinks::file::rotation_at_time_point(0, 0, 0),
            keywords::format = "[%TimeStamp%] [%Severity%] %Message%"
        );
        
        logging::core::get()->set_filter(
            logging::trivial::severity >= logging::trivial::info
        );
        
        logging::add_common_attributes();
    }
    
    void log_info(const std::string& message) {
        BOOST_LOG_SEV(logger_, logging::trivial::info) << message;
    }
    
    void log_warning(const std::string& message) {
        BOOST_LOG_SEV(logger_, logging::trivial::warning) << message;
    }
    
    void log_error(const std::string& message) {
        BOOST_LOG_SEV(logger_, logging::trivial::error) << message;
    }
    
    void log_critical(const std::string& message) {
        BOOST_LOG_SEV(logger_, logging::trivial::fatal) << message;
    }
};

// 커스텀 예외 클래스들
class GameServerException : public std::exception {
protected:
    std::string message_;
    
public:
    GameServerException(const std::string& message) : message_(message) {}
    const char* what() const noexcept override { return message_.c_str(); }
};

class NetworkException : public GameServerException {
public:
    NetworkException(const std::string& message) 
        : GameServerException("Network Error: " + message) {}
};

class AuthenticationException : public GameServerException {
public:
    AuthenticationException(const std::string& message) 
        : GameServerException("Authentication Error: " + message) {}
};

class DatabaseException : public GameServerException {
public:
    DatabaseException(const std::string& message) 
        : GameServerException("Database Error: " + message) {}
};

// 안전한 게임 세션 클래스
class SafeGameSession : public std::enable_shared_from_this<SafeGameSession> {
private:
    boost::asio::ip::tcp::socket socket_;
    GameServerLogger& logger_;
    std::array<char, 1024> buffer_;
    std::string client_id_;
    std::atomic<bool> is_active_;
    
public:
    SafeGameSession(boost::asio::ip::tcp::socket socket, 
                   GameServerLogger& logger)
        : socket_(std::move(socket)), logger_(logger), is_active_(true) {
        
        try {
            client_id_ = socket_.remote_endpoint().address().to_string() + ":" +
                        std::to_string(socket_.remote_endpoint().port());
            logger_.log_info("New session created: " + client_id_);
        } catch (const std::exception& e) {
            client_id_ = "unknown";
            logger_.log_warning("Failed to get client endpoint: " + std::string(e.what()));
        }
    }
    
    ~SafeGameSession() {
        logger_.log_info("Session destroyed: " + client_id_);
    }
    
    void start() {
        try {
            is_active_ = true;
            do_read();
        } catch (const std::exception& e) {
            logger_.log_error("Failed to start session " + client_id_ + ": " + e.what());
            safe_close();
        }
    }
    
    void stop() {
        is_active_ = false;
        safe_close();
    }
    
private:
    void do_read() {
        if (!is_active_) return;
        
        auto self = shared_from_this();
        
        socket_.async_read_some(boost::asio::buffer(buffer_),
            [self](boost::system::error_code ec, std::size_t length) {
                self->handle_read(ec, length);
            });
    }
    
    void handle_read(boost::system::error_code ec, std::size_t length) {
        if (!is_active_) return;
        
        try {
            if (ec) {
                if (ec == boost::asio::error::eof || 
                    ec == boost::asio::error::connection_reset) {
                    logger_.log_info("Client disconnected: " + client_id_);
                } else {
                    logger_.log_warning("Read error for " + client_id_ + ": " + ec.message());
                }
                safe_close();
                return;
            }
            
            // 패킷 처리
            process_packet_safely(buffer_.data(), length);
            
            // 다음 읽기 작업 예약
            do_read();
            
        } catch (const NetworkException& e) {
            logger_.log_error("Network exception for " + client_id_ + ": " + e.what());
            safe_close();
        } catch (const AuthenticationException& e) {
            logger_.log_warning("Authentication failed for " + client_id_ + ": " + e.what());
            send_error_response("Authentication failed");
            safe_close();
        } catch (const DatabaseException& e) {
            logger_.log_error("Database error for " + client_id_ + ": " + e.what());
            send_error_response("Internal server error");
        } catch (const std::exception& e) {
            logger_.log_critical("Unexpected exception for " + client_id_ + ": " + e.what());
            safe_close();
        }
    }
    
    void process_packet_safely(const char* data, std::size_t length) {
        // 패킷 크기 검증
        if (length == 0 || length > 1024) {
            throw NetworkException("Invalid packet size: " + std::to_string(length));
        }
        
        // 패킷 내용 검증
        if (!validate_packet_format(data, length)) {
            throw NetworkException("Invalid packet format");
        }
        
        // 실제 게임 로직 처리
        process_game_packet(data, length);
        
        logger_.log_info("Processed packet from " + client_id_ + 
                        " (" + std::to_string(length) + " bytes)");
    }
    
    bool validate_packet_format(const char* data, std::size_t length) {
        // 기본적인 패킷 형식 검증
        if (length < sizeof(uint32_t)) {
            return false;  // 최소 헤더 크기 미달
        }
        
        // 패킷 타입 검증
        uint32_t packet_type;
        std::memcpy(&packet_type, data, sizeof(packet_type));
        
        if (packet_type == 0 || packet_type > 1000) {
            return false;  // 유효하지 않은 패킷 타입
        }
        
        return true;
    }
    
    void process_game_packet(const char* data, std::size_t length) {
        // 게임 패킷 처리 로직
        uint32_t packet_type;
        std::memcpy(&packet_type, data, sizeof(packet_type));
        
        switch (packet_type) {
            case 1:  // 플레이어 이동
                handle_player_move(data + sizeof(uint32_t), length - sizeof(uint32_t));
                break;
            case 2:  // 채팅 메시지
                handle_chat_message(data + sizeof(uint32_t), length - sizeof(uint32_t));
                break;
            default:
                logger_.log_warning("Unknown packet type: " + std::to_string(packet_type));
        }
    }
    
    void handle_player_move(const char* data, std::size_t length) {
        if (length < sizeof(float) * 3) {
            throw NetworkException("Invalid move packet size");
        }
        
        float x, y, z;
        std::memcpy(&x, data, sizeof(float));
        std::memcpy(&y, data + sizeof(float), sizeof(float));
        std::memcpy(&z, data + sizeof(float) * 2, sizeof(float));
        
        // 좌표 유효성 검증
        if (std::isnan(x) || std::isnan(y) || std::isnan(z) ||
            std::abs(x) > 10000 || std::abs(y) > 10000 || std::abs(z) > 10000) {
            throw NetworkException("Invalid coordinates");
        }
        
        // 플레이어 이동 처리
        logger_.log_info("Player move: " + client_id_ + 
                        " to (" + std::to_string(x) + ", " + 
                        std::to_string(y) + ", " + std::to_string(z) + ")");
    }
    
    void handle_chat_message(const char* data, std::size_t length) {
        if (length == 0 || length > 256) {
            throw NetworkException("Invalid chat message length");
        }
        
        std::string message(data, length);
        
        // 메시지 내용 검증 (욕설 필터 등)
        if (!validate_chat_message(message)) {
            throw NetworkException("Invalid chat message content");
        }
        
        logger_.log_info("Chat message from " + client_id_ + ": " + message);
    }
    
    bool validate_chat_message(const std::string& message) {
        // 기본적인 채팅 메시지 검증
        if (message.empty() || message.length() > 256) {
            return false;
        }
        
        // 특수 문자나 제어 문자 확인
        for (char c : message) {
            if (c < 32 && c != '\t' && c != '\n') {
                return false;
            }
        }
        
        return true;
    }
    
    void send_error_response(const std::string& error_message) {
        try {
            std::string response = "ERROR: " + error_message;
            boost::asio::async_write(socket_, boost::asio::buffer(response),
                [self = shared_from_this()](boost::system::error_code ec, 
                                           std::size_t /*length*/) {
                    if (ec) {
                        self->logger_.log_error("Failed to send error response to " + 
                                              self->client_id_ + ": " + ec.message());
                    }
                });
        } catch (const std::exception& e) {
            logger_.log_error("Exception while sending error response to " + 
                            client_id_ + ": " + e.what());
        }
    }
    
    void safe_close() {
        if (!is_active_.exchange(false)) {
            return;  // 이미 닫힘
        }
        
        try {
            if (socket_.is_open()) {
                boost::system::error_code ec;
                socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);
                socket_.close(ec);
                
                if (ec) {
                    logger_.log_warning("Error closing socket for " + client_id_ + 
                                      ": " + ec.message());
                }
            }
        } catch (const std::exception& e) {
            logger_.log_error("Exception while closing session " + client_id_ + 
                            ": " + e.what());
        }
    }
};

// 안전한 게임 서버
class SafeGameServer {
private:
    boost::asio::io_context io_context_;
    boost::asio::ip::tcp::acceptor acceptor_;
    GameServerLogger logger_;
    std::atomic<bool> is_running_;
    
public:
    SafeGameServer(int port) 
        : acceptor_(io_context_, boost::asio::ip::tcp::endpoint(
              boost::asio::ip::tcp::v4(), port)),
          is_running_(false) {
        
        logger_.log_info("Game server initializing on port " + std::to_string(port));
    }
    
    void start() {
        try {
            is_running_ = true;
            start_accept();
            logger_.log_info("Game server started successfully");
            
            // 시그널 핸들러 설정 (우아한 종료)
            boost::asio::signal_set signals(io_context_, SIGINT, SIGTERM);
            signals.async_wait([this](boost::system::error_code ec, int signal) {
                if (!ec) {
                    logger_.log_info("Received shutdown signal: " + std::to_string(signal));
                    stop();
                }
            });
            
            io_context_.run();
            
        } catch (const std::exception& e) {
            logger_.log_critical("Failed to start server: " + std::string(e.what()));
            throw;
        }
    }
    
    void stop() {
        if (!is_running_.exchange(false)) {
            return;  // 이미 중지됨
        }
        
        try {
            logger_.log_info("Stopping game server...");
            acceptor_.close();
            io_context_.stop();
            logger_.log_info("Game server stopped");
        } catch (const std::exception& e) {
            logger_.log_error("Error stopping server: " + std::string(e.what()));
        }
    }
    
private:
    void start_accept() {
        if (!is_running_) return;
        
        auto socket = std::make_shared<boost::asio::ip::tcp::socket>(io_context_);
        
        acceptor_.async_accept(*socket,
            [this, socket](boost::system::error_code ec) {
                handle_accept(ec, socket);
            });
    }
    
    void handle_accept(boost::system::error_code ec, 
                      std::shared_ptr<boost::asio::ip::tcp::socket> socket) {
        try {
            if (!ec && is_running_) {
                // 새로운 세션 생성
                auto session = std::make_shared<SafeGameSession>(std::move(*socket), logger_);
                session->start();
            } else if (ec) {
                logger_.log_warning("Accept error: " + ec.message());
            }
            
            // 다음 연결 대기
            start_accept();
            
        } catch (const std::exception& e) {
            logger_.log_error("Exception in handle_accept: " + std::string(e.what()));
            start_accept();  // 계속 연결 수락 시도
        }
    }
};
```

### 19.4.2 메모리 누수 방지
메모리 누수를 방지하고 리소스를 안전하게 관리하는 방법을 살펴보겠다.

```cpp
#include <boost/asio.hpp>
#include <memory>
#include <unordered_map>
#include <atomic>
#include <mutex>

// RAII 원칙을 따르는 리소스 관리자
template<typename T>
class ResourceManager {
private:
    std::unordered_map<uint32_t, std::shared_ptr<T>> resources_;
    std::mutex mutex_;
    std::atomic<uint32_t> next_id_;
    
public:
    ResourceManager() : next_id_(1) {}
    
    uint32_t add_resource(std::shared_ptr<T> resource) {
        std::lock_guard<std::mutex> lock(mutex_);
        uint32_t id = next_id_++;
        resources_[id] = resource;
        return id;
    }
    
    std::shared_ptr<T> get_resource(uint32_t id) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = resources_.find(id);
        return (it != resources_.end()) ? it->second : nullptr;
    }
    
    bool remove_resource(uint32_t id) {
        std::lock_guard<std::mutex> lock(mutex_);
        return resources_.erase(id) > 0;
    }
    
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return resources_.size();
    }
    
    void cleanup_expired() {
        std::lock_guard<std::mutex> lock(mutex_);
        for (auto it = resources_.begin(); it != resources_.end();) {
            if (it->second.use_count() <= 1) {  // ResourceManager만 참조
                it = resources_.erase(it);
            } else {
                ++it;
            }
        }
    }
};

// 스마트 포인터를 활용한 안전한 세션 관리
class SessionManager {
private:
    ResourceManager<SafeGameSession> sessions_;
    boost::asio::steady_timer cleanup_timer_;
    GameServerLogger& logger_;
    
public:
    SessionManager(boost::asio::io_context& io_context, GameServerLogger& logger)
        : cleanup_timer_(io_context), logger_(logger) {
        start_cleanup_timer();
    }
    
    uint32_t add_session(std::shared_ptr<SafeGameSession> session) {
        uint32_t id = sessions_.add_resource(session);
        logger_.log_info("Session added: " + std::to_string(id) + 
                        " (Total: " + std::to_string(sessions_.size()) + ")");
        return id;
    }
    
    std::shared_ptr<SafeGameSession> get_session(uint32_t id) {
        return sessions_.get_resource(id);
    }
    
    void remove_session(uint32_t id) {
        if (sessions_.remove_resource(id)) {
            logger_.log_info("Session removed: " + std::to_string(id) + 
                            " (Total: " + std::to_string(sessions_.size()) + ")");
        }
    }
    
    size_t active_sessions() const {
        return sessions_.size();
    }
    
private:
    void start_cleanup_timer() {
        cleanup_timer_.expires_after(std::chrono::minutes(1));
        cleanup_timer_.async_wait([this](boost::system::error_code ec) {
            if (!ec) {
                size_t before = sessions_.size();
                sessions_.cleanup_expired();
                size_t after = sessions_.size();
                
                if (before != after) {
                    logger_.log_info("Cleaned up " + std::to_string(before - after) + 
                                    " expired sessions");
                }
                
                start_cleanup_timer();
            }
        });
    }
};

// 메모리 풀을 사용한 효율적인 버퍼 관리
class BufferPool {
private:
    struct Buffer {
        std::vector<char> data;
        std::atomic<bool> in_use;
        
        Buffer(size_t size) : data(size), in_use(false) {}
    };
    
    std::vector<std::unique_ptr<Buffer>> buffers_;
    std::mutex mutex_;
    size_t buffer_size_;
    size_t max_buffers_;
    
public:
    BufferPool(size_t buffer_size = 1024, size_t max_buffers = 1000)
        : buffer_size_(buffer_size), max_buffers_(max_buffers) {
        
        // 초기 버퍼 할당
        buffers_.reserve(max_buffers_);
        for (size_t i = 0; i < max_buffers_ / 4; ++i) {
            buffers_.push_back(std::make_unique<Buffer>(buffer_size_));
        }
    }
    
    class BufferHandle {
    private:
        BufferPool& pool_;
        Buffer* buffer_;
        
    public:
        BufferHandle(BufferPool& pool, Buffer* buffer) 
            : pool_(pool), buffer_(buffer) {}
        
        ~BufferHandle() {
            if (buffer_) {
                buffer_->in_use = false;
            }
        }
        
        BufferHandle(const BufferHandle&) = delete;
        BufferHandle& operator=(const BufferHandle&) = delete;
        
        BufferHandle(BufferHandle&& other) noexcept 
            : pool_(other.pool_), buffer_(other.buffer_) {
            other.buffer_ = nullptr;
        }
        
        BufferHandle& operator=(BufferHandle&& other) noexcept {
            if (this != &other) {
                if (buffer_) {
                    buffer_->in_use = false;
                }
                buffer_ = other.buffer_;
                other.buffer_ = nullptr;
            }
            return *this;
        }
        
        char* data() { return buffer_ ? buffer_->data.data() : nullptr; }
        size_t size() const { return buffer_ ? buffer_->data.size() : 0; }
    };
    
    BufferHandle acquire_buffer() {
        std::lock_guard<std::mutex> lock(mutex_);
        
        // 사용 가능한 버퍼 찾기
        for (auto& buffer : buffers_) {
            bool expected = false;
            if (buffer->in_use.compare_exchange_weak(expected, true)) {
                return BufferHandle(*this, buffer.get());
            }
        }
        
        // 새 버퍼 생성 (최대 개수 미달시)
        if (buffers_.size() < max_buffers_) {
            auto new_buffer = std::make_unique<Buffer>(buffer_size_);
            new_buffer->in_use = true;
            Buffer* ptr = new_buffer.get();
            buffers_.push_back(std::move(new_buffer));
            return BufferHandle(*this, ptr);
        }
        
        // 버퍼 풀이 가득 참 - 임시 버퍼 생성
        throw std::runtime_error("Buffer pool exhausted");
    }
    
    size_t total_buffers() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return buffers_.size();
    }
    
    size_t available_buffers() const {
        std::lock_guard<std::mutex> lock(mutex_);
        size_t available = 0;
        for (const auto& buffer : buffers_) {
            if (!buffer->in_use) {
                available++;
            }
        }
        return available;
    }
};
```

이번 장에서는 온라인 게임 서버의 보안과 안정성을 확보하는 다양한 기법들을 살펴보았다. SSL/TLS를 통한 암호화 통신, 패킷 무결성 검증, DDoS 방어, 그리고 체계적인 예외 처리와 리소스 관리까지 다루었다. 이러한 보안 조치들은 게임 서버의 신뢰성을 높이고 플레이어들에게 안전한 게임 환경을 제공하는 데 필수적이다.

다음 장에서는 이러한 보안 기능들을 포함한 실제 MMO 게임 서버를 구현해보겠다.


   