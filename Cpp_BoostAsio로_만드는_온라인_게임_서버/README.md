# C++ Boost.Asio로 만드는 온라인 게임 서버
저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상
  
-----

## 📄 01.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 1. 게임 서버 개발 환경 구축
  - 1.1 개발 환경 준비
    - 1.1.1 시스템 요구사항
    - 1.1.2 C++ 표준과 컴파일러 지원
    - 1.1.3 개발 도구 체크리스트
  - 1.2 Boost 라이브러리 설치와 설정
    - 1.2.1 Boost 라이브러리 소개
    - 1.2.2 vcpkg를 이용한 Boost 설치 (권장 방법)
- 적절한 폴더로 이동 (예: C:\dev)
- x64 Windows용 Boost 설치
- 특정 컴포넌트만 설치하는 경우
    - 1.2.3 수동 Boost 빌드 (고급 사용자용)
- Boost 폴더로 이동
- Bootstrap 실행
- Release 버전 빌드
    - 1.2.4 설치 확인
  - 1.3 Visual Studio 2022 설정
    - 1.3.1 프로젝트 설정 템플릿
    - 1.3.2 디버깅 및 개발 도구 설정
  - 1.4 첫 번째 테스트 프로젝트
  - 1.5 문제 해결 가이드

## 📄 02.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 2. Boost.Asio 개요
  - 2.1 Boost.Asio란 무엇인가?
    - 2.1.1 Boost.Asio의 정의와 역할
    - 2.1.2 게임 서버에서 Boost.Asio가 중요한 이유
    - 2.1.3 Boost.Asio의 핵심 개념
    - 2.1.4 기존 네트워킹 방식과의 비교
  - 2.2 멀티플랫폼 지원과 성능
    - 2.2.1 플랫폼별 최적화 구현
      - io_uring 사용하기
        - io_uring을 지원하는 리눅스 커널 버전
        - 조건
        - 예시: CMake 설정
- 또한 liburing 라이브러리를 찾아서 링크
        - 코드 수준 사용
        - 주의사항 및 제한점
        - link
    - 2.2.2 성능 벤치마크와 비교
    - 2.2.3 IPv6 지원과 네트워크 프로토콜
  - 2.3 안정성 보장 패턴
    - 객체 수명 안전성 (Lifetime Safety)
    - 세션 활성 상태 제어 (`std::atomic<bool>`)
    - 타임아웃 기반 세션 종료
    - 비동기 읽기 (Asynchronous Read)
    - 예외 안전성 (Exception Safety)
    - 세션 식별자 제공
    - 요약
  - 2.4 비동기 I/O의 개념과 장점
    - 2.4.1 동기 vs 비동기 I/O 비교
    - 2.4.2 이벤트 기반 프로그래밍 모델
      - 핵심 구성 필드
      - 이벤트 핸들러 정의
      - 이벤트 핸들러 설정 (setup_event_handlers)
      - 게임 루프 구현 (start_game_loop)
      - 비동기 이벤트 큐잉 (post_event)
      - 외부 이벤트 트리거
      - 전체 동작 흐름 요약
      - 장점 요약
    - 2.4.3 비동기 I/O의 성능 이점

## 📄 03.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 3. 동기 방식 네트워크 프로그래밍
  - 3.1 간단한 Echo 서버/클라이언트 구현
    - 3.1.1 Echo 서버란?
    - 3.1.2 동기 방식 TCP Echo 서버 구현
      - `SynchronousEchoServer` 클래스
        - 멤버 변수
        - 생성자
        - `run()` 메소드: 메인 서버 루프
        - `handle_client()` 메소드: 클라이언트 통신 처리
      - `main()` 함수
      - 동작 순서 요약
    - 3.1.3 동기 방식 TCP Echo 클라이언트 구현
      - 헤더 파일 및 전역 변수
      - `SynchronousEchoClient` 클래스
        - 멤버 변수 및 생성자
        - `connect_to_server()` 메소드: 서버 연결
        - `send_and_receive_message()` 메소드: 데이터 송수신
        - `run_...()` 메소드: 두 가지 실행 모드
        - `disconnect()` 메소드: 연결 종료
      - `main()` 함수
      - 동작 순서 요약
    - 3.1.4 실행 및 테스트
- 대화형 모드
- 자동 테스트 모드
  - 3.2 TCP 소켓 프로그래밍 기초
    - 3.2.1 TCP 소켓의 기본 개념
    - 3.2.2 소켓 옵션과 설정
    - 3.2.3 에러 처리와 예외 상황
    - 3.2.4 버퍼 관리와 데이터 처리
      - 🤔 왜 이런 코드가 필요한가? (The Problem)
      - ⚙️ 코드의 동작 방식 (How it Works)
      - `process_stream_data(const std::string& new_data)`
      - `try_extract_packet()`
      - ✨ 핵심 요약
  - 3.3 동기 방식의 특징과 한계
    - 3.3.1 동기 방식의 장점
    - 3.3.2 동기 방식의 한계
    - 3.3.3 게임 서버에서의 동기 방식 한계
      - 1) 실시간성 문제
        - 추가로 고려할 지점
      - 2) 동시 접속자(동접) 수 제한
        - 추가로 고려할 지점
      - 3) 게임 루프와의 충돌
        - 추가로 고려할 지점
      - 동기 방식의 핵심 병목
      - 권장 대응 전략(개선 방향)
        - 아키텍처 전환
        - 실행 모델 최적화
        - 데이터 계층 최적화
        - 운영·관측
      - 결론
  - 3.4 핵심 API 정리
    - 3.4.1 주요 클래스와 네임스페이스
      - 핵심 클래스
      - 버퍼 관련 API
      - 에러 처리 API
    - 3.4.2 동기 I/O 함수 정리
      - 연결 관련 함수
      - 읽기 함수
      - 쓰기 함수
      - 유틸리티 함수
    - 3.4.3 실습 종합 예제
      - 1. 서버 초기화
      - 2. 클라이언트 연결 수락
      - 3. 클라이언트 전용 스레드 실행
      - 4. 클라이언트 처리 (핸들러)
      - 5. 메시지 브로드캐스트
      - 6. 서버 종료
      - 7. 메인 함수
      - 핵심 요약

## 📄 04.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 4. 비동기 I/O 모델 이해
  - 4.1 비동기 I/O의 기본 개념
    - 기본 비동기 패턴
    - 동기 vs 비동기 비교
    - 프로액터 패턴 (Proactor Pattern)
      - `demonstrate_async_concept()`
      - `basic_async_pattern()`
      - `sync_vs_async_comparison()`
      - `simulate_execution_flow()`
  - 4.2 이벤트 기반 프로그래밍
    - 1. 이벤트 루프 (Event Loop) 개념
    - 2. 이벤트 큐와 처리 우선순위
    - 3. 게임 서버 이벤트 모델
      - 이벤트 루프 개념: `event_loop_concept()` → `simulate_event_loop()`
      - 이벤트 큐와 처리: `event_queue_processing()` → `demonstrate_event_priority()`
      - 게임 서버 이벤트 모델: `game_server_event_model()`
      - 메모리·수명·예외에 대한 주의점
      - `post`/`dispatch`/`defer` 차이 요약
      - 멀티스레드 확장과 `strand`
      - 운영 팁
  - 4.3 비동기 작업의 생명주기
    - 1. 작업 요청 (Initiation)
    - 2. 대기 상태 (Pending State)
    - 3. 준비 완료 (Ready State)
    - 4. 실행 (Dispatch & Run)
    - 5. 완료와 정리 (Completion & Cleanup)
    - 6. 반복 / 재스케줄 (Rescheduling)
    - 7. 정리

## 📄 05.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 5. io_context와 이벤트 루프
  - 5.1 io_context의 역할과 구조
    - io_context의 내부 구조
    - io_context의 생명주기
    - run() 계열 함수의 동작 방식
    - 작업 큐와 핸들러 실행 순서
    - 멀티스레드 환경에서의 io_context
    - work 가드와 io_context의 수명 관리
    - restart와 stopped 상태
    - executor와 io_context
    - io_context와 성능 최적화
    - 정리
  - 5.2 멀티스레드와 io_context
    - io_context의 스레드 안전성
    - 멀티스레드 실행 모델
    - 핸들러 동시 실행과 동기화
    - strand를 통한 직렬화
    - 멀티 io_context 패턴
    - 성능 고려사항
- 추가: Socket 객체의 close 함수의 스레드 세이프
  - 1. Boost.Asio의 스레드 세이프 규칙
  - 2. `close()` 함수의 특성
  - 3. 스레드 세이프 보장 여부
  - 4. 안전한 사용 방법
  - 5. 요약
- 추가: 멀티스레드 환경에서 안전한 소켓 종료 패턴
  - 1. 기본 원칙
  - 2. 안전한 종료 패턴
    - (1) strand 직렬화 방식
    - (2) post 방식 (단일 I/O 스레드에 close 위임)
    - (3) cancel과 close 분리
  - 3. 권장 패턴
  - 4. 요약
- 추가: 게임 서버 세션에서 안전한 소켓 종료 패턴
  - 1. 세션 클래스 기본 구조
  - 2. 코드 예제
  - 3. 핵심 포인트
  - 정리

## 📄 06.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 6. 비동기 Echo 서버/클라이언트 구현
  - 6.1 비동기 Echo 서버 구현
    - 비동기 Echo 서버 코드 상세 설명
      - AsyncEchoServer 클래스
      - start_accept() 메서드
      - Session 클래스
      - do_read() 메서드
      - do_write() 메서드
      - 전체 실행 흐름
      - 구체적인 시나리오 예시
      - 메모리 관리 상세
      - 핵심 포인트 정리
  - 6.2 비동기 Echo 클라이언트 구현
    - 비동기 Echo 클라이언트 코드 상세 설명
      - 클래스 멤버 변수 분석
      - 연결 과정: start() 메서드
      - 연결 수립: do_connect() 메서드
      - 메시지 전송: send_message() 메서드
      - 메시지 쓰기: do_write() 메서드
      - 데이터 수신: do_read() 메서드
      - 종료 처리: close() 메서드
      - 메인 프로그램: run_async_echo_client()
      - 전체 흐름도
    - 핵심 설계 패턴 정리
      - 1. 메시지 큐 패턴
      - 2. 스레드 안전성 패턴
      - 3. 버퍼 관리 패턴
      - 4. 독립적인 읽기/쓰기 체인
    - 실행 예시
  - 6.3 성능 비교 및 개선사항
    - 연결 처리 능력 비교
    - 동기 방식의 제약
    - 비동기 방식의 효율성
    - 메모리 사용량 상세 분석
      - 동기 방식의 메모리 구조
      - 비동기 방식의 메모리 구조
    - 실제 시스템 영향
    - 응답 시간 분석
      - 저부하 상황 (10명 동시 접속)
      - 중부하 상황 (100명 동시 접속)
      - 고부하 상황 (1,000명 동시 접속)
      - 극한 부하 상황 (10,000명 동시 접속)
    - C10K 문제와 해결
      - 전통적 접근의 한계
      - 이벤트 기반 해결책
      - 성능 개선 기법
      - 멀티스레드 활용
      - 버퍼 풀 사용
      - Zero-Copy 기법
      - 적합한 상황 선택
        - 동기 방식이 적합한 경우
        - 비동기 방식이 적합한 경우

## 📄 07.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 7. 콜백 함수와 핸들러 관리
  - 콜백 함수의 개념
  - 기본 콜백 패턴
    - 1. 함수 포인터 콜백
    - 2. 멤버 함수 콜백
    - 3. 함수 객체 (Functor) 콜백
  - 람다 표현식 활용
    - 간단한 람다
    - 캡처를 활용한 람다
    - 제네릭 람다 (C++14)
  - 함수 객체와 바인딩 고급 기법
    - std::function 사용
    - boost::bind vs std::bind
    - 커스텀 핸들러의 상태 관리
  - 콜백 체이닝
    - 순차적 체이닝 구현
    - 데이터 전달이 있는 체이닝
  - 콜백 패턴 선택 가이드
  - 객체 생명주기 관리
    - 댕글링 포인터 문제
      - 위험한 패턴
    - shared_ptr을 통한 안전한 관리
      - 기본 패턴
    - enable_shared_from_this의 필수성
  - 참조 카운트 상세 분석
    - 참조 카운트의 변화 추적
  - 실전 패턴: 네트워크 세션
    - weak_ptr와 순환 참조
      - 순환 참조 문제
      - weak_ptr 해결책
      - weak_ptr의 안전한 사용
    - 실전 가이드라인
      - 1. 기본 규칙
      - 2. 참조 선택 가이드
      - 3. 일반적인 실수와 해결책

## 📄 08.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 8. 에러 처리 최적화
  - 비동기 에러의 특성
  - error_code의 구조
  - 기본 에러 처리 패턴
    - 표준 에러 확인
  - 에러 종류별 처리
  - 에러 분류 시스템
  - 재시도 메커니즘
    - 지수 백오프 전략
  - 에러 로깅 시스템
  - 에러 전파 패턴
  - 에러 처리 모범 사례
    - 1. 모든 error_code 확인
    - 2. 에러별 적절한 대응
    - 3. 리소스 정리 보장
    - 4. 에러 로깅 일관성

## 📄 09.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 9. 고급 비동기 기법
  - 9.1 std::shared_ptr을 활용한 세션 관리
    - 9.1.1 스마트 포인터 기반 세션 클래스
      - 핵심 개념 요약
      - 함수별 설명
      - 동작 시나리오(요약)
    - 9.1.2 세션 매니저 구현
    - 9.1.3 RAII 패턴을 활용한 자동 세션 관리
  - 9.2 패킷 처리와 프로토콜 설계
    - 9.2.1 패킷 헤더 정의
    - 9.2.2 패킷 버퍼 클래스
      - 핵심 동작 흐름
      - 주요 메서드 설명
      - 장점
      - 주의사항과 개선 포인트
      - 사용 예시
    - 9.2.3 패킷 처리기 구현
      - 클래스 개요
    - 타입 정의
      - RegisterHandler()
      - ProcessPacket()
      - 처리 절차
      - 설계적 장점
      - 요약
    - 9.2.4 고급 세션 클래스 구현
  - 9.3 에러 처리와 예외 상황 대응
    - 9.3.1 에러 코드 정의와 처리
    - 9.3.2 타임아웃 처리
    - 9.3.3 연결 복구 및 재시도 메커니즘
      - 전체 구조 개요
      - `TimeoutManager` 클래스 설명
      - `SessionWithTimeout` 클래스 설명
      - 동작 순서
      - 동작 예시 흐름
      - 설계적 장점
      - 주의 및 개선 포인트
      - 요약
  - 9.4 성능 최적화 기법
    - 9.4.1 커스텀 메모리 할당자
      - 전체 구조 요약
      - `PoolAllocator` 클래스 상세 분석
      - Boost.Asio와의 연동 — `CustomAllocHandler`
      - 전체 동작 흐름
      - 장점
      - 주의점 및 개선 방향
      - 사용 예시
      - 요약
    - 9.4.2 객체 풀링
    - 9.4.3 논블로킹 큐를 활용한 스레드 간 통신
  - 정리

## 📄 10.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 10. UDP 프로그래밍
  - 10.1 UDP의 특성과 활용
    - 10.1.1 UDP의 기본 특성
    - 10.1.2 게임에서 UDP가 유용한 경우
    - 10.1.3 UDP의 장단점 분석
  - 10.2 비동기 UDP 서버/클라이언트 구현
    - 10.2.1 기본 UDP 서버 구현
      - 동작 흐름
      - 주요 포인트
      - 에러 처리와 경계 조건
      - 최소 구동 예시
    - 10.2.2 게임용 고급 UDP 서버
      - 🔧 전체 구조 개요
      - 📜 코드 흐름 요약
      - 🧩 주요 클래스/멤버 설명
      - 🧠 주요 동작 설명
      - 🕹 코드 흐름 다이어그램
      - 🧭 동작 요약
      - 💡 정리
    - 10.2.3 UDP 클라이언트 구현
      - 📦 전체 개요
      - 🔧 주요 구성 요소
      - ⚙️ 주요 함수별 상세 설명
      - 💡 전체 동작 흐름
      - 🧭 동작 흐름 다이어그램 (머메이드)
      - 🧩 정리
  - 10.3 게임에서의 UDP 활용 사례
    - 10.4.1 실시간 위치 동기화 시스템
    - 10.3.2 게임 이벤트 브로드캐스트 시스템
  - 10.4 신뢰성 있는 UDP 구현
    - 📦 전체 구조 개요
    - 🧩 핵심 개념 정리
      - 1️⃣ `ReliablePacket` 구조체
      - 2️⃣ 신뢰성 전송 (`SendReliable`)
      - 3️⃣ 비신뢰성 전송 (`SendUnreliable`)
      - 4️⃣ 수신 및 ACK 처리
      - 5️⃣ ACK 응답 패킷 전송
      - 6️⃣ 재전송 메커니즘 (`ProcessRetransmissions`)
    - 🔁 순서 및 중복 처리
      - `IsNewPacket(sequence)`
      - `MarkPacketReceived(sequence)`
    - 🧠 전체 동작 요약
    - 🕸 코드 흐름 다이어그램 (Mermaid)
    - 📋 주요 동작 정리표
    - 💡 요약
  - 정리

## 📄 11.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 11. 채팅 서버 구현
  - 11.1 채팅 서버 설계
    - 11.1.1 아키텍처 설계
    - 11.1.2 기본 클래스 구조 설계
    - 11.1.3 메시지 처리 시스템 설계
      - 전체 구조 개요
      - IMessageHandler – 메시지 처리 인터페이스
      - MessageDispatcher – 메시지 디스패처
      - 주요 역할
      - 동작 시퀀스 다이어그램 (Mermaid)
      - LoginHandler – 로그인 메시지 처리기
      - ChatMessageHandler – 채팅 메시지 처리기
      - 구조적 특징 및 장점
      - 실제 사용 예시
  - 11.2 멀티 클라이언트 관리
    - 11.2.1 세션 관리자 구현
    - 11.2.2 사용자 관리자 구현
    - 11.2.3 연결 풀링과 리소스 관리
  - 11.3 브로드캐스팅과 메시지 라우팅
    - 11.3.1 채팅방 구현
    - 11.3.2 채팅방 관리자 구현
    - 11.3.3 메시지 라우팅 시스템
    - 11.3.4 메시지 필터링 시스템
  - 11.4 세션 관리와 리소스 정리
    - 11.4.1 세션 구현
      - 클래스 개요
      - 생성자 및 소멸자
      - 3. Start() – 세션 시작
      - 4. DoRead() – 비동기 읽기 루프
      - DoWrite() – 비동기 쓰기 처리
      - SendMessage() – 송신 요청 API
      - Disconnect() – 연결 종료 및 리소스 정리
      - ProcessPacket() – 패킷 처리 및 디스패치
      - 전체 흐름 요약
      - 구조적 장점
    - 11.4.2 리소스 정리 시스템
    - 7.4.3 완전한 채팅 서버 구현
  - 정리

## 📄 12.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 12. 멀티스레드와 동시성
  - 12.1 WorkerThread 패턴 구현
    - 12.1.1 기본 WorkerThread 클래스
      - 전체 개요
      - 다이어그램
      - 클래스 멤버 구성
      - Start() – 스레드 시작
      - Stop() – 스레드 종료 및 정리
      - PostTask() – 비동기 작업 추가
      - PostTaskAndWait() – 동기적 작업 실행
      - WorkerLoop() – 핵심 스레드 루프
      - 시퀀스 다이어그램
      - 스레드 동기화 메커니즘
      - WorkerThread 사용 예시
      - 설계적 장점
      - 요약
    - 12.1.2 게임 로직 처리용 WorkerThread
    - 12.1.3 데이터베이스 워커 스레드
      - 클래스 구조 개요
      - 주요 구성 요소
      - 생성자 및 소멸자
      - ExecuteQuery() – 단일 쿼리 실행
      - ExecuteTransaction() – 트랜잭션 실행
      - 트랜잭션 실행 시퀀스 다이어그램
      - SavePlayerData() – 플레이어 데이터 저장
      - LoadPlayerData() – 플레이어 데이터 로드
      - ExecuteDatabaseQuery() – 비동기 쿼리 실행기
      - ExecuteDatabaseQuerySync() – 동기 쿼리 실행 (시뮬레이션)
      - 트랜잭션 유틸리티
      - GetQueryTypeName()
      - 전체 동작 흐름
      - 흐름 요약
      - 설계상의 특징 및 장점
      - 예시 실행 결과
      - 요약
  - 12.2 io_context의 멀티스레드 활용
    - 12.2.1 기본 멀티스레드 io_context 사용
      - 전체 구조 개요
      - io_context와 스레드의 관계
      - work_guard의 역할
      - Start() 함수의 동작
      - StartAccept()의 동작
      - Session 클래스의 역할
      - Stop()과 종료 처리
      - 멀티스레드 동작 예시 로그
      - 요약
    - 12.2.2 io_context 풀 관리
      - 전체 개요
      - IOContextPool의 구조
    - 클래스 구성도
      - 3. io_context 생성과 유지
      - io_context 실행 (`Start()`)
      - io_context 선택 (Load Balancing)
      - PooledServer 클래스의 구조
      - StartAccept() — 연결 수락과 분배
      - PooledSession — 독립적인 I/O 처리
      - Stop() — 안전한 종료
      - 단일 io_context 멀티스레드 vs io_context 풀 비교
      - 정리
  - 12.3 Strand를 이용한 동기화
    - 핵심 개념 요약
    - 왜 필요한가?
    - 동작 원리
    - 기본 사용법
      - strand 생성
      - strand를 이용한 안전한 작업 실행
    - 비동기 핸들러 내에서 strand 사용
    - strand의 사용 시점 정리
    - 정리
    - 12.3.1 기본 Strand 사용법
    - 12.3.2 게임 오브젝트 동기화를 위한 Strand 활용
    - 12.3.3 이벤트 시스템과 Strand 조합
  - 12.4 스레드 풀과 작업 분산
    - 12.4.1 커스텀 스레드 풀 구현
    - 12.4.2 작업 부하 분산 시스템
      - 전체 개요
      - 주요 구성 요소
      - LoadBalancer의 핵심 데이터 구조
      - WorkerStats 구조체
      - 동작 흐름 요약
      - 생성자: 워커 생성 및 통계 스레드 시작
      - 실행 흐름
      - SubmitTask() — 작업 제출과 처리
      - SelectBestWorker() — 부하 기반 선택 로직
      - CalculateWorkerLoad() — 부하 계산식
      - UpdateWorkerStats() — 처리 시간 갱신
  - 11. UpdateStatsLoop() — 워커 상태 감시 루프
      - 전체 구조 다이어그램
      - 예시 시나리오
      - 장단점 정리
      - 요약
    - 12.4.3 게임 서버용 통합 스레드 관리 시스템
  - 정리

## 📄 13.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 13. 타이머와 스케줄링
  - 13.1 기본 타이머 사용법
    - 13.1.1 steady_timer 기본 사용법
    - 13.1.2 다양한 타이머 종류
    - 13.1.3 타이머 오차 측정 및 보정
  - 13.2 반복 타이머 구현
    - 13.2.1 기본 반복 타이머
    - 13.2.2 정밀한 간격 유지를 위한 개선된 반복 타이머
    - 13.2.3 적응형 타이머 (서버 부하에 따른 조절)
  - 13.3 타이머 취소와 관리
    - 13.3.1 타이머 관리자 클래스
    - 13.3.2 타이머 그룹 관리
    - 13.3.3 타이머 풀링과 재사용
  - 13.4 게임 로직 스케줄링
    - 13.4.1 게임 틱 시스템
    - 13.4.2 이벤트 스케줄러
    - 13.4.3 게임 서버 통합 스케줄링 시스템
  - 정리

## 📄 14.md
- C++ Boost.Asio로 만드는 온라인 게임 서버
- Chapter 14. 코루틴 활용
  - 14.1 C++20 코루틴 개요
    - 14.1.1 코루틴 기본 개념
    - 14.1.2 Task 코루틴 구현
    - 14.1.3 Awaitable 객체 구현
  - 14.2 Boost.Asio의 spawn 기능
    - 14.2.1 Boost.Asio spawn 기본 사용법
      - 코드의 목적
      - 주요 구성요소
      - 실행 흐름 요약
      - 흐름을 다이어그램으로 표현
      - 코루틴 흐름
      - 주요 함수별 상세 설명
      - spawn()과 yield()의 개념적 관계
      - 비동기 → 코루틴 변환의 효과
      - 실행 결과 예시
      - 요약
    - 14.2.2 HTTP 클라이언트 코루틴 구현
  - 14.3 코루틴을 활용한 서버 구현
    - 14.3.1 게임 세션 코루틴
      - 전체 구조 개요
      - 전체 실행 흐름 요약
      - ASCII 다이어그램 — 코루틴 간 흐름
      - 시퀀스 다이어그램
      - 주요 컴포넌트별 설명
      - 코루틴 모델의 장점
      - 실행 예시 로그
      - 요약
  - 14.4 코루틴 기반 타임아웃 처리
    - 14.4.1 타임아웃 래퍼 클래스
    - 14.4.2 네트워크 작업 타임아웃
    - 14.4.3 게임 로직 타임아웃 처리
  - 정리

## 📄 15.md
- workingBooks
- Chapter 15. 메모리 최적화
  - 15.1 커스텀 할당자 구현
    - 15.1.1 메모리 풀 기반 할당자
    - 15.1.2 스택 할당자 구현
      - 스택 기반 메모리 할당자의 개념
      - 전체 구조 요약
      - 메모리 다이어그램
      - `StackAllocator`
      - `StackMarker`
      - `StackAllocatorAdapter<T>`
      - 동작 흐름
      - 실행 예시 출력
      - 성능 및 사용 사례
      - 확장 아이디어
      - 요약
    - 15.1.3 슬랩 할당자 (Slab Allocator)
  - 15.2 핸들러 메모리 풀링
    - 15.2.1 Boost.Asio 핸들러 최적화
    - 15.2.2 세션별 핸들러 풀링
  - 15.3 버퍼 관리 최적화
    - 15.3.1 순환 버퍼 구현
    - 15.3.2 버퍼 풀 관리
  - 15.4 메모리 누수 방지
    - 15.4.1 스마트 포인터 활용
    - 15.4.2 메모리 추적 시스템
    - 15.4.3 약한 참조 기반 관찰자 패턴
  - 정리

## 📄 16.md
- workingBooks
- Chapter 16. 고성능 서버 기법
  - 16.1 패킷 버퍼링과 배치 처리
    - 16.1.1 패킷 버퍼링 시스템
    - 16.1.2 네트워크 송신 최적화
      - 전체 개요
      - `NetworkSendBuffer` 클래스 구조
      - `OptimizedSession` 클래스 구조
    - 주요 멤버
      - 주기적 Flush 메커니즘 (`StartFlushTimer`)
      - 수신 및 에코 테스트 동작
      - 성능상의 장점
      - 개선 여지
      - 요약
    - 16.1.3 패킷 압축 및 집약
  - 16.2 연결 풀링과 재사용
    - 16.2.1 연결 풀 관리자
    - 16.2.2 세션 재사용 풀
  - 16.3 논블로킹 I/O 최적화
    - 16.3.1 이벤트 기반 I/O 처리
  - 16.4 성능 모니터링과 프로파일링
    - 16.4.1 성능 메트릭 수집
    - 16.4.2 시스템 리소스 모니터링
    - 16.4.3 통합 성능 모니터링 시스템
  - 정리

## 📄 17.md
- workingBooks
- Chapter 17. 확장 가능한 서버 설계
  - 17.1 로드 밸런싱과 클러스터링
    - 17.1.1 로드 밸런서 구현
    - 17.2.2 서버 클러스터 관리
  - 17.2 데이터베이스 연동
    - 17.2.1 데이터베이스 연결 풀과 ORM
  - 17.3 Redis와 캐시 시스템 연동
    - 17.3.1 Redis 클라이언트 구현
  - 정리

## 📄 18.md
- workingBooks
- Chapter 18. 프로토콜 설계와 직렬화
  - 18.1 게임 프로토콜 설계 원칙
    - 18.1.1 프로토콜 설계 기본 원칙
    - 19.1.2 패킷 압축과 최적화
  - 18.2 고정 길이 패킷 처리
    - 18.2.1 고정 길이 패킷 설계
    - 18.2.2 고정 길이 패킷 최적화
  - 18.3 커스텀 직렬화 구현
    - 18.3.1 고성능 바이너리 직렬화
  - 정리

## 📄 19.md
- workingBooks
- Chapter 19. 보안과 안정성
  - 19.1 네트워크 보안 기본
    - 19.1.1 게임 서버 보안 위협 요소
    - 19.1.2 SSL/TLS 적용
    - 19.1.3 클라이언트 인증 시스템
  - 19.2 패킷 암호화
    - 19.2.1 대칭키 암호화 구현
    - 19.2.2 메시지 무결성 검증
  - 19.3 DDoS 방어 기법
    - 19.3.1 연결 속도 제한
    - 19.3.2 SYN Flood 방어
  - 19.4 서버 안정성 확보
    - 19.4.1 예외 처리와 로깅
    - 19.4.2 메모리 누수 방지

## 📄 20.md
- workingBooks
- Chapter 20. MMO 게임 서버 구현
  - 20.1 MMO 서버 아키텍처 설계
    - 20.1.1 분산 서버 아키텍처
    - 20.1.2 로드 밸런싱과 서버 선택
  - 20.2 존 시스템과 플레이어 관리
    - 20.2.1 월드 분할과 존 관리
    - 20.2.2 플레이어 세션 관리
  - 20.3 실시간 동기화 구현 - 위치 동기화 시스템
    - 🧩 전체 구조 개요
    - 1️⃣ `PositionUpdate` — 위치 업데이트 단위 구조체
    - 2️⃣ `PositionHistory` — 보간 및 예측을 위한 히스토리 관리
      - 주요 역할
      - 🧱 2.1 업데이트 추가 (`add_update`)
      - 🌈 2.2 위치 보간 (`interpolate_position`)
      - 🚀 2.3 위치 예측 (`extrapolate_position`)
    - 3️⃣ `SynchronizationManager` — 객체 단위 동기화 관리
      - ⚙️ 주요 메서드
    - 4️⃣ `RealtimeSyncService` — 실시간 동기화 서비스 루프
      - 구조
      - 루프 동작 다이어그램
    - 🔄 데이터 흐름 요약
    - 📘 정리
    - 💡 핵심 개념 요약
  - 20.4 실시간 동기화 구현 -  이벤트 동기화
  - 20.5 서버 간 메시징 시스템
  - 20.6 분산 데이터베이스 연동

## 📄 21.md
- workingBooks
- Chapter 21. 모바일 게임 서버 구현
  - 21.1 모바일 환경의 특성
    - 21.1.1 네트워크 연결의 불안정성
    - 21.1.2 배터리 효율성 고려
    - 21.1.3 다양한 디바이스 성능
  - 21.2 HTTP/HTTPS 서버 구현
    - 21.2.1 기본 HTTP 서버 구현
    - 21.2.2 HTTPS 서버 구현
  - 21.3 RESTful API 설계
    - 21.3.1 API 라우터 구현
    - 21.3.2 API 서버 통합
  - 21.4 푸시 알림 시스템
    - 21.4.1 FCM(Firebase Cloud Messaging) 클라이언트 구현
    - 21.4.2 푸시 알림 스케줄러
    - 21.4.3 푸시 알림 관리 API

## 📄 99_부록.md
- workingBooks
- 부록
  - A. Boost.Asio API 레퍼런스
    - A.1 핵심 클래스 레퍼런스
      - io_context 클래스
      - ip::tcp 네임스페이스
      - 타이머 클래스
      - 버퍼 관련 함수들
    - A.2 에러 처리
    - A.3 코루틴 지원 (C++20)
  - B. 에러 코드와 해결 방법
    - B.1 일반적인 네트워크 에러
      - 연결 관련 에러
      - 읽기/쓰기 에러
    - B.2 플랫폼별 에러 처리
      - Windows 특화 에러
      - Linux 특화 에러
    - B.3 에러 복구 전략
  - C. 성능 측정 도구와 방법
    - C.1 내장 성능 측정 도구
      - 연결 및 처리량 측정
      - 지연 시간 측정
    - C.2 메모리 사용량 모니터링
    - C.3 종합 성능 모니터링 시스템
    - C.4 성능 테스트 도구
  - D. 참고 자료와 링크
    - D.1 공식 문서 및 자료
      - Boost.Asio 공식 문서
      - Boost 라이브러리 전체
      - C++ 표준 및 문서
    - D.2 게임 서버 개발 관련 자료
      - 네트워킹 및 서버 아키텍처
      - 게임 개발 커뮤니티
    - D.3 도구 및 라이브러리
      - 개발 도구
      - 디버깅 및 프로파일링
      - 유용한 C++ 라이브러리
    - D.4 학습 자료
      - 온라인 강의 및 튜토리얼
      - 추천 도서
    - D.5 커뮤니티 및 포럼
      - 기술 커뮤니티
      - 한국 커뮤니티
    - D.6 오픈소스 프로젝트
      - 참고할 만한 게임 서버 프로젝트
    - D.7 성능 최적화 자료
      - 성능 측정 및 최적화
      - 메모리 관리
    - D.8 보안 관련 자료
      - 네트워크 보안
    - D.9 최신 동향 및 뉴스
      - 기술 블로그 및 뉴스
