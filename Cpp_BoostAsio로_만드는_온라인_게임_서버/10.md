# C++ Boost.Asioë¡œ ë§Œë“œëŠ” ì˜¨ë¼ì¸ ê²Œì„ ì„œë²„
ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----   

# Chapter 10. UDP í”„ë¡œê·¸ë˜ë°
UDP(User Datagram Protocol)ëŠ” ì‹¤ì‹œê°„ ê²Œì„ì—ì„œ ë¹ ë¥¸ ì‘ë‹µì„±ì´ í•„ìš”í•œ ìƒí™©ì— ìµœì í™”ëœ í”„ë¡œí† ì½œì´ë‹¤. ì´ë²ˆ ì¥ì—ì„œëŠ” Boost.Asioë¥¼ í™œìš©í•˜ì—¬ UDP ê¸°ë°˜ì˜ ê²Œì„ ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•œë‹¤.

## 10.1 UDPì˜ íŠ¹ì„±ê³¼ í™œìš©

### 10.1.1 UDPì˜ ê¸°ë³¸ íŠ¹ì„±
UDPëŠ” TCPì™€ ë‹¬ë¦¬ ì—°ê²° ì—†ëŠ”(connectionless) í”„ë¡œí† ì½œë¡œ, ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì„±ì„ ê°€ì§„ë‹¤:

```cpp
/*
UDP íŠ¹ì„± ì •ë¦¬:
1. ë¹„ì—°ê²°ì„±(Connectionless): ì—°ê²° ì„¤ì •/í•´ì œ ê³¼ì •ì´ ì—†ìŒ
2. ë¹„ì‹ ë¢°ì„±(Unreliable): íŒ¨í‚· ì „ë‹¬ ë³´ì¥ ì•ˆ ë¨
3. ìˆœì„œ ë³´ì¥ ì•ˆ ë¨: íŒ¨í‚· ë„ì°© ìˆœì„œê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
4. ë¹ ë¥¸ ì „ì†¡: ì˜¤ë²„í—¤ë“œê°€ ì ì–´ ì†ë„ê°€ ë¹ ë¦„
5. ë¸Œë¡œë“œìºìŠ¤íŠ¸/ë©€í‹°ìºìŠ¤íŠ¸ ì§€ì›
*/

#include <boost/asio.hpp>
#include <iostream>
#include <string>

using boost::asio::ip::udp;
```

### 10.1.2 ê²Œì„ì—ì„œ UDPê°€ ìœ ìš©í•œ ê²½ìš°

```cpp
// ê²Œì„ì—ì„œ UDPë¥¼ ì‚¬ìš©í•˜ëŠ” ì£¼ìš” ì‚¬ë¡€ë“¤
enum class GameDataType
{
    PLAYER_POSITION,    // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì •ë³´
    ANIMATION_STATE,    // ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ
    PROJECTILE_DATA,    // ë°œì‚¬ì²´ ì •ë³´
    VOICE_CHAT,         // ìŒì„± ì±„íŒ…
    HEARTBEAT,          // ì—°ê²° ìƒíƒœ í™•ì¸
    BROADCAST_MESSAGE   // ë¸Œë¡œë“œìºìŠ¤íŠ¸ ë©”ì‹œì§€
};

struct PlayerPosition
{
    uint32_t player_id;
    float x, y, z;
    float rotation;
    uint32_t timestamp;
};

struct GamePacket
{
    GameDataType type;
    uint32_t sequence_number;
    uint32_t data_size;
    // ê°€ë³€ ê¸¸ì´ ë°ì´í„°ê°€ ë’¤ë”°ë¦„
};
```

### 10.1.3 UDPì˜ ì¥ë‹¨ì  ë¶„ì„

```cpp
class UDPAnalysis
{
public:
    static void PrintAdvantages()
    {
        std::cout << "UDP ì¥ì :\n";
        std::cout << "1. ë‚®ì€ ì§€ì—°ì‹œê°„ (Low Latency)\n";
        std::cout << "2. ì ì€ ë„¤íŠ¸ì›Œí¬ ì˜¤ë²„í—¤ë“œ\n";
        std::cout << "3. ë¸Œë¡œë“œìºìŠ¤íŠ¸/ë©€í‹°ìºìŠ¤íŠ¸ ì§€ì›\n";
        std::cout << "4. ì‹¤ì‹œê°„ ë°ì´í„° ì „ì†¡ì— ì í•©\n";
        std::cout << "5. ì„œë²„ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ì ìŒ\n\n";
    }
    
    static void PrintDisadvantages()
    {
        std::cout << "UDP ë‹¨ì :\n";
        std::cout << "1. íŒ¨í‚· ì†ì‹¤ ê°€ëŠ¥ì„±\n";
        std::cout << "2. ìˆœì„œ ë³´ì¥ ì•ˆ ë¨\n";
        std::cout << "3. ì¤‘ë³µ íŒ¨í‚· ê°€ëŠ¥ì„±\n";
        std::cout << "4. íë¦„ ì œì–´ ì—†ìŒ\n";
        std::cout << "5. ì‹ ë¢°ì„± í™•ë³´ë¥¼ ìœ„í•œ ì¶”ê°€ êµ¬í˜„ í•„ìš”\n\n";
    }
};
```
  
</br>  

## 10.2 ë¹„ë™ê¸° UDP ì„œë²„/í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„

### 10.2.1 ê¸°ë³¸ UDP ì„œë²„ êµ¬í˜„

```cpp
#include <boost/asio.hpp>
#include <boost/bind/bind.hpp>
#include <memory>
#include <iostream>
#include <array>

using boost::asio::ip::udp;

class UDPServer
{
public:
    UDPServer(boost::asio::io_context& io_context, short port)
        : socket_(io_context, udp::endpoint(udp::v4(), port))
    {
        StartReceive();
    }

private:
    void StartReceive()
    {
        socket_.async_receive_from(
            boost::asio::buffer(recv_buffer_), remote_endpoint_,
            boost::bind(&UDPServer::HandleReceive, this,
                boost::asio::placeholders::error,
                boost::asio::placeholders::bytes_transferred));
    }

    void HandleReceive(const boost::system::error_code& error,
                      std::size_t bytes_transferred)
    {
        if (!error)
        {
            // ë°›ì€ ë°ì´í„° ì²˜ë¦¬
            ProcessReceivedData(bytes_transferred);
            
            // Echo ì‘ë‹µ ì „ì†¡
            std::shared_ptr<std::string> message = 
                std::make_shared<std::string>("Echo: ");
            message->append(recv_buffer_.data(), bytes_transferred);

            socket_.async_send_to(
                boost::asio::buffer(*message), remote_endpoint_,
                boost::bind(&UDPServer::HandleSend, this, message,
                    boost::asio::placeholders::error,
                    boost::asio::placeholders::bytes_transferred));
        }
        else
        {
            std::cerr << "Receive error: " << error.message() << std::endl;
        }

        StartReceive();
    }

    void HandleSend(std::shared_ptr<std::string> message,
                   const boost::system::error_code& error,
                   std::size_t bytes_transferred)
    {
        if (error)
        {
            std::cerr << "Send error: " << error.message() << std::endl;
        }
        else
        {
            std::cout << "Sent " << bytes_transferred << " bytes" << std::endl;
        }
    }

    void ProcessReceivedData(std::size_t bytes_transferred)
    {
        std::cout << "Received from " << remote_endpoint_ << ": ";
        std::cout.write(recv_buffer_.data(), bytes_transferred);
        std::cout << std::endl;
    }

    udp::socket socket_;
    udp::endpoint remote_endpoint_;
    std::array<char, 1024> recv_buffer_;
};
```   

ìœ„ ì½”ë“œëŠ” Boost.Asioë¡œ UDP ì—ì½” ì„œë²„ë¥¼ ë¹„ë™ê¸°(Async) ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•œ ì˜ˆì‹œë‹¤. í•µì‹¬ì€ `async_receive_from`ìœ¼ë¡œ íŒ¨í‚·ì„ ë°›ì•„ ì²˜ë¦¬í•˜ê³ , ê°™ì€ ì†¡ì‹ ìì—ê²Œ `async_send_to`ë¡œ â€œEcho: â€¦â€ ì‘ë‹µì„ ë³´ë‚¸ ë’¤, ë‹¤ì‹œ ìˆ˜ì‹ ì„ ì¬ê°œí•˜ëŠ” ë£¨í”„ë¥¼ ë§Œë“œëŠ” ê²ƒì´ë‹¤.

#### ë™ì‘ íë¦„
1. **ìƒì„±ì**
   `udp::socket socket_(io_context, udp::endpoint(udp::v4(), port))`ë¡œ IPv4/`port`ì— ë°”ì¸ë”©í•œ ì†Œì¼“ì„ ì—°ë‹¤. ì´í›„ `StartReceive()`ë¥¼ í˜¸ì¶œí•´ ì²« ìˆ˜ì‹ ì„ ê±¸ì–´ë‘”ë‹¤.

2. **ìˆ˜ì‹  ì‹œì‘ â€“ `StartReceive()`**
   `socket_.async_receive_from(buffer(recv_buffer_), remote_endpoint_, HandleReceive)`ë¥¼ í˜¸ì¶œí•œë‹¤.

   * ìˆ˜ì‹ ëœ ë°ì´í„°ëŠ” `recv_buffer_`ì— ë“¤ì–´ê°€ê³ , ì†¡ì‹ ìì˜ ì£¼ì†ŒëŠ” `remote_endpoint_`ë¡œ ì±„ì›Œì§„ë‹¤.
   * ì‘ì—…ì´ ì™„ë£Œë˜ë©´ `HandleReceive(error, bytes_transferred)`ê°€ í˜¸ì¶œëœë‹¤.

3. **ìˆ˜ì‹  ì™„ë£Œ ì²˜ë¦¬ â€“ `HandleReceive()`**

   * ì—ëŸ¬ê°€ ì—†ìœ¼ë©´ `ProcessReceivedData(bytes_transferred)`ë¡œ ë°ì´í„°ë¥¼ ì¶œë ¥í•œë‹¤.
   * ì´ì–´ì„œ ì‘ë‹µ ë©”ì‹œì§€ `"Echo: " + ìˆ˜ì‹ ë°ì´í„°`ë¥¼ ë§Œë“¤ì–´ `async_send_to(..., HandleSend)`ë¡œ ë³´ë‚¸ë‹¤.
   * ë§ˆì§€ë§‰ì— **í•­ìƒ** `StartReceive()`ë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•´ ë‹¤ìŒ íŒ¨í‚·ì„ ê¸°ë‹¤ë¦°ë‹¤. ì´ë¡œì¨ ëŠì„ì—†ëŠ” ìˆ˜ì‹  ë£¨í”„ê°€ ìœ ì§€ëœë‹¤.

4. **ì†¡ì‹  ì™„ë£Œ ì²˜ë¦¬ â€“ `HandleSend()`**

   * ì—ëŸ¬ê°€ ìˆìœ¼ë©´ ë¡œê·¸ë§Œ ì°ê³ , ì—†ìœ¼ë©´ ì „ì†¡ ë°”ì´íŠ¸ ìˆ˜ë¥¼ ì¶œë ¥í•œë‹¤.

#### ì£¼ìš” í¬ì¸íŠ¸
* **ë¹„ë™ê¸° I/O**: ëª¨ë“  ë„¤íŠ¸ì›Œí¬ I/Oê°€ ì½œë°± ê¸°ë°˜ìœ¼ë¡œ ì´ë£¨ì–´ì§€ë¯€ë¡œ, `io_context.run()`ì´ ëŒê³  ìˆëŠ” ìŠ¤ë ˆë“œê°€ ì½œë°±ì„ ì‹¤í–‰í•œë‹¤. ë©”ì¸ì—ì„œ `io_context.run()`ì„ í˜¸ì¶œí•´ì•¼ ì‹¤ì œë¡œ ë™ì‘í•œë‹¤.
* **ì—”ë“œí¬ì¸íŠ¸ ìº¡ì²˜**: `async_receive_from`ê°€ ì™„ë£Œë˜ë©´ `remote_endpoint_`ì— ë°œì‹ ìì˜ IP:Portê°€ ë“¤ì–´ê°€ë©°, ì´ë¥¼ ê·¸ëŒ€ë¡œ `async_send_to`ì˜ ëŒ€ìƒ ì£¼ì†Œë¡œ ì‚¬ìš©í•œë‹¤.
* **ë²„í¼ ê´€ë¦¬**: `recv_buffer_`ëŠ” í´ë˜ìŠ¤ ë©¤ë²„ `std::array<char,1024>`ë¼ì„œ ë¹„ë™ê¸° ì‘ì—… ë™ì•ˆ ì•ˆì „í•˜ê²Œ ì‚´ì•„ìˆë‹¤. ì—ì½” ë©”ì‹œì§€ ìƒì„± ì‹œ `append(recv_buffer_.data(), bytes_transferred)`ë¡œ **ì‹¤ì œ ìˆ˜ì‹  ê¸¸ì´ë§Œ** ë¶™ì—¬ì„œ ì“°ë ˆê¸° ë°ì´í„°ê°€ ë’¤ì„ì´ëŠ” ê²ƒì„ ë°©ì§€í•œë‹¤.
* **ë©”ì‹œì§€ ìˆ˜ëª… ë³´ì¥**: `async_send_to`ê°€ ëë‚  ë•Œê¹Œì§€ ì†¡ì‹  ë²„í¼ê°€ ì‚´ì•„ìˆì–´ì•¼ í•˜ë¯€ë¡œ `std::shared_ptr<std::string> message`ë¥¼ ë§Œë“¤ì–´ í•¸ë“¤ëŸ¬ ì¸ìë¡œ ë„˜ê¸´ë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì „ì†¡ ì™„ë£Œ ì½œë°±ê¹Œì§€ ë©”ì‹œì§€ê°€ ìœ ì§€ëœë‹¤.

#### ì—ëŸ¬ ì²˜ë¦¬ì™€ ê²½ê³„ ì¡°ê±´
* **ìˆ˜ì‹ /ì†¡ì‹  ì—ëŸ¬**: ê°ê° ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ë£¨í”„ëŠ” ê³„ì† ëˆë‹¤. ì‹¤ì œ ì„œë²„ë¼ë©´ íŠ¹ì • ì—ëŸ¬(ì˜ˆ: `operation_aborted`)ì— ëŒ€í•´ ì¬ì‹œë„ ì¤‘ë‹¨ ë“±ì˜ ì •ì±…ì„ ë‘˜ ìˆ˜ ìˆë‹¤.
* **íŒ¨í‚· í¬ê¸°**: `recv_buffer_`ëŠ” 1024ë°”ì´íŠ¸ ê³ ì •ì´ë¼ ì´ˆê³¼ ë°ì´í„°ëŠ” ì˜ë¦´ ìˆ˜ ìˆë‹¤. MTU/í‰ê·  íŒ¨í‚· í¬ê¸°ì— ë§ì¶° ì¡°ì •í•˜ê±°ë‚˜, í•„ìš” ì‹œ ë” í° ë²„í¼/ë™ì  ë²„í¼ë¥¼ ê³ ë ¤í•´ì•¼ í•œë‹¤.
* **ë™ì‹œì„±**: í˜„ì¬ êµ¬í˜„ì€ í•œ ë²ˆì— **í•˜ë‚˜ì˜ ìˆ˜ì‹ **ë§Œ ëŒ€ê¸°í•œë‹¤. `io_context`ë¥¼ ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ëŒë¦´ ìˆ˜ëŠ” ìˆì§€ë§Œ, ê°™ì€ ì†Œì¼“ì— ëŒ€í•´ ë™ì‹œ `async_receive_from` í˜¸ì¶œì„ ëŠ˜ë¦¬ë ¤ë©´ ì£¼ì˜ê°€ í•„ìš”í•˜ë‹¤. ë‹¤ì¤‘ ìŠ¤ë ˆë“œ ìš´ìš© ì‹œì—ëŠ” `strand` ì‚¬ìš©ìœ¼ë¡œ í•¸ë“¤ëŸ¬ ì§ë ¬í™”ê°€ ìœ ìš©í•˜ë‹¤.
* **ê°ì²´ ìˆ˜ëª…**: í•¸ë“¤ëŸ¬ì—ì„œ `this`ë¥¼ ìƒ í¬ì¸í„°ë¡œ ë°”ì¸ë”©í•˜ê³  ìˆë‹¤. ì„œë²„ ê°ì²´ê°€ ì™¸ë¶€ì—ì„œ íŒŒê´´ë˜ë©´ UAF ìœ„í—˜ì´ ìƒê¸´ë‹¤. ì¼ë°˜ì ìœ¼ë¡œ `std::enable_shared_from_this`ë¥¼ ìƒì†í•˜ê³ , í•¸ë“¤ëŸ¬ì— `shared_from_this()`ë¥¼ ìº¡ì²˜í•˜ëŠ” íŒ¨í„´ì´ ì•ˆì „í•˜ë‹¤.

#### ìµœì†Œ êµ¬ë™ ì˜ˆì‹œ
ì‹¤í–‰ì„ ìœ„í•´ì„œëŠ” ì•„ë˜ì™€ ê°™ì´ `main`ì—ì„œ `io_context.run()`ì„ í˜¸ì¶œí•´ì•¼ í•œë‹¤.

```cpp
int main() {
    try {
        boost::asio::io_context io;
        auto server = std::make_shared<UDPServer>(io, 9000);
        io.run();
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
}
```
  

### 10.2.2 ê²Œì„ìš© ê³ ê¸‰ UDP ì„œë²„

```cpp
class GameUDPServer
{
public:
    GameUDPServer(boost::asio::io_context& io_context, short port)
        : socket_(io_context, udp::endpoint(udp::v4(), port)),
          sequence_number_(0)
    {
        StartReceive();
        StartHeartbeat();
    }

    void BroadcastToAllClients(const std::string& message)
    {
        std::lock_guard<std::mutex> lock(clients_mutex_);
        for (const auto& client : active_clients_)
        {
            SendToClient(client.second, message);
        }
    }

private:
    struct ClientInfo
    {
        udp::endpoint endpoint;
        std::chrono::steady_clock::time_point last_seen;
        uint32_t last_sequence;
    };

    void StartReceive()
    {
        socket_.async_receive_from(
            boost::asio::buffer(recv_buffer_), remote_endpoint_,
            [this](const boost::system::error_code& error, std::size_t bytes)
            {
                if (!error)
                {
                    HandleClientMessage(bytes);
                }
                StartReceive();
            });
    }

    void HandleClientMessage(std::size_t bytes_transferred)
    {
        if (bytes_transferred < sizeof(GamePacket))
            return;

        auto packet = reinterpret_cast<const GamePacket*>(recv_buffer_.data());
        
        // í´ë¼ì´ì–¸íŠ¸ ì •ë³´ ì—…ë°ì´íŠ¸
        UpdateClientInfo(remote_endpoint_, packet->sequence_number);
        
        // íŒ¨í‚· íƒ€ì…ë³„ ì²˜ë¦¬
        ProcessGamePacket(packet, bytes_transferred);
    }

    void UpdateClientInfo(const udp::endpoint& endpoint, uint32_t sequence)
    {
        std::lock_guard<std::mutex> lock(clients_mutex_);
        
        std::string client_key = endpoint.address().to_string() + 
                                ":" + std::to_string(endpoint.port());
        
        auto& client = active_clients_[client_key];
        client.endpoint = endpoint;
        client.last_seen = std::chrono::steady_clock::now();
        client.last_sequence = sequence;
    }

    void ProcessGamePacket(const GamePacket* packet, std::size_t total_size)
    {
        const char* data = reinterpret_cast<const char*>(packet + 1);
        
        switch (packet->type)
        {
        case GameDataType::PLAYER_POSITION:
            HandlePlayerPosition(data, packet->data_size);
            break;
        case GameDataType::HEARTBEAT:
            HandleHeartbeat();
            break;
        case GameDataType::BROADCAST_MESSAGE:
            HandleBroadcastMessage(data, packet->data_size);
            break;
        default:
            std::cout << "Unknown packet type: " 
                     << static_cast<int>(packet->type) << std::endl;
            break;
        }
    }

    void HandlePlayerPosition(const char* data, uint32_t size)
    {
        if (size < sizeof(PlayerPosition))
            return;

        auto pos = reinterpret_cast<const PlayerPosition*>(data);
        std::cout << "Player " << pos->player_id 
                 << " position: (" << pos->x << ", " << pos->y << ", " << pos->z << ")"
                 << std::endl;

        // ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        BroadcastPlayerPosition(*pos);
    }

    void HandleHeartbeat()
    {
        // í•˜íŠ¸ë¹„íŠ¸ ì‘ë‹µ
        SendHeartbeatResponse(remote_endpoint_);
    }

    void HandleBroadcastMessage(const char* data, uint32_t size)
    {
        std::string message(data, size);
        std::cout << "Broadcast message: " << message << std::endl;
        BroadcastToAllClients(message);
    }

    void BroadcastPlayerPosition(const PlayerPosition& pos)
    {
        GamePacket packet;
        packet.type = GameDataType::PLAYER_POSITION;
        packet.sequence_number = ++sequence_number_;
        packet.data_size = sizeof(PlayerPosition);

        std::vector<char> buffer(sizeof(GamePacket) + sizeof(PlayerPosition));
        std::memcpy(buffer.data(), &packet, sizeof(GamePacket));
        std::memcpy(buffer.data() + sizeof(GamePacket), &pos, sizeof(PlayerPosition));

        std::lock_guard<std::mutex> lock(clients_mutex_);
        for (const auto& client : active_clients_)
        {
            socket_.async_send_to(
                boost::asio::buffer(buffer), client.second.endpoint,
                [](const boost::system::error_code&, std::size_t) {});
        }
    }

    void SendToClient(const ClientInfo& client, const std::string& message)
    {
        GamePacket packet;
        packet.type = GameDataType::BROADCAST_MESSAGE;
        packet.sequence_number = ++sequence_number_;
        packet.data_size = static_cast<uint32_t>(message.size());

        std::vector<char> buffer(sizeof(GamePacket) + message.size());
        std::memcpy(buffer.data(), &packet, sizeof(GamePacket));
        std::memcpy(buffer.data() + sizeof(GamePacket), message.data(), message.size());

        auto send_buffer = std::make_shared<std::vector<char>>(std::move(buffer));
        socket_.async_send_to(
            boost::asio::buffer(*send_buffer), client.endpoint,
            [send_buffer](const boost::system::error_code&, std::size_t) {});
    }

    void SendHeartbeatResponse(const udp::endpoint& endpoint)
    {
        GamePacket packet;
        packet.type = GameDataType::HEARTBEAT;
        packet.sequence_number = ++sequence_number_;
        packet.data_size = 0;

        socket_.async_send_to(
            boost::asio::buffer(&packet, sizeof(GamePacket)), endpoint,
            [](const boost::system::error_code&, std::size_t) {});
    }

    void StartHeartbeat()
    {
        heartbeat_timer_ = std::make_unique<boost::asio::steady_timer>(
            socket_.get_executor(), std::chrono::seconds(5));
        
        heartbeat_timer_->async_wait([this](const boost::system::error_code& ec)
        {
            if (!ec)
            {
                CleanupInactiveClients();
                StartHeartbeat();
            }
        });
    }

    void CleanupInactiveClients()
    {
        std::lock_guard<std::mutex> lock(clients_mutex_);
        auto now = std::chrono::steady_clock::now();
        auto timeout = std::chrono::seconds(30);

        for (auto it = active_clients_.begin(); it != active_clients_.end();)
        {
            if (now - it->second.last_seen > timeout)
            {
                std::cout << "Client timeout: " << it->first << std::endl;
                it = active_clients_.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }

    udp::socket socket_;
    udp::endpoint remote_endpoint_;
    std::array<char, 1024> recv_buffer_;
    
    std::unordered_map<std::string, ClientInfo> active_clients_;
    std::mutex clients_mutex_;
    
    std::atomic<uint32_t> sequence_number_;
    std::unique_ptr<boost::asio::steady_timer> heartbeat_timer_;
};
```
  
ì´ ì½”ë“œëŠ” **ë©€í‹° í´ë¼ì´ì–¸íŠ¸ ì§€ì› + ìƒíƒœ ê´€ë¦¬ + í•˜íŠ¸ë¹„íŠ¸ ê¸°ë°˜ ì •ë¦¬(clean-up)** ê°€ í¬í•¨ëœ ê³ ê¸‰ UDP ì„œë²„ ì˜ˆì œë‹¤.
ë‹¨ìˆœíˆ íŒ¨í‚·ì„ ë°›ê³  ëŒë ¤ì£¼ëŠ” ìˆ˜ì¤€ì´ ì•„ë‹ˆë¼, **í´ë¼ì´ì–¸íŠ¸ ì¶”ì **, **ë¸Œë¡œë“œìºìŠ¤íŠ¸**, **ë°ì´í„° íƒ€ì… ì²˜ë¦¬**, **ë¹„í™œì„± í´ë¼ì´ì–¸íŠ¸ ì œê±°** ë“±ì˜ ê¸°ëŠ¥ì„ í¬í•¨í•˜ê³  ìˆë‹¤.

#### ğŸ”§ ì „ì²´ êµ¬ì¡° ê°œìš”
ì´ ì„œë²„ëŠ” `Boost.Asio` ê¸°ë°˜ ë¹„ë™ê¸° UDP ì„œë²„ë¡œì„œ ë‹¤ìŒì˜ êµ¬ì„± ìš”ì†Œë¥¼ ê°€ì§„ë‹¤.

| êµ¬ì„± ìš”ì†Œ                       | ì—­í•                                     |
| --------------------------- | ------------------------------------- |
| `GameUDPServer`             | ì„œë²„ì˜ í•µì‹¬ í´ë˜ìŠ¤                            |
| `ClientInfo`                | ê° í´ë¼ì´ì–¸íŠ¸ì˜ ìƒíƒœ(ì£¼ì†Œ, ìµœê·¼ ì‹œê°, ì‹œí€€ìŠ¤ ë²ˆí˜¸)ë¥¼ ì €ì¥    |
| `GamePacket`                | ê³µí†µ íŒ¨í‚· í—¤ë” êµ¬ì¡°ì²´ (íƒ€ì…, ì‹œí€€ìŠ¤ ë²ˆí˜¸, ë°ì´í„° í¬ê¸° í¬í•¨)  |
| `GameDataType`              | íŒ¨í‚· íƒ€ì… ì •ì˜ (ìœ„ì¹˜, í•˜íŠ¸ë¹„íŠ¸, ë¸Œë¡œë“œìºìŠ¤íŠ¸ ë“±)         |
| `PlayerPosition`            | í”Œë ˆì´ì–´ ìœ„ì¹˜ ì •ë³´ êµ¬ì¡°ì²´ (player_id, x, y, z ë“±) |
| `boost::asio::steady_timer` | ì£¼ê¸°ì  í•˜íŠ¸ë¹„íŠ¸ ì²´í¬ìš© íƒ€ì´ë¨¸                      |


#### ğŸ“œ ì½”ë“œ íë¦„ ìš”ì•½
1. **ì„œë²„ ì‹œì‘**

   * `GameUDPServer` ìƒì„±ìì—ì„œ UDP ì†Œì¼“ì„ ì§€ì • í¬íŠ¸ì— ë°”ì¸ë”©.
   * `StartReceive()` í˜¸ì¶œ â†’ í´ë¼ì´ì–¸íŠ¸ íŒ¨í‚· ë¹„ë™ê¸° ìˆ˜ì‹  ì‹œì‘.
   * `StartHeartbeat()` í˜¸ì¶œ â†’ 5ì´ˆë§ˆë‹¤ í´ë¼ì´ì–¸íŠ¸ íƒ€ì„ì•„ì›ƒ ê²€ì‚¬.

2. **íŒ¨í‚· ìˆ˜ì‹ **

   * `StartReceive()`ì—ì„œ `async_receive_from()` í˜¸ì¶œ.
   * ìˆ˜ì‹  ì™„ë£Œ ì‹œ ëŒë‹¤ ì½œë°±ìœ¼ë¡œ `HandleClientMessage()` í˜¸ì¶œ.

3. **í´ë¼ì´ì–¸íŠ¸ ê´€ë¦¬**

   * `UpdateClientInfo()`ì—ì„œ `endpoint` ê¸°ì¤€ìœ¼ë¡œ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‹ë³„.
   * ë§ˆì§€ë§‰ ìˆ˜ì‹  ì‹œê°(`last_seen`)ê³¼ ë§ˆì§€ë§‰ ì‹œí€€ìŠ¤ ë²ˆí˜¸ ê°±ì‹ .

4. **íŒ¨í‚· ì²˜ë¦¬**

   * `ProcessGamePacket()`ì—ì„œ `packet->type`ì— ë”°ë¼ ë¶„ê¸°:

     * `PLAYER_POSITION`: ì¢Œí‘œ ì¶œë ¥ í›„ `BroadcastPlayerPosition()`ìœ¼ë¡œ ì „íŒŒ.
     * `HEARTBEAT`: `SendHeartbeatResponse()`ë¡œ ì‘ë‹µ.
     * `BROADCAST_MESSAGE`: ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì— ë©”ì‹œì§€ ì „ì†¡.

5. **ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì „ì†¡**

   * `BroadcastToAllClients()` ë˜ëŠ” `BroadcastPlayerPosition()`ì—ì„œ
     ëª¨ë“  `active_clients_`ì— ëŒ€í•´ `async_send_to()` ìˆ˜í–‰.

6. **í•˜íŠ¸ë¹„íŠ¸ ê´€ë¦¬**

   * `StartHeartbeat()`ëŠ” 5ì´ˆ í›„ `CleanupInactiveClients()` í˜¸ì¶œ ì˜ˆì•½.
   * `CleanupInactiveClients()`ëŠ” 30ì´ˆ ì´ìƒ ë°˜ì‘ ì—†ëŠ” í´ë¼ì´ì–¸íŠ¸ ì‚­ì œ.


#### ğŸ§© ì£¼ìš” í´ë˜ìŠ¤/ë©¤ë²„ ì„¤ëª…

`ClientInfo`

```cpp
struct ClientInfo {
    udp::endpoint endpoint;                     // í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œ
    std::chrono::steady_clock::time_point last_seen; // ë§ˆì§€ë§‰ íŒ¨í‚· ìˆ˜ì‹  ì‹œê°„
    uint32_t last_sequence;                     // ë§ˆì§€ë§‰ìœ¼ë¡œ ë°›ì€ ì‹œí€€ìŠ¤ ë²ˆí˜¸
};
```

â†’ í´ë¼ì´ì–¸íŠ¸ë³„ë¡œ ìƒíƒœë¥¼ ì €ì¥í•´ ì¬ì ‘ì† ë° ì¤‘ë³µ ê´€ë¦¬ì— ì‚¬ìš©í•œë‹¤.
  

`GamePacket`

(ì½”ë“œì—ëŠ” ì •ì˜ ì•ˆ ë˜ì–´ ìˆì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ìŒ)

```cpp
struct GamePacket {
    GameDataType type;       // íŒ¨í‚· ì¢…ë¥˜ (enum)
    uint32_t sequence_number; 
    uint32_t data_size;      
};
```

â†’ í—¤ë” ì´í›„ ì‹¤ì œ ë°ì´í„°(payload)ê°€ ë”°ë¼ì˜¨ë‹¤.


#### ğŸ§  ì£¼ìš” ë™ì‘ ì„¤ëª…

1. `StartReceive()`  
ë¹„ë™ê¸° ìˆ˜ì‹  ë“±ë¡:

```cpp
socket_.async_receive_from(
    boost::asio::buffer(recv_buffer_), remote_endpoint_,
    [this](auto error, std::size_t bytes) { ... });
```

ìˆ˜ì‹ ì´ ì™„ë£Œë˜ë©´ `remote_endpoint_`ì— ì†¡ì‹ ì ì£¼ì†Œê°€ ì €ì¥ë˜ê³ , `HandleClientMessage()`ê°€ í˜¸ì¶œëœë‹¤.


2. `HandleClientMessage()`  

* ë°›ì€ ë²„í¼ë¥¼ `GamePacket`ìœ¼ë¡œ ìºìŠ¤íŒ….
* `UpdateClientInfo()`ë¡œ í´ë¼ì´ì–¸íŠ¸ ì •ë³´ ì—…ë°ì´íŠ¸.
* `ProcessGamePacket()`ìœ¼ë¡œ ì‹¤ì œ íŒ¨í‚· ì²˜ë¦¬ ìœ„ì„.


3. `ProcessGamePacket()`  
íŒ¨í‚· íƒ€ì…ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬:

* `PLAYER_POSITION`: í”Œë ˆì´ì–´ ìœ„ì¹˜ ê°±ì‹  ë° ë¸Œë¡œë“œìºìŠ¤íŠ¸.
* `HEARTBEAT`: í´ë¼ì´ì–¸íŠ¸ ìƒì¡´ í™•ì¸ â†’ ì‘ë‹µ ì†¡ì‹ .
* `BROADCAST_MESSAGE`: ì „ì²´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë©”ì‹œì§€ ì „ë‹¬.

  
4. `BroadcastPlayerPosition()`  

* `GamePacket + PlayerPosition` êµ¬ì¡°ë¡œ ë²„í¼ ìƒì„±.
* `active_clients_`ì— ìˆëŠ” ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¹„ë™ê¸° ì „ì†¡.
  

5. `StartHeartbeat()`  
 
* 5ì´ˆë§ˆë‹¤ `steady_timer`ê°€ ë™ì‘í•´ `CleanupInactiveClients()` ì‹¤í–‰.
* 30ì´ˆ ì´ìƒ ì‘ë‹µì´ ì—†ëŠ” í´ë¼ì´ì–¸íŠ¸ ì‚­ì œ.


#### ğŸ•¹ ì½”ë“œ íë¦„ ë‹¤ì´ì–´ê·¸ë¨

```mermaid
sequenceDiagram
    participant Client as í´ë¼ì´ì–¸íŠ¸
    participant Server as GameUDPServer
    participant Timer as HeartbeatTimer

    Note over Server: ì„œë²„ ì‹œì‘
    Server->>Server: StartReceive()
    Server->>Server: StartHeartbeat()

    Note over Client, Server: í´ë¼ì´ì–¸íŠ¸ê°€ íŒ¨í‚· ì „ì†¡
    Client->>Server: UDP Packet (GamePacket)
    Server->>Server: HandleClientMessage()
    Server->>Server: UpdateClientInfo()
    Server->>Server: ProcessGamePacket()

    alt íŒ¨í‚· íƒ€ì… == PLAYER_POSITION
        Server->>Server: HandlePlayerPosition()
        Server->>Server: BroadcastPlayerPosition()
        Server->>Client: ìœ„ì¹˜ì •ë³´ ì „ì†¡ (ëª¨ë“  í´ë¼ì´ì–¸íŠ¸)
    else íŒ¨í‚· íƒ€ì… == HEARTBEAT
        Server->>Server: HandleHeartbeat()
        Server->>Client: SendHeartbeatResponse()
    else íŒ¨í‚· íƒ€ì… == BROADCAST_MESSAGE
        Server->>Server: HandleBroadcastMessage()
        Server->>Client: BroadcastToAllClients()
    end

    Note over Timer: 5ì´ˆë§ˆë‹¤ íƒ€ì´ë¨¸ ì‘ë™
    Timer->>Server: CleanupInactiveClients()
    Server->>Server: 30ì´ˆ ì´ìƒ ë¯¸ì‘ë‹µ í´ë¼ì´ì–¸íŠ¸ ì‚­ì œ
```


#### ğŸ§­ ë™ì‘ ìš”ì•½

| í•­ëª©       | ì„¤ëª…                                             |
| -------- | ---------------------------------------------- |
| ë„¤íŠ¸ì›Œí¬ I/O | `async_receive_from` / `async_send_to`ë¡œ ë¹„ë™ê¸° ì²˜ë¦¬ |
| í´ë¼ì´ì–¸íŠ¸ ê´€ë¦¬ | IP:Port ë¬¸ìì—´ í‚¤ ê¸°ë°˜ì˜ `unordered_map`              |
| ìŠ¤ë ˆë“œ ì•ˆì „   | `std::mutex`ë¡œ `active_clients_` ë³´í˜¸             |
| ìƒì¡´ í™•ì¸    | í•˜íŠ¸ë¹„íŠ¸ + 30ì´ˆ íƒ€ì„ì•„ì›ƒ ê¸°ë°˜ í´ë¼ì´ì–¸íŠ¸ ì •ë¦¬                    |
| ë¸Œë¡œë“œìºìŠ¤íŠ¸   | ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë™ì‹œ ì „ì†¡ ê°€ëŠ¥                            |
| ì‹œí€€ìŠ¤ ê´€ë¦¬   | `std::atomic<uint32_t>`ë¡œ ì „ì†¡ íŒ¨í‚· ë²ˆí˜¸ ì¦ê°€           |


#### ğŸ’¡ ì •ë¦¬
`GameUDPServer`ëŠ” ë‹¨ìˆœ ì—ì½” ì„œë²„ì—ì„œ í•œ ë‹¨ê³„ ë°œì „í•´, **ê²Œì„ ë„¤íŠ¸ì›Œí¬ ì„œë²„ì˜ í•µì‹¬ êµ¬ì„± ìš”ì†Œ**ë¥¼ í¬í•¨í•œ í˜•íƒœë‹¤.
ì¦‰,

* í´ë¼ì´ì–¸íŠ¸ë³„ ì„¸ì…˜ ê´€ë¦¬
* ì‹¤ì‹œê°„ ì¢Œí‘œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
* í•˜íŠ¸ë¹„íŠ¸ë¡œ ìƒì¡´ í™•ì¸
* ë¹„ë™ê¸° ì´ë²¤íŠ¸ ë£¨í”„ ê¸°ë°˜ í™•ì¥ì„±

ë“±ì„ ëª¨ë‘ ê°–ì¶˜ êµ¬ì¡°ë¡œ, ì‹¤ì œ ê²Œì„ ì„œë²„ì˜ **UDP ì„¸ì…˜ ê´€ë¦¬ ëª¨ë¸ì˜ ì¶•ì†ŒíŒ**ì´ë¼ ë³¼ ìˆ˜ ìˆë‹¤.

    
### 10.2.3 UDP í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„

```cpp
class GameUDPClient
{
public:
    GameUDPClient(boost::asio::io_context& io_context, 
                  const std::string& host, const std::string& port)
        : socket_(io_context), sequence_number_(0)
    {
        udp::resolver resolver(io_context);
        server_endpoint_ = *resolver.resolve(udp::v4(), host, port).begin();
        
        socket_.open(udp::v4());
        StartReceive();
        StartHeartbeat();
    }

    void SendPlayerPosition(float x, float y, float z, float rotation)
    {
        PlayerPosition pos;
        pos.player_id = 12345; // ì‹¤ì œë¡œëŠ” í´ë¼ì´ì–¸íŠ¸ ID
        pos.x = x;
        pos.y = y;
        pos.z = z;
        pos.rotation = rotation;
        pos.timestamp = static_cast<uint32_t>(
            std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::steady_clock::now().time_since_epoch()).count());

        SendGameData(GameDataType::PLAYER_POSITION, &pos, sizeof(pos));
    }

    void SendBroadcastMessage(const std::string& message)
    {
        SendGameData(GameDataType::BROADCAST_MESSAGE, message.data(), message.size());
    }

private:
    void StartReceive()
    {
        socket_.async_receive_from(
            boost::asio::buffer(recv_buffer_), sender_endpoint_,
            [this](const boost::system::error_code& error, std::size_t bytes)
            {
                if (!error)
                {
                    HandleServerMessage(bytes);
                }
                StartReceive();
            });
    }

    void HandleServerMessage(std::size_t bytes_transferred)
    {
        if (bytes_transferred < sizeof(GamePacket))
            return;

        auto packet = reinterpret_cast<const GamePacket*>(recv_buffer_.data());
        const char* data = reinterpret_cast<const char*>(packet + 1);

        switch (packet->type)
        {
        case GameDataType::PLAYER_POSITION:
            HandlePlayerPositionUpdate(data, packet->data_size);
            break;
        case GameDataType::HEARTBEAT:
            HandleHeartbeatResponse();
            break;
        case GameDataType::BROADCAST_MESSAGE:
            HandleBroadcastMessage(data, packet->data_size);
            break;
        }
    }

    void HandlePlayerPositionUpdate(const char* data, uint32_t size)
    {
        if (size < sizeof(PlayerPosition))
            return;

        auto pos = reinterpret_cast<const PlayerPosition*>(data);
        std::cout << "Other player " << pos->player_id 
                 << " at (" << pos->x << ", " << pos->y << ", " << pos->z << ")"
                 << std::endl;
    }

    void HandleHeartbeatResponse()
    {
        last_heartbeat_response_ = std::chrono::steady_clock::now();
        std::cout << "Heartbeat response received" << std::endl;
    }

    void HandleBroadcastMessage(const char* data, uint32_t size)
    {
        std::string message(data, size);
        std::cout << "Broadcast: " << message << std::endl;
    }

    void SendGameData(GameDataType type, const void* data, size_t data_size)
    {
        GamePacket packet;
        packet.type = type;
        packet.sequence_number = ++sequence_number_;
        packet.data_size = static_cast<uint32_t>(data_size);

        std::vector<char> buffer(sizeof(GamePacket) + data_size);
        std::memcpy(buffer.data(), &packet, sizeof(GamePacket));
        if (data_size > 0)
        {
            std::memcpy(buffer.data() + sizeof(GamePacket), data, data_size);
        }

        auto send_buffer = std::make_shared<std::vector<char>>(std::move(buffer));
        socket_.async_send_to(
            boost::asio::buffer(*send_buffer), server_endpoint_,
            [send_buffer](const boost::system::error_code& ec, std::size_t bytes)
            {
                if (ec)
                {
                    std::cerr << "Send error: " << ec.message() << std::endl;
                }
            });
    }

    void StartHeartbeat()
    {
        heartbeat_timer_ = std::make_unique<boost::asio::steady_timer>(
            socket_.get_executor(), std::chrono::seconds(10));
        
        heartbeat_timer_->async_wait([this](const boost::system::error_code& ec)
        {
            if (!ec)
            {
                SendHeartbeat();
                StartHeartbeat();
            }
        });
    }

    void SendHeartbeat()
    {
        SendGameData(GameDataType::HEARTBEAT, nullptr, 0);
    }

    udp::socket socket_;
    udp::endpoint server_endpoint_;
    udp::endpoint sender_endpoint_;
    std::array<char, 1024> recv_buffer_;
    
    std::atomic<uint32_t> sequence_number_;
    std::chrono::steady_clock::time_point last_heartbeat_response_;
    std::unique_ptr<boost::asio::steady_timer> heartbeat_timer_;
};
```
   
ì´ ì½”ë“œëŠ” **`Boost.Asio` ê¸°ë°˜ì˜ ê²Œì„ìš© UDP í´ë¼ì´ì–¸íŠ¸** êµ¬í˜„ ì˜ˆì œë‹¤.
ì´ì „ì˜ `GameUDPServer`ì™€ ì§ì„ ì´ë£¨ëŠ” ì½”ë“œë¡œ, **ì„œë²„ì™€ì˜ ë¹„ë™ê¸° í†µì‹ **, **í•˜íŠ¸ë¹„íŠ¸ ì „ì†¡**, **í”Œë ˆì´ì–´ ìœ„ì¹˜ ë° ë©”ì‹œì§€ ì†¡ìˆ˜ì‹ **ì„ ë‹´ë‹¹í•œë‹¤.

#### ğŸ“¦ ì „ì²´ ê°œìš”
ì´ í´ë¼ì´ì–¸íŠ¸ëŠ” ë‹¤ìŒì˜ íŠ¹ì§•ì„ ê°€ì§„ë‹¤:

| ê¸°ëŠ¥        | ì„¤ëª…                                                              |
| --------- | --------------------------------------------------------------- |
| ë¹„ë™ê¸° ìˆ˜ì‹     | `async_receive_from()`ìœ¼ë¡œ ì„œë²„ ë©”ì‹œì§€ë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ìˆ˜ì‹                       |
| í•˜íŠ¸ë¹„íŠ¸ ì „ì†¡   | 10ì´ˆë§ˆë‹¤ ì„œë²„ë¡œ ìƒì¡´ ì‹ í˜¸(`HEARTBEAT`) ì†¡ì‹                                  |
| ë°ì´í„° ì†¡ì‹     | `GamePacket` í—¤ë”ë¥¼ ë¶™ì—¬ `PLAYER_POSITION`, `BROADCAST_MESSAGE` ë“± ì „ì†¡ |
| ì„œë²„ ì‘ë‹µ ì²˜ë¦¬  | ì„œë²„ì—ì„œ ì˜¤ëŠ” ì¢Œí‘œ/ë©”ì‹œì§€/í•˜íŠ¸ë¹„íŠ¸ ì‘ë‹µì„ êµ¬ë¶„í•˜ì—¬ ì²˜ë¦¬                                 |
| ì‹œí€€ìŠ¤ ë²ˆí˜¸ ê´€ë¦¬ | ëª¨ë“  ì†¡ì‹  íŒ¨í‚·ì€ `atomic<uint32_t>` ê¸°ë°˜ ìˆœë²ˆì„ ì¦ê°€ì‹œí‚´                        |


#### ğŸ”§ ì£¼ìš” êµ¬ì„± ìš”ì†Œ

1. `GameUDPClient` í´ë˜ìŠ¤  
UDP ì†Œì¼“ì„ ê´€ë¦¬í•˜ê³ , ì„œë²„ì™€ì˜ í†µì‹  ë¡œì§ ì „ì²´ë¥¼ ë‹´ë‹¹í•œë‹¤.

| ë©¤ë²„                               | ì—­í•                |
| -------------------------------- | ---------------- |
| `udp::socket socket_`            | UDP ì†Œì¼“ ê°ì²´        |
| `udp::endpoint server_endpoint_` | ì„œë²„ì˜ ì£¼ì†Œì™€ í¬íŠ¸       |
| `recv_buffer_`                   | ìˆ˜ì‹  ë°ì´í„° ë²„í¼        |
| `sequence_number_`               | ì „ì†¡ íŒ¨í‚·ì˜ ì¼ë ¨ë²ˆí˜¸      |
| `heartbeat_timer_`               | ì£¼ê¸°ì ì¸ í•˜íŠ¸ë¹„íŠ¸ ì „ì†¡ íƒ€ì´ë¨¸ |
| `last_heartbeat_response_`       | ë§ˆì§€ë§‰ í•˜íŠ¸ë¹„íŠ¸ ì‘ë‹µ ì‹œê°„   |


#### âš™ï¸ ì£¼ìš” í•¨ìˆ˜ë³„ ìƒì„¸ ì„¤ëª…

ğŸ§© 1. ìƒì„±ì  

```cpp
GameUDPClient(io_context, host, port)
```

* DNSë¥¼ í†µí•´ ì„œë²„ ì£¼ì†Œ(`host`, `port`)ë¥¼ `resolve()`.
* UDP ì†Œì¼“ì„ `open(udp::v4())`ìœ¼ë¡œ ì´ˆê¸°í™”.
* `StartReceive()`ë¡œ ìˆ˜ì‹  ëŒ€ê¸° ì‹œì‘.
* `StartHeartbeat()`ë¡œ ì£¼ê¸°ì  í•˜íŠ¸ë¹„íŠ¸ íƒ€ì´ë¨¸ ì„¤ì •.

â¡ï¸ í´ë¼ì´ì–¸íŠ¸ê°€ ìƒì„±ë˜ë©´ ë°”ë¡œ ì„œë²„ì™€ í†µì‹  ê°€ëŠ¥í•œ ìƒíƒœê°€ ëœë‹¤.

  
ğŸ§­ 2. `StartReceive()`  

```cpp
socket_.async_receive_from(
    boost::asio::buffer(recv_buffer_), sender_endpoint_,
    [this](error, bytes) { ... });
```

* ì„œë²„ì—ì„œ ì˜¤ëŠ” ëª¨ë“  UDP íŒ¨í‚·ì„ ë¹„ë™ê¸° ìˆ˜ì‹ í•œë‹¤.
* ìˆ˜ì‹ ì´ ì™„ë£Œë˜ë©´ `HandleServerMessage(bytes)` í˜¸ì¶œ.
* ê·¸ í›„ **ë‹¤ì‹œ `StartReceive()`ë¥¼ í˜¸ì¶œ**í•´ ë£¨í”„ ìœ ì§€.

â¡ï¸ í´ë¼ì´ì–¸íŠ¸ëŠ” ëŠì„ì—†ì´ ì„œë²„ì˜ ì‘ë‹µì„ ìˆ˜ì‹  ëŒ€ê¸°í•œë‹¤.

  
ğŸ“¬ 3. `HandleServerMessage()`  

```cpp
auto packet = reinterpret_cast<const GamePacket*>(recv_buffer_.data());
switch (packet->type) { ... }
```

* ë°›ì€ ë²„í¼ë¥¼ `GamePacket` êµ¬ì¡°ë¡œ í•´ì„í•œë‹¤.
* `type`ì— ë”°ë¼ ë¶„ê¸°:

  * `PLAYER_POSITION` â†’ `HandlePlayerPositionUpdate()`
  * `HEARTBEAT` â†’ `HandleHeartbeatResponse()`
  * `BROADCAST_MESSAGE` â†’ `HandleBroadcastMessage()`

â¡ï¸ ì„œë²„ì—ì„œ ì˜¤ëŠ” íŒ¨í‚·ì˜ ìš©ë„(ì¢Œí‘œ, í•˜íŠ¸ë¹„íŠ¸, ì±„íŒ… ë©”ì‹œì§€)ë¥¼ ì‹ë³„í•´ ì²˜ë¦¬í•œë‹¤.

 
ğŸ§ 4. `SendPlayerPosition()`  

```cpp
PlayerPosition pos;
pos.player_id = 12345;
pos.x = x; pos.y = y; pos.z = z;
pos.rotation = rotation;
pos.timestamp = í˜„ì¬ ì‹œê°;
SendGameData(GameDataType::PLAYER_POSITION, &pos, sizeof(pos));
```

* í˜„ì¬ í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ ì •ë³´ë¥¼ `PlayerPosition` êµ¬ì¡°ì²´ì— ë‹´ì•„ ì„œë²„ë¡œ ì „ì†¡.
* ì„œë²„ëŠ” ì´ë¥¼ ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸í•œë‹¤.

  
ğŸ“¢ 5. `SendBroadcastMessage()`  

```cpp
SendGameData(GameDataType::BROADCAST_MESSAGE, message.data(), message.size());
```

* ì±„íŒ…ì´ë‚˜ ì•Œë¦¼ ë©”ì‹œì§€ë¥¼ ì„œë²„ë¡œ ì „ì†¡.
* ì„œë²„ëŠ” ì´ ë©”ì‹œì§€ë¥¼ ì „ì²´ í´ë¼ì´ì–¸íŠ¸ì— ë¸Œë¡œë“œìºìŠ¤íŠ¸í•œë‹¤.

  
ğŸ’“ 6. `StartHeartbeat()` / `SendHeartbeat()`  

* 10ì´ˆë§ˆë‹¤ íƒ€ì´ë¨¸(`steady_timer`)ê°€ ë™ì‘í•´ `SendHeartbeat()` í˜¸ì¶œ.
* `SendHeartbeat()`ëŠ” ë°ì´í„° ì—†ì´ `HEARTBEAT` íŒ¨í‚· ì „ì†¡.
* ì„œë²„ëŠ” ì´ì— ëŒ€í•œ ì‘ë‹µì„ ë‹¤ì‹œ `HandleHeartbeatResponse()`ë¡œ ë³´ë‚¸ë‹¤.

â¡ï¸ ë„¤íŠ¸ì›Œí¬ ì—°ê²° ìœ ì§€ ë° ì„œë²„ ì—°ê²° í™•ì¸ìš© ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤.

  
âš’ 7. `SendGameData()`  

```cpp
GamePacket packet;
packet.type = type;
packet.sequence_number = ++sequence_number_;
packet.data_size = data_size;
```

* `GamePacket` í—¤ë” + ë°ì´í„°(payload)ë¥¼ ì¡°í•©í•´ UDP íŒ¨í‚· ìƒì„±.
* `async_send_to()`ë¡œ ì„œë²„ì— ë¹„ë™ê¸° ì†¡ì‹ .
* ì†¡ì‹  ë²„í¼ëŠ” `shared_ptr`ë¡œ ê´€ë¦¬í•´ ìˆ˜ëª… ë³´ì¥.

â¡ï¸ ëª¨ë“  ì†¡ì‹  í•¨ìˆ˜(`SendPlayerPosition`, `SendBroadcastMessage`, `SendHeartbeat`)ëŠ” ì´ í•¨ìˆ˜ë¥¼ ê³µí†µìœ¼ë¡œ ì‚¬ìš©í•œë‹¤.

  
#### ğŸ’¡ ì „ì²´ ë™ì‘ íë¦„

1. **í´ë¼ì´ì–¸íŠ¸ ìƒì„±**

   * ì„œë²„ ì£¼ì†Œ í•´ì„ ë° ì†Œì¼“ ì—´ê¸°.
   * ìˆ˜ì‹  ë£¨í”„ì™€ í•˜íŠ¸ë¹„íŠ¸ íƒ€ì´ë¨¸ ì‹œì‘.

2. **ì£¼ê¸°ì  í•˜íŠ¸ë¹„íŠ¸ ì†¡ì‹ **

   * 10ì´ˆë§ˆë‹¤ ì„œë²„ë¡œ `HEARTBEAT` íŒ¨í‚· ì†¡ì‹ .
   * ì„œë²„ë¡œë¶€í„° ì‘ë‹µì„ ë°›ìœ¼ë©´ `HandleHeartbeatResponse()` ì‹¤í–‰.

3. **ì‚¬ìš©ì ì…ë ¥ (ì˜ˆ: ì´ë™, ì±„íŒ…)**

   * `SendPlayerPosition()` ë˜ëŠ” `SendBroadcastMessage()` í˜¸ì¶œ.
   * `SendGameData()`ë¥¼ í†µí•´ ì„œë²„ë¡œ ì „ì†¡.

4. **ì„œë²„ë¡œë¶€í„° ì‘ë‹µ ìˆ˜ì‹ **

   * `StartReceive()` â†’ `HandleServerMessage()`
   * íƒ€ì…ë³„ ì²˜ë¦¬ (`PLAYER_POSITION`, `BROADCAST_MESSAGE`, `HEARTBEAT` ë“±).

  
#### ğŸ§­ ë™ì‘ íë¦„ ë‹¤ì´ì–´ê·¸ë¨ (ë¨¸ë©”ì´ë“œ)

```mermaid
sequenceDiagram
    participant Client as GameUDPClient
    participant Server as GameUDPServer
    participant Timer as HeartbeatTimer

    Note over Client: í´ë¼ì´ì–¸íŠ¸ ì‹œì‘
    Client->>Server: (1) PLAYER_POSITION / BROADCAST_MESSAGE ì „ì†¡
    Client->>Server: (2) HEARTBEAT ì£¼ê¸°ì  ì „ì†¡ (10ì´ˆë§ˆë‹¤)
    Server->>Client: (3) ì‘ë‹µ íŒ¨í‚· ìˆ˜ì‹ 

    Note over Client: StartReceive() ë¹„ë™ê¸° ë£¨í”„
    Client->>Client: HandleServerMessage()
    alt type == PLAYER_POSITION
        Client->>Client: HandlePlayerPositionUpdate()
        Client->>Console: "Other player position ì¶œë ¥"
    else type == HEARTBEAT
        Client->>Client: HandleHeartbeatResponse()
        Client->>Console: "Heartbeat response received"
    else type == BROADCAST_MESSAGE
        Client->>Client: HandleBroadcastMessage()
        Client->>Console: "Broadcast ë©”ì‹œì§€ ì¶œë ¥"
    end

    Note over Timer: 10ì´ˆ ì£¼ê¸°
    Timer->>Client: SendHeartbeat()
    Client->>Server: HEARTBEAT íŒ¨í‚· ì „ì†¡
```

  
#### ğŸ§© ì •ë¦¬

| í•­ëª©           | ì„¤ëª…                                 |
| ------------ | ---------------------------------- |
| **ë„¤íŠ¸ì›Œí¬ ëª¨ë¸**  | UDP ë¹„ë™ê¸° ë°©ì‹                         |
| **ìˆ˜ì‹  ë£¨í”„**    | í•­ìƒ `StartReceive()`ë¡œ ì¬ë“±ë¡           |
| **ì „ì†¡ ë²„í¼ ê´€ë¦¬** | `shared_ptr`ì„ ì‚¬ìš©í•´ ì†¡ì‹  ì™„ë£Œ ì‹œì ê¹Œì§€ ìˆ˜ëª… ìœ ì§€ |
| **í•˜íŠ¸ë¹„íŠ¸ ê´€ë¦¬**  | 10ì´ˆ ì£¼ê¸° ì „ì†¡ + ì„œë²„ ì‘ë‹µ ê°±ì‹                |
| **í™•ì¥ì„±**      | íŒ¨í‚· íƒ€ì…(enum) ê¸°ë°˜ìœ¼ë¡œ ê¸°ëŠ¥ í™•ì¥ ìš©ì´          |
| **ì‹¤ì „ ì ìš©**    | ìœ„ì¹˜ ë™ê¸°í™”, ì±„íŒ… ì‹œìŠ¤í…œ, ì—°ê²° ìœ ì§€ ë“± ê¸°ë³¸ í† ëŒ€ ì œê³µ   |


ì´ `GameUDPClient`ëŠ” **ê²Œì„ í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë²„ì™€ ì‹¤ì‹œê°„ ìƒíƒœë¥¼ ì£¼ê³ ë°›ëŠ” ê¸°ë³¸ í†µì‹  ê³¨ê²©**ì´ë‹¤.
ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹¤ì œ ê²Œì„ì—ì„œëŠ” ë‹¤ìŒì„ í™•ì¥í•  ìˆ˜ ìˆë‹¤:

* íŒ¨í‚· ì•”í˜¸í™” / ì••ì¶•
* í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ ë° ì‹ë³„
* ì˜ˆì¸¡ ë³´ì • (client-side prediction)
* íŒ¨í‚· ì†ì‹¤ ë³µêµ¬ (reliable UDP êµ¬í˜„)

ì¦‰, ì´ ì˜ˆì œëŠ” **ê²Œì„ ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°ì˜ ë¹„ë™ê¸° UDP í†µì‹  ê¸°ë³¸ êµ¬ì¡°ë¥¼ ì™„ì „í•˜ê²Œ ë³´ì—¬ì£¼ëŠ” í‘œì¤€ì ì¸ ì½”ë“œ**ë¼ í•  ìˆ˜ ìˆë‹¤.
  

</br>  
  

## 10.3 ê²Œì„ì—ì„œì˜ UDP í™œìš© ì‚¬ë¡€

### 10.4.1 ì‹¤ì‹œê°„ ìœ„ì¹˜ ë™ê¸°í™” ì‹œìŠ¤í…œ

```cpp
class RealtimePositionSync
{
public:
    struct PositionData
    {
        uint32_t player_id;
        float x, y, z;
        float velocity_x, velocity_y, velocity_z;
        float rotation;
        uint32_t timestamp;
        uint32_t sequence;
    };

    RealtimePositionSync(boost::asio::io_context& io_context)
        : socket_(io_context), timer_(io_context), sequence_(0)
    {
        StartSyncTimer();
    }

    void UpdatePosition(uint32_t player_id, float x, float y, float z,
                       float vx, float vy, float vz, float rotation)
    {
        std::lock_guard<std::mutex> lock(position_mutex_);
        
        auto& pos = player_positions_[player_id];
        pos.player_id = player_id;
        pos.x = x; pos.y = y; pos.z = z;
        pos.velocity_x = vx; pos.velocity_y = vy; pos.velocity_z = vz;
        pos.rotation = rotation;
        pos.timestamp = GetCurrentTimestamp();
        pos.sequence = ++sequence_;
    }

    void BroadcastPositions()
    {
        std::lock_guard<std::mutex> lock(position_mutex_);
        
        for (const auto& pair : player_positions_)
        {
            const auto& pos = pair.second;
            
            // ìœ„ì¹˜ ë°ì´í„°ë¥¼ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡
            BroadcastPosition(pos);
        }
    }

private:
    void StartSyncTimer()
    {
        // 60fpsë¡œ ìœ„ì¹˜ ë™ê¸°í™”
        timer_.expires_after(std::chrono::milliseconds(16));
        timer_.async_wait([this](const boost::system::error_code& ec)
        {
            if (!ec)
            {
                BroadcastPositions();
                StartSyncTimer();
            }
        });
    }

    void BroadcastPosition(const PositionData& pos)
    {
        // UDPë¥¼ í†µí•œ ìœ„ì¹˜ ë°ì´í„° ë¸Œë¡œë“œìºìŠ¤íŠ¸
        auto buffer = std::make_shared<std::vector<char>>(sizeof(PositionData));
        std::memcpy(buffer->data(), &pos, sizeof(PositionData));

        // ëª¨ë“  í™œì„± í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡ (í´ë¼ì´ì–¸íŠ¸ ëª©ë¡ì€ ë³„ë„ ê´€ë¦¬)
        for (const auto& client : active_clients_)
        {
            socket_.async_send_to(
                boost::asio::buffer(*buffer), client,
                [buffer](const boost::system::error_code&, std::size_t) {});
        }
    }

    uint32_t GetCurrentTimestamp()
    {
        return static_cast<uint32_t>(
            std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::steady_clock::now().time_since_epoch()).count());
    }

    udp::socket socket_;
    boost::asio::steady_timer timer_;
    
    std::unordered_map<uint32_t, PositionData> player_positions_;
    std::mutex position_mutex_;
    
    std::vector<udp::endpoint> active_clients_;
    std::atomic<uint32_t> sequence_;
};
```

### 10.3.2 ê²Œì„ ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì‹œìŠ¤í…œ

```cpp
class GameEventBroadcaster
{
public:
    enum class EventType
    {
        PLAYER_SPAWN,
        PLAYER_DEATH,
        ITEM_PICKUP,
        EXPLOSION,
        ACHIEVEMENT,
        MATCH_RESULT
    };

    struct GameEvent
    {
        EventType type;
        uint32_t source_player_id;
        uint32_t target_player_id;
        float x, y, z; // ì´ë²¤íŠ¸ ë°œìƒ ìœ„ì¹˜
        uint32_t event_data; // ì¶”ê°€ ì´ë²¤íŠ¸ ë°ì´í„°
        uint32_t timestamp;
    };

    GameEventBroadcaster(boost::asio::io_context& io_context, short port)
        : socket_(io_context, udp::endpoint(udp::v4(), port))
    {
    }

    void TriggerEvent(EventType type, uint32_t source_id, uint32_t target_id,
                     float x, float y, float z, uint32_t data = 0)
    {
        GameEvent event;
        event.type = type;
        event.source_player_id = source_id;
        event.target_player_id = target_id;
        event.x = x; event.y = y; event.z = z;
        event.event_data = data;
        event.timestamp = GetCurrentTimestamp();

        BroadcastEvent(event);
        LogEvent(event);
    }

    void AddClient(const udp::endpoint& client)
    {
        std::lock_guard<std::mutex> lock(clients_mutex_);
        clients_.insert(client);
        std::cout << "Client added: " << client << std::endl;
    }

    void RemoveClient(const udp::endpoint& client)
    {
        std::lock_guard<std::mutex> lock(clients_mutex_);
        clients_.erase(client);
        std::cout << "Client removed: " << client << std::endl;
    }

private:
    void BroadcastEvent(const GameEvent& event)
    {
        auto buffer = std::make_shared<std::vector<char>>(sizeof(GameEvent));
        std::memcpy(buffer->data(), &event, sizeof(GameEvent));

        std::lock_guard<std::mutex> lock(clients_mutex_);
        for (const auto& client : clients_)
        {
            socket_.async_send_to(
                boost::asio::buffer(*buffer), client,
                [buffer](const boost::system::error_code& ec, std::size_t bytes)
                {
                    if (ec)
                    {
                        std::cerr << "Broadcast error: " << ec.message() << std::endl;
                    }
                });
        }
    }

    void LogEvent(const GameEvent& event)
    {
        std::cout << "Event: " << GetEventTypeName(event.type)
                 << " Source: " << event.source_player_id
                 << " Target: " << event.target_player_id
                 << " Position: (" << event.x << ", " << event.y << ", " << event.z << ")"
                 << std::endl;
    }

    std::string GetEventTypeName(EventType type)
    {
        switch (type)
        {
        case EventType::PLAYER_SPAWN: return "PLAYER_SPAWN";
        case EventType::PLAYER_DEATH: return "PLAYER_DEATH";
        case EventType::ITEM_PICKUP: return "ITEM_PICKUP";
        case EventType::EXPLOSION: return "EXPLOSION";
        case EventType::ACHIEVEMENT: return "ACHIEVEMENT";
        case EventType::MATCH_RESULT: return "MATCH_RESULT";
        default: return "UNKNOWN";
        }
    }

    uint32_t GetCurrentTimestamp()
    {
        return static_cast<uint32_t>(
            std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::steady_clock::now().time_since_epoch()).count());
    }

    udp::socket socket_;
    std::set<udp::endpoint> clients_;
    std::mutex clients_mutex_;
};
```
  
## 10.4 ì‹ ë¢°ì„± ìˆëŠ” UDP êµ¬í˜„

```cpp
class ReliableUDP
{
public:
    struct ReliablePacket
    {
        uint32_t sequence_number;
        uint32_t ack_number;
        uint32_t ack_bitfield; // 32ê°œ ì´ì „ íŒ¨í‚·ì˜ ìˆ˜ì‹  ì—¬ë¶€
        bool requires_ack;
        uint32_t data_size;
        // ë°ì´í„°ê°€ ë’¤ë”°ë¦„
    };

    ReliableUDP(boost::asio::io_context& io_context, udp::endpoint local_endpoint)
        : socket_(io_context, local_endpoint), send_sequence_(0), recv_sequence_(0)
    {
        StartReceive();
        StartAckTimer();
    }

    void SendReliable(const std::vector<char>& data, const udp::endpoint& target)
    {
        uint32_t seq = ++send_sequence_;
        
        // íŒ¨í‚· ìƒì„±
        std::vector<char> packet(sizeof(ReliablePacket) + data.size());
        auto* header = reinterpret_cast<ReliablePacket*>(packet.data());
        header->sequence_number = seq;
        header->requires_ack = true;
        header->data_size = static_cast<uint32_t>(data.size());
        
        std::memcpy(packet.data() + sizeof(ReliablePacket), data.data(), data.size());

        // ì „ì†¡
        SendPacket(packet, target);
        
        // ì¬ì „ì†¡ì„ ìœ„í•´ ë³´ê´€
        PendingPacket pending;
        pending.packet = packet;
        pending.target = target;
        pending.sequence = seq;
        pending.send_time = std::chrono::steady_clock::now();
        pending.retry_count = 0;
        
        std::lock_guard<std::mutex> lock(pending_mutex_);
        pending_packets_[seq] = pending;
    }

    void SendUnreliable(const std::vector<char>& data, const udp::endpoint& target)
    {
        uint32_t seq = ++send_sequence_;
        
        std::vector<char> packet(sizeof(ReliablePacket) + data.size());
        auto* header = reinterpret_cast<ReliablePacket*>(packet.data());
        header->sequence_number = seq;
        header->requires_ack = false;
        header->data_size = static_cast<uint32_t>(data.size());
        
        std::memcpy(packet.data() + sizeof(ReliablePacket), data.data(), data.size());
        
        SendPacket(packet, target);
    }

private:
    struct PendingPacket
    {
        std::vector<char> packet;
        udp::endpoint target;
        uint32_t sequence;
        std::chrono::steady_clock::time_point send_time;
        int retry_count;
    };

    void StartReceive()
    {
        socket_.async_receive_from(
            boost::asio::buffer(recv_buffer_), remote_endpoint_,
            [this](const boost::system::error_code& error, std::size_t bytes)
            {
                if (!error)
                {
                    HandleIncomingPacket(bytes);
                }
                StartReceive();
            });
    }

    void HandleIncomingPacket(std::size_t bytes_transferred)
    {
        if (bytes_transferred < sizeof(ReliablePacket))
            return;

        auto* header = reinterpret_cast<const ReliablePacket*>(recv_buffer_.data());
        
        // ACK ì²˜ë¦¬
        ProcessAcknowledgment(header->ack_number, header->ack_bitfield);
        
        // íŒ¨í‚· ìˆœì„œ í™•ì¸
        if (IsNewPacket(header->sequence_number))
        {
            // ìƒˆ íŒ¨í‚· ì²˜ë¦¬
            MarkPacketReceived(header->sequence_number);
            
            if (header->data_size > 0)
            {
                std::vector<char> data(header->data_size);
                std::memcpy(data.data(), recv_buffer_.data() + sizeof(ReliablePacket), 
                           header->data_size);
                
                // ë°ì´í„° ì²˜ë¦¬ (ìƒìœ„ ë ˆì´ì–´ë¡œ ì „ë‹¬)
                OnDataReceived(data, remote_endpoint_);
            }
        }
        
        // ACK ì‘ë‹µ (í•„ìš”í•œ ê²½ìš°)
        if (header->requires_ack)
        {
            SendAcknowledgment(remote_endpoint_);
        }
    }

    void ProcessAcknowledgment(uint32_t ack_number, uint32_t ack_bitfield)
    {
        std::lock_guard<std::mutex> lock(pending_mutex_);
        
        // ê°€ì¥ ìµœê·¼ ACK ì²˜ë¦¬
        auto it = pending_packets_.find(ack_number);
        if (it != pending_packets_.end())
        {
            pending_packets_.erase(it);
        }
        
        // ë¹„íŠ¸í•„ë“œë¡œ ì´ì „ íŒ¨í‚·ë“¤ ACK ì²˜ë¦¬
        for (int i = 0; i < 32; ++i)
        {
            if (ack_bitfield & (1u << i))
            {
                uint32_t seq = ack_number - (i + 1);
                auto bit_it = pending_packets_.find(seq);
                if (bit_it != pending_packets_.end())
                {
                    pending_packets_.erase(bit_it);
                }
            }
        }
    }

    bool IsNewPacket(uint32_t sequence)
    {
        // ì‹œí€€ìŠ¤ ë²ˆí˜¸ ì²´í¬ (ìˆœí™˜ ì‹œí€€ìŠ¤ ê³ ë ¤)
        return sequence > recv_sequence_ || 
               (recv_sequence_ - sequence) > (UINT32_MAX / 2);
    }

    void MarkPacketReceived(uint32_t sequence)
    {
        if (sequence > recv_sequence_)
        {
            recv_sequence_ = sequence;
        }
        
        // ìˆ˜ì‹  ë¹„íŠ¸í•„ë“œ ì—…ë°ì´íŠ¸
        uint32_t diff = recv_sequence_ - sequence;
        if (diff < 32)
        {
            recv_bitfield_ |= (1u << diff);
        }
    }

    void SendAcknowledgment(const udp::endpoint& target)
    {
        ReliablePacket ack_packet;
        ack_packet.sequence_number = ++send_sequence_;
        ack_packet.ack_number = recv_sequence_;
        ack_packet.ack_bitfield = recv_bitfield_;
        ack_packet.requires_ack = false;
        ack_packet.data_size = 0;
        
        std::vector<char> packet(sizeof(ReliablePacket));
        std::memcpy(packet.data(), &ack_packet, sizeof(ReliablePacket));
        
        SendPacket(packet, target);
    }

    void SendPacket(const std::vector<char>& packet, const udp::endpoint& target)
    {
        auto buffer = std::make_shared<std::vector<char>>(packet);
        socket_.async_send_to(
            boost::asio::buffer(*buffer), target,
            [buffer](const boost::system::error_code&, std::size_t) {});
    }

    void StartAckTimer()
    {
        ack_timer_ = std::make_unique<boost::asio::steady_timer>(
            socket_.get_executor(), std::chrono::milliseconds(100));
        
        ack_timer_->async_wait([this](const boost::system::error_code& ec)
        {
            if (!ec)
            {
                ProcessRetransmissions();
                StartAckTimer();
            }
        });
    }

    void ProcessRetransmissions()
    {
        std::lock_guard<std::mutex> lock(pending_mutex_);
        auto now = std::chrono::steady_clock::now();
        
        for (auto& pair : pending_packets_)
        {
            auto& pending = pair.second;
            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
                now - pending.send_time);
            
            if (elapsed.count() > 200 && pending.retry_count < 5) // 200ms íƒ€ì„ì•„ì›ƒ
            {
                SendPacket(pending.packet, pending.target);
                pending.send_time = now;
                pending.retry_count++;
            }
            else if (pending.retry_count >= 5)
            {
                // ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ - ì—°ê²° ëŠê¹€ìœ¼ë¡œ ì²˜ë¦¬
                OnConnectionLost(pending.target);
            }
        }
    }

    void OnDataReceived(const std::vector<char>& data, const udp::endpoint& sender)
    {
        // ìƒìœ„ ë ˆì´ì–´ë¡œ ë°ì´í„° ì „ë‹¬
        std::cout << "Received " << data.size() << " bytes from " << sender << std::endl;
    }

    void OnConnectionLost(const udp::endpoint& peer)
    {
        std::cout << "Connection lost to " << peer << std::endl;
    }

    udp::socket socket_;
    udp::endpoint remote_endpoint_;
    std::array<char, 1024> recv_buffer_;
    
    std::atomic<uint32_t> send_sequence_;
    uint32_t recv_sequence_;
    uint32_t recv_bitfield_;
    
    std::unordered_map<uint32_t, PendingPacket> pending_packets_;
    std::mutex pending_mutex_;
    
    std::unique_ptr<boost::asio::steady_timer> ack_timer_;
};
```

ì´ ì½”ë“œëŠ” **UDP ê¸°ë°˜ì´ì§€ë§Œ ì‹ ë¢°ì„±(Reliability)ì„ ë³´ì¥í•˜ëŠ” ì „ì†¡ ê³„ì¸µ**ì„ êµ¬í˜„í•œ ì˜ˆì œë‹¤.
ì¦‰, TCPì˜ ì¼ë¶€ ê¸°ëŠ¥(ì¬ì „ì†¡, ACK, ìˆœì„œ ê´€ë¦¬)ì„ ì§ì ‘ UDP ìœ„ì—ì„œ êµ¬í˜„í•´ **â€œReliable UDPâ€ í”„ë¡œí† ì½œ**ì„ ë§Œë“  ê²ƒì´ë‹¤.
ê²Œì„ ë„¤íŠ¸ì›Œí‚¹, ìŠ¤íŠ¸ë¦¬ë° ë“±ì—ì„œ **ë‚®ì€ ì§€ì—°(latency)**ì„ ìœ ì§€í•˜ë©´ì„œ **ì¼ë¶€ ë°ì´í„°ëŠ” ë°˜ë“œì‹œ ë„ì°©í•´ì•¼ í•˜ëŠ” ìƒí™©**ì— ìœ ìš©í•˜ë‹¤.


### ğŸ“¦ ì „ì²´ êµ¬ì¡° ê°œìš”

| êµ¬ì„± ìš”ì†Œ                                     | ì„¤ëª…                                    |
| ----------------------------------------- | ------------------------------------- |
| **`ReliablePacket`**                      | ì „ì†¡ë˜ëŠ” íŒ¨í‚·ì˜ í—¤ë” êµ¬ì¡°ì²´ (ì‹œí€€ìŠ¤, ACK, ë¹„íŠ¸í•„ë“œ ë“± í¬í•¨) |
| **`PendingPacket`**                       | ì•„ì§ ACKë¥¼ ë°›ì§€ ëª»í•œ ì†¡ì‹  íŒ¨í‚·ì˜ ì •ë³´ (ì¬ì „ì†¡ìš©)        |
| **`pending_packets_`**                    | ì‹œí€€ìŠ¤ ë²ˆí˜¸ë¥¼ í‚¤ë¡œ `PendingPacket` ë³´ê´€í•˜ëŠ” map   |
| **`recv_sequence_`**                      | ë§ˆì§€ë§‰ìœ¼ë¡œ ë°›ì€ íŒ¨í‚·ì˜ ì‹œí€€ìŠ¤ ë²ˆí˜¸                   |
| **`recv_bitfield_`**                      | ìµœê·¼ 32ê°œ íŒ¨í‚·ì˜ ìˆ˜ì‹  ì—¬ë¶€ë¥¼ ë¹„íŠ¸ë¡œ ê¸°ë¡              |
| **`StartAckTimer()`**                     | ì¼ì • ì£¼ê¸°ë¡œ ì¬ì „ì†¡ì„ í™•ì¸í•˜ëŠ” íƒ€ì´ë¨¸(100ms ì£¼ê¸°)        |
| **`SendReliable()` / `SendUnreliable()`** | ì‹ ë¢°ì„± ìˆëŠ” íŒ¨í‚· / ì—†ëŠ” íŒ¨í‚· ì†¡ì‹                   |
| **`ProcessAcknowledgment()`**             | ACK ë° ë¹„íŠ¸í•„ë“œ ê¸°ë°˜ìœ¼ë¡œ ëˆ„ë½ëœ íŒ¨í‚· ê´€ë¦¬             |
| **`ProcessRetransmissions()`**            | ACKë˜ì§€ ì•Šì€ íŒ¨í‚· ì¬ì „ì†¡ ë° ì—°ê²° í•´ì œ ì²˜ë¦¬            |


### ğŸ§© í•µì‹¬ ê°œë… ì •ë¦¬

#### 1ï¸âƒ£ `ReliablePacket` êµ¬ì¡°ì²´

```cpp
struct ReliablePacket {
    uint32_t sequence_number;   // ì†¡ì‹ ìê°€ ì§€ì •í•œ ê³ ìœ  ì‹œí€€ìŠ¤
    uint32_t ack_number;        // ìˆ˜ì‹ ìê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ ë°›ì€ ì‹œí€€ìŠ¤
    uint32_t ack_bitfield;      // ì´ì „ 32ê°œì˜ íŒ¨í‚· ìˆ˜ì‹  ì—¬ë¶€ (1 = ìˆ˜ì‹ )
    bool requires_ack;          // trueë©´ ìˆ˜ì‹  ì‹œ ACKë¥¼ ë³´ë‚´ì•¼ í•¨
    uint32_t data_size;         // payload í¬ê¸°
};
```

â¡ï¸ **TCPì˜ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°** ê°œë…ì„ ê°„ë‹¨íˆ êµ¬í˜„í•œ ê²ƒ
ì¦‰, ì†¡ì‹ ì-ìˆ˜ì‹ ìê°€ ì„œë¡œ ì‹œí€€ìŠ¤ ìƒíƒœë¥¼ êµí™˜í•˜ì—¬ ëˆ„ë½ëœ íŒ¨í‚·ì„ íŒë‹¨í•  ìˆ˜ ìˆë‹¤.

#### 2ï¸âƒ£ ì‹ ë¢°ì„± ì „ì†¡ (`SendReliable`)
1. íŒ¨í‚· í—¤ë”(`ReliablePacket`) ìƒì„±
2. `requires_ack = true`ë¡œ ì„¤ì •
3. ë°ì´í„°(payload) ë³µì‚¬
4. `SendPacket()`ìœ¼ë¡œ ì‹¤ì œ ì†¡ì‹ 
5. `pending_packets_`ì— ë³´ê´€í•˜ì—¬ ACK ëŒ€ê¸°

```cpp
pending_packets_[seq] = {packet, target, seq, now, 0};
```

â¡ï¸ ACKê°€ ì˜¤ë©´ í•´ë‹¹ ì‹œí€€ìŠ¤ë¥¼ ì‚­ì œí•˜ê³ , ì˜¤ì§€ ì•Šìœ¼ë©´ ì¬ì „ì†¡í•œë‹¤.


#### 3ï¸âƒ£ ë¹„ì‹ ë¢°ì„± ì „ì†¡ (`SendUnreliable`)
ë‹¨ìˆœíˆ UDP ì „ì†¡ë§Œ ìˆ˜í–‰. ACK ë³´ê´€í•˜ì§€ ì•ŠëŠ”ë‹¤.
â†’ ê²Œì„ì—ì„œ â€œì¦‰ì‹œì„±â€ì´ ì¤‘ìš”í•˜ê³ , ìœ ì‹¤ë¼ë„ ê´œì°®ì€ ë°ì´í„°(ì˜ˆ: ìœ„ì¹˜ ì—…ë°ì´íŠ¸)ì— ì‚¬ìš© ê°€ëŠ¥.


#### 4ï¸âƒ£ ìˆ˜ì‹  ë° ACK ì²˜ë¦¬

`HandleIncomingPacket()` íë¦„  

1. íŒ¨í‚· í—¤ë” í•´ì„
2. `ProcessAcknowledgment()`ë¡œ ìƒëŒ€ê°€ ë³´ë‚¸ ACK ì²˜ë¦¬
3. `IsNewPacket()`ìœ¼ë¡œ ì¤‘ë³µ ì²´í¬
4. ìƒˆ íŒ¨í‚·ì´ë©´ `OnDataReceived()` í˜¸ì¶œ
5. `requires_ack`ë©´ ACK ì‘ë‹µ ì†¡ì‹ 

```cpp
if (header->requires_ack) {
    SendAcknowledgment(remote_endpoint_);
}
```

â¡ï¸ ì´ë ‡ê²Œ ìˆ˜ì‹ ìê°€ ë°œì†¡ìì—ê²Œ â€œì§€ê¸ˆê¹Œì§€ ì´ íŒ¨í‚·ë“¤ì„ ì˜ ë°›ì•˜ë‹¤â€ëŠ” ì •ë³´ë¥¼ ê³„ì† ë³´ë‚´ì¤€ë‹¤.


#### 5ï¸âƒ£ ACK ì‘ë‹µ íŒ¨í‚· ì „ì†¡
`SendAcknowledgment()`ëŠ” ìˆ˜ì‹ ìì˜ í˜„ì¬ ìƒíƒœë¥¼ ì†¡ì‹ ìì—ê²Œ ë³´ê³ í•œë‹¤:

```cpp
ack_packet.ack_number = recv_sequence_;
ack_packet.ack_bitfield = recv_bitfield_;
```

â¡ï¸ `recv_bitfield_`ì€ **ìµœê·¼ 32ê°œì˜ íŒ¨í‚· ìˆ˜ì‹  ì—¬ë¶€**ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.
ì´ë¡œì¨ ìˆ˜ì‹ ìëŠ” **ë‹¨ì¼ ACKë¡œ ì—¬ëŸ¬ íŒ¨í‚·ì˜ ìˆ˜ì‹  ìƒíƒœë¥¼ í‘œí˜„**í•  ìˆ˜ ìˆë‹¤.


#### 6ï¸âƒ£ ì¬ì „ì†¡ ë©”ì»¤ë‹ˆì¦˜ (`ProcessRetransmissions`)
* 100ms ì£¼ê¸° íƒ€ì´ë¨¸ (`StartAckTimer`)ê°€ ì‹¤í–‰
* `pending_packets_`ì„ ìˆœíšŒí•˜ë©°:

  * ë§ˆì§€ë§‰ ì „ì†¡ í›„ 200ms ì´ìƒ ì§€ë‚¨ â†’ ì¬ì „ì†¡
  * ì¬ì‹œë„ 5íšŒ ì´ˆê³¼ ì‹œ ì—°ê²° ëŠê¹€ ì²˜ë¦¬ (`OnConnectionLost()`)

```cpp
if (elapsed.count() > 200 && pending.retry_count < 5)
    SendPacket(pending.packet, pending.target);
```

â¡ï¸ UDPëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì¬ì „ì†¡ì´ ì—†ê¸° ë•Œë¬¸ì— ì´ íƒ€ì´ë¨¸ê°€ í•µì‹¬ì´ë‹¤.


### ğŸ” ìˆœì„œ ë° ì¤‘ë³µ ì²˜ë¦¬

#### `IsNewPacket(sequence)`
ì‹œí€€ìŠ¤ ë²ˆí˜¸ê°€ ì´ì „ë³´ë‹¤ í° ê²½ìš° (ë˜ëŠ” wrap-around ê³ ë ¤) ìƒˆ íŒ¨í‚·ìœ¼ë¡œ ê°„ì£¼.
ì´ë¯¸ ë°›ì€ íŒ¨í‚·ì€ ë¬´ì‹œí•˜ì—¬ **ì¤‘ë³µ ì „ì†¡ ë¬¸ì œ**ë¥¼ í•´ê²°í•œë‹¤.

#### `MarkPacketReceived(sequence)`
* `recv_sequence_`ë¥¼ ê°±ì‹ 
* ìˆ˜ì‹ ëœ ì‹œí€€ìŠ¤ì— ëŒ€í•´ `recv_bitfield_`ì˜ í•´ë‹¹ ë¹„íŠ¸ë¥¼ 1ë¡œ ì„¤ì •

â¡ï¸ ì´ ë¹„íŠ¸í•„ë“œëŠ” ë‚˜ì¤‘ì— `SendAcknowledgment()`ì—ì„œ ì‚¬ìš©ë˜ì–´ ìƒëŒ€ë°©ì—ê²Œ ì „ë‹¬ëœë‹¤.


### ğŸ§  ì „ì²´ ë™ì‘ ìš”ì•½
1. ì†¡ì‹ ìëŠ” `SendReliable()`ë¡œ íŒ¨í‚·ì„ ë³´ëƒ„.
   â†’ `pending_packets_`ì— ì €ì¥, ACK ëŒ€ê¸°.
2. ìˆ˜ì‹ ìëŠ” ìƒˆ íŒ¨í‚·ì„ ë°›ìœ¼ë©´ `MarkPacketReceived()` í›„ ACK ì „ì†¡.
3. ì†¡ì‹ ìëŠ” `ProcessAcknowledgment()`ì—ì„œ ACK í™•ì¸ í›„ `pending_packets_`ì—ì„œ ì œê±°.
4. íƒ€ì´ë¨¸(`StartAckTimer`)ëŠ” 100msë§ˆë‹¤ ì¬ì „ì†¡ ê²€ì‚¬.
5. ì¬ì‹œë„ 5íšŒ ì´ˆê³¼ ì‹œ ì—°ê²° í•´ì œ ì²˜ë¦¬.

  
### ğŸ•¸ ì½”ë“œ íë¦„ ë‹¤ì´ì–´ê·¸ë¨ (Mermaid)

```mermaid
sequenceDiagram
    participant Sender as ReliableUDP (ì†¡ì‹ ì)
    participant Receiver as ReliableUDP (ìˆ˜ì‹ ì)
    participant Timer as AckTimer

    Note over Sender,Receiver: ReliableUDP í†µì‹  íë¦„

    Sender->>Receiver: SendReliable() â†’ ReliablePacket(Seq=N, requires_ack=true)
    Receiver->>Receiver: HandleIncomingPacket()
    Receiver->>Receiver: MarkPacketReceived(N)
    Receiver->>Sender: SendAcknowledgment(Ack=N, AckBitfield=recent 32)

    Sender->>Sender: ProcessAcknowledgment(Ack=N)
    Sender->>Sender: pending_packets_[N] ì œê±°

    Note over Timer: 100ms ì£¼ê¸° íƒ€ì´ë¨¸ ì‘ë™
    Timer->>Sender: ProcessRetransmissions()
    alt ACK ëˆ„ë½
        Sender->>Receiver: ì¬ì „ì†¡ (Retry++)
    else ì¬ì‹œë„ 5íšŒ ì´ˆê³¼
        Sender->>Sender: OnConnectionLost()
    end

    Receiver->>Receiver: OnDataReceived() í˜¸ì¶œ
```

### ğŸ“‹ ì£¼ìš” ë™ì‘ ì •ë¦¬í‘œ

| í•­ëª©          | ì—­í•                                        |
| ----------- | ---------------------------------------- |
| **ACK ì‹œìŠ¤í…œ** | `ack_number` + `ack_bitfield`ë¡œ ëˆ„ë½ëœ íŒ¨í‚· ì¶”ì  |
| **ì¬ì „ì†¡ íƒ€ì´ë¨¸** | 100msë§ˆë‹¤ ì‹¤í–‰, 200ms ì´ìƒ ë¯¸ì‘ë‹µ ì‹œ ì¬ì „ì†¡           |
| **ì‹ ë¢°ì„± ì „ì†¡**  | `requires_ack=true`, pending ëª©ë¡ ë³´ê´€       |
| **ë¹„ì‹ ë¢°ì„± ì „ì†¡** | `requires_ack=false`, ì¦‰ì‹œ ì†¡ì‹               |
| **ìˆ˜ì‹  ë¹„íŠ¸í•„ë“œ** | ìµœê·¼ 32ê°œì˜ ìˆ˜ì‹  ìƒíƒœ ê¸°ë¡ ë° ACKë¡œ ë°˜ì˜               |
| **ì‹œí€€ìŠ¤ ë¹„êµ**  | wrap-around ëŒ€ì‘, ì¤‘ë³µ íŒ¨í‚· ë¬´ì‹œ                 |
| **ì—°ê²° ê´€ë¦¬**   | 5íšŒ ì´ìƒ ì¬ì „ì†¡ ì‹œ ì—°ê²° ëŠê¹€ ì²˜ë¦¬                     |


### ğŸ’¡ ìš”ì•½
`ReliableUDP`ëŠ” UDPì˜ ì¥ì (ì €ì§€ì—°)ì„ ìœ ì§€í•˜ë©´ì„œ TCPì˜ ì¼ë¶€ ì‹ ë¢°ì„± ê¸°ëŠ¥(ACK, ì¬ì „ì†¡, ìˆœì„œ ë³´ì¥)ì„ ì§ì ‘ êµ¬í˜„í•œ ê³„ì¸µì´ë‹¤.
ì´ êµ¬ì¡°ëŠ” **ê²Œì„ ì„œë²„, ìŒì„± ì±„íŒ…, IoT ì „ì†¡** ë“±ì—ì„œ í”íˆ ì‚¬ìš©ëœë‹¤.

â¡ï¸ í•µì‹¬ ì•„ì´ë””ì–´:

* **ë¹„íŠ¸í•„ë“œ ê¸°ë°˜ ACK** â†’ ë‹¤ìˆ˜ íŒ¨í‚· ìƒíƒœë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ë³´ê³ 
* **íƒ€ì´ë¨¸ ê¸°ë°˜ ì¬ì „ì†¡** â†’ UDP ì‹ ë¢°ì„± í™•ë³´
* **ë¹„ë™ê¸° êµ¬ì¡° (Boost.Asio)** â†’ ì´ë²¤íŠ¸ ê¸°ë°˜ ê³ ì„±ëŠ¥ í†µì‹ 

ì¦‰, ì´ í´ë˜ìŠ¤ëŠ” â€œ**TCPì˜ ì‹ ë¢°ì„±ì„ UDPì˜ ì†ë„ë¡œ êµ¬í˜„í•œ ë¯¸ë‹ˆ í”„ë¡œí† ì½œ ìŠ¤íƒ**â€ì´ë¼ê³  í•  ìˆ˜ ìˆë‹¤.



</br>  

## ì •ë¦¬

ì´ë²ˆ ì¥ì—ì„œëŠ” Boost.Asioë¥¼ í™œìš©í•œ UDP í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•´ ìì„¸íˆ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤. ì£¼ìš” ë‚´ìš©ì„ ìš”ì•½í•˜ë©´:

1. **UDPì˜ íŠ¹ì„±ê³¼ í™œìš©**: ë¹ ë¥¸ ì „ì†¡ ì†ë„ì™€ ë‚®ì€ ì§€ì—°ì‹œê°„ì„ ì œê³µí•˜ì§€ë§Œ ì‹ ë¢°ì„± ë³´ì¥ì´ ì—†ëŠ” UDPì˜ íŠ¹ì„±ì„ ì´í•´í–ˆìŠµë‹ˆë‹¤.

2. **ë¹„ë™ê¸° UDP ì„œë²„/í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„**: Boost.Asioë¥¼ ì‚¬ìš©í•˜ì—¬ ê²Œì„ ì„œë²„ì— ì í•©í•œ UDP í†µì‹ ì„ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí–ˆìŠµë‹ˆë‹¤.

3. **UDPì™€ TCPì˜ ë¹„êµ**: ê° í”„ë¡œí† ì½œì˜ ì¥ë‹¨ì ê³¼ ê²Œì„ ê¸°ëŠ¥ë³„ ì ì ˆí•œ í”„ë¡œí† ì½œ ì„ íƒ ê¸°ì¤€ì„ ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.

4. **ê²Œì„ì—ì„œì˜ UDP í™œìš© ì‚¬ë¡€**: ì‹¤ì‹œê°„ ìœ„ì¹˜ ë™ê¸°í™”, ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸, ë§¤ì¹˜ë©”ì´í‚¹, ì‹ ë¢°ì„± ìˆëŠ” UDP êµ¬í˜„ ë“± ì‹¤ì œ ê²Œì„ ê°œë°œì—ì„œ í™œìš©í•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ì˜ˆì œë¥¼ ë‹¤ë¤˜ìŠµë‹ˆë‹¤.

UDPëŠ” ì‹¤ì‹œê°„ ê²Œì„ì—ì„œ í•„ìˆ˜ì ì¸ í”„ë¡œí† ì½œì´ë©°, ì ì ˆíˆ í™œìš©í•˜ë©´ ë›°ì–´ë‚œ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì¥ì—ì„œëŠ” ì±„íŒ… ì„œë²„ êµ¬í˜„ì„ í†µí•´ ì‹¤ì „ ê²Œì„ ì„œë²„ ê°œë°œ ê¸°ë²•ì„ í•™ìŠµí•˜ê² ìŠµë‹ˆë‹¤.


 
  
  