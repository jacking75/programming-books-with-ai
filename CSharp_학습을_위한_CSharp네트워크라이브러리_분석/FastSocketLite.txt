Directory structure:
└── edu_FastSocketLite/
    ├── README.md
    ├── FastSocketLite.Server.sln
    ├── FastSocketLite.SocketBase.sln
    ├── Samples/
    │   ├── EchoServer.sln
    │   └── EchoServer/
    │       ├── App.config
    │       ├── EchoServer.csproj
    │       ├── EchoService.cs
    │       └── Program.cs
    ├── Server/
    │   ├── AbsSocketService.cs
    │   ├── AbsUdpService.cs
    │   ├── FastSocketLite.Server.csproj
    │   ├── ISocketListener.cs
    │   ├── ISocketService.cs
    │   ├── IUdpServer.cs
    │   ├── IUdpService.cs
    │   ├── SocketListener.cs
    │   ├── SocketServer.cs
    │   ├── SocketServerManager.cs
    │   ├── UdpAsyncSendPool.cs
    │   ├── UdpServer.cs
    │   ├── UdpSession.cs
    │   ├── Config/
    │   │   ├── Server.cs
    │   │   ├── ServerCollection.cs
    │   │   └── SocketServerConfig.cs
    │   ├── Messaging/
    │   │   ├── CommandLineMessage.cs
    │   │   ├── DefaultBinaryMessage.cs
    │   │   ├── IMessage.cs
    │   │   └── ThriftMessage.cs
    │   └── Protocol/
    │       ├── BadProtocolException.cs
    │       ├── CommandLineProtocol.cs
    │       ├── DefaultBinaryProtocol.cs
    │       ├── IProtocol.cs
    │       ├── IUdpProtocol.cs
    │       ├── ProtocolNames.cs
    │       └── ThriftProtocol.cs
    └── SocketBase/
        ├── BaseHost.cs
        ├── ConnectionCollection.cs
        ├── DefaultConnection.cs
        ├── DisconnectedHandler.cs
        ├── FastSocketLite.SocketBase.csproj
        ├── IConnection.cs
        ├── IHost.cs
        ├── MessageReceivedEventArgs.cs
        ├── Packet.cs
        ├── PacketQueue.cs
        ├── SocketAsyncEventArgsPool.cs
        ├── Log/
        │   ├── ConsoleListener.cs
        │   ├── DiagnosticListener.cs
        │   ├── ITraceListener.cs
        │   ├── ListenerWrapper.cs
        │   ├── NLogListener.cs
        │   └── Trace.cs
        └── Utils/
            ├── ConsistentHashContainer.cs
            ├── Date.cs
            ├── IPUtility.cs
            ├── NetworkBitConverter.cs
            └── ReflectionHelper.cs

================================================
FILE: README.md
================================================
# FastSocketList
FastSocket.Net(https://github.com/ihaoqihao/FastSocket.Net)을 .NET Core로 포팅한 것이다.
  
## TODO
- [] .NET Core 및 C# 최신 버전의 기능 적용
- [] 샘플 코드 만들기
- [] 기능 추가
- [] 대규모 더미 클라이언트 테스트
- [] 프로파일링을 통한 최적화 작업  


================================================
FILE: FastSocketLite.Server.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.168
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "FastSocketLite.Server", "Server\FastSocketLite.Server.csproj", "{214C7042-0ADE-4370-B27A-A3B1E419B389}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "FastSocketLite.SocketBase", "SocketBase\FastSocketLite.SocketBase.csproj", "{49AA183C-DFA3-47C9-9E86-CE11EBFE1C2B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{214C7042-0ADE-4370-B27A-A3B1E419B389}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{214C7042-0ADE-4370-B27A-A3B1E419B389}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{214C7042-0ADE-4370-B27A-A3B1E419B389}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{214C7042-0ADE-4370-B27A-A3B1E419B389}.Release|Any CPU.Build.0 = Release|Any CPU
		{49AA183C-DFA3-47C9-9E86-CE11EBFE1C2B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{49AA183C-DFA3-47C9-9E86-CE11EBFE1C2B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{49AA183C-DFA3-47C9-9E86-CE11EBFE1C2B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{49AA183C-DFA3-47C9-9E86-CE11EBFE1C2B}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B11F23AA-5C3C-407B-A6A9-9CF71357CF70}
	EndGlobalSection
EndGlobal



================================================
FILE: FastSocketLite.SocketBase.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.168
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "FastSocketLite.SocketBase", "SocketBase\FastSocketLite.SocketBase.csproj", "{614A13BD-BE9F-4304-A239-E63EC005F6DC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{614A13BD-BE9F-4304-A239-E63EC005F6DC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{614A13BD-BE9F-4304-A239-E63EC005F6DC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{614A13BD-BE9F-4304-A239-E63EC005F6DC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{614A13BD-BE9F-4304-A239-E63EC005F6DC}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CBF6ACD8-64DE-48AB-9526-FB421203A9E9}
	EndGlobalSection
EndGlobal



================================================
FILE: Samples/EchoServer.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.168
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "EchoServer", "EchoServer\EchoServer.csproj", "{0C240F46-AB61-452F-938C-D0179CAB4347}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "FastSocketLite.SocketBase", "..\SocketBase\FastSocketLite.SocketBase.csproj", "{4B597173-4E33-4564-BDF1-4946322648E4}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "FastSocketLite.Server", "..\Server\FastSocketLite.Server.csproj", "{9101086D-B7E2-4990-B0D5-11CBEF09DC48}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0C240F46-AB61-452F-938C-D0179CAB4347}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0C240F46-AB61-452F-938C-D0179CAB4347}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0C240F46-AB61-452F-938C-D0179CAB4347}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0C240F46-AB61-452F-938C-D0179CAB4347}.Release|Any CPU.Build.0 = Release|Any CPU
		{4B597173-4E33-4564-BDF1-4946322648E4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4B597173-4E33-4564-BDF1-4946322648E4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4B597173-4E33-4564-BDF1-4946322648E4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4B597173-4E33-4564-BDF1-4946322648E4}.Release|Any CPU.Build.0 = Release|Any CPU
		{9101086D-B7E2-4990-B0D5-11CBEF09DC48}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9101086D-B7E2-4990-B0D5-11CBEF09DC48}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9101086D-B7E2-4990-B0D5-11CBEF09DC48}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9101086D-B7E2-4990-B0D5-11CBEF09DC48}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {868FB565-C408-47FC-B54A-3B7986DFF32E}
	EndGlobalSection
EndGlobal



================================================
FILE: Samples/EchoServer/App.config
================================================
﻿<?xml version="1.0" encoding="utf-8" ?>
<configuration>

  <configSections>
    <section name="socketServer"
             type="FastSocketLite.Server.Config.SocketServerConfig, FastSocketLite.Server"/>
  </configSections>

  <socketServer>
    <servers>
      <!-- serviceType은 네임스페이스.클래스, 네임스페이스 -->
      <server name="EchoServer"
              port="11021"
              socketBufferSize="8192"
              messageBufferSize="8192"
              maxMessageSize="102400"
              maxConnections="20000"
              serviceType="EchoServer.EchoService, EchoServer"
              protocol="commandLine"/>
    </servers>
  </socketServer>

</configuration>


================================================
FILE: Samples/EchoServer/EchoServer.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\Server\FastSocketLite.Server.csproj" />
    <ProjectReference Include="..\..\SocketBase\FastSocketLite.SocketBase.csproj" />
  </ItemGroup>

</Project>



================================================
FILE: Samples/EchoServer/EchoService.cs
================================================
癤퓎sing System;
using System.Collections.Generic;
using System.Text;
using FastSocketLite.Server;
using FastSocketLite.Server.Messaging;
using FastSocketLite.SocketBase;

namespace EchoServer
{
    public class EchoService : AbsSocketService<CommandLineMessage>
    {
        public override void OnConnected(IConnection connection)
        {
            base.OnConnected(connection);
            Console.WriteLine(connection.RemoteEndPoint.ToString() + " " + connection.ConnectionID.ToString() + " connected");
            connection.BeginReceive();
        }

        public override void OnReceived(IConnection connection, CommandLineMessage message)
        {
            base.OnReceived(connection, message);
            switch (message.CmdName)
            {
                case "echo":
                    message.Reply(connection, "echo_reply " + message.Parameters[0]);
                    break;
                case "init":
                    Console.WriteLine("connection:" + connection.ConnectionID.ToString() + " init");
                    message.Reply(connection, "init_reply ok");
                    break;
                default:
                    message.Reply(connection, "error unknow command ");
                    break;
            }
        }

        public override void OnDisconnected(IConnection connection, Exception ex)
        {
            base.OnDisconnected(connection, ex);
            Console.WriteLine(connection.RemoteEndPoint.ToString() + " disconnected");
        }

        public override void OnException(IConnection connection, Exception ex)
        {
            base.OnException(connection, ex);
            Console.WriteLine(ex.ToString());
        }
    }
}



================================================
FILE: Samples/EchoServer/Program.cs
================================================
﻿using FastSocketLite.Server;
using FastSocketLite.SocketBase;
using System;

namespace EchoServer
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                SocketServerManager.Init();
                SocketServerManager.Start();

                //10 초마다 모든 연결이 끊어 지도록 한다.
                System.Threading.Tasks.Task.Factory.StartNew(() =>
                {
                    while (true)
                    {
                        System.Threading.Thread.Sleep(1000 * 10);
                        IHost host;
                        if (SocketServerManager.TryGetHost("quickStart", out host))
                        {
                            var arr = host.ListAllConnection();
                            foreach (var c in arr)
                            {
                                c.BeginDisconnect();
                            }
                        }
                    }
                });

                Console.ReadLine();
            }
            catch(Exception ex)
            {
                Console.WriteLine($"[Exception: {ex.ToString()}");
            }
        }
    }
}



================================================
FILE: Server/AbsSocketService.cs
================================================
﻿using System;

namespace FastSocketLite.Server
{
    /// <summary>
    /// abstract socket service interface.
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public abstract class AbsSocketService<TMessage> : ISocketService<TMessage>
        where TMessage : class, Messaging.IMessage
    {
        /// <summary>
        /// 이 메소드는 소켓 연결이 설정 될 때 호출된다.
        /// </summary>
        /// <param name="connection"></param>
        public virtual void OnConnected(SocketBase.IConnection connection)
        {
        }
        
        public virtual void OnSendCallback(SocketBase.IConnection connection, SocketBase.Packet packet, bool isSuccess)
        {
        }

        /// <summary>
        /// 이 메소드는 새로운 클라이언트 메시지가 수신 될 때 호출된다.
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="message"></param>
        public virtual void OnReceived(SocketBase.IConnection connection, TMessage message)
        {
        }
        /// <summary>
        /// 이 메소드는 소켓 연결이 끊어지면 호출된다.
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="ex"></param>
        public virtual void OnDisconnected(SocketBase.IConnection connection, Exception ex)
        {
        }

        /// <summary>
        /// 이 메소드는 예외가 발생할 때 호출된다.
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="ex"></param>
        public virtual void OnException(SocketBase.IConnection connection, Exception ex)
        {
        }
    }
}


================================================
FILE: Server/AbsUdpService.cs
================================================
癤퓎sing System;

namespace FastSocketLite.Server
{
    /// <summary>
    /// udp service
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public abstract class AbsUdpService<TMessage> : IUdpService<TMessage>
        where TMessage : class, Messaging.IMessage
    {
        public virtual void OnReceived(UdpSession session, TMessage message)
        {
        }
        
        public virtual void OnError(UdpSession session, Exception ex)
        {
        }
    }
}


================================================
FILE: Server/FastSocketLite.Server.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="System.Configuration.ConfigurationManager" Version="9.0.0" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\SocketBase\FastSocketLite.SocketBase.csproj" />
  </ItemGroup>
</Project>


================================================
FILE: Server/ISocketListener.cs
================================================
癤퓎sing System;
using System.Net;

namespace FastSocketLite.Server
{
    /// <summary>
    /// socket listener
    /// </summary>
    public interface ISocketListener
    {
        /// <summary>
        /// socket accepted event
        /// </summary>
        event Action<SocketBase.IConnection> Accepted;

        EndPoint EndPoint { get; }

        void Start();
        
        void Stop();
    }
}


================================================
FILE: Server/ISocketService.cs
================================================
﻿using System;

namespace FastSocketLite.Server
{
    /// <summary>
    /// socket service interface.
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public interface ISocketService<TMessage> where TMessage : class, Messaging.IMessage
    {
        /// <summary>
        /// 이 메소드는 소켓 연결이 설정 될 때 호출된다.
        /// </summary>
        /// <param name="connection"></param>
        void OnConnected(SocketBase.IConnection connection);

        void OnSendCallback(SocketBase.IConnection connection, SocketBase.Packet packet, bool isSuccess);

        /// <summary>
        ///이 메소드는 새로운 클라이언트 메시지가 수신 될 때 호출된다.
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="message"></param>
        void OnReceived(SocketBase.IConnection connection, TMessage message);

        /// <summary>
        /// 이 메소드는 소켓 연결이 끊어지면 호출된다.
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="ex"></param>
        void OnDisconnected(SocketBase.IConnection connection, Exception ex);

        /// <summary>
        /// 이 메소드는 예외가 발생할 때 호출된다.
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="ex"></param>
        void OnException(SocketBase.IConnection connection, Exception ex);
    }
}


================================================
FILE: Server/IUdpServer.cs
================================================
癤퓎sing System.Net;

namespace FastSocketLite.Server
{
    /// <summary>
    /// upd server interface
    /// </summary>
    public interface IUdpServer
    {
        void Start();
        
        void Stop();
        
        void SendTo(EndPoint endPoint, byte[] payload);
    }

    /// <summary>
    /// upd server interface
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public interface IUdpServer<TMessage> : IUdpServer  where TMessage : class, Messaging.IMessage
    {
    }
}


================================================
FILE: Server/IUdpService.cs
================================================
癤퓎sing System;

namespace FastSocketLite.Server
{
    /// <summary>
    /// udp service interface.
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public interface IUdpService<TMessage> where TMessage : class, Messaging.IMessage
    {
        void OnReceived(UdpSession session, TMessage message);
        
        void OnError(UdpSession session, Exception ex);
    }
}


================================================
FILE: Server/SocketListener.cs
================================================
癤퓎sing System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace FastSocketLite.Server
{
    /// <summary>
    /// socket listener
    /// </summary>
    public sealed class SocketListener : ISocketListener
    {
        private readonly SocketBase.IHost _host = null;
        private const int BACKLOG = 500;
        private Socket _socket = null;
        private readonly SocketAsyncEventArgs _ae = null;
        

        
        /// <summary>
        /// new
        /// </summary>
        /// <param name="endPoint"></param>
        /// <param name="host"></param>
        /// <exception cref="ArgumentNullException">endPoint is null</exception>
        /// <exception cref="ArgumentNullException">host is null</exception>
        public SocketListener(IPEndPoint endPoint, SocketBase.IHost host)
        {
            if (endPoint == null)
            {
                throw new ArgumentNullException("endPoint");
            }

            if (host == null)
            {
                throw new ArgumentNullException("host");
            }

            this.EndPoint = endPoint;
            this._host = host;

            this._ae = new SocketAsyncEventArgs();
            this._ae.Completed += this.AcceptCompleted;
        }
        

        
        /// <summary>
        /// socket accepted event
        /// </summary>
        public event Action<SocketBase.IConnection> Accepted;
        
        public EndPoint EndPoint { get; private set; }
        
        public void Start()
        {
            if (this._socket == null)
            {
                this._socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                this._socket.Bind(this.EndPoint);
                this._socket.Listen(BACKLOG);

                this.AcceptAsync(this._socket);
            }
        }
        public void Stop()
        {
            if (this._socket != null)
            {
                this._socket.Close();
                this._socket = null;
            }
        }
        

        
        /// <summary>
        /// accept socket.
        /// </summary>
        /// <param name="socket"></param>
        private void AcceptAsync(Socket socket)
        {
            if (socket == null)
            {
                return;
            }

            bool completed = true;
            try
            {
                completed = this._socket.AcceptAsync(this._ae);
            }
            catch (Exception ex)
            {
                SocketBase.Log.Trace.Error(ex.Message, ex);
            }

            if (!completed)
            {
                ThreadPool.QueueUserWorkItem(_ => this.AcceptCompleted(this, this._ae));
            }
        }
        /// <summary>
        /// async accept socket completed handle.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void AcceptCompleted(object sender, SocketAsyncEventArgs e)
        {
            Socket accepted = null;
            if (e.SocketError == SocketError.Success)
            {
                accepted = e.AcceptSocket;
            }

            e.AcceptSocket = null;

            if (accepted != null)
            {
                this.Accepted(this._host.NewConnection(accepted));
            }

            //continue to accept!
            this.AcceptAsync(this._socket);
        }
        
    }
}


================================================
FILE: Server/SocketServer.cs
================================================
癤퓎sing System;
using System.Net;

namespace FastSocketLite.Server
{
    /// <summary>
    /// socket server.
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public class SocketServer<TMessage> : SocketBase.BaseHost where TMessage : class, Messaging.IMessage
    {        
        private readonly SocketListener _listener = null;
        private readonly ISocketService<TMessage> _socketService = null;
        private readonly Protocol.IProtocol<TMessage> _protocol = null;
        private readonly int _maxMessageSize;
        private readonly int _maxConnections;
        

        
        /// <summary>
        /// new
        /// </summary>
        /// <param name="port"></param>
        /// <param name="socketService"></param>
        /// <param name="protocol"></param>
        /// <param name="socketBufferSize"></param>
        /// <param name="messageBufferSize"></param>
        /// <param name="maxMessageSize"></param>
        /// <param name="maxConnections"></param>
        /// <exception cref="ArgumentNullException">socketService is null.</exception>
        /// <exception cref="ArgumentNullException">protocol is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">maxMessageSize</exception>
        /// <exception cref="ArgumentOutOfRangeException">maxConnections</exception>
        public SocketServer(int port,
            ISocketService<TMessage> socketService,
            Protocol.IProtocol<TMessage> protocol,
            int socketBufferSize,
            int messageBufferSize,
            int maxMessageSize,
            int maxConnections)
            : base(socketBufferSize, messageBufferSize)
        {
            if (socketService == null)
            {
                throw new ArgumentNullException("socketService");
            }

            if (protocol == null)
            {
                throw new ArgumentNullException("protocol");
            }

            if (maxMessageSize < 1)
            {
                throw new ArgumentOutOfRangeException("maxMessageSize");
            }

            if (maxConnections < 1)
            {
                throw new ArgumentOutOfRangeException("maxConnections");
            }

            this._socketService = socketService;
            this._protocol = protocol;
            this._maxMessageSize = maxMessageSize;
            this._maxConnections = maxConnections;

            this._listener = new SocketListener(new IPEndPoint(IPAddress.Any, port), this);
            this._listener.Accepted += this.OnAccepted;
        }
        

        /// <summary>
        /// socket accepted handler
        /// </summary>
        /// <param name="connection"></param>
        private void OnAccepted(SocketBase.IConnection connection)
        {
            if (base.CountConnection() < this._maxConnections)
            {
                base.RegisterConnection(connection);
                return;
            }

            SocketBase.Log.Trace.Info("too many connections.");
            connection.BeginDisconnect();
        }
        

        
        public override void Start()
        {
            base.Start();
            this._listener.Start();
        }

        public override void Stop()
        {
            this._listener.Stop();
            base.Stop();
        }
        
        override public void OnConnected(SocketBase.IConnection connection)
        {
            base.OnConnected(connection);
            this._socketService.OnConnected(connection);
        }
                
        override public void OnSendCallback(SocketBase.IConnection connection,
            SocketBase.Packet packet, bool isSuccess)
        {
            base.OnSendCallback(connection, packet, isSuccess);
            this._socketService.OnSendCallback(connection, packet, isSuccess);
        }
                
        override public void OnMessageReceived(SocketBase.IConnection connection,
            SocketBase.MessageReceivedEventArgs e)
        {
            base.OnMessageReceived(connection, e);

            int readlength;
            TMessage message = null;
            try
            {
                message = this._protocol.Parse(connection, e.Buffer, this._maxMessageSize, out readlength);
            }
            catch (Exception ex)
            {
                this.OnConnectionError(connection, ex);
                connection.BeginDisconnect(ex);
                e.SetReadlength(e.Buffer.Count);
                return;
            }

            if (message != null)
            {
                this._socketService.OnReceived(connection, message);
            }

            e.SetReadlength(readlength);
        }

        override public void OnDisconnected(SocketBase.IConnection connection, Exception ex)
        {
            base.OnDisconnected(connection, ex);
            this._socketService.OnDisconnected(connection, ex);
        }

        override public void OnConnectionError(SocketBase.IConnection connection, Exception ex)
        {
            base.OnConnectionError(connection, ex);
            this._socketService.OnException(connection, ex);
        }
        
    }
}


================================================
FILE: Server/SocketServerManager.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;

namespace FastSocketLite.Server
{
    /// <summary>
    /// Socket server manager.
    /// </summary>
    public class SocketServerManager
    {
        /// <summary>
        /// key:server name.
        /// </summary>
        static private readonly Dictionary<string, SocketBase.IHost> _dicHosts = new Dictionary<string, SocketBase.IHost>();
        

        /// <summary>
        /// 初始化Socket Server
        /// </summary>
        static public void Init()
        {
            Init("socketServer");
        }
        /// <summary>
        /// Socket Server 초기화
        /// </summary>
        /// <param name="sectionName"></param>
        static public void Init(string sectionName)
        {
            if (string.IsNullOrEmpty(sectionName))
            {
                throw new ArgumentNullException("sectionName");
            }

            Init(ConfigurationManager.GetSection(sectionName) as Config.SocketServerConfig);
        }
        
        static void Init(Config.SocketServerConfig config)
        {
            if (config == null)
            {
                throw new ArgumentNullException("config");
            }

            if (config.Servers == null)
            {
                return;
            }

            foreach (Config.Server serverConfig in config.Servers)
            {
                //inti protocol
                var objProtocol = GetProtocol(serverConfig.Protocol);
                if (objProtocol == null)
                {
                    throw new InvalidOperationException("protocol");
                }

                //init custom service
                var tService = Type.GetType(serverConfig.ServiceType, false);
                if (tService == null)
                {
                    throw new InvalidOperationException("serviceType");
                }

                var objService = Activator.CreateInstance(tService);
                if (objService == null)
                {
                    throw new InvalidOperationException("serviceType");
                }

                //init host.
                _dicHosts.Add(serverConfig.Name, Activator.CreateInstance(
                    typeof(SocketServer<>).MakeGenericType(
                    objProtocol.GetType().GetInterface(typeof(Protocol.IProtocol<>).Name).GetGenericArguments()),
                        serverConfig.Port,
                        objService,
                        objProtocol,
                        serverConfig.SocketBufferSize,
                        serverConfig.MessageBufferSize,
                        serverConfig.MaxMessageSize,
                        serverConfig.MaxConnections) as SocketBase.IHost);
            }
        }
        
        static public object GetProtocol(string protocol)
        {
            switch (protocol)
            {
                case Protocol.ProtocolNames.Thrift: return new Protocol.ThriftProtocol();
                case Protocol.ProtocolNames.CommandLine: return new Protocol.CommandLineProtocol();
            }
            return Activator.CreateInstance(Type.GetType(protocol, false));
        }

        
        static public void Start()
        {
            _dicHosts.ToList().ForEach(c => c.Value.Start());
        }
        
        static public void Stop()
        {
            _dicHosts.ToList().ForEach(c => c.Value.Stop());
        }
        
        static public bool TryGetHost(string name, out SocketBase.IHost host)
        {
            return _dicHosts.TryGetValue(name, out host);
        }
        
    }
}


================================================
FILE: Server/UdpAsyncSendPool.cs
================================================
癤퓎sing System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace FastSocketLite.Server
{
    internal class AsyncSendPool
    {
        private const int MAXPOOLSIZE = 3000;
        private readonly int _messageBufferSize;
        private readonly Socket _socket = null;
        private readonly ConcurrentStack<SocketAsyncEventArgs> _stack =  new ConcurrentStack<SocketAsyncEventArgs>();
        

        /// <summary>
        /// new
        /// </summary>
        /// <param name="messageBufferSize"></param>
        /// <param name="socket"></param>
        public AsyncSendPool(int messageBufferSize, Socket socket)
        {
            if (socket == null)
            {
                throw new ArgumentNullException("socket");
            }

            this._messageBufferSize = messageBufferSize;
            this._socket = socket;
        }
        

        
        /// <summary>
        /// send completed handle
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void SendCompleted(object sender, SocketAsyncEventArgs e)
        {
            this.Release(e);
        }
        


        
        /// <summary>
        /// acquire
        /// </summary>
        /// <returns></returns>
        public SocketAsyncEventArgs Acquire()
        {
            SocketAsyncEventArgs e;
            if (this._stack.TryPop(out e))
            {
                return e;
            }

            e = new SocketAsyncEventArgs();
            e.SetBuffer(new byte[this._messageBufferSize], 0, this._messageBufferSize);
            e.Completed += this.SendCompleted;
            return e;
        }
        /// <summary>
        /// release
        /// </summary>
        /// <param name="e"></param>
        public void Release(SocketAsyncEventArgs e)
        {
            if (this._stack.Count >= MAXPOOLSIZE)
            {
                e.Completed -= this.SendCompleted;
                e.Dispose();
                return;
            }

            this._stack.Push(e);
        }
        /// <summary>
        /// sned async
        /// </summary>
        /// <param name="endPoint"></param>
        /// <param name="payload"></param>
        /// <exception cref="ArgumentNullException">endPoint is null</exception>
        /// <exception cref="ArgumentNullException">payload is null or empty</exception>
        /// <exception cref="ArgumentOutOfRangeException">payload length鸚㏛틢messageBufferSize</exception>
        public void SendAsync(EndPoint endPoint, byte[] payload)
        {
            if (endPoint == null)
            {
                throw new ArgumentNullException("endPoint");
            }

            if (payload == null || payload.Length == 0)
            {
                throw new ArgumentNullException("payload");
            }

            if (payload.Length > this._messageBufferSize)
                throw new ArgumentOutOfRangeException("payload.Length", "payload length鸚㏛틢messageBufferSize");

            var e = this.Acquire();
            e.RemoteEndPoint = endPoint;

            Buffer.BlockCopy(payload, 0, e.Buffer, 0, payload.Length);
            e.SetBuffer(0, payload.Length);

            if (!this._socket.SendToAsync(e))
                ThreadPool.QueueUserWorkItem(_ => this.Release(e));
        }
        
    }
}



================================================
FILE: Server/UdpServer.cs
================================================
癤퓎sing System;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace FastSocketLite.Server
{
    /// <summary>
    /// upd server
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public sealed class UdpServer<TMessage> : IUdpServer<TMessage> where TMessage : class, Messaging.IMessage
    {
        private readonly int _port;
        private readonly int _messageBufferSize;

        private Socket _socket = null;
        private AsyncSendPool _pool = null;

        private readonly Protocol.IUdpProtocol<TMessage> _protocol = null;
        private readonly IUdpService<TMessage> _service = null;
        

        
        /// <summary>
        /// new
        /// </summary>
        /// <param name="port"></param>
        /// <param name="protocol"></param>
        /// <param name="service"></param>
        public UdpServer(int port, Protocol.IUdpProtocol<TMessage> protocol,
                                        IUdpService<TMessage> service)
            : this(port, 2048, protocol, service)
        {
        }
        /// <summary>
        /// new
        /// </summary>
        /// <param name="port"></param>
        /// <param name="messageBufferSize"></param>
        /// <param name="protocol"></param>
        /// <param name="service"></param>
        /// <exception cref="ArgumentNullException">protocol is null.</exception>
        /// <exception cref="ArgumentNullException">service is null.</exception>
        public UdpServer(int port, int messageBufferSize,
                                        Protocol.IUdpProtocol<TMessage> protocol,
                                        IUdpService<TMessage> service)
        {
            if (protocol == null)
            {
                throw new ArgumentNullException("protocol");
            }

            if (service == null)
            {
                throw new ArgumentNullException("service");
            }

            this._port = port;
            this._messageBufferSize = messageBufferSize;
            this._protocol = protocol;
            this._service = service;
        }
        

        
        private void BeginReceive(SocketAsyncEventArgs e)
        {
            if (!this._socket.ReceiveFromAsync(e))
                ThreadPool.QueueUserWorkItem(_ => this.ReceiveCompleted(this, e));
        }
        
        private void ReceiveCompleted(object sender, SocketAsyncEventArgs e)
        {
            if (e.BytesTransferred > 0 && e.SocketError == SocketError.Success)
            {
                var session = new UdpSession(e.RemoteEndPoint, this);
                TMessage message = null;

                try
                {
                    message = this._protocol.Parse(new ArraySegment<byte>(e.Buffer, 0, e.BytesTransferred));
                }
                catch (Exception ex)
                {
                    SocketBase.Log.Trace.Error(ex.Message, ex);
                    this._service.OnError(session, ex);
                }

                if (message != null)
                {
                    this._service.OnReceived(session, message);
                }
            }

            //receive again
            this.BeginReceive(e);
        }
        

                
        public void Start()
        {
            this._socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            this._socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            this._socket.Bind(new IPEndPoint(IPAddress.Any, this._port));
            this._socket.DontFragment = true;

            this._pool = new AsyncSendPool(this._messageBufferSize, this._socket);

            var e = new SocketAsyncEventArgs();
            e.RemoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
            e.SetBuffer(new byte[this._messageBufferSize], 0, this._messageBufferSize);
            e.Completed += this.ReceiveCompleted;
            this.BeginReceive(e);
        }
        
        public void Stop()
        {
            this._socket.Close();
            this._socket = null;
            this._pool = null;
        }
        
        public void SendTo(EndPoint endPoint, byte[] payload)
        {
            this._pool.SendAsync(endPoint, payload);
        }        
                
    } 
}


================================================
FILE: Server/UdpSession.cs
================================================
癤퓎sing System;
using System.Net;

namespace FastSocketLite.Server
{
    /// <summary>
    /// upd session
    /// </summary>
    public sealed class UdpSession
    {
        /// <summary>
        /// udp server
        /// </summary>
        private readonly IUdpServer _server = null;
        /// <summary>
        /// get remote endPoint
        /// </summary>
        public readonly EndPoint RemoteEndPoint = null;

        /// <summary>
        /// new
        /// </summary>
        /// <param name="remoteEndPoint"></param>
        /// <param name="server"></param>
        /// <exception cref="ArgumentNullException">server is null</exception>
        public UdpSession(EndPoint remoteEndPoint, IUdpServer server)
        {
            if (server == null)
            {
                throw new ArgumentNullException("server");
            }

            this.RemoteEndPoint = remoteEndPoint;
            this._server = server;
        }

        /// <summary>
        /// sned async
        /// </summary>
        /// <param name="payload"></param>
        /// <exception cref="ArgumentNullException">payload is null or empty</exception>
        public void SendAsync(byte[] payload)
        {
            this._server.SendTo(this.RemoteEndPoint, payload);
        }
    }
}


================================================
FILE: Server/Config/Server.cs
================================================
Error reading file with 'cp949': 'cp949' codec can't decode byte 0x8c in position 1435: illegal multibyte sequence


================================================
FILE: Server/Config/ServerCollection.cs
================================================
﻿using System.Configuration;

namespace FastSocketLite.Server.Config
{
    /// <summary>
    /// 서버 컬렉션
    /// </summary>
    [ConfigurationCollection(typeof(Server), AddItemName = "server")]
    public class ServerCollection : ConfigurationElementCollection
    {
        protected override ConfigurationElement CreateNewElement()
        {
            return new Server();
        }
        
        protected override object GetElementKey(ConfigurationElement element)
        {
            var server = element as Server;
            return server.Name;
        }

        /// <summary>
        /// 지정된 위치에서 객체를 가져온다.
        /// </summary>
        /// <param name="i"></param>
        /// <returns></returns>
        public Server this[int i]
        {
            get { return BaseGet(i) as Server; }
        }
    }
}


================================================
FILE: Server/Config/SocketServerConfig.cs
================================================
癤퓎sing System.Configuration;

namespace FastSocketLite.Server.Config
{
    /// <summary>
    /// socket server config.
    /// </summary>
    public class SocketServerConfig : ConfigurationSection
    {
        [ConfigurationProperty("servers", IsRequired = true)]
        public ServerCollection Servers
        {
            get { return this["servers"] as ServerCollection; }
        }
    }
}


================================================
FILE: Server/Messaging/CommandLineMessage.cs
================================================
﻿using System;
using System.Text;

namespace FastSocketLite.Server.Messaging
{
    /// <summary>
    /// command line message.
    /// </summary>
    public class CommandLineMessage : Messaging.IMessage
    {
        #region Public Members
        /// <summary>
        /// get the current command name.
        /// </summary>
        public readonly string CmdName;
        /// <summary>
        /// 参数
        /// </summary>
        public readonly string[] Parameters;
        #endregion

        
        /// <summary>
        /// new
        /// </summary>
        /// <param name="cmdName"></param>
        /// <param name="parameters"></param>
        /// <exception cref="ArgumentNullException">cmdName is null</exception>
        public CommandLineMessage(string cmdName, params string[] parameters)
        {
            if (cmdName == null)
            {
                throw new ArgumentNullException("cmdName");
            }

            this.CmdName = cmdName;
            this.Parameters = parameters;
        }
        

        
        /// <summary>
        /// reply
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="value"></param>
        /// <exception cref="ArgumentNullException">connection is null</exception>
        public void Reply(SocketBase.IConnection connection, string value)
        {
            if (connection == null)
            {
                throw new ArgumentNullException("connection");
            }

            connection.BeginSend(ToPacket(value));
        }

        /// <summary>
        /// to <see cref="SocketBase.Packet"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentNullException">value is null</exception>
        static public SocketBase.Packet ToPacket(string value)
        {
            if (value == null)
            {
                throw new ArgumentNullException("value");
            }

            return new SocketBase.Packet(Encoding.UTF8.GetBytes(string.Concat(value, Environment.NewLine)));
        }
        
    }
}


================================================
FILE: Server/Messaging/DefaultBinaryMessage.cs
================================================
癤퓎sing System;
using System.Collections.Generic;
using System.Text;

namespace FastSocketLite.Server.Messaging
{
    public class DefaultBinaryMessage : Messaging.IMessage
    {
        public UInt16 TotalSize;
        public UInt16 PacketID;
        public SByte Type;
        public UInt16 Version;
        public byte[] Body;

        public const Int16 HEADER_SIZE = sizeof(Int16) + sizeof(Int16) + sizeof(SByte) + sizeof(Int16);

        public DefaultBinaryMessage(UInt16 totalSize, UInt16 packetID, SByte type, UInt16 version, byte[] body)
        {
            TotalSize = totalSize;
            PacketID = packetID;
            Type = type;
            Version = version;
            Body = body;
        }
    }
}



================================================
FILE: Server/Messaging/IMessage.cs
================================================
﻿
namespace FastSocketLite.Server.Messaging
{
    /// <summary>
    /// message interface
    /// </summary>
    public interface IMessage
    {
    }
}


================================================
FILE: Server/Messaging/ThriftMessage.cs
================================================
癤퓎sing System;

namespace FastSocketLite.Server.Messaging
{
    /// <summary>
    /// thrift message.
    /// </summary>
    public sealed class ThriftMessage : IMessage
    {
        /// <summary>
        /// payload
        /// </summary>
        public readonly byte[] Payload;

        /// <summary>
        /// new
        /// </summary>
        /// <param name="payload"></param>
        public ThriftMessage(byte[] payload)
        {
            if (payload == null)
            {
                throw new ArgumentNullException("payload");
            }

            this.Payload = payload;
        }
    }
}


================================================
FILE: Server/Protocol/BadProtocolException.cs
================================================
癤퓎sing System;

namespace FastSocketLite.Server.Protocol
{
    /// <summary>
    /// bad protocol exception
    /// </summary>
    public sealed class BadProtocolException : ApplicationException
    {
        /// <summary>
        /// new
        /// </summary>
        public BadProtocolException()  : base("bad protocol.")
        {
        }

        public BadProtocolException(string message) : base(message)
        {
        }
    }
}


================================================
FILE: Server/Protocol/CommandLineProtocol.cs
================================================
﻿using System;
using System.Linq;
using System.Text;

namespace FastSocketLite.Server.Protocol
{
    public sealed class CommandLineProtocol : IProtocol<Messaging.CommandLineMessage>
    {
        static private readonly string[] SPLITER = new string[] { " " };

        /// <summary>
        /// parse
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="buffer"></param>
        /// <param name="maxMessageSize"></param>
        /// <param name="readlength"></param>
        /// <returns></returns>
        /// <exception cref="BadProtocolException">bad command line protocol</exception>
        public Messaging.CommandLineMessage Parse(SocketBase.IConnection connection, ArraySegment<byte> buffer,
            int maxMessageSize, out int readlength)
        {
            if (buffer.Count < 2)
            {
                readlength = 0;
                return null;
            }

            // \r\n 태그 찾기
            for (int i = buffer.Offset, len = buffer.Offset + buffer.Count; i < len; i++)
            {
                if (buffer.Array[i] == 13 && i + 1 < len && buffer.Array[i + 1] == 10)
                {
                    readlength = i + 2 - buffer.Offset;

                    if (readlength == 2)
                    {
                        return new Messaging.CommandLineMessage(string.Empty);
                    }

                    if (readlength > maxMessageSize)
                    {
                        throw new BadProtocolException("message is too long");
                    }

                    string command = Encoding.UTF8.GetString(buffer.Array, buffer.Offset, readlength - 2);
                    var arr = command.Split(SPLITER, StringSplitOptions.RemoveEmptyEntries);

                    if (arr.Length == 0)
                    {
                        return new Messaging.CommandLineMessage(string.Empty);
                    }

                    if (arr.Length == 1)
                    {
                        return new Messaging.CommandLineMessage(arr[0]);
                    }

                    return new Messaging.CommandLineMessage(arr[0], arr.Skip(1).ToArray());
                }
            }

            readlength = 0;
            return null;
        }
    }
}


================================================
FILE: Server/Protocol/DefaultBinaryProtocol.cs
================================================
癤퓎sing System;
using System.Collections.Generic;
using System.Text;

namespace FastSocketLite.Server.Protocol
{
    public sealed class DefaultBinaryProtocol :  IProtocol<Messaging.DefaultBinaryMessage>
    {
        /// <summary>
        /// parse
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="buffer"></param>
        /// <param name="maxMessageSize"></param>
        /// <param name="readlength"></param>
        /// <returns></returns>
        /// <exception cref="BadProtocolException">bad command line protocol</exception>
        public Messaging.DefaultBinaryMessage Parse(SocketBase.IConnection connection, ArraySegment<byte> buffer,
                                                                                                         int maxMessageSize, out int readlength)
        {
            if (buffer.Count < Messaging.DefaultBinaryMessage.HEADER_SIZE)
            {
                readlength = 0;
                return null;
            }

            var startPos = buffer.Offset;
            var bufferLen = buffer.Offset + buffer.Count;
            var totalSize = BitConverter.ToUInt16(buffer.Array, startPos);

            if(totalSize > bufferLen)
            {
                readlength = 0;
                return null;
            }

            var bodyLen = totalSize - Messaging.DefaultBinaryMessage.HEADER_SIZE;
            var packetID = BitConverter.ToUInt16(buffer.Array, startPos + 2);
            var type = (SByte)buffer.Array[startPos + 4];
            var version = BitConverter.ToUInt16(buffer.Array, startPos + 5);
            byte[] body = null;

            if (bodyLen > 0)
            {
                body = new byte[bodyLen];
                Buffer.BlockCopy(buffer.Array, startPos + 7, body, 0, bodyLen);
            }

            readlength = totalSize;
            return new Messaging.DefaultBinaryMessage(totalSize, packetID, type, version, body);                        
        }
    }
}



================================================
FILE: Server/Protocol/IProtocol.cs
================================================
﻿using FastSocketLite.SocketBase;
using System;

namespace FastSocketLite.Server.Protocol
{
    /// <summary>
    /// tcp 프로토콜 인터페이스
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public interface IProtocol<TMessage> where TMessage : class, Messaging.IMessage
    {
        /// <summary>
        /// parse protocol message
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="buffer"></param>
        /// <param name="maxMessageSize"></param>
        /// <param name="readlength"></param>
        /// <returns></returns>
        TMessage Parse(IConnection connection, ArraySegment<byte> buffer,
            int maxMessageSize, out int readlength);
    }
}


================================================
FILE: Server/Protocol/IUdpProtocol.cs
================================================
癤퓎sing System;

namespace FastSocketLite.Server.Protocol
{
    /// <summary>
    /// upd protocol
    /// </summary>
    /// <typeparam name="TMessage"></typeparam>
    public interface IUdpProtocol<TMessage> where TMessage : class, Messaging.IMessage
    {
        /// <summary>
        /// parse protocol message
        /// </summary>
        /// <param name="buffer"></param>
        /// <returns></returns>
        TMessage Parse(ArraySegment<byte> buffer);
    }
}


================================================
FILE: Server/Protocol/ProtocolNames.cs
================================================
﻿
namespace FastSocketLite.Server.Protocol
{
    /// <summary>
    /// ProtocolNames
    /// </summary>
    static public class ProtocolNames
    {
        /// <summary>
        /// thrift协议
        /// </summary>
        public const string Thrift = "thrift";
        /// <summary>
        /// 命令行协议
        /// </summary>
        public const string CommandLine = "commandLine";
    }
}


================================================
FILE: Server/Protocol/ThriftProtocol.cs
================================================
﻿using System;

namespace FastSocketLite.Server.Protocol
{
    /// <summary>
    /// thrift protocol
    /// </summary>
    public sealed class ThriftProtocol : IProtocol<Messaging.ThriftMessage>
    {
        /// <summary>
        /// parse
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="buffer"></param>
        /// <param name="maxMessageSize"></param>
        /// <param name="readlength"></param>
        /// <returns></returns>
        /// <exception cref="BadProtocolException">bad thrift protocol</exception>
        public Messaging.ThriftMessage Parse(SocketBase.IConnection connection, ArraySegment<byte> buffer,
            int maxMessageSize, out int readlength)
        {
            if (buffer.Count < 4)
            {
                readlength = 0;
                return null;
            }

            //message length 얻기
            var messageLength = SocketBase.Utils.NetworkBitConverter.ToInt32(buffer.Array, buffer.Offset);
            if (messageLength < 14)
            {
                throw new BadProtocolException("bad thrift protocol");
            }

            if (messageLength > maxMessageSize)
            {
                throw new BadProtocolException("message is too long");
            }

            readlength = messageLength + 4;
            if (buffer.Count < readlength)
            {
                readlength = 0;
                return null;
            }

            var payload = new byte[messageLength];
            Buffer.BlockCopy(buffer.Array, buffer.Offset + 4, payload, 0, messageLength);
            return new Messaging.ThriftMessage(payload);
        }
    }
}


================================================
FILE: SocketBase/BaseHost.cs
================================================
Error reading file with 'cp949': 'cp949' codec can't decode byte 0xec in position 3056: illegal multibyte sequence


================================================
FILE: SocketBase/ConnectionCollection.cs
================================================
癤퓎sing System;
using System.Collections.Concurrent;
using System.Linq;

namespace FastSocketLite.SocketBase
{
    /// <summary>
    /// socket connection collection
    /// </summary>
    public sealed class ConnectionCollection
    {
        /// <summary>
        /// key:ConnectionID
        /// </summary>
        private readonly ConcurrentDictionary<long, IConnection> _dic = new ConcurrentDictionary<long, IConnection>();
        

        public bool Add(IConnection connection)
        {
            if (connection == null)
            {
                throw new ArgumentNullException("connection");
            }

            return this._dic.TryAdd(connection.ConnectionID, connection);
        }
        
        public bool Remove(long connectionID)
        {
            return this._dic.TryRemove(connectionID, out var connection);
        }
        
        public IConnection Get(long connectionID)
        {
            this._dic.TryGetValue(connectionID, out var connection);
            return connection;
        }
        
        public IConnection[] ToArray()
        {
            return this._dic.ToArray().Select(c => c.Value).ToArray();
        }
        
        public int Count()
        {
            return this._dic.Count;
        }
        
        public void DisconnectAll()
        {
            var connections = this.ToArray();

            foreach (var conn in connections)
            {
                conn.BeginDisconnect();
            }
        }        
    }
}


================================================
FILE: SocketBase/DefaultConnection.cs
================================================
Error reading file with 'cp949': 'cp949' codec can't decode byte 0xed in position 7362: illegal multibyte sequence


================================================
FILE: SocketBase/DisconnectedHandler.cs
================================================
癤퓎sing System;

namespace FastSocketLite.SocketBase
{
    /// <summary>
    /// connection disconnected delegate
    /// </summary>
    /// <param name="connection"></param>
    /// <param name="ex"></param>
    public delegate void DisconnectedHandler(IConnection connection, Exception ex);
}


================================================
FILE: SocketBase/FastSocketLite.SocketBase.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <Compile Remove="Utils\TaskEx.cs" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="NLog.Extensions.Logging" Version="1.4.0" />
  </ItemGroup>
</Project>


================================================
FILE: SocketBase/IConnection.cs
================================================
癤퓎sing System;
using System.Net;

namespace FastSocketLite.SocketBase
{
    /// <summary>
    /// a connection interface.
    /// </summary>
    public interface IConnection
    {
        /// <summary>
        /// disconnected event
        /// </summary>
        event DisconnectedHandler Disconnected;

        /// <summary>
        /// return the connection is active.
        /// </summary>
        bool Active { get; }

        /// <summary>
        /// get the connection latest active time.
        /// </summary>
        DateTime LatestActiveTime { get; }
        
        /// <summary>
        /// get the connection id.
        /// </summary>
        long ConnectionID { get; }
        
        IPEndPoint LocalEndPoint { get; }
        
        IPEndPoint RemoteEndPoint { get; }
        
        object UserData { get; set; }

        void BeginSend(Packet packet);
        
        void BeginReceive();
        
        void BeginDisconnect(Exception ex = null);
    }
}


================================================
FILE: SocketBase/IHost.cs
================================================
癤퓎sing System.Net.Sockets;

namespace FastSocketLite.SocketBase
{
    /// <summary>
    /// socket connection host interface
    /// </summary>
    public interface IHost
    {
        /// <summary>
        /// get socket buffer size
        /// </summary>
        int SocketBufferSize { get; }

        /// <summary>
        /// get message buffer size
        /// </summary>
        int MessageBufferSize { get; }

        /// <summary>
        /// create new <see cref="IConnection"/>
        /// </summary>
        /// <param name="socket"></param>
        /// <returns></returns>
        IConnection NewConnection(Socket socket);
        
        /// <summary>
        /// get <see cref="IConnection"/> by connectionID
        /// </summary>
        /// <param name="connectionID"></param>
        /// <returns></returns>
        IConnection GetConnectionByID(long connectionID);
        
        /// <summary>
        /// list all <see cref="IConnection"/>
        /// </summary>
        /// <returns></returns>
        IConnection[] ListAllConnection();
        
        /// <summary>
        /// get connection count.
        /// </summary>
        /// <returns></returns>
        int CountConnection();

        void Start();
        
        void Stop();
    }
}


================================================
FILE: SocketBase/MessageReceivedEventArgs.cs
================================================
﻿using System;

namespace FastSocketLite.SocketBase
{
    //TODO ArraySegment를 Span으로 바꾸기
    /// <summary>
    /// 메시지 처리 handler
    /// </summary>
    /// <param name="buffer"></param>
    /// <param name="readlength"></param>
    public delegate void MessageProcessHandler(ArraySegment<byte> buffer, int readlength);

    /// <summary>
    /// message received eventArgs
    /// </summary>
    public sealed class MessageReceivedEventArgs
    {
        /// <summary>
        /// process callback
        /// </summary>
        private readonly MessageProcessHandler _processCallback = null;

        //TODO ArraySegment를 Span으로 바꾸기
        /// <summary>
        /// Buffer
        /// </summary>
        public readonly ArraySegment<byte> Buffer;

        //TODO ArraySegment를 Span으로 바꾸기
        /// <summary>
        /// new
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="processCallback"></param>
        /// <exception cref="ArgumentNullException">processCallback is null</exception>
        public MessageReceivedEventArgs(ArraySegment<byte> buffer, MessageProcessHandler processCallback)
        {
            if (processCallback == null) throw new ArgumentNullException("processCallback");
            this.Buffer = buffer;
            this._processCallback = processCallback;
        }

        public void SetReadlength(int readlength)
        {
            this._processCallback(this.Buffer, readlength);
        }
    }
}


================================================
FILE: SocketBase/Packet.cs
================================================
癤퓎sing System;

namespace FastSocketLite.SocketBase
{
    /// <summary>
    /// packet
    /// </summary>
    public class Packet
    {
        /// <summary>
        /// get or set sent size.
        /// </summary>
        internal int SentSize = 0;
        /// <summary>
        /// get the packet created time
        /// </summary>
        public readonly DateTime CreatedTime = Utils.Date.UtcNow;
        /// <summary>
        /// get payload
        /// </summary>
        public readonly byte[] Payload;
        

        /// <summary>
        /// new
        /// </summary>
        /// <param name="payload"></param>
        /// <exception cref="ArgumentNullException">payload is null.</exception>
        public Packet(byte[] payload)
        {
            if (payload == null)
            {
                throw new ArgumentNullException("payload");
            }

            this.Payload = payload;
        }
        

        /// <summary>
        /// get or set tag object
        /// </summary>
        public object Tag { get; set; }
        
        public bool IsSent()
        {
            return this.SentSize == this.Payload.Length;
        }        
    }
}


================================================
FILE: SocketBase/PacketQueue.cs
================================================
Error reading file with 'cp949': 'cp949' codec can't decode byte 0xeb in position 3434: illegal multibyte sequence


================================================
FILE: SocketBase/SocketAsyncEventArgsPool.cs
================================================
Error reading file with 'cp949': 'cp949' codec can't decode byte 0xec in position 1297: illegal multibyte sequence


================================================
FILE: SocketBase/Log/ConsoleListener.cs
================================================
癤퓎sing System;

namespace FastSocketLite.SocketBase.Log
{
    /// <summary>
    /// console trace listener
    /// </summary>
    public sealed class ConsoleListener : ITraceListener
    {
        /// <summary>
        /// debug
        /// </summary>
        /// <param name="message"></param>
        public void Debug(string message)
        {
            Console.WriteLine(string.Concat("debug: ", message, Environment.NewLine));
        }
        /// <summary>
        /// error
        /// </summary>
        /// <param name="message"></param>
        /// <param name="ex"></param>
        public void Error(string message, Exception ex)
        {
            Console.WriteLine(string.Concat("error: ", message, Environment.NewLine, ex.ToString(), Environment.NewLine));
        }
        /// <summary>
        /// info
        /// </summary>
        /// <param name="message"></param>
        public void Info(string message)
        {
            Console.WriteLine(string.Concat("info: ", message, Environment.NewLine));
        }
    }
}


================================================
FILE: SocketBase/Log/DiagnosticListener.cs
================================================
癤퓎sing System;

namespace FastSocketLite.SocketBase.Log
{
    /// <summary>
    /// diagnostic listener
    /// </summary>
    public sealed class DiagnosticListener : ITraceListener
    {
        /// <summary>
        /// debug
        /// </summary>
        /// <param name="message"></param>
        public void Debug(string message)
        {
            System.Diagnostics.Trace.WriteLine(message);
        }
        /// <summary>
        /// error
        /// </summary>
        /// <param name="message"></param>
        /// <param name="ex"></param>
        public void Error(string message, Exception ex)
        {
            System.Diagnostics.Trace.TraceError(ex.ToString());
        }
        /// <summary>
        /// info
        /// </summary>
        /// <param name="message"></param>
        public void Info(string message)
        {
            System.Diagnostics.Trace.TraceInformation(message);
        }
    }
}


================================================
FILE: SocketBase/Log/ITraceListener.cs
================================================
癤퓎sing System;

namespace FastSocketLite.SocketBase.Log
{
    /// <summary>
    /// trace listener interface.
    /// </summary>
    public interface ITraceListener
    {
        /// <summary>
        /// debug
        /// </summary>
        /// <param name="message"></param>
        void Debug(string message);
        /// <summary>
        /// error
        /// </summary>
        /// <param name="message"></param>
        /// <param name="ex"></param>
        void Error(string message, Exception ex);
        /// <summary>
        /// info
        /// </summary>
        /// <param name="message"></param>
        void Info(string message);
    }
}


================================================
FILE: SocketBase/Log/ListenerWrapper.cs
================================================
癤퓎sing System;

namespace FastSocketLite.SocketBase.Log
{
    /// <summary>
    /// trace listener wrapper
    /// </summary>
    public sealed class ListenerWrapper : ITraceListener
    {
        private readonly Action<string> _onDebug = null;
        private readonly Action<string, Exception> _onError = null;
        private readonly Action<string> _onInfo = null;

        /// <summary>
        /// new
        /// </summary>
        /// <param name="onDebug"></param>
        /// <param name="onError"></param>
        /// <param name="onInfo"></param>
        public ListenerWrapper(Action<string> onDebug, Action<string, Exception> onError, Action<string> onInfo)
        {
            if (onDebug == null) throw new ArgumentNullException("onDebug");
            if (onError == null) throw new ArgumentNullException("onError");
            if (onInfo == null) throw new ArgumentNullException("onInfo");

            this._onDebug = onDebug;
            this._onError = onError;
            this._onInfo = onInfo;
        }

        /// <summary>
        /// debug
        /// </summary>
        /// <param name="message"></param>
        public void Debug(string message)
        {
            this._onDebug(message);
        }
        /// <summary>
        /// error
        /// </summary>
        /// <param name="message"></param>
        /// <param name="ex"></param>
        public void Error(string message, Exception ex)
        {
            this._onError(message, ex);
        }
        /// <summary>
        /// info
        /// </summary>
        /// <param name="message"></param>
        public void Info(string message)
        {
            this._onInfo(message);
        }
    }
}


================================================
FILE: SocketBase/Log/NLogListener.cs
================================================
癤퓎sing NLog;
using System;
using System.Collections.Generic;
using System.Text;

namespace FastSocketLite.SocketBase.Log
{
    /// <summary>
    /// NLog trace listener
    /// </summary>
    class NLogListener : ITraceListener
    {
        Logger _Logger = LogManager.GetCurrentClassLogger();
        /// <summary>
        /// debug
        /// </summary>
        /// <param name="message"></param>
        public void Debug(string message)
        {
            _Logger.Debug(message);
        }
        /// <summary>
        /// error
        /// </summary>
        /// <param name="message"></param>
        /// <param name="ex"></param>
        public void Error(string message, Exception ex)
        {
            _Logger.Error($"{message},  Exception: {ex.ToString()}");
        }
        /// <summary>
        /// info
        /// </summary>
        /// <param name="message"></param>
        public void Info(string message)
        {
            _Logger.Info(message);
        }
    }
}



================================================
FILE: SocketBase/Log/Trace.cs
================================================
癤퓎sing System;
using System.Collections.Generic;

namespace FastSocketLite.SocketBase.Log
{
    /// <summary>
    /// trace
    /// </summary>
    static public class Trace
    {
        static private readonly List<ITraceListener> _list = new List<ITraceListener>();

        /// <summary>
        /// enable console trace listener
        /// </summary>
        static public void EnableConsole()
        {
            _list.Add(new ConsoleListener());
        }
        /// <summary>
        /// enable diagnostic
        /// </summary>
        static public void EnableDiagnostic()
        {
            _list.Add(new DiagnosticListener());
        }

        /// <summary>
        /// enable NLog trace listener
        /// </summary>
        static public void EnableNLog()
        {
            _list.Add(new NLogListener());
        }

        /// <summary>
        /// add listener
        /// </summary>
        /// <param name="listener"></param>
        /// <exception cref="ArgumentNullException">listener is null</exception>
        static public void AddListener(ITraceListener listener)
        {
            if (listener == null) throw new ArgumentNullException("listener");
            _list.Add(listener);
        }

        /// <summary>
        /// debug
        /// </summary>
        /// <param name="message"></param>
        /// <exception cref="ArgumentNullException">message is null</exception>
        static public void Debug(string message)
        {
            if (message == null) throw new ArgumentNullException("message");
            _list.ForEach(c => c.Debug(message));
        }
        /// <summary>
        /// info
        /// </summary>
        /// <param name="message"></param>
        /// <exception cref="ArgumentNullException">message is null</exception>
        static public void Info(string message)
        {
            if (message == null) throw new ArgumentNullException("message");
            _list.ForEach(c => c.Info(message));
        }
        /// <summary>
        /// error
        /// </summary>
        /// <param name="message"></param>
        /// <param name="ex"></param>
        /// <exception cref="ArgumentNullException">message is null</exception>
        static public void Error(string message, Exception ex)
        {
            if (message == null) throw new ArgumentNullException("message");
            _list.ForEach(c => c.Error(message, ex));
        }
    }
}


================================================
FILE: SocketBase/Utils/ConsistentHashContainer.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

namespace FastSocketLite.SocketBase.Utils
{
    /// <summary>
    /// 一致性哈希container
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public sealed class ConsistentHashContainer<T>
    {
        #region Private Members
        private readonly Dictionary<uint, T> _dic = new Dictionary<uint, T>();
        private readonly T[] _arr = null;
        private readonly uint[] _keys = null;
        #endregion

        #region Constructors
        /// <summary>
        /// new
        /// </summary>
        /// <param name="source"></param>
        /// <exception cref="ArgumentNullException">source is null</exception>
        public ConsistentHashContainer(IDictionary<string, T> source)
        {
            if (source == null) throw new ArgumentNullException("source");

            var servers = new List<T>();
            var keys = new List<uint>();

            foreach (var child in source)
            {
                for (int i = 0; i < 250; i++)
                {
                    uint key = BitConverter.ToUInt32(new ModifiedFNV1_32().ComputeHash(Encoding.ASCII.GetBytes(child.Key + "-" + i)), 0);
                    if (!this._dic.ContainsKey(key))
                    {
                        this._dic[key] = child.Value;
                        keys.Add(key);
                    }
                }
                servers.Add(child.Value);
            }

            this._arr = servers.ToArray();
            keys.Sort();
            this._keys = keys.ToArray();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Given an item key hash, 
        /// this method returns the Server which is closest on the server key continuum.
        /// </summary>
        /// <param name="consistentKey"></param>
        /// <returns></returns>
        private T Get(uint consistentKey)
        {
            int i = Array.BinarySearch(this._keys, consistentKey);

            //If not exact match...
            if (i < 0)
            {
                //Get the index of the first item bigger than the one searched for.
                i = ~i;
                //If i is bigger than the last index, it was bigger than the last item = use the first item.
                if (i >= this._keys.Length) i = 0;
            }
            return this._dic[this._keys[i]];
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// get
        /// </summary>
        /// <param name="consistentKey"></param>
        /// <returns></returns>
        public T Get(byte[] consistentKey)
        {
            if (this._arr.Length == 0) return default(T);
            //Quick return if we only have one.
            if (this._arr.Length == 1) return this._arr[0];
            return Get(BitConverter.ToUInt32(new ModifiedFNV1_32().ComputeHash(consistentKey), 0));
        }
        #endregion

        #region FNV1_32
        /// <summary>
        /// Fowler-Noll-Vo hash, variant 1, 32-bit version.
        /// http://www.isthe.com/chongo/tech/comp/fnv/
        /// </summary>
        public class FNV1_32 : HashAlgorithm
        {
            private static readonly uint FNV_prime = 16777619;
            private static readonly uint offset_basis = 2166136261;
            /// <summary>
            /// hash
            /// </summary>
            protected uint hash;

            /// <summary>
            /// new
            /// </summary>
            public FNV1_32()
            {
                HashSizeValue = 32;
            }
            /// <summary>
            /// init
            /// </summary>
            public override void Initialize()
            {
                hash = offset_basis;
            }
            /// <summary>
            /// hashcore
            /// </summary>
            /// <param name="array"></param>
            /// <param name="ibStart"></param>
            /// <param name="cbSize"></param>
            protected override void HashCore(byte[] array, int ibStart, int cbSize)
            {
                int length = ibStart + cbSize;
                for (int i = ibStart; i < length; i++) hash = (hash * FNV_prime) ^ array[i];
            }
            /// <summary>
            /// hash final
            /// </summary>
            /// <returns></returns>
            protected override byte[] HashFinal()
            {
                return BitConverter.GetBytes(hash);
            }
        }
        #endregion

        #region ModifiedFNV1_32
        /// <summary>
        /// Modified Fowler-Noll-Vo hash, 32-bit version.
        /// http://home.comcast.net/~bretm/hash/6.html
        /// </summary>
        public class ModifiedFNV1_32 : FNV1_32
        {
            /// <summary>
            /// hashFinal.
            /// </summary>
            /// <returns></returns>
            protected override byte[] HashFinal()
            {
                hash += hash << 13;
                hash ^= hash >> 7;
                hash += hash << 3;
                hash ^= hash >> 17;
                hash += hash << 5;
                return BitConverter.GetBytes(hash);
            }
        }
        #endregion
    }
}


================================================
FILE: SocketBase/Utils/Date.cs
================================================
﻿using System;

namespace FastSocketLite.SocketBase.Utils
{
    /// <summary>
    /// 시간 관련 작업
    /// </summary>
    static public class Date
    {
        #region Private Members
        static private int lastTicks = -1;
        static private DateTime lastDateTime;

        /// <summary>
        /// unix 시간
        /// </summary>
        static private readonly DateTime unixEpoch =
            new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        /// <summary>
        /// the max milliseconds since epoch.
        /// </summary>
        static private readonly long dateTimeMaxValueMillisecondsSinceEpoch =
            (DateTime.MaxValue - unixEpoch).Ticks / 10000;
        #endregion

        #region Public Methods
        /// <summary>
        /// Gets the current utc time in an optimized fashion.
        /// </summary>
        static public DateTime UtcNow
        {
            get
            {
                int tickCount = Environment.TickCount;
                if (tickCount == lastTicks) return lastDateTime;

                DateTime dt = DateTime.UtcNow;
                lastTicks = tickCount;
                lastDateTime = dt;
                return dt;
            }
        }
        /// <summary>
        /// Converts a DateTime to UTC (with special handling for MinValue and MaxValue).
        /// </summary>
        /// <param name="dateTime">A DateTime.</param>
        /// <returns>The DateTime in UTC.</returns>
        public static DateTime ToUniversalTime(DateTime dateTime)
        {
            if (dateTime.Kind == DateTimeKind.Utc) return dateTime;
            else
            {
                if (dateTime == DateTime.MinValue) return DateTime.SpecifyKind(DateTime.MinValue, DateTimeKind.Utc);
                else if (dateTime == DateTime.MaxValue) return DateTime.SpecifyKind(DateTime.MaxValue, DateTimeKind.Utc);
                else return dateTime.ToUniversalTime();
            }
        }
        /// <summary>
        /// Converts a DateTime to number of milliseconds since Unix epoch.
        /// </summary>
        /// <param name="dateTime">A DateTime.</param>
        /// <returns>Number of seconds since Unix epoch.</returns>
        public static long ToMillisecondsSinceEpoch(DateTime dateTime)
        {
            return (ToUniversalTime(dateTime) - unixEpoch).Ticks / 10000;
        }
        /// <summary>
        /// Converts a DateTime to number of seconds since Unix epoch.
        /// </summary>
        /// <param name="dateTime">A DateTime.</param>
        /// <returns>Number of seconds since Unix epoch.</returns>
        public static long ToSecondsSinceEpoch(DateTime dateTime)
        {
            return ToMillisecondsSinceEpoch(dateTime) / 1000;
        }
        /// <summary>
        /// Converts from number of milliseconds since Unix epoch to DateTime.
        /// </summary>
        /// <param name="millisecondsSinceEpoch">The number of milliseconds since Unix epoch.</param>
        /// <returns>A DateTime.</returns>
        public static DateTime ToDateTimeFromMillisecondsSinceEpoch(long millisecondsSinceEpoch)
        {
            // MaxValue has to be handled specially to avoid rounding errors
            if (millisecondsSinceEpoch == dateTimeMaxValueMillisecondsSinceEpoch)
                return DateTime.SpecifyKind(DateTime.MaxValue, DateTimeKind.Utc);
            else return unixEpoch.AddTicks(millisecondsSinceEpoch * 10000);
        }
        /// <summary>
        /// Converts from number of seconds since Unix epoch to DateTime.
        /// </summary>
        /// <param name="secondsSinceEpoch">The number of seconds since Unix epoch.</param>
        /// <returns>A DateTime.</returns>
        public static DateTime ToDateTimeFromSecondsSinceEpoch(long secondsSinceEpoch)
        {
            return ToDateTimeFromMillisecondsSinceEpoch(secondsSinceEpoch * 1000);
        }
        /// <summary>
        /// Converts a DateTime to local time (with special handling for MinValue and MaxValue).
        /// </summary>
        /// <param name="dateTime">A DateTime.</param>
        /// <param name="kind">A DateTimeKind.</param>
        /// <returns>The DateTime in local time.</returns>
        public static DateTime ToLocalTime(DateTime dateTime, DateTimeKind kind)
        {
            if (dateTime.Kind == kind) return dateTime;
            else
            {
                if (dateTime == DateTime.MinValue) return DateTime.SpecifyKind(DateTime.MinValue, kind);
                else if (dateTime == DateTime.MaxValue) return DateTime.SpecifyKind(DateTime.MaxValue, kind);
                else return DateTime.SpecifyKind(dateTime.ToLocalTime(), kind);
            }
        }
        /// <summary>
        /// SpecifyKind
        /// </summary>
        /// <param name="dt"></param>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static DateTime SpecifyKind(DateTime dt, DateTimeKind kind)
        {
            if (dt.Kind == kind) return dt;
            return DateTime.SpecifyKind(dt, kind);
        }
        #endregion
    }
}


================================================
FILE: SocketBase/Utils/IPUtility.cs
================================================
﻿using System.Collections.Generic;
using System.Net;

namespace FastSocketLite.SocketBase.Utils
{
    /// <summary>
    /// ip utility
    /// </summary>
    static public class IPUtility
    {
        #region Private Members
        /// <summary>
        /// A 클래스: 10.0.0.0-10.255.255.255
        /// </summary>
        static private long ipABegin, ipAEnd;
        /// <summary>
        /// B 클래스: 172.16.0.0-172.31.255.255   
        /// </summary>
        static private long ipBBegin, ipBEnd;
        /// <summary>
        /// C 클래스: 192.168.0.0-192.168.255.255
        /// </summary>
        static private long ipCBegin, ipCEnd;
        #endregion

        #region Constructors
        /// <summary>
        /// static new
        /// </summary>
        static IPUtility()
        {
            ipABegin = ConvertToNumber("10.0.0.0");
            ipAEnd = ConvertToNumber("10.255.255.255");

            ipBBegin = ConvertToNumber("172.16.0.0");
            ipBEnd = ConvertToNumber("172.31.255.255");

            ipCBegin = ConvertToNumber("192.168.0.0");
            ipCEnd = ConvertToNumber("192.168.255.255");
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// ipaddress convert to long
        /// </summary>
        /// <param name="ipAddress"></param>
        /// <returns></returns>
        static public long ConvertToNumber(string ipAddress)
        {
            return ConvertToNumber(IPAddress.Parse(ipAddress));
        }
        /// <summary>
        /// ipaddress convert to long
        /// </summary>
        /// <param name="ipAddress"></param>
        /// <returns></returns>
        static public long ConvertToNumber(IPAddress ipAddress)
        {
            var bytes = ipAddress.GetAddressBytes();
            return bytes[0] * 256 * 256 * 256 + bytes[1] * 256 * 256 + bytes[2] * 256 + bytes[3];
        }
        /// <summary>
        /// true이면 인트라넷 IP
        /// </summary>
        /// <param name="ipAddress"></param>
        /// <returns></returns>
        static public bool IsIntranet(string ipAddress)
        {
            return IsIntranet(ConvertToNumber(ipAddress));
        }
        /// <summary>
        /// true이면 인트라넷 IP
        /// </summary>
        /// <param name="ipAddress"></param>
        /// <returns></returns>
        static public bool IsIntranet(IPAddress ipAddress)
        {
            return IsIntranet(ConvertToNumber(ipAddress));
        }
        /// <summary>
        /// true이면 인트라넷 IP
        /// </summary>
        /// <param name="longIP"></param>
        /// <returns></returns>
        static public bool IsIntranet(long longIP)
        {
            return ((longIP >= ipABegin) && (longIP <= ipAEnd) ||
                    (longIP >= ipBBegin) && (longIP <= ipBEnd) ||
                    (longIP >= ipCBegin) && (longIP <= ipCEnd));
        }
        

        static public IPAddress GetLocalIntranetIP()
        {
            var list = Dns.GetHostEntry(Dns.GetHostName()).AddressList;
            foreach (var child in list)
            {
                if (IsIntranet(child)) return child;
            }

            return null;
        }
        
        static public List<IPAddress> GetLocalIntranetIPList()
        {
            var list = Dns.GetHostEntry(Dns.GetHostName()).AddressList;
            var result = new List<IPAddress>();
            foreach (var child in list)
            {
                if (IsIntranet(child)) result.Add(child);
            }

            return result;
        }
        #endregion
    }
}


================================================
FILE: SocketBase/Utils/NetworkBitConverter.cs
================================================
﻿using System;
using System.Net;

namespace FastSocketLite.SocketBase.Utils
{
    /// <summary>
    /// network bit converter.
    /// </summary>
    static public class NetworkBitConverter
    {
        /// <summary>
        /// 지정된 16 비트 부호있는 정수 값을 네트워크 바이트 배열로 반환.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        static public byte[] GetBytes(short value)
        {
            return BitConverter.GetBytes(IPAddress.HostToNetworkOrder(value));
        }

        /// <summary>
        /// 지정된 32 비트 부호있는 정수 값을 네트워크 바이트 배열로 반환.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        static public byte[] GetBytes(int value)
        {
            return BitConverter.GetBytes(IPAddress.HostToNetworkOrder(value));
        }

        /// <summary>
        /// 지정된 64 비트 부호있는 정수 값을 네트워크 바이트 배열로 반환.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        static public byte[] GetBytes(long value)
        {
            return BitConverter.GetBytes(IPAddress.HostToNetworkOrder(value));
        }

        /// <summary>
        /// 네트워크 바이트 배열의 지정된 위치에서 2 바이트에서 변환 된 16 비트 부호있는 정수를 반환.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="startIndex"></param>
        /// <returns></returns>
        static public short ToInt16(byte[] value, int startIndex)
        {
            return IPAddress.NetworkToHostOrder(BitConverter.ToInt16(value, startIndex));
        }

        /// <summary>
        /// 네트워크 바이트 배열의 지정된 위치에서 2 바이트에서 변환 된 32 비트 부호있는 정수를 반환.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="startIndex"></param>
        /// <returns></returns>
        static public int ToInt32(byte[] value, int startIndex)
        {
            return IPAddress.NetworkToHostOrder(BitConverter.ToInt32(value, startIndex));
        }

        /// <summary>
        /// 네트워크 바이트 배열의 지정된 위치에서 2 바이트에서 변환 된 64 비트 부호있는 정수를 반환.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="startIndex"></param>
        /// <returns></returns>
        static public long ToInt64(byte[] value, int startIndex)
        {
            return IPAddress.NetworkToHostOrder(BitConverter.ToInt64(value, startIndex));
        }
    }
}


================================================
FILE: SocketBase/Utils/ReflectionHelper.cs
================================================
﻿using System;
using System.Linq;
using System.Reflection;

namespace FastSocketLite.SocketBase.Utils
{
    public static class ReflectionHelper
    {
        /// <summary>
        /// 지정된 클래스 타입을 구현하는 기본 클래스 인스턴스를 가져온다.
        /// </summary>
        /// <typeparam name="T">인터페이스 유형</typeparam>
        /// <param name="assembly">지정된 어셈블리</param>
        /// <returns></returns>
        /// <exception cref="ArgumentNullException">assembly is null</exception>
        static public T[] GetImplementObjects<T>(Assembly assembly)
        {
            if (assembly == null) throw new ArgumentNullException("assembly");

            return assembly.GetExportedTypes().Where(c =>
            {
                if (c.IsClass && !c.IsAbstract)
                {
                    var interfaces = c.GetInterfaces();
                    if (interfaces != null) return interfaces.Contains(typeof(T));
                }
                return false;
            }).Select(c => (T)c.GetConstructor(new Type[0]).Invoke(new object[0])).ToArray();
        }
    }
}

