# OpenSiv3Dë¥¼ ì´ìš©í•œ C++ í”„ë¡œê·¸ë˜ë° í•™ìŠµ
  
ì €ì: ìµœí¥ë°°, Claude AI  
  
C++ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ë°°ìš°ëŠ” ê²ƒì— ì¤‘ì ì„ ë‘ë˜, Siv3D í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•˜ì—¬ ì‹œê°ì ìœ¼ë¡œ í¥ë¯¸ë¡œìš´ ì˜ˆì œë¥¼ í†µí•´ í•™ìŠµ íš¨ê³¼ë¥¼ ë†’ì´ë„ë¡ ì„¤ê³„ ë˜ì—ˆë‹¤. ë‹¨ìˆœí•œ ì½˜ì†” í”„ë¡œê·¸ë¨ ëŒ€ì‹  ê·¸ë˜í”½, ì†Œë¦¬, ìƒí˜¸ì‘ìš©ì„ í¬í•¨í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ë©° C++ì˜ ê°œë…ì„ ìµí ìˆ˜ ìˆë‹¤.  
  
í•„ìš” ì†Œí”„íŠ¸ì›¨ì–´:  
- Windows 10 ì´ìƒ
- Visual Studio 2022 ì´ìƒ   
  
-----    
    
# Chapter.09: í˜„ëŒ€ì  C++ ê¸°ëŠ¥

## 9.1 ëŒë‹¤ í‘œí˜„ì‹ (Lambda Expressions)
ëŒë‹¤ í‘œí˜„ì‹ì€ ìµëª… í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ëŠ” ê¸°ëŠ¥ìœ¼ë¡œ, ì½”ë“œë¥¼ ë” ê°„ê²°í•˜ê³  ê°€ë…ì„± ìˆê²Œ ë§Œë“¤ì–´ ì¤€ë‹¤.

### ê¸°ë³¸ ë¬¸ë²•:
```cpp
auto ëŒë‹¤ì´ë¦„ = [ìº¡ì²˜ì ˆ](ë§¤ê°œë³€ìˆ˜) -> ë°˜í™˜íƒ€ì… { í•¨ìˆ˜ ë³¸ë¬¸ };
```

### Siv3Dë¥¼ í™œìš©í•œ ëŒë‹¤ ì˜ˆì œ:

```cpp
#include <Siv3D.hpp>

void Main()
{
	// ë°°ê²½ ì„¤ì •
	Scene::SetBackground(ColorF{ 0.6, 0.8, 0.9 });

	// ë²„íŠ¼ ìƒíƒœì™€ ìœ„ì¹˜ ê´€ë¦¬
	bool isButtonPressed = false;
	const Rect button{ Arg::center(400, 300), 200, 80 };

	// í´ë¦­ íš¨ê³¼ìŒ ë¡œë“œ
	const Audio clickSound{ U"example/sound/click.mp3" };

	// í´ë¦­ ì²˜ë¦¬ ëŒë‹¤ í•¨ìˆ˜ ì •ì˜
	auto handleClick = [&isButtonPressed, &clickSound, &button]() {
		if (button.leftClicked())
		{
			isButtonPressed = !isButtonPressed;
			clickSound.playOneShot();
		}
		};

	// ê·¸ë¦¬ê¸° í•¨ìˆ˜ ëŒë‹¤ ì •ì˜
	auto drawButton = [&]() {
		// ë²„íŠ¼ ìƒíƒœì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½
		ColorF buttonColor = isButtonPressed ? ColorF{ 0.9, 0.6, 0.3 } : ColorF{ 0.3, 0.6, 0.9 };
		button.draw(buttonColor);
		button.drawFrame(2, ColorF{ 0.1 });
		FontAsset(U"ButtonFont")(isButtonPressed ? U"ì¼œì§" : U"êº¼ì§").drawAt(button.center(), ColorF{ 1.0 });
		};

	// í°íŠ¸ ë“±ë¡
	FontAsset::Register(U"ButtonFont", 30, Typeface::Bold);

	while (System::Update())
	{
		// ëŒë‹¤ í•¨ìˆ˜ í˜¸ì¶œ
		handleClick();
		drawButton();
	}
}
```

ì´ ì˜ˆì œì—ì„œ ëŒë‹¤ í‘œí˜„ì‹ì€ ë²„íŠ¼ í´ë¦­ ì²˜ë¦¬ì™€ ê·¸ë¦¬ê¸° ë¡œì§ì„ ìº¡ìŠí™”í•˜ì—¬ ì½”ë“œë¥¼ ë” ëª¨ë“ˆí™”í•œë‹¤.
  

## 9.2 ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° (Smart Pointers)
ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ëŠ” ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•˜ê³  ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ë¥¼ ìë™í™”í•˜ëŠ” í˜„ëŒ€ì  C++ì˜ í•µì‹¬ ê¸°ëŠ¥ì´ë‹¤.  

### ì£¼ìš” ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°:
- `std::unique_ptr`: ë…ì  ì†Œìœ ê¶Œ
- `std::shared_ptr`: ê³µìœ  ì†Œìœ ê¶Œ
- `std::weak_ptr`: ì•½í•œ ì°¸ì¡°

### Siv3Dë¡œ êµ¬í˜„í•œ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì˜ˆì œ:

```cpp
#include <Siv3D.hpp>
#include <memory>
#include <vector>

// ê°„ë‹¨í•œ ê²Œì„ ì˜¤ë¸Œì íŠ¸ í´ë˜ìŠ¤
class GameObject 
{
private:
    Vec2 m_pos;
    ColorF m_color;
    String m_name;
    
public:
    GameObject(Vec2 pos, ColorF color, String name)
        : m_pos(pos), m_color(color), m_name(name) {}
    
    void update() {
        // ê°„ë‹¨í•œ ì›€ì§ì„ ë¡œì§
        m_pos.x += Random(-2.0, 2.0);
        m_pos.y += Random(-2.0, 2.0);
    }
    
    void draw() const {
        Circle{m_pos, 30}.draw(m_color);
        FontAsset(U"ObjectFont")(m_name).drawAt(m_pos, ColorF{0.1});
    }
    
    const Vec2& getPosition() const {
        return m_pos;
    }
    
    const String& getName() const {
        return m_name;
    }
};

void Main()
{
    // ë°°ê²½ ì„¤ì •
    Scene::SetBackground(ColorF{0.2, 0.3, 0.4});
    
    // í°íŠ¸ ë“±ë¡
    FontAsset::Register(U"ObjectFont", 16, Typeface::Medium);
    
    // ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ë¥¼ ì´ìš©í•œ ê°ì²´ ê´€ë¦¬
    std::vector<std::shared_ptr<GameObject>> gameObjects;
    
    // ê°ì²´ ì¶”ê°€ ë²„íŠ¼
    Rect addButton{Arg::center(100, 50), 150, 40};
    
    while (System::Update())
    {
        // ë²„íŠ¼ìœ¼ë¡œ ìƒˆ ê°ì²´ ì¶”ê°€
        addButton.draw(ColorF{0.4, 0.7, 0.3});
        FontAsset(U"ObjectFont")(U"ê°ì²´ ì¶”ê°€").drawAt(addButton.center(), ColorF{1.0});
        
        if (addButton.leftClicked())
        {
            // unique_ptr ìƒì„± í›„ shared_ptrë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
            auto newObject = std::make_unique<GameObject>(
                Vec2{Random(100.0, 700.0), Random(100.0, 500.0)},
                ColorF{Random(0.0, 1.0), Random(0.0, 1.0), Random(0.0, 1.0)},
                U"ê°ì²´-{}"_fmt(gameObjects.size() + 1)
            );
            
            // unique_ptrë¥¼ shared_ptrë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
            gameObjects.push_back(std::shared_ptr<GameObject>(newObject.release()));
        }
        
        // ê°ì²´ ì œê±° ë²„íŠ¼
        Rect removeButton{Arg::center(300, 50), 150, 40};
        removeButton.draw(ColorF{0.7, 0.4, 0.3});
        FontAsset(U"ObjectFont")(U"ê°ì²´ ì œê±°").drawAt(removeButton.center(), ColorF{1.0});
        
        if (removeButton.leftClicked() && !gameObjects.empty())
        {
            // ê°ì²´ ì œê±° (ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ê°€ ìë™ìœ¼ë¡œ ë©”ëª¨ë¦¬ í•´ì œ)
            gameObjects.pop_back();
        }
        
        // ê°ì²´ ì •ë³´ í‘œì‹œ ë° ì—…ë°ì´íŠ¸
        for (auto& obj : gameObjects)
        {
            obj->update();
            obj->draw();
        }
        
        // í˜„ì¬ ê°ì²´ ìˆ˜ í‘œì‹œ
        FontAsset(U"ObjectFont")(U"í˜„ì¬ ê°ì²´ ìˆ˜: {}"_fmt(gameObjects.size()))
            .draw(20, 100, ColorF{1.0});
    }
}
```

ì´ ì˜ˆì œì—ì„œëŠ” `std::unique_ptr`ê³¼ `std::shared_ptr`ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²Œì„ ì˜¤ë¸Œì íŠ¸ì˜ ìˆ˜ëª…ì„ ê´€ë¦¬í•œë‹¤. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê±±ì • ì—†ì´ ê°ì²´ë¥¼ ìƒì„±í•˜ê³  ì œê±°í•  ìˆ˜ ìˆë‹¤.
  


## 9.3 ì´ë™ ì˜ë¯¸ë¡  (Move Semantics)
ì´ë™ ì˜ë¯¸ë¡ ì€ ë¶ˆí•„ìš”í•œ ë³µì‚¬ë¥¼ ì¤„ì´ê³  ì„±ëŠ¥ì„ ìµœì í™”í•˜ëŠ” C++11ë¶€í„° ë„ì…ëœ ì¤‘ìš”í•œ ê¸°ëŠ¥ì´ë‹¤.

### í•µì‹¬ ê°œë…:
- ìš°ì¸¡ê°’ ì°¸ì¡° (rvalue reference)
- ì´ë™ ìƒì„±ì (move constructor)
- ì´ë™ ëŒ€ì… ì—°ì‚°ì (move assignment operator)

### Siv3Dë¥¼ í™œìš©í•œ ì´ë™ ì˜ë¯¸ë¡  ì˜ˆì œ:

```cpp
#include <Siv3D.hpp>
#include <vector>

// ë¬´ê±°ìš´ ë¦¬ì†ŒìŠ¤ë¥¼ ê°€ì§„ í´ë˜ìŠ¤ (ì˜ˆ: í° ì´ë¯¸ì§€ ë°ì´í„°)
class ImageResource 
{
private:
    Array<ColorF> m_pixels;
    String m_name;
    Vec2 m_pos;
    
public:
    // ì¼ë°˜ ìƒì„±ì
    ImageResource(const String& name, size_t size, Vec2 pos)
        : m_pixels(size * size), m_name(name), m_pos(pos)
    {
        // ì„ì˜ íŒ¨í„´ìœ¼ë¡œ í”½ì…€ ì´ˆê¸°í™”
        for (auto& pixel : m_pixels)
        {
            pixel = ColorF{Random(0.0, 1.0), Random(0.0, 1.0), Random(0.0, 1.0)};
        }
        
        Print << U"[ìƒì„±ë¨] " << m_name;
    }
    
    // ë³µì‚¬ ìƒì„±ì (ì˜ë„ì ìœ¼ë¡œ ë¹„íš¨ìœ¨ì ìœ¼ë¡œ ë§Œë“¦)
    ImageResource(const ImageResource& other)
        : m_pixels(other.m_pixels), m_name(other.m_name + U"ì˜ ë³µì‚¬ë³¸"), m_pos(other.m_pos + Vec2{10, 10})
    {
        Print << U"[ë³µì‚¬ë¨] " << m_name << U" (ë¹„ìš© ë†’ìŒ)";
        
        // ë³µì‚¬ì— ì‹œê°„ì´ ê±¸ë¦¬ëŠ” ê²ƒ ì‹œë®¬ë ˆì´ì…˜
        System::Sleep(500ms);
    }
    
    // ì´ë™ ìƒì„±ì
    ImageResource(ImageResource&& other) noexcept
        : m_pixels(std::move(other.m_pixels)), 
          m_name(std::move(other.m_name) + U"(ì´ë™ë¨)"), 
          m_pos(other.m_pos + Vec2{50, 0})
    {
        Print << U"[ì´ë™ë¨] " << m_name << U" (íš¨ìœ¨ì )";
        
        // ì´ë™ì€ ë¹ ë¦„
        other.m_pixels.clear();
    }
    
    // ì´ë™ ëŒ€ì… ì—°ì‚°ì
    ImageResource& operator=(ImageResource&& other) noexcept {
        if (this != &other)
        {
            m_pixels = std::move(other.m_pixels);
            m_name = std::move(other.m_name) + U"(ì´ë™ ëŒ€ì…ë¨)";
            m_pos = other.m_pos;
            
            Print << U"[ì´ë™ ëŒ€ì…] " << m_name;
            
            other.m_pixels.clear();
        }
        return *this;
    }
    
    // ì†Œë©¸ì
    ~ImageResource() {
        if (!m_pixels.empty()) {
            Print << U"[ì œê±°ë¨] " << m_name;
        }
    }
    
    void draw() const {
        if (m_pixels.empty()) return;
        
        // ì´ë¯¸ì§€ ë°ì´í„° ì‹œê°í™”
        const int size = static_cast<int>(std::sqrt(m_pixels.size()));
        for (int y = 0; y < size; ++y) {
            for (int x = 0; x < size; ++x) {
                const int index = y * size + x;
                if (index < m_pixels.size()) {
                    Rect{static_cast<int>(m_pos.x) + x * 2, 
                         static_cast<int>(m_pos.y) + y * 2, 2, 2}
                        .draw(m_pixels[index]);
                }
            }
        }
        
        // ì´ë¦„ í‘œì‹œ
        FontAsset(U"ResourceFont")(m_name).draw(m_pos.x, m_pos.y - 20, ColorF{1.0});
    }
    
    ImageResource createCopy() const {
        return *this;  // ë³µì‚¬ ìƒì„±ì í˜¸ì¶œ
    }
    
    ImageResource createMove() {
        return std::move(*this);  // ì´ë™ ìƒì„±ì í˜¸ì¶œ
    }
};

void Main()
{
    // ë°°ê²½ ì„¤ì •
    Scene::SetBackground(ColorF{0.1, 0.1, 0.2});
    
    // í°íŠ¸ ë“±ë¡
    FontAsset::Register(U"ResourceFont", 16, Typeface::Medium);
    FontAsset::Register(U"ButtonFont", 20, Typeface::Bold);
    
    // ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
    std::vector<ImageResource> resources;
    
    // ì›ë³¸ ë¦¬ì†ŒìŠ¤ ìƒì„±
    resources.emplace_back(U"ì›ë³¸ ì´ë¯¸ì§€", 30, Vec2{100, 150});
    
    // ë²„íŠ¼ ì„¤ì •
    const Rect copyButton{50, 50, 200, 40};
    const Rect moveButton{300, 50, 200, 40};
    const Rect clearButton{550, 50, 200, 40};
    
    while (System::Update())
    {
        // ë³µì‚¬ ë²„íŠ¼
        copyButton.draw(ColorF{0.6, 0.3, 0.3});
        FontAsset(U"ButtonFont")(U"ë³µì‚¬").drawAt(copyButton.center(), ColorF{1.0});
        
        if (copyButton.leftClicked() && !resources.empty())
        {
            // ë³µì‚¬ ìƒì„±ì í˜¸ì¶œ
            resources.push_back(resources[0].createCopy());
        }
        
        // ì´ë™ ë²„íŠ¼
        moveButton.draw(ColorF{0.3, 0.6, 0.3});
        FontAsset(U"ButtonFont")(U"ì´ë™").drawAt(moveButton.center(), ColorF{1.0});
        
        if (moveButton.leftClicked() && resources.size() >= 2)
        {
            // ë§ˆì§€ë§‰ ë¦¬ì†ŒìŠ¤ë¥¼ ì´ë™í•˜ì—¬ ìƒˆ ë¦¬ì†ŒìŠ¤ ìƒì„±
            resources.push_back(std::move(resources.back()));
            resources.erase(resources.end() - 2);  // ì´ë™ëœ ê°ì²´ ì œê±°
        }
        
        // ì´ˆê¸°í™” ë²„íŠ¼
        clearButton.draw(ColorF{0.3, 0.3, 0.6});
        FontAsset(U"ButtonFont")(U"ì´ˆê¸°í™”").drawAt(clearButton.center(), ColorF{1.0});
        
        if (clearButton.leftClicked())
        {
            resources.clear();
            resources.emplace_back(U"ì›ë³¸ ì´ë¯¸ì§€", 30, Vec2{100, 150});
        }
        
        // ë¦¬ì†ŒìŠ¤ ê·¸ë¦¬ê¸°
        for (const auto& resource : resources)
        {
            resource.draw();
        }
        
        // ì„¤ëª… í‘œì‹œ
        FontAsset(U"ResourceFont")(U"ë¦¬ì†ŒìŠ¤ ê°œìˆ˜: {}"_fmt(resources.size()))
            .draw(50, 100, ColorF{1.0});
    }
}
```

ì´ ì˜ˆì œëŠ” ì´ë™ ì˜ë¯¸ë¡ ì˜ íš¨ìœ¨ì„±ì„ ì‹œê°ì ìœ¼ë¡œ ë³´ì—¬ì¤€ë‹¤. ë³µì‚¬ëŠ” ëŠë¦¬ê³  ë¹„ìš©ì´ ë†’ì§€ë§Œ, ì´ë™ì€ íš¨ìœ¨ì ì´ë©° ì„±ëŠ¥ì„ í¬ê²Œ í–¥ìƒì‹œí‚¨ë‹¤.
  

## 9.4 auto í‚¤ì›Œë“œ
`auto` í‚¤ì›Œë“œëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ìë™ìœ¼ë¡œ ì¶”ë¡ í•˜ê²Œ í•´ì£¼ëŠ” ê¸°ëŠ¥ìœ¼ë¡œ, ì½”ë“œë¥¼ ë” ê°„ê²°í•˜ê²Œ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

### Siv3Dë¡œ êµ¬í˜„í•œ auto í‚¤ì›Œë“œ í™œìš© ì˜ˆì œ:

```cpp
#include <Siv3D.hpp>
#include <map>
#include <vector>

void Main()
{
    // ë°°ê²½ ì„¤ì •
    Scene::SetBackground(ColorF{0.1, 0.2, 0.3});
    
    // í°íŠ¸ ë“±ë¡
    FontAsset::Register(U"MainFont", 24, Typeface::Bold);
    FontAsset::Register(U"DescFont", 16, Typeface::Medium);
    
    // autoë¥¼ í™œìš©í•œ ë‹¤ì–‘í•œ ë°ì´í„° êµ¬ì¡° ì˜ˆì œ
    
    // 1. autoì™€ ì»¬ë ‰ì…˜
    std::vector<int> numbers = {5, 10, 15, 20, 25};
    int sum = 0;
    
    // ê¸°ì¡´ ë°©ì‹
    for (std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        sum += *it;
    }
    
    // auto í™œìš© ë°©ì‹
    sum = 0;
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        sum += *it;
    }
    
    // ë²”ìœ„ ê¸°ë°˜ forë¬¸ê³¼ auto
    sum = 0;
    for (const auto& num : numbers) {
        sum += num;
    }
    
    // 2. ë³µì¡í•œ íƒ€ì…ê³¼ auto
    std::map<String, std::vector<ColorF>> colorCollections;
    colorCollections[U"ë¹¨ê°•ê³„ì—´"] = {ColorF{0.8, 0.2, 0.2}, ColorF{1.0, 0.4, 0.4}, ColorF{0.6, 0.0, 0.0}};
    colorCollections[U"íŒŒë‘ê³„ì—´"] = {ColorF{0.2, 0.2, 0.8}, ColorF{0.4, 0.4, 1.0}, ColorF{0.0, 0.0, 0.6}};
    
    // auto ì—†ì´ í‘œí˜„í•˜ê¸° ë³µì¡í•œ íƒ€ì… ê°„ì†Œí™”
    auto colorIterator = colorCollections.find(U"ë¹¨ê°•ê³„ì—´");
    
    // 3. ëŒë‹¤ì™€ í•¨ê»˜ ì‚¬ìš©
    auto calculateDistance = [](const Vec2& a, const Vec2& b) {
        return Math::Sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
    };
    
    // 4. ê°€ë…ì„± í–¥ìƒ ì˜ˆì œ
    auto windowWidth = Window::Width();
    auto windowCenter = Scene::Center();
    
    // ì¸í„°ë™í‹°ë¸Œ ë°ëª¨
    while (System::Update())
    {
        // ì œëª© í‘œì‹œ
        FontAsset(U"MainFont")(U"auto í‚¤ì›Œë“œ í™œìš© ì˜ˆì œ").drawAt(400, 50, ColorF{1.0});
        
        // ì„¤ëª… ë° ì˜ˆì œ í‘œì‹œ
        int y = 100;
        
        FontAsset(U"DescFont")(U"1. ë°˜ë³µì ì‚¬ìš© ê°„ì†Œí™”:").draw(50, y, ColorF{1.0});
        y += 30;
        FontAsset(U"DescFont")(U"ê¸°ì¡´: std::vector<int>::iterator it = numbers.begin();").draw(70, y, ColorF{0.8, 0.8, 1.0});
        y += 30;
        FontAsset(U"DescFont")(U"auto ì‚¬ìš©: auto it = numbers.begin();").draw(70, y, ColorF{0.4, 1.0, 0.4});
        y += 50;
        
        FontAsset(U"DescFont")(U"2. ë³µì¡í•œ íƒ€ì… ê°„ì†Œí™”:").draw(50, y, ColorF{1.0});
        y += 30;
        FontAsset(U"DescFont")(U"ê¸°ì¡´: std::map<String, std::vector<ColorF>>::iterator it;").draw(70, y, ColorF{0.8, 0.8, 1.0});
        y += 30;
        FontAsset(U"DescFont")(U"auto ì‚¬ìš©: auto it = colorCollections.find(key);").draw(70, y, ColorF{0.4, 1.0, 0.4});
        y += 50;
        
        FontAsset(U"DescFont")(U"3. ëŒë‹¤ í‘œí˜„ì‹ í™œìš©:").draw(50, y, ColorF{1.0});
        y += 30;
        
        // ëŒë‹¤ í•¨ìˆ˜ ì‚¬ìš© ë°ëª¨ - ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
        Vec2 point1{300, y};
        Vec2 point2{Cursor::Pos()};
        
        Circle{point1, 10}.draw(ColorF{1.0, 0.7, 0.1});
        Line{point1, point2}.draw(2, ColorF{0.7, 0.7, 0.7});
        
        auto distance = calculateDistance(point1, point2);
        FontAsset(U"DescFont")(U"ë‘ ì  ì‚¬ì´ ê±°ë¦¬: {:.1f}"_fmt(distance)).draw(point1.x + 20, point1.y - 10, ColorF{1.0});
        
        y += 50;
        
        FontAsset(U"DescFont")(U"4. ê°€ë…ì„± í–¥ìƒ:").draw(50, y, ColorF{1.0});
        y += 30;
        FontAsset(U"DescFont")(U"ìœˆë„ìš° í¬ê¸°: {} x {}"_fmt(windowWidth, Window::Height())).draw(70, y, ColorF{0.4, 1.0, 0.4});
        y += 30;
        FontAsset(U"DescFont")(U"í™”ë©´ ì¤‘ì•™: ({:.1f}, {:.1f})"_fmt(windowCenter.x, windowCenter.y)).draw(70, y, ColorF{0.4, 1.0, 0.4});
        
        // ìƒ‰ìƒ ì»¬ë ‰ì…˜ ì‹œê°í™”
        y += 50;
        FontAsset(U"DescFont")(U"ì»¬ëŸ¬ ì»¬ë ‰ì…˜ (autoë¡œ ìˆœíšŒ):").draw(50, y, ColorF{1.0});
        y += 30;
        
        int x = 70;
        for (const auto& [name, colors] : colorCollections) {
            FontAsset(U"DescFont")(name).draw(x, y, ColorF{1.0});
            
            for (size_t i = 0; i < colors.size(); ++i) {
                Rect{x + static_cast<int>(i) * 40, y + 20, 30, 30}.draw(colors[i]);
            }
            
            y += 70;
        }
    }
}
```

ì´ ì˜ˆì œëŠ” `auto`ì˜ ë‹¤ì–‘í•œ í™œìš© ë°©ë²•ì„ ë³´ì—¬ì£¼ë©°, íŠ¹íˆ ë³µì¡í•œ íƒ€ì… ëª…ì‹œë¥¼ ê°„ì†Œí™”í•˜ëŠ” ë°©ë²•ê³¼ ê°€ë…ì„± í–¥ìƒì— ì´ˆì ì„ ë§ì¶”ê³  ìˆë‹¤.  
  

## ìµœì¢… í†µí•© ì˜ˆì œ: í˜„ëŒ€ì  C++ ê¸°ëŠ¥ì„ í™œìš©í•œ ê°„ë‹¨í•œ ê²Œì„
ì•„ë˜ ì˜ˆì œëŠ” ëŒë‹¤ í‘œí˜„ì‹, ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°, ì´ë™ ì˜ë¯¸ë¡ , auto í‚¤ì›Œë“œë¥¼ ëª¨ë‘ í™œìš©í•œ ê°„ë‹¨í•œ ê²Œì„ì´ë‹¤:

```cpp
#include <Siv3D.hpp>
#include <memory>
#include <vector>
#include <functional>

// ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë©´ ì½”ë“œê°€ ê°„ê²°í•´ì§‘ë‹ˆë‹¤.
using namespace s3d;

// ê²Œì„ ê°ì²´ ì¸í„°í˜ì´ìŠ¤
class GameObject {
public:
	virtual ~GameObject() = default;
	virtual void update() = 0;
	virtual void draw() const = 0;
	virtual bool isAlive() const = 0;
	virtual RectF getCollider() const = 0; // [ë³€ê²½] Rect -> RectF
};

// í”Œë ˆì´ì–´ í´ë˜ìŠ¤
class Player : public GameObject {
private:
	Vec2 m_pos;
	Texture m_texture;
	bool m_isAlive;

public:
	Player(const Vec2& pos, const Texture& texture)
		: m_pos(pos), m_texture(texture), m_isAlive(true) {
	}

	void update() override {
		Vec2 velocity{ 0, 0 };

		if (KeyLeft.pressed()) velocity.x -= 5;
		if (KeyRight.pressed()) velocity.x += 5;
		if (KeyUp.pressed()) velocity.y -= 5;
		if (KeyDown.pressed()) velocity.y += 5;

		m_pos += velocity;

		// [ë³€ê²½] í•˜ë“œì½”ë”©ëœ í™”ë©´ í¬ê¸° ëŒ€ì‹  Scene::Rect() ì‚¬ìš©
		m_pos = m_pos.clamp(Scene::Rect());
	}

	void draw() const override {
		m_texture.drawAt(m_pos);
	}

	bool isAlive() const override {
		return m_isAlive;
	}

	void setAlive(bool alive) {
		m_isAlive = alive;
	}

	RectF getCollider() const override {
		// [ë³€ê²½] RectF ìƒì„±ì ë¬¸ë²• ë³€ê²½
		return RectF{ Arg::center = m_pos, 40, 40 };
	}
};

// ì  í´ë˜ìŠ¤
class Enemy : public GameObject {
private:
	Vec2 m_pos;
	Vec2 m_velocity;
	ColorF m_color;
	bool m_isAlive;

public:
	Enemy(const Vec2& pos, const Vec2& velocity, const ColorF& color)
		: m_pos(pos), m_velocity(velocity), m_color(color), m_isAlive(true) {
	}

	void update() override {
		m_pos += m_velocity;

		// [ë³€ê²½] í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ (ë” ê°„ê²°í•œ ë°©ì‹)
		if ((m_pos.x < 0 && m_velocity.x < 0) || (m_pos.x > Scene::Width() && m_velocity.x > 0))
		{
			m_velocity.x *= -1;
		}
		if ((m_pos.y < 0 && m_velocity.y < 0) || (m_pos.y > Scene::Height() && m_velocity.y > 0))
		{
			m_velocity.y *= -1;
		}
	}

	void draw() const override {
		Circle{ m_pos, 20 }.draw(m_color);
	}

	bool isAlive() const override {
		return m_isAlive;
	}

	void destroy() {
		m_isAlive = false;
	}

	RectF getCollider() const override {
		// [ë³€ê²½] RectF ìƒì„±ì ë¬¸ë²• ë³€ê²½
		return RectF{ Arg::center = m_pos, 40, 40 };
	}
};

// ì•„ì´í…œ í´ë˜ìŠ¤
class Item : public GameObject {
private:
	Vec2 m_pos;
	double m_angle;
	Texture m_texture;
	bool m_isAlive;

public:
	Item(const Vec2& pos, const Texture& texture)
		: m_pos(pos), m_angle(0), m_texture(texture), m_isAlive(true) {
	}

	void update() override {
		m_angle += 0.02;
		m_pos.y += Math::Sin(m_angle) * 0.5;
	}

	void draw() const override {
		m_texture.scaled(0.5).rotated(m_angle).drawAt(m_pos);
	}

	bool isAlive() const override {
		return m_isAlive;
	}

	void collect() {
		m_isAlive = false;
	}

	RectF getCollider() const override {
		// [ë³€ê²½] RectF ìƒì„±ì ë¬¸ë²• ë³€ê²½
		return RectF{ Arg::center = m_pos, 30, 30 };
	}
};

// ê²Œì„ ë§¤ë‹ˆì € í´ë˜ìŠ¤
class GameManager {
private:
	// [ë³€ê²½] unique_ptr -> shared_ptrë¡œ í†µì¼
	std::vector<std::shared_ptr<GameObject>> m_gameObjects;
	std::shared_ptr<Player> m_player;
	Texture m_playerTexture;
	Texture m_itemTexture;
	Font m_font;
	Audio m_itemSound;
	Audio m_damageSound;
	int m_score;

	std::function<void()> m_onEnemyDestroyed;
	std::function<void()> m_onItemCollected;
	std::function<void()> m_onPlayerDamaged;

public:
	GameManager()
		: m_playerTexture{ U"ğŸš€"_emoji }
		, m_itemTexture{ U"â­"_emoji }
		, m_font{ 30, Typeface::Bold }
		, m_itemSound{ GMInstrument::Marimba, static_cast<uint8>(PianoKey::C5), 0.5s }
		, m_damageSound{ GMInstrument::BrassSection, static_cast<uint8>(PianoKey::A3), 0.5s }
		, m_score{ 0 }
	{
		m_player = std::make_shared<Player>(Scene::Center(), m_playerTexture);
		m_gameObjects.push_back(m_player); // [ë³€ê²½] shared_ptrë¥¼ ë°”ë¡œ ì¶”ê°€

		m_onEnemyDestroyed = [this]() {
			m_score += 100;
			spawnEnemy();
			};
		m_onItemCollected = [this]() {
			m_score += 50;
			m_itemSound.playOneShot();
			spawnItem();
			};
		m_onPlayerDamaged = [this]() {
			m_score = Max(0, m_score - 30);
			m_damageSound.playOneShot();
			};

		for (int i = 0; i < 5; ++i) spawnEnemy();
		for (int i = 0; i < 3; ++i) spawnItem();
	}

	void spawnEnemy() {
		// [ë³€ê²½] make_shared ì‚¬ìš© ë° RandomVec2ë¡œ ê°„ê²°í™”
		const Vec2 velocity = RandomVec2(Circle{ 3.0 });
		const ColorF color{ Random(0.5, 1.0), Random(0.5, 1.0), Random(0.5, 1.0) };
		auto enemy = std::make_shared<Enemy>(RandomVec2(Scene::Rect()), velocity, color);
		m_gameObjects.push_back(enemy);
	}

	void spawnItem() {
		// [ë³€ê²½] make_shared ì‚¬ìš©
		auto item = std::make_shared<Item>(RandomVec2(Scene::Rect()), m_itemTexture);
		m_gameObjects.push_back(item);
	}

	void update() {
		for (auto& obj : m_gameObjects) {
			obj->update();
		}

		checkCollisions();

		// [ë³€ê²½] C++20 Ranges ë¬¸ë²•ìœ¼ë¡œ ë” ê°„ê²°í•˜ê²Œ ì œê±° (Erase-Remove Idiomê³¼ ë™ì¼)
		std::erase_if(m_gameObjects, [](const auto& obj) { return !obj->isAlive(); });
	}

	void checkCollisions() {
		if (!m_player || !m_player->isAlive()) return;

		const auto playerCollider = m_player->getCollider();

		for (auto& obj : m_gameObjects) {
			if (obj == m_player) continue;

			if (playerCollider.intersects(obj->getCollider())) {
				if (auto enemy = std::dynamic_pointer_cast<Enemy>(obj)) {
					enemy->destroy();
					m_onPlayerDamaged();
					m_onEnemyDestroyed();
				}
				else if (auto item = std::dynamic_pointer_cast<Item>(obj)) {
					item->collect();
					m_onItemCollected();
				}
			}
		}
	}

	void draw() const {
		for (const auto& obj : m_gameObjects) {
			obj->draw();
		}

		m_font(U"ì ìˆ˜: {}"_fmt(m_score)).draw(20, 20, Palette::White);
		m_font(U"ì¡°ì‘: ë°©í–¥í‚¤").draw(20, 560, ColorF{ 0.7 });
	}
};

void Main()
{
	Window::SetTitle(U"í˜„ëŒ€ì  C++ ê²Œì„ ì˜ˆì œ");
	Scene::SetBackground(ColorF{ 0.1, 0.2, 0.4 });

	GameManager gameManager;

	while (System::Update())
	{
		gameManager.update();
		gameManager.draw();
	}
}
```

ì´ í†µí•© ì˜ˆì œëŠ” í˜„ëŒ€ì  C++ ê¸°ëŠ¥ì„ ëª¨ë‘ í™œìš©í•˜ì—¬ ê°„ë‹¨í•œ 2D ê²Œì„ì„ êµ¬í˜„í–ˆë‹¤:
- **ëŒë‹¤ í‘œí˜„ì‹**: ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° ê°ì²´ í•„í„°ë§ì— ì‚¬ìš©
- **ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°**: ê²Œì„ ê°ì²´ë“¤ì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ì— í™œìš©
- **ì´ë™ ì˜ë¯¸ë¡ **: ê°ì²´ ì „ì†¡ ì‹œ ì„±ëŠ¥ ìµœì í™”
- **auto í‚¤ì›Œë“œ**: ë³µì¡í•œ íƒ€ì…ì„ ê°„ë‹¨í•˜ê²Œ í‘œí˜„
  


## ê²°ë¡ 
í˜„ëŒ€ì  C++ ê¸°ëŠ¥ë“¤ì€ ì½”ë“œë¥¼ ë” ê°„ê²°í•˜ê³ , ì•ˆì „í•˜ë©°, ì„±ëŠ¥ì´ ì¢‹ê²Œ ë§Œë“¤ì–´ì¤€ë‹¤. Siv3Dì™€ ê°™ì€ ì‹œê°ì  í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•˜ë©´ ì´ëŸ¬í•œ ê°œë…ë“¤ì„ ë” í¥ë¯¸ë¡­ê²Œ ë°°ìš¸ ìˆ˜ ìˆìœ¼ë©°, ì‹¤ì œë¡œ ë™ì‘í•˜ëŠ” ê²°ê³¼ë¬¼ì„ ë§Œë“¤ë©´ì„œ í•™ìŠµí•  ìˆ˜ ìˆë‹¤.  
  
 
