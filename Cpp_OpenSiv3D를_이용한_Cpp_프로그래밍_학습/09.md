# OpenSiv3D를 이용한 C++ 프로그래밍 학습
  
저자: 최흥배, Claude AI  
  
C++ 프로그래밍 언어를 배우는 것에 중점을 두되, Siv3D 프레임워크를 활용하여 시각적으로 흥미로운 예제를 통해 학습 효과를 높이도록 설계 되었다. 단순한 콘솔 프로그램 대신 그래픽, 소리, 상호작용을 포함한 프로그램을 만들며 C++의 개념을 익힐 수 있다.  
  
필요 소프트웨어:  
- Windows 10 이상
- Visual Studio 2022 이상   
  
-----    
    
# Chapter.09: 현대적 C++ 기능

## 9.1 람다 표현식 (Lambda Expressions)
람다 표현식은 익명 함수를 생성하는 기능으로, 코드를 더 간결하고 가독성 있게 만들어 준다.

### 기본 문법:
```cpp
auto 람다이름 = [캡처절](매개변수) -> 반환타입 { 함수 본문 };
```

### Siv3D를 활용한 람다 예제:

```cpp
#include <Siv3D.hpp>

void Main()
{
	// 배경 설정
	Scene::SetBackground(ColorF{ 0.6, 0.8, 0.9 });

	// 버튼 상태와 위치 관리
	bool isButtonPressed = false;
	const Rect button{ Arg::center(400, 300), 200, 80 };

	// 클릭 효과음 로드
	const Audio clickSound{ U"example/sound/click.mp3" };

	// 클릭 처리 람다 함수 정의
	auto handleClick = [&isButtonPressed, &clickSound, &button]() {
		if (button.leftClicked())
		{
			isButtonPressed = !isButtonPressed;
			clickSound.playOneShot();
		}
		};

	// 그리기 함수 람다 정의
	auto drawButton = [&]() {
		// 버튼 상태에 따라 색상 변경
		ColorF buttonColor = isButtonPressed ? ColorF{ 0.9, 0.6, 0.3 } : ColorF{ 0.3, 0.6, 0.9 };
		button.draw(buttonColor);
		button.drawFrame(2, ColorF{ 0.1 });
		FontAsset(U"ButtonFont")(isButtonPressed ? U"켜짐" : U"꺼짐").drawAt(button.center(), ColorF{ 1.0 });
		};

	// 폰트 등록
	FontAsset::Register(U"ButtonFont", 30, Typeface::Bold);

	while (System::Update())
	{
		// 람다 함수 호출
		handleClick();
		drawButton();
	}
}
```

이 예제에서 람다 표현식은 버튼 클릭 처리와 그리기 로직을 캡슐화하여 코드를 더 모듈화한다.
  

## 9.2 스마트 포인터 (Smart Pointers)
스마트 포인터는 메모리 누수를 방지하고 리소스 관리를 자동화하는 현대적 C++의 핵심 기능이다.  

### 주요 스마트 포인터:
- `std::unique_ptr`: 독점 소유권
- `std::shared_ptr`: 공유 소유권
- `std::weak_ptr`: 약한 참조

### Siv3D로 구현한 스마트 포인터 예제:

```cpp
#include <Siv3D.hpp>
#include <memory>
#include <vector>

// 간단한 게임 오브젝트 클래스
class GameObject 
{
private:
    Vec2 m_pos;
    ColorF m_color;
    String m_name;
    
public:
    GameObject(Vec2 pos, ColorF color, String name)
        : m_pos(pos), m_color(color), m_name(name) {}
    
    void update() {
        // 간단한 움직임 로직
        m_pos.x += Random(-2.0, 2.0);
        m_pos.y += Random(-2.0, 2.0);
    }
    
    void draw() const {
        Circle{m_pos, 30}.draw(m_color);
        FontAsset(U"ObjectFont")(m_name).drawAt(m_pos, ColorF{0.1});
    }
    
    const Vec2& getPosition() const {
        return m_pos;
    }
    
    const String& getName() const {
        return m_name;
    }
};

void Main()
{
    // 배경 설정
    Scene::SetBackground(ColorF{0.2, 0.3, 0.4});
    
    // 폰트 등록
    FontAsset::Register(U"ObjectFont", 16, Typeface::Medium);
    
    // 스마트 포인터를 이용한 객체 관리
    std::vector<std::shared_ptr<GameObject>> gameObjects;
    
    // 객체 추가 버튼
    Rect addButton{Arg::center(100, 50), 150, 40};
    
    while (System::Update())
    {
        // 버튼으로 새 객체 추가
        addButton.draw(ColorF{0.4, 0.7, 0.3});
        FontAsset(U"ObjectFont")(U"객체 추가").drawAt(addButton.center(), ColorF{1.0});
        
        if (addButton.leftClicked())
        {
            // unique_ptr 생성 후 shared_ptr로 변환하여 저장
            auto newObject = std::make_unique<GameObject>(
                Vec2{Random(100.0, 700.0), Random(100.0, 500.0)},
                ColorF{Random(0.0, 1.0), Random(0.0, 1.0), Random(0.0, 1.0)},
                U"객체-{}"_fmt(gameObjects.size() + 1)
            );
            
            // unique_ptr를 shared_ptr로 변환하여 저장
            gameObjects.push_back(std::shared_ptr<GameObject>(newObject.release()));
        }
        
        // 객체 제거 버튼
        Rect removeButton{Arg::center(300, 50), 150, 40};
        removeButton.draw(ColorF{0.7, 0.4, 0.3});
        FontAsset(U"ObjectFont")(U"객체 제거").drawAt(removeButton.center(), ColorF{1.0});
        
        if (removeButton.leftClicked() && !gameObjects.empty())
        {
            // 객체 제거 (스마트 포인터가 자동으로 메모리 해제)
            gameObjects.pop_back();
        }
        
        // 객체 정보 표시 및 업데이트
        for (auto& obj : gameObjects)
        {
            obj->update();
            obj->draw();
        }
        
        // 현재 객체 수 표시
        FontAsset(U"ObjectFont")(U"현재 객체 수: {}"_fmt(gameObjects.size()))
            .draw(20, 100, ColorF{1.0});
    }
}
```

이 예제에서는 `std::unique_ptr`과 `std::shared_ptr`를 사용하여 게임 오브젝트의 수명을 관리한다. 메모리 누수 걱정 없이 객체를 생성하고 제거할 수 있다.
  


## 9.3 이동 의미론 (Move Semantics)
이동 의미론은 불필요한 복사를 줄이고 성능을 최적화하는 C++11부터 도입된 중요한 기능이다.

### 핵심 개념:
- 우측값 참조 (rvalue reference)
- 이동 생성자 (move constructor)
- 이동 대입 연산자 (move assignment operator)

### Siv3D를 활용한 이동 의미론 예제:

```cpp
#include <Siv3D.hpp>
#include <vector>

// 무거운 리소스를 가진 클래스 (예: 큰 이미지 데이터)
class ImageResource 
{
private:
    Array<ColorF> m_pixels;
    String m_name;
    Vec2 m_pos;
    
public:
    // 일반 생성자
    ImageResource(const String& name, size_t size, Vec2 pos)
        : m_pixels(size * size), m_name(name), m_pos(pos)
    {
        // 임의 패턴으로 픽셀 초기화
        for (auto& pixel : m_pixels)
        {
            pixel = ColorF{Random(0.0, 1.0), Random(0.0, 1.0), Random(0.0, 1.0)};
        }
        
        Print << U"[생성됨] " << m_name;
    }
    
    // 복사 생성자 (의도적으로 비효율적으로 만듦)
    ImageResource(const ImageResource& other)
        : m_pixels(other.m_pixels), m_name(other.m_name + U"의 복사본"), m_pos(other.m_pos + Vec2{10, 10})
    {
        Print << U"[복사됨] " << m_name << U" (비용 높음)";
        
        // 복사에 시간이 걸리는 것 시뮬레이션
        System::Sleep(500ms);
    }
    
    // 이동 생성자
    ImageResource(ImageResource&& other) noexcept
        : m_pixels(std::move(other.m_pixels)), 
          m_name(std::move(other.m_name) + U"(이동됨)"), 
          m_pos(other.m_pos + Vec2{50, 0})
    {
        Print << U"[이동됨] " << m_name << U" (효율적)";
        
        // 이동은 빠름
        other.m_pixels.clear();
    }
    
    // 이동 대입 연산자
    ImageResource& operator=(ImageResource&& other) noexcept {
        if (this != &other)
        {
            m_pixels = std::move(other.m_pixels);
            m_name = std::move(other.m_name) + U"(이동 대입됨)";
            m_pos = other.m_pos;
            
            Print << U"[이동 대입] " << m_name;
            
            other.m_pixels.clear();
        }
        return *this;
    }
    
    // 소멸자
    ~ImageResource() {
        if (!m_pixels.empty()) {
            Print << U"[제거됨] " << m_name;
        }
    }
    
    void draw() const {
        if (m_pixels.empty()) return;
        
        // 이미지 데이터 시각화
        const int size = static_cast<int>(std::sqrt(m_pixels.size()));
        for (int y = 0; y < size; ++y) {
            for (int x = 0; x < size; ++x) {
                const int index = y * size + x;
                if (index < m_pixels.size()) {
                    Rect{static_cast<int>(m_pos.x) + x * 2, 
                         static_cast<int>(m_pos.y) + y * 2, 2, 2}
                        .draw(m_pixels[index]);
                }
            }
        }
        
        // 이름 표시
        FontAsset(U"ResourceFont")(m_name).draw(m_pos.x, m_pos.y - 20, ColorF{1.0});
    }
    
    ImageResource createCopy() const {
        return *this;  // 복사 생성자 호출
    }
    
    ImageResource createMove() {
        return std::move(*this);  // 이동 생성자 호출
    }
};

void Main()
{
    // 배경 설정
    Scene::SetBackground(ColorF{0.1, 0.1, 0.2});
    
    // 폰트 등록
    FontAsset::Register(U"ResourceFont", 16, Typeface::Medium);
    FontAsset::Register(U"ButtonFont", 20, Typeface::Bold);
    
    // 리소스 관리
    std::vector<ImageResource> resources;
    
    // 원본 리소스 생성
    resources.emplace_back(U"원본 이미지", 30, Vec2{100, 150});
    
    // 버튼 설정
    const Rect copyButton{50, 50, 200, 40};
    const Rect moveButton{300, 50, 200, 40};
    const Rect clearButton{550, 50, 200, 40};
    
    while (System::Update())
    {
        // 복사 버튼
        copyButton.draw(ColorF{0.6, 0.3, 0.3});
        FontAsset(U"ButtonFont")(U"복사").drawAt(copyButton.center(), ColorF{1.0});
        
        if (copyButton.leftClicked() && !resources.empty())
        {
            // 복사 생성자 호출
            resources.push_back(resources[0].createCopy());
        }
        
        // 이동 버튼
        moveButton.draw(ColorF{0.3, 0.6, 0.3});
        FontAsset(U"ButtonFont")(U"이동").drawAt(moveButton.center(), ColorF{1.0});
        
        if (moveButton.leftClicked() && resources.size() >= 2)
        {
            // 마지막 리소스를 이동하여 새 리소스 생성
            resources.push_back(std::move(resources.back()));
            resources.erase(resources.end() - 2);  // 이동된 객체 제거
        }
        
        // 초기화 버튼
        clearButton.draw(ColorF{0.3, 0.3, 0.6});
        FontAsset(U"ButtonFont")(U"초기화").drawAt(clearButton.center(), ColorF{1.0});
        
        if (clearButton.leftClicked())
        {
            resources.clear();
            resources.emplace_back(U"원본 이미지", 30, Vec2{100, 150});
        }
        
        // 리소스 그리기
        for (const auto& resource : resources)
        {
            resource.draw();
        }
        
        // 설명 표시
        FontAsset(U"ResourceFont")(U"리소스 개수: {}"_fmt(resources.size()))
            .draw(50, 100, ColorF{1.0});
    }
}
```

이 예제는 이동 의미론의 효율성을 시각적으로 보여준다. 복사는 느리고 비용이 높지만, 이동은 효율적이며 성능을 크게 향상시킨다.
  

## 9.4 auto 키워드
`auto` 키워드는 컴파일러가 변수의 타입을 자동으로 추론하게 해주는 기능으로, 코드를 더 간결하게 작성할 수 있다.

### Siv3D로 구현한 auto 키워드 활용 예제:

```cpp
#include <Siv3D.hpp>
#include <map>
#include <vector>

void Main()
{
    // 배경 설정
    Scene::SetBackground(ColorF{0.1, 0.2, 0.3});
    
    // 폰트 등록
    FontAsset::Register(U"MainFont", 24, Typeface::Bold);
    FontAsset::Register(U"DescFont", 16, Typeface::Medium);
    
    // auto를 활용한 다양한 데이터 구조 예제
    
    // 1. auto와 컬렉션
    std::vector<int> numbers = {5, 10, 15, 20, 25};
    int sum = 0;
    
    // 기존 방식
    for (std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
        sum += *it;
    }
    
    // auto 활용 방식
    sum = 0;
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        sum += *it;
    }
    
    // 범위 기반 for문과 auto
    sum = 0;
    for (const auto& num : numbers) {
        sum += num;
    }
    
    // 2. 복잡한 타입과 auto
    std::map<String, std::vector<ColorF>> colorCollections;
    colorCollections[U"빨강계열"] = {ColorF{0.8, 0.2, 0.2}, ColorF{1.0, 0.4, 0.4}, ColorF{0.6, 0.0, 0.0}};
    colorCollections[U"파랑계열"] = {ColorF{0.2, 0.2, 0.8}, ColorF{0.4, 0.4, 1.0}, ColorF{0.0, 0.0, 0.6}};
    
    // auto 없이 표현하기 복잡한 타입 간소화
    auto colorIterator = colorCollections.find(U"빨강계열");
    
    // 3. 람다와 함께 사용
    auto calculateDistance = [](const Vec2& a, const Vec2& b) {
        return Math::Sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
    };
    
    // 4. 가독성 향상 예제
    auto windowWidth = Window::Width();
    auto windowCenter = Scene::Center();
    
    // 인터랙티브 데모
    while (System::Update())
    {
        // 제목 표시
        FontAsset(U"MainFont")(U"auto 키워드 활용 예제").drawAt(400, 50, ColorF{1.0});
        
        // 설명 및 예제 표시
        int y = 100;
        
        FontAsset(U"DescFont")(U"1. 반복자 사용 간소화:").draw(50, y, ColorF{1.0});
        y += 30;
        FontAsset(U"DescFont")(U"기존: std::vector<int>::iterator it = numbers.begin();").draw(70, y, ColorF{0.8, 0.8, 1.0});
        y += 30;
        FontAsset(U"DescFont")(U"auto 사용: auto it = numbers.begin();").draw(70, y, ColorF{0.4, 1.0, 0.4});
        y += 50;
        
        FontAsset(U"DescFont")(U"2. 복잡한 타입 간소화:").draw(50, y, ColorF{1.0});
        y += 30;
        FontAsset(U"DescFont")(U"기존: std::map<String, std::vector<ColorF>>::iterator it;").draw(70, y, ColorF{0.8, 0.8, 1.0});
        y += 30;
        FontAsset(U"DescFont")(U"auto 사용: auto it = colorCollections.find(key);").draw(70, y, ColorF{0.4, 1.0, 0.4});
        y += 50;
        
        FontAsset(U"DescFont")(U"3. 람다 표현식 활용:").draw(50, y, ColorF{1.0});
        y += 30;
        
        // 람다 함수 사용 데모 - 마우스 위치와의 거리 계산
        Vec2 point1{300, y};
        Vec2 point2{Cursor::Pos()};
        
        Circle{point1, 10}.draw(ColorF{1.0, 0.7, 0.1});
        Line{point1, point2}.draw(2, ColorF{0.7, 0.7, 0.7});
        
        auto distance = calculateDistance(point1, point2);
        FontAsset(U"DescFont")(U"두 점 사이 거리: {:.1f}"_fmt(distance)).draw(point1.x + 20, point1.y - 10, ColorF{1.0});
        
        y += 50;
        
        FontAsset(U"DescFont")(U"4. 가독성 향상:").draw(50, y, ColorF{1.0});
        y += 30;
        FontAsset(U"DescFont")(U"윈도우 크기: {} x {}"_fmt(windowWidth, Window::Height())).draw(70, y, ColorF{0.4, 1.0, 0.4});
        y += 30;
        FontAsset(U"DescFont")(U"화면 중앙: ({:.1f}, {:.1f})"_fmt(windowCenter.x, windowCenter.y)).draw(70, y, ColorF{0.4, 1.0, 0.4});
        
        // 색상 컬렉션 시각화
        y += 50;
        FontAsset(U"DescFont")(U"컬러 컬렉션 (auto로 순회):").draw(50, y, ColorF{1.0});
        y += 30;
        
        int x = 70;
        for (const auto& [name, colors] : colorCollections) {
            FontAsset(U"DescFont")(name).draw(x, y, ColorF{1.0});
            
            for (size_t i = 0; i < colors.size(); ++i) {
                Rect{x + static_cast<int>(i) * 40, y + 20, 30, 30}.draw(colors[i]);
            }
            
            y += 70;
        }
    }
}
```

이 예제는 `auto`의 다양한 활용 방법을 보여주며, 특히 복잡한 타입 명시를 간소화하는 방법과 가독성 향상에 초점을 맞추고 있다.  
  

## 최종 통합 예제: 현대적 C++ 기능을 활용한 간단한 게임
아래 예제는 람다 표현식, 스마트 포인터, 이동 의미론, auto 키워드를 모두 활용한 간단한 게임이다:

```cpp
#include <Siv3D.hpp>
#include <memory>
#include <vector>
#include <functional>

// 네임스페이스를 사용하면 코드가 간결해집니다.
using namespace s3d;

// 게임 객체 인터페이스
class GameObject {
public:
	virtual ~GameObject() = default;
	virtual void update() = 0;
	virtual void draw() const = 0;
	virtual bool isAlive() const = 0;
	virtual RectF getCollider() const = 0; // [변경] Rect -> RectF
};

// 플레이어 클래스
class Player : public GameObject {
private:
	Vec2 m_pos;
	Texture m_texture;
	bool m_isAlive;

public:
	Player(const Vec2& pos, const Texture& texture)
		: m_pos(pos), m_texture(texture), m_isAlive(true) {
	}

	void update() override {
		Vec2 velocity{ 0, 0 };

		if (KeyLeft.pressed()) velocity.x -= 5;
		if (KeyRight.pressed()) velocity.x += 5;
		if (KeyUp.pressed()) velocity.y -= 5;
		if (KeyDown.pressed()) velocity.y += 5;

		m_pos += velocity;

		// [변경] 하드코딩된 화면 크기 대신 Scene::Rect() 사용
		m_pos = m_pos.clamp(Scene::Rect());
	}

	void draw() const override {
		m_texture.drawAt(m_pos);
	}

	bool isAlive() const override {
		return m_isAlive;
	}

	void setAlive(bool alive) {
		m_isAlive = alive;
	}

	RectF getCollider() const override {
		// [변경] RectF 생성자 문법 변경
		return RectF{ Arg::center = m_pos, 40, 40 };
	}
};

// 적 클래스
class Enemy : public GameObject {
private:
	Vec2 m_pos;
	Vec2 m_velocity;
	ColorF m_color;
	bool m_isAlive;

public:
	Enemy(const Vec2& pos, const Vec2& velocity, const ColorF& color)
		: m_pos(pos), m_velocity(velocity), m_color(color), m_isAlive(true) {
	}

	void update() override {
		m_pos += m_velocity;

		// [변경] 화면 밖으로 나가면 반대 방향으로 (더 간결한 방식)
		if ((m_pos.x < 0 && m_velocity.x < 0) || (m_pos.x > Scene::Width() && m_velocity.x > 0))
		{
			m_velocity.x *= -1;
		}
		if ((m_pos.y < 0 && m_velocity.y < 0) || (m_pos.y > Scene::Height() && m_velocity.y > 0))
		{
			m_velocity.y *= -1;
		}
	}

	void draw() const override {
		Circle{ m_pos, 20 }.draw(m_color);
	}

	bool isAlive() const override {
		return m_isAlive;
	}

	void destroy() {
		m_isAlive = false;
	}

	RectF getCollider() const override {
		// [변경] RectF 생성자 문법 변경
		return RectF{ Arg::center = m_pos, 40, 40 };
	}
};

// 아이템 클래스
class Item : public GameObject {
private:
	Vec2 m_pos;
	double m_angle;
	Texture m_texture;
	bool m_isAlive;

public:
	Item(const Vec2& pos, const Texture& texture)
		: m_pos(pos), m_angle(0), m_texture(texture), m_isAlive(true) {
	}

	void update() override {
		m_angle += 0.02;
		m_pos.y += Math::Sin(m_angle) * 0.5;
	}

	void draw() const override {
		m_texture.scaled(0.5).rotated(m_angle).drawAt(m_pos);
	}

	bool isAlive() const override {
		return m_isAlive;
	}

	void collect() {
		m_isAlive = false;
	}

	RectF getCollider() const override {
		// [변경] RectF 생성자 문법 변경
		return RectF{ Arg::center = m_pos, 30, 30 };
	}
};

// 게임 매니저 클래스
class GameManager {
private:
	// [변경] unique_ptr -> shared_ptr로 통일
	std::vector<std::shared_ptr<GameObject>> m_gameObjects;
	std::shared_ptr<Player> m_player;
	Texture m_playerTexture;
	Texture m_itemTexture;
	Font m_font;
	Audio m_itemSound;
	Audio m_damageSound;
	int m_score;

	std::function<void()> m_onEnemyDestroyed;
	std::function<void()> m_onItemCollected;
	std::function<void()> m_onPlayerDamaged;

public:
	GameManager()
		: m_playerTexture{ U"🚀"_emoji }
		, m_itemTexture{ U"⭐"_emoji }
		, m_font{ 30, Typeface::Bold }
		, m_itemSound{ GMInstrument::Marimba, static_cast<uint8>(PianoKey::C5), 0.5s }
		, m_damageSound{ GMInstrument::BrassSection, static_cast<uint8>(PianoKey::A3), 0.5s }
		, m_score{ 0 }
	{
		m_player = std::make_shared<Player>(Scene::Center(), m_playerTexture);
		m_gameObjects.push_back(m_player); // [변경] shared_ptr를 바로 추가

		m_onEnemyDestroyed = [this]() {
			m_score += 100;
			spawnEnemy();
			};
		m_onItemCollected = [this]() {
			m_score += 50;
			m_itemSound.playOneShot();
			spawnItem();
			};
		m_onPlayerDamaged = [this]() {
			m_score = Max(0, m_score - 30);
			m_damageSound.playOneShot();
			};

		for (int i = 0; i < 5; ++i) spawnEnemy();
		for (int i = 0; i < 3; ++i) spawnItem();
	}

	void spawnEnemy() {
		// [변경] make_shared 사용 및 RandomVec2로 간결화
		const Vec2 velocity = RandomVec2(Circle{ 3.0 });
		const ColorF color{ Random(0.5, 1.0), Random(0.5, 1.0), Random(0.5, 1.0) };
		auto enemy = std::make_shared<Enemy>(RandomVec2(Scene::Rect()), velocity, color);
		m_gameObjects.push_back(enemy);
	}

	void spawnItem() {
		// [변경] make_shared 사용
		auto item = std::make_shared<Item>(RandomVec2(Scene::Rect()), m_itemTexture);
		m_gameObjects.push_back(item);
	}

	void update() {
		for (auto& obj : m_gameObjects) {
			obj->update();
		}

		checkCollisions();

		// [변경] C++20 Ranges 문법으로 더 간결하게 제거 (Erase-Remove Idiom과 동일)
		std::erase_if(m_gameObjects, [](const auto& obj) { return !obj->isAlive(); });
	}

	void checkCollisions() {
		if (!m_player || !m_player->isAlive()) return;

		const auto playerCollider = m_player->getCollider();

		for (auto& obj : m_gameObjects) {
			if (obj == m_player) continue;

			if (playerCollider.intersects(obj->getCollider())) {
				if (auto enemy = std::dynamic_pointer_cast<Enemy>(obj)) {
					enemy->destroy();
					m_onPlayerDamaged();
					m_onEnemyDestroyed();
				}
				else if (auto item = std::dynamic_pointer_cast<Item>(obj)) {
					item->collect();
					m_onItemCollected();
				}
			}
		}
	}

	void draw() const {
		for (const auto& obj : m_gameObjects) {
			obj->draw();
		}

		m_font(U"점수: {}"_fmt(m_score)).draw(20, 20, Palette::White);
		m_font(U"조작: 방향키").draw(20, 560, ColorF{ 0.7 });
	}
};

void Main()
{
	Window::SetTitle(U"현대적 C++ 게임 예제");
	Scene::SetBackground(ColorF{ 0.1, 0.2, 0.4 });

	GameManager gameManager;

	while (System::Update())
	{
		gameManager.update();
		gameManager.draw();
	}
}
```

이 통합 예제는 현대적 C++ 기능을 모두 활용하여 간단한 2D 게임을 구현했다:
- **람다 표현식**: 이벤트 처리 및 객체 필터링에 사용
- **스마트 포인터**: 게임 객체들의 메모리 관리에 활용
- **이동 의미론**: 객체 전송 시 성능 최적화
- **auto 키워드**: 복잡한 타입을 간단하게 표현
  


## 결론
현대적 C++ 기능들은 코드를 더 간결하고, 안전하며, 성능이 좋게 만들어준다. Siv3D와 같은 시각적 프레임워크를 활용하면 이러한 개념들을 더 흥미롭게 배울 수 있으며, 실제로 동작하는 결과물을 만들면서 학습할 수 있다.  
  
 
