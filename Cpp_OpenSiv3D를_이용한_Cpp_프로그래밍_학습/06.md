# OpenSiv3Dë¥¼ ì´ìš©í•œ C++ í”„ë¡œê·¸ë˜ë° í•™ìŠµ
  
ì €ì: ìµœí¥ë°°, Claude AI  
  
C++ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ë°°ìš°ëŠ” ê²ƒì— ì¤‘ì ì„ ë‘ë˜, Siv3D í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•˜ì—¬ ì‹œê°ì ìœ¼ë¡œ í¥ë¯¸ë¡œìš´ ì˜ˆì œë¥¼ í†µí•´ í•™ìŠµ íš¨ê³¼ë¥¼ ë†’ì´ë„ë¡ ì„¤ê³„ ë˜ì—ˆë‹¤. ë‹¨ìˆœí•œ ì½˜ì†” í”„ë¡œê·¸ë¨ ëŒ€ì‹  ê·¸ë˜í”½, ì†Œë¦¬, ìƒí˜¸ì‘ìš©ì„ í¬í•¨í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ë©° C++ì˜ ê°œë…ì„ ìµí ìˆ˜ ìˆë‹¤.  
  
í•„ìš” ì†Œí”„íŠ¸ì›¨ì–´:  
- Windows 10 ì´ìƒ
- Visual Studio 2022 ì´ìƒ   
  
-----    
    
# Chapter.6: ìƒì†ê³¼ ë‹¤í˜•ì„±

ìƒì†ê³¼ ë‹¤í˜•ì„±ì€ ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ ê°œë…ìœ¼ë¡œ, ì½”ë“œ ì¬ì‚¬ìš©ì„±ì„ ë†’ì´ê³  ë³µì¡í•œ ì‹œìŠ¤í…œì„ íš¨ìœ¨ì ìœ¼ë¡œ ì„¤ê³„í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.  
ì´ë²ˆ ë‹¨ê³„ì—ì„œëŠ” C++ì˜ ìƒì†ê³¼ ë‹¤í˜•ì„± ê°œë…ì„ Siv3D í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•´ ì‹œê°ì ì´ê³  ì¬ë¯¸ìˆëŠ” ë°©ì‹ìœ¼ë¡œ ë°°ì›Œë³´ê² ë‹¤.  
  

## 6.1 ìƒì† ê¸°ë³¸ ê°œë…

### ìƒì†ì˜ ê°œë…
ìƒì†(Inheritance)ì€ ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ì†ì„±ê³¼ ê¸°ëŠ¥ì„ ìƒˆë¡œìš´ í´ë˜ìŠ¤ê°€ ë¬¼ë ¤ë°›ì•„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì´ë‹¤. ì´ë¥¼ í†µí•´ ì½”ë“œ ì¤‘ë³µì„ ì¤„ì´ê³  ê³„ì¸µì  ê´€ê³„ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.  

```cpp
// ê¸°ë³¸ í´ë˜ìŠ¤ (ë¶€ëª¨ í´ë˜ìŠ¤)
class GameObject 
{
protected:
    Vec2 position;
    double rotation;
    
public:
    GameObject(const Vec2& pos, double rot) 
        : position(pos), rotation(rot) {}
    
    void setPosition(const Vec2& pos) {
        position = pos;
    }
    
    Vec2 getPosition() const {
        return position;
    }
    
    void setRotation(double rot) {
        rotation = rot;
    }
    
    double getRotation() const {
        return rotation;
    }
    
    void update() {
        // ê¸°ë³¸ ì—…ë°ì´íŠ¸ ë¡œì§
    }
    
    void draw() const {
        // ê¸°ë³¸ ê·¸ë¦¬ê¸° ë¡œì§
    }
};

// íŒŒìƒ í´ë˜ìŠ¤ (ìì‹ í´ë˜ìŠ¤)
class Character : public GameObject {
private:
    String name;
    double speed;
    
public:
    Character(const Vec2& pos, double rot, const String& charName, double charSpeed)
        : GameObject(pos, rot), name(charName), speed(charSpeed) {}
    
    void move(const Vec2& direction) {
        position += direction * speed;
    }
    
    String getName() const {
        return name;
    }
    
    void draw() const {
        // ìºë¦­í„° ê·¸ë¦¬ê¸° ë¡œì§
        Circle{position, 30}.draw(ColorF{0.6, 0.8, 0.3});
        FontAsset(U"Regular")(name).drawAt(position.movedBy(0, -40));
    }
};
```

### ìƒì†ì˜ ì¢…ë¥˜
C++ì—ì„œ ìƒì†ì€ ì ‘ê·¼ ì œì–´ìì— ë”°ë¼ ë‹¤ìŒê³¼ ê°™ì´ êµ¬ë¶„ëœë‹¤:

- **public ìƒì†**: ë¶€ëª¨ í´ë˜ìŠ¤ì˜ public ë©¤ë²„ëŠ” publicìœ¼ë¡œ, protected ë©¤ë²„ëŠ” protectedë¡œ ìƒì†ëœë‹¤.
- **protected ìƒì†**: ë¶€ëª¨ í´ë˜ìŠ¤ì˜ public, protected ë©¤ë²„ê°€ ëª¨ë‘ protectedë¡œ ìƒì†ëœë‹¤.
- **private ìƒì†**: ë¶€ëª¨ í´ë˜ìŠ¤ì˜ public, protected ë©¤ë²„ê°€ ëª¨ë‘ privateìœ¼ë¡œ ìƒì†ëœë‹¤.
  
```cpp
class PublicDerived : public GameObject { /* ... */ };
class ProtectedDerived : protected GameObject { /* ... */ };
class PrivateDerived : private GameObject { /* ... */ };
```
  

## 6.2 ê°€ìƒ í•¨ìˆ˜ì™€ ë‹¤í˜•ì„±

### ê°€ìƒ í•¨ìˆ˜(Virtual Function)
ê°€ìƒ í•¨ìˆ˜ëŠ” íŒŒìƒ í´ë˜ìŠ¤ì—ì„œ ì¬ì •ì˜(override)í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ì´ë‹¤. `virtual` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì„ ì–¸í•œë‹¤.  

```cpp
class Shape 
{
protected:
    Vec2 position;
    ColorF color;
    
public:
    Shape(const Vec2& pos, const ColorF& col)
        : position(pos), color(col) {}
    
    // ê°€ìƒ í•¨ìˆ˜ ì„ ì–¸
    virtual void draw() const {
        // ê¸°ë³¸ ë„í˜• ê·¸ë¦¬ê¸° ë¡œì§
    }
    
    virtual double getArea() const {
        return 0.0; // ê¸°ë³¸ êµ¬í˜„ì€ ë©´ì  0
    }
};

class Circle : public Shape 
{
private:
    double radius;
    
public:
    Circle(const Vec2& pos, double r, const ColorF& col)
        : Shape(pos, col), radius(r) {}
    
    // ê°€ìƒ í•¨ìˆ˜ ì¬ì •ì˜(ì˜¤ë²„ë¼ì´ë“œ)
    void draw() const override {
        Siv3D::Circle{position, radius}.draw(color);
    }
    
    double getArea() const override {
        return Math::Pi * radius * radius;
    }
};

class Rectangle : public Shape 
{
private:
    double width;
    double height;
    
public:
    Rectangle(const Vec2& pos, double w, double h, const ColorF& col)
        : Shape(pos, col), width(w), height(h) {}
    
    // ê°€ìƒ í•¨ìˆ˜ ì¬ì •ì˜(ì˜¤ë²„ë¼ì´ë“œ)
    void draw() const override {
        RectF{position, width, height}.draw(color);
    }
    
    double getArea() const override {
        return width * height;
    }
};
```

### ë‹¤í˜•ì„±(Polymorphism)
ë‹¤í˜•ì„±ì€ ê°™ì€ ì¸í„°í˜ì´ìŠ¤ë¡œ ë‹¤ì–‘í•œ ê°ì²´ë¥¼ ë‹¤ë£° ìˆ˜ ìˆëŠ” ëŠ¥ë ¥ì´ë‹¤. C++ì—ì„œëŠ” ë² ì´ìŠ¤ í´ë˜ìŠ¤ í¬ì¸í„°ë‚˜ ì°¸ì¡°ë¥¼ í†µí•´ íŒŒìƒ í´ë˜ìŠ¤ ê°ì²´ì— ì ‘ê·¼í•  ë•Œ ë‹¤í˜•ì„±ì´ ë°œìƒí•œë‹¤.

```cpp
// ë‹¤í˜•ì„± í™œìš© ì˜ˆì œ
void drawShape(const Shape& shape) {
    shape.draw(); // ì‹¤ì œ ê°ì²´ì˜ íƒ€ì…ì— ë”°ë¼ ì ì ˆí•œ draw í•¨ìˆ˜ê°€ í˜¸ì¶œë¨
}

// ì‚¬ìš© ì˜ˆì‹œ
Circle circle{Vec2{200, 200}, 50, ColorF{0.8, 0.2, 0.2}};
Rectangle rect{Vec2{400, 200}, 80, 60, ColorF{0.2, 0.8, 0.2}};

drawShape(circle); // Circleì˜ draw í•¨ìˆ˜ í˜¸ì¶œ
drawShape(rect); // Rectangleì˜ draw í•¨ìˆ˜ í˜¸ì¶œ

// í¬ì¸í„° ë°°ì—´ì„ í†µí•œ ë‹¤í˜•ì„±
Array<std::unique_ptr<Shape>> shapes;
shapes << std::make_unique<Circle>(Vec2{100, 100}, 30, ColorF{0.8, 0.3, 0.3});
shapes << std::make_unique<Rectangle>(Vec2{200, 100}, 60, 40, ColorF{0.3, 0.8, 0.3});

// ëª¨ë“  ë„í˜• ê·¸ë¦¬ê¸°
for (const auto& shape : shapes) {
    shape->draw();
}
```
  

## 6.3 ì¶”ìƒ í´ë˜ìŠ¤ì™€ ì¸í„°í˜ì´ìŠ¤

### ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜ì™€ ì¶”ìƒ í´ë˜ìŠ¤
ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜(pure virtual function)ëŠ” êµ¬í˜„ì´ ì—†ëŠ” ê°€ìƒ í•¨ìˆ˜ë¡œ, `= 0`ìœ¼ë¡œ ì„ ì–¸í•œë‹¤. í•˜ë‚˜ ì´ìƒì˜ ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜ë¥¼ í¬í•¨í•˜ëŠ” í´ë˜ìŠ¤ë¥¼ ì¶”ìƒ í´ë˜ìŠ¤(abstract class)ë¼ê³  í•˜ë©°, ì´ëŠ” ì§ì ‘ ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ì—†ë‹¤.  
  
```cpp
// ì¶”ìƒ í´ë˜ìŠ¤
class Drawable 
{
public:
    // ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜
    virtual void draw() const = 0;
    
    // ì¼ë°˜ ê°€ìƒ í•¨ìˆ˜
    virtual void update() {
        // ê¸°ë³¸ êµ¬í˜„
    }
    
    // ê°€ìƒ ì†Œë©¸ì
    virtual ~Drawable() = default;
};

// ì¶”ìƒ í´ë˜ìŠ¤ êµ¬í˜„
class AnimatedSprite : public Drawable 
{
private:
    Texture texture;
    Array<RectF> frames;
    int currentFrame;
    double animationSpeed;
    Vec2 position;
    
public:
    AnimatedSprite(const Texture& tex, const Array<RectF>& frameRects, double speed, const Vec2& pos)
        : texture(tex), frames(frameRects), currentFrame(0), animationSpeed(speed), position(pos) {}
    
    // ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜ êµ¬í˜„
    void draw() const override {
        texture(frames[currentFrame]).drawAt(position);
    }
    
    void update() override {
        // í”„ë ˆì„ ì—…ë°ì´íŠ¸
        currentFrame = (currentFrame + static_cast<int>(Scene::DeltaTime() * animationSpeed)) % frames.size();
    }
};
```

### ì¸í„°í˜ì´ìŠ¤ íŒ¨í„´
C++ì—ëŠ” ì¸í„°í˜ì´ìŠ¤ í‚¤ì›Œë“œê°€ ì—†ì§€ë§Œ, ëª¨ë“  í•¨ìˆ˜ê°€ ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜ì¸ ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ í†µí•´ ì¸í„°í˜ì´ìŠ¤ íŒ¨í„´ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.  
  
```cpp
// ì¸í„°í˜ì´ìŠ¤ íŒ¨í„´
class Clickable 
{
public:
    virtual bool onClick(const Vec2& mousePos) = 0;
    virtual ~Clickable() = default;
};

class Hoverable 
{
public:
    virtual void onHover(const Vec2& mousePos) = 0;
    virtual ~Hoverable() = default;
};

// ì—¬ëŸ¬ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
class Button : public Drawable, public Clickable, public Hoverable 
{
private:
    RectF rect;
    String label;
    std::function<void()> action;
    ColorF normalColor;
    ColorF hoverColor;
    bool isHovering;
    
public:
    Button(const RectF& buttonRect, const String& buttonLabel, const std::function<void()>& buttonAction)
        : rect(buttonRect), label(buttonLabel), action(buttonAction),
          normalColor(0.3, 0.3, 0.8), hoverColor(0.4, 0.4, 0.9), isHovering(false) {}
    
    void draw() const override {
        rect.draw(isHovering ? hoverColor : normalColor);
        FontAsset(U"Regular")(label).drawAt(rect.center(), ColorF{1.0});
    }
    
    bool onClick(const Vec2& mousePos) override {
        if (rect.contains(mousePos)) {
            action();
            return true;
        }
        return false;
    }
    
    void onHover(const Vec2& mousePos) override {
        isHovering = rect.contains(mousePos);
    }
};
```
  

## 6.4 Siv3D í™œìš© ì˜ˆì œ: ë‹¤ì–‘í•œ ì  ìºë¦­í„° ìƒì† êµ¬ì¡° ë§Œë“¤ê¸°
ì´ì œ ìƒì†ê³¼ ë‹¤í˜•ì„±ì„ í™œìš©í•˜ì—¬ ë‹¤ì–‘í•œ ì  ìºë¦­í„° ì‹œìŠ¤í…œì„ êµ¬í˜„í•´ ë³´ê² ë‹¤.

```cpp
#include <Siv3D.hpp>

// ì  ìºë¦­í„°ì˜ ê¸°ë³¸ í´ë˜ìŠ¤
class Enemy 
{
protected:
    Vec2 position;
    double health;
    double speed;
    Texture texture;
    double radius;
    
public:
    Enemy(const Vec2& pos, double hp, double spd, const Texture& tex, double rad)
        : position(pos), health(hp), speed(spd), texture(tex), radius(rad) {}
    
    virtual ~Enemy() = default;
    
    // ê°€ìƒ í•¨ìˆ˜ë“¤
    virtual void update() {
        // ê¸°ë³¸ ì´ë™ ë¡œì§
        move();
    }
    
    virtual void draw() const {
        texture.resized(radius * 2).drawAt(position);
        
        // ì²´ë ¥ë°” í‘œì‹œ
        const double barWidth = radius * 2;
        const double barHeight = 5.0;
        const Vec2 barPos = position.movedBy(0, -radius - 10);
        
        RectF{barPos.x - barWidth / 2, barPos.y, barWidth, barHeight}.draw(ColorF{0.3});
        RectF{barPos.x - barWidth / 2, barPos.y, barWidth * (health / 100.0), barHeight}.draw(ColorF{0.8, 0.2, 0.2});
    }
    
    virtual void takeDamage(double damage) {
        health = Max(0.0, health - damage);
    }
    
    virtual bool isDead() const {
        return health <= 0;
    }
    
    virtual double getCollisionRadius() const {
        return radius;
    }
    
    virtual Vec2 getPosition() const {
        return position;
    }
    
protected:
    // ê° ì  íƒ€ì…ë³„ë¡œ ë‹¤ë¥¸ ì´ë™ ë°©ì‹ êµ¬í˜„
    virtual void move() = 0;
};

// ì§ì„  ì´ë™í•˜ëŠ” ì 
class LinearEnemy : public Enemy 
{
private:
    Vec2 direction;
    
public:
    LinearEnemy(const Vec2& pos, const Vec2& dir, double spd = 2.0)
        : Enemy(pos, 100, spd, Texture{U"ğŸ‘¾"_emoji}, 30), direction(dir.normalized()) {}
    
protected:
    void move() override {
        position += direction * speed;
        
        // í™”ë©´ ê²½ê³„ì— ë‹¿ìœ¼ë©´ ë°©í–¥ ì „í™˜
        if (position.x < radius || position.x > Scene::Width() - radius) {
            direction.x *= -1;
            position.x = Clamp(position.x, radius, Scene::Width() - radius);
        }
        
        if (position.y < radius || position.y > Scene::Height() - radius) {
            direction.y *= -1;
            position.y = Clamp(position.y, radius, Scene::Height() - radius);
        }
    }
};

// ì¶”ì í•˜ëŠ” ì 
class ChasingEnemy : public Enemy 
{
private:
    Vec2 targetPosition;
    
public:
    ChasingEnemy(const Vec2& pos, double spd = 1.5)
        : Enemy(pos, 150, spd, Texture{U"ğŸ‘¹"_emoji}, 35), targetPosition(Scene::Center()) {}
    
    void setTarget(const Vec2& target) {
        targetPosition = target;
    }
    
protected:
    void move() override {
        Vec2 direction = (targetPosition - position);
        
        if (!direction.isZero()) {
            direction = direction.normalized();
            position += direction * speed;
        }
    }
    
public:
    void draw() const override {
        Enemy::draw();
        
        // ëª©í‘œ ì§€ì ê¹Œì§€ ì„  ê·¸ë¦¬ê¸°
        Line{position, targetPosition}.draw(1.0, ColorF{0.8, 0.2, 0.2, 0.3});
    }
};

// ì›í˜• íŒ¨í„´ìœ¼ë¡œ ì´ë™í•˜ëŠ” ì 
class CircularEnemy : public Enemy 
{
private:
    Vec2 center;
    double radius;
    double angle;
    double angularSpeed;
    
public:
    CircularEnemy(const Vec2& centerPos, double orbitRadius, double startAngle = 0.0, double rotationSpeed = 0.02)
        : Enemy(centerPos + Vec2{Cos(startAngle), Sin(startAngle)} * orbitRadius, 80, 0, Texture{U"ğŸ‘»"_emoji}, 28),
          center(centerPos), radius(orbitRadius), angle(startAngle), angularSpeed(rotationSpeed) {}
    
protected:
    void move() override {
        angle += angularSpeed;
        position = center + Vec2{Cos(angle), Sin(angle)} * radius;
    }
    
public:
    void draw() const override {
        Enemy::draw();
        
        // ì›í˜• ê²½ë¡œ í‘œì‹œ
        Circle{center, radius}.drawFrame(1.0, ColorF{0.5, 0.5, 0.8, 0.3});
    }
};

// ëŒì§„í•˜ëŠ” ì 
class ChargingEnemy : public Enemy 
{
private:
    enum class State {
        Idle,
        Preparing,
        Charging,
        Cooldown
    };
    
    State state = State::Idle;
    Vec2 targetPosition;
    Vec2 chargeDirection;
    double idleTime = 0;
    double prepareTime = 0;
    double chargeTime = 0;
    double cooldownTime = 0;
    
    const double MAX_IDLE_TIME = 2.0;
    const double MAX_PREPARE_TIME = 1.0;
    const double MAX_CHARGE_TIME = 0.5;
    const double MAX_COOLDOWN_TIME = 1.5;
    const double CHARGE_SPEED_MULTIPLIER = 5.0;
    
public:
    ChargingEnemy(const Vec2& pos)
        : Enemy(pos, 120, 1.0, Texture{U"ğŸ¦‚"_emoji}, 32) {}
    
    void setTarget(const Vec2& target) {
        targetPosition = target;
    }
    
    void update() override {
        move();
    }
    
protected:
    void move() override {
        const double deltaTime = Scene::DeltaTime();
        
        switch (state) {
        case State::Idle:
            idleTime += deltaTime;
            if (idleTime >= MAX_IDLE_TIME) {
                state = State::Preparing;
                idleTime = 0;
                
                // ëª©í‘œ ë°©í–¥ ì„¤ì •
                chargeDirection = (targetPosition - position).normalized();
            }
            break;
            
        case State::Preparing:
            prepareTime += deltaTime;
            if (prepareTime >= MAX_PREPARE_TIME) {
                state = State::Charging;
                prepareTime = 0;
            }
            break;
            
        case State::Charging:
            chargeTime += deltaTime;
            position += chargeDirection * speed * CHARGE_SPEED_MULTIPLIER;
            
            if (chargeTime >= MAX_CHARGE_TIME) {
                state = State::Cooldown;
                chargeTime = 0;
            }
            
            // í™”ë©´ ê²½ê³„ ì²˜ë¦¬
            position.x = Clamp(position.x, radius, Scene::Width() - radius);
            position.y = Clamp(position.y, radius, Scene::Height() - radius);
            break;
            
        case State::Cooldown:
            cooldownTime += deltaTime;
            if (cooldownTime >= MAX_COOLDOWN_TIME) {
                state = State::Idle;
                cooldownTime = 0;
            }
            break;
        }
    }
    
    void draw() const override {
        ColorF overlayColor;
        
        switch (state) {
        case State::Idle:
            overlayColor = ColorF{1.0, 1.0, 1.0, 1.0};
            break;
        case State::Preparing:
            overlayColor = ColorF{1.0, 0.8, 0.3, 1.0};
            break;
        case State::Charging:
            overlayColor = ColorF{1.0, 0.2, 0.2, 1.0};
            break;
        case State::Cooldown:
            overlayColor = ColorF{0.5, 0.5, 0.8, 1.0};
            break;
        }
        
        // ìƒíƒœì— ë”°ë¼ ìƒ‰ìƒ ë³€í™”
        texture.resized(radius * 2).drawAt(position, overlayColor);
        
        // ì²´ë ¥ë°”
        const double barWidth = radius * 2;
        const double barHeight = 5.0;
        const Vec2 barPos = position.movedBy(0, -radius - 10);
        
        RectF{barPos.x - barWidth / 2, barPos.y, barWidth, barHeight}.draw(ColorF{0.3});
        RectF{barPos.x - barWidth / 2, barPos.y, barWidth * (health / 100.0), barHeight}.draw(ColorF{0.8, 0.2, 0.2});
        
        // ì¤€ë¹„/ì¿¨ë‹¤ìš´ ìƒíƒœ í‘œì‹œ
        if (state == State::Preparing) {
            Circle{position, radius * (1.0 + prepareTime / MAX_PREPARE_TIME)}
                .drawFrame(2, ColorF{1.0, 0.8, 0.3, 0.7 - 0.7 * (prepareTime / MAX_PREPARE_TIME)});
        }
        else if (state == State::Charging) {
            // ëŒì§„ ë°©í–¥ í‘œì‹œ
            Line{position, position + chargeDirection * 100}
                .draw(3, ColorF{1.0, 0.2, 0.2, 0.7});
        }
    }
};

void Main() 
{
    Scene::SetBackground(ColorF{0.2, 0.3, 0.4});
    
    FontAsset::Register(U"Regular", FontMethod::MSDF, 20, Typeface::CJK_Regular_KR);
    
    // í”Œë ˆì´ì–´ ìœ„ì¹˜
    Vec2 playerPos = Scene::Center();
    
    // ì  ìºë¦­í„° ìƒì„±
    Array<std::unique_ptr<Enemy>> enemies;
    
    // ì„ í˜• ì´ë™ ì 
    enemies << std::make_unique<LinearEnemy>(Vec2{100, 100}, Vec2{1, 0.5});
    enemies << std::make_unique<LinearEnemy>(Vec2{700, 100}, Vec2{-0.7, 0.7});
    
    // ì¶”ì  ì 
    enemies << std::make_unique<ChasingEnemy>(Vec2{100, 500});
    
    // ì›í˜• ì´ë™ ì 
    enemies << std::make_unique<CircularEnemy>(Vec2{400, 300}, 150, 0);
    enemies << std::make_unique<CircularEnemy>(Vec2{400, 300}, 150, Math::Pi, -0.02);
    
    // ëŒì§„ ì 
    enemies << std::make_unique<ChargingEnemy>(Vec2{600, 500});
    
    while (System::Update()) {
        // í”Œë ˆì´ì–´ ì´ë™ (ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¡œ)
        playerPos = Cursor::Pos();
        
        // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        Circle{playerPos, 25}.draw(ColorF{0.2, 0.6, 0.9});
        
        // ì  ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
        for (auto& enemy : enemies) {
            // íŠ¹ì • íƒ€ì…ì˜ ì ì— ëŒ€í•´ ì¶”ê°€ ì„¤ì •
            if (auto chasingEnemy = dynamic_cast<ChasingEnemy*>(enemy.get())) {
                chasingEnemy->setTarget(playerPos);
            }
            else if (auto chargingEnemy = dynamic_cast<ChargingEnemy*>(enemy.get())) {
                chargingEnemy->setTarget(playerPos);
            }
            
            enemy->update();
            enemy->draw();
            
            // ì¶©ëŒ ê²€ì‚¬ (í”Œë ˆì´ì–´ì™€ ì )
            if (Circle{playerPos, 25}.intersects(Circle{enemy->getPosition(), enemy->getCollisionRadius()})) {
                enemy->takeDamage(1.0); // ì¶©ëŒ ì‹œ ì ì—ê²Œ ë°ë¯¸ì§€
            }
        }
        
        // ì£½ì€ ì  ì œê±°
        enemies.remove_if([](const std::unique_ptr<Enemy>& enemy) {
            return enemy->isDead();
        });
        
        // ì•ˆë‚´ í…ìŠ¤íŠ¸
        FontAsset(U"Regular")(U"ë‹¤ì–‘í•œ ì  ìºë¦­í„° ì˜ˆì œ").draw(20, 20, ColorF{1.0});
        FontAsset(U"Regular")(U"ë§ˆìš°ìŠ¤ë¥¼ ì›€ì§ì—¬ í”Œë ˆì´ì–´ ì´ë™").draw(20, 50, ColorF{0.8});
        FontAsset(U"Regular")(U"ë‚¨ì€ ì : {}"_fmt(enemies.size())).draw(20, 80, ColorF{0.8});
    }
}
```  
  
ì‹¤í–‰ í™”ë©´:  
![](./images/017.png)     
    

ì´ ì½”ë“œì˜ í•µì‹¬ì€ **ê°ì²´ ì§€í–¥ í”„ë¡œê·¸ë˜ë°(OOP)**, ê·¸ì¤‘ì—ì„œë„ **ìƒì†**ê³¼ **ë‹¤í˜•ì„±**ì´ë¼ëŠ” ê°œë…ì„ í™œìš©í•˜ëŠ” ê²ƒì´ë‹¤. ë§ì´ ì¢€ ì–´ë µì£ ? "ë¶•ì–´ë¹µ í‹€"ì„ ìƒê°í•˜ë©´ ì‰¬ì›Œìš”.

  * **ê¸°ë³¸ ë¶•ì–´ë¹µ í‹€ (`Enemy` í´ë˜ìŠ¤)**: ëª¨ë“  ë¶•ì–´ë¹µì´ ê°€ì ¸ì•¼ í•  ê¸°ë³¸ ëª¨ì–‘, íŒ¥, í¬ê¸° ë“±ì„ ì •í•´ë†“ì€ ê¸°ë³¸ í‹€ì´ë‹¤.
  * **ë‹¤ì–‘í•œ ë¶•ì–´ë¹µ (`LinearEnemy`, `ChasingEnemy` ë“±)**: ê¸°ë³¸ ë¶•ì–´ë¹µ í‹€ì—ì„œ ëª¨ì–‘ì€ ê°€ì ¸ì˜¤ë˜, ì†ì¬ë£Œë¥¼ ìŠˆí¬ë¦¼ì´ë‚˜ í”¼ìë¡œ ë°”ê¾¼ íŠ¹ë³„í•œ ë¶•ì–´ë¹µë“¤ì´ë‹¤.

ì´ ì½”ë“œë„ ë˜‘ê°™ë‹¤. ëª¨ë“  ì ì˜ ê³µí†µ ê¸°ëŠ¥(ì²´ë ¥, ìœ„ì¹˜, ë°ë¯¸ì§€ ë°›ê¸° ë“±)ì€ `Enemy`ë¼ëŠ” ê¸°ë³¸ í‹€ì— ë§Œë“¤ì–´ë‘ê³ , ê° ì ì˜ ê°œì„± ìˆëŠ” ì›€ì§ì„ì€ ìì‹ í´ë˜ìŠ¤ì—ì„œ ë”°ë¡œ êµ¬í˜„í•˜ëŠ” ë°©ì‹ì´ë‹¤.

### ì½”ë“œ êµ¬ì¡° í•œëˆˆì— ë³´ê¸° (í´ë˜ìŠ¤ ìƒì† ê´€ê³„)
ë¨¼ì € ì „ì²´ì ì¸ êµ¬ì¡°ë¥¼ ë¨¸ë©”ì´ë“œ ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ ì‚´í´ë³´ì. `Enemy`ë¼ëŠ” ë¶€ëª¨ë¥¼ ë‚˜ë¨¸ì§€ ë„¤ ì¢…ë¥˜ì˜ ì ë“¤ì´ ìƒì†ë°›ëŠ” êµ¬ì¡°ì´ë‹¤.

```mermaid
classDiagram
    class Enemy {
        +virtual void update()
        +virtual void draw()
        +virtual void takeDamage(damage)
        +virtual void move() = 0
    }

    class LinearEnemy {
        +void move() override
    }

    class ChasingEnemy {
        +void move() override
    }

    class CircularEnemy {
        +void move() override
    }

    class ChargingEnemy {
        +void move() override
    }

    Enemy <|-- LinearEnemy : ìƒì†
    Enemy <|-- ChasingEnemy : ìƒì†
    Enemy <|-- CircularEnemy : ìƒì†
    Enemy <|-- ChargingEnemy : ìƒì†
```

### ğŸ“œ ì½”ë“œ ìƒì„¸ ì„¤ëª…

#### 1. `Enemy` í´ë˜ìŠ¤: ëª¨ë“  ì ì˜ "ë¶€ëª¨" ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦
ì´ í´ë˜ìŠ¤ëŠ” ëª¨ë“  ì  ìºë¦­í„°ê°€ ê³µí†µìœ¼ë¡œ ê°€ì§ˆ **ì†ì„±(ë³€ìˆ˜)**ê³¼ **í–‰ë™(í•¨ìˆ˜)**ì„ ì •ì˜í•œ ê¸°ë³¸ ì„¤ê³„ë„ì´ë‹¤.

  * **ì£¼ìš” ì†ì„± (protected):**

      * `Vec2 position`: ì ì˜ í˜„ì¬ ìœ„ì¹˜ (x, y ì¢Œí‘œ)
      * `double health`: ì²´ë ¥
      * `double speed`: ì´ë™ ì†ë„
      * `Texture texture`: ì ì˜ ì´ë¯¸ì§€ (ì´ëª¨ì§€ í…ìŠ¤ì²˜)
      * `double radius`: ì¶©ëŒ íŒì •ì„ ìœ„í•œ ë°˜ì§€ë¦„ í¬ê¸°

  * **ì£¼ìš” í–‰ë™ (public):**

      * `update()`: ë§¤ í”„ë ˆì„ë§ˆë‹¤ í˜¸ì¶œë˜ì–´ ì ì˜ ìƒíƒœë¥¼ ê°±ì‹ í•œë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ `move()` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤.
      * `draw()`: ì ì˜ ì´ë¯¸ì§€ì™€ ì²´ë ¥ ë°”ë¥¼ í™”ë©´ì— ê·¸ë¦°ë‹¤.
      * `takeDamage(damage)`: í”¼í•´ë¥¼ ì…ì—ˆì„ ë•Œ ì²´ë ¥ì„ ê¹ëŠ”ë‹¤.
      * `isDead()`: ì²´ë ¥ì´ 0 ì´í•˜ì¸ì§€ í™•ì¸í•˜ì—¬ ì£½ì—ˆëŠ”ì§€ ì•Œë ¤ì¤€ë‹¤.
      * `virtual void move() = 0;`: **ê°€ì¥ ì¤‘ìš”í•œ ë¶€ë¶„ì´ë‹¤!**
          * `virtual`: "ì´ í•¨ìˆ˜ëŠ” ìì‹ í´ë˜ìŠ¤ê°€ ë§ˆìŒëŒ€ë¡œ ê³ ì³ ì“¸ ìˆ˜ ìˆì–´!" ë¼ëŠ” ëœ»ì´ë‹¤. (â†’ **ë‹¤í˜•ì„±**)
          * `= 0`: "ë‚˜ëŠ” `move`ë¥¼ ì–´ë–»ê²Œ í•´ì•¼ í• ì§€ ëª°ë¼. ìì‹ë“¤ì´ ê°ì ì•Œì•„ì„œ ìê¸°ë§Œì˜ `move` ë°©ì‹ì„ ë°˜ë“œì‹œ ë§Œë“¤ì–´ì•¼ í•´!" ë¼ëŠ” ê°•ì œì ì¸ ê·œì¹™ì´ë‹¤. (â†’ **ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜**)

ì´ `move()` í•¨ìˆ˜ ë•Œë¬¸ì— `Enemy` í´ë˜ìŠ¤ëŠ” ëª¨ë“  ì ì˜ ì›€ì§ì„ ë°©ì‹ì„ í•˜ë‚˜ë¡œ í†µì¼í•˜ë©´ì„œë„, ì‹¤ì œ ì›€ì§ì„ì€ ê°ì ë‹¤ë¥´ê²Œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ìœ ì—°í•œ êµ¬ì¡°ë¥¼ ê°€ì§€ê²Œ ëœë‹¤.


#### 2. `LinearEnemy`, `ChasingEnemy` ë“±: ê°œì„± ë„˜ì¹˜ëŠ” "ìì‹ë“¤"
ì´ í´ë˜ìŠ¤ë“¤ì€ `Enemy` í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ì•„ ë§Œë“¤ì–´ì¡Œë‹¤. `public Enemy` ë¶€ë¶„ì´ "ë‚˜ëŠ” Enemyì˜ ìì‹ì´ë‹¤!"ë¼ê³  ì„ ì–¸í•˜ëŠ” ë¶€ë¶„ì´ë‹¤.   ë•ë¶„ì— ì´ë“¤ì€ `Enemy`ì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ë¬¼ë ¤ë°›ê³ , ìì‹ ë§Œì˜ íŠ¹ë³„í•œ ê¸°ëŠ¥, ì¦‰ `move()`ë¥¼ êµ¬í˜„í•œë‹¤.

  * **`LinearEnemy` ğŸ‘¾ (ì§ì„  ì´ë™ ì )**

      * ì •í•´ì§„ ë°©í–¥ìœ¼ë¡œ ê³„ì† ì§ì§„í•˜ë‹¤ê°€ í™”ë©´ ëì— ë‹¿ìœ¼ë©´ íŠ•ê²¨ì„œ ë°©í–¥ì„ ë°”ê¾¼ë‹¤.
      * `move()` í•¨ìˆ˜ ì•ˆì— ì´ ë¡œì§ì´ êµ¬í˜„ë˜ì–´ ìˆë‹¤.

  * **`ChasingEnemy` ğŸ‘¹ (ì¶”ì í•˜ëŠ” ì )**

      * `targetPosition` (ì£¼ë¡œ í”Œë ˆì´ì–´ ìœ„ì¹˜)ì„ í–¥í•´ ê³„ì† ë”°ë¼ì˜¨ë‹¤.
      * `move()` í•¨ìˆ˜ì—ì„œ ëª©í‘œ ì§€ì ê³¼ ìì‹ ì˜ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•´ ê·¸ ë°©í–¥ìœ¼ë¡œ ì›€ì§ì¸ë‹¤.

  * **`CircularEnemy` ğŸ‘» (ì›í˜• ì´ë™ ì )**

      * ì •í•´ì§„ ì¤‘ì‹¬ì (`center`)ì„ ê¸°ì¤€ìœ¼ë¡œ ë¹™ê¸€ë¹™ê¸€ ì›ì„ ê·¸ë¦¬ë©° ëˆë‹¤.
      * `move()` í•¨ìˆ˜ì—ì„œ ê°ë„ë¥¼ ê³„ì† ë°”ê¾¸ë©° ì› ìœ„ì˜ ì¢Œí‘œë¥¼ ê³„ì‚°í•´ ì´ë™í•œë‹¤.

  * **`ChargingEnemy` ğŸ¦‚ (ëŒì§„í•˜ëŠ” ì )**

      * ê°€ì¥ ë³µì¡í•œ ì ìœ¼ë¡œ, **ìƒíƒœ(State)** ê°œë…ì„ ê°€ì§„ë‹¤.
      * `Idle(ëŒ€ê¸°)` â†’ `Preparing(ì¤€ë¹„)` â†’ `Charging(ëŒì§„)` â†’ `Cooldown(íœ´ì‹)` ìˆœì„œë¡œ ìƒíƒœê°€ ë³€í•œë‹¤.
      * `move()` í•¨ìˆ˜ ì•ˆì—ì„œ í˜„ì¬ ìì‹ ì˜ `state`ê°€ ë¬´ì—‡ì¸ì§€ì— ë”°ë¼ ì™„ì „íˆ ë‹¤ë¥¸ í–‰ë™ì„ í•©ë‹ˆë‹¤. ë§ˆì¹˜ ì‹ í˜¸ë“±ì²˜ëŸ¼ ìƒíƒœì— ë”°ë¼ í–‰ë™ì´ ë°”ë€ŒëŠ” ê²ƒì´ë‹¤.  
  
ì—¬ê¸°ì„œ `override` í‚¤ì›Œë“œëŠ” "ë¶€ëª¨ë‹˜ì˜ `move` í•¨ìˆ˜ë¥¼ ì œê°€ ìƒˆë¡œ ë§Œë“¤ì–´ì„œ ë®ì–´ì“°ê² ë‹¤!"ë¼ëŠ” ëœ»ìœ¼ë¡œ, ì‹¤ìˆ˜ë¥¼ ë°©ì§€í•´ì£¼ëŠ” ìœ ìš©í•œ í‚¤ì›Œë“œì´ë‹¤.  

#### 3. `Main()` í•¨ìˆ˜: ê²Œì„ì˜ ì‹¤ì œ ë¬´ëŒ€ ğŸ¬
ì´ê³³ì€ ìœ„ì—ì„œ ë§Œë“  ì  í´ë˜ìŠ¤ë“¤ì„ ì‹¤ì œë¡œ ìƒì„±í•˜ê³  ê²Œì„ì„ ì§„í–‰í•˜ëŠ” ê³µê°„ì´ë‹¤.  
  
1.  **ì  ìƒì„±:**

    ```cpp
    Array<std::unique_ptr<Enemy>> enemies;
    enemies << std::make_unique<LinearEnemy>(...);
    enemies << std::make_unique<ChasingEnemy>(...);
    ```

    `enemies`ë¼ëŠ” í° ë°”êµ¬ë‹ˆì— ì—¬ëŸ¬ ì¢…ë¥˜ì˜ ì ë“¤ì„ ë‹´ëŠ”ë‹¤. ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ì ì€ ë°”êµ¬ë‹ˆì˜ íƒ€ì…ì´ `Enemy`ë¼ëŠ” ê²ƒì´ë‹¤. `LinearEnemy`, `ChasingEnemy` ë“± ì¢…ë¥˜ëŠ” ë‹¤ë¥´ì§€ë§Œ ëª¨ë‘ `Enemy`ì˜ ìì‹ë“¤ì´ê¸° ë•Œë¬¸ì— í•˜ë‚˜ì˜ `Enemy` ë°”êµ¬ë‹ˆì— ë‹´ì„ ìˆ˜ ìˆë‹¤. (â†’ **ë‹¤í˜•ì„±ì˜ ì¥ì **)
    (`std::unique_ptr`ëŠ” ë©”ëª¨ë¦¬ë¥¼ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•˜ê¸° ìœ„í•œ C++ì˜ ë„êµ¬ë¼ê³  ìƒê°í•˜ì‹œë©´ ëœë‹¤.)

2.  **ë©”ì¸ ë£¨í”„ (`while (System::Update())`):**
    ì´ ë¶€ë¶„ì€ ê²Œì„ì´ êº¼ì§€ì§€ ì•ŠëŠ” í•œ ê³„ì†í•´ì„œ ë°˜ë³µëœë‹¤. ë§ˆì¹˜ ì˜í™” í•„ë¦„ì´ 1ì´ˆì— ìˆ˜ì‹­ ì¥ì”© ì§€ë‚˜ê°€ëŠ” ê²ƒê³¼ ê°™ë‹¤.

      * **í”Œë ˆì´ì–´ ì´ë™:** ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ë”°ë¼ í”Œë ˆì´ì–´ê°€ ì›€ì§ì¸ë‹¤.

      * **ì  ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°:**

        ```cpp
        for (auto& enemy : enemies) {
            // ...
            enemy->update();
            enemy->draw();
        }
        ```

        ì´ ë¶€ë¶„ì´ ë°”ë¡œ **ë‹¤í˜•ì„±**ì˜ ë§ˆë²•ì´ ì¼ì–´ë‚˜ëŠ” ê³³ì´ë‹¤! ë°”êµ¬ë‹ˆ ì•ˆì— ìˆëŠ” ì ì´ `LinearEnemy`ì¸ì§€ `ChasingEnemy`ì¸ì§€ ì‹ ê²½ ì“°ì§€ ì•Šê³  ê·¸ëƒ¥ "ì›€ì§ì—¬\!(`update`)"ë¼ê³  ëª…ë ¹ë§Œ ë‚´ë¦¬ë©´, ê° ì ë“¤ì€ **ìì‹ ì—ê²Œ ë§ëŠ” `move` ë°©ì‹**ì„ ì•Œì•„ì„œ ìˆ˜í–‰í•œë‹¤. ì½”ë“œê°€ ì•„ì£¼ ê°„ê²°í•´ì§„ë‹¤.

      * **íŠ¹ì • ì ì—ê²Œ ì •ë³´ ì „ë‹¬:**

        ```cpp
        if (auto chasingEnemy = dynamic_cast<ChasingEnemy*>(enemy.get())) {
            chasingEnemy->setTarget(playerPos);
        }
        ```

        `dynamic_cast`ëŠ” "ë°”êµ¬ë‹ˆ ì†ì˜ ì´ `Enemy`ê°€ í˜¹ì‹œ `ChasingEnemy` íƒ€ì…ì´ë‹ˆ?"ë¼ê³  í™•ì¸í•˜ëŠ” ê³¼ì •ì´ë‹¤. ë§Œì•½ ë§ë‹¤ë©´, `setTarget` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ë¥¼ ì•Œë ¤ì¤€ë‹¤. ëŒì§„í•˜ëŠ” ì ë„ ë§ˆì°¬ê°€ì§€ì´ë‹¤.

      * **ì¶©ëŒ ì²˜ë¦¬ ë° ì œê±°:** í”Œë ˆì´ì–´ì™€ ì ì´ ë¶€ë”ªíˆë©´ ì ì˜ ì²´ë ¥ì„ ê¹ê³ , ì²´ë ¥ì´ 0ì´ ëœ ì ì€ `enemies` ë°”êµ¬ë‹ˆì—ì„œ ì œê±°í•œë‹¤.

### âœ¨ ìµœì¢… ìš”ì•½
ì´ ì½”ë“œëŠ” **ìƒì†**ì„ ì´ìš©í•´ 'ì 'ì´ë¼ëŠ” ê³µí†µëœ ê°œë…ì„ `Enemy` í´ë˜ìŠ¤ë¡œ ë¬¶ê³ , **ë‹¤í˜•ì„±**ì„ ì´ìš©í•´ ê°ê¸° ë‹¤ë¥¸ ì›€ì§ì„ì„ ê°€ì§„ ì ë“¤ì„ `move()`ë¼ëŠ” í•˜ë‚˜ì˜ í•¨ìˆ˜ ì´ë¦„ìœ¼ë¡œ í†µì¼í•˜ì—¬ ë§¤ìš° íš¨ìœ¨ì ì´ê³  ê¹”ë”í•˜ê²Œ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤€ë‹¤.

ì´ëŸ° êµ¬ì¡° ë•ë¶„ì— ë‚˜ì¤‘ì— "ìˆœê°„ì´ë™í•˜ëŠ” ì "ì´ë‚˜ "ë¶„ì—´í•˜ëŠ” ì " ê°™ì€ ìƒˆë¡œìš´ ì¢…ë¥˜ì˜ ì ì„ ì¶”ê°€í•˜ê³  ì‹¶ì„ ë•Œ, `Enemy`ë¥¼ ìƒì†ë°›ì•„ ìƒˆë¡œìš´ `move()` í•¨ìˆ˜ë§Œ ë§Œë“¤ì–´ì£¼ë©´ ë˜ë¯€ë¡œ **ì½”ë“œë¥¼ í™•ì¥í•˜ê¸°ê°€ ë§¤ìš° ì‰¬ì›Œì§„ë‹¤.**    
  

## 6.5 Siv3D í™œìš© ì˜ˆì œ: ë‹¤í˜•ì„±ì„ í™œìš©í•œ ê²Œì„ ì—”í‹°í‹° ì‹œìŠ¤í…œ
ì´ì œ ì¢€ ë” ì¼ë°˜ì ì¸ ê²Œì„ ì—”í‹°í‹° ì‹œìŠ¤í…œì„ êµ¬í˜„í•´ ë³´ê² ë‹¤. ì´ ì‹œìŠ¤í…œì€ ê²Œì„ ë‚´ ëª¨ë“  ê°œì²´ì˜ ê¸°ë³¸ì´ ëœë‹¤.

```cpp
#include <Siv3D.hpp>

// [í•µì‹¬] ëª¨ë“  ê²Œì„ ê°ì²´ê°€ ë”°ë¼ì•¼ í•  ê·œì¹™(ì¸í„°í˜ì´ìŠ¤)ì„ ì •ì˜í•©ë‹ˆë‹¤.
// ìˆœìˆ˜ ê°€ìƒ í•¨ìˆ˜ë“¤ì€ "ì´ í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ëŠ” ë…€ì„ì€ ì´ í•¨ìˆ˜ë“¤ì„ ë°˜ë“œì‹œ ë§Œë“¤ì–´ì•¼ í•œë‹¤"ëŠ” ëœ»ì…ë‹ˆë‹¤.
struct IGameObject
{
	virtual ~IGameObject() = default;

	// ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸ ë¡œì§
	virtual void update() = 0;

	// í™”ë©´ì— ê·¸ë¦¬ëŠ” ë¡œì§
	virtual void draw() const = 0;

	// ì´ ê°ì²´ê°€ ì—¬ì „íˆ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸
	virtual bool isAlive() const = 0;

	// ì¶©ëŒ íŒì •ì„ ìœ„í•œ ì›í˜• ì½œë¼ì´ë” ë°˜í™˜
	virtual Circle getCollider() const = 0;

	// ë‹¤ë¥¸ ê°ì²´ì™€ ì¶©ëŒí–ˆì„ ë•Œì˜ ì²˜ë¦¬
	virtual void onCollision(IGameObject& other) = 0;

	// ì¶©ëŒ ì²˜ë¦¬ ì‹œ êµ¬ë¶„ì„ ìœ„í•œ íƒœê·¸
	virtual StringView getTypeTag() const = 0;
};

// ----------------------------------------------------------------
// í”Œë ˆì´ì–´ êµ¬í˜„
// ----------------------------------------------------------------
class Player : public IGameObject
{
private:
	Vec2 m_pos;
	int m_health = 3;
	Circle m_collider{ 0, 0, 30 };
	const Texture m_texture{ U"ğŸš€"_emoji };

public:
	Player(const Vec2& pos) : m_pos{ pos } {}

	void update() override
	{
		// í‚¤ë³´ë“œ ì…ë ¥ì— ë”°ë¥¸ ì´ë™
		const Vec2 velocity = Vec2{ KeyD.pressed() - KeyA.pressed(), KeyS.pressed() - KeyW.pressed() }
		.setLength(5.0);
		m_pos += velocity;

		// í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ ìœ„ì¹˜ ë³´ì •
		m_pos.x = Clamp(m_pos.x, m_collider.r, Scene::Width() - m_collider.r);
		m_pos.y = Clamp(m_pos.y, m_collider.r, Scene::Height() - m_collider.r);

		m_collider.setPos(m_pos);
	}

	void draw() const override
	{
		m_collider.draw(ColorF{ 0.3, 0.4, 0.8, 0.3 });
		m_texture.resized(m_collider.r * 2).drawAt(m_pos);

		// ë‚¨ì€ ì²´ë ¥ì„ í™”ë©´ ìƒë‹¨ì— í‘œì‹œ
		for (int i = 0; i < m_health; ++i)
		{
			Circle{ 30 + i * 25.0, 30, 10 }.draw(Palette::Red);
		}
	}

	bool isAlive() const override { return (m_health > 0); }
	Circle getCollider() const override { return m_collider; }
	StringView getTypeTag() const override { return U"Player"; }

	Vec2 getPos() const { return m_pos; }

	void onCollision(IGameObject& other) override
	{
		// ì ê³¼ ë¶€ë”ªí˜”ë‹¤ë©´ ì²´ë ¥ ê°ì†Œ
		if (other.getTypeTag() == U"Enemy")
		{
			m_health = Max(0, m_health - 1);
		}
	}
};

// ----------------------------------------------------------------
// ì  êµ¬í˜„
// ----------------------------------------------------------------
class Enemy : public IGameObject
{
private:
	Vec2 m_pos;
	Vec2 m_velocity;
	int m_health = 100;
	Circle m_collider;
	Texture m_texture;

public:
	Enemy(const Vec2& pos, const Texture& texture, double radius, double speed)
		: m_pos{ pos }
		, m_velocity{ RandomVec2() * speed }
		, m_collider{ pos, radius }
		, m_texture{ texture } {
	}

	void update() override
	{
		m_pos += m_velocity;

		// í™”ë©´ ê²½ê³„ì— ë‹¿ìœ¼ë©´ íŠ•ê¸°ê¸°
		if ((m_pos.x < m_collider.r && m_velocity.x < 0) || (m_pos.x > Scene::Width() - m_collider.r && m_velocity.x > 0))
		{
			m_velocity.x *= -1;
		}
		if ((m_pos.y < m_collider.r && m_velocity.y < 0) || (m_pos.y > Scene::Height() - m_collider.r && m_velocity.y > 0))
		{
			m_velocity.y *= -1;
		}

		m_collider.setPos(m_pos);
	}

	void draw() const override
	{
		m_collider.draw(ColorF{ 0.8, 0.2, 0.2, 0.3 });
		m_texture.resized(m_collider.r * 2).drawAt(m_pos);
	}

	bool isAlive() const override { return (m_health > 0); }
	Circle getCollider() const override { return m_collider; }
	StringView getTypeTag() const override { return U"Enemy"; }

	void onCollision(IGameObject& other) override
	{
		// ì´ì•Œê³¼ ë¶€ë”ªí˜”ë‹¤ë©´ ì²´ë ¥ ê°ì†Œ
		if (other.getTypeTag() == U"Bullet")
		{
			m_health -= 50;
		}
		// í”Œë ˆì´ì–´ì™€ ë¶€ë”ªí˜”ë‹¤ë©´ ì¦‰ì‹œ ì‚¬ë¼ì§
		else if (other.getTypeTag() == U"Player")
		{
			m_health = 0;
		}
	}
};

// ----------------------------------------------------------------
// ì´ì•Œ êµ¬í˜„
// ----------------------------------------------------------------
class Bullet : public IGameObject
{
private:
	Vec2 m_pos;
	Vec2 m_velocity;
	Circle m_collider;
	Timer m_lifeTimer; // ìˆ˜ëª… íƒ€ì´ë¨¸

public:
	Bullet(const Vec2& startPos, const Vec2& targetPos)
		: m_pos{ startPos }
		, m_velocity{ (targetPos - startPos).setLength(12.0) }
		, m_collider{ startPos, 8 }
		, m_lifeTimer{ 2s, StartImmediately::Yes } {
	}

	void update() override
	{
		m_pos += m_velocity;
		m_collider.setPos(m_pos);
	}

	void draw() const override
	{
		m_collider.draw(Palette::Yellow);
	}

	// ìˆ˜ëª…ì´ ë‹¤í–ˆê±°ë‚˜ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ false
	bool isAlive() const override { return !m_lifeTimer.reachedZero() && Scene::Rect().intersects(m_collider); }
	Circle getCollider() const override { return m_collider; }
	StringView getTypeTag() const override { return U"Bullet"; }

	void onCollision(IGameObject& other) override
	{
		// ì ê³¼ ë¶€ë”ªí˜”ë‹¤ë©´ ì´ì•Œì€ ì‚¬ë¼ì§
		if (other.getTypeTag() == U"Enemy")
		{
			m_lifeTimer.reset(); // íƒ€ì´ë¨¸ë¥¼ 0ìœ¼ë¡œ ë§Œë“¤ì–´ ì¦‰ì‹œ ì†Œë©¸
		}
	}
};


// ----------------------------------------------------------------
// ë©”ì¸ í•¨ìˆ˜
// ----------------------------------------------------------------
void Main()
{
	Scene::SetBackground(ColorF{ 0.1, 0.1, 0.2 });

	// [í•µì‹¬] ëª¨ë“  ê²Œì„ ê°ì²´ë¥¼ IGameObject íƒ€ì…ì˜ í¬ì¸í„°ë¡œ ì¼ê´„ ê´€ë¦¬í•©ë‹ˆë‹¤.
	Array<std::unique_ptr<IGameObject>> gameObjects;

	// í”Œë ˆì´ì–´ ìƒì„± ë° ë°°ì—´ì— ì¶”ê°€
	auto player = std::make_shared<Player>(Scene::Center());
	gameObjects << std::make_unique<Player>(Scene::Center());

	Timer enemySpawnTimer{ 2s, StartImmediately::Yes };
	const Array<Texture> enemyTextures = { Texture{U"ğŸ‘¾"_emoji}, Texture{U"ğŸ‘¹"_emoji}, Texture{U"ğŸ‘»"_emoji} };

	while (System::Update())
	{
		// ---------------------------------
		// 1. ìƒì„± ë¡œì§
		// ---------------------------------

		// 2ì´ˆë§ˆë‹¤ ì  ìƒì„±
		if (enemySpawnTimer.reachedZero())
		{
			gameObjects << std::make_unique<Enemy>(
				RandomVec2(Scene::Rect().stretched(-50)), // í™”ë©´ ê°€ì¥ìë¦¬ë¥¼ ì œì™¸í•œ ëœë¤ ìœ„ì¹˜
				Sample(enemyTextures),                    // ëœë¤ í…ìŠ¤ì²˜
				Random(20.0, 40.0),                       // ëœë¤ í¬ê¸°
				Random(1.0, 3.0)                          // ëœë¤ ì†ë„
			);
			enemySpawnTimer.restart();
		}

		// ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­ ì‹œ ì´ì•Œ ìƒì„±
		if (MouseL.down())
		{
			// Player ê°ì²´ë¥¼ ì°¾ì•„ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜´ (ì—†ì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ í™•ì¸)
			for (const auto& obj : gameObjects)
			{
				if (obj->getTypeTag() == U"Player")
				{
					// dynamic_castë¥¼ í†µí•´ Playerì˜ ê³ ìœ  í•¨ìˆ˜(getPos)ì— ì ‘ê·¼
					if (auto p = dynamic_cast<Player*>(obj.get()))
					{
						gameObjects << std::make_unique<Bullet>(p->getPos(), Cursor::Pos());
					}
					break;
				}
			}
		}

		// ---------------------------------
		// 2. ì—…ë°ì´íŠ¸ ë¡œì§ (ë‹¤í˜•ì„± í™œìš©)
		// ---------------------------------
		for (const auto& obj : gameObjects)
		{
			obj->update();
		}

		// ---------------------------------
		// 3. ì¶©ëŒ ì²˜ë¦¬ ë¡œì§ (ë‹¤í˜•ì„± í™œìš©)
		// ---------------------------------
		for (size_t i = 0; i < gameObjects.size(); ++i)
		{
			for (size_t k = i + 1; k < gameObjects.size(); ++k)
			{
				const auto& objA = gameObjects[i];
				const auto& objB = gameObjects[k];

				// ë‘ ê°ì²´ì˜ ì½œë¼ì´ë”ê°€ ê²¹ì³¤ë‹¤ë©´
				if (objA->getCollider().intersects(objB->getCollider()))
				{
					// ê°ìì—ê²Œ "ë„ˆ, ì–˜ë‘ ë¶€ë”ªí˜”ì–´!" ë¼ê³  ì•Œë ¤ì£¼ê¸°ë§Œ í•˜ë©´ ë.
					// ì–´ë–»ê²Œ í–‰ë™í• ì§€ëŠ” ê°ì²´ ìŠ¤ìŠ¤ë¡œ ê²°ì •í•©ë‹ˆë‹¤.
					objA->onCollision(*objB);
					objB->onCollision(*objA);
				}
			}
		}

		// ---------------------------------
		// 4. ê·¸ë¦¬ê¸° ë¡œì§ (ë‹¤í˜•ì„± í™œìš©)
		// ---------------------------------
		for (const auto& obj : gameObjects)
		{
			obj->draw();
		}

		// ---------------------------------
		// 5. ì†Œë©¸ ë¡œì§
		// ---------------------------------
		// isAlive()ê°€ falseë¥¼ ë°˜í™˜í•˜ëŠ” ëª¨ë“  ê°ì²´ë¥¼ ë°°ì—´ì—ì„œ ì œê±°
		gameObjects.remove_if([](const auto& obj) {
			return not obj->isAlive();
		});
	}
}
```  
  
ì‹¤í–‰ í™”ë©´:   
![](./images/0.png)   

### ì½”ë“œ ì„¤ëª…: ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ ê²Œì„ ê°ì²´ ê´€ë¦¬
ì´ ì½”ë“œëŠ” ìµœì‹  OpenSiv3Dë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ì¢…ë¥˜ì˜ ê²Œì„ ìºë¦­í„°(ê°ì²´)ë¥¼ **'ì¸í„°í˜ì´ìŠ¤'**ë¼ëŠ” ë§¤ìš° ì„¸ë ¨ë˜ê³  íš¨ìœ¨ì ì¸ ë°©ì‹ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ì˜ˆì œì´ë‹¤.

ì´ˆë³´ìì˜ ëˆˆë†’ì´ì— ë§ì¶° ì´ ì½”ë“œì˜ **êµ¬ì¡°**, **íë¦„**, ê·¸ë¦¬ê³  **ë™ì‘** ë°©ì‹ì— ëŒ€í•´ ìì„¸íˆ ì„¤ëª…í•˜ê² ë‹¤.

#### 1. êµ¬ì¡° (Structure)
ì´ ì½”ë“œì˜ êµ¬ì¡°ëŠ” ë§ˆì¹˜ **"ì—­í• ì„ ë¶€ì—¬í•˜ëŠ” ê³„ì•½"**ê³¼ ê°™ë‹¤. ëª¨ë“  ê²Œì„ ê°ì²´ëŠ” ë°˜ë“œì‹œ ì§€ì¼œì•¼ í•  ê³µí†µëœ ê·œì¹™ì„ ì•½ì†í•˜ê³ , ê°ì ê°œì„± ìˆëŠ” ë°©ì‹ìœ¼ë¡œ ê·¸ ê·œì¹™ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ë‹¤.

##### â– IGameObject: ëª¨ë“  ê°ì²´ì˜ ì„¤ê³„ë„ (ì¸í„°í˜ì´ìŠ¤)
ì½”ë“œ ìµœìƒë‹¨ì˜ `struct IGameObject`ëŠ” ëª¨ë“  ê²Œì„ ê°ì²´ê°€ ê°€ì ¸ì•¼ í•  **í•„ìˆ˜ ê¸°ëŠ¥ ëª©ë¡ì„ ì •ì˜í•œ ì„¤ê³„ë„**ì´ë‹¤. ë ˆê³  ë¸”ë¡ì˜ ìœ„ì•„ë˜ ëŒê¸°ë¥¼ ìƒê°í•˜ë©´ ì‰½ë‹¤. ì–´ë–¤ ëª¨ì–‘ì˜ ë ˆê³  ë¸”ë¡ì´ë“  ë‹¤ë¥¸ ë¸”ë¡ê³¼ ì—°ê²°ë˜ë ¤ë©´ ì´ ëŒê¸°ê°€ ë°˜ë“œì‹œ ìˆì–´ì•¼ í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤.

```cpp
struct IGameObject
{
    virtual void update() = 0; // "ë„ˆëŠ” ë§¤ ìˆœê°„ ìŠ¤ìŠ¤ë¡œ ìƒíƒœë¥¼ ê°±ì‹ í•  ì¤„ ì•Œì•„ì•¼ í•œë‹¤!"
    virtual void draw() const = 0; // "ë„ˆëŠ” ìŠ¤ìŠ¤ë¡œ í™”ë©´ì— ê·¸ë ¤ì§ˆ ì¤„ ì•Œì•„ì•¼ í•œë‹¤!"
    virtual bool isAlive() const = 0; // "ë„ˆëŠ” ì‚´ì•„ìˆëŠ”ì§€ ì£½ì—ˆëŠ”ì§€ ë§í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤!"
    virtual Circle getCollider() const = 0; // "ë„ˆì˜ ì¶©ëŒ ë²”ìœ„ë¥¼ ì•Œë ¤ì¤˜ì•¼ í•œë‹¤!"
    virtual void onCollision(IGameObject& other) = 0; // "ëˆ„êµ°ê°€ì™€ ë¶€ë”ªí˜”ì„ ë•Œ ì–´ë–»ê²Œ í–‰ë™í• ì§€ ì•Œì•„ì•¼ í•œë‹¤!"
    virtual StringView getTypeTag() const = 0; // "ë„ˆì˜ ì¢…ë¥˜ê°€ ë¬´ì—‡ì¸ì§€(í”Œë ˆì´ì–´, ì ) ì•Œë ¤ì¤˜ì•¼ í•œë‹¤!"
};
```

ì—¬ê¸°ì„œ `= 0`ì€ "ì´ ê¸°ëŠ¥ì˜ êµ¬ì²´ì ì¸ ë‚´ìš©ì€ ìì‹ í´ë˜ìŠ¤ê°€ ë°˜ë“œì‹œ ì§ì ‘ ë§Œë“¤ì–´ì•¼ í•œë‹¤"ëŠ” ê°•ë ¥í•œ ê·œì¹™ì´ë‹¤.

##### â– Player, Enemy, Bullet: ì„¤ê³„ë„ë¥¼ êµ¬í˜„í•œ ì‹¤ì œ ê°ì²´ë“¤
`Player`, `Enemy`, `Bullet` í´ë˜ìŠ¤ëŠ” `public IGameObject` ë¼ëŠ” ì„ ì–¸ì„ í†µí•´ **"IGameObjectì˜ ëª¨ë“  ê·œì¹™ì„ ì¶©ì‹¤íˆ ë”°ë¥´ê² ìŠµë‹ˆë‹¤"** ë¼ê³  ê³„ì•½í•œ ì‹¤ì œ ê°ì²´ë“¤ì´ë‹¤.

ì´ ê´€ê³„ë¥¼ ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ í‘œí˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```mermaid
classDiagram
    direction LR
    class IGameObject {
        <<Interface>>
        +update()
        +draw()
        +isAlive()
        +onCollision()
    }
    class Player {
        +update()
        +draw()
        +isAlive()
        +onCollision()
    }
    class Enemy {
        +update()
        +draw()
        +isAlive()
        +onCollision()
    }
    class Bullet {
        +update()
        +draw()
        +isAlive()
        +onCollision()
    }

    IGameObject <|.. Player : implements
    IGameObject <|.. Enemy : implements
    IGameObject <|.. Bullet : implements
```

ì´ êµ¬ì¡°ì˜ í•µì‹¬ì€ `Player`, `Enemy`, `Bullet`ê°€ ì„œë¡œ ì „í˜€ ë‹¤ë¥¸ ëª¨ìŠµì„ í•˜ê³  ìˆì§€ë§Œ, '`IGameObject` ê³„ì•½ì„ ì§€ì¼°ë‹¤'ëŠ” ê³µí†µì  í•˜ë‚˜ë§Œìœ¼ë¡œ **í•˜ë‚˜ì˜ ê·¸ë£¹ìœ¼ë¡œ ë¬¶ì–´ì„œ ê´€ë¦¬**í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì´ë‹¤.


#### 2. íë¦„ (Flow)
ê²Œì„ì˜ ì§„í–‰ íë¦„ì€ `Main` í•¨ìˆ˜ ì•ˆì˜ `while (System::Update())` ë£¨í”„ê°€ ì „ë¶€ì´ë‹¤. ì´ ë£¨í”„ëŠ” 1ì´ˆì— ìˆ˜ì‹­ ë²ˆì”© ë¹™ê¸€ë¹™ê¸€ ëŒë©´ì„œ ê²Œì„ ì„¸ìƒì„ ê³„ì†í•´ì„œ ì›€ì§ì´ê²Œ ë§Œë“œëŠ” ì‹¬ì¥ê³¼ ê°™ë‹¤.

##### â– ë§ˆë²•ì˜ ìƒì: `Array<std::unique_ptr<IGameObject>> gameObjects`
ì´ ì½”ë“œëŠ” `gameObjects`ë¼ëŠ” ë‹¨ í•˜ë‚˜ì˜ ë°°ì—´, ì¦‰ \*\*'ë§ˆë²•ì˜ ìƒì'\*\*ì— ëª¨ë“  ê°ì²´ë¥¼ ë‹´ì•„ ê´€ë¦¬í•œë‹¤. ì´ ìƒìëŠ” ë‚´ìš©ë¬¼ì´ í”Œë ˆì´ì–´ì¸ì§€, ì ì¸ì§€, ì´ì•Œì¸ì§€ ì „í˜€ ì‹ ê²½ ì“°ì§€ ì•ŠëŠ”ë‹¤. ê·¸ì € '`IGameObject` ê³„ì•½ì„ ì§€í‚¨ ê°ì²´'ë¼ëŠ” ì‚¬ì‹¤ë§Œ ë³´ê³  ëª¨ë‘ ë‹´ì•„ì£¼ëŠ” ê²ƒì´ë‹¤.

**ì´ê²ƒì´ ë°”ë¡œ ë‹¤í˜•ì„±ì˜ í•µì‹¬ì´ë‹¤.**

##### â– ê²Œì„ ë£¨í”„ì˜ 5ë‹¨ê³„

ê²Œì„ ë£¨í”„ëŠ” í¬ê²Œ 5ê°€ì§€ ë‹¨ê³„ë¥¼ ìˆœì„œëŒ€ë¡œ ë°˜ë³µ ì‹¤í–‰í•œë‹¤.

```
+---------------------------------------------------------------------+
|                                                                     |
|   [ ê²Œì„ ë£¨í”„ ì‹œì‘ ]                                                  |
|                                                                     |
|   1. ìƒì„±: ìƒˆë¡œìš´ ì ì´ë‚˜ ì´ì•Œì´ í•„ìš”í•˜ë©´ ë§Œë“¤ì–´ì„œ 'ë§ˆë²• ìƒì'ì— ë„£ëŠ”ë‹¤.      |
|      (spawnEnemies, MouseL.down())                                  |
|      â†“                                                              |
|   2. ì—…ë°ì´íŠ¸: ìƒì ì† ëª¨ë“  ê°ì²´ì—ê²Œ "ê°ì ì•Œì•„ì„œ ì›€ì§ì—¬!" ë¼ê³  ëª…ë ¹í•œë‹¤.    |
|      (obj->update())                                                |
|      â†“                                                              |
|   3. ì¶©ëŒ ì²˜ë¦¬: ìƒì ì† ëª¨ë“  ê°ì²´ë¥¼ ì„œë¡œ ë¹„êµí•´ì„œ ë¶€ë”ªí˜”ëŠ”ì§€ ê²€ì‚¬í•œë‹¤.       |
|      ë¶€ë”ªí˜”ë‹¤ë©´, ê°ì²´ë“¤ì—ê²Œ "ë„ˆí¬ ë‘˜ ë¶€ë”ªí˜”ì–´!" ë¼ê³  ì•Œë ¤ì¤€ë‹¤.             |
|      (objA->onCollision(*objB))                                     |
|      â†“                                                              |
|   4. ê·¸ë¦¬ê¸°: ìƒì ì† ëª¨ë“  ê°ì²´ì—ê²Œ "ê°ì ì•Œì•„ì„œ í™”ë©´ì— ë‚˜íƒ€ë‚˜!" ë¼ê³  ëª…ë ¹í•œë‹¤.|
|      (obj->draw())                                                  |
|      â†“                                                              |
|   5. ì†Œë©¸: ìƒì ì† ëª¨ë“  ê°ì²´ì—ê²Œ "í˜¹ì‹œ ì£½ì—ˆë‹ˆ?" ë¼ê³  ë¬¼ì–´ë³´ê³ ,             | 
|      ì£½ì—ˆë‹¤ê³  ëŒ€ë‹µí•˜ëŠ” ê°ì²´ëŠ” ìƒìì—ì„œ ë¹¼ì„œ ë²„ë¦°ë‹¤.                       |
|      (gameObjects.remove_if(...))                                   |
|      â†“                                                              |
|   [ ë‹¤ì‹œ ì²˜ìŒìœ¼ë¡œ ]                                                   |
|                                                                     |
+---------------------------------------------------------------------+
```

`Main` í•¨ìˆ˜ëŠ” ì´ì²˜ëŸ¼ **ì „ì²´ì ì¸ ì§€íœ˜**ë§Œ í•  ë¿, ê° ê°ì²´ê°€ ì–´ë–»ê²Œ ì›€ì§ì´ê³ , ë¶€ë”ªí˜”ì„ ë•Œ ì–´ë–»ê²Œ ë°˜ì‘í•˜ëŠ”ì§€ì™€ ê°™ì€ ì„¸ë¶€ì ì¸ í–‰ë™ì—ëŠ” ì „í˜€ ê´€ì—¬í•˜ì§€ ì•ŠëŠ”ë‹¤. ëª¨ë“  ê²ƒì€ ê°ì²´ ìŠ¤ìŠ¤ë¡œê°€ ì•Œì•„ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ë‹¤.


#### 3. ë™ì‘ (Behavior)
ì´ ì½”ë“œë¥¼ ì‹¤í–‰í–ˆì„ ë•Œ í™”ë©´ì—ì„œ ì¼ì–´ë‚˜ëŠ” ì¼ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

1.  **í”Œë ˆì´ì–´(ğŸš€) ë“±ì¥**: í™”ë©´ ì¤‘ì•™ì— í”Œë ˆì´ì–´ê°€ ë‚˜íƒ€ë‚˜ê³ , ì‚¬ìš©ìëŠ” `WASD` í‚¤ë¥¼ ì´ìš©í•´ ììœ ë¡­ê²Œ ì›€ì§ì¼ ìˆ˜ ìˆë‹¤.

2.  **ì (ğŸ‘¾, ğŸ‘¹, ğŸ‘») ìƒì„±**: 2ì´ˆë§ˆë‹¤ í™”ë©´ì˜ ëœë¤í•œ ìœ„ì¹˜ì—ì„œ ëœë¤í•œ ëª¨ìŠµê³¼ í¬ê¸°ë¥¼ ê°€ì§„ ì ë“¤ì´ ë‚˜íƒ€ë‚˜ ë²½ì— íŠ•ê¸°ë©° ëŒì•„ë‹¤ë‹Œë‹¤.

3.  **ì´ì•Œ(ğŸŸ¡) ë°œì‚¬**: ë§ˆìš°ìŠ¤ ì™¼ìª½ ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ì—ì„œ ë§ˆìš°ìŠ¤ ì»¤ì„œ ë°©í–¥ìœ¼ë¡œ ë…¸ë€ìƒ‰ ì´ì•Œì´ ë°œì‚¬ëœë‹¤.

4.  **ìƒí˜¸ì‘ìš© (ì¶©ëŒ)**:

      * **ì´ì•Œê³¼ ì **: ì´ì•Œì´ ì ì—ê²Œ ëª…ì¤‘í•˜ë©´, `Enemy`ì˜ `onCollision` í•¨ìˆ˜ê°€ í˜¸ì¶œëœë‹¤. ì´ í•¨ìˆ˜ëŠ” ë¶€ë”ªíŒ ê°ì²´ì˜ `getTypeTag()`ê°€ "Bullet"ì¸ ê²ƒì„ í™•ì¸í•˜ê³  ìŠ¤ìŠ¤ë¡œì˜ ì²´ë ¥ì„ ê¹ëŠ”ë‹¤. ë™ì‹œì— `Bullet`ì˜ `onCollision` í•¨ìˆ˜ë„ í˜¸ì¶œë˜ì–´, ë¶€ë”ªíŒ ê°ì²´ê°€ "Enemy"ì„ì„ í™•ì¸í•˜ê³  ìŠ¤ìŠ¤ë¡œë¥¼ ì†Œë©¸ì‹œí‚¨ë‹¤.
      * **ì ê³¼ í”Œë ˆì´ì–´**: ì ì´ í”Œë ˆì´ì–´ì™€ ë¶€ë”ªíˆë©´, `Player`ì˜ `onCollision` í•¨ìˆ˜ê°€ "Enemy"ë¥¼ ê°ì§€í•˜ê³  ìì‹ ì˜ ì²´ë ¥ì„ ê¹ëŠ”ë‹¤. `Enemy`ëŠ” "Player"ì™€ ë¶€ë”ªí˜”ìŒì„ í™•ì¸í•˜ê³  ì¦‰ì‹œ ì†Œë©¸í•œë‹¤.

5.  **ì†Œë©¸**: ì²´ë ¥ì´ 0ì´ ëœ ê°ì²´ë‚˜ ìˆ˜ëª…ì„ ë‹¤í•œ ì´ì•Œì€ `isAlive()` í•¨ìˆ˜ê°€ `false`ë¥¼ ë°˜í™˜í•˜ê²Œ ëœë‹¤. ê·¸ëŸ¬ë©´ ê²Œì„ ë£¨í”„ì˜ ë§ˆì§€ë§‰ ë‹¨ê³„ì—ì„œ ì´ë“¤ì„ ë°œê²¬í•˜ê³  `gameObjects` ë°°ì—´ì—ì„œ ì™„ì „íˆ ì œê±°í•´ë²„ë¦¬ëŠ” ê²ƒì´ë‹¤.



## 6.6 ìƒì†ê³¼ ë‹¤í˜•ì„±ì˜ ì£¼ìš” ì´ì 

1. **ì½”ë“œ ì¬ì‚¬ìš©ì„± í–¥ìƒ**
   - ê¸°ì¡´ í´ë˜ìŠ¤ì˜ ê¸°ëŠ¥ì„ í™•ì¥í•˜ì—¬ ìƒˆë¡œìš´ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
   - ê³µí†µ ì½”ë“œë¥¼ ë¶€ëª¨ í´ë˜ìŠ¤ì— ì‘ì„±í•˜ì—¬ ì¤‘ë³µì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤.

2. **ìœ ì§€ë³´ìˆ˜ ìš©ì´ì„±**
   - ê¸°ë³¸ í´ë˜ìŠ¤ì˜ ìˆ˜ì •ì´ ëª¨ë“  íŒŒìƒ í´ë˜ìŠ¤ì— ìë™ìœ¼ë¡œ ì ìš©ëœë‹¤.
   - ì½”ë“œ êµ¬ì¡°ê°€ ë” ëª…í™•í•´ì§€ê³  ëª¨ë“ˆí™”ëœë‹¤.

3. **í™•ì¥ì„±**
   - ê¸°ì¡´ ì‹œìŠ¤í…œì„ ë³€ê²½í•˜ì§€ ì•Šê³  ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
   - ê°œë°©-íì‡„ ì›ì¹™(OCP)ì„ ì‰½ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

4. **ë‹¤í˜•ì  ë™ì‘**
   - ê°™ì€ ì¸í„°í˜ì´ìŠ¤ë¡œ ë‹¤ì–‘í•œ ê°ì²´ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.
   - ëŸ°íƒ€ì„ì— ì ì ˆí•œ ë©”ì„œë“œê°€ ë™ì ìœ¼ë¡œ ì„ íƒëœë‹¤.
  

## 6.7 C++23ì˜ ìƒì† ë° ë‹¤í˜•ì„± ê´€ë ¨ ê¸°ëŠ¥
C++23ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìƒì† ë° ë‹¤í˜•ì„± ê´€ë ¨ ê°œì„  ì‚¬í•­ì´ ìˆë‹¤:

1. **ê°€ìƒ í•¨ìˆ˜ ìµœì í™” ê°œì„ **
   - ê°€ìƒ í•¨ìˆ˜ í˜¸ì¶œì— ëŒ€í•œ ì»´íŒŒì¼ëŸ¬ ìµœì í™”ê°€ í–¥ìƒë˜ì—ˆë‹¤.

2. **ë””í´íŠ¸ í…œí”Œë¦¿ ì¸ì ìƒì†**
   - í…œí”Œë¦¿ ìƒì† ì‹œ ê¸°ë³¸ ì¸ì ì²˜ë¦¬ê°€ ê°œì„ ë˜ì—ˆë‹¤.

3. **ì¡°ê±´ë¶€ ëª…ì‹œì  ê°€ìƒ ì˜¤ë²„ë¼ì´ë“œ**
   - íŠ¹ì • ì¡°ê±´ì—ì„œë§Œ ê°€ìƒ í•¨ìˆ˜ë¥¼ ì˜¤ë²„ë¼ì´ë“œí•˜ëŠ” ê¸°ëŠ¥ì´ ê°œì„ ë˜ì—ˆë‹¤.

4. **ê°œì„ ëœ ê°œë…(Concepts) ìƒì†**
   - í…œí”Œë¦¿ ë§¤ê°œë³€ìˆ˜ ì œì•½ ì¡°ê±´ì„ ìƒì†ì— ë” ìœ ì—°í•˜ê²Œ ì ìš©í•  ìˆ˜ ìˆë‹¤.
  

## ê²°ë¡ 
ì´ë²ˆ ë‹¨ê³„ì—ì„œëŠ” C++ì˜ ìƒì†ê³¼ ë‹¤í˜•ì„± ê°œë…ì„ Siv3Dë¥¼ í™œìš©í•˜ì—¬ ì‹œê°ì ì´ê³  ì¬ë¯¸ìˆëŠ” ë°©ì‹ìœ¼ë¡œ ë°°ì› ë‹¤. ì´ëŸ¬í•œ ê°œë…ë“¤ì€ ëŒ€ê·œëª¨ í”„ë¡œê·¸ë¨ì„ êµ¬ì„±í•˜ëŠ” ë° í•„ìˆ˜ì ì´ë©°, ì½”ë“œì˜ ì¬ì‚¬ìš©ì„±, í™•ì¥ì„±, ìœ ì§€ë³´ìˆ˜ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚¨ë‹¤.

ì‹¤ìŠµì—ì„œ êµ¬í˜„í•œ ì½”ë“œëŠ” ëª¨ë‘ ì‹¤ì œ ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ ê°œë°œì—ì„œ í™œìš©ë˜ëŠ” íŒ¨í„´ì´ë‹¤. ì´ëŸ¬í•œ ì˜ˆì œë¥¼ í†µí•´ ìƒì†ê³¼ ë‹¤í˜•ì„±ì˜ ì‹¤ìš©ì ì¸ í™œìš©ë²•ì„ ìµíˆê³ , ë” ë‚˜ì•„ê°€ ìì‹ ë§Œì˜ ì°½ì˜ì ì¸ í”„ë¡œì íŠ¸ì— ì ìš©í•´ ë³´ì‹œê¸° ë°”ë€ë‹¤.


