# OpenSiv3Dë¥¼ ì´ìš©í•œ C++ í”„ë¡œê·¸ë˜ë° í•™ìŠµ
  
ì €ì: ìµœí¥ë°°, Claude AI  
  
C++ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ë°°ìš°ëŠ” ê²ƒì— ì¤‘ì ì„ ë‘ë˜, Siv3D í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•˜ì—¬ ì‹œê°ì ìœ¼ë¡œ í¥ë¯¸ë¡œìš´ ì˜ˆì œë¥¼ í†µí•´ í•™ìŠµ íš¨ê³¼ë¥¼ ë†’ì´ë„ë¡ ì„¤ê³„ ë˜ì—ˆë‹¤. ë‹¨ìˆœí•œ ì½˜ì†” í”„ë¡œê·¸ë¨ ëŒ€ì‹  ê·¸ë˜í”½, ì†Œë¦¬, ìƒí˜¸ì‘ìš©ì„ í¬í•¨í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ë©° C++ì˜ ê°œë…ì„ ìµí ìˆ˜ ìˆë‹¤.  
  
í•„ìš” ì†Œí”„íŠ¸ì›¨ì–´:  
- Windows 10 ì´ìƒ
- Visual Studio 2022 ì´ìƒ   
  
-----    
    
# Chapter.10: ìµœì¢… í”„ë¡œì íŠ¸
ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ëª¨ë“  C++ ê°œë…ì„ ì¢…í•©ì ìœ¼ë¡œ í™œìš©í•˜ì—¬ ì‹¤ì œ ë™ì‘í•˜ëŠ” ì™„ì„±ëœ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“¤ì–´ ë³´ì. ì´ë²ˆ ë‹¨ê³„ì—ì„œëŠ” ì½”ë“œ êµ¬ì¡°í™”, ìµœì í™”, ë””ë²„ê¹… ê¸°ë²•ê³¼ í•¨ê»˜ ì‹¤ì œ í”„ë¡œì íŠ¸ ê°œë°œ ê²½í—˜ì„ ìŒ“ì„ ê²ƒì´ë‹¤. Siv3Dì˜ ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ í™œìš©í•˜ì—¬ ì¬ë¯¸ìˆê³  ì‹¤ìš©ì ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì™„ì„±í•´ ë³´ì.
  

## 10.1 í”„ë¡œì íŠ¸ ê¸°íšê³¼ êµ¬ì¡°í™”

### ì½”ë“œ êµ¬ì¡°í™”ì˜ ì¤‘ìš”ì„±
í° í”„ë¡œì íŠ¸ë¥¼ ì‹œì‘í•˜ê¸° ì „ì— ì½”ë“œ êµ¬ì¡°ë¥¼ ì˜ ì„¤ê³„í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤. ì´ë¥¼ í†µí•´:
- ì½”ë“œì˜ ê°€ë…ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ìœ ì§€ë³´ìˆ˜ê°€ ìš©ì´í•´ì§‘ë‹ˆë‹¤
- ê¸°ëŠ¥ í™•ì¥ì´ ì‰¬ì›Œì§‘ë‹ˆë‹¤
- íŒ€ ì‘ì—… ì‹œ í˜‘ì—…ì´ ìˆ˜ì›”í•´ì§‘ë‹ˆë‹¤

### í”„ë¡œì íŠ¸ êµ¬ì¡° ì„¤ê³„í•˜ê¸°

```cpp
// í”„ë¡œì íŠ¸ êµ¬ì¡° ì˜ˆì‹œ
// MyGame/
// â”œâ”€â”€ src/
// â”‚   â”œâ”€â”€ main.cpp             // ë©”ì¸ ì§„ì…ì 
// â”‚   â”œâ”€â”€ Game.hpp             // ê²Œì„ í´ë˜ìŠ¤ ì„ ì–¸
// â”‚   â”œâ”€â”€ Game.cpp             // ê²Œì„ í´ë˜ìŠ¤ êµ¬í˜„
// â”‚   â”œâ”€â”€ entities/            // ê²Œì„ ì—”í‹°í‹°(ìºë¦­í„°, ì  ë“±) ê´€ë ¨ íŒŒì¼
// â”‚   â”‚   â”œâ”€â”€ Player.hpp
// â”‚   â”‚   â”œâ”€â”€ Player.cpp
// â”‚   â”‚   â”œâ”€â”€ Enemy.hpp
// â”‚   â”‚   â””â”€â”€ Enemy.cpp
// â”‚   â”œâ”€â”€ systems/             // ê²Œì„ ì‹œìŠ¤í…œ(ì¶©ëŒ, ë¬¼ë¦¬ ë“±) ê´€ë ¨ íŒŒì¼
// â”‚   â”‚   â”œâ”€â”€ CollisionSystem.hpp
// â”‚   â”‚   â””â”€â”€ CollisionSystem.cpp
// â”‚   â””â”€â”€ ui/                  // ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ê´€ë ¨ íŒŒì¼
// â”‚       â”œâ”€â”€ Button.hpp
// â”‚       â””â”€â”€ Button.cpp
// â”œâ”€â”€ assets/                  // ì´ë¯¸ì§€, ì‚¬ìš´ë“œ ë“± ë¦¬ì†ŒìŠ¤ íŒŒì¼
// â”‚   â”œâ”€â”€ images/
// â”‚   â”œâ”€â”€ sounds/
// â”‚   â””â”€â”€ fonts/
// â””â”€â”€ config/                  // ì„¤ì • íŒŒì¼
//     â””â”€â”€ game_config.json
```
  
  
## 10.2 ìµœì í™” ê¸°ë²•

### ì„±ëŠ¥ ë³‘ëª© ì§€ì  ì°¾ê¸°
í”„ë¡œì íŠ¸ê°€ ì»¤ì§€ë©´ ì„±ëŠ¥ ìµœì í™”ê°€ ì¤‘ìš”í•´ì§„ë‹¤. Siv3Dì—ì„œ ì œê³µí•˜ëŠ” í”„ë¡œíŒŒì¼ë§ ë„êµ¬ë¥¼ í™œìš©í•´ë³´ì:

```cpp
#include <Siv3D.hpp>

void Main() 
{
    // í”„ë¡œíŒŒì¼ëŸ¬ ì´ˆê¸°í™”
    Profiler::EnableAssetCreationLogging();
    
    while (System::Update()) {
        Profiler::Begin(U"GameLogic");
        // ê²Œì„ ë¡œì§ ì‹¤í–‰
        // ...
        Profiler::End(U"GameLogic");
        
        Profiler::Begin(U"Rendering");
        // ë Œë”ë§ ì½”ë“œ
        // ...
        Profiler::End(U"Rendering");
        
        // í”„ë¡œíŒŒì¼ëŸ¬ ê²°ê³¼ í‘œì‹œ
        Profiler::ShowSimple();
    }
}
```

### ë°ì´í„° êµ¬ì¡° ìµœì í™”
ì ì ˆí•œ ë°ì´í„° êµ¬ì¡° ì„ íƒê³¼ ë©”ëª¨ë¦¬ ê´€ë¦¬ëŠ” ì„±ëŠ¥ì— í° ì˜í–¥ì„ ë¯¸ì¹œë‹¤:

```cpp
// ë¹„íš¨ìœ¨ì ì¸ ì½”ë“œ
std::vector<Enemy> enemies;
for (int i = 0; i < enemies.size(); i++) {
    if (!enemies[i].isActive()) {
        enemies.erase(enemies.begin() + i);
        i--; // ì¸ë±ìŠ¤ ì¡°ì •
    }
}

// ìµœì í™”ëœ ì½”ë“œ
std::erase_if(enemies, [](const Enemy& e) { return !e.isActive(); });
```

### ì´ë™ ì˜ë¯¸ë¡ (Move Semantics) í™œìš©
ë¶ˆí•„ìš”í•œ ë³µì‚¬ë¥¼ ì¤„ì´ê³  ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤:

```cpp
// ë¶ˆí•„ìš”í•œ ë³µì‚¬
std::vector<Texture> loadTextures() {
    std::vector<Texture> textures;
    textures.push_back(Texture{U"assets/player.png"});
    textures.push_back(Texture{U"assets/enemy.png"});
    return textures;
}

// ì´ë™ ì˜ë¯¸ë¡  í™œìš©
void processTextures() {
    auto textures = loadTextures(); // ìë™ìœ¼ë¡œ ì´ë™ ìƒì„±ì ì‚¬ìš©
    
    // ëª…ì‹œì  std::move ì‚¬ìš©
    GameTextures gameTextures;
    gameTextures.playerTexture = std::move(textures[0]);
    gameTextures.enemyTexture = std::move(textures[1]);
}
```
  


## 10.3 ë””ë²„ê¹… ê¸°ë²•

### íš¨ê³¼ì ì¸ ë””ë²„ê¹… ë°©ë²•
ë””ë²„ê¹…ì€ ê°œë°œ ê³¼ì •ì—ì„œ í•„ìˆ˜ì ì¸ ê¸°ìˆ ì´ë‹¤. C++ì—ì„œì˜ ë””ë²„ê¹… ë°©ë²•ì„ ì•Œì•„ë³´ì:

#### 1. Print ë””ë²„ê¹…
Siv3DëŠ” ê°„í¸í•œ Print í•¨ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤:

```cpp
Print << U"í”Œë ˆì´ì–´ ìœ„ì¹˜: " << player.getPosition();
Print << U"ì  ìˆ˜: " << enemies.size();

// ì¡°ê±´ë¶€ ë¡œê¹…
if (Debug::IsDebugBuild()) {
    Print << U"ë””ë²„ê·¸ ì •ë³´: " << someValue;
}
```

#### 2. ì‹œê°ì  ë””ë²„ê¹…
ì‹œê°ì  ìš”ì†Œë¥¼ ì¶”ê°€í•˜ì—¬ ê²Œì„ ìƒíƒœë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤:

```cpp
void drawDebugInfo() {
    // ì¶©ëŒ ì˜ì—­ í‘œì‹œ
    for (const auto& enemy : enemies) {
        enemy.getCollider().drawFrame(1, Palette::Red);
    }
    
    // ê²½ë¡œ í‘œì‹œ
    for (size_t i = 0; i < path.size() - 1; ++i) {
        Line(path[i], path[i + 1]).draw(2, Palette::Yellow);
    }
    
    // ìƒíƒœ ì •ë³´
    FontAsset(U"Debug")(U"FPS: {:.1f}"_fmt(Profiler::FPS())).draw(10, 10);
    FontAsset(U"Debug")(U"ë©”ëª¨ë¦¬: {} MB"_fmt(Profiler::GetUsedMemoryMB())).draw(10, 40);
}
```

#### 3. ì˜ˆì™¸ ì²˜ë¦¬
ì ì ˆí•œ ì˜ˆì™¸ ì²˜ë¦¬ë¡œ ì˜¤ë¥˜ë¥¼ ì‹ë³„í•˜ê³  ì²˜ë¦¬í•œë‹¤:

```cpp
try {
    Texture texture{U"assets/missing.png"};
    // í…ìŠ¤ì²˜ ì‚¬ìš©
} catch (const Error& error) {
    Print << U"ì˜¤ë¥˜ ë°œìƒ: " << error.what();
    // ì˜¤ë¥˜ ë³µêµ¬ ë¡œì§
}
```

#### 4. ë‹¨ì •ë¬¸(Assertions) ì‚¬ìš©
C++ì˜ `assert` ë˜ëŠ” Siv3Dì˜ ì»¤ìŠ¤í…€ ë‹¨ì •ë¬¸ì„ í™œìš©í•˜ì:

```cpp
// ì „í†µì ì¸ assert
assert(player.getHealth() >= 0);

// Siv3D ì»¤ìŠ¤í…€ assertion í•¨ìˆ˜
void MyAssert(bool condition, const String& message) {
    if (!condition) {
        Print << U"ë‹¨ì • ì‹¤íŒ¨: " << message;
        if (Debug::IsDebugBuild()) {
            System::DebugBreak();
        }
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
MyAssert(player.getHealth() >= 0, U"í”Œë ˆì´ì–´ ì²´ë ¥ì´ ìŒìˆ˜ì…ë‹ˆë‹¤!");
```
  


## 10.4 ë¯¸ë‹ˆ ê²Œì„ ì œì‘: í”Œë«í¼ ê²Œì„
ì´ì œ ë°°ìš´ ë‚´ìš©ì„ ì¢…í•©í•˜ì—¬ ê°„ë‹¨í•œ í”Œë«í¼ ê²Œì„ì„ ë§Œë“¤ì–´ ë³´ì. ì´ ê²Œì„ì€ í”Œë ˆì´ì–´ê°€ í”Œë«í¼ì„ ì í”„í•˜ë©° ì½”ì¸ì„ ëª¨ìœ¼ëŠ” ê°„ë‹¨í•œ ê²Œì„ì´ë‹¤.

### ê²Œì„ êµ¬ì¡° ì„¤ê³„

```cpp
#include <Siv3D.hpp>
#include <vector>
#include <memory>

// ê²Œì„ ìƒìˆ˜
constexpr double GRAVITY = 0.5;
constexpr double JUMP_POWER = -12.0;
constexpr double MOVE_SPEED = 5.0;

// ê²Œì„ ì˜¤ë¸Œì íŠ¸ ê¸°ë³¸ í´ë˜ìŠ¤
class GameObject {
public:
    virtual ~GameObject() = default;
    virtual void update() = 0;
    virtual void draw() const = 0;
    virtual RectF getCollider() const = 0;
};

// í”Œë ˆì´ì–´ í´ë˜ìŠ¤
class Player : public GameObject {
private:
    Vec2 m_pos;
    Vec2 m_velocity;
    Texture m_texture;
    bool m_isJumping;
    int m_score;
    
public:
    Player(Vec2 pos)
        : m_pos(pos), m_velocity(0, 0), m_isJumping(false), m_score(0) {
        m_texture = Texture(Emoji(U"ğŸ¤–"));
    }
    
    void update() override {
        // ì¤‘ë ¥ ì ìš©
        m_velocity.y += GRAVITY;
        
        // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
        if (KeyLeft.pressed()) m_velocity.x = -MOVE_SPEED;
        else if (KeyRight.pressed()) m_velocity.x = MOVE_SPEED;
        else m_velocity.x = 0;
        
        if (KeySpace.down() && !m_isJumping) {
            m_velocity.y = JUMP_POWER;
            m_isJumping = true;
            AudioAsset(U"Jump").playOneShot();
        }
        
        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        m_pos += m_velocity;
        
        // í™”ë©´ ê²½ê³„ ì²˜ë¦¬
        if (m_pos.x < 0) m_pos.x = 0;
        if (m_pos.x > Scene::Width() - 40) m_pos.x = Scene::Width() - 40;
    }
    
    void draw() const override {
        m_texture.resized(40).drawAt(m_pos);
        
        // ë””ë²„ê·¸ ì •ë³´
        if (Debug::IsDebugBuild()) {
            getCollider().drawFrame(1, Palette::Red);
        }
    }
    
    RectF getCollider() const override {
        return RectF(m_pos - Vec2(20, 20), 40, 40);
    }
    
    void land() {
        m_velocity.y = 0;
        m_isJumping = false;
    }
    
    void addScore(int points) {
        m_score += points;
        AudioAsset(U"Coin").playOneShot();
    }
    
    int getScore() const { return m_score; }
    Vec2 getPosition() const { return m_pos; }
    Vec2& getVelocity() { return m_velocity; }
};

// í”Œë«í¼ í´ë˜ìŠ¤
class Platform : public GameObject {
private:
    RectF m_rect;
    ColorF m_color;
    
public:
    Platform(RectF rect, ColorF color = ColorF(0.7, 0.8, 0.9))
        : m_rect(rect), m_color(color) {}
    
    void update() override {
        // í”Œë«í¼ì€ ì •ì ì´ë¯€ë¡œ ì—…ë°ì´íŠ¸ í•„ìš” ì—†ìŒ
    }
    
    void draw() const override {
        m_rect.draw(m_color).drawFrame(1, ColorF(0.5));
    }
    
    RectF getCollider() const override {
        return m_rect;
    }
};

// ì½”ì¸ í´ë˜ìŠ¤
class Coin : public GameObject {
private:
    Vec2 m_pos;
    double m_angle;
    Texture m_texture;
    bool m_isCollected;
    
public:
    Coin(Vec2 pos)
        : m_pos(pos), m_angle(0), m_isCollected(false) {
        m_texture = Texture(Emoji(U"ğŸª™"));
    }
    
    void update() override {
        m_angle += 0.05;  // íšŒì „ íš¨ê³¼
    }
    
    void draw() const override {
        if (!m_isCollected) {
            m_texture.resized(30).rotated(m_angle).drawAt(m_pos);
            
            // ë””ë²„ê·¸ ì •ë³´
            if (Debug::IsDebugBuild()) {
                getCollider().drawFrame(1, Palette::Yellow);
            }
        }
    }
    
    RectF getCollider() const override {
        return RectF(m_pos - Vec2(15, 15), 30, 30);
    }
    
    bool isCollected() const { return m_isCollected; }
    void collect() { m_isCollected = true; }
};

// ê²Œì„ ë§¤ë‹ˆì € í´ë˜ìŠ¤
class GameManager {
private:
    std::shared_ptr<Player> m_player;
    std::vector<std::shared_ptr<Platform>> m_platforms;
    std::vector<std::shared_ptr<Coin>> m_coins;
    Font m_font;
    double m_cameraY;
    int m_levelHeight;
    
    void checkCollisions() {
        auto playerCollider = m_player->getCollider();
        
        // í”Œë«í¼ ì¶©ëŒ í™•ì¸
        for (const auto& platform : m_platforms) {
            auto platformCollider = platform->getCollider();
            
            // í”Œë ˆì´ì–´ê°€ í”Œë«í¼ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
            if (playerCollider.bottom > platformCollider.top &&
                playerCollider.bottom < platformCollider.center().y &&
                playerCollider.horizontalOverlaps(platformCollider) &&
                m_player->getVelocity().y > 0) {
                
                m_player->getVelocity().y = 0;
                m_player->land();
                m_player->getPosition().y = platformCollider.top - 20;
            }
        }
        
        // ì½”ì¸ ì¶©ëŒ í™•ì¸
        for (auto& coin : m_coins) {
            if (!coin->isCollected() && playerCollider.intersects(coin->getCollider())) {
                coin->collect();
                m_player->addScore(100);
            }
        }
    }
    
    void generateLevel(int width, int height) {
        m_levelHeight = height;
        
        // ë°”ë‹¥ í”Œë«í¼
        m_platforms.push_back(std::make_shared<Platform>(
            RectF(0, 550, width, 50), ColorF(0.5, 0.8, 0.5)));
        
        // ëœë¤ í”Œë«í¼ ìƒì„±
        Random rng{123};  // ì‹œë“œ ê°’ ê³ ì •
        
        for (int y = 500; y > 0; y -= 150) {
            int platformCount = rng.int32(1, 3);
            
            for (int i = 0; i < platformCount; ++i) {
                double x = rng.double1() * (width - 200);
                double platformWidth = rng.double(100.0, 200.0);
                
                m_platforms.push_back(std::make_shared<Platform>(
                    RectF(x, y, platformWidth, 20)));
                
                // í”Œë«í¼ ìœ„ì— ì½”ì¸ ìƒì„± (50% í™•ë¥ )
                if (rng.int32(0, 1) == 0) {
                    m_coins.push_back(std::make_shared<Coin>(
                        Vec2(x + platformWidth / 2, y - 25)));
                }
            }
        }
    }
    
public:
    GameManager()
        : m_font(30, Typeface::Bold), m_cameraY(0) {
        // í”Œë ˆì´ì–´ ìƒì„±
        m_player = std::make_shared<Player>(Vec2(400, 300));
        
        // ë ˆë²¨ ìƒì„±
        generateLevel(800, 2000);
        
        // ì˜¤ë””ì˜¤ ì—ì…‹ ë“±ë¡
        AudioAsset::Register(U"Jump", GMInstrument::SynthBrass, PianoKey::C4, 0.3s);
        AudioAsset::Register(U"Coin", GMInstrument::Marimba, PianoKey::E5, 0.3s);
    }
    
    void update() {
        // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸
        m_player->update();
        
        // ì¶©ëŒ í™•ì¸
        checkCollisions();
        
        // ì½”ì¸ ì—…ë°ì´íŠ¸
        for (auto& coin : m_coins) {
            coin->update();
        }
        
        // ì¹´ë©”ë¼ Y ìœ„ì¹˜ ì„¤ì • (ë¶€ë“œëŸ¬ìš´ ë”°ë¼ê°€ê¸°)
        double targetY = m_player->getPosition().y - 300;
        m_cameraY = Math::Lerp(m_cameraY, targetY, 0.1);
        
        // ë†’ì´ ì œí•œ
        m_cameraY = Clamp(m_cameraY, 0.0, static_cast<double>(m_levelHeight));
    }
    
    void draw() const {
        // ë°°ê²½
        Scene::SetBackground(ColorF(0.4, 0.6, 0.8));
        
        // ì¹´ë©”ë¼ ë³€í™˜ ì ìš©
        const Transformer2D transformer{Mat3x2::Translate(0, -m_cameraY)};
        
        // í”Œë«í¼ ê·¸ë¦¬ê¸°
        for (const auto& platform : m_platforms) {
            platform->draw();
        }
        
        // ì½”ì¸ ê·¸ë¦¬ê¸°
        for (const auto& coin : m_coins) {
            coin->draw();
        }
        
        // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        m_player->draw();
        
        // UIëŠ” ì¹´ë©”ë¼ ë³€í™˜ ë°–ì—ì„œ ê·¸ë ¤ì•¼ í•¨
        {
            const ScopedTransformer2D resetTransformer{Mat3x2::Identity()};
            
            // ì ìˆ˜ í‘œì‹œ
            m_font(U"ì ìˆ˜: {}"_fmt(m_player->getScore())).draw(20, 20, ColorF(1.0));
            
            // ì¡°ì‘ ë°©ë²•
            const String controls = U"â† â†’ : ì´ë™ | Space : ì í”„";
            m_font(controls).drawAt(400, 560, ColorF(1.0));
        }
    }
};

// ë©”ì¸ í•¨ìˆ˜
void Main() {
    // ì°½ ì„¤ì •
    Window::SetTitle(U"í”Œë«í¼ ì í”„ ê²Œì„");
    Window::Resize(800, 600);
    
    // ê²Œì„ ë§¤ë‹ˆì € ìƒì„±
    auto gameManager = std::make_unique<GameManager>();
    
    while (System::Update()) {
        // ê²Œì„ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
        gameManager->update();
        gameManager->draw();
    }
}
```

### ì£¼ìš” C++ ê°œë… ì ìš©
ì´ í”Œë«í¼ ê²Œì„ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ C++ ê°œë…ë“¤ì„ ì ìš©í–ˆë‹¤:

1. **í´ë˜ìŠ¤ì™€ ìƒì†**: `GameObject`ë¥¼ ê¸°ë³¸ í´ë˜ìŠ¤ë¡œ í•˜ì—¬ ë‹¤ì–‘í•œ ê²Œì„ ê°ì²´ë“¤ì´ ìƒì†ë°›ëŠ”ë‹¤.
2. **ë‹¤í˜•ì„±**: ê°€ìƒ í•¨ìˆ˜ë¥¼ í†µí•œ ë‹¤í˜•ì„±ìœ¼ë¡œ ê°ì²´ë“¤ì„ ì¼ê´€ë˜ê²Œ ê´€ë¦¬í•œë‹¤.
3. **ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°**: `std::shared_ptr`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ìë™í™”í–ˆë‹¤.
4. **STL ì»¨í…Œì´ë„ˆ**: `std::vector`ë¡œ ê²Œì„ ê°ì²´ ì»¬ë ‰ì…˜ì„ ê´€ë¦¬í•œë‹¤.
5. **ëŒë‹¤ í‘œí˜„ì‹**: ì¶©ëŒ ê°ì§€ ë“±ì— ëŒë‹¤ í•¨ìˆ˜ë¥¼ í™œìš©í•  ìˆ˜ ìˆë‹¤.
6. **ë¬¸ìì—´ í¬ë§·íŒ…**: Siv3Dì˜ ë¬¸ìì—´ í¬ë§·íŒ… ê¸°ëŠ¥(`_fmt`)ì„ ì‚¬ìš©í–ˆë‹¤.
7. **ì˜ˆì™¸ ì²˜ë¦¬**: ë¦¬ì†ŒìŠ¤ ë¡œë”© ë“±ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•œë‹¤.
  


## 10.5 ë°ì´í„° ì‹œê°í™” ë„êµ¬ ë§Œë“¤ê¸°
ë‘ ë²ˆì§¸ í”„ë¡œì íŠ¸ë¡œ, ë°ì´í„°ë¥¼ ì‹œê°ì ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ë„êµ¬ë¥¼ ë§Œë“¤ì–´ ë³´ì. ì´ ì• í”Œë¦¬ì¼€ì´ì…˜ì€ CSV íŒŒì¼ì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì™€ ë‹¤ì–‘í•œ í˜•íƒœì˜ ì°¨íŠ¸ë¡œ ì‹œê°í™”í•œë‹¤.

```cpp
#include <Siv3D.hpp>
#include <vector>
#include <map>
#include <string>

// ë°ì´í„° í¬ì¸íŠ¸ êµ¬ì¡°ì²´
struct DataPoint {
    double x;
    double y;
    String label;
    ColorF color;
};

// ì°¨íŠ¸ ì¢…ë¥˜
enum class ChartType {
    LineChart,
    BarChart,
    ScatterPlot,
    PieChart
};

// ë°ì´í„° ê´€ë¦¬ í´ë˜ìŠ¤
class DataManager {
private:
    std::vector<DataPoint> m_data;
    String m_title;
    String m_xLabel;
    String m_yLabel;
    double m_minX, m_maxX;
    double m_minY, m_maxY;
    
public:
    DataManager() : m_minX(0), m_maxX(0), m_minY(0), m_maxY(0) {}
    
    bool loadFromCSV(const FilePath& path) {
        CSVData csv;
        
        try {
            csv = CSVReader::LoadCSV(path);
        } catch (const Error& error) {
            Print << U"CSV íŒŒì¼ ë¡œë”© ì˜¤ë¥˜: " << error.what();
            return false;
        }
        
        if (csv.isEmpty()) {
            return false;
        }
        
        m_data.clear();
        
        // CSV ì²« í–‰ì€ í—¤ë”ë¡œ ê°€ì •
        if (csv.columns() >= 3) {
            m_xLabel = csv[0][0];
            m_yLabel = csv[0][1];
            m_title = csv[0][2];
        }
        
        // ìƒ‰ìƒ ë°°ì—´
        Array<ColorF> colors = {
            Palette::Red, Palette::Green, Palette::Blue,
            Palette::Yellow, Palette::Orange, Palette::Purple,
            Palette::Cyan, Palette::Lime, Palette::Pink
        };
        
        // ë°ì´í„° íŒŒì‹±
        for (size_t i = 1; i < csv.rows(); i++) {
            if (csv.columns(i) >= 3) {
                Optional<double> x = Parse<double>(csv[i][0]);
                Optional<double> y = Parse<double>(csv[i][1]);
                
                if (x && y) {
                    DataPoint point;
                    point.x = *x;
                    point.y = *y;
                    point.label = csv[i][2];
                    point.color = colors[i % colors.size()];
                    
                    m_data.push_back(point);
                    
                    // ìµœì†Œ/ìµœëŒ€ê°’ ì—…ë°ì´íŠ¸
                    if (m_data.size() == 1) {
                        m_minX = m_maxX = point.x;
                        m_minY = m_maxY = point.y;
                    } else {
                        m_minX = std::min(m_minX, point.x);
                        m_maxX = std::max(m_maxX, point.x);
                        m_minY = std::min(m_minY, point.y);
                        m_maxY = std::max(m_maxY, point.y);
                    }
                }
            }
        }
        
        return !m_data.empty();
    }
    
    // ê²Œí„° ë©”ì„œë“œë“¤
    const std::vector<DataPoint>& getData() const { return m_data; }
    String getTitle() const { return m_title; }
    String getXLabel() const { return m_xLabel; }
    String getYLabel() const { return m_yLabel; }
    double getMinX() const { return m_minX; }
    double getMaxX() const { return m_maxX; }
    double getMinY() const { return m_minY; }
    double getMaxY() const { return m_maxY; }
};

// ì°¨íŠ¸ ê¸°ë³¸ í´ë˜ìŠ¤
class Chart {
protected:
    const DataManager& m_dataManager;
    Rect m_rect;
    Font m_titleFont;
    Font m_labelFont;
    Font m_valueFont;
    
public:
    Chart(const DataManager& dataManager, Rect rect)
        : m_dataManager(dataManager), m_rect(rect),
          m_titleFont(24, Typeface::Bold),
          m_labelFont(18, Typeface::Medium),
          m_valueFont(14, Typeface::Regular) {}
    
    virtual ~Chart() = default;
    virtual void draw() const = 0;
    
    void drawTitle() const {
        m_titleFont(m_dataManager.getTitle()).drawAt(m_rect.center().x, m_rect.y + 30, Palette::Black);
    }
    
    void drawAxes() const {
        // Xì¶•
        Line(m_rect.x + 60, m_rect.y + m_rect.h - 60, m_rect.x + m_rect.w - 30, m_rect.y + m_rect.h - 60)
            .draw(2, Palette::Black);
        m_labelFont(m_dataManager.getXLabel()).draw(m_rect.x + m_rect.w / 2 - 50, m_rect.y + m_rect.h - 30, Palette::Black);
        
        // Yì¶•
        Line(m_rect.x + 60, m_rect.y + 60, m_rect.x + 60, m_rect.y + m_rect.h - 60)
            .draw(2, Palette::Black);
        m_labelFont(m_dataManager.getYLabel()).drawAt(m_rect.x + 30, m_rect.y + m_rect.h / 2, 90_deg, Palette::Black);
    }
    
    // ì¢Œí‘œ ë³€í™˜ í•¨ìˆ˜ (ë°ì´í„° -> í™”ë©´)
    Vec2 dataToScreen(double x, double y) const {
        const double xRange = m_dataManager.getMaxX() - m_dataManager.getMinX();
        const double yRange = m_dataManager.getMaxY() - m_dataManager.getMinY();
        
        // ë²”ìœ„ê°€ 0ì´ë©´ ì˜ˆì™¸ ì²˜ë¦¬
        double xRatio = (xRange == 0) ? 0.5 : (x - m_dataManager.getMinX()) / xRange;
        double yRatio = (yRange == 0) ? 0.5 : 1.0 - (y - m_dataManager.getMinY()) / yRange;
        
        const double chartWidth = m_rect.w - 90; // ì¢Œìš° ì—¬ë°±
        const double chartHeight = m_rect.h - 120; // ìƒí•˜ ì—¬ë°±
        
        return Vec2(
            m_rect.x + 60 + xRatio * chartWidth,
            m_rect.y + 60 + yRatio * chartHeight
        );
    }
};

// ì„  ê·¸ë˜í”„ í´ë˜ìŠ¤
class LineChart : public Chart {
public:
    using Chart::Chart;
    
    void draw() const override {
        drawTitle();
        drawAxes();
        
        const auto& data = m_dataManager.getData();
        if (data.size() < 2) return;
        
        // ë°ì´í„° ì„  ê·¸ë¦¬ê¸°
        for (size_t i = 0; i < data.size() - 1; ++i) {
            Vec2 p1 = dataToScreen(data[i].x, data[i].y);
            Vec2 p2 = dataToScreen(data[i + 1].x, data[i + 1].y);
            
            Line(p1, p2).draw(2, data[i].color);
        }
        
        // ë°ì´í„° í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
        for (const auto& point : data) {
            Vec2 p = dataToScreen(point.x, point.y);
            Circle(p, 5).draw(point.color);
            
            // ë¼ë²¨ í‘œì‹œ
            m_valueFont(point.label).draw(p.x + 10, p.y - 10, Palette::Black);
        }
    }
};

// ë§‰ëŒ€ ê·¸ë˜í”„ í´ë˜ìŠ¤
class BarChart : public Chart {
public:
    using Chart::Chart;
    
    void draw() const override {
        drawTitle();
        drawAxes();
        
        const auto& data = m_dataManager.getData();
        if (data.empty()) return;
        
        const double barWidth = (m_rect.w - 120) / data.size() * 0.8;
        const double spacing = (m_rect.w - 120) / data.size() * 0.2;
        
        for (size_t i = 0; i < data.size(); ++i) {
            const auto& point = data[i];
            Vec2 bottom = dataToScreen(point.x, 0);
            Vec2 top = dataToScreen(point.x, point.y);
            
            // ë§‰ëŒ€ ê·¸ë¦¬ê¸°
            RectF(bottom.x - barWidth / 2, top.y, barWidth, bottom.y - top.y)
                .draw(point.color);
            
            // ë¼ë²¨ í‘œì‹œ
            m_valueFont(point.label).drawAt(bottom.x, bottom.y + 20, Palette::Black);
            m_valueFont(ToString(point.y)).drawAt(bottom.x, top.y - 10, Palette::Black);
        }
    }
};

// ì‚°ì ë„ í´ë˜ìŠ¤
class ScatterPlot : public Chart {
public:
    using Chart::Chart;
    
    void draw() const override {
        drawTitle();
        drawAxes();
        
        const auto& data = m_dataManager.getData();
        
        // ë°ì´í„° í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
        for (const auto& point : data) {
            Vec2 p = dataToScreen(point.x, point.y);
            Circle(p, 8).draw(point.color);
            
            // ë¼ë²¨ í‘œì‹œ
            m_valueFont(point.label).draw(p.x + 10, p.y - 10, Palette::Black);
            m_valueFont(U"({:.1f}, {:.1f})"_fmt(point.x, point.y))
                .draw(p.x + 10, p.y + 10, Palette::Gray);
        }
    }
};

// ì› ê·¸ë˜í”„ í´ë˜ìŠ¤
class PieChart : public Chart {
public:
    using Chart::Chart;
    
    void draw() const override {
        drawTitle();
        
        const auto& data = m_dataManager.getData();
        if (data.empty()) return;
        
        // ì´í•© ê³„ì‚°
        double total = 0;
        for (const auto& point : data) {
            total += point.y;
        }
        
        if (total <= 0) return;
        
        // ì¤‘ì‹¬ì  ë° ë°˜ì§€ë¦„
        const Vec2 center(m_rect.center().x, m_rect.center().y + 50);
        const double radius = std::min(m_rect.w, m_rect.h) * 0.35;
        
        // íŒŒì´ ì¡°ê° ê·¸ë¦¬ê¸°
        double startAngle = 0;
        
        for (const auto& point : data) {
            double angle = 2 * Math::Pi * (point.y / total);
            
            // íŒŒì´ ì¡°ê°
            Ellipse(center, radius, radius).drawPie(startAngle, angle, point.color);
            
            // íŒŒì´ ì¡°ê° ì¤‘ì•™ ë°©í–¥ ê³„ì‚°
            double midAngle = startAngle + angle / 2;
            Vec2 direction(std::cos(midAngle), std::sin(midAngle));
            Vec2 labelPos = center + direction * (radius * 1.2);
            
            // ë¼ë²¨ í‘œì‹œ
            m_valueFont(U"{}: {:.1f} ({:.1f}%)"_fmt(point.label, point.y, (point.y / total) * 100))
                .draw(labelPos.x, labelPos.y, Palette::Black);
            
            startAngle += angle;
        }
    }
};

// ì‹œê°í™” ì•± í´ë˜ìŠ¤
class VisualizationApp {
private:
    DataManager m_dataManager;
    std::unique_ptr<Chart> m_currentChart;
    ChartType m_chartType;
    Array<String> m_chartTypeNames;
    Rect m_chartArea;
    Font m_uiFont;
    TextEditState m_csvPathState;
    
    void createChart() {
        switch (m_chartType) {
        case ChartType::LineChart:
            m_currentChart = std::make_unique<LineChart>(m_dataManager, m_chartArea);
            break;
        case ChartType::BarChart:
            m_currentChart = std::make_unique<BarChart>(m_dataManager, m_chartArea);
            break;
        case ChartType::ScatterPlot:
            m_currentChart = std::make_unique<ScatterPlot>(m_dataManager, m_chartArea);
            break;
        case ChartType::PieChart:
            m_currentChart = std::make_unique<PieChart>(m_dataManager, m_chartArea);
            break;
        }
    }
    
public:
    VisualizationApp()
        : m_chartType(ChartType::LineChart),
          m_chartTypeNames{U"ì„  ê·¸ë˜í”„", U"ë§‰ëŒ€ ê·¸ë˜í”„", U"ì‚°ì ë„", U"ì› ê·¸ë˜í”„"},
          m_chartArea(50, 50, 700, 500),
          m_uiFont(18, Typeface::Medium) {
        
        m_csvPathState.text = U"sample/data.csv";
    }
    
    void update() {
        // ì°¨íŠ¸ ìœ í˜• ì„ íƒ ë²„íŠ¼
        for (int i = 0; i < 4; ++i) {
            Rect button(50 + i * 180, 570, 170, 40);
            
            if (button.draw(i == static_cast<int>(m_chartType) ?
                           Palette::Orange : Palette::White).clickedLeft()) {
                m_chartType = static_cast<ChartType>(i);
                createChart();
            }
            
            m_uiFont(m_chartTypeNames[i]).drawAt(button.center(), Palette::Black);
        }
        
        // CSV íŒŒì¼ ë¡œë“œ UI
        Rect csvPathBox(50, 620, 500, 40);
        SimpleGUI::TextBox(m_csvPathState, csvPathBox);
        
        Rect loadButton(560, 620, 100, 40);
        if (loadButton.draw(Palette::Blue).clickedLeft()) {
            if (m_dataManager.loadFromCSV(m_csvPathState.text)) {
                createChart();
            }
        }
        m_uiFont(U"ë¶ˆëŸ¬ì˜¤ê¸°").drawAt(loadButton.center(), Palette::White);
        
        Rect browseButton(670, 620, 80, 40);
        if (browseButton.draw(Palette::Green).clickedLeft()) {
            if (auto path = Dialog::OpenFile({FileFilter::CSV()})) {
                m_csvPathState.text = *path;
                if (m_dataManager.loadFromCSV(m_csvPathState.text)) {
                    createChart();
                }
            }
        }
        m_uiFont(U"ì°¾ê¸°").drawAt(browseButton.center(), Palette::White);
    }
    
    void draw() const {
        // ë°°ê²½
        Scene::SetBackground(ColorF(0.95));
        
        // ì°¨íŠ¸ ì˜ì—­
        m_chartArea.drawFrame(2, Palette::Gray);
        
        // ì°¨íŠ¸ ê·¸ë¦¬ê¸°
        if (m_currentChart) {
            m_currentChart->draw();
        } else {
            m_uiFont(U"ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€ ì‹œê°í™”í•˜ì„¸ìš”.").drawAt(m_chartArea.center(), Palette::Gray);
        }
    }
};

// ë©”ì¸ í•¨ìˆ˜
void Main() {
    // ì°½ ì„¤ì •
    Window::SetTitle(U"ë°ì´í„° ì‹œê°í™” ë„êµ¬");
    Window::Resize(800, 680);
    
    // ì•± ê°ì²´ ìƒì„±
    VisualizationApp app;
    
    while (System::Update()) {
        app.update();
        app.draw();
    }
}
```

ì´ í”„ë¡œì íŠ¸ì—ì„œ í™œìš©í•œ ì£¼ìš” C++ ê°œë…ë“¤:

1. **í…œí”Œë¦¿ ë° ë‹¤í˜•ì„±**: ë‹¤ì–‘í•œ ì°¨íŠ¸ ìœ í˜•ì„ ìƒì†ê³¼ ë‹¤í˜•ì„±ìœ¼ë¡œ êµ¬í˜„í–ˆë‹¤.
2. **ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°**: `std::unique_ptr`ë¡œ ì°¨íŠ¸ ê°ì²´ë¥¼ ê´€ë¦¬í•œë‹¤.
3. **ê³µí†µ ì¸í„°í˜ì´ìŠ¤**: ëª¨ë“  ì°¨íŠ¸ í´ë˜ìŠ¤ëŠ” ë™ì¼í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•œë‹¤.
4. **ì‚¬ìš©ì ì •ì˜ ìë£Œí˜•**: `struct DataPoint`ë¡œ ë°ì´í„° í¬ì¸íŠ¸ë¥¼ í‘œí˜„í•œë‹¤.
5. **ì—´ê±°í˜•**: `ChartType`ìœ¼ë¡œ ì°¨íŠ¸ ìœ í˜•ì„ ì •ì˜í–ˆë‹¤.
6. **íŒŒì¼ I/O**: CSV íŒŒì¼ì„ ì½ì–´ì™€ ë°ì´í„°ë¡œ ë³€í™˜í•œë‹¤.
7. **ì˜ˆì™¸ ì²˜ë¦¬**: íŒŒì¼ ë¡œë”© ì‹œ ì˜ˆì™¸ë¥¼ ì ì ˆíˆ ì²˜ë¦¬í•œë‹¤.
  



## 10.6 ì¸í„°ë™í‹°ë¸Œ ë©€í‹°ë¯¸ë””ì–´ ì• í”Œë¦¬ì¼€ì´ì…˜
ë§ˆì§€ë§‰ í”„ë¡œì íŠ¸ë¡œ, ë‹¤ì–‘í•œ ë¯¸ë””ì–´ ìš”ì†Œ(ë¹„ë””ì˜¤, ì˜¤ë””ì˜¤, ì´ë¯¸ì§€)ë¥¼ ë‹¤ë£¨ëŠ” ì¸í„°ë™í‹°ë¸Œ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“¤ì–´ ë³´ì.

```cpp
#include <Siv3D.hpp>
#include <memory>
#include <vector>
#include <variant>
#include <functional>

// ë¯¸ë””ì–´ íƒ€ì… ì—´ê±°í˜•
enum class MediaType {
    Image,
    Audio,
    Video,
    Text
};

// ë¯¸ë””ì–´ í•­ëª© ê¸°ë³¸ í´ë˜ìŠ¤
class MediaItem {
protected:
    String m_name;
    String m_path;
    Rect m_rect;
    bool m_isSelected;
    
public:
    MediaItem(const String& name, const String& path, const Rect& rect)
        : m_name(name), m_path(path), m_rect(rect), m_isSelected(false) {}
    
    virtual ~MediaItem() = default;
    virtual void update() = 0;
    virtual void draw() const = 0;
    virtual MediaType getType() const = 0;
    
    const String& getName() const { return m_name; }
    const String& getPath() const { return m_path; }
    const Rect& getRect() const { return m_rect; }
    
    bool isSelected() const { return m_isSelected; }
    void setSelected(bool selected) { m_isSelected = selected; }
    
    bool contains(const Vec2& pos) const {
        return m_rect.contains(pos);
    }
};

// ì´ë¯¸ì§€ ë¯¸ë””ì–´ í•­ëª©
class ImageItem : public MediaItem {
private:
    Texture m_texture;
    double m_scale;
    bool m_isLoaded;
    
public:
    ImageItem(const String& name, const String& path, const Rect& rect)
        : MediaItem(name, path, rect), m_scale(1.0), m_isLoaded(false) {
        try {
            m_texture = Texture(path);
            m_isLoaded = true;
        } catch (const Error& error) {
            Print << U"ì´ë¯¸ì§€ ë¡œë”© ì˜¤ë¥˜: " << error.what();
        }
    }
    
    void update() override {
        if (m_isSelected && MouseWheel::Rotation()) {
            m_scale += MouseWheel::Rotation() * 0.1;
            m_scale = Clamp(m_scale, 0.5, 3.0);
        }
    }
    
    void draw() const override {
        // í•­ëª© ë°°ê²½
        m_rect.draw(m_isSelected ? ColorF(0.7, 0.9, 1.0) : ColorF(0.9));
        
        // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        if (m_isLoaded) {
            const Vec2 center = m_rect.center();
            const double aspectRatio = static_cast<double>(m_texture.width()) / m_texture.height();
            
            const double drawWidth = std::min(m_rect.w - 20, (m_rect.h - 20) * aspectRatio) * m_scale;
            const double drawHeight = drawWidth / aspectRatio;
            
            m_texture.resized(drawWidth, drawHeight).drawAt(center);
        } else {
            // ë¡œë”© ì‹¤íŒ¨ í‘œì‹œ
            FontAsset(U"Default")(U"ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨").drawAt(m_rect.center(), Palette::Red);
        }
        
        // í…Œë‘ë¦¬ ë° ì´ë¦„
        m_rect.drawFrame(2, m_isSelected ? Palette::Orange : Palette::Gray);
        FontAsset(U"Default")(m_name).draw(m_rect.x + 10, m_rect.y + 10, Palette::Black);
    }
    
    MediaType getType() const override { return MediaType::Image; }
};

// ì˜¤ë””ì˜¤ ë¯¸ë””ì–´ í•­ëª©
class AudioItem : public MediaItem {
private:
    Audio m_audio;
    bool m_isLoaded;
    bool m_isPlaying;
    FFT m_fft;
    
public:
    AudioItem(const String& name, const String& path, const Rect& rect)
        : MediaItem(name, path, rect), m_isLoaded(false), m_isPlaying(false), m_fft(FFTSampleLength::Medium) {
        try {
            m_audio = Audio(path);
            m_isLoaded = true;
        } catch (const Error& error) {
            Print << U"ì˜¤ë””ì˜¤ ë¡œë”© ì˜¤ë¥˜: " << error.what();
        }
    }
    
    ~AudioItem() {
        if (m_isPlaying) {
            m_audio.stop();
        }
    }
    
    void update() override {
        if (m_isSelected && MouseL.down() && m_isLoaded) {
            if (m_isPlaying) {
                m_audio.pause();
                m_isPlaying = false;
            } else {
                m_audio.play();
                m_isPlaying = true;
            }
        }
        
        // FFT ë¶„ì„
        if (m_isPlaying) {
            m_fft.update(m_audio);
        }
    }
    
    void draw() const override {
        // í•­ëª© ë°°ê²½
        m_rect.draw(m_isSelected ? ColorF(0.7, 0.9, 1.0) : ColorF(0.9));
        
        // ì˜¤ë””ì˜¤ ì‹œê°í™”
        if (m_isLoaded) {
            // ì¬ìƒ ìƒíƒœ
            const String statusText = m_isPlaying ? U"â–  ì¬ìƒ ì¤‘" : U"â–¶ ì¼ì‹œ ì •ì§€ë¨";
            FontAsset(U"Default")(statusText)
                .draw(m_rect.x + 10, m_rect.center().y, m_isPlaying ? Palette::Red : Palette::Black);
            
            // ì¬ìƒ ì‹œê°„
            const double duration = m_audio.lengthSec();
            const double currentTime = m_audio.posSec();
            FontAsset(U"Default")(U"{:0>2}:{:0>2} / {:0>2}:{:0>2}"_fmt(
                static_cast<int>(currentTime) / 60, static_cast<int>(currentTime) % 60,
                static_cast<int>(duration) / 60, static_cast<int>(duration) % 60
            )).draw(m_rect.x + 10, m_rect.center().y + 30, Palette::Black);
            
            // ì˜¤ë””ì˜¤ íŒŒí˜• ë˜ëŠ” FFT ì‹œê°í™”
            if (m_isPlaying) {
                const double barWidth = (m_rect.w - 20) / 30;
                for (int i = 0; i < 30; ++i) {
                    const double height = m_fft.buffer[i / 30.0 * m_fft.buffer.size()] * 100;
                    RectF(m_rect.x + 10 + i * barWidth, m_rect.y + m_rect.h - 20 - height,
                        barWidth * 0.8, height).draw(ColorF(0.2, 0.7, 0.9, 0.8));
                }
            }
        } else {
            // ë¡œë”© ì‹¤íŒ¨ í‘œì‹œ
            FontAsset(U"Default")(U"ì˜¤ë””ì˜¤ ë¡œë”© ì‹¤íŒ¨").drawAt(m_rect.center(), Palette::Red);
        }
        
        // í…Œë‘ë¦¬ ë° ì´ë¦„
        m_rect.drawFrame(2, m_isSelected ? Palette::Orange : Palette::Gray);
        FontAsset(U"Default")(m_name).draw(m_rect.x + 10, m_rect.y + 10, Palette::Black);
    }
    
    MediaType getType() const override { return MediaType::Audio; }
};

// ë¹„ë””ì˜¤ ë¯¸ë””ì–´ í•­ëª©
class VideoItem : public MediaItem {
private:
    VideoTexture m_video;
    bool m_isLoaded;
    bool m_isPlaying;
    
public:
    VideoItem(const String& name, const String& path, const Rect& rect)
        : MediaItem(name, path, rect), m_isLoaded(false), m_isPlaying(false) {
        try {
            m_video = VideoTexture(path);
            m_isLoaded = true;
        } catch (const Error& error) {
            Print << U"ë¹„ë””ì˜¤ ë¡œë”© ì˜¤ë¥˜: " << error.what();
        }
    }
    
    ~VideoItem() {
        if (m_isPlaying) {
            m_video.pause();
        }
    }
    
    void update() override {
        if (m_isSelected && MouseL.down() && m_isLoaded) {
            if (m_isPlaying) {
                m_video.pause();
                m_isPlaying = false;
            } else {
                m_video.play();
                m_isPlaying = true;
            }
        }
    }
    
    void draw() const override {
        // í•­ëª© ë°°ê²½
        m_rect.draw(m_isSelected ? ColorF(0.7, 0.9, 1.0) : ColorF(0.9));
        
        // ë¹„ë””ì˜¤ ê·¸ë¦¬ê¸°
        if (m_isLoaded) {
            const Vec2 center = m_rect.center();
            const double aspectRatio = static_cast<double>(m_video.getSize().x) / m_video.getSize().y;
            
            const double drawWidth = std::min(m_rect.w - 20, (m_rect.h - 60) * aspectRatio);
            const double drawHeight = drawWidth / aspectRatio;
            
            m_video.scaled(drawWidth / m_video.getSize().x).drawAt(center.movedBy(0, -15));
            
            // ì¬ìƒ ìƒíƒœ
            const String statusText = m_isPlaying ? U"â–  ì¬ìƒ ì¤‘" : U"â–¶ ì¼ì‹œ ì •ì§€ë¨";
            FontAsset(U"Default")(statusText)
                .draw(m_rect.x + 10, m_rect.y + m_rect.h - 30, m_isPlaying ? Palette::Red : Palette::Black);
        } else {
            // ë¡œë”© ì‹¤íŒ¨ í‘œì‹œ
            FontAsset(U"Default")(U"ë¹„ë””ì˜¤ ë¡œë”© ì‹¤íŒ¨").drawAt(m_rect.center(), Palette::Red);
        }
        
        // í…Œë‘ë¦¬ ë° ì´ë¦„
        m_rect.drawFrame(2, m_isSelected ? Palette::Orange : Palette::Gray);
        FontAsset(U"Default")(m_name).draw(m_rect.x + 10, m_rect.y + 10, Palette::Black);
    }
    
    MediaType getType() const override { return MediaType::Video; }
};

// í…ìŠ¤íŠ¸ ë¯¸ë””ì–´ í•­ëª©
class TextItem : public MediaItem {
private:
    String m_content;
    bool m_isLoaded;
    TextEditState m_textEdit;
    
public:
    TextItem(const String& name, const String& path, const Rect& rect)
        : MediaItem(name, path, rect), m_isLoaded(false) {
        try {
            TextReader reader(path);
            if (reader) {
                m_content = reader.readAll();
                m_textEdit.text = m_content;
                m_isLoaded = true;
            }
        } catch (const Error& error) {
            Print << U"í…ìŠ¤íŠ¸ ë¡œë”© ì˜¤ë¥˜: " << error.what();
        }
    }
    
    void update() override {
        if (m_isSelected && m_isLoaded) {
            // í…ìŠ¤íŠ¸ í¸ì§‘
            SimpleGUI::TextArea(m_textEdit, m_rect.stretched(-10));
            
            // ì €ì¥
            if (KeyS.down() && KeyControl.pressed()) {
                saveText();
            }
        }
    }
    
    void draw() const override {
        // í•­ëª© ë°°ê²½
        m_rect.draw(m_isSelected ? ColorF(0.7, 0.9, 1.0) : ColorF(0.9));
        
        if (m_isLoaded) {
            if (m_isSelected) {
                // TextAreaê°€ ê·¸ë ¤ì§ (updateì—ì„œ ì²˜ë¦¬)
            } else {
                // í…ìŠ¤íŠ¸ ë¯¸ë¦¬ë³´ê¸°
                FontAsset(U"Default")(m_content.substr(0, 100) + (m_content.length() > 100 ? U"..." : U""))
                    .draw(m_rect.stretched(-10), Palette::Black);
            }
        } else {
            // ë¡œë”© ì‹¤íŒ¨ í‘œì‹œ
            FontAsset(U"Default")(U"í…ìŠ¤íŠ¸ ë¡œë”© ì‹¤íŒ¨").drawAt(m_rect.center(), Palette::Red);
        }
        
        // í…Œë‘ë¦¬ ë° ì´ë¦„
        m_rect.drawFrame(2, m_isSelected ? Palette::Orange : Palette::Gray);
        FontAsset(U"Default")(m_name).draw(m_rect.x + 10, m_rect.y + 10, Palette::Black);
        
        if (m_isSelected && m_isLoaded) {
            FontAsset(U"Default")(U"Ctrl+Së¡œ ì €ì¥").draw(m_rect.x + 10, m_rect.y + 40, Palette::Black);
        }
    }
    
    MediaType getType() const override { return MediaType::Text; }
    
private:
    void saveText() {
        TextWriter writer(m_path);
        if (writer) {
            writer.write(m_textEdit.text);
            Print << U"íŒŒì¼ì„ ì €ì¥í–ˆìŠµë‹ˆë‹¤: " << m_path;
        } else {
            Print << U"íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: " << m_path;
        }
    }
};

// ë¯¸ë””ì–´ ê°¤ëŸ¬ë¦¬ í´ë˜ìŠ¤
class MediaGallery {
private:
    std::vector<std::shared_ptr<MediaItem>> m_items;
    Font m_titleFont;
    Font m_buttonFont;
    Optional<size_t> m_selectedIndex;
    
    struct MediaTemplate {
        String label;
        MediaType type;
        Array<FileFilter> filters;
    };
    
    Array<MediaTemplate> m_templates;
    
public:
    MediaGallery()
        : m_titleFont(28, Typeface::Bold),
          m_buttonFont(18, Typeface::Medium) {
        
        // í°íŠ¸ ì—ì…‹ ë“±ë¡
        FontAsset::Register(U"Default", 16, Typeface::Regular);
        
        // ë¯¸ë””ì–´ í…œí”Œë¦¿ ì´ˆê¸°í™”
        m_templates = {
            { U"ì´ë¯¸ì§€", MediaType::Image, { FileFilter::AllImageFiles() } },
            { U"ì˜¤ë””ì˜¤", MediaType::Audio, { FileFilter::AllAudioFiles() } },
            { U"ë¹„ë””ì˜¤", MediaType::Video, { FileFilter::Video() } },
            { U"í…ìŠ¤íŠ¸", MediaType::Text, { FileFilter::Text(), FileFilter::Source() } }
        };
    }
    
    void update() {
        // ì•„ì´í…œ ì—…ë°ì´íŠ¸
        for (auto& item : m_items) {
            item->update();
        }
        
        // ë§ˆìš°ìŠ¤ í´ë¦­ìœ¼ë¡œ ì•„ì´í…œ ì„ íƒ
        if (MouseL.down()) {
            bool itemSelected = false;
            
            for (size_t i = 0; i < m_items.size(); ++i) {
                if (m_items[i]->contains(Cursor::Pos())) {
                    selectItem(i);
                    itemSelected = true;
                    break;
                }
            }
            
            if (!itemSelected && m_selectedIndex) {
                deselectItem();
            }
        }
        
        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        if (KeyDelete.down() && m_selectedIndex) {
            removeSelectedItem();
        }
    }
    
    void draw() const {
        // íƒ€ì´í‹€
        m_titleFont(U"ë©€í‹°ë¯¸ë””ì–´ ê°¤ëŸ¬ë¦¬").drawAt(400, 30, Palette::Black);
        
        // ì•„ì´í…œ ê·¸ë¦¬ê¸°
        for (const auto& item : m_items) {
            item->draw();
        }
        
        // ì¶”ê°€ ë²„íŠ¼ë“¤
        for (int i = 0; i < m_templates.size(); ++i) {
            Rect button(50 + i * 180, 620, 170, 40);
            
            if (button.draw(Palette::Blue).clickedLeft()) {
                addMediaItem(m_templates[i].type);
            }
            
            m_buttonFont(U"{} ì¶”ê°€"_fmt(m_templates[i].label)).drawAt(button.center(), Palette::White);
        }
        
        // ì‚­ì œ ë²„íŠ¼
        Rect deleteButton(650, 620, 100, 40);
        if (m_selectedIndex) {
            if (deleteButton.draw(Palette::Red).clickedLeft()) {
                removeSelectedItem();
            }
            m_buttonFont(U"ì‚­ì œ").drawAt(deleteButton.center(), Palette::White);
        } else {
            deleteButton.draw(ColorF(0.7));
            m_buttonFont(U"ì‚­ì œ").drawAt(deleteButton.center(), ColorF(0.8));
        }
    }
    
private:
    void addMediaItem(MediaType type) {
        Optional<FilePath> path;
        String name;
        
        // íŒŒì¼ ëŒ€í™”ìƒìë¡œ íŒŒì¼ ì„ íƒ
        for (const auto& tmpl : m_templates) {
            if (tmpl.type == type) {
                path = Dialog::OpenFile(tmpl.filters);
                break;
            }
        }
        
        if (!path) return;
        
        // íŒŒì¼ ì´ë¦„ ì¶”ì¶œ
        name = FileSystem::FileName(*path);
        
        // í•­ëª© ë°°ì¹˜ ìœ„ì¹˜ ê³„ì‚°
        const int itemsPerRow = 2;
        const int itemWidth = 370;
        const int itemHeight = 280;
        const int itemCount = static_cast<int>(m_items.size());
        
        const int row = itemCount / itemsPerRow;
        const int col = itemCount % itemsPerRow;
        
        Rect rect(30 + col * (itemWidth + 10), 70 + row * (itemHeight + 10), itemWidth, itemHeight);
        
        // ìƒˆ ë¯¸ë””ì–´ í•­ëª© ìƒì„±
        std::shared_ptr<MediaItem> newItem;
        
        switch (type) {
        case MediaType::Image:
            newItem = std::make_shared<ImageItem>(name, *path, rect);
            break;
        case MediaType::Audio:
            newItem = std::make_shared<AudioItem>(name, *path, rect);
            break;
        case MediaType::Video:
            newItem = std::make_shared<VideoItem>(name, *path, rect);
            break;
        case MediaType::Text:
            newItem = std::make_shared<TextItem>(name, *path, rect);
            break;
        }
        
        // ìƒˆ í•­ëª© ì¶”ê°€ ë° ì„ íƒ
        if (newItem) {
            m_items.push_back(newItem);
            selectItem(m_items.size() - 1);
        }
    }
    
    void selectItem(size_t index) {
        if (m_selectedIndex) {
            m_items[*m_selectedIndex]->setSelected(false);
        }
        
        m_selectedIndex = index;
        m_items[index]->setSelected(true);
    }
    
    void deselectItem() {
        if (m_selectedIndex) {
            m_items[*m_selectedIndex]->setSelected(false);
            m_selectedIndex = none;
        }
    }
    
    void removeSelectedItem() {
        if (m_selectedIndex) {
            m_items.erase(m_items.begin() + *m_selectedIndex);
            m_selectedIndex = none;
        }
    }
};

// ë©”ì¸ í•¨ìˆ˜
void Main() {
    // ì°½ ì„¤ì •
    Window::SetTitle(U"ë©€í‹°ë¯¸ë””ì–´ ê°¤ëŸ¬ë¦¬");
    Window::Resize(800, 680);
    
    // ë¯¸ë””ì–´ ê°¤ëŸ¬ë¦¬ ìƒì„±
    MediaGallery gallery;
    
    while (System::Update()) {
        gallery.update();
        gallery.draw();
    }
}
```

ì´ í”„ë¡œì íŠ¸ì—ì„œ í™œìš©í•œ ì£¼ìš” C++ ê°œë…ë“¤:

1. **ìƒì†ê³¼ ë‹¤í˜•ì„±**: ë‹¤ì–‘í•œ ë¯¸ë””ì–´ ìœ í˜•ì„ í•˜ë‚˜ì˜ ì¸í„°í˜ì´ìŠ¤ë¡œ ì²˜ë¦¬í•œë‹¤.
2. **ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°**: `std::shared_ptr`ë¡œ ë¯¸ë””ì–´ í•­ëª©ë“¤ì„ ê´€ë¦¬í•œë‹¤.
3. **RAII íŒ¨í„´**: ë¦¬ì†ŒìŠ¤ì˜ ìƒì„±ê³¼ ì†Œë©¸ì„ ê°ì²´ì˜ ìˆ˜ëª…ì— ì—°ê²°í•œë‹¤.
4. **í…œí”Œë¦¿ ë©”íƒ€í”„ë¡œê·¸ë˜ë°**: ë°ì´í„° êµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ ì²˜ë¦¬ì— í™œìš©í•œë‹¤.
5. **í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°**: ëŒë‹¤ì™€ í•¨ìˆ˜ ê°ì²´ë¥¼ ì‚¬ìš©í•œë‹¤.
6. **ì˜ˆì™¸ ì²˜ë¦¬**: íŒŒì¼ ë¡œë”©ê³¼ ì²˜ë¦¬ ì˜¤ë¥˜ë¥¼ ì¡ì•„ë‚¸ë‹¤.
7. **ë‹¤ì–‘í•œ STL í™œìš©**: ì»¨í…Œì´ë„ˆ, ì•Œê³ ë¦¬ì¦˜ ë“±ì„ í™œìš©í•œë‹¤.
  



## 10.7 ìµœì¢… ì •ë¦¬
ì´ë²ˆ ë‹¨ê³„ì—ì„œëŠ” C++ì˜ ë‹¤ì–‘í•œ ê°œë…ë“¤ì„ ì‹¤ì œ í”„ë¡œì íŠ¸ì— ì ìš©í•´ ë³´ì•˜ë‹¤. ì´ í”„ë¡œì íŠ¸ë“¤ì€ ì—¬ëŸ¬ë¶„ì˜ í•™ìŠµ ì—¬ì •ì˜ ì¢…ì°©ì ì´ ì•„ë‹Œ, ìƒˆë¡œìš´ ì¶œë°œì ì´ ë  ê²ƒì´ë‹¤. ë‹¤ìŒì€ ì•ìœ¼ë¡œì˜ í•™ìŠµ ë°©í–¥ì— ëŒ€í•œ ì œì•ˆì´ë‹¤:  

### ë” ë°°ì›Œë³¼ ì£¼ì œ
1. **ë©€í‹°ìŠ¤ë ˆë”©**: C++20ì˜ `std::jthread`ì™€ ë³‘ë ¬ ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•œ ê³ ì„±ëŠ¥ ì• í”Œë¦¬ì¼€ì´ì…˜ ê°œë°œ
2. **ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°**: ì˜¨ë¼ì¸ ê¸°ëŠ¥ì´ ìˆëŠ” ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ ë§Œë“¤ê¸°
3. **ë””ìì¸ íŒ¨í„´**: ë” í™•ì¥ ê°€ëŠ¥í•˜ê³  ìœ ì§€ë³´ìˆ˜ê°€ ì‰¬ìš´ ì½”ë“œ êµ¬ì¡° ë§Œë“¤ê¸°
4. **C++23ì˜ ì‹ ê¸°ëŠ¥**: `std::ranges`, `std::format` ë“±ì˜ ìµœì‹  ê¸°ëŠ¥ í™œìš©í•˜ê¸°
5. **ê²Œì„ ì—”ì§„ ê°œë°œ**: ìì‹ ë§Œì˜ ì‘ì€ ê²Œì„ ì—”ì§„ ë§Œë“¤ê¸°
  

### í”„ë¡œì íŠ¸ ì•„ì´ë””ì–´
1. **ìì‹ ë§Œì˜ ê²Œì„ ê°œë°œ**: ê°„ë‹¨í•œ í„´ì œ RPG, í¼ì¦ ê²Œì„, ì•¡ì…˜ ê²Œì„ ë“±
2. **ì‹œë®¬ë ˆì´ì…˜ í”„ë¡œê·¸ë¨**: ë¬¼ë¦¬, í™”í•™, ìƒë¬¼í•™ ë“±ì˜ í˜„ìƒì„ ì‹œë®¬ë ˆì´ì…˜
3. **ë°ì´í„° ë¶„ì„ ë„êµ¬**: ë¹…ë°ì´í„° ì‹œê°í™” ë° ë¶„ì„ ë„êµ¬
4. **ì°½ì‘ ë„êµ¬**: ë””ì§€í„¸ ì•„íŠ¸, ìŒì•… ì‘ê³¡, ìŠ¤í† ë¦¬í…”ë§ ë“±ì˜ ë„êµ¬
5. **ìœ í‹¸ë¦¬í‹° ì• í”Œë¦¬ì¼€ì´ì…˜**: ì¼ìƒ ìƒí™œì´ë‚˜ ì—…ë¬´ì— ë„ì›€ì´ ë˜ëŠ” ë„êµ¬
  

### ë§ˆë¬´ë¦¬
C++ì™€ Siv3Dë¥¼ í™œìš©í•œ í”„ë¡œê·¸ë˜ë° ì—¬ì •ì—ì„œ ì¤‘ìš”í•œ ê²ƒì€ ê³„ì†í•´ì„œ ë§Œë“¤ê³ , ë°°ìš°ê³ , ê°œì„ í•˜ëŠ” ê²ƒì´ë‹¤. ì²˜ìŒë¶€í„° ì™„ë²½í•œ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ì˜¤ë¥˜ë¥¼ ë§Œë‚˜ê³ , ê·¸ê²ƒì„ í•´ê²°í•˜ë©° ì„±ì¥í•˜ëŠ” ê³¼ì •ì´ ì§„ì •í•œ í”„ë¡œê·¸ë˜ë° í•™ìŠµì´ë‹¤.

ì´ì œ ì—¬ëŸ¬ë¶„ì€ C++ì˜ ê¸°ë³¸ê³¼ ë‹¤ì–‘í•œ ê³ ê¸‰ ê¸°ëŠ¥ë“¤ì„ ë°°ì› ë‹¤. ì´ë¥¼ í† ëŒ€ë¡œ ìì‹ ë§Œì˜ ì°½ì˜ì ì¸ í”„ë¡œì íŠ¸ë¥¼ ì‹œì‘í•´ ë³´ì. í”„ë¡œê·¸ë˜ë°ì˜ ì§„ì •í•œ ì¦ê±°ì›€ì€ ìì‹ ì˜ ì•„ì´ë””ì–´ë¥¼ ì½”ë“œë¡œ í‘œí˜„í•˜ê³ , ê·¸ê²ƒì´ ì‹¤ì œë¡œ ë™ì‘í•˜ëŠ” ê²ƒì„ ë³´ëŠ” ìˆœê°„ì— ìˆë‹¤.

í–‰ìš´ì„ ë¹ˆë‹¤! ì—¬ëŸ¬ë¶„ì˜ C++ í”„ë¡œê·¸ë˜ë° ì—¬ì •ì´ ì¦ê²ê³  ë³´ëŒì°¨ê¸°ë¥¼ ë°”ë€ë‹¤.

