# OpenSiv3D를 이용한 C++ 프로그래밍 학습
  
저자: 최흥배, Claude AI  
  
C++ 프로그래밍 언어를 배우는 것에 중점을 두되, Siv3D 프레임워크를 활용하여 시각적으로 흥미로운 예제를 통해 학습 효과를 높이도록 설계 되었다. 단순한 콘솔 프로그램 대신 그래픽, 소리, 상호작용을 포함한 프로그램을 만들며 C++의 개념을 익힐 수 있다.  
  
필요 소프트웨어:  
- Windows 10 이상
- Visual Studio 2022 이상   
  
-----    
    
# Chapter.10: 최종 프로젝트
지금까지 배운 모든 C++ 개념을 종합적으로 활용하여 실제 동작하는 완성된 애플리케이션을 만들어 보자. 이번 단계에서는 코드 구조화, 최적화, 디버깅 기법과 함께 실제 프로젝트 개발 경험을 쌓을 것이다. Siv3D의 다양한 기능을 활용하여 재미있고 실용적인 애플리케이션을 완성해 보자.
  

## 10.1 프로젝트 기획과 구조화

### 코드 구조화의 중요성
큰 프로젝트를 시작하기 전에 코드 구조를 잘 설계하는 것이 중요하다. 이를 통해:
- 코드의 가독성을 높일 수 있습니다
- 유지보수가 용이해집니다
- 기능 확장이 쉬워집니다
- 팀 작업 시 협업이 수월해집니다

### 프로젝트 구조 설계하기

```cpp
// 프로젝트 구조 예시
// MyGame/
// ├── src/
// │   ├── main.cpp             // 메인 진입점
// │   ├── Game.hpp             // 게임 클래스 선언
// │   ├── Game.cpp             // 게임 클래스 구현
// │   ├── entities/            // 게임 엔티티(캐릭터, 적 등) 관련 파일
// │   │   ├── Player.hpp
// │   │   ├── Player.cpp
// │   │   ├── Enemy.hpp
// │   │   └── Enemy.cpp
// │   ├── systems/             // 게임 시스템(충돌, 물리 등) 관련 파일
// │   │   ├── CollisionSystem.hpp
// │   │   └── CollisionSystem.cpp
// │   └── ui/                  // 사용자 인터페이스 관련 파일
// │       ├── Button.hpp
// │       └── Button.cpp
// ├── assets/                  // 이미지, 사운드 등 리소스 파일
// │   ├── images/
// │   ├── sounds/
// │   └── fonts/
// └── config/                  // 설정 파일
//     └── game_config.json
```
  
  
## 10.2 최적화 기법

### 성능 병목 지점 찾기
프로젝트가 커지면 성능 최적화가 중요해진다. Siv3D에서 제공하는 프로파일링 도구를 활용해보자:

```cpp
#include <Siv3D.hpp>

void Main() 
{
    // 프로파일러 초기화
    Profiler::EnableAssetCreationLogging();
    
    while (System::Update()) {
        Profiler::Begin(U"GameLogic");
        // 게임 로직 실행
        // ...
        Profiler::End(U"GameLogic");
        
        Profiler::Begin(U"Rendering");
        // 렌더링 코드
        // ...
        Profiler::End(U"Rendering");
        
        // 프로파일러 결과 표시
        Profiler::ShowSimple();
    }
}
```

### 데이터 구조 최적화
적절한 데이터 구조 선택과 메모리 관리는 성능에 큰 영향을 미친다:

```cpp
// 비효율적인 코드
std::vector<Enemy> enemies;
for (int i = 0; i < enemies.size(); i++) {
    if (!enemies[i].isActive()) {
        enemies.erase(enemies.begin() + i);
        i--; // 인덱스 조정
    }
}

// 최적화된 코드
std::erase_if(enemies, [](const Enemy& e) { return !e.isActive(); });
```

### 이동 의미론(Move Semantics) 활용
불필요한 복사를 줄이고 성능을 향상시킬 수 있다:

```cpp
// 불필요한 복사
std::vector<Texture> loadTextures() {
    std::vector<Texture> textures;
    textures.push_back(Texture{U"assets/player.png"});
    textures.push_back(Texture{U"assets/enemy.png"});
    return textures;
}

// 이동 의미론 활용
void processTextures() {
    auto textures = loadTextures(); // 자동으로 이동 생성자 사용
    
    // 명시적 std::move 사용
    GameTextures gameTextures;
    gameTextures.playerTexture = std::move(textures[0]);
    gameTextures.enemyTexture = std::move(textures[1]);
}
```
  


## 10.3 디버깅 기법

### 효과적인 디버깅 방법
디버깅은 개발 과정에서 필수적인 기술이다. C++에서의 디버깅 방법을 알아보자:

#### 1. Print 디버깅
Siv3D는 간편한 Print 함수를 제공합니다:

```cpp
Print << U"플레이어 위치: " << player.getPosition();
Print << U"적 수: " << enemies.size();

// 조건부 로깅
if (Debug::IsDebugBuild()) {
    Print << U"디버그 정보: " << someValue;
}
```

#### 2. 시각적 디버깅
시각적 요소를 추가하여 게임 상태를 확인할 수 있다:

```cpp
void drawDebugInfo() {
    // 충돌 영역 표시
    for (const auto& enemy : enemies) {
        enemy.getCollider().drawFrame(1, Palette::Red);
    }
    
    // 경로 표시
    for (size_t i = 0; i < path.size() - 1; ++i) {
        Line(path[i], path[i + 1]).draw(2, Palette::Yellow);
    }
    
    // 상태 정보
    FontAsset(U"Debug")(U"FPS: {:.1f}"_fmt(Profiler::FPS())).draw(10, 10);
    FontAsset(U"Debug")(U"메모리: {} MB"_fmt(Profiler::GetUsedMemoryMB())).draw(10, 40);
}
```

#### 3. 예외 처리
적절한 예외 처리로 오류를 식별하고 처리한다:

```cpp
try {
    Texture texture{U"assets/missing.png"};
    // 텍스처 사용
} catch (const Error& error) {
    Print << U"오류 발생: " << error.what();
    // 오류 복구 로직
}
```

#### 4. 단정문(Assertions) 사용
C++의 `assert` 또는 Siv3D의 커스텀 단정문을 활용하자:

```cpp
// 전통적인 assert
assert(player.getHealth() >= 0);

// Siv3D 커스텀 assertion 함수
void MyAssert(bool condition, const String& message) {
    if (!condition) {
        Print << U"단정 실패: " << message;
        if (Debug::IsDebugBuild()) {
            System::DebugBreak();
        }
    }
}

// 사용 예시
MyAssert(player.getHealth() >= 0, U"플레이어 체력이 음수입니다!");
```
  


## 10.4 미니 게임 제작: 플랫폼 게임
이제 배운 내용을 종합하여 간단한 플랫폼 게임을 만들어 보자. 이 게임은 플레이어가 플랫폼을 점프하며 코인을 모으는 간단한 게임이다.

### 게임 구조 설계

```cpp
#include <Siv3D.hpp>
#include <vector>
#include <memory>

// 게임 상수
constexpr double GRAVITY = 0.5;
constexpr double JUMP_POWER = -12.0;
constexpr double MOVE_SPEED = 5.0;

// 게임 오브젝트 기본 클래스
class GameObject {
public:
    virtual ~GameObject() = default;
    virtual void update() = 0;
    virtual void draw() const = 0;
    virtual RectF getCollider() const = 0;
};

// 플레이어 클래스
class Player : public GameObject {
private:
    Vec2 m_pos;
    Vec2 m_velocity;
    Texture m_texture;
    bool m_isJumping;
    int m_score;
    
public:
    Player(Vec2 pos)
        : m_pos(pos), m_velocity(0, 0), m_isJumping(false), m_score(0) {
        m_texture = Texture(Emoji(U"🤖"));
    }
    
    void update() override {
        // 중력 적용
        m_velocity.y += GRAVITY;
        
        // 키보드 입력 처리
        if (KeyLeft.pressed()) m_velocity.x = -MOVE_SPEED;
        else if (KeyRight.pressed()) m_velocity.x = MOVE_SPEED;
        else m_velocity.x = 0;
        
        if (KeySpace.down() && !m_isJumping) {
            m_velocity.y = JUMP_POWER;
            m_isJumping = true;
            AudioAsset(U"Jump").playOneShot();
        }
        
        // 위치 업데이트
        m_pos += m_velocity;
        
        // 화면 경계 처리
        if (m_pos.x < 0) m_pos.x = 0;
        if (m_pos.x > Scene::Width() - 40) m_pos.x = Scene::Width() - 40;
    }
    
    void draw() const override {
        m_texture.resized(40).drawAt(m_pos);
        
        // 디버그 정보
        if (Debug::IsDebugBuild()) {
            getCollider().drawFrame(1, Palette::Red);
        }
    }
    
    RectF getCollider() const override {
        return RectF(m_pos - Vec2(20, 20), 40, 40);
    }
    
    void land() {
        m_velocity.y = 0;
        m_isJumping = false;
    }
    
    void addScore(int points) {
        m_score += points;
        AudioAsset(U"Coin").playOneShot();
    }
    
    int getScore() const { return m_score; }
    Vec2 getPosition() const { return m_pos; }
    Vec2& getVelocity() { return m_velocity; }
};

// 플랫폼 클래스
class Platform : public GameObject {
private:
    RectF m_rect;
    ColorF m_color;
    
public:
    Platform(RectF rect, ColorF color = ColorF(0.7, 0.8, 0.9))
        : m_rect(rect), m_color(color) {}
    
    void update() override {
        // 플랫폼은 정적이므로 업데이트 필요 없음
    }
    
    void draw() const override {
        m_rect.draw(m_color).drawFrame(1, ColorF(0.5));
    }
    
    RectF getCollider() const override {
        return m_rect;
    }
};

// 코인 클래스
class Coin : public GameObject {
private:
    Vec2 m_pos;
    double m_angle;
    Texture m_texture;
    bool m_isCollected;
    
public:
    Coin(Vec2 pos)
        : m_pos(pos), m_angle(0), m_isCollected(false) {
        m_texture = Texture(Emoji(U"🪙"));
    }
    
    void update() override {
        m_angle += 0.05;  // 회전 효과
    }
    
    void draw() const override {
        if (!m_isCollected) {
            m_texture.resized(30).rotated(m_angle).drawAt(m_pos);
            
            // 디버그 정보
            if (Debug::IsDebugBuild()) {
                getCollider().drawFrame(1, Palette::Yellow);
            }
        }
    }
    
    RectF getCollider() const override {
        return RectF(m_pos - Vec2(15, 15), 30, 30);
    }
    
    bool isCollected() const { return m_isCollected; }
    void collect() { m_isCollected = true; }
};

// 게임 매니저 클래스
class GameManager {
private:
    std::shared_ptr<Player> m_player;
    std::vector<std::shared_ptr<Platform>> m_platforms;
    std::vector<std::shared_ptr<Coin>> m_coins;
    Font m_font;
    double m_cameraY;
    int m_levelHeight;
    
    void checkCollisions() {
        auto playerCollider = m_player->getCollider();
        
        // 플랫폼 충돌 확인
        for (const auto& platform : m_platforms) {
            auto platformCollider = platform->getCollider();
            
            // 플레이어가 플랫폼 위에 있는지 확인
            if (playerCollider.bottom > platformCollider.top &&
                playerCollider.bottom < platformCollider.center().y &&
                playerCollider.horizontalOverlaps(platformCollider) &&
                m_player->getVelocity().y > 0) {
                
                m_player->getVelocity().y = 0;
                m_player->land();
                m_player->getPosition().y = platformCollider.top - 20;
            }
        }
        
        // 코인 충돌 확인
        for (auto& coin : m_coins) {
            if (!coin->isCollected() && playerCollider.intersects(coin->getCollider())) {
                coin->collect();
                m_player->addScore(100);
            }
        }
    }
    
    void generateLevel(int width, int height) {
        m_levelHeight = height;
        
        // 바닥 플랫폼
        m_platforms.push_back(std::make_shared<Platform>(
            RectF(0, 550, width, 50), ColorF(0.5, 0.8, 0.5)));
        
        // 랜덤 플랫폼 생성
        Random rng{123};  // 시드 값 고정
        
        for (int y = 500; y > 0; y -= 150) {
            int platformCount = rng.int32(1, 3);
            
            for (int i = 0; i < platformCount; ++i) {
                double x = rng.double1() * (width - 200);
                double platformWidth = rng.double(100.0, 200.0);
                
                m_platforms.push_back(std::make_shared<Platform>(
                    RectF(x, y, platformWidth, 20)));
                
                // 플랫폼 위에 코인 생성 (50% 확률)
                if (rng.int32(0, 1) == 0) {
                    m_coins.push_back(std::make_shared<Coin>(
                        Vec2(x + platformWidth / 2, y - 25)));
                }
            }
        }
    }
    
public:
    GameManager()
        : m_font(30, Typeface::Bold), m_cameraY(0) {
        // 플레이어 생성
        m_player = std::make_shared<Player>(Vec2(400, 300));
        
        // 레벨 생성
        generateLevel(800, 2000);
        
        // 오디오 에셋 등록
        AudioAsset::Register(U"Jump", GMInstrument::SynthBrass, PianoKey::C4, 0.3s);
        AudioAsset::Register(U"Coin", GMInstrument::Marimba, PianoKey::E5, 0.3s);
    }
    
    void update() {
        // 플레이어 업데이트
        m_player->update();
        
        // 충돌 확인
        checkCollisions();
        
        // 코인 업데이트
        for (auto& coin : m_coins) {
            coin->update();
        }
        
        // 카메라 Y 위치 설정 (부드러운 따라가기)
        double targetY = m_player->getPosition().y - 300;
        m_cameraY = Math::Lerp(m_cameraY, targetY, 0.1);
        
        // 높이 제한
        m_cameraY = Clamp(m_cameraY, 0.0, static_cast<double>(m_levelHeight));
    }
    
    void draw() const {
        // 배경
        Scene::SetBackground(ColorF(0.4, 0.6, 0.8));
        
        // 카메라 변환 적용
        const Transformer2D transformer{Mat3x2::Translate(0, -m_cameraY)};
        
        // 플랫폼 그리기
        for (const auto& platform : m_platforms) {
            platform->draw();
        }
        
        // 코인 그리기
        for (const auto& coin : m_coins) {
            coin->draw();
        }
        
        // 플레이어 그리기
        m_player->draw();
        
        // UI는 카메라 변환 밖에서 그려야 함
        {
            const ScopedTransformer2D resetTransformer{Mat3x2::Identity()};
            
            // 점수 표시
            m_font(U"점수: {}"_fmt(m_player->getScore())).draw(20, 20, ColorF(1.0));
            
            // 조작 방법
            const String controls = U"← → : 이동 | Space : 점프";
            m_font(controls).drawAt(400, 560, ColorF(1.0));
        }
    }
};

// 메인 함수
void Main() {
    // 창 설정
    Window::SetTitle(U"플랫폼 점프 게임");
    Window::Resize(800, 600);
    
    // 게임 매니저 생성
    auto gameManager = std::make_unique<GameManager>();
    
    while (System::Update()) {
        // 게임 업데이트 및 그리기
        gameManager->update();
        gameManager->draw();
    }
}
```

### 주요 C++ 개념 적용
이 플랫폼 게임에서는 다음과 같은 C++ 개념들을 적용했다:

1. **클래스와 상속**: `GameObject`를 기본 클래스로 하여 다양한 게임 객체들이 상속받는다.
2. **다형성**: 가상 함수를 통한 다형성으로 객체들을 일관되게 관리한다.
3. **스마트 포인터**: `std::shared_ptr`를 사용하여 메모리 관리를 자동화했다.
4. **STL 컨테이너**: `std::vector`로 게임 객체 컬렉션을 관리한다.
5. **람다 표현식**: 충돌 감지 등에 람다 함수를 활용할 수 있다.
6. **문자열 포맷팅**: Siv3D의 문자열 포맷팅 기능(`_fmt`)을 사용했다.
7. **예외 처리**: 리소스 로딩 등에서 발생할 수 있는 예외를 처리한다.
  


## 10.5 데이터 시각화 도구 만들기
두 번째 프로젝트로, 데이터를 시각적으로 표현하는 도구를 만들어 보자. 이 애플리케이션은 CSV 파일에서 데이터를 읽어와 다양한 형태의 차트로 시각화한다.

```cpp
#include <Siv3D.hpp>
#include <vector>
#include <map>
#include <string>

// 데이터 포인트 구조체
struct DataPoint {
    double x;
    double y;
    String label;
    ColorF color;
};

// 차트 종류
enum class ChartType {
    LineChart,
    BarChart,
    ScatterPlot,
    PieChart
};

// 데이터 관리 클래스
class DataManager {
private:
    std::vector<DataPoint> m_data;
    String m_title;
    String m_xLabel;
    String m_yLabel;
    double m_minX, m_maxX;
    double m_minY, m_maxY;
    
public:
    DataManager() : m_minX(0), m_maxX(0), m_minY(0), m_maxY(0) {}
    
    bool loadFromCSV(const FilePath& path) {
        CSVData csv;
        
        try {
            csv = CSVReader::LoadCSV(path);
        } catch (const Error& error) {
            Print << U"CSV 파일 로딩 오류: " << error.what();
            return false;
        }
        
        if (csv.isEmpty()) {
            return false;
        }
        
        m_data.clear();
        
        // CSV 첫 행은 헤더로 가정
        if (csv.columns() >= 3) {
            m_xLabel = csv[0][0];
            m_yLabel = csv[0][1];
            m_title = csv[0][2];
        }
        
        // 색상 배열
        Array<ColorF> colors = {
            Palette::Red, Palette::Green, Palette::Blue,
            Palette::Yellow, Palette::Orange, Palette::Purple,
            Palette::Cyan, Palette::Lime, Palette::Pink
        };
        
        // 데이터 파싱
        for (size_t i = 1; i < csv.rows(); i++) {
            if (csv.columns(i) >= 3) {
                Optional<double> x = Parse<double>(csv[i][0]);
                Optional<double> y = Parse<double>(csv[i][1]);
                
                if (x && y) {
                    DataPoint point;
                    point.x = *x;
                    point.y = *y;
                    point.label = csv[i][2];
                    point.color = colors[i % colors.size()];
                    
                    m_data.push_back(point);
                    
                    // 최소/최대값 업데이트
                    if (m_data.size() == 1) {
                        m_minX = m_maxX = point.x;
                        m_minY = m_maxY = point.y;
                    } else {
                        m_minX = std::min(m_minX, point.x);
                        m_maxX = std::max(m_maxX, point.x);
                        m_minY = std::min(m_minY, point.y);
                        m_maxY = std::max(m_maxY, point.y);
                    }
                }
            }
        }
        
        return !m_data.empty();
    }
    
    // 게터 메서드들
    const std::vector<DataPoint>& getData() const { return m_data; }
    String getTitle() const { return m_title; }
    String getXLabel() const { return m_xLabel; }
    String getYLabel() const { return m_yLabel; }
    double getMinX() const { return m_minX; }
    double getMaxX() const { return m_maxX; }
    double getMinY() const { return m_minY; }
    double getMaxY() const { return m_maxY; }
};

// 차트 기본 클래스
class Chart {
protected:
    const DataManager& m_dataManager;
    Rect m_rect;
    Font m_titleFont;
    Font m_labelFont;
    Font m_valueFont;
    
public:
    Chart(const DataManager& dataManager, Rect rect)
        : m_dataManager(dataManager), m_rect(rect),
          m_titleFont(24, Typeface::Bold),
          m_labelFont(18, Typeface::Medium),
          m_valueFont(14, Typeface::Regular) {}
    
    virtual ~Chart() = default;
    virtual void draw() const = 0;
    
    void drawTitle() const {
        m_titleFont(m_dataManager.getTitle()).drawAt(m_rect.center().x, m_rect.y + 30, Palette::Black);
    }
    
    void drawAxes() const {
        // X축
        Line(m_rect.x + 60, m_rect.y + m_rect.h - 60, m_rect.x + m_rect.w - 30, m_rect.y + m_rect.h - 60)
            .draw(2, Palette::Black);
        m_labelFont(m_dataManager.getXLabel()).draw(m_rect.x + m_rect.w / 2 - 50, m_rect.y + m_rect.h - 30, Palette::Black);
        
        // Y축
        Line(m_rect.x + 60, m_rect.y + 60, m_rect.x + 60, m_rect.y + m_rect.h - 60)
            .draw(2, Palette::Black);
        m_labelFont(m_dataManager.getYLabel()).drawAt(m_rect.x + 30, m_rect.y + m_rect.h / 2, 90_deg, Palette::Black);
    }
    
    // 좌표 변환 함수 (데이터 -> 화면)
    Vec2 dataToScreen(double x, double y) const {
        const double xRange = m_dataManager.getMaxX() - m_dataManager.getMinX();
        const double yRange = m_dataManager.getMaxY() - m_dataManager.getMinY();
        
        // 범위가 0이면 예외 처리
        double xRatio = (xRange == 0) ? 0.5 : (x - m_dataManager.getMinX()) / xRange;
        double yRatio = (yRange == 0) ? 0.5 : 1.0 - (y - m_dataManager.getMinY()) / yRange;
        
        const double chartWidth = m_rect.w - 90; // 좌우 여백
        const double chartHeight = m_rect.h - 120; // 상하 여백
        
        return Vec2(
            m_rect.x + 60 + xRatio * chartWidth,
            m_rect.y + 60 + yRatio * chartHeight
        );
    }
};

// 선 그래프 클래스
class LineChart : public Chart {
public:
    using Chart::Chart;
    
    void draw() const override {
        drawTitle();
        drawAxes();
        
        const auto& data = m_dataManager.getData();
        if (data.size() < 2) return;
        
        // 데이터 선 그리기
        for (size_t i = 0; i < data.size() - 1; ++i) {
            Vec2 p1 = dataToScreen(data[i].x, data[i].y);
            Vec2 p2 = dataToScreen(data[i + 1].x, data[i + 1].y);
            
            Line(p1, p2).draw(2, data[i].color);
        }
        
        // 데이터 포인트 그리기
        for (const auto& point : data) {
            Vec2 p = dataToScreen(point.x, point.y);
            Circle(p, 5).draw(point.color);
            
            // 라벨 표시
            m_valueFont(point.label).draw(p.x + 10, p.y - 10, Palette::Black);
        }
    }
};

// 막대 그래프 클래스
class BarChart : public Chart {
public:
    using Chart::Chart;
    
    void draw() const override {
        drawTitle();
        drawAxes();
        
        const auto& data = m_dataManager.getData();
        if (data.empty()) return;
        
        const double barWidth = (m_rect.w - 120) / data.size() * 0.8;
        const double spacing = (m_rect.w - 120) / data.size() * 0.2;
        
        for (size_t i = 0; i < data.size(); ++i) {
            const auto& point = data[i];
            Vec2 bottom = dataToScreen(point.x, 0);
            Vec2 top = dataToScreen(point.x, point.y);
            
            // 막대 그리기
            RectF(bottom.x - barWidth / 2, top.y, barWidth, bottom.y - top.y)
                .draw(point.color);
            
            // 라벨 표시
            m_valueFont(point.label).drawAt(bottom.x, bottom.y + 20, Palette::Black);
            m_valueFont(ToString(point.y)).drawAt(bottom.x, top.y - 10, Palette::Black);
        }
    }
};

// 산점도 클래스
class ScatterPlot : public Chart {
public:
    using Chart::Chart;
    
    void draw() const override {
        drawTitle();
        drawAxes();
        
        const auto& data = m_dataManager.getData();
        
        // 데이터 포인트 그리기
        for (const auto& point : data) {
            Vec2 p = dataToScreen(point.x, point.y);
            Circle(p, 8).draw(point.color);
            
            // 라벨 표시
            m_valueFont(point.label).draw(p.x + 10, p.y - 10, Palette::Black);
            m_valueFont(U"({:.1f}, {:.1f})"_fmt(point.x, point.y))
                .draw(p.x + 10, p.y + 10, Palette::Gray);
        }
    }
};

// 원 그래프 클래스
class PieChart : public Chart {
public:
    using Chart::Chart;
    
    void draw() const override {
        drawTitle();
        
        const auto& data = m_dataManager.getData();
        if (data.empty()) return;
        
        // 총합 계산
        double total = 0;
        for (const auto& point : data) {
            total += point.y;
        }
        
        if (total <= 0) return;
        
        // 중심점 및 반지름
        const Vec2 center(m_rect.center().x, m_rect.center().y + 50);
        const double radius = std::min(m_rect.w, m_rect.h) * 0.35;
        
        // 파이 조각 그리기
        double startAngle = 0;
        
        for (const auto& point : data) {
            double angle = 2 * Math::Pi * (point.y / total);
            
            // 파이 조각
            Ellipse(center, radius, radius).drawPie(startAngle, angle, point.color);
            
            // 파이 조각 중앙 방향 계산
            double midAngle = startAngle + angle / 2;
            Vec2 direction(std::cos(midAngle), std::sin(midAngle));
            Vec2 labelPos = center + direction * (radius * 1.2);
            
            // 라벨 표시
            m_valueFont(U"{}: {:.1f} ({:.1f}%)"_fmt(point.label, point.y, (point.y / total) * 100))
                .draw(labelPos.x, labelPos.y, Palette::Black);
            
            startAngle += angle;
        }
    }
};

// 시각화 앱 클래스
class VisualizationApp {
private:
    DataManager m_dataManager;
    std::unique_ptr<Chart> m_currentChart;
    ChartType m_chartType;
    Array<String> m_chartTypeNames;
    Rect m_chartArea;
    Font m_uiFont;
    TextEditState m_csvPathState;
    
    void createChart() {
        switch (m_chartType) {
        case ChartType::LineChart:
            m_currentChart = std::make_unique<LineChart>(m_dataManager, m_chartArea);
            break;
        case ChartType::BarChart:
            m_currentChart = std::make_unique<BarChart>(m_dataManager, m_chartArea);
            break;
        case ChartType::ScatterPlot:
            m_currentChart = std::make_unique<ScatterPlot>(m_dataManager, m_chartArea);
            break;
        case ChartType::PieChart:
            m_currentChart = std::make_unique<PieChart>(m_dataManager, m_chartArea);
            break;
        }
    }
    
public:
    VisualizationApp()
        : m_chartType(ChartType::LineChart),
          m_chartTypeNames{U"선 그래프", U"막대 그래프", U"산점도", U"원 그래프"},
          m_chartArea(50, 50, 700, 500),
          m_uiFont(18, Typeface::Medium) {
        
        m_csvPathState.text = U"sample/data.csv";
    }
    
    void update() {
        // 차트 유형 선택 버튼
        for (int i = 0; i < 4; ++i) {
            Rect button(50 + i * 180, 570, 170, 40);
            
            if (button.draw(i == static_cast<int>(m_chartType) ?
                           Palette::Orange : Palette::White).clickedLeft()) {
                m_chartType = static_cast<ChartType>(i);
                createChart();
            }
            
            m_uiFont(m_chartTypeNames[i]).drawAt(button.center(), Palette::Black);
        }
        
        // CSV 파일 로드 UI
        Rect csvPathBox(50, 620, 500, 40);
        SimpleGUI::TextBox(m_csvPathState, csvPathBox);
        
        Rect loadButton(560, 620, 100, 40);
        if (loadButton.draw(Palette::Blue).clickedLeft()) {
            if (m_dataManager.loadFromCSV(m_csvPathState.text)) {
                createChart();
            }
        }
        m_uiFont(U"불러오기").drawAt(loadButton.center(), Palette::White);
        
        Rect browseButton(670, 620, 80, 40);
        if (browseButton.draw(Palette::Green).clickedLeft()) {
            if (auto path = Dialog::OpenFile({FileFilter::CSV()})) {
                m_csvPathState.text = *path;
                if (m_dataManager.loadFromCSV(m_csvPathState.text)) {
                    createChart();
                }
            }
        }
        m_uiFont(U"찾기").drawAt(browseButton.center(), Palette::White);
    }
    
    void draw() const {
        // 배경
        Scene::SetBackground(ColorF(0.95));
        
        // 차트 영역
        m_chartArea.drawFrame(2, Palette::Gray);
        
        // 차트 그리기
        if (m_currentChart) {
            m_currentChart->draw();
        } else {
            m_uiFont(U"데이터를 불러와 시각화하세요.").drawAt(m_chartArea.center(), Palette::Gray);
        }
    }
};

// 메인 함수
void Main() {
    // 창 설정
    Window::SetTitle(U"데이터 시각화 도구");
    Window::Resize(800, 680);
    
    // 앱 객체 생성
    VisualizationApp app;
    
    while (System::Update()) {
        app.update();
        app.draw();
    }
}
```

이 프로젝트에서 활용한 주요 C++ 개념들:

1. **템플릿 및 다형성**: 다양한 차트 유형을 상속과 다형성으로 구현했다.
2. **스마트 포인터**: `std::unique_ptr`로 차트 객체를 관리한다.
3. **공통 인터페이스**: 모든 차트 클래스는 동일한 인터페이스를 제공한다.
4. **사용자 정의 자료형**: `struct DataPoint`로 데이터 포인트를 표현한다.
5. **열거형**: `ChartType`으로 차트 유형을 정의했다.
6. **파일 I/O**: CSV 파일을 읽어와 데이터로 변환한다.
7. **예외 처리**: 파일 로딩 시 예외를 적절히 처리한다.
  



## 10.6 인터랙티브 멀티미디어 애플리케이션
마지막 프로젝트로, 다양한 미디어 요소(비디오, 오디오, 이미지)를 다루는 인터랙티브 애플리케이션을 만들어 보자.

```cpp
#include <Siv3D.hpp>
#include <memory>
#include <vector>
#include <variant>
#include <functional>

// 미디어 타입 열거형
enum class MediaType {
    Image,
    Audio,
    Video,
    Text
};

// 미디어 항목 기본 클래스
class MediaItem {
protected:
    String m_name;
    String m_path;
    Rect m_rect;
    bool m_isSelected;
    
public:
    MediaItem(const String& name, const String& path, const Rect& rect)
        : m_name(name), m_path(path), m_rect(rect), m_isSelected(false) {}
    
    virtual ~MediaItem() = default;
    virtual void update() = 0;
    virtual void draw() const = 0;
    virtual MediaType getType() const = 0;
    
    const String& getName() const { return m_name; }
    const String& getPath() const { return m_path; }
    const Rect& getRect() const { return m_rect; }
    
    bool isSelected() const { return m_isSelected; }
    void setSelected(bool selected) { m_isSelected = selected; }
    
    bool contains(const Vec2& pos) const {
        return m_rect.contains(pos);
    }
};

// 이미지 미디어 항목
class ImageItem : public MediaItem {
private:
    Texture m_texture;
    double m_scale;
    bool m_isLoaded;
    
public:
    ImageItem(const String& name, const String& path, const Rect& rect)
        : MediaItem(name, path, rect), m_scale(1.0), m_isLoaded(false) {
        try {
            m_texture = Texture(path);
            m_isLoaded = true;
        } catch (const Error& error) {
            Print << U"이미지 로딩 오류: " << error.what();
        }
    }
    
    void update() override {
        if (m_isSelected && MouseWheel::Rotation()) {
            m_scale += MouseWheel::Rotation() * 0.1;
            m_scale = Clamp(m_scale, 0.5, 3.0);
        }
    }
    
    void draw() const override {
        // 항목 배경
        m_rect.draw(m_isSelected ? ColorF(0.7, 0.9, 1.0) : ColorF(0.9));
        
        // 이미지 그리기
        if (m_isLoaded) {
            const Vec2 center = m_rect.center();
            const double aspectRatio = static_cast<double>(m_texture.width()) / m_texture.height();
            
            const double drawWidth = std::min(m_rect.w - 20, (m_rect.h - 20) * aspectRatio) * m_scale;
            const double drawHeight = drawWidth / aspectRatio;
            
            m_texture.resized(drawWidth, drawHeight).drawAt(center);
        } else {
            // 로딩 실패 표시
            FontAsset(U"Default")(U"이미지 로딩 실패").drawAt(m_rect.center(), Palette::Red);
        }
        
        // 테두리 및 이름
        m_rect.drawFrame(2, m_isSelected ? Palette::Orange : Palette::Gray);
        FontAsset(U"Default")(m_name).draw(m_rect.x + 10, m_rect.y + 10, Palette::Black);
    }
    
    MediaType getType() const override { return MediaType::Image; }
};

// 오디오 미디어 항목
class AudioItem : public MediaItem {
private:
    Audio m_audio;
    bool m_isLoaded;
    bool m_isPlaying;
    FFT m_fft;
    
public:
    AudioItem(const String& name, const String& path, const Rect& rect)
        : MediaItem(name, path, rect), m_isLoaded(false), m_isPlaying(false), m_fft(FFTSampleLength::Medium) {
        try {
            m_audio = Audio(path);
            m_isLoaded = true;
        } catch (const Error& error) {
            Print << U"오디오 로딩 오류: " << error.what();
        }
    }
    
    ~AudioItem() {
        if (m_isPlaying) {
            m_audio.stop();
        }
    }
    
    void update() override {
        if (m_isSelected && MouseL.down() && m_isLoaded) {
            if (m_isPlaying) {
                m_audio.pause();
                m_isPlaying = false;
            } else {
                m_audio.play();
                m_isPlaying = true;
            }
        }
        
        // FFT 분석
        if (m_isPlaying) {
            m_fft.update(m_audio);
        }
    }
    
    void draw() const override {
        // 항목 배경
        m_rect.draw(m_isSelected ? ColorF(0.7, 0.9, 1.0) : ColorF(0.9));
        
        // 오디오 시각화
        if (m_isLoaded) {
            // 재생 상태
            const String statusText = m_isPlaying ? U"■ 재생 중" : U"▶ 일시 정지됨";
            FontAsset(U"Default")(statusText)
                .draw(m_rect.x + 10, m_rect.center().y, m_isPlaying ? Palette::Red : Palette::Black);
            
            // 재생 시간
            const double duration = m_audio.lengthSec();
            const double currentTime = m_audio.posSec();
            FontAsset(U"Default")(U"{:0>2}:{:0>2} / {:0>2}:{:0>2}"_fmt(
                static_cast<int>(currentTime) / 60, static_cast<int>(currentTime) % 60,
                static_cast<int>(duration) / 60, static_cast<int>(duration) % 60
            )).draw(m_rect.x + 10, m_rect.center().y + 30, Palette::Black);
            
            // 오디오 파형 또는 FFT 시각화
            if (m_isPlaying) {
                const double barWidth = (m_rect.w - 20) / 30;
                for (int i = 0; i < 30; ++i) {
                    const double height = m_fft.buffer[i / 30.0 * m_fft.buffer.size()] * 100;
                    RectF(m_rect.x + 10 + i * barWidth, m_rect.y + m_rect.h - 20 - height,
                        barWidth * 0.8, height).draw(ColorF(0.2, 0.7, 0.9, 0.8));
                }
            }
        } else {
            // 로딩 실패 표시
            FontAsset(U"Default")(U"오디오 로딩 실패").drawAt(m_rect.center(), Palette::Red);
        }
        
        // 테두리 및 이름
        m_rect.drawFrame(2, m_isSelected ? Palette::Orange : Palette::Gray);
        FontAsset(U"Default")(m_name).draw(m_rect.x + 10, m_rect.y + 10, Palette::Black);
    }
    
    MediaType getType() const override { return MediaType::Audio; }
};

// 비디오 미디어 항목
class VideoItem : public MediaItem {
private:
    VideoTexture m_video;
    bool m_isLoaded;
    bool m_isPlaying;
    
public:
    VideoItem(const String& name, const String& path, const Rect& rect)
        : MediaItem(name, path, rect), m_isLoaded(false), m_isPlaying(false) {
        try {
            m_video = VideoTexture(path);
            m_isLoaded = true;
        } catch (const Error& error) {
            Print << U"비디오 로딩 오류: " << error.what();
        }
    }
    
    ~VideoItem() {
        if (m_isPlaying) {
            m_video.pause();
        }
    }
    
    void update() override {
        if (m_isSelected && MouseL.down() && m_isLoaded) {
            if (m_isPlaying) {
                m_video.pause();
                m_isPlaying = false;
            } else {
                m_video.play();
                m_isPlaying = true;
            }
        }
    }
    
    void draw() const override {
        // 항목 배경
        m_rect.draw(m_isSelected ? ColorF(0.7, 0.9, 1.0) : ColorF(0.9));
        
        // 비디오 그리기
        if (m_isLoaded) {
            const Vec2 center = m_rect.center();
            const double aspectRatio = static_cast<double>(m_video.getSize().x) / m_video.getSize().y;
            
            const double drawWidth = std::min(m_rect.w - 20, (m_rect.h - 60) * aspectRatio);
            const double drawHeight = drawWidth / aspectRatio;
            
            m_video.scaled(drawWidth / m_video.getSize().x).drawAt(center.movedBy(0, -15));
            
            // 재생 상태
            const String statusText = m_isPlaying ? U"■ 재생 중" : U"▶ 일시 정지됨";
            FontAsset(U"Default")(statusText)
                .draw(m_rect.x + 10, m_rect.y + m_rect.h - 30, m_isPlaying ? Palette::Red : Palette::Black);
        } else {
            // 로딩 실패 표시
            FontAsset(U"Default")(U"비디오 로딩 실패").drawAt(m_rect.center(), Palette::Red);
        }
        
        // 테두리 및 이름
        m_rect.drawFrame(2, m_isSelected ? Palette::Orange : Palette::Gray);
        FontAsset(U"Default")(m_name).draw(m_rect.x + 10, m_rect.y + 10, Palette::Black);
    }
    
    MediaType getType() const override { return MediaType::Video; }
};

// 텍스트 미디어 항목
class TextItem : public MediaItem {
private:
    String m_content;
    bool m_isLoaded;
    TextEditState m_textEdit;
    
public:
    TextItem(const String& name, const String& path, const Rect& rect)
        : MediaItem(name, path, rect), m_isLoaded(false) {
        try {
            TextReader reader(path);
            if (reader) {
                m_content = reader.readAll();
                m_textEdit.text = m_content;
                m_isLoaded = true;
            }
        } catch (const Error& error) {
            Print << U"텍스트 로딩 오류: " << error.what();
        }
    }
    
    void update() override {
        if (m_isSelected && m_isLoaded) {
            // 텍스트 편집
            SimpleGUI::TextArea(m_textEdit, m_rect.stretched(-10));
            
            // 저장
            if (KeyS.down() && KeyControl.pressed()) {
                saveText();
            }
        }
    }
    
    void draw() const override {
        // 항목 배경
        m_rect.draw(m_isSelected ? ColorF(0.7, 0.9, 1.0) : ColorF(0.9));
        
        if (m_isLoaded) {
            if (m_isSelected) {
                // TextArea가 그려짐 (update에서 처리)
            } else {
                // 텍스트 미리보기
                FontAsset(U"Default")(m_content.substr(0, 100) + (m_content.length() > 100 ? U"..." : U""))
                    .draw(m_rect.stretched(-10), Palette::Black);
            }
        } else {
            // 로딩 실패 표시
            FontAsset(U"Default")(U"텍스트 로딩 실패").drawAt(m_rect.center(), Palette::Red);
        }
        
        // 테두리 및 이름
        m_rect.drawFrame(2, m_isSelected ? Palette::Orange : Palette::Gray);
        FontAsset(U"Default")(m_name).draw(m_rect.x + 10, m_rect.y + 10, Palette::Black);
        
        if (m_isSelected && m_isLoaded) {
            FontAsset(U"Default")(U"Ctrl+S로 저장").draw(m_rect.x + 10, m_rect.y + 40, Palette::Black);
        }
    }
    
    MediaType getType() const override { return MediaType::Text; }
    
private:
    void saveText() {
        TextWriter writer(m_path);
        if (writer) {
            writer.write(m_textEdit.text);
            Print << U"파일을 저장했습니다: " << m_path;
        } else {
            Print << U"파일 저장 실패: " << m_path;
        }
    }
};

// 미디어 갤러리 클래스
class MediaGallery {
private:
    std::vector<std::shared_ptr<MediaItem>> m_items;
    Font m_titleFont;
    Font m_buttonFont;
    Optional<size_t> m_selectedIndex;
    
    struct MediaTemplate {
        String label;
        MediaType type;
        Array<FileFilter> filters;
    };
    
    Array<MediaTemplate> m_templates;
    
public:
    MediaGallery()
        : m_titleFont(28, Typeface::Bold),
          m_buttonFont(18, Typeface::Medium) {
        
        // 폰트 에셋 등록
        FontAsset::Register(U"Default", 16, Typeface::Regular);
        
        // 미디어 템플릿 초기화
        m_templates = {
            { U"이미지", MediaType::Image, { FileFilter::AllImageFiles() } },
            { U"오디오", MediaType::Audio, { FileFilter::AllAudioFiles() } },
            { U"비디오", MediaType::Video, { FileFilter::Video() } },
            { U"텍스트", MediaType::Text, { FileFilter::Text(), FileFilter::Source() } }
        };
    }
    
    void update() {
        // 아이템 업데이트
        for (auto& item : m_items) {
            item->update();
        }
        
        // 마우스 클릭으로 아이템 선택
        if (MouseL.down()) {
            bool itemSelected = false;
            
            for (size_t i = 0; i < m_items.size(); ++i) {
                if (m_items[i]->contains(Cursor::Pos())) {
                    selectItem(i);
                    itemSelected = true;
                    break;
                }
            }
            
            if (!itemSelected && m_selectedIndex) {
                deselectItem();
            }
        }
        
        // 키보드 단축키
        if (KeyDelete.down() && m_selectedIndex) {
            removeSelectedItem();
        }
    }
    
    void draw() const {
        // 타이틀
        m_titleFont(U"멀티미디어 갤러리").drawAt(400, 30, Palette::Black);
        
        // 아이템 그리기
        for (const auto& item : m_items) {
            item->draw();
        }
        
        // 추가 버튼들
        for (int i = 0; i < m_templates.size(); ++i) {
            Rect button(50 + i * 180, 620, 170, 40);
            
            if (button.draw(Palette::Blue).clickedLeft()) {
                addMediaItem(m_templates[i].type);
            }
            
            m_buttonFont(U"{} 추가"_fmt(m_templates[i].label)).drawAt(button.center(), Palette::White);
        }
        
        // 삭제 버튼
        Rect deleteButton(650, 620, 100, 40);
        if (m_selectedIndex) {
            if (deleteButton.draw(Palette::Red).clickedLeft()) {
                removeSelectedItem();
            }
            m_buttonFont(U"삭제").drawAt(deleteButton.center(), Palette::White);
        } else {
            deleteButton.draw(ColorF(0.7));
            m_buttonFont(U"삭제").drawAt(deleteButton.center(), ColorF(0.8));
        }
    }
    
private:
    void addMediaItem(MediaType type) {
        Optional<FilePath> path;
        String name;
        
        // 파일 대화상자로 파일 선택
        for (const auto& tmpl : m_templates) {
            if (tmpl.type == type) {
                path = Dialog::OpenFile(tmpl.filters);
                break;
            }
        }
        
        if (!path) return;
        
        // 파일 이름 추출
        name = FileSystem::FileName(*path);
        
        // 항목 배치 위치 계산
        const int itemsPerRow = 2;
        const int itemWidth = 370;
        const int itemHeight = 280;
        const int itemCount = static_cast<int>(m_items.size());
        
        const int row = itemCount / itemsPerRow;
        const int col = itemCount % itemsPerRow;
        
        Rect rect(30 + col * (itemWidth + 10), 70 + row * (itemHeight + 10), itemWidth, itemHeight);
        
        // 새 미디어 항목 생성
        std::shared_ptr<MediaItem> newItem;
        
        switch (type) {
        case MediaType::Image:
            newItem = std::make_shared<ImageItem>(name, *path, rect);
            break;
        case MediaType::Audio:
            newItem = std::make_shared<AudioItem>(name, *path, rect);
            break;
        case MediaType::Video:
            newItem = std::make_shared<VideoItem>(name, *path, rect);
            break;
        case MediaType::Text:
            newItem = std::make_shared<TextItem>(name, *path, rect);
            break;
        }
        
        // 새 항목 추가 및 선택
        if (newItem) {
            m_items.push_back(newItem);
            selectItem(m_items.size() - 1);
        }
    }
    
    void selectItem(size_t index) {
        if (m_selectedIndex) {
            m_items[*m_selectedIndex]->setSelected(false);
        }
        
        m_selectedIndex = index;
        m_items[index]->setSelected(true);
    }
    
    void deselectItem() {
        if (m_selectedIndex) {
            m_items[*m_selectedIndex]->setSelected(false);
            m_selectedIndex = none;
        }
    }
    
    void removeSelectedItem() {
        if (m_selectedIndex) {
            m_items.erase(m_items.begin() + *m_selectedIndex);
            m_selectedIndex = none;
        }
    }
};

// 메인 함수
void Main() {
    // 창 설정
    Window::SetTitle(U"멀티미디어 갤러리");
    Window::Resize(800, 680);
    
    // 미디어 갤러리 생성
    MediaGallery gallery;
    
    while (System::Update()) {
        gallery.update();
        gallery.draw();
    }
}
```

이 프로젝트에서 활용한 주요 C++ 개념들:

1. **상속과 다형성**: 다양한 미디어 유형을 하나의 인터페이스로 처리한다.
2. **스마트 포인터**: `std::shared_ptr`로 미디어 항목들을 관리한다.
3. **RAII 패턴**: 리소스의 생성과 소멸을 객체의 수명에 연결한다.
4. **템플릿 메타프로그래밍**: 데이터 구조와 알고리즘 처리에 활용한다.
5. **함수형 프로그래밍**: 람다와 함수 객체를 사용한다.
6. **예외 처리**: 파일 로딩과 처리 오류를 잡아낸다.
7. **다양한 STL 활용**: 컨테이너, 알고리즘 등을 활용한다.
  



## 10.7 최종 정리
이번 단계에서는 C++의 다양한 개념들을 실제 프로젝트에 적용해 보았다. 이 프로젝트들은 여러분의 학습 여정의 종착점이 아닌, 새로운 출발점이 될 것이다. 다음은 앞으로의 학습 방향에 대한 제안이다:  

### 더 배워볼 주제
1. **멀티스레딩**: C++20의 `std::jthread`와 병렬 알고리즘을 활용한 고성능 애플리케이션 개발
2. **네트워크 프로그래밍**: 온라인 기능이 있는 게임이나 애플리케이션 만들기
3. **디자인 패턴**: 더 확장 가능하고 유지보수가 쉬운 코드 구조 만들기
4. **C++23의 신기능**: `std::ranges`, `std::format` 등의 최신 기능 활용하기
5. **게임 엔진 개발**: 자신만의 작은 게임 엔진 만들기
  

### 프로젝트 아이디어
1. **자신만의 게임 개발**: 간단한 턴제 RPG, 퍼즐 게임, 액션 게임 등
2. **시뮬레이션 프로그램**: 물리, 화학, 생물학 등의 현상을 시뮬레이션
3. **데이터 분석 도구**: 빅데이터 시각화 및 분석 도구
4. **창작 도구**: 디지털 아트, 음악 작곡, 스토리텔링 등의 도구
5. **유틸리티 애플리케이션**: 일상 생활이나 업무에 도움이 되는 도구
  

### 마무리
C++와 Siv3D를 활용한 프로그래밍 여정에서 중요한 것은 계속해서 만들고, 배우고, 개선하는 것이다. 처음부터 완벽한 코드를 작성하는 것은 불가능하다. 오류를 만나고, 그것을 해결하며 성장하는 과정이 진정한 프로그래밍 학습이다.

이제 여러분은 C++의 기본과 다양한 고급 기능들을 배웠다. 이를 토대로 자신만의 창의적인 프로젝트를 시작해 보자. 프로그래밍의 진정한 즐거움은 자신의 아이디어를 코드로 표현하고, 그것이 실제로 동작하는 것을 보는 순간에 있다.

행운을 빈다! 여러분의 C++ 프로그래밍 여정이 즐겁고 보람차기를 바란다.

