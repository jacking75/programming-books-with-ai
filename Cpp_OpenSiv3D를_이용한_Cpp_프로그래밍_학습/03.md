# OpenSiv3D를 이용한 C++ 프로그래밍 학습
  
저자: 최흥배, Claude AI  
  
C++ 프로그래밍 언어를 배우는 것에 중점을 두되, Siv3D 프레임워크를 활용하여 시각적으로 흥미로운 예제를 통해 학습 효과를 높이도록 설계 되었다. 단순한 콘솔 프로그램 대신 그래픽, 소리, 상호작용을 포함한 프로그램을 만들며 C++의 개념을 익힐 수 있다.  
  
필요 소프트웨어:  
- Windows 10 이상
- Visual Studio 2022 이상   
  
-----    
    
# Chapter.03: 함수와 모듈화
    
## 3.1 함수 선언과 정의

### 함수의 기본 개념
함수는 특정 작업을 수행하는 코드 블록으로, 프로그램에서 재사용 가능한 단위이다. 함수를 사용하면 코드를 논리적으로 분리하고, 중복을 줄이며, 유지보수를 쉽게 할 수 있다.

### 함수 선언 구문
C++에서 함수 선언은 다음과 같은 형식을 갖는다:

```cpp
반환타입 함수이름(매개변수목록);
```

예를 들면:
```cpp
int add(int a, int b);  // 함수 선언 (프로토타입)
```

### 함수 정의
함수 정의는 함수의 실제 구현을 포함한다:

```cpp
반환타입 함수이름(매개변수목록) {
    // 함수 본문
    return 반환값;  // 반환 타입이 void가 아닌 경우
}
```

예를 들면:
```cpp
int add(int a, int b) {  // 함수 정의
    return a + b;
}
```

### 반환 타입과 void
함수는 특정 타입의 값을 반환하거나, 아무것도 반환하지 않을 수 있다. 값을 반환하지 않는 함수의 반환 타입은 `void` 이다.  

```cpp
void printMessage(const std::string& message) {
    std::cout << message << std::endl;
    // 반환값 없음
}
```

### C++23의 함수 관련 새 기능
C++23에서는 `if consteval` 구문이 추가되었다. 이는 컴파일 타임에 함수가 상수 평가되는지 확인할 수 있게 해준다.

```cpp
constexpr int getValue() {
    if consteval {
        return 100;  // 컴파일 타임에 호출될 때 실행
    } else {
        return 200;  // 런타임에 호출될 때 실행
    }
}
```
  

## 3.2 매개변수 전달 방식
C++에서는 함수에 인자를 전달하는 여러 방식이 있다:

### 값에 의한 전달 (Pass by value)
매개변수로 값의 복사본이 전달된다. 함수 내에서 매개변수를 변경해도 원본은 영향을 받지 않다.

```cpp
void doubleValue(int num) {
    num *= 2;  // 복사본만 변경됨
}

int main() {
    int x = 5;
    doubleValue(x);
    // x는 여전히 5
}
```

### 참조에 의한 전달 (Pass by reference)
매개변수로 원본 값에 대한 참조가 전달된다. 함수 내에서 매개변수를 변경하면 원본도 변경된다.  
  
```cpp
void doubleValue(int& num) {
    num *= 2;  // 원본이 변경됨
}

int main() {
    int x = 5;
    doubleValue(x);
    // x는 이제 10
}
```

### 포인터에 의한 전달 (Pass by pointer)
매개변수로 값의 메모리 주소가 전달된다. 함수 내에서 해당 주소의 값을 변경할 수 있다.

```cpp
void doubleValue(int* num) {
    *num *= 2;  // 원본이 변경됨
}

int main() {
    int x = 5;
    doubleValue(&x);
    // x는 이제 10
}
```

### const 참조
값을 변경하지 않고 효율적으로 전달할 때 사용한다. 특히 큰 객체를 복사 없이 전달할 때 유용하다.

```cpp
void printValue(const int& num) {
    // num = 100;  // 컴파일 오류: const 참조는 수정할 수 없음
    std::cout << num << std::endl;
}
```

### C++23의 auto 매개변수
C++23에서는 함수 매개변수에 `auto`를 사용할 수 있어 템플릿 같은 유연성을 간단하게 얻을 수 있다.

```cpp
void printAny(const auto& value) {
    std::cout << value << std::endl;
}
```
  

## 3.3 함수 오버로딩

### 함수 오버로딩의 개념
함수 오버로딩은 같은 이름의 함수를 매개변수 목록을 다르게 하여 여러 개 정의하는 기능이다. 컴파일러는 함수 호출 시 전달된 인자의 타입과 개수를 기준으로 적절한 함수를 선택한다.

### 오버로딩 규칙
함수 오버로딩이 가능한 경우:  
- 매개변수의 개수가 다른 경우
- 매개변수의 타입이 다른 경우
- 매개변수의 순서가 다른 경우

### 반환 타입만 다른 경우 오버로딩 불가
반환 타입만 다르고 매개변수가 동일한 함수는 오버로딩할 수 없다.

```cpp
int getValue();
double getValue();  // 오류: 반환 타입만 다른 오버로딩은 불가능
```

### 함수 오버로딩 예시

```cpp
void draw(int x, int y) {
    std::cout << "정수 좌표로 그립니다: (" << x << ", " << y << ")" << std::endl;
}

void draw(double x, double y) {
    std::cout << "실수 좌표로 그립니다: (" << x << ", " << y << ")" << std::endl;
}

void draw(const std::string& shape) {
    std::cout << shape << "을(를) 그립니다." << std::endl;
}

int main() {
    draw(10, 20);         // "정수 좌표로 그립니다: (10, 20)" 출력
    draw(15.5, 32.7);     // "실수 좌표로 그립니다: (15.5, 32.7)" 출력
    draw("원");           // "원을(를) 그립니다." 출력
}
```
  

## 3.4 기본 매개변수

### 기본 매개변수 정의
함수의 매개변수에 기본값을 지정할 수 있다. 함수 호출 시 해당 인자를 생략하면 기본값이 사용된다.

```cpp
void setVolume(int level = 50) {
    std::cout << "볼륨을 " << level << "으로 설정했습니다." << std::endl;
}

int main() {
    setVolume();     // "볼륨을 50으로 설정했습니다." 출력
    setVolume(75);   // "볼륨을 75으로 설정했습니다." 출력
}
```

### 기본 매개변수 사용 시 주의사항
- 기본 매개변수는 함수 선언 또는 정의 중 한 곳에만 지정해야 한다 (일반적으로 선언에 지정).
- 기본 매개변수는 오른쪽부터 지정해야 한다. 중간에 있는 매개변수만 기본값을 가질 수 없다.

```cpp
// 올바른 예
void configure(int id, std::string name = "기본이름", bool active = true);

// 잘못된 예 (컴파일 오류)
void configure(int id = 1, std::string name, bool active = true);
```

### 여러 개의 기본 매개변수
여러 매개변수에 기본값을 지정할 수 있다:

```cpp
void createProfile(const std::string& name, int age = 20, const std::string& country = "한국") {
    std::cout << "이름: " << name << ", 나이: " << age << ", 국가: " << country << std::endl;
}

int main() {
    createProfile("홍길동");                     // "이름: 홍길동, 나이: 20, 국가: 한국" 출력
    createProfile("김철수", 25);                 // "이름: 김철수, 나이: 25, 국가: 한국" 출력
    createProfile("이영희", 30, "일본");         // "이름: 이영희, 나이: 30, 국가: 일본" 출력
}
```
  
-----  
    
## 3.5 Siv3D 활용 예제: 다양한 도형 그리기
이제 앞서 배운 함수 개념들을 Siv3D를 활용하여 실습해 보겠다. 다양한 도형을 그리는 함수들을 만들고 활용해 보겠다.

```cpp
#include <Siv3D.hpp>

// 원 그리기 - 매개변수 1개 (위치만)
void drawCircle(const Vec2& pos) {
	Circle(pos, 50).draw(ColorF(1.0, 0.0, 0.0)); // 빨간색 기본 원
}

// 원 그리기 - 매개변수 2개 (위치 + 크기)
void drawCircle(const Vec2& pos, double size) {
	Circle(pos, size).draw(ColorF(0.0, 1.0, 0.0)); // 초록색 크기 지정 원
}

// 원 그리기 - 매개변수 3개 (위치 + 크기 + 색상)
void drawCircle(const Vec2& pos, double size, const ColorF& color) {
	Circle(pos, size).draw(color); // 모든 것을 지정한 원
}

void Main()
{
	Scene::SetBackground(ColorF(0.2, 0.2, 0.2));

	const Font font{ FontMethod::SDF, 24, Typeface::CJK_Regular_KR };

	while (System::Update()) {

		font(U"함수 오버로딩 예제").drawAt(400, 50, ColorF(1.0, 1.0, 0.0));

		// 1. 위치만 지정 (기본 크기, 기본 색상)
		font(U"1. 위치만 지정").draw(50, 120, ColorF(0.8));
		drawCircle(Vec2(150, 200));

		// 2. 위치와 크기 지정 (기본 색상)
		font(U"2. 위치 + 크기 지정").draw(50, 250, ColorF(0.8));
		drawCircle(Vec2(150, 310), 30);

		// 3. 위치, 크기, 색상 모두 지정
		font(U"3. 위치 + 크기 + 색상 지정").draw(50, 380, ColorF(0.8));
		drawCircle(Vec2(150, 450), 40, ColorF(0.0, 0.5, 1.0));

		// 마우스 위치에 따라 다른 함수 호출
		font(U"마우스를 움직여보세요!").draw(450, 120, ColorF(0.8));

		Vec2 mousePos = Cursor::Pos();
		if (mousePos.x > 600) {
			drawCircle(Vec2(600, 200), 25, ColorF(1.0, 0.5, 1.0));
			font(U"3개 매개변수").draw(520, 250, ColorF(0.7));
		}
		else if (mousePos.x > 500) {
			drawCircle(Vec2(600, 200), 35);
			font(U"2개 매개변수").draw(520, 250, ColorF(0.7));
		}
		else {
			drawCircle(Vec2(600, 200));
			font(U"1개 매개변수").draw(520, 250, ColorF(0.7));
		}
	}
}

```

### 코드 설명
이 간단한 예제는 다음을 보여준다:
  
함수 오버로딩의 핵심 개념:
- 같은 이름의 함수 drawCircle이 3개 있다
- 각각 매개변수의 개수가 다르다 (1개, 2개, 3개)
- 컴파일러가 호출할 때 넘겨주는 매개변수에 따라 자동으로 적절한 함수를 선택한다
  
시각적으로 확인할 수 있는 부분:  
- 왼쪽에는 각각 다른 매개변수로 호출한 원들이 고정으로 표시된다
- 오른쪽에는 마우스 위치에 따라 다른 오버로딩된 함수가 호출되어 실시간으로 변화하는 원을 볼 수 있다.
  

## 3.6 Siv3D 활용 예제: 애니메이션 효과
이번 예제는 함수를 활용하여 다양한 애니메이션 효과를 구현한다.

```cpp
#include <Siv3D.hpp>

// 색상 전환 효과를 계산하는 함수 (값에 의한 전달)
ColorF pulseColor(double time, double speed = 1.0) {
	double t = Periodic::Sine0_1(time * speed);
	return ColorF(1.0, 0.4 + 0.6 * t, 0.4 + 0.6 * t);
}

// 크기 변화 효과를 계산하는 함수 (참조에 의한 전달)
void calculateSize(double time, double baseSize, double& width, double& height) {
	double t = Periodic::Sine0_1(time * 2);
	width = baseSize * (0.8 + 0.2 * t);
	height = baseSize * (1.2 - 0.2 * t);
}

// 진동 효과를 가진 텍스트를 그리는 함수 (오버로딩 예시)
void drawShakingText(const Font& font, const String& text, const Vec2& pos, double time) {
	// 기본 컬러
	double shake = Math::Sin(time * 10) * 2.0;
	font(text).draw(pos.movedBy(shake, 0), ColorF(1.0));
}

// 색상 효과가 추가된 버전 (오버로딩 예시)
void drawShakingText(const Font& font, const String& text, const Vec2& pos, double time, const ColorF& color) {
	double shake = Math::Sin(time * 10) * 2.0;
	font(text).draw(pos.movedBy(shake, 0), color);
}

void Main()
{
	Scene::SetBackground(ColorF(0.1, 0.1, 0.1));

	// 폰트 생성
	const Font font{ FontMethod::SDF, 30, Typeface::CJK_Regular_KR };

	while (System::Update()) {
		const double time = Scene::Time();

		// 깜빡이는 색상 효과
		ColorF color = pulseColor(time);

		// 크기가 변하는 사각형
		double width, height;
		calculateSize(time, 100, width, height);
		RectF(Arg::center(Scene::Center()), width, height).draw(color);

		// 진동 효과를 가진 텍스트 그리기 (오버로딩된 함수 사용)
		drawShakingText(font, U"함수와 애니메이션", Vec2(250, 100), time);
		drawShakingText(font, U"오버로딩 예제", Vec2(280, 500), time, HSV(time * 30));

		// 함수를 조합하여 복잡한 애니메이션 만들기
		for (int i = 0; i < 8; ++i) {
			// 원형으로 배치된 회전하는 도형들
			double angle = time + i * Math::TwoPi / 8;
			Vec2 pos(400 + Math::Cos(angle) * 150, 300 + Math::Sin(angle) * 150);

			// HSV 색상 모델로 무지개 색상 생성
			ColorF circleColor = HSV(i * 45 + time * 30, 0.8, 1.0);

			Circle(pos, 15 + Math::Sin(time * 3 + i) * 5).draw(circleColor);
		}
	}
}
```

### 코드 설명
- `pulseColor()` 함수는 값에 의한 전달 방식을 사용하여 시간에 따라 변하는 색상을 계산한다.
- `calculateSize()` 함수는 참조에 의한 전달을 사용하여 너비와 높이 값을 직접 수정한다.
- `drawShakingText()` 함수는 오버로딩을 통해 두 가지 버전으로 정의되었다.
- 하단 부분에서는 함수들을 조합하여 복잡한 애니메이션 효과를 구현했다.
  

## 3.7 Siv3D 활용 예제: 버튼 클릭 게임
마지막 예제는 함수를 활용한 모듈화를 보여주는 간단한 버튼 클릭 게임이다.

```cpp
#include <Siv3D.hpp>

// 버튼 구조체 정의
struct Button {
    RectF rect;
    ColorF color;
    String label;
    int value;
    bool clicked;
};

// 버튼 생성 함수 (기본 매개변수 활용)
Button createButton(const Vec2& pos, double width, double height, int value, 
                  const String& label = U"", const ColorF& color = ColorF(0.4, 0.4, 0.8, 0.9)) {
    return Button{ RectF(pos, width, height), color, label, value, false };
}

// 버튼 그리기 함수 (const 참조 활용)
void drawButton(const Button& button, const Font& font) {
    // 클릭 여부에 따라 색상 변경
    ColorF drawColor = button.clicked ? button.color.gamma(0.7) : button.color;
    
    button.rect.draw(drawColor);
    button.rect.drawFrame(2, ColorF(0.9));
    font(button.label).drawAt(button.rect.center(), ColorF(0.9));
}

// 버튼 업데이트 함수 (참조에 의한 전달)
bool updateButton(Button& button) {
    if (button.rect.leftClicked()) {
        button.clicked = true;
        return true;
    }
    return false;
}

// 점수 표시 함수 (기본 매개변수)
void displayScore(const Font& font, int score, const Vec2& pos = Vec2(20, 20)) {
    font(U"점수: {}"_fmt(score)).draw(pos, ColorF(1.0));
}

// 게임 타이머 표시 함수
void displayTimer(const Font& font, double startTime, double duration, const Vec2& pos) {
    double remainingTime = duration - (Scene::Time() - startTime);
    if (remainingTime < 0) remainingTime = 0;
    
    font(U"남은 시간: {:.1f}"_fmt(remainingTime)).draw(pos, 
        remainingTime < 5 ? ColorF(1.0, 0.1, 0.1) : ColorF(1.0));
}

// 게임 결과 표시 함수 (오버로딩)
void displayResult(const Font& font, int score) {
    font(U"게임 종료! 최종 점수: {}"_fmt(score)).drawAt(Scene::Center(), ColorF(1.0));
}

// 게임 결과 표시 함수 (상세 정보 포함) - 오버로딩
void displayResult(const Font& font, int score, int correctClicks, int wrongClicks) {
    font(U"게임 종료!").drawAt(Scene::Center().movedBy(0, -40), ColorF(1.0));
    font(U"최종 점수: {}"_fmt(score)).drawAt(Scene::Center(), ColorF(1.0));
    font(U"정답: {}, 오답: {}"_fmt(correctClicks, wrongClicks))
        .drawAt(Scene::Center().movedBy(0, 40), ColorF(0.8));
}

void Main() 
{
    Scene::SetBackground(ColorF(0.2, 0.2, 0.3));
    
    // 폰트 생성
    const Font font{ FontMethod::SDF, 30, Typeface::CJK_Regular_KR };
    
    // 버튼 배열 초기화
    Array<Button> buttons;
    for (int y = 0; y < 3; ++y) {
        for (int x = 0; x < 3; ++x) {
            // 랜덤 값 생성 (1~9)
            int value = Random(1, 9);
            
            // HSV 색상으로 버튼마다 다른 색상 설정
            ColorF color = HSV(value * 40, 0.7, 0.9);
            
            // 기본 매개변수를 활용한 버튼 생성 함수 호출
            buttons.push_back(createButton(
                Vec2(150 + x * 200, 150 + y * 150),
                180, 130, value, U"{}"_fmt(value), color
            ));
        }
    }
    
    int score = 0;
    int targetValue = Random(1, 9);
    int correctClicks = 0;
    int wrongClicks = 0;
    
    const double gameDuration = 30.0; // 게임 시간 (초)
    const double startTime = Scene::Time();
    
    while (System::Update()) {
        // 게임 타이머 표시
        displayTimer(font, startTime, gameDuration, Vec2(400, 50));
        
        // 게임 종료 체크
        const double elapsedTime = Scene::Time() - startTime;
        if (elapsedTime >= gameDuration) {
            // 오버로딩된 함수 호출 (상세 정보 포함)
            displayResult(font, score, correctClicks, wrongClicks);
            continue;
        }
        
        // 현재 목표 표시
        font(U"목표: {}"_fmt(targetValue)).draw(20, 60, ColorF(1.0, 0.9, 0.6));
        
        // 점수 표시 (기본 매개변수 사용)
        displayScore(font, score);
        
        // 버튼 업데이트 및 그리기
        for (auto& button : buttons) {
            if (updateButton(button)) {
                if (button.value == targetValue) {
                    // 정답이면 점수 증가 및 새 목표 설정
                    score += 100;
                    correctClicks++;
                    targetValue = Random(1, 9);
                    
                    // 모든 버튼 클릭 상태 초기화 및 새 값 할당
                    for (auto& b : buttons) {
                        b.clicked = false;
                        b.value = Random(1, 9);
                        b.label = U"{}"_fmt(b.value);
                        b.color = HSV(b.value * 40, 0.7, 0.9);
                    }
                    break;
                } else {
                    // 오답이면 점수 감소
                    score = Max(0, score - 20);
                    wrongClicks++;
                }
            }
            
            // 버튼 그리기 함수 호출
            drawButton(button, font);
        }
    }
}
```

### 코드 설명
- `Button` 구조체를 정의하여 버튼 관련 데이터를 하나로 묶었다.
- `createButton()` 함수는 기본 매개변수를 활용하여 버튼 생성을 간편하게 한다.
- `drawButton()`과 `updateButton()` 함수는 각각 버튼 그리기와 상태 업데이트를 담당한다.
- `displayScore()` 함수는 기본 매개변수를 통해 위치를 선택적으로 지정할 수 있다.
- `displayResult()` 함수는 오버로딩을 통해 두 가지 버전으로 정의되었다.
- 여러 함수로 코드를 모듈화하여 가독성과 유지보수성을 높였다.
  
  

## 3.8 연습 문제
1. 삼각형을 그리는 함수 `drawTriangle()`을 구현해보세요. 함수 오버로딩을 통해 색이 채워진 삼각형과 테두리만 있는 삼각형을 그릴 수 있어야 합니다.

2. 화면에 여러 개의 공이 떨어지는 애니메이션을 구현해보세요. 함수를 사용하여 공의 움직임, 충돌 검사, 그리기 등을 모듈화하세요.

3. 위의 버튼 클릭 게임을 확장하여 다음 기능을 추가해보세요:
   - 난이도 조절 기능 (기본 매개변수 활용)
   - 게임 일시정지 기능
   - 특수 버튼 추가 (점수 두 배, 시간 추가 등)
  

## 학습 정리
이번 장에서는 C++의 함수와 모듈화에 대해 배웠다:

- **함수 선언과 정의**: 함수의 기본 개념, 선언과 정의 방법, C++23의 새로운 기능인 `if consteval`
- **매개변수 전달 방식**: 값, 참조, 포인터에 의한 전달 및 `const` 참조
- **함수 오버로딩**: 같은 이름으로 다른 매개변수를 가진 함수 정의
- **기본 매개변수**: 함수 호출 시 생략 가능한 매개변수 설정

Siv3D를 활용한 예제를 통해 이론적인 개념을 실제 코드로 구현해보며, 함수를 통한 코드 모듈화의 장점을 체험했다. 특히 게임 개발에서 함수를 활용하면 코드를 더 논리적으로 구성하고 유지보수하기 쉽게 만들 수 있다.

다음 단계에서는 클래스와 객체지향 프로그래밍에 대해 배우면서, 더 복잡한 프로그램을 구조화하는 방법을 알아보겠다.  

