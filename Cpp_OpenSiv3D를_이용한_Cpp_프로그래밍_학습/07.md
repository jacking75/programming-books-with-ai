# OpenSiv3Dë¥¼ ì´ìš©í•œ C++ í”„ë¡œê·¸ë˜ë° í•™ìŠµ
  
ì €ì: ìµœí¥ë°°, Claude AI  
  
C++ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ë°°ìš°ëŠ” ê²ƒì— ì¤‘ì ì„ ë‘ë˜, Siv3D í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•˜ì—¬ ì‹œê°ì ìœ¼ë¡œ í¥ë¯¸ë¡œìš´ ì˜ˆì œë¥¼ í†µí•´ í•™ìŠµ íš¨ê³¼ë¥¼ ë†’ì´ë„ë¡ ì„¤ê³„ ë˜ì—ˆë‹¤. ë‹¨ìˆœí•œ ì½˜ì†” í”„ë¡œê·¸ë¨ ëŒ€ì‹  ê·¸ë˜í”½, ì†Œë¦¬, ìƒí˜¸ì‘ìš©ì„ í¬í•¨í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ë©° C++ì˜ ê°œë…ì„ ìµí ìˆ˜ ìˆë‹¤.  
  
í•„ìš” ì†Œí”„íŠ¸ì›¨ì–´:  
- Windows 10 ì´ìƒ
- Visual Studio 2022 ì´ìƒ   
  
-----    
    
# Chapter.07: ì˜ˆì™¸ ì²˜ë¦¬ì™€ íŒŒì¼ ì…ì¶œë ¥
í”„ë¡œê·¸ë¨ì„ ê°œë°œí•  ë•Œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì˜¤ë¥˜ë¥¼ ìš°ì•„í•˜ê²Œ ì²˜ë¦¬í•˜ê³ , ì‚¬ìš©ìì˜ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  ë¶ˆëŸ¬ì˜¤ëŠ” ê¸°ëŠ¥ì€ ëª¨ë“  ì‹¤ìš©ì ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ í•„ìˆ˜ ìš”ì†Œì´ë‹¤. ì´ë²ˆ ë‹¨ê³„ì—ì„œëŠ” C++ì˜ ì˜ˆì™¸ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜ê³¼ íŒŒì¼ ì…ì¶œë ¥ ì‹œìŠ¤í…œì„ ë°°ìš°ê³ , Siv3Dë¥¼ í™œìš©í•˜ì—¬ ì´ë¥¼ ì‹¤ì œ ê²Œì„ê³¼ ì• í”Œë¦¬ì¼€ì´ì…˜ì— ì ìš©í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ë‹¤.
  

## 7.1 C++ ì˜ˆì™¸ ì²˜ë¦¬

### 1.1 try-catch êµ¬ë¬¸
ì˜ˆì™¸ ì²˜ë¦¬ëŠ” í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ë¥¼ ê°ì§€í•˜ê³  ì²˜ë¦¬í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤. C++ì—ì„œëŠ” `try-catch` ë¸”ë¡ì„ ì‚¬ìš©í•œë‹¤.

```cpp
try {
    // ì˜ˆì™¸ê°€ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì½”ë“œ
    int denominator = 0;
    if (denominator == 0) {
        throw std::runtime_error("0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }
    int result = 10 / denominator;
} 
catch (const std::runtime_error& e) {
    // std::runtime_error íƒ€ì…ì˜ ì˜ˆì™¸ ì²˜ë¦¬
    Print << U"ì˜¤ë¥˜ ë°œìƒ: " << Unicode::Widen(e.what());
} 
catch (const std::exception& e) {
    // ê¸°íƒ€ std::exception íŒŒìƒ ì˜ˆì™¸ ì²˜ë¦¬
    Print << U"ë‹¤ë¥¸ ì˜ˆì™¸ ë°œìƒ: " << Unicode::Widen(e.what());
} 
catch (...) {
    // ëª¨ë“  ë‹¤ë¥¸ íƒ€ì…ì˜ ì˜ˆì™¸ ì²˜ë¦¬
    Print << U"ì•Œ ìˆ˜ ì—†ëŠ” ì˜ˆì™¸ ë°œìƒ";
}
```

#### ì˜ˆì™¸ ì „íŒŒ
ì˜ˆì™¸ëŠ” í˜¸ì¶œ ìŠ¤íƒì„ ë”°ë¼ ìƒìœ„ í•¨ìˆ˜ë¡œ ì „íŒŒëœë‹¤. í˜¸ì¶œ ê²½ë¡œ ìƒì˜ ì–´ë–¤ í•¨ìˆ˜ì—ì„œë“  ì˜ˆì™¸ë¥¼ ì¡ì•„ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.  
  
```cpp
void funcC() {
    throw std::runtime_error("funcCì—ì„œ ì˜ˆì™¸ ë°œìƒ");
}

void funcB() {
    funcC(); // ì˜ˆì™¸ê°€ ì—¬ê¸°ë¥¼ í†µê³¼í•˜ì—¬ ìƒìœ„ë¡œ ì „íŒŒë¨
}

void funcA() {
    try {
        funcB();
    } catch (const std::exception& e) {
        // funcCì—ì„œ ë°œìƒí•œ ì˜ˆì™¸ê°€ ì—¬ê¸°ì„œ ì¡í˜
        Print << U"ì˜ˆì™¸ ì¡í˜: " << Unicode::Widen(e.what());
    }
}
```

### 1.2 ì˜ˆì™¸ í´ë˜ìŠ¤
C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë‹¤ì–‘í•œ ì˜ˆì™¸ í´ë˜ìŠ¤ë¥¼ ì œê³µí•œë‹¤. ëª¨ë“  í‘œì¤€ ì˜ˆì™¸ëŠ” `std::exception` í´ë˜ìŠ¤ë¥¼ ìƒì†í•œë‹¤.

```cpp
// ì£¼ìš” í‘œì¤€ ì˜ˆì™¸ í´ë˜ìŠ¤
// std::exception - ëª¨ë“  í‘œì¤€ ì˜ˆì™¸ì˜ ê¸°ë³¸ í´ë˜ìŠ¤
// std::runtime_error - ì‹¤í–‰ ì‹œê°„ì— ê°ì§€ë  ìˆ˜ ìˆëŠ” ì˜¤ë¥˜
// std::logic_error - í”„ë¡œê·¸ë¨ì˜ ë‚´ë¶€ ë…¼ë¦¬ ì˜¤ë¥˜
// std::out_of_range - ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì ‘ê·¼
// std::invalid_argument - ì˜ëª»ëœ ì¸ìˆ˜
```

#### ì‚¬ìš©ì ì •ì˜ ì˜ˆì™¸ í´ë˜ìŠ¤
íŠ¹ì • ì• í”Œë¦¬ì¼€ì´ì…˜ì— ë§ëŠ” ì˜ˆì™¸ í´ë˜ìŠ¤ë¥¼ ì§ì ‘ ì •ì˜í•  ìˆ˜ ìˆë‹¤.

```cpp
class GameException : public std::exception {
private:
    std::string message;

public:
    GameException(const std::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

// ë” êµ¬ì²´ì ì¸ ê²Œì„ ì˜ˆì™¸
class ResourceNotFoundException : public GameException {
public:
    ResourceNotFoundException(const std::string& resourceName)
        : GameException("ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + resourceName) {}
};
```

#### C++23ì˜ ì˜ˆì™¸ ê¸°ëŠ¥
C++23ì—ì„œëŠ” `std::unexpected()`ê°€ ë„ì…ë˜ì–´ í”„ë¡œê·¸ë¨ì˜ ì˜ˆì™¸ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜ì´ ê°œì„ ë˜ì—ˆë‹¤.
  


## 7.2 C++ íŒŒì¼ ì…ì¶œë ¥

### 2.1 C++ ìŠ¤íŠ¸ë¦¼
C++ì—ì„œëŠ” ì…ì¶œë ¥ì„ ìŠ¤íŠ¸ë¦¼(stream) ê°œë…ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤.

- `iostream`: ì½˜ì†” ì…ì¶œë ¥(`std::cin`, `std::cout`)
- `fstream`: íŒŒì¼ ì…ì¶œë ¥(`std::ifstream`, `std::ofstream`, `std::fstream`)
- `stringstream`: ë¬¸ìì—´ ì²˜ë¦¬(`std::stringstream`, `std::istringstream`, `std::ostringstream`)

### 2.2 íŒŒì¼ ì…ì¶œë ¥ ê¸°ë³¸

```cpp
#include <fstream>
#include <iostream>
#include <string>

// íŒŒì¼ ì“°ê¸°
void writeToFile() {
    std::ofstream outFile("data.txt"); // íŒŒì¼ ì—´ê¸°
    
    if (outFile.is_open()) {
        outFile << "ì•ˆë…•í•˜ì„¸ìš”!" << std::endl;
        outFile << 12345 << std::endl;
        outFile << 3.14159 << std::endl;
    } else {
        std::cerr << "íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." << std::endl;
    }
    
    // íŒŒì¼ì€ outFileì´ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚  ë•Œ ìë™ìœ¼ë¡œ ë‹«í˜
}

// íŒŒì¼ ì½ê¸°
void readFromFile() {
    std::ifstream inFile("data.txt"); // íŒŒì¼ ì—´ê¸°
    
    if (inFile.is_open()) {
        std::string line;
        int number;
        double pi;
        
        std::getline(inFile, line); // ì²« ë²ˆì§¸ ì¤„ ì½ê¸°
        inFile >> number;           // ì •ìˆ˜ ì½ê¸°
        inFile >> pi;               // ì‹¤ìˆ˜ ì½ê¸°
        
        std::cout << "ì½ì€ ë°ì´í„°: " << line << ", " << number << ", " << pi << std::endl;
    } else {
        std::cerr << "íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." << std::endl;
    }
}
```

#### íŒŒì¼ ëª¨ë“œ
íŒŒì¼ì„ ì—´ ë•Œ ë‹¤ì–‘í•œ ëª¨ë“œë¥¼ ì§€ì •í•  ìˆ˜ ìˆë‹¤.

```cpp
// ì“°ê¸° ëª¨ë“œ (ê¸°ì¡´ ë‚´ìš© ì‚­ì œ)
std::ofstream outFile("data.txt", std::ios::out);

// ì¶”ê°€ ëª¨ë“œ (ê¸°ì¡´ ë‚´ìš© ìœ ì§€í•˜ê³  ëì— ì¶”ê°€)
std::ofstream appendFile("data.txt", std::ios::app);

// ì½ê¸° ë° ì“°ê¸° ëª¨ë“œ
std::fstream rwFile("data.txt", std::ios::in | std::ios::out);

// ë°”ì´ë„ˆë¦¬ ëª¨ë“œ (í…ìŠ¤íŠ¸ ë³€í™˜ ì—†ì´)
std::ofstream binFile("data.bin", std::ios::binary);
```

### 2.3 ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì²˜ë¦¬
êµ¬ì¡°ì²´ë‚˜ í´ë˜ìŠ¤ ë°ì´í„°ë¥¼ ë°”ì´ë„ˆë¦¬ í˜•íƒœë¡œ ì €ì¥/ë¡œë“œí•  ìˆ˜ ìˆë‹¤.

```cpp
struct PlayerData {
    int level;
    double health;
    char name[20];
};

// ë°”ì´ë„ˆë¦¬ íŒŒì¼ì— ì“°ê¸°
void saveBinary() {
    PlayerData player{10, 95.5, "í”Œë ˆì´ì–´1"};
    
    std::ofstream outFile("player.dat", std::ios::binary);
    if (outFile) {
        outFile.write(reinterpret_cast<const char*>(&player), sizeof(PlayerData));
    }
}

// ë°”ì´ë„ˆë¦¬ íŒŒì¼ì—ì„œ ì½ê¸°
void loadBinary() {
    PlayerData player;
    
    std::ifstream inFile("player.dat", std::ios::binary);
    if (inFile) {
        inFile.read(reinterpret_cast<char*>(&player), sizeof(PlayerData));
        std::cout << "í”Œë ˆì´ì–´ ì •ë³´: " << player.name << ", ë ˆë²¨: " 
                  << player.level << ", ì²´ë ¥: " << player.health << std::endl;
    }
}
```

### 2.4 C++23ì˜ íŒŒì¼ ì‹œìŠ¤í…œ ë¼ì´ë¸ŒëŸ¬ë¦¬
C++17ë¶€í„° ë„ì…ë˜ê³  C++23ì—ì„œ ê°œì„ ëœ `<filesystem>` ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” íŒŒì¼ ë° ë””ë ‰í† ë¦¬ ì¡°ì‘ì„ ìœ„í•œ ê°•ë ¥í•œ ë„êµ¬ë¥¼ ì œê³µí•œë‹¤.

```cpp
#include <filesystem>
namespace fs = std::filesystem;

void fileSystemDemo() {
    // í˜„ì¬ ê²½ë¡œ
    fs::path currentPath = fs::current_path();
    
    // ë””ë ‰í† ë¦¬ ìƒì„±
    fs::create_directory("data");
    
    // íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    if (fs::exists("config.txt")) {
        // íŒŒì¼ í¬ê¸°
        auto fileSize = fs::file_size("config.txt");
        
        // íŒŒì¼ ë³µì‚¬
        fs::copy_file("config.txt", "config_backup.txt", fs::copy_options::overwrite_existing);
    }
    
    // ë””ë ‰í† ë¦¬ ìˆœíšŒ
    for (const auto& entry : fs::directory_iterator(currentPath)) {
        std::cout << entry.path().filename() << std::endl;
    }
}
```
  
### 2.5 std::filesystem ì£¼ìš” ê¸°ëŠ¥ ì˜ˆì œ

#### ê¸°ë³¸ ì„¤ì •
```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;  // í¸ì˜ë¥¼ ìœ„í•œ alias
```

#### 1. íŒŒì¼/ë””ë ‰í† ë¦¬ ì¡´ì¬ í™•ì¸ - exists()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    std::string path = "test.txt";
    
    if (fs::exists(path)) {
        std::cout << path << " íŒŒì¼ì´ ì¡´ì¬í•œë‹¤" << std::endl;
    } else {
        std::cout << path << " íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤" << std::endl;
    }
    
    return 0;
}
```
**API ì„¤ëª…**: `fs::exists(path)` - ì§€ì •ëœ ê²½ë¡œì— íŒŒì¼ì´ë‚˜ ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤. ì¡´ì¬í•˜ë©´ true, ì—†ìœ¼ë©´ falseë¥¼ ë°˜í™˜í•œë‹¤.

#### 2. íŒŒì¼ íƒ€ì… í™•ì¸ - is_regular_file(), is_directory()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    std::string path = "example";
    
    if (fs::exists(path)) {
        if (fs::is_regular_file(path)) {
            std::cout << path << "ëŠ” ì¼ë°˜ íŒŒì¼ì´ë‹¤" << std::endl;
        } else if (fs::is_directory(path)) {
            std::cout << path << "ëŠ” ë””ë ‰í† ë¦¬ë‹¤" << std::endl;
        }
    }
    
    return 0;
}
```
**API ì„¤ëª…**: 
- `fs::is_regular_file(path)` - ì¼ë°˜ íŒŒì¼ì¸ì§€ í™•ì¸í•œë‹¤
- `fs::is_directory(path)` - ë””ë ‰í† ë¦¬ì¸ì§€ í™•ì¸í•œë‹¤

#### 3. ë””ë ‰í† ë¦¬ ìƒì„± - create_directory(), create_directories()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    // ë‹¨ì¼ ë””ë ‰í† ë¦¬ ìƒì„±
    if (fs::create_directory("new_folder")) {
        std::cout << "new_folder ë””ë ‰í† ë¦¬ê°€ ìƒì„±ë˜ì—ˆë‹¤" << std::endl;
    }
    
    // ì¤‘ê°„ ê²½ë¡œê¹Œì§€ ëª¨ë‘ ìƒì„±
    if (fs::create_directories("parent/child/grandchild")) {
        std::cout << "ì¤‘ê°„ ê²½ë¡œê¹Œì§€ ëª¨ë‘ ìƒì„±ë˜ì—ˆë‹¤" << std::endl;
    }
    
    return 0;
}
```
**API ì„¤ëª…**:
- `fs::create_directory(path)` - ë‹¨ì¼ ë””ë ‰í† ë¦¬ë¥¼ ìƒì„±í•œë‹¤. ë¶€ëª¨ ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ì‹¤íŒ¨í•œë‹¤
- `fs::create_directories(path)` - í•„ìš”í•œ ëª¨ë“  ì¤‘ê°„ ë””ë ‰í† ë¦¬ê¹Œì§€ ìƒì„±í•œë‹¤

#### 4. íŒŒì¼/ë””ë ‰í† ë¦¬ ì‚­ì œ - remove(), remove_all()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    // ë‹¨ì¼ íŒŒì¼ ë˜ëŠ” ë¹ˆ ë””ë ‰í† ë¦¬ ì‚­ì œ
    if (fs::remove("test.txt")) {
        std::cout << "test.txtê°€ ì‚­ì œë˜ì—ˆë‹¤" << std::endl;
    }
    
    // ë””ë ‰í† ë¦¬ì™€ ëª¨ë“  ë‚´ìš©ë¬¼ ì‚­ì œ
    std::uintmax_t deletedCount = fs::remove_all("folder_to_delete");
    std::cout << deletedCount << "ê°œì˜ í•­ëª©ì´ ì‚­ì œë˜ì—ˆë‹¤" << std::endl;
    
    return 0;
}
```
**API ì„¤ëª…**:
- `fs::remove(path)` - íŒŒì¼ì´ë‚˜ ë¹ˆ ë””ë ‰í† ë¦¬ë¥¼ ì‚­ì œí•œë‹¤
- `fs::remove_all(path)` - ë””ë ‰í† ë¦¬ì™€ ëª¨ë“  ë‚´ìš©ë¬¼ì„ ì¬ê·€ì ìœ¼ë¡œ ì‚­ì œí•œë‹¤

#### 5. íŒŒì¼ ë³µì‚¬ - copy_file()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    try {
        fs::copy_file("source.txt", "destination.txt");
        std::cout << "íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ë³µì‚¬ë˜ì—ˆë‹¤" << std::endl;
    } catch (const fs::filesystem_error& e) {
        std::cout << "ë³µì‚¬ ì‹¤íŒ¨: " << e.what() << std::endl;
    }
    
    return 0;
}
```
**API ì„¤ëª…**: `fs::copy_file(from, to)` - íŒŒì¼ì„ ë³µì‚¬í•œë‹¤. ì˜ˆì™¸ê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ try-catch ì‚¬ìš©ì„ ê¶Œì¥í•œë‹¤.

#### 6. íŒŒì¼ í¬ê¸° í™•ì¸ - file_size()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    std::string filename = "test.txt";
    
    if (fs::exists(filename) && fs::is_regular_file(filename)) {
        std::uintmax_t size = fs::file_size(filename);
        std::cout << filename << "ì˜ í¬ê¸°: " << size << " ë°”ì´íŠ¸" << std::endl;
    }
    
    return 0;
}
```
**API ì„¤ëª…**: `fs::file_size(path)` - íŒŒì¼ì˜ í¬ê¸°ë¥¼ ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ë°˜í™˜í•œë‹¤. ì¼ë°˜ íŒŒì¼ì—ë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤.

#### 7. í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ - current_path()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    // í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ í™•ì¸
    fs::path currentDir = fs::current_path();
    std::cout << "í˜„ì¬ ë””ë ‰í† ë¦¬: " << currentDir << std::endl;
    
    // ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½
    fs::current_path("C:/temp");
    std::cout << "ë³€ê²½ëœ ë””ë ‰í† ë¦¬: " << fs::current_path() << std::endl;
    
    return 0;
}
```
**API ì„¤ëª…**: 
- `fs::current_path()` - í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ë¥¼ ë°˜í™˜í•œë‹¤
- `fs::current_path(path)` - ì‘ì—… ë””ë ‰í† ë¦¬ë¥¼ ë³€ê²½í•œë‹¤

#### 8. ë””ë ‰í† ë¦¬ ë‚´ìš©ë¬¼ ìˆœíšŒ - directory_iterator

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    std::string dirPath = ".";  // í˜„ì¬ ë””ë ‰í† ë¦¬
    
    for (const auto& entry : fs::directory_iterator(dirPath)) {
        std::cout << entry.path().filename() << " - ";
        
        if (entry.is_regular_file()) {
            std::cout << "íŒŒì¼ (" << entry.file_size() << " bytes)";
        } else if (entry.is_directory()) {
            std::cout << "ë””ë ‰í† ë¦¬";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```
**API ì„¤ëª…**: `fs::directory_iterator(path)` - ë””ë ‰í† ë¦¬ì˜ ë‚´ìš©ë¬¼ì„ ìˆœíšŒí•  ìˆ˜ ìˆëŠ” ë°˜ë³µìë¥¼ ì œê³µí•œë‹¤.

#### 9. ê²½ë¡œ ì¡°ì‘ - path í´ë˜ìŠ¤

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    fs::path filePath = "C:/Users/Documents/test.txt";
    
    std::cout << "ì „ì²´ ê²½ë¡œ: " << filePath << std::endl;
    std::cout << "íŒŒì¼ëª…: " << filePath.filename() << std::endl;
    std::cout << "í™•ì¥ì: " << filePath.extension() << std::endl;
    std::cout << "ë¶€ëª¨ ê²½ë¡œ: " << filePath.parent_path() << std::endl;
    std::cout << "í™•ì¥ì ì œì™¸ ì´ë¦„: " << filePath.stem() << std::endl;
    
    // ê²½ë¡œ ê²°í•©
    fs::path newPath = fs::path("C:/temp") / "new_file.dat";
    std::cout << "ê²°í•©ëœ ê²½ë¡œ: " << newPath << std::endl;
    
    return 0;
}
```
**API ì„¤ëª…**: 
- `path::filename()` - íŒŒì¼ëª… ë¶€ë¶„ ë°˜í™˜
- `path::extension()` - í™•ì¥ì ë°˜í™˜
- `path::parent_path()` - ë¶€ëª¨ ë””ë ‰í† ë¦¬ ê²½ë¡œ ë°˜í™˜
- `path::stem()` - í™•ì¥ìë¥¼ ì œì™¸í•œ íŒŒì¼ëª… ë°˜í™˜
- `operator/` - ê²½ë¡œë¥¼ ì•ˆì „í•˜ê²Œ ê²°í•©í•œë‹¤

#### 10. ì¬ê·€ì  ë””ë ‰í† ë¦¬ ìˆœíšŒ - recursive_directory_iterator

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() 
{
    std::string dirPath = ".";
    
    for (const auto& entry : fs::recursive_directory_iterator(dirPath)) {
        // ê¹Šì´ì— ë”°ë¥¸ ë“¤ì—¬ì“°ê¸°
        int depth = std::distance(fs::path(dirPath).begin(), entry.path().begin()) - 1;
        std::string indent(depth * 2, ' ');
        
        std::cout << indent << entry.path().filename();
        
        if (entry.is_directory()) {
            std::cout << "/";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```
**API ì„¤ëª…**: `fs::recursive_directory_iterator(path)` - í•˜ìœ„ ë””ë ‰í† ë¦¬ê¹Œì§€ ì¬ê·€ì ìœ¼ë¡œ ìˆœíšŒí•˜ëŠ” ë°˜ë³µìë¥¼ ì œê³µí•œë‹¤.

#### ì£¼ì˜ì‚¬í•­
1. **ì˜ˆì™¸ ì²˜ë¦¬**: filesystem í•¨ìˆ˜ë“¤ì€ ì˜ˆì™¸ë¥¼ ë˜ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ try-catch ë¸”ë¡ ì‚¬ìš©ì„ ê¶Œì¥í•œë‹¤
2. **ê²½ë¡œ êµ¬ë¶„ì**: `/` ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ë©´ í”Œë«í¼ì— ë§ëŠ” ê²½ë¡œ êµ¬ë¶„ìë¥¼ ìë™ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤
3. **ê¶Œí•œ**: íŒŒì¼ ì‹œìŠ¤í…œ ì‘ì—… ì‹œ ì ì ˆí•œ ê¶Œí•œì´ í•„ìš”í•˜ë‹¤
4. **C++17 ì´ìƒ**: std::filesystemì€ C++17ë¶€í„° ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤
  

  
## 7.3 Siv3Dì™€ í•¨ê»˜í•˜ëŠ” ì˜ˆì™¸ ì²˜ë¦¬ ë° íŒŒì¼ ì…ì¶œë ¥
Siv3DëŠ” íŒŒì¼ ì…ì¶œë ¥ê³¼ ì˜ˆì™¸ ì²˜ë¦¬ë¥¼ ë³´ë‹¤ ê°„í¸í•˜ê²Œ ë‹¤ë£° ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

### 3.1 Siv3Dì˜ íŒŒì¼ ì…ì¶œë ¥ ê¸°ëŠ¥
Siv3DëŠ” í…ìŠ¤íŠ¸ íŒŒì¼, ë°”ì´ë„ˆë¦¬ íŒŒì¼, JSON, CSV, INI ë“± ë‹¤ì–‘í•œ í˜•ì‹ì˜ íŒŒì¼ì„ ì‰½ê²Œ ë‹¤ë£° ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

#### í…ìŠ¤íŠ¸ íŒŒì¼ ì²˜ë¦¬

```cpp
#include <Siv3D.hpp>

void Main()
{
    // í…ìŠ¤íŠ¸ íŒŒì¼ ì“°ê¸°
    TextWriter writer(U"data.txt");
    if (writer) {
        writer << U"Siv3Dë¡œ ì‘ì„±í•œ íŒŒì¼ì…ë‹ˆë‹¤." << U"\n";
        writer << U"ìˆ«ì: " << 12345 << U"\n";
        writer << U"ì‹¤ìˆ˜: " << 3.14159;
    }
    
    // í…ìŠ¤íŠ¸ íŒŒì¼ ì½ê¸°
    TextReader reader(U"data.txt");
    if (reader) {
        String line;
        while (reader.readLine(line)) {
            Print << line;
        }
    }
}
```

#### JSON íŒŒì¼ ì²˜ë¦¬

```cpp
#include <Siv3D.hpp>

void Main()
{
	// JSON ë°ì´í„° ìƒì„±
	JSON json;
	json[U"name"] = U"í”Œë ˆì´ì–´1";
	json[U"level"] = 10;
	json[U"health"] = 95.5;
	json[U"items"].push_back(U"ê²€");
	json[U"items"].push_back(U"ë°©íŒ¨");
	json[U"items"].push_back(U"ë¬¼ì•½");

	// JSON íŒŒì¼ ì €ì¥
	json.save(U"player.json");

	// JSON íŒŒì¼ ë¡œë“œ
	JSON loadedJson = JSON::Load(U"player.json");
	if (loadedJson) {
		Print << U"ì´ë¦„: " << loadedJson[U"name"].getString();
		Print << U"ë ˆë²¨: " << loadedJson[U"level"].get<int>();
		Print << U"ì²´ë ¥: " << loadedJson[U"health"].get<double>();
		Print << U"ì•„ì´í…œ:";

		for (const auto& item : loadedJson[U"items"].arrayView()) {
			Print << U"  - " << item.getString();
		}
	}
}
```

### 3.2 Siv3D í™œìš© ì˜ˆì œ: ê²Œì„ ì €ì¥ ë° ë¶ˆëŸ¬ì˜¤ê¸° ì‹œìŠ¤í…œ
ì´ì œ ë°°ìš´ ë‚´ìš©ì„ í™œìš©í•˜ì—¬ ì™„ì „í•œ ê²Œì„ ì €ì¥ ë° ë¶ˆëŸ¬ì˜¤ê¸° ì‹œìŠ¤í…œì„ êµ¬í˜„í•´ ë³´ê² ë‹¤.

```cpp
#include <Siv3D.hpp>

// ì €ì¥í•  í”Œë ˆì´ì–´ ë°ì´í„°ë¥¼ ë‹´ëŠ” êµ¬ì¡°ì²´
// class ëŒ€ì‹  ê°„ë‹¨í•œ structë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ì— ë°”ë¡œ ì ‘ê·¼í•©ë‹ˆë‹¤.
struct PlayerData
{
	String name = U"í”Œë ˆì´ì–´";
	int32 level = 1;
	Vec2 position = { 400, 300 };
};

void Main()
{
	// 1. ê¸°ë³¸ ì„¤ì •
	Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });
	const Font font{ FontMethod::SDF, 40, Typeface::CJK_Regular_KR };
	PlayerData player;

	// 2. ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ë²„íŠ¼
	const Rect saveButton{ 50, 500, 150, 50 };
	const Rect loadButton{ 220, 500, 150, 50 };

	while (System::Update())
	{
		// 3. ë°ì´í„° ë³€ê²½ ë¡œì§ (ë§ˆìš°ìŠ¤ í´ë¦­ ì‹œ ë ˆë²¨ ì¦ê°€ ë° ìœ„ì¹˜ ë³€ê²½)
		if (MouseL.down())
		{
			player.level++;
			player.position = Cursor::Pos();
		}

		// 4. ì €ì¥ ë²„íŠ¼ ê¸°ëŠ¥
		if (saveButton.leftClicked())
		{
			// (1) JSON ê°ì²´ ìƒì„±
			JSON json;

			// (2) ë°ì´í„° ê¸°ë¡: player ë°ì´í„° -> json ê°ì²´
			json[U"name"] = player.name;
			json[U"level"] = player.level;
			json[U"position"] = player.position; // Vec2ë„ ì§ì ‘ ì €ì¥ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

			// (3) íŒŒì¼ë¡œ ì €ì¥
			json.save(U"save.json");
			Print << U"ì €ì¥ ì™„ë£Œ!";
		}

		// 5. ë¶ˆëŸ¬ì˜¤ê¸° ë²„íŠ¼ ê¸°ëŠ¥
		if (loadButton.leftClicked())
		{
			// (1) JSON íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°
			const JSON json = JSON::Load(U"save.json");

			if (json) // íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì—´ë ¸ë‹¤ë©´
			{
				// (2) ë°ì´í„° ì½ê¸°: json ê°ì²´ -> player ë°ì´í„°
				player.name = json[U"name"].getString();
				player.level = json[U"level"].get<int32>();
				player.position = json[U"position"].get<Vec2>();
				Print << U"ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!";
			}
		}

		// 6. í™”ë©´ì— í˜„ì¬ ë°ì´í„° ê·¸ë¦¬ê¸°
		font(U"ì´ë¦„: ", player.name).draw(50, 50);
		font(U"ë ˆë²¨: ", player.level).draw(50, 110);
		font(U"ìœ„ì¹˜: ", player.position).draw(50, 170);
		font(U"ğŸ–±ï¸ í™”ë©´ì„ í´ë¦­í•˜ë©´ ë ˆë²¨ê³¼ ìœ„ì¹˜ê°€ ë°”ë€ë‹ˆë‹¤.").draw(50, 250);

		// í”Œë ˆì´ì–´ ìœ„ì¹˜ì— ì´ëª¨ì§€ í‘œì‹œ
		font(U"ğŸ˜€").drawAt(player.position);

		// ë²„íŠ¼ ê·¸ë¦¬ê¸°
		saveButton.draw().drawFrame(2, Palette::Black);
		loadButton.draw().drawFrame(2, Palette::Black);
		font(U"ì €ì¥").drawAt(saveButton.center(), Palette::Black);
		font(U"ë¶ˆëŸ¬ì˜¤ê¸°").drawAt(loadButton.center(), Palette::Black);
	}
}
```

### 3.3 ì„¤ì • íŒŒì¼ ê´€ë¦¬ ì‹œìŠ¤í…œ
ì´ì œ ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì„¤ì •ì„ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œì„ ë§Œë“¤ì–´ ë³´ê² ë‹¤.

```cpp
#include <Siv3D.hpp>

// ì„¤ì • ê´€ë¦¬ í´ë˜ìŠ¤
class ConfigManager 
{
private:
    // ì„¤ì • ë°ì´í„°
    struct Config {
        int resolutionWidth = 800;
        int resolutionHeight = 600;
        bool fullscreen = false;
        double masterVolume = 0.8;
        double bgmVolume = 0.7;
        double sfxVolume = 0.9;
        ColorF backgroundColor = ColorF(0.3, 0.4, 0.5);
        String language = U"í•œêµ­ì–´";
    };
    
    Config currentConfig;
    String configFilePath;
    
public:
    ConfigManager(const String& filename = U"config.json") 
        : configFilePath(filename) {
        loadConfig();
    }
    
    // ì„¤ì • ì €ì¥
    bool saveConfig() {
        try {
            JSON json;
            
            json[U"resolution"][U"width"] = currentConfig.resolutionWidth;
            json[U"resolution"][U"height"] = currentConfig.resolutionHeight;
            json[U"fullscreen"] = currentConfig.fullscreen;
            json[U"volume"][U"master"] = currentConfig.masterVolume;
            json[U"volume"][U"bgm"] = currentConfig.bgmVolume;
            json[U"volume"][U"sfx"] = currentConfig.sfxVolume;
            json[U"backgroundColor"][U"r"] = currentConfig.backgroundColor.r;
            json[U"backgroundColor"][U"g"] = currentConfig.backgroundColor.g;
            json[U"backgroundColor"][U"b"] = currentConfig.backgroundColor.b;
            json[U"language"] = currentConfig.language;
            
            return json.save(configFilePath);
        }
        catch (const std::exception& e) {
            Print << U"ì„¤ì • ì €ì¥ ì˜¤ë¥˜: " << Unicode::Widen(e.what());
            return false;
        }
    }
    
    // ì„¤ì • ë¡œë“œ
    bool loadConfig() {
        try {
            if (!FileSystem::Exists(configFilePath)) {
                Print << U"ì„¤ì • íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ ì„¤ì •ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.";
                return false;
            }
            
            JSON json = JSON::Load(configFilePath);
            
            if (!json) {
                throw std::runtime_error("ì„¤ì • íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.");
            }
            
            currentConfig.resolutionWidth = json[U"resolution"][U"width"].get<int>();
            currentConfig.resolutionHeight = json[U"resolution"][U"height"].get<int>();
            currentConfig.fullscreen = json[U"fullscreen"].get<bool>();
            currentConfig.masterVolume = json[U"volume"][U"master"].get<double>();
            currentConfig.bgmVolume = json[U"volume"][U"bgm"].get<double>();
            currentConfig.sfxVolume = json[U"volume"][U"sfx"].get<double>();
            currentConfig.backgroundColor.r = json[U"backgroundColor"][U"r"].get<double>();
            currentConfig.backgroundColor.g = json[U"backgroundColor"][U"g"].get<double>();
            currentConfig.backgroundColor.b = json[U"backgroundColor"][U"b"].get<double>();
            currentConfig.language = json[U"language"].getString();
            
            return true;
        }
        catch (const std::exception& e) {
            Print << U"ì„¤ì • ë¡œë“œ ì˜¤ë¥˜: " << Unicode::Widen(e.what());
            return false;
        }
    }
    
    // ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ë³µì›
    void resetToDefaults() {
        currentConfig = Config();
    }
    
    // ì„¤ì • ì ‘ê·¼ì
    void setResolution(int width, int height) { 
        currentConfig.resolutionWidth = width; 
        currentConfig.resolutionHeight = height; 
    }
    
    void setFullscreen(bool value) { 
        currentConfig.fullscreen = value; 
    }
    
    void setMasterVolume(double volume) { 
        currentConfig.masterVolume = Clamp(volume, 0.0, 1.0); 
    }
    
    void setBGMVolume(double volume) { 
        currentConfig.bgmVolume = Clamp(volume, 0.0, 1.0); 
    }
    
    void setSFXVolume(double volume) { 
        currentConfig.sfxVolume = Clamp(volume, 0.0, 1.0); 
    }
    
    void setBackgroundColor(const ColorF& color) { 
        currentConfig.backgroundColor = color; 
    }
    
    void setLanguage(const String& lang) { 
        currentConfig.language = lang; 
    }
    
    // ì„¤ì • ê°€ì ¸ì˜¤ê¸°
    std::pair<int, int> getResolution() const { 
        return {currentConfig.resolutionWidth, currentConfig.resolutionHeight}; 
    }
    
    bool isFullscreen() const { 
        return currentConfig.fullscreen; 
    }
    
    double getMasterVolume() const { 
        return currentConfig.masterVolume; 
    }
    
    double getBGMVolume() const { 
        return currentConfig.bgmVolume; 
    }
    
    double getSFXVolume() const { 
        return currentConfig.sfxVolume; 
    }
    
    ColorF getBackgroundColor() const { 
        return currentConfig.backgroundColor; 
    }
    
    String getLanguage() const { 
        return currentConfig.language; 
    }
    
    // í˜„ì¬ ì„¤ì • ì ìš©
    void applySettings() {
        Scene::SetBackground(currentConfig.backgroundColor);
        // ì‹¤ì œ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œëŠ” í•´ìƒë„ ë³€ê²½, ë³¼ë¥¨ ì„¤ì • ë“±ì˜ ì½”ë“œê°€ ì—¬ê¸°ì— ì¶”ê°€ë©ë‹ˆë‹¤.
    }
};

// ì„¤ì • UI í´ë˜ìŠ¤
class SettingsUI {
private:
    ConfigManager& config;
    Font font;
    
    // UI ìš”ì†Œ
    Rect fullscreenCheckbox;
    RectF masterVolumeSlider;
    RectF bgmVolumeSlider;
    RectF sfxVolumeSlider;
    RectF saveButton;
    RectF resetButton;
    RectF colorPickerButton;
    Array<RectF> resolutionButtons;
    Array<std::pair<int, int>> resolutions;
    
    // ë“œë˜ê·¸ ìƒíƒœ
    enum class DragState {
        None,
        MasterVolume,
        BGMVolume,
        SFXVolume
    } dragState = DragState::None;
    
    // ìƒ‰ìƒ ì„ íƒ í™œì„±í™” ìƒíƒœ
    bool colorPickerActive = false;
    HSV currentColor;
    
public:
    SettingsUI(ConfigManager& configManager)
        : config(configManager) {
        
        const Font font{ FontMethod::SDF, 24, Typeface::CJK_Regular_KR };

        // í•´ìƒë„ ì˜µì…˜
        resolutions = {
            {800, 600},
            {1024, 768},
            {1280, 720},
            {1920, 1080}
        };
        
        // UI ìš”ì†Œ ìœ„ì¹˜ ì„¤ì •
        for (size_t i = 0; i < resolutions.size(); i++) {
            resolutionButtons << RectF(50, 100 + i * 50, 200, 40);
        }
        
        fullscreenCheckbox = Rect(50, 350, 30, 30);
        
        masterVolumeSlider = RectF(250, 100, 300, 30);
        bgmVolumeSlider = RectF(250, 150, 300, 30);
        sfxVolumeSlider = RectF(250, 200, 300, 30);
        
        colorPickerButton = RectF(50, 400, 200, 40);
        
        saveButton = RectF(400, 500, 120, 50);
        resetButton = RectF(550, 500, 120, 50);
        
        // í˜„ì¬ ì„¤ì •ëœ ìƒ‰ìƒ
        ColorF bgColor = config.getBackgroundColor();
        currentColor = HSV(bgColor);
    }
    
    void update() {
        // ì „ì²´í™”ë©´ ì²´í¬ë°•ìŠ¤
        if (fullscreenCheckbox.leftClicked()) {
            config.setFullscreen(!config.isFullscreen());
        }
        
        // í•´ìƒë„ ë²„íŠ¼
        for (size_t i = 0; i < resolutionButtons.size(); i++) {
            if (resolutionButtons[i].leftClicked()) {
                config.setResolution(resolutions[i].first, resolutions[i].second);
            }
        }
        
        // ë³¼ë¥¨ ìŠ¬ë¼ì´ë” ì²˜ë¦¬
        if (MouseL.down()) {
            if (masterVolumeSlider.mouseOver()) {
                dragState = DragState::MasterVolume;
            }
            else if (bgmVolumeSlider.mouseOver()) {
                dragState = DragState::BGMVolume;
            }
            else if (sfxVolumeSlider.mouseOver()) {
                dragState = DragState::SFXVolume;
            }
        }
        
        if (!MouseL.pressed()) {
            dragState = DragState::None;
        }
        
        if (MouseL.pressed()) {
            double x = Cursor::Pos().x;
            
            switch (dragState) {
            case DragState::MasterVolume:
                config.setMasterVolume((x - masterVolumeSlider.x) / masterVolumeSlider.w);
                break;
            case DragState::BGMVolume:
                config.setBGMVolume((x - bgmVolumeSlider.x) / bgmVolumeSlider.w);
                break;
            case DragState::SFXVolume:
                config.setSFXVolume((x - sfxVolumeSlider.x) / sfxVolumeSlider.w);
                break;
            default:
                break;
            }
        }
        
        // ìƒ‰ìƒ ì„ íƒê¸° ë²„íŠ¼
        if (colorPickerButton.leftClicked()) {
            colorPickerActive = !colorPickerActive;
        }
        
        // ìƒ‰ìƒ ì„ íƒê¸° ì²˜ë¦¬
        if (colorPickerActive) {
            if (MouseL.pressed()) {
                // ê°„ë‹¨í•œ HSV ìƒ‰ìƒ ì„ íƒ
                Rect colorArea(600, 100, 150, 150);
                if (colorArea.mouseOver()) {
                    double s = (Cursor::Pos().x - colorArea.x) / colorArea.w;
                    double v = 1.0 - (Cursor::Pos().y - colorArea.y) / colorArea.h;
                    currentColor.s = s;
                    currentColor.v = v;
                }
                
                // ìƒ‰ìƒ(H) ì„ íƒê¸°
                Rect hueArea(600, 260, 150, 20);
                if (hueArea.mouseOver()) {
                    double h = (Cursor::Pos().x - hueArea.x) / hueArea.w;
                    currentColor.h = h;
                }
                
                config.setBackgroundColor(currentColor);
            }
        }
        
        // ì €ì¥ ë²„íŠ¼
        if (saveButton.leftClicked()) {
            if (config.saveConfig()) {
                config.applySettings();
                Print << U"ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.";
            }
        }
        
        // ì´ˆê¸°í™” ë²„íŠ¼
        if (resetButton.leftClicked()) {
            config.resetToDefaults();
            ColorF bgColor = config.getBackgroundColor();
            currentColor = HSV(bgColor);
        }
    }
    
    void draw() const {
        // ì œëª©
        font(U"ì„¤ì •").draw(50, 50, ColorF(1.0));
        
        // í•´ìƒë„ ì„¹ì…˜
        font(U"í•´ìƒë„").draw(50, 70, ColorF(0.8));
        
        auto currentRes = config.getResolution();
        for (size_t i = 0; i < resolutionButtons.size(); i++) {
            ColorF buttonColor = (currentRes.first == resolutions[i].first && 
                                 currentRes.second == resolutions[i].second) ? 
                                 ColorF(0.3, 0.7, 0.3) : ColorF(0.5);
            
            resolutionButtons[i].draw(buttonColor);
            font(U"{}x{}"_fmt(resolutions[i].first, resolutions[i].second))
                .drawAt(resolutionButtons[i].center(), ColorF(1.0));
        }
        
        // ì „ì²´í™”ë©´ ì˜µì…˜
        font(U"ì „ì²´í™”ë©´").draw(100, 350, ColorF(0.8));
        fullscreenCheckbox.draw(ColorF(0.5));
        if (config.isFullscreen()) {
            Line(fullscreenCheckbox.pos, fullscreenCheckbox.br()).draw(3, ColorF(0.2, 0.8, 0.2));
            Line(fullscreenCheckbox.tr(), fullscreenCheckbox.bl()).draw(3, ColorF(0.2, 0.8, 0.2));
        }
        
        // ë³¼ë¥¨ ì„¹ì…˜
        font(U"ë³¼ë¥¨").draw(250, 70, ColorF(0.8));
        
        // ë§ˆìŠ¤í„° ë³¼ë¥¨
        font(U"ë§ˆìŠ¤í„°").draw(180, 105, ColorF(0.8));
        masterVolumeSlider.draw(ColorF(0.3));
        RectF(masterVolumeSlider.pos, masterVolumeSlider.w * config.getMasterVolume(), masterVolumeSlider.h)
            .draw(ColorF(0.2, 0.7, 0.3));
            
        // BGM ë³¼ë¥¨
        font(U"ë°°ê²½ìŒ").draw(180, 155, ColorF(0.8));
        bgmVolumeSlider.draw(ColorF(0.3));
        RectF(bgmVolumeSlider.pos, bgmVolumeSlider.w * config.getBGMVolume(), bgmVolumeSlider.h)
            .draw(ColorF(0.2, 0.7, 0.3));
            
        // íš¨ê³¼ìŒ ë³¼ë¥¨
        font(U"íš¨ê³¼ìŒ").draw(180, 205, ColorF(0.8));
        sfxVolumeSlider.draw(ColorF(0.3));
        RectF(sfxVolumeSlider.pos, sfxVolumeSlider.w * config.getSFXVolume(), sfxVolumeSlider.h)
            .draw(ColorF(0.2, 0.7, 0.3));
            
        // ë°°ê²½ ìƒ‰ìƒ
        font(U"ë°°ê²½ìƒ‰").draw(50, 400, ColorF(0.8));
        colorPickerButton.draw(config.getBackgroundColor());
        font(U"ë³€ê²½").drawAt(colorPickerButton.center(), ColorF(1.0));
        
        // ìƒ‰ìƒ ì„ íƒê¸°
        if (colorPickerActive) {
            Rect colorArea(600, 100, 150, 150);
            Rect hueArea(600, 260, 150, 20);
            
            // HSV ìƒ‰ìƒ íŒ”ë ˆíŠ¸
            for (int y = 0; y < colorArea.h; y++) {
                for (int x = 0; x < colorArea.w; x++) {
                    double s = static_cast<double>(x) / colorArea.w;
                    double v = 1.0 - static_cast<double>(y) / colorArea.h;
                    HSV pixelColor(currentColor.h, s, v);
                    Rect(colorArea.x + x, colorArea.y + y, 1, 1).draw(pixelColor);
                }
            }
            
            // ìƒ‰ìƒ(H) ì„ íƒê¸°
            for (int x = 0; x < hueArea.w; x++) {
                double h = static_cast<double>(x) / hueArea.w;
                Rect(hueArea.x + x, hueArea.y, 1, hueArea.h).draw(HSV(h, 1.0, 1.0));
            }
            
            // ì„ íƒëœ ìœ„ì¹˜ í‘œì‹œ
            Circle(colorArea.x + currentColor.s * colorArea.w, 
                   colorArea.y + (1.0 - currentColor.v) * colorArea.h, 5)
                .drawFrame(2, ColorF(1.0));
                
            Rect(hueArea.x + currentColor.h * hueArea.w - 2, hueArea.y - 5, 4, hueArea.h + 10)
                .draw(ColorF(1.0));
                
            // í˜„ì¬ ì„ íƒëœ ìƒ‰ìƒ í‘œì‹œ
            Rect(600, 290, 150, 30).draw(currentColor);
            font(U"R:{:.2f} G:{:.2f} B:{:.2f}"_fmt(
                currentColor.toColor().r, 
                currentColor.toColor().g, 
                currentColor.toColor().b))
                .draw(600, 330, ColorF(0.8));
        }
        
        // ë²„íŠ¼
        saveButton.draw(ColorF(0.2, 0.6, 0.3));
        font(U"ì €ì¥").drawAt(saveButton.center(), ColorF(1.0));
        
        resetButton.draw(ColorF(0.6, 0.3, 0.2));
        font(U"ì´ˆê¸°í™”").drawAt(resetButton.center(), ColorF(1.0));
    }
};

void Main() {
    // ì„¤ì • ê´€ë¦¬ì ìƒì„±
    ConfigManager configManager(U"settings.json");
    
    // í˜„ì¬ ì„¤ì • ì ìš©
    configManager.applySettings();
    
    // ì„¤ì • UI ìƒì„±
    SettingsUI settingsUI(configManager);
    
    while (System::Update()) {
        settingsUI.update();
        settingsUI.draw();
    }
}
```

### 3.4 ì˜ˆì™¸ ì²˜ë¦¬ë¥¼ í¬í•¨í•œ ë¦¬ì†ŒìŠ¤ ë¡œë”© ì‹œìŠ¤í…œ
ë§ˆì§€ë§‰ìœ¼ë¡œ, ê²Œì„ì—ì„œ ì‚¬ìš©í•  ë¦¬ì†ŒìŠ¤(ì´ë¯¸ì§€, ì‚¬ìš´ë“œ, í°íŠ¸ ë“±)ë¥¼ ì•ˆì „í•˜ê²Œ ë¡œë“œí•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•´ ë³´ê² ë‹¤.

```cpp
#include <Siv3D.hpp>

// ì‚¬ìš©ì ì •ì˜ ì˜ˆì™¸ í´ë˜ìŠ¤
class ResourceException : public std::exception
{
private:
	std::string message;

public:
	ResourceException(const std::string& msg) : message(msg) {}

	const char* what() const noexcept override {
		return message.c_str();
	}
};

// ë¦¬ì†ŒìŠ¤ íƒ€ì… ì—´ê±°í˜•
enum class ResourceType
{
	Texture,
	Audio,
	Font,
	Other
};

// ë¦¬ì†ŒìŠ¤ ì •ë³´ êµ¬ì¡°ì²´
struct ResourceInfo
{
	String path;
	ResourceType type;
	bool isRequired;
	String fallbackPath; // ê¸°ë³¸ ëŒ€ì²´ ê²½ë¡œ
};

// ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ í´ë˜ìŠ¤
class ResourceManager
{
private:
	// ë¦¬ì†ŒìŠ¤ ì»¨í…Œì´ë„ˆ
	HashTable<String, Texture> textures;
	HashTable<String, Audio> audios;
	HashTable<String, Font> fonts;

	// ë¡œë”© ìƒíƒœ
	int totalResources = 0;
	int loadedResources = 0;
	bool isLoading = false;
	Array<String> errors;

	// ë¦¬ì†ŒìŠ¤ ì •ì˜
	Array<std::pair<String, ResourceInfo>> resourceDefinitions;

public:
	ResourceManager() = default;

	// ë¦¬ì†ŒìŠ¤ ì •ì˜ ì¶”ê°€
	void addResourceDefinition(const String& id, const ResourceInfo& info) {
		resourceDefinitions.emplace_back(id, info);
	}

	// ëª¨ë“  ë¦¬ì†ŒìŠ¤ ë¡œë“œ
	bool loadAllResources() {
		isLoading = true;
		totalResources = static_cast<int>(resourceDefinitions.size());
		loadedResources = 0;
		errors.clear();

		for (const auto& [id, info] : resourceDefinitions) {
			try {
				bool success = loadResource(id, info);

				if (!success && info.isRequired) {
					throw ResourceException("í•„ìˆ˜ ë¦¬ì†ŒìŠ¤ ë¡œë“œ ì‹¤íŒ¨: " + Unicode::Narrow(id));
				}
				else if (!success) {
					errors << U"ê²½ê³ : " + id + U" ë¡œë“œ ì‹¤íŒ¨. ëŒ€ì²´ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©";
				}

				loadedResources++;
			}
			catch (const std::exception& e) {
				errors << U"ì˜¤ë¥˜: " + Unicode::Widen(e.what());

				if (info.isRequired) {
					isLoading = false;
					return false;
				}
			}
		}

		isLoading = false;
		return true;
	}

	// ë‹¨ì¼ ë¦¬ì†ŒìŠ¤ ë¡œë“œ
	bool loadResource(const String& id, const ResourceInfo& info) {
		bool success = false;

		switch (info.type) {
		case ResourceType::Texture:
			success = loadTexture(id, info.path, info.fallbackPath);
			break;
		case ResourceType::Audio:
			success = loadAudio(id, info.path, info.fallbackPath);
			break;
		case ResourceType::Font:
			success = loadFont(id, info.path, info.fallbackPath);
			break;
		case ResourceType::Other:
			// ê¸°íƒ€ ë¦¬ì†ŒìŠ¤ íƒ€ì… ì²˜ë¦¬
			success = true;
			break;
		}

		return success;
	}

	// í…ìŠ¤ì²˜ ë¡œë“œ
	bool loadTexture(const String& id, const String& path, const String& fallbackPath = U"") {
		try {
			if (!FileSystem::Exists(path)) {
				if (!fallbackPath.isEmpty() && FileSystem::Exists(fallbackPath)) {
					textures[id] = Texture(fallbackPath);
					return true;
				}
				return false;
			}

			textures[id] = Texture(path);
			return static_cast<bool>(textures[id]);
		}
		catch (const std::exception&) {
			// ì´ëª¨ì§€ ë“±ìœ¼ë¡œ ì‹œë„
			if (path.starts_with(U"_emoji")) {
				const String emojiText = path.substr(7, path.size() - 8); // "_emoji(" ì™€ ")" ì œì™¸
				textures[id] = Texture(emojiText + U"_emoji");
				return static_cast<bool>(textures[id]);
			}

			if (!fallbackPath.isEmpty()) {
				try {
					textures[id] = Texture(fallbackPath);
					return static_cast<bool>(textures[id]);
				}
				catch (...) {}
			}

			// ê¸°ë³¸ í…ìŠ¤ì²˜
			textures[id] = Texture(Emoji(U"â“"));
			return false;
		}
	}

	// ì˜¤ë””ì˜¤ ë¡œë“œ
	bool loadAudio(const String& id, const String& path, const String& fallbackPath = U"") {
		try {
			if (!FileSystem::Exists(path)) {
				if (!fallbackPath.isEmpty() && FileSystem::Exists(fallbackPath)) {
					audios[id] = Audio(fallbackPath);
					return true;
				}
				return false;
			}

			audios[id] = Audio(path);
			return static_cast<bool>(audios[id]);
		}
		catch (const std::exception&) {
			if (!fallbackPath.isEmpty()) {
				try {
					audios[id] = Audio(fallbackPath);
					return static_cast<bool>(audios[id]);
				}
				catch (...) {}
			}

			return false;
		}
	}

	// í°íŠ¸ ë¡œë“œ
	bool loadFont(const String& id, const String& path, const String& fallbackPath = U"") {
		try {
			if (path.isEmpty()) {
				// ê¸°ë³¸ í°íŠ¸
				fonts[id] = Font(30);
				return true;
			}

			if (path.starts_with(U"size=")) {
				// í¬ê¸° ì§€ì • ê¸°ë³¸ í°íŠ¸
				int32 size = Parse<int32>(path.substr(5));
				fonts[id] = Font(size);
				return true;
			}

			if (!FileSystem::Exists(path)) {
				if (!fallbackPath.isEmpty()) {
					fonts[id] = Font(30, fallbackPath);
					return true;
				}

				// ê¸°ë³¸ í°íŠ¸
				fonts[id] = Font(30);
				return true;
			}

			fonts[id] = Font(30, path);
			return static_cast<bool>(fonts[id]);
		}
		catch (const std::exception&) {
			// ê¸°ë³¸ í°íŠ¸
			fonts[id] = Font(30);
			return false;
		}
	}

	// ë¦¬ì†ŒìŠ¤ ê°€ì ¸ì˜¤ê¸°
	const Texture& getTexture(const String& id) const {
		if (textures.contains(id)) {
			return textures.at(id);
		}

		static const Texture defaultTexture(Emoji(U"â“"));
		return defaultTexture;
	}

	const Audio& getAudio(const String& id) const {
		if (audios.contains(id)) {
			return audios.at(id);
		}

		throw ResourceException("ì˜¤ë””ì˜¤ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: " + Unicode::Narrow(id));
	}

	const Font& getFont(const String& id) const {
		if (fonts.contains(id)) {
			return fonts.at(id);
		}

		static const Font defaultFont(30);
		return defaultFont;
	}

	// ë¡œë”© ì§„í–‰ ìƒí™©
	double getLoadingProgress() const {
		if (totalResources == 0) return 1.0;
		return static_cast<double>(loadedResources) / totalResources;
	}

	// ë¡œë”© ì¤‘ì¸ì§€ í™•ì¸
	bool isLoadingInProgress() const {
		return isLoading;
	}

	// ì—ëŸ¬ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
	const Array<String>& getErrors() const {
		return errors;
	}
};

// ë¡œë”© í™”ë©´ í´ë˜ìŠ¤
class LoadingScreen
{
private:
	ResourceManager& resourceManager;
	Font font;
	double timer = 0;

public:
	LoadingScreen(ResourceManager& rm)
		: resourceManager(rm), font(30) {
	}

	bool update() {
		timer += Scene::DeltaTime();

		// ë¡œë”©ì´ ì™„ë£Œë˜ë©´ true ë°˜í™˜
		return !resourceManager.isLoadingInProgress();
	}

	void draw() const {
		// ë°°ê²½
		Scene::Rect().draw(ColorF(0.1, 0.1, 0.2));

		// ë¡œë”© í…ìŠ¤íŠ¸
		font(U"ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘...").drawAt(Scene::Center().movedBy(0, -50));

		// ë¡œë”© ë°”
		const double progress = resourceManager.getLoadingProgress();
		const RectF loadingBar(Scene::Width() * 0.2, Scene::Height() * 0.6, Scene::Width() * 0.6, 30);
		loadingBar.draw(ColorF(0.3));
		loadingBar.stretched(-loadingBar.w * (1.0 - progress), 0, 0, 0).draw(ColorF(0.2, 0.6, 0.3));

		// ë¡œë”© ì• ë‹ˆë©”ì´ì…˜
		const int dots = static_cast<int>(std::fmod((timer * 2), 4.0));
		String dotsStr;
		for (int i = 0; i < dots; i++) {
			dotsStr += U".";
		}
		font(dotsStr).draw(Scene::Center().x + 120, Scene::Center().y - 50);

		// ë°±ë¶„ìœ¨ í‘œì‹œ
		font(U"{:.0f}%"_fmt(progress * 100)).drawAt(loadingBar.center(), ColorF(1.0));

		// ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
		const Array<String>& errors = resourceManager.getErrors();
		for (size_t i = 0; i < Min(errors.size(), size_t(5)); i++) {
			font(errors[i]).draw(20, Scene::Height() * 0.7 + i * 30, ColorF(1.0, 0.3, 0.3));
		}
	}
};

// ê²Œì„ í´ë˜ìŠ¤
class Game
{
private:
	ResourceManager resourceManager;
	enum class GameState {
		Loading,
		MainMenu,
		Playing,
		GameOver
	} state;

	LoadingScreen loadingScreen;

	// ê²Œì„ ìƒíƒœ ë³€ìˆ˜
	Vec2 playerPos;
	double score = 0;

public:
	Game() : loadingScreen(resourceManager), state(GameState::Loading) {
		// ê²Œì„ì— í•„ìš”í•œ ë¦¬ì†ŒìŠ¤ ì •ì˜
		resourceManager.addResourceDefinition(U"player", {
			U"player.png", ResourceType::Texture, true, U"ğŸš€_emoji"
		});

		resourceManager.addResourceDefinition(U"enemy", {
			U"enemy.png", ResourceType::Texture, true, U"ğŸ‘¾_emoji"
		});

		resourceManager.addResourceDefinition(U"background", {
			U"background.jpg", ResourceType::Texture, false, U""
		});

		resourceManager.addResourceDefinition(U"bgm", {
			U"bgm.mp3", ResourceType::Audio, false, U""
		});

		resourceManager.addResourceDefinition(U"explosion", {
			U"explosion.mp3", ResourceType::Audio, false, U""
		});

		resourceManager.addResourceDefinition(U"mainFont", {
			U"font.ttf", ResourceType::Font, false, U""
		});

		resourceManager.addResourceDefinition(U"titleFont", {
			U"size=40", ResourceType::Font, true, U""
		});

		// ë¦¬ì†ŒìŠ¤ ë¡œë”© ì‹œì‘ (ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ë¡œë“œí•  ìˆ˜ë„ ìˆìŒ)
		std::thread([this]() {
			try {
				resourceManager.loadAllResources();
			}
			catch (const std::exception& e) {
				Print << U"ì‹¬ê°í•œ ë¡œë”© ì˜¤ë¥˜: " << Unicode::Widen(e.what());
			}
		}).detach();

		// ì´ˆê¸° ì„¤ì •
		playerPos = Scene::Center();
	}

	void update() {
		switch (state) {
		case GameState::Loading:
			if (loadingScreen.update()) {
				state = GameState::MainMenu;

				// ë¡œë”© ì™„ë£Œ í›„ BGM ì¬ìƒ ì‹œë„
				try {
					resourceManager.getAudio(U"bgm").setLoop(true);
					resourceManager.getAudio(U"bgm").play();
				}
				catch (const std::exception& e) {
					Print << U"BGM ì¬ìƒ ì˜¤ë¥˜: " << Unicode::Widen(e.what());
				}
			}
			break;

		case GameState::MainMenu:
			if (MouseL.down()) {
				state = GameState::Playing;
			}
			break;

		case GameState::Playing:
			// ê°„ë‹¨í•œ ê²Œì„ ë¡œì§
			if (KeyLeft.pressed()) playerPos.x -= 5;
			if (KeyRight.pressed()) playerPos.x += 5;
			if (KeyUp.pressed()) playerPos.y -= 5;
			if (KeyDown.pressed()) playerPos.y += 5;

			// í™”ë©´ ê²½ê³„ ì²´í¬
			playerPos.x = Clamp(playerPos.x, 30.0, Scene::Width() - 30.0);
			playerPos.y = Clamp(playerPos.y, 30.0, Scene::Height() - 30.0);

			// ì ìˆ˜ ì¦ê°€
			score += Scene::DeltaTime() * 10;

			// ê²Œì„ ì˜¤ë²„ ì¡°ê±´
			if (MouseR.down()) {
				state = GameState::GameOver;

				// íš¨ê³¼ìŒ ì¬ìƒ ì‹œë„
				try {
					resourceManager.getAudio(U"explosion").play();
				}
				catch (const std::exception& e) {
					Print << U"íš¨ê³¼ìŒ ì¬ìƒ ì˜¤ë¥˜: " << Unicode::Widen(e.what());
				}
			}
			break;

		case GameState::GameOver:
			if (MouseL.down()) {
				// ê²Œì„ ì¬ì‹œì‘
				score = 0;
				playerPos = Scene::Center();
				state = GameState::MainMenu;
			}
			break;
		}
	}

	void draw() const {
		switch (state) {
		case GameState::Loading:
			loadingScreen.draw();
			break;

		case GameState::MainMenu:
			// ë°°ê²½
			drawBackground();

			// íƒ€ì´í‹€
			resourceManager.getFont(U"titleFont")(U"ìš°ì£¼ ëª¨í—˜").drawAt(Scene::Center().movedBy(0, -100), ColorF(1.0));
			resourceManager.getFont(U"mainFont")(U"í´ë¦­í•˜ì—¬ ì‹œì‘").drawAt(Scene::Center(), ColorF(1.0, 0.9, 0.6));
			break;

		case GameState::Playing:
			// ë°°ê²½
			drawBackground();

			// ì ìˆ˜
			resourceManager.getFont(U"mainFont")(U"ì ìˆ˜: {:.0f}"_fmt(score)).draw(20, 20, ColorF(1.0));

			// í”Œë ˆì´ì–´
			resourceManager.getTexture(U"player").resized(60).drawAt(playerPos);

			// ì  (ì˜ˆì‹œ)
			for (int i = 0; i < 5; i++) {
				const Vec2 enemyPos(100 + i * 150, 200);
				resourceManager.getTexture(U"enemy").resized(50).drawAt(enemyPos);
			}

			// ì•ˆë‚´ í…ìŠ¤íŠ¸
			resourceManager.getFont(U"mainFont")(U"ë°©í–¥í‚¤ë¡œ ì´ë™, ì˜¤ë¥¸ìª½ í´ë¦­ìœ¼ë¡œ ê²Œì„ ì˜¤ë²„").draw(20, Scene::Height() - 50, ColorF(0.8));
			break;

		case GameState::GameOver:
			// ë°°ê²½
			drawBackground();

			// ê²Œì„ ì˜¤ë²„ í…ìŠ¤íŠ¸
			resourceManager.getFont(U"titleFont")(U"ê²Œì„ ì˜¤ë²„").drawAt(Scene::Center().movedBy(0, -100), ColorF(1.0, 0.3, 0.3));
			resourceManager.getFont(U"mainFont")(U"ìµœì¢… ì ìˆ˜: {:.0f}"_fmt(score)).drawAt(Scene::Center(), ColorF(1.0));
			resourceManager.getFont(U"mainFont")(U"í´ë¦­í•˜ì—¬ ì¬ì‹œì‘").drawAt(Scene::Center().movedBy(0, 100), ColorF(0.8));
			break;
		}
	}

private:
	void drawBackground() const {
		// ë°°ê²½ ê·¸ë¦¬ê¸° (ì—†ìœ¼ë©´ ë‹¨ìƒ‰ ë°°ê²½)
		if (static_cast<bool>(resourceManager.getTexture(U"background"))) {
			resourceManager.getTexture(U"background").resized(Scene::Size()).draw();
		}
		else {
			Scene::Rect().draw(ColorF(0.1, 0.1, 0.2));
		}
	}
};

void Main()
{
	// ì˜ˆì™¸ ì²˜ë¦¬ê°€ ìˆëŠ” ë©”ì¸ í•¨ìˆ˜
	try {
		Game game;

		while (System::Update()) {
			game.update();
			game.draw();
		}
	}
	catch (const std::exception& e) {
		// ì‹¬ê°í•œ ì˜ˆì™¸ ì²˜ë¦¬
		Scene::SetBackground(ColorF(0.3, 0.0, 0.0));
		const Font errorFont(30);

		while (System::Update()) {
			errorFont(U"ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:").draw(20, 50, ColorF(1.0));
			errorFont(Unicode::Widen(e.what())).draw(20, 100, ColorF(1.0, 0.7, 0.7));
			errorFont(U"ê²Œì„ì„ ì¢…ë£Œí•©ë‹ˆë‹¤. ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ì„¸ìš”.").draw(20, 200, ColorF(0.8));

			// í˜„ì¬ í”„ë ˆì„ì— ì…ë ¥ëœ ëª¨ë“  í‚¤ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
			const Array<Input>& allKeys = Keyboard::GetAllInputs();

			// any_ofì™€ ëŒë‹¤ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ .down() ìƒíƒœì¸ í‚¤ê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
			if (allKeys.any([](const Input& key) { return key.down(); }) || MouseL.down())
			{
				break;
			}			
		}
	}
}
```
  


## ê²°ë¡ 
ì´ë²ˆ ë‹¨ê³„ì—ì„œëŠ” C++ì˜ ì˜ˆì™¸ ì²˜ë¦¬ì™€ íŒŒì¼ ì…ì¶œë ¥ ì‹œìŠ¤í…œì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ì•˜ë‹¤. ì´ëŸ¬í•œ ê¸°ëŠ¥ë“¤ì€ ì‹¤ì œ ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ ê°œë°œì—ì„œ ë‹¤ì–‘í•œ ìƒí™©ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ í•„ìˆ˜ì ì¸ ìš”ì†Œì´ë‹¤.  
  
íŠ¹íˆ Siv3Dë¥¼ í™œìš©í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì€ ì‹¤ìš©ì ì¸ ì‹œìŠ¤í…œì„ êµ¬í˜„í•´ ë³´ì•˜ë‹¤:  
  
1. **ê²Œì„ ì €ì¥ ë° ë¶ˆëŸ¬ì˜¤ê¸° ì‹œìŠ¤í…œ**: JSON í˜•ì‹ì„ ì‚¬ìš©í•˜ì—¬ ê²Œì„ ìƒíƒœë¥¼ ì €ì¥í•˜ê³  ë¶ˆëŸ¬ì˜¤ëŠ” ê¸°ëŠ¥
2. **ì„¤ì • íŒŒì¼ ê´€ë¦¬ ì‹œìŠ¤í…œ**: ì‚¬ìš©ì ì„¤ì •ì„ ë³´ê´€í•˜ê³  UIë¥¼ í†µí•´ ë³€ê²½í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥
3. **ë¦¬ì†ŒìŠ¤ ë¡œë”© ì‹œìŠ¤í…œ**: ì˜ˆì™¸ ì²˜ë¦¬ë¥¼ í†µí•´ ì•ˆì „í•˜ê²Œ ê²Œì„ ë¦¬ì†ŒìŠ¤ë¥¼ ë¡œë“œí•˜ëŠ” ê¸°ëŠ¥
  
ì´ëŸ¬í•œ ê¸°ëŠ¥ë“¤ì€ ê±°ì˜ ëª¨ë“  ê²Œì„ê³¼ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ í•„ìš”í•œ ê¸°ì´ˆì ì¸ ìš”ì†Œì´ë©°, ì´ë²ˆ ë‹¨ê³„ì—ì„œ ë°°ìš´ ë‚´ìš©ì„ í™œìš©í•˜ì—¬ ë” ë³µì¡í•˜ê³  ê°•ë ¥í•œ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆë‹¤.  
  
  