# OpenSiv3D를 이용한 C++ 프로그래밍 학습
  
저자: 최흥배, Claude AI  
  
C++ 프로그래밍 언어를 배우는 것에 중점을 두되, Siv3D 프레임워크를 활용하여 시각적으로 흥미로운 예제를 통해 학습 효과를 높이도록 설계 되었다. 단순한 콘솔 프로그램 대신 그래픽, 소리, 상호작용을 포함한 프로그램을 만들며 C++의 개념을 익힐 수 있다.  
  
필요 소프트웨어:  
- Windows 10 이상
- Visual Studio 2022 이상   
  
-----    
    
# Chapter.07: 예외 처리와 파일 입출력
프로그램을 개발할 때 발생할 수 있는 오류를 우아하게 처리하고, 사용자의 데이터를 저장하고 불러오는 기능은 모든 실용적인 애플리케이션의 필수 요소이다. 이번 단계에서는 C++의 예외 처리 메커니즘과 파일 입출력 시스템을 배우고, Siv3D를 활용하여 이를 실제 게임과 애플리케이션에 적용하는 방법을 알아보겠다.
  

## 7.1 C++ 예외 처리

### 1.1 try-catch 구문
예외 처리는 프로그램 실행 중 발생하는 오류를 감지하고 처리하는 메커니즘이다. C++에서는 `try-catch` 블록을 사용한다.

```cpp
try {
    // 예외가 발생할 수 있는 코드
    int denominator = 0;
    if (denominator == 0) {
        throw std::runtime_error("0으로 나눌 수 없습니다.");
    }
    int result = 10 / denominator;
} 
catch (const std::runtime_error& e) {
    // std::runtime_error 타입의 예외 처리
    Print << U"오류 발생: " << Unicode::Widen(e.what());
} 
catch (const std::exception& e) {
    // 기타 std::exception 파생 예외 처리
    Print << U"다른 예외 발생: " << Unicode::Widen(e.what());
} 
catch (...) {
    // 모든 다른 타입의 예외 처리
    Print << U"알 수 없는 예외 발생";
}
```

#### 예외 전파
예외는 호출 스택을 따라 상위 함수로 전파된다. 호출 경로 상의 어떤 함수에서든 예외를 잡아 처리할 수 있다.  
  
```cpp
void funcC() {
    throw std::runtime_error("funcC에서 예외 발생");
}

void funcB() {
    funcC(); // 예외가 여기를 통과하여 상위로 전파됨
}

void funcA() {
    try {
        funcB();
    } catch (const std::exception& e) {
        // funcC에서 발생한 예외가 여기서 잡힘
        Print << U"예외 잡힘: " << Unicode::Widen(e.what());
    }
}
```

### 1.2 예외 클래스
C++ 표준 라이브러리는 다양한 예외 클래스를 제공한다. 모든 표준 예외는 `std::exception` 클래스를 상속한다.

```cpp
// 주요 표준 예외 클래스
// std::exception - 모든 표준 예외의 기본 클래스
// std::runtime_error - 실행 시간에 감지될 수 있는 오류
// std::logic_error - 프로그램의 내부 논리 오류
// std::out_of_range - 범위를 벗어난 접근
// std::invalid_argument - 잘못된 인수
```

#### 사용자 정의 예외 클래스
특정 애플리케이션에 맞는 예외 클래스를 직접 정의할 수 있다.

```cpp
class GameException : public std::exception {
private:
    std::string message;

public:
    GameException(const std::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

// 더 구체적인 게임 예외
class ResourceNotFoundException : public GameException {
public:
    ResourceNotFoundException(const std::string& resourceName)
        : GameException("리소스를 찾을 수 없습니다: " + resourceName) {}
};
```

#### C++23의 예외 기능
C++23에서는 `std::unexpected()`가 도입되어 프로그램의 예외 처리 메커니즘이 개선되었다.
  


## 7.2 C++ 파일 입출력

### 2.1 C++ 스트림
C++에서는 입출력을 스트림(stream) 개념으로 처리한다.

- `iostream`: 콘솔 입출력(`std::cin`, `std::cout`)
- `fstream`: 파일 입출력(`std::ifstream`, `std::ofstream`, `std::fstream`)
- `stringstream`: 문자열 처리(`std::stringstream`, `std::istringstream`, `std::ostringstream`)

### 2.2 파일 입출력 기본

```cpp
#include <fstream>
#include <iostream>
#include <string>

// 파일 쓰기
void writeToFile() {
    std::ofstream outFile("data.txt"); // 파일 열기
    
    if (outFile.is_open()) {
        outFile << "안녕하세요!" << std::endl;
        outFile << 12345 << std::endl;
        outFile << 3.14159 << std::endl;
    } else {
        std::cerr << "파일을 열 수 없습니다." << std::endl;
    }
    
    // 파일은 outFile이 스코프를 벗어날 때 자동으로 닫힘
}

// 파일 읽기
void readFromFile() {
    std::ifstream inFile("data.txt"); // 파일 열기
    
    if (inFile.is_open()) {
        std::string line;
        int number;
        double pi;
        
        std::getline(inFile, line); // 첫 번째 줄 읽기
        inFile >> number;           // 정수 읽기
        inFile >> pi;               // 실수 읽기
        
        std::cout << "읽은 데이터: " << line << ", " << number << ", " << pi << std::endl;
    } else {
        std::cerr << "파일을 열 수 없습니다." << std::endl;
    }
}
```

#### 파일 모드
파일을 열 때 다양한 모드를 지정할 수 있다.

```cpp
// 쓰기 모드 (기존 내용 삭제)
std::ofstream outFile("data.txt", std::ios::out);

// 추가 모드 (기존 내용 유지하고 끝에 추가)
std::ofstream appendFile("data.txt", std::ios::app);

// 읽기 및 쓰기 모드
std::fstream rwFile("data.txt", std::ios::in | std::ios::out);

// 바이너리 모드 (텍스트 변환 없이)
std::ofstream binFile("data.bin", std::ios::binary);
```

### 2.3 바이너리 파일 처리
구조체나 클래스 데이터를 바이너리 형태로 저장/로드할 수 있다.

```cpp
struct PlayerData {
    int level;
    double health;
    char name[20];
};

// 바이너리 파일에 쓰기
void saveBinary() {
    PlayerData player{10, 95.5, "플레이어1"};
    
    std::ofstream outFile("player.dat", std::ios::binary);
    if (outFile) {
        outFile.write(reinterpret_cast<const char*>(&player), sizeof(PlayerData));
    }
}

// 바이너리 파일에서 읽기
void loadBinary() {
    PlayerData player;
    
    std::ifstream inFile("player.dat", std::ios::binary);
    if (inFile) {
        inFile.read(reinterpret_cast<char*>(&player), sizeof(PlayerData));
        std::cout << "플레이어 정보: " << player.name << ", 레벨: " 
                  << player.level << ", 체력: " << player.health << std::endl;
    }
}
```

### 2.4 C++23의 파일 시스템 라이브러리
C++17부터 도입되고 C++23에서 개선된 `<filesystem>` 라이브러리는 파일 및 디렉토리 조작을 위한 강력한 도구를 제공한다.

```cpp
#include <filesystem>
namespace fs = std::filesystem;

void fileSystemDemo() {
    // 현재 경로
    fs::path currentPath = fs::current_path();
    
    // 디렉토리 생성
    fs::create_directory("data");
    
    // 파일 존재 여부 확인
    if (fs::exists("config.txt")) {
        // 파일 크기
        auto fileSize = fs::file_size("config.txt");
        
        // 파일 복사
        fs::copy_file("config.txt", "config_backup.txt", fs::copy_options::overwrite_existing);
    }
    
    // 디렉토리 순회
    for (const auto& entry : fs::directory_iterator(currentPath)) {
        std::cout << entry.path().filename() << std::endl;
    }
}
```
  
### 2.5 std::filesystem 주요 기능 예제

#### 기본 설정
```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;  // 편의를 위한 alias
```

#### 1. 파일/디렉토리 존재 확인 - exists()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    std::string path = "test.txt";
    
    if (fs::exists(path)) {
        std::cout << path << " 파일이 존재한다" << std::endl;
    } else {
        std::cout << path << " 파일이 존재하지 않는다" << std::endl;
    }
    
    return 0;
}
```
**API 설명**: `fs::exists(path)` - 지정된 경로에 파일이나 디렉토리가 존재하는지 확인한다. 존재하면 true, 없으면 false를 반환한다.

#### 2. 파일 타입 확인 - is_regular_file(), is_directory()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    std::string path = "example";
    
    if (fs::exists(path)) {
        if (fs::is_regular_file(path)) {
            std::cout << path << "는 일반 파일이다" << std::endl;
        } else if (fs::is_directory(path)) {
            std::cout << path << "는 디렉토리다" << std::endl;
        }
    }
    
    return 0;
}
```
**API 설명**: 
- `fs::is_regular_file(path)` - 일반 파일인지 확인한다
- `fs::is_directory(path)` - 디렉토리인지 확인한다

#### 3. 디렉토리 생성 - create_directory(), create_directories()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    // 단일 디렉토리 생성
    if (fs::create_directory("new_folder")) {
        std::cout << "new_folder 디렉토리가 생성되었다" << std::endl;
    }
    
    // 중간 경로까지 모두 생성
    if (fs::create_directories("parent/child/grandchild")) {
        std::cout << "중간 경로까지 모두 생성되었다" << std::endl;
    }
    
    return 0;
}
```
**API 설명**:
- `fs::create_directory(path)` - 단일 디렉토리를 생성한다. 부모 디렉토리가 없으면 실패한다
- `fs::create_directories(path)` - 필요한 모든 중간 디렉토리까지 생성한다

#### 4. 파일/디렉토리 삭제 - remove(), remove_all()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    // 단일 파일 또는 빈 디렉토리 삭제
    if (fs::remove("test.txt")) {
        std::cout << "test.txt가 삭제되었다" << std::endl;
    }
    
    // 디렉토리와 모든 내용물 삭제
    std::uintmax_t deletedCount = fs::remove_all("folder_to_delete");
    std::cout << deletedCount << "개의 항목이 삭제되었다" << std::endl;
    
    return 0;
}
```
**API 설명**:
- `fs::remove(path)` - 파일이나 빈 디렉토리를 삭제한다
- `fs::remove_all(path)` - 디렉토리와 모든 내용물을 재귀적으로 삭제한다

#### 5. 파일 복사 - copy_file()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    try {
        fs::copy_file("source.txt", "destination.txt");
        std::cout << "파일이 성공적으로 복사되었다" << std::endl;
    } catch (const fs::filesystem_error& e) {
        std::cout << "복사 실패: " << e.what() << std::endl;
    }
    
    return 0;
}
```
**API 설명**: `fs::copy_file(from, to)` - 파일을 복사한다. 예외가 발생할 수 있으므로 try-catch 사용을 권장한다.

#### 6. 파일 크기 확인 - file_size()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    std::string filename = "test.txt";
    
    if (fs::exists(filename) && fs::is_regular_file(filename)) {
        std::uintmax_t size = fs::file_size(filename);
        std::cout << filename << "의 크기: " << size << " 바이트" << std::endl;
    }
    
    return 0;
}
```
**API 설명**: `fs::file_size(path)` - 파일의 크기를 바이트 단위로 반환한다. 일반 파일에만 사용 가능하다.

#### 7. 현재 작업 디렉토리 - current_path()

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    // 현재 작업 디렉토리 확인
    fs::path currentDir = fs::current_path();
    std::cout << "현재 디렉토리: " << currentDir << std::endl;
    
    // 작업 디렉토리 변경
    fs::current_path("C:/temp");
    std::cout << "변경된 디렉토리: " << fs::current_path() << std::endl;
    
    return 0;
}
```
**API 설명**: 
- `fs::current_path()` - 현재 작업 디렉토리를 반환한다
- `fs::current_path(path)` - 작업 디렉토리를 변경한다

#### 8. 디렉토리 내용물 순회 - directory_iterator

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    std::string dirPath = ".";  // 현재 디렉토리
    
    for (const auto& entry : fs::directory_iterator(dirPath)) {
        std::cout << entry.path().filename() << " - ";
        
        if (entry.is_regular_file()) {
            std::cout << "파일 (" << entry.file_size() << " bytes)";
        } else if (entry.is_directory()) {
            std::cout << "디렉토리";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```
**API 설명**: `fs::directory_iterator(path)` - 디렉토리의 내용물을 순회할 수 있는 반복자를 제공한다.

#### 9. 경로 조작 - path 클래스

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() {
    fs::path filePath = "C:/Users/Documents/test.txt";
    
    std::cout << "전체 경로: " << filePath << std::endl;
    std::cout << "파일명: " << filePath.filename() << std::endl;
    std::cout << "확장자: " << filePath.extension() << std::endl;
    std::cout << "부모 경로: " << filePath.parent_path() << std::endl;
    std::cout << "확장자 제외 이름: " << filePath.stem() << std::endl;
    
    // 경로 결합
    fs::path newPath = fs::path("C:/temp") / "new_file.dat";
    std::cout << "결합된 경로: " << newPath << std::endl;
    
    return 0;
}
```
**API 설명**: 
- `path::filename()` - 파일명 부분 반환
- `path::extension()` - 확장자 반환
- `path::parent_path()` - 부모 디렉토리 경로 반환
- `path::stem()` - 확장자를 제외한 파일명 반환
- `operator/` - 경로를 안전하게 결합한다

#### 10. 재귀적 디렉토리 순회 - recursive_directory_iterator

```cpp
#include <filesystem>
#include <iostream>
namespace fs = std::filesystem;

int main() 
{
    std::string dirPath = ".";
    
    for (const auto& entry : fs::recursive_directory_iterator(dirPath)) {
        // 깊이에 따른 들여쓰기
        int depth = std::distance(fs::path(dirPath).begin(), entry.path().begin()) - 1;
        std::string indent(depth * 2, ' ');
        
        std::cout << indent << entry.path().filename();
        
        if (entry.is_directory()) {
            std::cout << "/";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```
**API 설명**: `fs::recursive_directory_iterator(path)` - 하위 디렉토리까지 재귀적으로 순회하는 반복자를 제공한다.

#### 주의사항
1. **예외 처리**: filesystem 함수들은 예외를 던질 수 있으므로 try-catch 블록 사용을 권장한다
2. **경로 구분자**: `/` 연산자를 사용하면 플랫폼에 맞는 경로 구분자를 자동으로 사용한다
3. **권한**: 파일 시스템 작업 시 적절한 권한이 필요하다
4. **C++17 이상**: std::filesystem은 C++17부터 사용 가능하다
  

  
## 7.3 Siv3D와 함께하는 예외 처리 및 파일 입출력
Siv3D는 파일 입출력과 예외 처리를 보다 간편하게 다룰 수 있는 기능을 제공한다.

### 3.1 Siv3D의 파일 입출력 기능
Siv3D는 텍스트 파일, 바이너리 파일, JSON, CSV, INI 등 다양한 형식의 파일을 쉽게 다룰 수 있는 기능을 제공한다.

#### 텍스트 파일 처리

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 텍스트 파일 쓰기
    TextWriter writer(U"data.txt");
    if (writer) {
        writer << U"Siv3D로 작성한 파일입니다." << U"\n";
        writer << U"숫자: " << 12345 << U"\n";
        writer << U"실수: " << 3.14159;
    }
    
    // 텍스트 파일 읽기
    TextReader reader(U"data.txt");
    if (reader) {
        String line;
        while (reader.readLine(line)) {
            Print << line;
        }
    }
}
```

#### JSON 파일 처리

```cpp
#include <Siv3D.hpp>

void Main()
{
	// JSON 데이터 생성
	JSON json;
	json[U"name"] = U"플레이어1";
	json[U"level"] = 10;
	json[U"health"] = 95.5;
	json[U"items"].push_back(U"검");
	json[U"items"].push_back(U"방패");
	json[U"items"].push_back(U"물약");

	// JSON 파일 저장
	json.save(U"player.json");

	// JSON 파일 로드
	JSON loadedJson = JSON::Load(U"player.json");
	if (loadedJson) {
		Print << U"이름: " << loadedJson[U"name"].getString();
		Print << U"레벨: " << loadedJson[U"level"].get<int>();
		Print << U"체력: " << loadedJson[U"health"].get<double>();
		Print << U"아이템:";

		for (const auto& item : loadedJson[U"items"].arrayView()) {
			Print << U"  - " << item.getString();
		}
	}
}
```

### 3.2 Siv3D 활용 예제: 게임 저장 및 불러오기 시스템
이제 배운 내용을 활용하여 완전한 게임 저장 및 불러오기 시스템을 구현해 보겠다.

```cpp
#include <Siv3D.hpp>

// 저장할 플레이어 데이터를 담는 구조체
// class 대신 간단한 struct를 사용하여 변수에 바로 접근합니다.
struct PlayerData
{
	String name = U"플레이어";
	int32 level = 1;
	Vec2 position = { 400, 300 };
};

void Main()
{
	// 1. 기본 설정
	Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });
	const Font font{ FontMethod::SDF, 40, Typeface::CJK_Regular_KR };
	PlayerData player;

	// 2. 저장/불러오기 버튼
	const Rect saveButton{ 50, 500, 150, 50 };
	const Rect loadButton{ 220, 500, 150, 50 };

	while (System::Update())
	{
		// 3. 데이터 변경 로직 (마우스 클릭 시 레벨 증가 및 위치 변경)
		if (MouseL.down())
		{
			player.level++;
			player.position = Cursor::Pos();
		}

		// 4. 저장 버튼 기능
		if (saveButton.leftClicked())
		{
			// (1) JSON 객체 생성
			JSON json;

			// (2) 데이터 기록: player 데이터 -> json 객체
			json[U"name"] = player.name;
			json[U"level"] = player.level;
			json[U"position"] = player.position; // Vec2도 직접 저장이 가능합니다.

			// (3) 파일로 저장
			json.save(U"save.json");
			Print << U"저장 완료!";
		}

		// 5. 불러오기 버튼 기능
		if (loadButton.leftClicked())
		{
			// (1) JSON 파일 불러오기
			const JSON json = JSON::Load(U"save.json");

			if (json) // 파일이 성공적으로 열렸다면
			{
				// (2) 데이터 읽기: json 객체 -> player 데이터
				player.name = json[U"name"].getString();
				player.level = json[U"level"].get<int32>();
				player.position = json[U"position"].get<Vec2>();
				Print << U"불러오기 완료!";
			}
		}

		// 6. 화면에 현재 데이터 그리기
		font(U"이름: ", player.name).draw(50, 50);
		font(U"레벨: ", player.level).draw(50, 110);
		font(U"위치: ", player.position).draw(50, 170);
		font(U"🖱️ 화면을 클릭하면 레벨과 위치가 바뀝니다.").draw(50, 250);

		// 플레이어 위치에 이모지 표시
		font(U"😀").drawAt(player.position);

		// 버튼 그리기
		saveButton.draw().drawFrame(2, Palette::Black);
		loadButton.draw().drawFrame(2, Palette::Black);
		font(U"저장").drawAt(saveButton.center(), Palette::Black);
		font(U"불러오기").drawAt(loadButton.center(), Palette::Black);
	}
}
```

### 3.3 설정 파일 관리 시스템
이제 게임이나 애플리케이션의 설정을 관리하는 시스템을 만들어 보겠다.

```cpp
#include <Siv3D.hpp>

// 설정 관리 클래스
class ConfigManager 
{
private:
    // 설정 데이터
    struct Config {
        int resolutionWidth = 800;
        int resolutionHeight = 600;
        bool fullscreen = false;
        double masterVolume = 0.8;
        double bgmVolume = 0.7;
        double sfxVolume = 0.9;
        ColorF backgroundColor = ColorF(0.3, 0.4, 0.5);
        String language = U"한국어";
    };
    
    Config currentConfig;
    String configFilePath;
    
public:
    ConfigManager(const String& filename = U"config.json") 
        : configFilePath(filename) {
        loadConfig();
    }
    
    // 설정 저장
    bool saveConfig() {
        try {
            JSON json;
            
            json[U"resolution"][U"width"] = currentConfig.resolutionWidth;
            json[U"resolution"][U"height"] = currentConfig.resolutionHeight;
            json[U"fullscreen"] = currentConfig.fullscreen;
            json[U"volume"][U"master"] = currentConfig.masterVolume;
            json[U"volume"][U"bgm"] = currentConfig.bgmVolume;
            json[U"volume"][U"sfx"] = currentConfig.sfxVolume;
            json[U"backgroundColor"][U"r"] = currentConfig.backgroundColor.r;
            json[U"backgroundColor"][U"g"] = currentConfig.backgroundColor.g;
            json[U"backgroundColor"][U"b"] = currentConfig.backgroundColor.b;
            json[U"language"] = currentConfig.language;
            
            return json.save(configFilePath);
        }
        catch (const std::exception& e) {
            Print << U"설정 저장 오류: " << Unicode::Widen(e.what());
            return false;
        }
    }
    
    // 설정 로드
    bool loadConfig() {
        try {
            if (!FileSystem::Exists(configFilePath)) {
                Print << U"설정 파일이 없습니다. 기본 설정을 사용합니다.";
                return false;
            }
            
            JSON json = JSON::Load(configFilePath);
            
            if (!json) {
                throw std::runtime_error("설정 파일이 손상되었습니다.");
            }
            
            currentConfig.resolutionWidth = json[U"resolution"][U"width"].get<int>();
            currentConfig.resolutionHeight = json[U"resolution"][U"height"].get<int>();
            currentConfig.fullscreen = json[U"fullscreen"].get<bool>();
            currentConfig.masterVolume = json[U"volume"][U"master"].get<double>();
            currentConfig.bgmVolume = json[U"volume"][U"bgm"].get<double>();
            currentConfig.sfxVolume = json[U"volume"][U"sfx"].get<double>();
            currentConfig.backgroundColor.r = json[U"backgroundColor"][U"r"].get<double>();
            currentConfig.backgroundColor.g = json[U"backgroundColor"][U"g"].get<double>();
            currentConfig.backgroundColor.b = json[U"backgroundColor"][U"b"].get<double>();
            currentConfig.language = json[U"language"].getString();
            
            return true;
        }
        catch (const std::exception& e) {
            Print << U"설정 로드 오류: " << Unicode::Widen(e.what());
            return false;
        }
    }
    
    // 기본 설정으로 복원
    void resetToDefaults() {
        currentConfig = Config();
    }
    
    // 설정 접근자
    void setResolution(int width, int height) { 
        currentConfig.resolutionWidth = width; 
        currentConfig.resolutionHeight = height; 
    }
    
    void setFullscreen(bool value) { 
        currentConfig.fullscreen = value; 
    }
    
    void setMasterVolume(double volume) { 
        currentConfig.masterVolume = Clamp(volume, 0.0, 1.0); 
    }
    
    void setBGMVolume(double volume) { 
        currentConfig.bgmVolume = Clamp(volume, 0.0, 1.0); 
    }
    
    void setSFXVolume(double volume) { 
        currentConfig.sfxVolume = Clamp(volume, 0.0, 1.0); 
    }
    
    void setBackgroundColor(const ColorF& color) { 
        currentConfig.backgroundColor = color; 
    }
    
    void setLanguage(const String& lang) { 
        currentConfig.language = lang; 
    }
    
    // 설정 가져오기
    std::pair<int, int> getResolution() const { 
        return {currentConfig.resolutionWidth, currentConfig.resolutionHeight}; 
    }
    
    bool isFullscreen() const { 
        return currentConfig.fullscreen; 
    }
    
    double getMasterVolume() const { 
        return currentConfig.masterVolume; 
    }
    
    double getBGMVolume() const { 
        return currentConfig.bgmVolume; 
    }
    
    double getSFXVolume() const { 
        return currentConfig.sfxVolume; 
    }
    
    ColorF getBackgroundColor() const { 
        return currentConfig.backgroundColor; 
    }
    
    String getLanguage() const { 
        return currentConfig.language; 
    }
    
    // 현재 설정 적용
    void applySettings() {
        Scene::SetBackground(currentConfig.backgroundColor);
        // 실제 애플리케이션에서는 해상도 변경, 볼륨 설정 등의 코드가 여기에 추가됩니다.
    }
};

// 설정 UI 클래스
class SettingsUI {
private:
    ConfigManager& config;
    Font font;
    
    // UI 요소
    Rect fullscreenCheckbox;
    RectF masterVolumeSlider;
    RectF bgmVolumeSlider;
    RectF sfxVolumeSlider;
    RectF saveButton;
    RectF resetButton;
    RectF colorPickerButton;
    Array<RectF> resolutionButtons;
    Array<std::pair<int, int>> resolutions;
    
    // 드래그 상태
    enum class DragState {
        None,
        MasterVolume,
        BGMVolume,
        SFXVolume
    } dragState = DragState::None;
    
    // 색상 선택 활성화 상태
    bool colorPickerActive = false;
    HSV currentColor;
    
public:
    SettingsUI(ConfigManager& configManager)
        : config(configManager) {
        
        const Font font{ FontMethod::SDF, 24, Typeface::CJK_Regular_KR };

        // 해상도 옵션
        resolutions = {
            {800, 600},
            {1024, 768},
            {1280, 720},
            {1920, 1080}
        };
        
        // UI 요소 위치 설정
        for (size_t i = 0; i < resolutions.size(); i++) {
            resolutionButtons << RectF(50, 100 + i * 50, 200, 40);
        }
        
        fullscreenCheckbox = Rect(50, 350, 30, 30);
        
        masterVolumeSlider = RectF(250, 100, 300, 30);
        bgmVolumeSlider = RectF(250, 150, 300, 30);
        sfxVolumeSlider = RectF(250, 200, 300, 30);
        
        colorPickerButton = RectF(50, 400, 200, 40);
        
        saveButton = RectF(400, 500, 120, 50);
        resetButton = RectF(550, 500, 120, 50);
        
        // 현재 설정된 색상
        ColorF bgColor = config.getBackgroundColor();
        currentColor = HSV(bgColor);
    }
    
    void update() {
        // 전체화면 체크박스
        if (fullscreenCheckbox.leftClicked()) {
            config.setFullscreen(!config.isFullscreen());
        }
        
        // 해상도 버튼
        for (size_t i = 0; i < resolutionButtons.size(); i++) {
            if (resolutionButtons[i].leftClicked()) {
                config.setResolution(resolutions[i].first, resolutions[i].second);
            }
        }
        
        // 볼륨 슬라이더 처리
        if (MouseL.down()) {
            if (masterVolumeSlider.mouseOver()) {
                dragState = DragState::MasterVolume;
            }
            else if (bgmVolumeSlider.mouseOver()) {
                dragState = DragState::BGMVolume;
            }
            else if (sfxVolumeSlider.mouseOver()) {
                dragState = DragState::SFXVolume;
            }
        }
        
        if (!MouseL.pressed()) {
            dragState = DragState::None;
        }
        
        if (MouseL.pressed()) {
            double x = Cursor::Pos().x;
            
            switch (dragState) {
            case DragState::MasterVolume:
                config.setMasterVolume((x - masterVolumeSlider.x) / masterVolumeSlider.w);
                break;
            case DragState::BGMVolume:
                config.setBGMVolume((x - bgmVolumeSlider.x) / bgmVolumeSlider.w);
                break;
            case DragState::SFXVolume:
                config.setSFXVolume((x - sfxVolumeSlider.x) / sfxVolumeSlider.w);
                break;
            default:
                break;
            }
        }
        
        // 색상 선택기 버튼
        if (colorPickerButton.leftClicked()) {
            colorPickerActive = !colorPickerActive;
        }
        
        // 색상 선택기 처리
        if (colorPickerActive) {
            if (MouseL.pressed()) {
                // 간단한 HSV 색상 선택
                Rect colorArea(600, 100, 150, 150);
                if (colorArea.mouseOver()) {
                    double s = (Cursor::Pos().x - colorArea.x) / colorArea.w;
                    double v = 1.0 - (Cursor::Pos().y - colorArea.y) / colorArea.h;
                    currentColor.s = s;
                    currentColor.v = v;
                }
                
                // 색상(H) 선택기
                Rect hueArea(600, 260, 150, 20);
                if (hueArea.mouseOver()) {
                    double h = (Cursor::Pos().x - hueArea.x) / hueArea.w;
                    currentColor.h = h;
                }
                
                config.setBackgroundColor(currentColor);
            }
        }
        
        // 저장 버튼
        if (saveButton.leftClicked()) {
            if (config.saveConfig()) {
                config.applySettings();
                Print << U"설정이 저장되었습니다.";
            }
        }
        
        // 초기화 버튼
        if (resetButton.leftClicked()) {
            config.resetToDefaults();
            ColorF bgColor = config.getBackgroundColor();
            currentColor = HSV(bgColor);
        }
    }
    
    void draw() const {
        // 제목
        font(U"설정").draw(50, 50, ColorF(1.0));
        
        // 해상도 섹션
        font(U"해상도").draw(50, 70, ColorF(0.8));
        
        auto currentRes = config.getResolution();
        for (size_t i = 0; i < resolutionButtons.size(); i++) {
            ColorF buttonColor = (currentRes.first == resolutions[i].first && 
                                 currentRes.second == resolutions[i].second) ? 
                                 ColorF(0.3, 0.7, 0.3) : ColorF(0.5);
            
            resolutionButtons[i].draw(buttonColor);
            font(U"{}x{}"_fmt(resolutions[i].first, resolutions[i].second))
                .drawAt(resolutionButtons[i].center(), ColorF(1.0));
        }
        
        // 전체화면 옵션
        font(U"전체화면").draw(100, 350, ColorF(0.8));
        fullscreenCheckbox.draw(ColorF(0.5));
        if (config.isFullscreen()) {
            Line(fullscreenCheckbox.pos, fullscreenCheckbox.br()).draw(3, ColorF(0.2, 0.8, 0.2));
            Line(fullscreenCheckbox.tr(), fullscreenCheckbox.bl()).draw(3, ColorF(0.2, 0.8, 0.2));
        }
        
        // 볼륨 섹션
        font(U"볼륨").draw(250, 70, ColorF(0.8));
        
        // 마스터 볼륨
        font(U"마스터").draw(180, 105, ColorF(0.8));
        masterVolumeSlider.draw(ColorF(0.3));
        RectF(masterVolumeSlider.pos, masterVolumeSlider.w * config.getMasterVolume(), masterVolumeSlider.h)
            .draw(ColorF(0.2, 0.7, 0.3));
            
        // BGM 볼륨
        font(U"배경음").draw(180, 155, ColorF(0.8));
        bgmVolumeSlider.draw(ColorF(0.3));
        RectF(bgmVolumeSlider.pos, bgmVolumeSlider.w * config.getBGMVolume(), bgmVolumeSlider.h)
            .draw(ColorF(0.2, 0.7, 0.3));
            
        // 효과음 볼륨
        font(U"효과음").draw(180, 205, ColorF(0.8));
        sfxVolumeSlider.draw(ColorF(0.3));
        RectF(sfxVolumeSlider.pos, sfxVolumeSlider.w * config.getSFXVolume(), sfxVolumeSlider.h)
            .draw(ColorF(0.2, 0.7, 0.3));
            
        // 배경 색상
        font(U"배경색").draw(50, 400, ColorF(0.8));
        colorPickerButton.draw(config.getBackgroundColor());
        font(U"변경").drawAt(colorPickerButton.center(), ColorF(1.0));
        
        // 색상 선택기
        if (colorPickerActive) {
            Rect colorArea(600, 100, 150, 150);
            Rect hueArea(600, 260, 150, 20);
            
            // HSV 색상 팔레트
            for (int y = 0; y < colorArea.h; y++) {
                for (int x = 0; x < colorArea.w; x++) {
                    double s = static_cast<double>(x) / colorArea.w;
                    double v = 1.0 - static_cast<double>(y) / colorArea.h;
                    HSV pixelColor(currentColor.h, s, v);
                    Rect(colorArea.x + x, colorArea.y + y, 1, 1).draw(pixelColor);
                }
            }
            
            // 색상(H) 선택기
            for (int x = 0; x < hueArea.w; x++) {
                double h = static_cast<double>(x) / hueArea.w;
                Rect(hueArea.x + x, hueArea.y, 1, hueArea.h).draw(HSV(h, 1.0, 1.0));
            }
            
            // 선택된 위치 표시
            Circle(colorArea.x + currentColor.s * colorArea.w, 
                   colorArea.y + (1.0 - currentColor.v) * colorArea.h, 5)
                .drawFrame(2, ColorF(1.0));
                
            Rect(hueArea.x + currentColor.h * hueArea.w - 2, hueArea.y - 5, 4, hueArea.h + 10)
                .draw(ColorF(1.0));
                
            // 현재 선택된 색상 표시
            Rect(600, 290, 150, 30).draw(currentColor);
            font(U"R:{:.2f} G:{:.2f} B:{:.2f}"_fmt(
                currentColor.toColor().r, 
                currentColor.toColor().g, 
                currentColor.toColor().b))
                .draw(600, 330, ColorF(0.8));
        }
        
        // 버튼
        saveButton.draw(ColorF(0.2, 0.6, 0.3));
        font(U"저장").drawAt(saveButton.center(), ColorF(1.0));
        
        resetButton.draw(ColorF(0.6, 0.3, 0.2));
        font(U"초기화").drawAt(resetButton.center(), ColorF(1.0));
    }
};

void Main() {
    // 설정 관리자 생성
    ConfigManager configManager(U"settings.json");
    
    // 현재 설정 적용
    configManager.applySettings();
    
    // 설정 UI 생성
    SettingsUI settingsUI(configManager);
    
    while (System::Update()) {
        settingsUI.update();
        settingsUI.draw();
    }
}
```

### 3.4 예외 처리를 포함한 리소스 로딩 시스템
마지막으로, 게임에서 사용할 리소스(이미지, 사운드, 폰트 등)를 안전하게 로드하는 시스템을 구현해 보겠다.

```cpp
#include <Siv3D.hpp>

// 사용자 정의 예외 클래스
class ResourceException : public std::exception
{
private:
	std::string message;

public:
	ResourceException(const std::string& msg) : message(msg) {}

	const char* what() const noexcept override {
		return message.c_str();
	}
};

// 리소스 타입 열거형
enum class ResourceType
{
	Texture,
	Audio,
	Font,
	Other
};

// 리소스 정보 구조체
struct ResourceInfo
{
	String path;
	ResourceType type;
	bool isRequired;
	String fallbackPath; // 기본 대체 경로
};

// 리소스 관리 클래스
class ResourceManager
{
private:
	// 리소스 컨테이너
	HashTable<String, Texture> textures;
	HashTable<String, Audio> audios;
	HashTable<String, Font> fonts;

	// 로딩 상태
	int totalResources = 0;
	int loadedResources = 0;
	bool isLoading = false;
	Array<String> errors;

	// 리소스 정의
	Array<std::pair<String, ResourceInfo>> resourceDefinitions;

public:
	ResourceManager() = default;

	// 리소스 정의 추가
	void addResourceDefinition(const String& id, const ResourceInfo& info) {
		resourceDefinitions.emplace_back(id, info);
	}

	// 모든 리소스 로드
	bool loadAllResources() {
		isLoading = true;
		totalResources = static_cast<int>(resourceDefinitions.size());
		loadedResources = 0;
		errors.clear();

		for (const auto& [id, info] : resourceDefinitions) {
			try {
				bool success = loadResource(id, info);

				if (!success && info.isRequired) {
					throw ResourceException("필수 리소스 로드 실패: " + Unicode::Narrow(id));
				}
				else if (!success) {
					errors << U"경고: " + id + U" 로드 실패. 대체 리소스 사용";
				}

				loadedResources++;
			}
			catch (const std::exception& e) {
				errors << U"오류: " + Unicode::Widen(e.what());

				if (info.isRequired) {
					isLoading = false;
					return false;
				}
			}
		}

		isLoading = false;
		return true;
	}

	// 단일 리소스 로드
	bool loadResource(const String& id, const ResourceInfo& info) {
		bool success = false;

		switch (info.type) {
		case ResourceType::Texture:
			success = loadTexture(id, info.path, info.fallbackPath);
			break;
		case ResourceType::Audio:
			success = loadAudio(id, info.path, info.fallbackPath);
			break;
		case ResourceType::Font:
			success = loadFont(id, info.path, info.fallbackPath);
			break;
		case ResourceType::Other:
			// 기타 리소스 타입 처리
			success = true;
			break;
		}

		return success;
	}

	// 텍스처 로드
	bool loadTexture(const String& id, const String& path, const String& fallbackPath = U"") {
		try {
			if (!FileSystem::Exists(path)) {
				if (!fallbackPath.isEmpty() && FileSystem::Exists(fallbackPath)) {
					textures[id] = Texture(fallbackPath);
					return true;
				}
				return false;
			}

			textures[id] = Texture(path);
			return static_cast<bool>(textures[id]);
		}
		catch (const std::exception&) {
			// 이모지 등으로 시도
			if (path.starts_with(U"_emoji")) {
				const String emojiText = path.substr(7, path.size() - 8); // "_emoji(" 와 ")" 제외
				textures[id] = Texture(emojiText + U"_emoji");
				return static_cast<bool>(textures[id]);
			}

			if (!fallbackPath.isEmpty()) {
				try {
					textures[id] = Texture(fallbackPath);
					return static_cast<bool>(textures[id]);
				}
				catch (...) {}
			}

			// 기본 텍스처
			textures[id] = Texture(Emoji(U"❓"));
			return false;
		}
	}

	// 오디오 로드
	bool loadAudio(const String& id, const String& path, const String& fallbackPath = U"") {
		try {
			if (!FileSystem::Exists(path)) {
				if (!fallbackPath.isEmpty() && FileSystem::Exists(fallbackPath)) {
					audios[id] = Audio(fallbackPath);
					return true;
				}
				return false;
			}

			audios[id] = Audio(path);
			return static_cast<bool>(audios[id]);
		}
		catch (const std::exception&) {
			if (!fallbackPath.isEmpty()) {
				try {
					audios[id] = Audio(fallbackPath);
					return static_cast<bool>(audios[id]);
				}
				catch (...) {}
			}

			return false;
		}
	}

	// 폰트 로드
	bool loadFont(const String& id, const String& path, const String& fallbackPath = U"") {
		try {
			if (path.isEmpty()) {
				// 기본 폰트
				fonts[id] = Font(30);
				return true;
			}

			if (path.starts_with(U"size=")) {
				// 크기 지정 기본 폰트
				int32 size = Parse<int32>(path.substr(5));
				fonts[id] = Font(size);
				return true;
			}

			if (!FileSystem::Exists(path)) {
				if (!fallbackPath.isEmpty()) {
					fonts[id] = Font(30, fallbackPath);
					return true;
				}

				// 기본 폰트
				fonts[id] = Font(30);
				return true;
			}

			fonts[id] = Font(30, path);
			return static_cast<bool>(fonts[id]);
		}
		catch (const std::exception&) {
			// 기본 폰트
			fonts[id] = Font(30);
			return false;
		}
	}

	// 리소스 가져오기
	const Texture& getTexture(const String& id) const {
		if (textures.contains(id)) {
			return textures.at(id);
		}

		static const Texture defaultTexture(Emoji(U"❓"));
		return defaultTexture;
	}

	const Audio& getAudio(const String& id) const {
		if (audios.contains(id)) {
			return audios.at(id);
		}

		throw ResourceException("오디오 리소스를 찾을 수 없음: " + Unicode::Narrow(id));
	}

	const Font& getFont(const String& id) const {
		if (fonts.contains(id)) {
			return fonts.at(id);
		}

		static const Font defaultFont(30);
		return defaultFont;
	}

	// 로딩 진행 상황
	double getLoadingProgress() const {
		if (totalResources == 0) return 1.0;
		return static_cast<double>(loadedResources) / totalResources;
	}

	// 로딩 중인지 확인
	bool isLoadingInProgress() const {
		return isLoading;
	}

	// 에러 메시지 가져오기
	const Array<String>& getErrors() const {
		return errors;
	}
};

// 로딩 화면 클래스
class LoadingScreen
{
private:
	ResourceManager& resourceManager;
	Font font;
	double timer = 0;

public:
	LoadingScreen(ResourceManager& rm)
		: resourceManager(rm), font(30) {
	}

	bool update() {
		timer += Scene::DeltaTime();

		// 로딩이 완료되면 true 반환
		return !resourceManager.isLoadingInProgress();
	}

	void draw() const {
		// 배경
		Scene::Rect().draw(ColorF(0.1, 0.1, 0.2));

		// 로딩 텍스트
		font(U"리소스 로딩 중...").drawAt(Scene::Center().movedBy(0, -50));

		// 로딩 바
		const double progress = resourceManager.getLoadingProgress();
		const RectF loadingBar(Scene::Width() * 0.2, Scene::Height() * 0.6, Scene::Width() * 0.6, 30);
		loadingBar.draw(ColorF(0.3));
		loadingBar.stretched(-loadingBar.w * (1.0 - progress), 0, 0, 0).draw(ColorF(0.2, 0.6, 0.3));

		// 로딩 애니메이션
		const int dots = static_cast<int>(std::fmod((timer * 2), 4.0));
		String dotsStr;
		for (int i = 0; i < dots; i++) {
			dotsStr += U".";
		}
		font(dotsStr).draw(Scene::Center().x + 120, Scene::Center().y - 50);

		// 백분율 표시
		font(U"{:.0f}%"_fmt(progress * 100)).drawAt(loadingBar.center(), ColorF(1.0));

		// 에러 메시지 표시
		const Array<String>& errors = resourceManager.getErrors();
		for (size_t i = 0; i < Min(errors.size(), size_t(5)); i++) {
			font(errors[i]).draw(20, Scene::Height() * 0.7 + i * 30, ColorF(1.0, 0.3, 0.3));
		}
	}
};

// 게임 클래스
class Game
{
private:
	ResourceManager resourceManager;
	enum class GameState {
		Loading,
		MainMenu,
		Playing,
		GameOver
	} state;

	LoadingScreen loadingScreen;

	// 게임 상태 변수
	Vec2 playerPos;
	double score = 0;

public:
	Game() : loadingScreen(resourceManager), state(GameState::Loading) {
		// 게임에 필요한 리소스 정의
		resourceManager.addResourceDefinition(U"player", {
			U"player.png", ResourceType::Texture, true, U"🚀_emoji"
		});

		resourceManager.addResourceDefinition(U"enemy", {
			U"enemy.png", ResourceType::Texture, true, U"👾_emoji"
		});

		resourceManager.addResourceDefinition(U"background", {
			U"background.jpg", ResourceType::Texture, false, U""
		});

		resourceManager.addResourceDefinition(U"bgm", {
			U"bgm.mp3", ResourceType::Audio, false, U""
		});

		resourceManager.addResourceDefinition(U"explosion", {
			U"explosion.mp3", ResourceType::Audio, false, U""
		});

		resourceManager.addResourceDefinition(U"mainFont", {
			U"font.ttf", ResourceType::Font, false, U""
		});

		resourceManager.addResourceDefinition(U"titleFont", {
			U"size=40", ResourceType::Font, true, U""
		});

		// 리소스 로딩 시작 (별도 스레드에서 로드할 수도 있음)
		std::thread([this]() {
			try {
				resourceManager.loadAllResources();
			}
			catch (const std::exception& e) {
				Print << U"심각한 로딩 오류: " << Unicode::Widen(e.what());
			}
		}).detach();

		// 초기 설정
		playerPos = Scene::Center();
	}

	void update() {
		switch (state) {
		case GameState::Loading:
			if (loadingScreen.update()) {
				state = GameState::MainMenu;

				// 로딩 완료 후 BGM 재생 시도
				try {
					resourceManager.getAudio(U"bgm").setLoop(true);
					resourceManager.getAudio(U"bgm").play();
				}
				catch (const std::exception& e) {
					Print << U"BGM 재생 오류: " << Unicode::Widen(e.what());
				}
			}
			break;

		case GameState::MainMenu:
			if (MouseL.down()) {
				state = GameState::Playing;
			}
			break;

		case GameState::Playing:
			// 간단한 게임 로직
			if (KeyLeft.pressed()) playerPos.x -= 5;
			if (KeyRight.pressed()) playerPos.x += 5;
			if (KeyUp.pressed()) playerPos.y -= 5;
			if (KeyDown.pressed()) playerPos.y += 5;

			// 화면 경계 체크
			playerPos.x = Clamp(playerPos.x, 30.0, Scene::Width() - 30.0);
			playerPos.y = Clamp(playerPos.y, 30.0, Scene::Height() - 30.0);

			// 점수 증가
			score += Scene::DeltaTime() * 10;

			// 게임 오버 조건
			if (MouseR.down()) {
				state = GameState::GameOver;

				// 효과음 재생 시도
				try {
					resourceManager.getAudio(U"explosion").play();
				}
				catch (const std::exception& e) {
					Print << U"효과음 재생 오류: " << Unicode::Widen(e.what());
				}
			}
			break;

		case GameState::GameOver:
			if (MouseL.down()) {
				// 게임 재시작
				score = 0;
				playerPos = Scene::Center();
				state = GameState::MainMenu;
			}
			break;
		}
	}

	void draw() const {
		switch (state) {
		case GameState::Loading:
			loadingScreen.draw();
			break;

		case GameState::MainMenu:
			// 배경
			drawBackground();

			// 타이틀
			resourceManager.getFont(U"titleFont")(U"우주 모험").drawAt(Scene::Center().movedBy(0, -100), ColorF(1.0));
			resourceManager.getFont(U"mainFont")(U"클릭하여 시작").drawAt(Scene::Center(), ColorF(1.0, 0.9, 0.6));
			break;

		case GameState::Playing:
			// 배경
			drawBackground();

			// 점수
			resourceManager.getFont(U"mainFont")(U"점수: {:.0f}"_fmt(score)).draw(20, 20, ColorF(1.0));

			// 플레이어
			resourceManager.getTexture(U"player").resized(60).drawAt(playerPos);

			// 적 (예시)
			for (int i = 0; i < 5; i++) {
				const Vec2 enemyPos(100 + i * 150, 200);
				resourceManager.getTexture(U"enemy").resized(50).drawAt(enemyPos);
			}

			// 안내 텍스트
			resourceManager.getFont(U"mainFont")(U"방향키로 이동, 오른쪽 클릭으로 게임 오버").draw(20, Scene::Height() - 50, ColorF(0.8));
			break;

		case GameState::GameOver:
			// 배경
			drawBackground();

			// 게임 오버 텍스트
			resourceManager.getFont(U"titleFont")(U"게임 오버").drawAt(Scene::Center().movedBy(0, -100), ColorF(1.0, 0.3, 0.3));
			resourceManager.getFont(U"mainFont")(U"최종 점수: {:.0f}"_fmt(score)).drawAt(Scene::Center(), ColorF(1.0));
			resourceManager.getFont(U"mainFont")(U"클릭하여 재시작").drawAt(Scene::Center().movedBy(0, 100), ColorF(0.8));
			break;
		}
	}

private:
	void drawBackground() const {
		// 배경 그리기 (없으면 단색 배경)
		if (static_cast<bool>(resourceManager.getTexture(U"background"))) {
			resourceManager.getTexture(U"background").resized(Scene::Size()).draw();
		}
		else {
			Scene::Rect().draw(ColorF(0.1, 0.1, 0.2));
		}
	}
};

void Main()
{
	// 예외 처리가 있는 메인 함수
	try {
		Game game;

		while (System::Update()) {
			game.update();
			game.draw();
		}
	}
	catch (const std::exception& e) {
		// 심각한 예외 처리
		Scene::SetBackground(ColorF(0.3, 0.0, 0.0));
		const Font errorFont(30);

		while (System::Update()) {
			errorFont(U"심각한 오류가 발생했습니다:").draw(20, 50, ColorF(1.0));
			errorFont(Unicode::Widen(e.what())).draw(20, 100, ColorF(1.0, 0.7, 0.7));
			errorFont(U"게임을 종료합니다. 아무 키나 누르세요.").draw(20, 200, ColorF(0.8));

			// 현재 프레임에 입력된 모든 키를 가져옵니다.
			const Array<Input>& allKeys = Keyboard::GetAllInputs();

			// any_of와 람다 함수를 사용해 .down() 상태인 키가 있는지 확인합니다.
			if (allKeys.any([](const Input& key) { return key.down(); }) || MouseL.down())
			{
				break;
			}			
		}
	}
}
```
  


## 결론
이번 단계에서는 C++의 예외 처리와 파일 입출력 시스템에 대해 자세히 알아보았다. 이러한 기능들은 실제 게임이나 애플리케이션 개발에서 다양한 상황을 처리하기 위한 필수적인 요소이다.  
  
특히 Siv3D를 활용하여 다음과 같은 실용적인 시스템을 구현해 보았다:  
  
1. **게임 저장 및 불러오기 시스템**: JSON 형식을 사용하여 게임 상태를 저장하고 불러오는 기능
2. **설정 파일 관리 시스템**: 사용자 설정을 보관하고 UI를 통해 변경할 수 있는 기능
3. **리소스 로딩 시스템**: 예외 처리를 통해 안전하게 게임 리소스를 로드하는 기능
  
이러한 기능들은 거의 모든 게임과 애플리케이션에서 필요한 기초적인 요소이며, 이번 단계에서 배운 내용을 활용하여 더 복잡하고 강력한 시스템을 구축할 수 있다.  
  
  