# OpenSiv3Dë¥¼ ì´ìš©í•œ C++ í”„ë¡œê·¸ë˜ë° í•™ìŠµ
  
ì €ì: ìµœí¥ë°°, Claude AI  
  
C++ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ë°°ìš°ëŠ” ê²ƒì— ì¤‘ì ì„ ë‘ë˜, Siv3D í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•˜ì—¬ ì‹œê°ì ìœ¼ë¡œ í¥ë¯¸ë¡œìš´ ì˜ˆì œë¥¼ í†µí•´ í•™ìŠµ íš¨ê³¼ë¥¼ ë†’ì´ë„ë¡ ì„¤ê³„ ë˜ì—ˆë‹¤. ë‹¨ìˆœí•œ ì½˜ì†” í”„ë¡œê·¸ë¨ ëŒ€ì‹  ê·¸ë˜í”½, ì†Œë¦¬, ìƒí˜¸ì‘ìš©ì„ í¬í•¨í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ë©° C++ì˜ ê°œë…ì„ ìµí ìˆ˜ ìˆë‹¤.  
  
í•„ìš” ì†Œí”„íŠ¸ì›¨ì–´:  
- Windows 10 ì´ìƒ
- Visual Studio 2022 ì´ìƒ   
  
-----    
    
# Chapter.08: í‘œì¤€ í…œí”Œë¦¿ ë¼ì´ë¸ŒëŸ¬ë¦¬(STL)

## 8.1 STL ê°œìš”
STL(Standard Template Library)ì€ C++ì—ì„œ ì œê³µí•˜ëŠ” ê°•ë ¥í•œ í…œí”Œë¦¿ ê¸°ë°˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‹¤. ì»¨í…Œì´ë„ˆ, ì´í„°ë ˆì´í„°, ì•Œê³ ë¦¬ì¦˜, í•¨ìˆ˜ ê°ì²´ë¡œ êµ¬ì„±ë˜ì–´ ìˆì–´ íš¨ìœ¨ì ì¸ í”„ë¡œê·¸ë˜ë°ì„ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.

<pre>
STL êµ¬ì„± ìš”ì†Œ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        STL                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Containers  â”‚ Iterators   â”‚ Algorithms  â”‚ Functors      â”‚
â”‚ (ì»¨í…Œì´ë„ˆ)   â”‚ (ì´í„°ë ˆì´í„°)  â”‚ (ì•Œê³ ë¦¬ì¦˜)   â”‚ (í•¨ìˆ˜ê°ì²´)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
  

## 8.2 STL ì»¨í…Œì´ë„ˆ

### 2.1 ìˆœì°¨ ì»¨í…Œì´ë„ˆ (Sequence Containers)

#### 2.1.1 vector
vectorëŠ” ë™ì  ë°°ì—´ì„ êµ¬í˜„í•œ ì»¨í…Œì´ë„ˆë¡œ, ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” STL ì»¨í…Œì´ë„ˆ ì¤‘ í•˜ë‚˜ë‹¤.

**ì£¼ìš” íŠ¹ì§•:**
- ì—°ì†ëœ ë©”ëª¨ë¦¬ ê³µê°„ì— ë°ì´í„° ì €ì¥
- ì„ì˜ ì ‘ê·¼(Random Access) ê°€ëŠ¥
- ëë¶€ë¶„ì—ì„œì˜ ì‚½ì…/ì‚­ì œê°€ ë¹ ë¦„ (O(1))
- ì¤‘ê°„ ì‚½ì…/ì‚­ì œëŠ” ëŠë¦¼ (O(n))

**ì˜ˆì œ ì½”ë“œ:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() 
{
    // vector ì„ ì–¸ê³¼ ì´ˆê¸°í™”
    std::vector<int> numbers;
    std::vector<int> scores = {85, 90, 78, 92, 88};
    
    // ìš”ì†Œ ì¶”ê°€
    numbers.push_back(10);
    numbers.push_back(20);
    numbers.push_back(30);
    
    // ìš”ì†Œ ì ‘ê·¼
    std::cout << "ì²« ë²ˆì§¸ ìš”ì†Œ: " << numbers[0] << std::endl;
    std::cout << "ë‘ ë²ˆì§¸ ìš”ì†Œ: " << numbers.at(1) << std::endl;  // ë²”ìœ„ ê²€ì‚¬
    
    // í¬ê¸° ì •ë³´
    std::cout << "í¬ê¸°: " << numbers.size() << std::endl;
    std::cout << "ìš©ëŸ‰: " << numbers.capacity() << std::endl;
    
    // ë°˜ë³µìë¥¼ ì´ìš©í•œ ìˆœíšŒ
    std::cout << "ëª¨ë“  ìš”ì†Œ: ";
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // ë²”ìœ„ ê¸°ë°˜ forë¬¸ (C++11)
    std::cout << "ë²”ìœ„ ê¸°ë°˜ for: ";
    for (const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // ìš”ì†Œ ì‚­ì œ
    numbers.pop_back();  // ë§ˆì§€ë§‰ ìš”ì†Œ ì œê±°
    
    // íŠ¹ì • ìœ„ì¹˜ì— ì‚½ì…
    numbers.insert(numbers.begin() + 1, 15);  // ì¸ë±ìŠ¤ 1ì— 15 ì‚½ì…
    
    // ë²¡í„° ì •ë ¬
    std::sort(scores.begin(), scores.end());
    
    return 0;
}
```

**ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ:**

```cpp
// ê²Œì„ ì„œë²„ì—ì„œ í”Œë ˆì´ì–´ ëª©ë¡ ê´€ë¦¬
#include <vector>
#include <string>

struct Player {
    int id;
    std::string name;
    int level;
    
    Player(int _id, const std::string& _name, int _level) 
        : id(_id), name(_name), level(_level) {}
};

class GameRoom {
private:
    std::vector<Player> players;
    
public:
    void addPlayer(const Player& player) {
        players.push_back(player);
    }
    
    void removePlayer(int playerId) {
        players.erase(
            std::remove_if(players.begin(), players.end(),
                [playerId](const Player& p) { return p.id == playerId; }),
            players.end()
        );
    }
    
    Player* findPlayer(int playerId) {
        auto it = std::find_if(players.begin(), players.end(),
            [playerId](const Player& p) { return p.id == playerId; });
        return (it != players.end()) ? &(*it) : nullptr;
    }
};
```
 
#### 2.1.2 deque
deque(double-ended queue)ëŠ” ì–‘ìª½ ëì—ì„œ ë¹ ë¥¸ ì‚½ì…/ì‚­ì œê°€ ê°€ëŠ¥í•œ ì»¨í…Œì´ë„ˆë‹¤.

**ì£¼ìš” íŠ¹ì§•:**
- ì–‘ìª½ ëì—ì„œì˜ ì‚½ì…/ì‚­ì œê°€ ë¹ ë¦„ (O(1))
- ì„ì˜ ì ‘ê·¼ ê°€ëŠ¥
- ë©”ëª¨ë¦¬ê°€ ì—°ì†ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ
- vectorë³´ë‹¤ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ í´ ìˆ˜ ìˆìŒ

**ì˜ˆì œ ì½”ë“œ:**

```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> dq;
    
    // ì–‘ìª½ ëì— ìš”ì†Œ ì¶”ê°€
    dq.push_back(3);    // ë’¤ì— ì¶”ê°€
    dq.push_back(4);
    dq.push_front(2);   // ì•ì— ì¶”ê°€
    dq.push_front(1);
    
    // ê²°ê³¼: [1, 2, 3, 4]
    
    // ìš”ì†Œ ì ‘ê·¼
    std::cout << "ì²« ë²ˆì§¸: " << dq.front() << std::endl;
    std::cout << "ë§ˆì§€ë§‰: " << dq.back() << std::endl;
    std::cout << "ì¸ë±ìŠ¤ 2: " << dq[2] << std::endl;
    
    // ì–‘ìª½ ëì—ì„œ ìš”ì†Œ ì œê±°
    dq.pop_front();  // ì•ì—ì„œ ì œê±°
    dq.pop_back();   // ë’¤ì—ì„œ ì œê±°
    
    // ìˆœíšŒ
    for (const auto& elem : dq) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ - ë©”ì‹œì§€ í:**

```cpp
#include <deque>
#include <string>

class MessageQueue {
private:
    std::deque<std::string> messages;
    
public:
    // ì¼ë°˜ ë©”ì‹œì§€ëŠ” ë’¤ì— ì¶”ê°€
    void addMessage(const std::string& msg) {
        messages.push_back(msg);
    }
    
    // ê¸´ê¸‰ ë©”ì‹œì§€ëŠ” ì•ì— ì¶”ê°€
    void addUrgentMessage(const std::string& msg) {
        messages.push_front(msg);
    }
    
    std::string getNextMessage() {
        if (messages.empty()) return "";
        
        std::string msg = messages.front();
        messages.pop_front();
        return msg;
    }
    
    bool isEmpty() const {
        return messages.empty();
    }
};
```

#### 2.1.3 list
listëŠ” ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬í˜„ëœ ì»¨í…Œì´ë„ˆë‹¤.

**ì£¼ìš” íŠ¹ì§•:**
- ì–´ëŠ ìœ„ì¹˜ì—ì„œë“  ë¹ ë¥¸ ì‚½ì…/ì‚­ì œ (O(1))
- ì„ì˜ ì ‘ê·¼ ë¶ˆê°€ëŠ¥ (ìˆœì°¨ ì ‘ê·¼ë§Œ ê°€ëŠ¥)
- ë©”ëª¨ë¦¬ê°€ ì—°ì†ë˜ì§€ ì•ŠìŒ
- ê° ë…¸ë“œê°€ ë³„ë„ì˜ ë©”ëª¨ë¦¬ í• ë‹¹

**ì˜ˆì œ ì½”ë“œ:**

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> numbers = {1, 2, 3, 4, 5};
    
    // ìš”ì†Œ ì¶”ê°€
    numbers.push_front(0);    // ì•ì— ì¶”ê°€
    numbers.push_back(6);     // ë’¤ì— ì¶”ê°€
    
    // íŠ¹ì • ìœ„ì¹˜ì— ì‚½ì…
    auto it = numbers.begin();
    std::advance(it, 3);  // 3ë²ˆì§¸ ìœ„ì¹˜ë¡œ ì´ë™
    numbers.insert(it, 99);
    
    // ìˆœíšŒ
    std::cout << "ë¦¬ìŠ¤íŠ¸ ìš”ì†Œ: ";
    for (const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // íŠ¹ì • ê°’ ì œê±°
    numbers.remove(99);  // ê°’ì´ 99ì¸ ëª¨ë“  ìš”ì†Œ ì œê±°
    
    // ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œ ì œê±°
    numbers.remove_if([](int n) { return n % 2 == 0; });  // ì§ìˆ˜ ì œê±°
    
    // ì •ë ¬
    numbers.sort();
    
    // ì¤‘ë³µ ì œê±° (ì •ë ¬ëœ ìƒíƒœì—ì„œ)
    numbers.unique();
    
    std::cout << "ì²˜ë¦¬ í›„: ";
    for (const auto& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ - LRU ìºì‹œ:**

```cpp
#include <list>
#include <unordered_map>

template<typename Key, typename Value>
class LRUCache {
private:
    size_t capacity;
    std::list<std::pair<Key, Value>> items;
    std::unordered_map<Key, typename std::list<std::pair<Key, Value>>::iterator> cache;
    
public:
    LRUCache(size_t cap) : capacity(cap) {}
    
    Value get(const Key& key) {
        auto it = cache.find(key);
        if (it == cache.end()) {
            throw std::runtime_error("Key not found");
        }
        
        // ìµœê·¼ ì‚¬ìš©ìœ¼ë¡œ ì´ë™
        items.splice(items.begin(), items, it->second);
        return it->second->second;
    }
    
    void put(const Key& key, const Value& value) {
        auto it = cache.find(key);
        
        if (it != cache.end()) {
            // ê¸°ì¡´ ê°’ ì—…ë°ì´íŠ¸
            it->second->second = value;
            items.splice(items.begin(), items, it->second);
        } else {
            // ìƒˆ ê°’ ì¶”ê°€
            if (cache.size() >= capacity) {
                // ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±°
                cache.erase(items.back().first);
                items.pop_back();
            }
            
            items.emplace_front(key, value);
            cache[key] = items.begin();
        }
    }
};
```

### 2.2 ì—°ê´€ ì»¨í…Œì´ë„ˆ (Associative Containers)

#### 2.2.1 map
mapì€ í‚¤-ê°’ ìŒì„ ì €ì¥í•˜ëŠ” ì»¨í…Œì´ë„ˆë¡œ, í‚¤ì— ë”°ë¼ ìë™ìœ¼ë¡œ ì •ë ¬ëœë‹¤.

**ì£¼ìš” íŠ¹ì§•:**
- í‚¤ëŠ” ìœ ì¼í•´ì•¼ í•¨
- í‚¤ì— ë”°ë¼ ìë™ ì •ë ¬ (ê¸°ë³¸ì ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ)
- ë‚´ë¶€ì ìœ¼ë¡œ ê· í˜• ì´ì§„ íŠ¸ë¦¬ êµ¬ì¡° (ë³´í†µ Red-Black Tree)
- ê²€ìƒ‰, ì‚½ì…, ì‚­ì œ: O(log n)

**ì˜ˆì œ ì½”ë“œ:**

```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    // map ì„ ì–¸ê³¼ ì´ˆê¸°í™”
    std::map<std::string, int> scores;
    std::map<int, std::string> students = {
        {1, "ê¹€ì² ìˆ˜"},
        {2, "ì´ì˜í¬"},
        {3, "ë°•ë¯¼ìˆ˜"}
    };
    
    // ìš”ì†Œ ì‚½ì…
    scores["ê¹€ì² ìˆ˜"] = 85;
    scores["ì´ì˜í¬"] = 92;
    scores["ë°•ë¯¼ìˆ˜"] = 78;
    
    // insert ì‚¬ìš©
    scores.insert(std::make_pair("ìµœì˜ìˆ˜", 88));
    scores.insert({"í™ê¸¸ë™", 95});  // C++11
    
    // ìš”ì†Œ ì ‘ê·¼
    std::cout << "ê¹€ì² ìˆ˜ì˜ ì ìˆ˜: " << scores["ê¹€ì² ìˆ˜"] << std::endl;
    
    // at() ì‚¬ìš© (í‚¤ê°€ ì—†ìœ¼ë©´ ì˜ˆì™¸ ë°œìƒ)
    try {
        std::cout << "ì´ì˜í¬ì˜ ì ìˆ˜: " << scores.at("ì´ì˜í¬") << std::endl;
    } catch (const std::out_of_range& e) {
        std::cout << "í‚¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ" << std::endl;
    }
    
    // í‚¤ ì¡´ì¬ í™•ì¸
    if (scores.find("ë°•ë¯¼ìˆ˜") != scores.end()) {
        std::cout << "ë°•ë¯¼ìˆ˜ ì¡´ì¬í•¨" << std::endl;
    }
    
    // countë¡œ ì¡´ì¬ í™•ì¸ (mapì—ì„œëŠ” 0 ë˜ëŠ” 1)
    if (scores.count("í™ê¸¸ë™") > 0) {
        std::cout << "í™ê¸¸ë™ ì¡´ì¬í•¨" << std::endl;
    }
    
    // ìˆœíšŒ (í‚¤ ìˆœì„œë¡œ ì •ë ¬ë¨)
    std::cout << "\nëª¨ë“  ì ìˆ˜ (ì •ë ¬ë¨):\n";
    for (const auto& pair : scores) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    
    // ë°˜ë³µì ì‚¬ìš©
    std::cout << "\në°˜ë³µìë¥¼ ì´ìš©í•œ ìˆœíšŒ:\n";
    for (auto it = scores.begin(); it != scores.end(); ++it) {
        std::cout << it->first << ": " << it->second << std::endl;
    }
    
    // ìš”ì†Œ ì œê±°
    scores.erase("ìµœì˜ìˆ˜");  // í‚¤ë¡œ ì œê±°
    
    // ë²”ìœ„ ê²€ìƒ‰
    auto lower = scores.lower_bound("ê¹€");
    auto upper = scores.upper_bound("ì´");
    
    std::cout << "\n'ê¹€'ë¶€í„° 'ì´' ì‚¬ì´:\n";
    for (auto it = lower; it != upper; ++it) {
        std::cout << it->first << ": " << it->second << std::endl;
    }
    
    return 0;
}
```

**ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ - ì„¤ì • ê´€ë¦¬:**

```cpp
#include <map>
#include <string>
#include <iostream>

class ConfigManager {
private:
    std::map<std::string, std::string> config;
    
public:
    void loadConfig() {
        // ì‹¤ì œë¡œëŠ” íŒŒì¼ì—ì„œ ì½ì–´ì˜´
        config["server_ip"] = "127.0.0.1";
        config["server_port"] = "8080";
        config["max_connections"] = "100";
        config["log_level"] = "INFO";
    }
    
    std::string getValue(const std::string& key) const {
        auto it = config.find(key);
        return (it != config.end()) ? it->second : "";
    }
    
    void setValue(const std::string& key, const std::string& value) {
        config[key] = value;
    }
    
    void printAllConfig() const {
        std::cout << "í˜„ì¬ ì„¤ì •:\n";
        for (const auto& pair : config) {
            std::cout << pair.first << " = " << pair.second << std::endl;
        }
    }
    
    bool hasKey(const std::string& key) const {
        return config.find(key) != config.end();
    }
};
```

#### 2.2.2 unordered_map
unordered_mapì€ í•´ì‹œ í…Œì´ë¸”ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ í‚¤-ê°’ ì»¨í…Œì´ë„ˆë‹¤.

**ì£¼ìš” íŠ¹ì§•:**
- í•´ì‹œ í…Œì´ë¸” ê¸°ë°˜ìœ¼ë¡œ ë¹ ë¥¸ ì ‘ê·¼ (í‰ê·  O(1))
- í‚¤ëŠ” ìœ ì¼í•˜ì§€ë§Œ ì •ë ¬ë˜ì§€ ì•ŠìŒ
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ mapë³´ë‹¤ í´ ìˆ˜ ìˆìŒ
- í•´ì‹œ ì¶©ëŒ ì‹œ ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥

**ì˜ˆì œ ì½”ë“œ:**

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, int> wordCount;
    
    // ë‹¨ì–´ ì¹´ìš´íŒ…
    std::string text = "apple banana apple orange banana apple";
    std::string word;
    
    // ê°„ë‹¨í•œ íŒŒì‹± (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ë°©ë²• ì‚¬ìš©)
    std::vector<std::string> words = {"apple", "banana", "apple", "orange", "banana", "apple"};
    
    for (const auto& w : words) {
        wordCount[w]++;  // í‚¤ê°€ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ì´ˆê¸°í™” í›„ ì¦ê°€
    }
    
    // ê²°ê³¼ ì¶œë ¥ (ìˆœì„œëŠ” ë³´ì¥ë˜ì§€ ì•ŠìŒ)
    std::cout << "ë‹¨ì–´ ì¹´ìš´íŠ¸:\n";
    for (const auto& pair : wordCount) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    
    // íŠ¹ì • í‚¤ ê²€ìƒ‰
    auto it = wordCount.find("apple");
    if (it != wordCount.end()) {
        std::cout << "\napple íšŸìˆ˜: " << it->second << std::endl;
    }
    
    // í•´ì‹œ ê´€ë ¨ ì •ë³´
    std::cout << "\ní•´ì‹œ í…Œì´ë¸” ì •ë³´:\n";
    std::cout << "ë²„í‚· ìˆ˜: " << wordCount.bucket_count() << std::endl;
    std::cout << "ë¡œë“œ íŒ©í„°: " << wordCount.load_factor() << std::endl;
    std::cout << "ìµœëŒ€ ë¡œë“œ íŒ©í„°: " << wordCount.max_load_factor() << std::endl;
    
    return 0;
}
```

**ì„±ëŠ¥ ë¹„êµ ì˜ˆì‹œ:**

```cpp
#include <map>
#include <unordered_map>
#include <chrono>
#include <random>

void performanceTest() {
    const int N = 100000;
    std::vector<int> keys(N);
    
    // ëœë¤ í‚¤ ìƒì„±
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 1000000);
    
    for (int i = 0; i < N; ++i) {
        keys[i] = dis(gen);
    }
    
    // map í…ŒìŠ¤íŠ¸
    auto start = std::chrono::high_resolution_clock::now();
    std::map<int, int> m;
    for (int key : keys) {
        m[key]++;
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto map_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // unordered_map í…ŒìŠ¤íŠ¸
    start = std::chrono::high_resolution_clock::now();
    std::unordered_map<int, int> um;
    for (int key : keys) {
        um[key]++;
    }
    end = std::chrono::high_resolution_clock::now();
    auto unordered_map_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "map ì‹œê°„: " << map_time.count() << "ms\n";
    std::cout << "unordered_map ì‹œê°„: " << unordered_map_time.count() << "ms\n";
}
```

#### 2.2.3 setê³¼ unordered_set
setì€ ìœ ì¼í•œ ê°’ë“¤ì˜ ì§‘í•©ì„ ì €ì¥í•˜ëŠ” ì»¨í…Œì´ë„ˆë‹¤.

**ì£¼ìš” íŠ¹ì§•:**
- ëª¨ë“  ê°’ì´ ìœ ì¼í•¨
- set: ìë™ ì •ë ¬ (O(log n))
- unordered_set: í•´ì‹œ ê¸°ë°˜ (í‰ê·  O(1))

**ì˜ˆì œ ì½”ë“œ:**

```cpp
#include <iostream>
#include <set>
#include <unordered_set>
#include <vector>

int main() {
    // set ì˜ˆì œ
    std::set<int> sortedSet = {3, 1, 4, 1, 5, 9, 2, 6};
    
    std::cout << "Set ìš”ì†Œ (ì •ë ¬ë¨): ";
    for (const auto& elem : sortedSet) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    // ìš”ì†Œ ì‚½ì…
    auto result = sortedSet.insert(7);
    if (result.second) {
        std::cout << "7ì´ ì„±ê³µì ìœ¼ë¡œ ì‚½ì…ë¨\n";
    }
    
    // ì¤‘ë³µ ì‚½ì… ì‹œë„
    result = sortedSet.insert(5);  // ì´ë¯¸ ì¡´ì¬
    if (!result.second) {
        std::cout << "5ëŠ” ì´ë¯¸ ì¡´ì¬í•¨\n";
    }
    
    // ìš”ì†Œ ê²€ìƒ‰
    if (sortedSet.find(4) != sortedSet.end()) {
        std::cout << "4ê°€ ì¡´ì¬í•¨\n";
    }
    
    // unordered_set ì˜ˆì œ
    std::unordered_set<std::string> uniqueWords;
    std::vector<std::string> words = {"apple", "banana", "apple", "orange", "banana"};
    
    for (const auto& word : words) {
        uniqueWords.insert(word);
    }
    
    std::cout << "\nìœ ì¼í•œ ë‹¨ì–´ë“¤: ";
    for (const auto& word : uniqueWords) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // ì§‘í•© ì—°ì‚° ì˜ˆì œ
    std::set<int> set1 = {1, 2, 3, 4, 5};
    std::set<int> set2 = {4, 5, 6, 7, 8};
    std::set<int> result_set;
    
    // êµì§‘í•©
    std::set_intersection(set1.begin(), set1.end(),
                         set2.begin(), set2.end(),
                         std::inserter(result_set, result_set.begin()));
    
    std::cout << "\nêµì§‘í•©: ";
    for (const auto& elem : result_set) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ - ì¤‘ë³µ ì œê±°ì™€ ë©¤ë²„ì‹­ í…ŒìŠ¤íŠ¸:**

```cpp
#include <unordered_set>
#include <string>

class UserSession {
private:
    std::unordered_set<int> activeUsers;
    std::unordered_set<std::string> bannedIPs;
    
public:
    bool loginUser(int userId, const std::string& ip) {
        // IP ì°¨ë‹¨ í™•ì¸
        if (bannedIPs.find(ip) != bannedIPs.end()) {
            return false;  // ì°¨ë‹¨ëœ IP
        }
        
        // ì¤‘ë³µ ë¡œê·¸ì¸ í™•ì¸
        if (activeUsers.find(userId) != activeUsers.end()) {
            return false;  // ì´ë¯¸ ë¡œê·¸ì¸ë¨
        }
        
        activeUsers.insert(userId);
        return true;
    }
    
    void logoutUser(int userId) {
        activeUsers.erase(userId);
    }
    
    bool isUserActive(int userId) const {
        return activeUsers.find(userId) != activeUsers.end();
    }
    
    void banIP(const std::string& ip) {
        bannedIPs.insert(ip);
    }
    
    size_t getActiveUserCount() const {
        return activeUsers.size();
    }
};
```

## 8.3 ì´í„°ë ˆì´í„°(Iterators)
ì´í„°ë ˆì´í„°ëŠ” ì»¨í…Œì´ë„ˆì˜ ìš”ì†Œë“¤ì„ ìˆœíšŒí•˜ê³  ì ‘ê·¼í•˜ëŠ” ì¼ë°˜í™”ëœ ë°©ë²•ì„ ì œê³µí•œë‹¤.

```mermaid
graph TD
    A[ì´í„°ë ˆì´í„° ê³„ì¸µêµ¬ì¡°] --> B[Input Iterator]
    A --> C[Output Iterator]
    B --> D[Forward Iterator]
    D --> E[Bidirectional Iterator]
    E --> F[Random Access Iterator]
    
    B --> G[istream_iterator]
    C --> H[ostream_iterator]
    D --> I[forward_list::iterator]
    E --> J[list::iterator, set::iterator]
    F --> K[vector::iterator, deque::iterator]
```

**ì´í„°ë ˆì´í„° ì¢…ë¥˜ì™€ íŠ¹ì§•:**

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <iterator>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<int> lst = {10, 20, 30, 40, 50};
    
    // 1. ê¸°ë³¸ ì´í„°ë ˆì´í„° ì‚¬ìš©
    std::cout << "Vector (Random Access Iterator):\n";
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 2. ì—­ë°©í–¥ ì´í„°ë ˆì´í„°
    std::cout << "Vector ì—­ìˆœ:\n";
    for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 3. const ì´í„°ë ˆì´í„°
    std::cout << "List (Bidirectional Iterator):\n";
    for (auto it = lst.cbegin(); it != lst.cend(); ++it) {
        std::cout << *it << " ";
        // *it = 100;  // ì»´íŒŒì¼ ì—ëŸ¬ (const)
    }
    std::cout << std::endl;
    
    // 4. ì´í„°ë ˆì´í„° ì—°ì‚°
    auto it = vec.begin();
    std::advance(it, 2);  // 2ì¹¸ ì „ì§„
    std::cout << "3ë²ˆì§¸ ìš”ì†Œ: " << *it << std::endl;
    
    // Random Access Iteratorë§Œ ê°€ëŠ¥í•œ ì—°ì‚°
    auto it2 = vec.begin() + 3;  // ì§ì ‘ ì´ë™
    std::cout << "4ë²ˆì§¸ ìš”ì†Œ: " << *it2 << std::endl;
    std::cout << "ê±°ë¦¬: " << std::distance(vec.begin(), it2) << std::endl;
    
    // 5. ì‚½ì… ì´í„°ë ˆì´í„°
    std::vector<int> dest;
    std::copy(vec.begin(), vec.end(), std::back_inserter(dest));
    
    std::cout << "ë³µì‚¬ëœ ë²¡í„°: ";
    for (const auto& val : dest) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ - ì•ˆì „í•œ ì´í„°ë ˆì´í„° ì‚¬ìš©:**

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

class SafeVector {
private:
    std::vector<int> data;
    
public:
    // ì•ˆì „í•œ ìš”ì†Œ ì œê±°
    void removeEvenNumbers() {
        // ì˜¬ë°”ë¥¸ ë°©ë²•: erase-remove ê´€ìš©êµ¬
        data.erase(
            std::remove_if(data.begin(), data.end(),
                [](int n) { return n % 2 == 0; }),
            data.end()
        );
    }
    
    // ì˜ëª»ëœ ë°©ë²• (ì°¸ê³ ìš©)
    void removeEvenNumbersWrong() {
        for (auto it = data.begin(); it != data.end(); ++it) {
            if (*it % 2 == 0) {
                data.erase(it);  // ìœ„í—˜! ì´í„°ë ˆì´í„° ë¬´íš¨í™”
                // --it;  // ì´ê²ƒë„ ìœ„í—˜í•  ìˆ˜ ìˆìŒ
            }
        }
    }
    
    // ì˜¬ë°”ë¥¸ ì‚­ì œ ë°©ë²•
    void removeEvenNumbersCorrect() {
        for (auto it = data.begin(); it != data.end(); ) {
            if (*it % 2 == 0) {
                it = data.erase(it);  // eraseëŠ” ë‹¤ìŒ ìœ íš¨í•œ ì´í„°ë ˆì´í„° ë°˜í™˜
            } else {
                ++it;
            }
        }
    }
    
    void addNumber(int n) { data.push_back(n); }
    
    void print() const {
        for (const auto& n : data) {
            std::cout << n << " ";
        }
        std::cout << std::endl;
    }
};
```

## 8.4 STL ì•Œê³ ë¦¬ì¦˜
STL ì•Œê³ ë¦¬ì¦˜ì€ ì»¨í…Œì´ë„ˆì— ë…ë¦½ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” í•¨ìˆ˜ë“¤ì˜ ì§‘í•©ì´ë‹¤.

**ì£¼ìš” ì•Œê³ ë¦¬ì¦˜ ë¶„ë¥˜:**

```
STL ì•Œê³ ë¦¬ì¦˜
â”œâ”€â”€ ë³€ê²½í•˜ì§€ ì•ŠëŠ” ì•Œê³ ë¦¬ì¦˜
â”‚   â”œâ”€â”€ find, find_if
â”‚   â”œâ”€â”€ count, count_if
â”‚   â”œâ”€â”€ search, binary_search
â”‚   â””â”€â”€ equal, mismatch
â”œâ”€â”€ ë³€ê²½í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
â”‚   â”œâ”€â”€ copy, copy_if
â”‚   â”œâ”€â”€ transform
â”‚   â”œâ”€â”€ replace, replace_if
â”‚   â””â”€â”€ remove, remove_if
â”œâ”€â”€ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
â”‚   â”œâ”€â”€ sort, stable_sort
â”‚   â”œâ”€â”€ partial_sort
â”‚   â””â”€â”€ nth_element
â””â”€â”€ ì§‘í•© ì•Œê³ ë¦¬ì¦˜
    â”œâ”€â”€ set_union
    â”œâ”€â”€ set_intersection
    â””â”€â”€ set_difference
```

**ì˜ˆì œ ì½”ë“œ:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <functional>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3};
    std::vector<int> result;
    
    // 1. ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜
    auto it = std::find(numbers.begin(), numbers.end(), 8);
    if (it != numbers.end()) {
        std::cout << "8ì„ ì°¾ìŒ, ìœ„ì¹˜: " << std::distance(numbers.begin(), it) << std::endl;
    }
    
    // ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì²« ë²ˆì§¸ ìš”ì†Œ ì°¾ê¸°
    auto it2 = std::find_if(numbers.begin(), numbers.end(), 
                           [](int n) { return n > 5; });
    if (it2 != numbers.end()) {
        std::cout << "5ë³´ë‹¤ í° ì²« ë²ˆì§¸ ìˆ˜: " << *it2 << std::endl;
    }
    
    // 2. ì¹´ìš´íŒ…
    int count_greater_5 = std::count_if(numbers.begin(), numbers.end(),
                                       [](int n) { return n > 5; });
    std::cout << "5ë³´ë‹¤ í° ìˆ˜ì˜ ê°œìˆ˜: " << count_greater_5 << std::endl;
    
    // 3. ì •ë ¬
    std::vector<int> sorted_nums = numbers;
    std::sort(sorted_nums.begin(), sorted_nums.end());
    
    std::cout << "ì •ë ¬ëœ ìˆ˜ì—´: ";
    for (const auto& n : sorted_nums) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
    std::sort(sorted_nums.begin(), sorted_nums.end(), std::greater<int>());
    
    std::cout << "ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬: ";
    for (const auto& n : sorted_nums) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // 4. ë³€í™˜
    std::vector<int> doubled;
    std::transform(numbers.begin(), numbers.end(), std::back_inserter(doubled),
                  [](int n) { return n * 2; });
    
    std::cout << "ë‘ ë°°ë¡œ ë§Œë“  ìˆ˜ì—´: ";
    for (const auto& n : doubled) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // 5. ëˆ„ì  ì—°ì‚°
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    std::cout << "í•©ê³„: " << sum << std::endl;
    
    int product = std::accumulate(numbers.begin(), numbers.end(), 1, 
                                 std::multiplies<int>());
    std::cout << "ê³±: " << product << std::endl;
    
    // 6. ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìš”ì†Œ ë³µì‚¬
    std::vector<int> evens;
    std::copy_if(numbers.begin(), numbers.end(), std::back_inserter(evens),
                [](int n) { return n % 2 == 0; });
    
    std::cout << "ì§ìˆ˜ë“¤: ";
    for (const auto& n : evens) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // 7. ëª¨ë“ /ì¼ë¶€ ì¡°ê±´ ê²€ì‚¬
    bool all_positive = std::all_of(numbers.begin(), numbers.end(),
                                   [](int n) { return n > 0; });
    std::cout << "ëª¨ë“  ìˆ˜ê°€ ì–‘ìˆ˜ì¸ê°€? " << (all_positive ? "ì˜ˆ" : "ì•„ë‹ˆì˜¤") << std::endl;
    
    bool any_greater_7 = std::any_of(numbers.begin(), numbers.end(),
                                    [](int n) { return n > 7; });
    std::cout << "7ë³´ë‹¤ í° ìˆ˜ê°€ ìˆëŠ”ê°€? " << (any_greater_7 ? "ì˜ˆ" : "ì•„ë‹ˆì˜¤") << std::endl;
    
    return 0;
}
```

**ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ - ë°ì´í„° ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸:**

```cpp
#include <vector>
#include <string>
#include <algorithm>
#include <numeric>

struct Player {
    int id;
    std::string name;
    int level;
    int score;
    
    Player(int _id, const std::string& _name, int _level, int _score)
        : id(_id), name(_name), level(_level), score(_score) {}
};

class PlayerAnalyzer {
private:
    std::vector<Player> players;
    
public:
    void addPlayer(const Player& player) {
        players.push_back(player);
    }
    
    // ë ˆë²¨ë³„ ìƒìœ„ í”Œë ˆì´ì–´ ì°¾ê¸°
    std::vector<Player> getTopPlayersByLevel(int minLevel, int topN) {
        std::vector<Player> filtered;
        
        // 1. ìµœì†Œ ë ˆë²¨ ì´ìƒì¸ í”Œë ˆì´ì–´ í•„í„°ë§
        std::copy_if(players.begin(), players.end(), 
                    std::back_inserter(filtered),
                    [minLevel](const Player& p) { return p.level >= minLevel; });
        
        // 2. ì ìˆ˜ ê¸°ì¤€ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
        std::sort(filtered.begin(), filtered.end(),
                 [](const Player& a, const Player& b) { 
                     return a.score > b.score; 
                 });
        
        // 3. ìƒìœ„ Nëª…ë§Œ ì„ íƒ
        if (filtered.size() > topN) {
            filtered.resize(topN);
        }
        
        return filtered;
    }
    
    // í†µê³„ ê³„ì‚°
    struct PlayerStats {
        double avgLevel;
        double avgScore;
        int maxScore;
        int minScore;
        size_t totalPlayers;
    };
    
    PlayerStats calculateStats() const {
        if (players.empty()) {
            return {0, 0, 0, 0, 0};
        }
        
        PlayerStats stats;
        
        // í‰ê·  ë ˆë²¨
        stats.avgLevel = std::accumulate(players.begin(), players.end(), 0.0,
            [](double sum, const Player& p) { return sum + p.level; }) / players.size();
        
        // í‰ê·  ì ìˆ˜
        stats.avgScore = std::accumulate(players.begin(), players.end(), 0.0,
            [](double sum, const Player& p) { return sum + p.score; }) / players.size();
        
        // ìµœëŒ€/ìµœì†Œ ì ìˆ˜
        auto minMaxScore = std::minmax_element(players.begin(), players.end(),
            [](const Player& a, const Player& b) { return a.score < b.score; });
        
        stats.minScore = minMaxScore.first->score;
        stats.maxScore = minMaxScore.second->score;
        stats.totalPlayers = players.size();
        
        return stats;
    }
    
    // ë ˆë²¨ ë¶„í¬ ê³„ì‚°
    std::map<int, int> getLevelDistribution() const {
        std::map<int, int> distribution;
        
        std::for_each(players.begin(), players.end(),
            [&distribution](const Player& p) {
                distribution[p.level]++;
            });
        
        return distribution;
    }
};
```
  

## 8.5 í•¨ìˆ˜ ê°ì²´(Functors)
í•¨ìˆ˜ ê°ì²´ëŠ” í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ê°ì²´ë¡œ, operator()ë¥¼ ì •ì˜í•œ í´ë˜ìŠ¤ë‚˜ ëŒë‹¤ í•¨ìˆ˜ë¥¼ ë§í•œë‹¤.

**í•¨ìˆ˜ ê°ì²´ì˜ ì¢…ë¥˜:**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

// 1. í•¨ìˆ˜ ê°ì²´ í´ë˜ìŠ¤
class Multiply {
private:
    int factor;
    
public:
    Multiply(int f) : factor(f) {}
    
    int operator()(int x) const {
        return x * factor;
    }
};

// 2. ì¡°ê±´ì(Predicate) í•¨ìˆ˜ ê°ì²´
class IsEven {
public:
    bool operator()(int x) const {
        return x % 2 == 0;
    }
};

class IsGreaterThan {
private:
    int threshold;
    
public:
    IsGreaterThan(int t) : threshold(t) {}
    
    bool operator()(int x) const {
        return x > threshold;
    }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 1. í•¨ìˆ˜ ê°ì²´ ì‚¬ìš©
    Multiply multiplyBy3(3);
    std::vector<int> tripled;
    
    std::transform(numbers.begin(), numbers.end(), 
                  std::back_inserter(tripled), multiplyBy3);
    
    std::cout << "3ë°° ìˆ˜ì—´: ";
    for (const auto& n : tripled) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // 2. ì¡°ê±´ì ì‚¬ìš©
    IsEven isEven;
    int evenCount = std::count_if(numbers.begin(), numbers.end(), isEven);
    std::cout << "ì§ìˆ˜ ê°œìˆ˜: " << evenCount << std::endl;
    
    IsGreaterThan greaterThan5(5);
    int countGreater5 = std::count_if(numbers.begin(), numbers.end(), greaterThan5);
    std::cout << "5ë³´ë‹¤ í° ìˆ˜ ê°œìˆ˜: " << countGreater5 << std::endl;
    
    // 3. í‘œì¤€ í•¨ìˆ˜ ê°ì²´ ì‚¬ìš©
    std::sort(numbers.begin(), numbers.end(), std::greater<int>());
    std::cout << "ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬: ";
    for (const auto& n : numbers) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // 4. ëŒë‹¤ í•¨ìˆ˜ (C++11)
    std::vector<int> filtered;
    std::copy_if(numbers.begin(), numbers.end(), 
                std::back_inserter(filtered),
                [](int x) { return x % 3 == 0; });  // 3ì˜ ë°°ìˆ˜ë§Œ
    
    std::cout << "3ì˜ ë°°ìˆ˜: ";
    for (const auto& n : filtered) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    // 5. ìº¡ì²˜ë¥¼ ì‚¬ìš©í•œ ëŒë‹¤
    int multiplier = 4;
    std::vector<int> quadrupled;
    
    std::transform(numbers.begin(), numbers.end(),
                  std::back_inserter(quadrupled),
                  [multiplier](int x) { return x * multiplier; });
    
    std::cout << "4ë°° ìˆ˜ì—´: ";
    for (const auto& n : quadrupled) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**std::function ì‚¬ìš©:**

```cpp
#include <functional>
#include <iostream>
#include <vector>

// ë‹¤ì–‘í•œ í•¨ìˆ˜ íƒ€ì…ì„ ì €ì¥í•  ìˆ˜ ìˆëŠ” ì»¨í…Œì´ë„ˆ
class Calculator {
private:
    std::vector<std::function<int(int, int)>> operations;
    
public:
    void addOperation(std::function<int(int, int)> op) {
        operations.push_back(op);
    }
    
    void performOperations(int a, int b) {
        for (size_t i = 0; i < operations.size(); ++i) {
            std::cout << "ì—°ì‚° " << i + 1 << " ê²°ê³¼: " 
                      << operations[i](a, b) << std::endl;
        }
    }
};

// ì¼ë°˜ í•¨ìˆ˜
int add(int a, int b) {
    return a + b;
}

// í•¨ìˆ˜ ê°ì²´
class Multiply {
public:
    int operator()(int a, int b) const {
        return a * b;
    }
};

int main() {
    Calculator calc;
    
    // ì¼ë°˜ í•¨ìˆ˜ ì¶”ê°€
    calc.addOperation(add);
    
    // í•¨ìˆ˜ ê°ì²´ ì¶”ê°€
    calc.addOperation(Multiply());
    
    // ëŒë‹¤ í•¨ìˆ˜ ì¶”ê°€
    calc.addOperation([](int a, int b) { return a - b; });
    
    // ìº¡ì²˜ ìˆëŠ” ëŒë‹¤ ì¶”ê°€
    int divisor = 2;
    calc.addOperation([divisor](int a, int b) { return (a + b) / divisor; });
    
    calc.performOperations(10, 5);
    
    return 0;
}
```

**ì‹¤ë¬´ í™œìš© ì˜ˆì‹œ - ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ:**

```cpp
#include <functional>
#include <vector>
#include <string>
#include <iostream>

class EventSystem {
public:
    using EventHandler = std::function<void(const std::string&)>;
    
private:
    std::vector<EventHandler> handlers;
    
public:
    void subscribe(EventHandler handler) {
        handlers.push_back(handler);
    }
    
    void publish(const std::string& message) {
        for (const auto& handler : handlers) {
            handler(message);
        }
    }
};

class Logger {
public:
    void log(const std::string& message) {
        std::cout << "[LOG] " << message << std::endl;
    }
};

class EmailNotifier {
private:
    std::string recipient;
    
public:
    EmailNotifier(const std::string& email) : recipient(email) {}
    
    void sendEmail(const std::string& message) {
        std::cout << "[EMAIL to " << recipient << "] " << message << std::endl;
    }
};

int main() {
    EventSystem eventSystem;
    Logger logger;
    EmailNotifier emailer("admin@game.com");
    
    // ë‹¤ì–‘í•œ í•¸ë“¤ëŸ¬ ë“±ë¡
    eventSystem.subscribe([&logger](const std::string& msg) {
        logger.log(msg);
    });
    
    eventSystem.subscribe([&emailer](const std::string& msg) {
        emailer.sendEmail(msg);
    });
    
    eventSystem.subscribe([](const std::string& msg) {
        std::cout << "[CONSOLE] " << msg << std::endl;
    });
    
    // ì´ë²¤íŠ¸ ë°œìƒ
    eventSystem.publish("Server started successfully!");
    eventSystem.publish("Warning: High memory usage detected!");
    
    return 0;
}
```


## 8.6 ì‹¤ìš©ì ì¸ STL í™œìš© ì˜ˆì œ

### 6.1 STLì„ í™œìš©í•œ ê²Œì„ ì˜¤ë¸Œì íŠ¸ ê´€ë¦¬

```cpp
#include <vector>
#include <memory>
#include <algorithm>
#include <Siv3D.hpp>

// ê²Œì„ ì˜¤ë¸Œì íŠ¸ ê¸°ë³¸ í´ë˜ìŠ¤
class GameObject {
protected:
    Vec2 position;
    ColorF color;
    double radius;
    bool active = true;

public:
    GameObject(const Vec2& pos, const ColorF& col, double r)
        : position(pos), color(col), radius(r) {}
    
    virtual ~GameObject() = default;
    
    virtual void update() {
        // ê¸°ë³¸ ì—…ë°ì´íŠ¸ ë¡œì§
    }
    
    virtual void draw() const {
        Circle(position, radius).draw(color);
    }
    
    bool isActive() const {
        return active;
    }
    
    void setActive(bool value) {
        active = value;
    }
    
    const Vec2& getPosition() const {
        return position;
    }
    
    double getRadius() const {
        return radius;
    }
    
    bool intersects(const GameObject& other) const {
        return (position.distanceFrom(other.position) < (radius + other.radius));
    }
};

// í”Œë ˆì´ì–´ í´ë˜ìŠ¤
class Player : public GameObject {
private:
    double speed = 3.0;

public:
    Player(const Vec2& pos)
        : GameObject(pos, ColorF(0.2, 0.6, 0.9), 20) {}
    
    void update() override {
        Vec2 direction(0, 0);
        
        if (KeyLeft.pressed()) direction.x -= 1;
        if (KeyRight.pressed()) direction.x += 1;
        if (KeyUp.pressed()) direction.y -= 1;
        if (KeyDown.pressed()) direction.y += 1;
        
        if (!direction.isZero()) {
            direction = direction.normalized();
            position += direction * speed;
        }
        
        // í™”ë©´ ê²½ê³„ ì²˜ë¦¬
        position.x = Clamp(position.x, radius, 800 - radius);
        position.y = Clamp(position.y, radius, 600 - radius);
    }
    
    void draw() const override {
        Circle(position, radius).draw(color);
        
        // í”Œë ˆì´ì–´ ëˆˆ
        Circle(position.movedBy(-7, -5), 3).draw(ColorF(1.0));
        Circle(position.movedBy(7, -5), 3).draw(ColorF(1.0));        
    }
};

// ì  í´ë˜ìŠ¤
class Enemy : public GameObject {
private:
    Vec2 velocity;
    double speed;

public:
    Enemy(const Vec2& pos, double s)
        : GameObject(pos, ColorF(0.9, 0.3, 0.3), 15), speed(s) {
        // ëœë¤ ë°©í–¥ìœ¼ë¡œ ì´ë™
        double angle = Random(0.0, Math::TwoPi);
        velocity = Vec2(std::cos(angle), std::sin(angle)) * speed;
    }
    
    void update() override {
        position += velocity;
        
        // í™”ë©´ ê²½ê³„ì— ë¶€ë”ªíˆë©´ ë°˜ì‚¬
        if (position.x < radius || position.x > 800 - radius) {
            velocity.x *= -1;
            position.x = Clamp(position.x, radius, 800 - radius);
        }
        
        if (position.y < radius || position.y > 600 - radius) {
            velocity.y *= -1;
            position.y = Clamp(position.y, radius, 600 - radius);
        }
    }
    
    void draw() const override {
        // ì  ê·¸ë¦¬ê¸°
        Circle(position, radius).draw(color);
        
        // ëˆˆ
        Circle(position.movedBy(-5, -3), 2).draw(ColorF(1.0));
        Circle(position.movedBy(5, -3), 2).draw(ColorF(1.0));        
    }
};

// ì•„ì´í…œ í´ë˜ìŠ¤
class Item : public GameObject {
private:
    double rotationAngle = 0;

public:
    Item(const Vec2& pos)
        : GameObject(pos, ColorF(0.9, 0.9, 0.3), 10) {}
    
    void update() override {
        rotationAngle += 0.02;
    }
    
    void draw() const override {
        Circle(position, radius).draw(color);
        
        // ë³„ ëª¨ì–‘ í‘œì‹œ
        for (int i = 0; i < 5; i++) {
            double angle = rotationAngle + (i * Math::TwoPi / 5);
            Vec2 starPoint = position + Vec2(std::cos(angle), std::sin(angle)) * (radius * 0.7);
            Vec2 nextPoint = position + Vec2(std::cos(angle + Math::TwoPi / 10), std::sin(angle + Math::TwoPi / 10)) * (radius * 0.3);
            
            Line(position, starPoint).draw(2, ColorF(1.0, 0.8, 0.0));
            Line(starPoint, nextPoint).draw(2, ColorF(1.0, 0.8, 0.0));
        }
    }
};

// ê²Œì„ ì›”ë“œ í´ë˜ìŠ¤
class GameWorld {
private:
    std::vector<std::unique_ptr<GameObject>> objects;
    Player* playerPtr = nullptr; // í”Œë ˆì´ì–´ì— ëŒ€í•œ í¬ì¸í„° (ì†Œìœ ê¶Œì€ objectsê°€ ê°€ì§)
    int score = 0;
    
public:
    GameWorld() {
        // í”Œë ˆì´ì–´ ìƒì„±
        auto player = std::make_unique<Player>(Scene::Center());
        playerPtr = player.get(); // í¬ì¸í„° ì €ì¥
        objects.push_back(std::move(player));
        
        // ì´ˆê¸° ì  ìƒì„±
        for (int i = 0; i < 5; ++i) {
            spawnEnemy();
        }
        
        // ì´ˆê¸° ì•„ì´í…œ ìƒì„±
        for (int i = 0; i < 3; ++i) {
            spawnItem();
        }
    }
    
    void update() {
        // ëª¨ë“  ì˜¤ë¸Œì íŠ¸ ì—…ë°ì´íŠ¸
        for (auto& obj : objects) {
            if (obj->isActive()) {
                obj->update();
            }
        }
        
        // ì¶©ëŒ ê²€ì‚¬
        for (size_t i = 1; i < objects.size(); ++i) { // 1ë¶€í„° ì‹œì‘ (0ì€ í”Œë ˆì´ì–´)
            if (objects[i]->isActive() && playerPtr->intersects(*objects[i])) {
                if (dynamic_cast<Enemy*>(objects[i].get())) {
                    // ì ê³¼ ì¶©ëŒ
                    objects[i]->setActive(false);
                    score -= 100;
                    
                    // ì  ì¬ìƒì„±
                    spawnEnemy();
                }
                else if (dynamic_cast<Item*>(objects[i].get())) {
                    // ì•„ì´í…œê³¼ ì¶©ëŒ
                    objects[i]->setActive(false);
                    score += 200;
                    
                    // ì•„ì´í…œ ì¬ìƒì„±
                    spawnItem();
                }
            }
        }
        
        // ë¹„í™œì„±í™”ëœ ì˜¤ë¸Œì íŠ¸ ì œê±°
        objects.erase(
            std::remove_if(objects.begin(), objects.end(),
                          [](const std::unique_ptr<GameObject>& obj) {
                              return !obj->isActive();
                          }),
            objects.end()
        );
    }
    
    void draw() const {
        // ëª¨ë“  ì˜¤ë¸Œì íŠ¸ ê·¸ë¦¬ê¸°
        for (const auto& obj : objects) {
            if (obj->isActive()) {
                obj->draw();
            }
        }
        
        // ì ìˆ˜ í‘œì‹œ
        FontAsset(U"Regular")(U"ì ìˆ˜: {}"_fmt(score)).draw(20, 20, ColorF(1.0));
        
        // ì˜¤ë¸Œì íŠ¸ í†µê³„
        int enemyCount = std::count_if(objects.begin(), objects.end(),
                                     [](const std::unique_ptr<GameObject>& obj) {
                                         return dynamic_cast<Enemy*>(obj.get()) != nullptr;
                                     });
        
        int itemCount = std::count_if(objects.begin(), objects.end(),
                                    [](const std::unique_ptr<GameObject>& obj) {
                                        return dynamic_cast<Item*>(obj.get()) != nullptr;
                                    });
        
        FontAsset(U"Regular")(U"ì : {}, ì•„ì´í…œ: {}, ì´ ê°ì²´: {}"_fmt(enemyCount, itemCount, objects.size()))
            .draw(20, 50, ColorF(0.7));
            
        // ì¡°ì‘ë²•
        FontAsset(U"Regular")(U"ë°©í–¥í‚¤ë¡œ ì´ë™, ì  í”¼í•˜ê³  ì•„ì´í…œ ìˆ˜ì§‘").draw(20, 580, ColorF(0.7));
    }
    
private:
    void spawnEnemy() {
        Vec2 position;
        // í”Œë ˆì´ì–´ì—ì„œ ì¼ì • ê±°ë¦¬ ë–¨ì–´ì§„ ê³³ì— ìƒì„±
        do {
            position = RandomVec2(Rect(0, 0, 800, 600));
        } while (position.distanceFrom(playerPtr->getPosition()) < 100);
        
        objects.push_back(std::make_unique<Enemy>(position, Random(1.0, 3.0)));
    }
    
    void spawnItem() {
        Vec2 position = RandomVec2(Rect(50, 50, 700, 500));
        objects.push_back(std::make_unique<Item>(position));
    }
};

void Main()
{
    // ìœˆë„ìš° ì„¤ì •
    Window::SetTitle(U"STL ê²Œì„ ì˜¤ë¸Œì íŠ¸ ê´€ë¦¬");
    Scene::SetBackground(ColorF(0.1, 0.1, 0.2));
    
    // í°íŠ¸ ë“±ë¡
    FontAsset::Register(U"Regular", 20, Typeface::Regular);
    
    // ê²Œì„ ì›”ë“œ ìƒì„±
    GameWorld world;
    
    while (System::Update())
    {
        world.update();
        world.draw();
    }
}
```

### 6.2 ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•œ ì  AI
ì´ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ STL ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ì—¬ AI ë¡œì§ì„ êµ¬í˜„í•œë‹¤.  
- std::for_each: ëª¨ë“  ì ì˜ ìƒíƒœë¥¼ í•œ ë²ˆì— ê°±ì‹ í•œë‹¤.
- std::min_element: í”Œë ˆì´ì–´ì—ê²Œ ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ì°¾ëŠ”ë‹¤.
- std::count_if: íŠ¹ì • ìƒíƒœ(ì¶”ê²© ì¤‘)ì— ìˆëŠ” ì ì˜ ìˆ˜ë¥¼ ì„¼ë‹¤.
- std::remove_if (Erase-Remove Idiom): ì²´ë ¥ì´ 0 ì´í•˜ì¸ ì ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì œê±°í•œë‹¤.  
  
  
```cpp
#include <Siv3D.hpp>
#include <algorithm> // STL ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ í¬í•¨

// ì ì˜ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—´ê±°í˜•
enum class EnemyState
{
	Idle,       // ëŒ€ê¸°
	Chasing,    // ì¶”ê²©
	Attacking,  // ê³µê²© (ì´ ì˜ˆì œì—ì„œëŠ” ì‚¬ìš© ì•ˆ í•¨)
};

// ì  ìºë¦­í„°ë¥¼ ì •ì˜í•˜ëŠ” êµ¬ì¡°ì²´
struct Enemy
{
	Vec2 pos;
	double speed = 150.0;
	double health = 100.0;
	EnemyState state = EnemyState::Idle;
	Circle body() const { return Circle{ pos, 20 }; }

	void update(const Vec2& playerPos, double deltaTime)
	{
		if (state == EnemyState::Chasing)
		{
			// í”Œë ˆì´ì–´ë¥¼ í–¥í•˜ëŠ” ë°©í–¥ ë²¡í„°ë¥¼ ê³„ì‚°í•˜ê³  ì •ê·œí™”
			const Vec2 direction = (playerPos - pos).normalized();
			pos += direction * speed * deltaTime;
		}
	}

	void draw() const
	{
		// ìƒíƒœì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½
		Color bodyColor = Palette::Gray;
		if (state == EnemyState::Chasing)
		{
			bodyColor = Palette::Orange;
		}

		body().draw(bodyColor);
		body().drawFrame(2, Palette::Black);
	}
};


void Main()
{
	// ê¸°ë³¸ ì„¤ì •
	Scene::SetBackground(ColorF{ 0.2, 0.3, 0.4 });
	const Font font{ 30 };

	// í”Œë ˆì´ì–´ì™€ ì  ìƒì„±
	Vec2 playerPos = Scene::Center();
	Array<Enemy> enemies;
	for (int i = 0; i < 10; ++i)
	{
		enemies.push_back({ RandomVec2(Scene::Rect()), 150.0 });
	}

	while (System::Update())
	{
		// í”Œë ˆì´ì–´ëŠ” ë§ˆìš°ìŠ¤ë¥¼ ë”°ë¼ ì´ë™
		playerPos = Cursor::Pos();

		// ==================================================
		// ## 1. std::for_each: ëª¨ë“  ì ì˜ ìƒíƒœ ì—…ë°ì´íŠ¸
		//    - í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ë¥¼ í™•ì¸í•˜ì—¬ ì¶”ê²© ìƒíƒœë¡œ ë³€ê²½
		// ==================================================
		const double chaseDistance = 300.0;
		std::for_each(enemies.begin(), enemies.end(), [&](Enemy& enemy) {
			if (enemy.pos.distanceFrom(playerPos) < chaseDistance)
			{
				enemy.state = EnemyState::Chasing;
			}
			else
			{
				enemy.state = EnemyState::Idle;
			}
		});


		// ==================================================
		// ## 2. std::min_element: ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
		//    - ëŒë‹¤ ë¹„êµ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ê°€ ìµœì†Œì¸ ì ì„ ì°¾ìŒ
		// ==================================================
		auto closestEnemyIt = std::min_element(enemies.begin(), enemies.end(),
			[&](const Enemy& a, const Enemy& b) {
				return a.pos.distanceFrom(playerPos) < b.pos.distanceFrom(playerPos);
			}
		);


		// ==================================================
		// ## 3. std::count_if: ì¶”ê²© ì¤‘ì¸ ì ì˜ ìˆ˜ ì„¸ê¸°
		// ==================================================
		const int chasingCount = std::count_if(enemies.begin(), enemies.end(),
			[](const Enemy& enemy) {
				return enemy.state == EnemyState::Chasing;
			}
		);


		// ==================================================
		// ## 4. Erase-Remove Idiom: ì£½ì€ ì  ì œê±°
		//    - ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­ìœ¼ë¡œ ì ì—ê²Œ í”¼í•´ë¥¼ ì¤Œ
		//    - ì²´ë ¥ì´ 0 ì´í•˜ì¸ ì ì„ ë°°ì—´ì—ì„œ íš¨ìœ¨ì ìœ¼ë¡œ ì œê±°
		// ==================================================
		if (MouseL.down())
		{
			for (auto& enemy : enemies)
			{
				if (enemy.body().mouseOver())
				{
					enemy.health -= 50;
				}
			}
		}

		// std::remove_ifë¡œ ì²´ë ¥ì´ 0 ì´í•˜ì¸ ì ë“¤ì„ ë°°ì—´ì˜ ëìœ¼ë¡œ ì˜®ê¸°ê³ ,
		// ê·¸ ì‹œì‘ ìœ„ì¹˜(ì´í„°ë ˆì´í„°)ë¥¼ ë°˜í™˜ë°›ìŒ
		auto toRemoveIt = std::remove_if(enemies.begin(), enemies.end(),
			[](const Enemy& enemy) {
				return enemy.health <= 0;
			}
		);

		// ë°°ì—´ì˜ ëìœ¼ë¡œ ì˜®ê²¨ì§„ ìš”ì†Œë“¤ì„ ì‹¤ì œë¡œ ì‚­ì œ
		enemies.erase(toRemoveIt, enemies.end());


		// ê° ì ì˜ ë¡œì§ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
		const double deltaTime = Scene::DeltaTime();
		for (auto& enemy : enemies)
		{
			enemy.update(playerPos, deltaTime);
			enemy.draw();
		}

		// í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
		Circle{ playerPos, 25 }.draw(Palette::Skyblue);

		// ê°€ì¥ ê°€ê¹Œìš´ ì  ê°•ì¡° í‘œì‹œ
		if (closestEnemyIt != enemies.end())
		{
			closestEnemyIt->body().drawFrame(4, Palette::Red);
		}

		// UI ì •ë³´ ì¶œë ¥
		font(U"STL ì  AI ì˜ˆì œ").draw(20, 20);
		font(U"ì¶”ê²© ì¤‘ì¸ ì : {}"_fmt(chasingCount)).draw(20, 60);
		font(U"ë‚¨ì€ ì : {}"_fmt(enemies.size())).draw(20, 100);
		font(U"ì ì„ í´ë¦­í•˜ì—¬ í”¼í•´ë¥¼ ì…íˆì„¸ìš”.").draw(20, Scene::Height() - 50);
	}
}
```
  
#### 1. `std::for_each`
ì  ì „ì²´ë¥¼ ìˆœíšŒí•˜ë©° ê° ì ì˜ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•œë‹¤. `for` ë°˜ë³µë¬¸ê³¼ ê¸°ëŠ¥ì ìœ¼ë¡œëŠ” ë™ì¼í•˜ì§€ë§Œ, "ëª¨ë“  ìš”ì†Œì— ë™ì¼í•œ ì‘ì—…ì„ ì ìš©í•œë‹¤"ëŠ” ì˜ë„ë¥¼ ëª…í™•í•˜ê²Œ ë³´ì—¬ì¤„ ìˆ˜ ìˆë‹¤. ì—¬ê¸°ì„œëŠ” ê° ì ê³¼ í”Œë ˆì´ì–´ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ì—¬ `Idle` ë˜ëŠ” `Chasing` ìƒíƒœë¡œ ë³€ê²½í•œë‹¤.

#### 2. `std::min_element`
í”Œë ˆì´ì–´ì—ê²Œ ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ì°¾ëŠ” ë° ì‚¬ìš©ëœë‹¤. ì„¸ ë²ˆì§¸ ì¸ìë¡œ ì „ë‹¬ëœ ëŒë‹¤ í•¨ìˆ˜ `[&](const Enemy& a, const Enemy& b){ ... }`ëŠ” ë‘ ì  `a`ì™€ `b` ì¤‘ ëˆ„ê°€ í”Œë ˆì´ì–´ì™€ ë” ê°€ê¹Œìš´ì§€ë¥¼ ë¹„êµí•˜ëŠ” ê·œì¹™ì„ ì •ì˜í•œë‹¤. ì´ ì•Œê³ ë¦¬ì¦˜ì€ ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ê°€ë¦¬í‚¤ëŠ” ë°˜ë³µì(iterator)ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ, í•´ë‹¹ ì ì„ íŠ¹ë³„í•˜ê²Œ(ì˜ˆ: ë¹¨ê°„ìƒ‰ í…Œë‘ë¦¬) í‘œì‹œí•  ìˆ˜ ìˆë‹¤.
  
#### 3. `std::count_if`
`Chasing` ìƒíƒœì¸ ì ì´ ëª‡ ëª…ì¸ì§€ ê³„ì‚°í•œë‹¤. ëŒë‹¤ í•¨ìˆ˜ `[](const Enemy& e){ return e.state == EnemyState::Chasing; }`ëŠ” "ì´ ì ì´ ì¶”ê²© ìƒíƒœì¸ê°€?"ë¥¼ ë¬»ëŠ” ì¡°ê±´ì´ë©°, ì´ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤.
  
#### 4. `std::remove_if` (Erase-Remove Idiom)
ì´ê²ƒì€ C++ì—ì„œ íŠ¹ì • ì¡°ê±´ì˜ ìš”ì†Œë¥¼ ë™ì  ë°°ì—´ì—ì„œ ì œê±°í•˜ëŠ” í‘œì¤€ì ì¸ ë°©ë²•ì´ë‹¤.
  
  * **1ë‹¨ê³„ (`std::remove_if`)**: ì²´ë ¥ì´ 0 ì´í•˜ì¸ ëª¨ë“  ì ì„ ë°°ì—´ì˜ ë§¨ ë’¤ë¡œ ì´ë™ì‹œí‚¨ë‹¤. ì‹¤ì œ ë°ì´í„°ê°€ ì‚­ì œë˜ì§€ëŠ” ì•Šìœ¼ë©°, "ì“¸ëª¨ì—†ëŠ”" ë°ì´í„°ë“¤ì´ ëª¨ì—¬ìˆëŠ” ì˜ì—­ì˜ ì‹œì‘ì ì„ ë°˜í™˜í•œë‹¤.
  * **2ë‹¨ê³„ (`.erase`)**: `s3d::Array` (ë˜ëŠ” `std::vector`)ì˜ `.erase()` ë©¤ë²„ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ "ì“¸ëª¨ì—†ëŠ”" ë°ì´í„° ì˜ì—­ì„ ì‹¤ì œë¡œ ë©”ëª¨ë¦¬ì—ì„œ ì œê±°í•œë‹¤. ì´ ë°©ì‹ì€ ìš”ì†Œë¥¼ í•˜ë‚˜ì”© ì°¾ì•„ ì‚­ì œí•˜ëŠ” ê²ƒë³´ë‹¤ í›¨ì”¬ íš¨ìœ¨ì ì´ë‹¤.
  


### 6.3 mapì„ í™œìš©í•œ íƒ€ì¼ ê¸°ë°˜ ê²Œì„
OpenSiv3Dì—ì„œ s3d::HashTable(C++ì˜ std::unordered_mapê³¼ ìœ ì‚¬)ì„ í™œìš©í•˜ì—¬ íƒ€ì¼ ê¸°ë°˜ ê²Œì„ì˜ ë§µì„ êµ¬í˜„í•˜ëŠ” ì˜ˆì œ ì½”ë“œì´ë‹¤.  
  
ì´ ì˜ˆì œëŠ” HashTableì„ ì‚¬ìš©í•´ ì¢Œí‘œë¥¼ í‚¤(Key)ë¡œ, íƒ€ì¼ íƒ€ì…ì„ ê°’(Value)ìœ¼ë¡œ ì €ì¥í•œë‹¤. ì´ ë°©ì‹ì€ ë§µì˜ ëª¨ë“  ê³µê°„ì„ ë°°ì—´ë¡œ ë§Œë“œëŠ” ëŒ€ì‹ , ì˜ë¯¸ ìˆëŠ” íƒ€ì¼ì˜ ìœ„ì¹˜ë§Œ ì €ì¥í•˜ë¯€ë¡œ ê±°ëŒ€í•˜ê±°ë‚˜ ë¹„ì •í˜•ì ì¸ ë§µ(Sparse Map)ì„ íš¨ìœ¨ì ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.  

#### HashTableì„ í™œìš©í•œ íƒ€ì¼ë§µ ì˜ˆì œ
ì´ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê¸°ëŠ¥ì„ í¬í•¨í•œë‹¤.
- HashTable<Point, TileType>: Point(íƒ€ì¼ ì¢Œí‘œ)ë¥¼ í‚¤ë¡œ ì‚¬ìš©í•˜ì—¬ ë§µ ë°ì´í„°ë¥¼ ì €ì¥í•œë‹¤.
- Perlin Noise: ì ˆì°¨ì ìœ¼ë¡œ ìì—°ìŠ¤ëŸ¬ìš´ ì§€í˜•ì„ ìƒì„±í•œë‹¤.
- Camera2D: ë§ˆìš°ìŠ¤ ìš°í´ë¦­ ë“œë˜ê·¸ì™€ íœ  ìŠ¤í¬ë¡¤ë¡œ ë§µì„ íƒìƒ‰í•  ìˆ˜ ìˆë‹¤.
- íƒ€ì¼ í¸ì§‘: ë§ˆìš°ìŠ¤ ì¢Œí´ë¦­ìœ¼ë¡œ ë§µì˜ íƒ€ì¼ì„ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
  

```cpp
#include <Siv3D.hpp>

// íƒ€ì¼ì˜ ì¢…ë¥˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì—´ê±°í˜•
enum class TileType : uint8
{
	Grass,
	Water,
	Sand,
	Stone,
};

// ê²Œì„ ë§µì„ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤
class GameMap
{
private:
	HashTable<Point, TileType> m_tiles;
	Texture m_tileset;
	TileType m_defaultTile = TileType::Grass;

public:
	// íƒ€ì¼ì˜ í¬ê¸° (í”½ì…€ ë‹¨ìœ„)
	static constexpr int32 TileSize = 32;

	GameMap()
	{
		m_tileset = Texture{ U"ğŸŸ©ğŸ’§ğŸ–ï¸ğŸª¨"_emoji, TextureDesc::Mipped };
		const PerlinNoise noise{ RandomUint32() };
		for (int32 y = -50; y < 50; ++y)
		{
			for (int32 x = -50; x < 50; ++x)
			{
				const double n = noise.octave2D(x * 0.1, y * 0.1, 4);
				if (n > 0.6)
				{
					m_tiles[{x, y}] = TileType::Stone;
				}
				else if (n > 0.45)
				{
					m_tiles[{x, y}] = TileType::Sand;
				}
				else if (n < 0.2)
				{
					m_tiles[{x, y}] = TileType::Water;
				}
			}
		}
	}

	void setTile(const Point& tilePos, TileType type)
	{
		if (type == m_defaultTile)
		{
			m_tiles.erase(tilePos);
		}
		else
		{
			m_tiles[tilePos] = type;
		}
	}

	// [ìˆ˜ì •ë¨] ë§µ ê·¸ë¦¬ê¸° í•¨ìˆ˜
	void draw(const Camera2D& camera) const
	{
		// 1. ì¹´ë©”ë¼ì˜ ì¤‘ì‹¬ ì¢Œí‘œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê·¸ë¦´ íƒ€ì¼ ë²”ìœ„ë¥¼ ê³„ì‚°
		const Point centerTile = Floor(camera.getCenter() / TileSize).asPoint();
		const int32 drawRangeX = (Scene::Width() / TileSize / 2) + 2;
		const int32 drawRangeY = (Scene::Height() / TileSize / 2) + 2;

		for (int32 y = (centerTile.y - drawRangeY); y < (centerTile.y + drawRangeY); ++y)
		{
			for (int32 x = (centerTile.x - drawRangeX); x < (centerTile.x + drawRangeX); ++x)
			{
				const Point tilePos{ x, y };
				
				// 2. HashTableì—ì„œ íƒ€ì¼ íƒ€ì…ì„ ì§ì ‘ ì°¾ì•„ì˜¤ëŠ” ë¡œì§
				TileType type;
				const auto it = m_tiles.find(tilePos);

				if (it != m_tiles.end())
				{
					// í‚¤ë¥¼ ì°¾ì•˜ìœ¼ë©´ í•´ë‹¹ íƒ€ì¼ íƒ€ì…ì„ ì‚¬ìš©
					type = it->second;
				}
				else
				{
					// í‚¤ë¥¼ ì°¾ì§€ ëª»í–ˆìœ¼ë©´ ê¸°ë³¸ íƒ€ì¼ íƒ€ì…ì„ ì‚¬ìš©
					type = m_defaultTile;
				}
				
				// íƒ€ì¼ íƒ€ì…ì— ë§ëŠ” í…ìŠ¤ì²˜ ì˜ì—­ì„ í™”ë©´ì— ê·¸ë¦¼
				m_tileset(static_cast<int32>(type) * 64, 0, 64, 64)
					.resized(TileSize)
					.draw(x * TileSize, y * TileSize);
			}
		}
	}
};

void Main()
{
	Window::Resize(1280, 720);
	const Font font{ 30 };
	Camera2D camera{ Scene::Center(), 1.0 };
	GameMap gameMap;

	while (System::Update())
	{
		camera.update();

		if (MouseL.pressed())
		{
			const Vec2 worldPos = Cursor::PosF();
			const Point tilePos = Floor(worldPos / GameMap::TileSize).asPoint();
			gameMap.setTile(tilePos, TileType::Stone);
		}

		{
			const auto t = camera.createTransformer();
			gameMap.draw(camera);
		}

		Rect{ 0, 0, 450, 120 }.draw(ColorF{ 0.0, 0.5 });
		font(U"HashTable íƒ€ì¼ë§µ ì˜ˆì œ").draw(10, 10);
		font(U"ìš°í´ë¦­ ë“œë˜ê·¸: ì´ë™").draw(10, 45);
		font(U"ë§ˆìš°ìŠ¤ íœ : ì¤Œ").draw(10, 80);
	}
}
```
    
#### HashTable<Point, TileType> ì˜ ì—­í• 
ì´ ì˜ˆì œì˜ í•µì‹¬ì´ë‹¤. s3d::HashTableì€ C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ std::unordered_mapê³¼ ê¸°ëŠ¥ì ìœ¼ë¡œ ë§¤ìš° ìœ ì‚¬í•œ ì»¨í…Œì´ë„ˆì´ë‹¤.
  
- Key: s3d::Pointë¥¼ ì‚¬ìš©í•˜ì—¬ íƒ€ì¼ì˜ ì •ìˆ˜ ì¢Œí‘œ (x, y)ë¥¼ ê³ ìœ í•œ í‚¤ë¡œ ì‚¬ìš©í•œë‹¤.
- Value: TileType ì—´ê±°í˜•ì„ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ì¢Œí‘œì— ì–´ë–¤ ì¢…ë¥˜ì˜ íƒ€ì¼ì´ ìˆëŠ”ì§€ë¥¼ ì €ì¥í•œë‹¤.
  
#### ì™œ Grid(2D ë°°ì—´) ëŒ€ì‹  HashTableì„ ì‚¬ìš©í–ˆëŠ”ê°€?
- ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±: GridëŠ” ë§µì˜ ëª¨ë“  (x, y) ìœ„ì¹˜ì— ëŒ€í•œ ë°ì´í„°ë¥¼ ì €ì¥í•´ì•¼ í•œë‹¤. í•˜ì§€ë§Œ HashTableì€ ê¸°ë³¸ íƒ€ì¼(Grass)ì´ ì•„ë‹Œ íŠ¹ë³„í•œ íƒ€ì¼(Water, Stone ë“±)ì˜ ì •ë³´ë§Œ ì €ì¥í•œë‹¤. ë”°ë¼ì„œ ì›”ë“œê°€ ì•„ë¬´ë¦¬ ë„“ì–´ì ¸ë„ ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” ê³³ë§Œ ë©”ëª¨ë¦¬ë¥¼ ì°¨ì§€í•œë‹¤.
- ìœ ì—°ì„±: ë§µì˜ í¬ê¸°ë¥¼ ë¯¸ë¦¬ ì •í•  í•„ìš”ê°€ ì—†ë‹¤. ì–´ë–¤ ì¢Œí‘œ (-1000, 5000)ì—ë„ ì¦‰ì‹œ ìƒˆë¡œìš´ íƒ€ì¼ì„ ì¶”ê°€í•˜ê±°ë‚˜ ì‚­ì œí•  ìˆ˜ ìˆì–´, ë¬´í•œíˆ í™•ì¥ë˜ëŠ” ë§µì„ êµ¬í˜„í•˜ê¸°ì— ì í•©í•˜ë‹¤.  
  

  
## 8.7 C++23ì˜ STL í–¥ìƒëœ ê¸°ëŠ¥
C++23 í‘œì¤€ì—ì„œëŠ” STLì´ ë”ìš± í–¥ìƒë˜ì—ˆë‹¤. ì£¼ìš” ê°œì„  ì‚¬í•­ì„ ì‚´í´ë³´ê² ë‹¤.

### 7.1 rangesì™€ views

```cpp
#include <ranges>
#include <algorithm>
#include <vector>
#include <Siv3D.hpp>

void Main()
{
    // ë°ì´í„° ì¤€ë¹„
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // C++23ì˜ rangesì™€ views
    auto evenSquares = numbers 
        | std::views::filter([](int n) { return n % 2 == 0; }) // ì§ìˆ˜ë§Œ í•„í„°ë§
        | std::views::transform([](int n) { return n * n; });  // ì œê³±í•˜ê¸°
    
    // ê²°ê³¼ ì¶œë ¥
    Print << U"ì›ë³¸ ë²¡í„°:";
    for (int n : numbers) {
        Print << n << U' ';
    }
    
    Print << U"ì§ìˆ˜ ì œê³± ê²°ê³¼:";
    for (int n : evenSquares) {
        Print << n << U' ';
    }
    
    // ê³ ê¸‰ ranges ì‚¬ìš© ì˜ˆ
    std::vector<std::string> words = {"apple", "banana", "cherry", "date", "elderberry"};
    
    // ê¸¸ì´ê°€ 5 ì´ìƒì¸ ë‹¨ì–´ë§Œ ëŒ€ë¬¸ìë¡œ ë³€í™˜
    auto longWordsUpper = words
        | std::views::filter([](const std::string& s) { return s.length() >= 5; })
        | std::views::transform([](std::string s) {
              std::transform(s.begin(), s.end(), s.begin(), ::toupper);
              return s;
          });
    
    Print << U"ì›ë³¸ ë‹¨ì–´:";
    for (const auto& word : words) {
        Print << Unicode::Widen(word);
    }
    
    Print << U"5ê¸€ì ì´ìƒ ëŒ€ë¬¸ì ë³€í™˜:";
    for (const auto& word : longWordsUpper) {
        Print << Unicode::Widen(word);
    }
    
    // ì—°ì†ëœ ìˆ«ì ìƒì„±ê³¼ ì¡°ì‘
    auto numberSequence = std::views::iota(1, 20)
        | std::views::filter([](int n) { return n % 3 == 0; });
    
    Print << U"3ì˜ ë°°ìˆ˜ (1-20):";
    for (int n : numberSequence) {
        Print << n << U' ';
    }

    while (System::Update())
    {
        // ranges ì‹œê°í™”
        FontAsset(U"Regular")(U"C++23 rangesì™€ views").draw(50, 50, ColorF(1.0));
        
        // ì›ë³¸ ë²¡í„°
        FontAsset(U"Regular")(U"ì›ë³¸ ë²¡í„°:").draw(50, 100, ColorF(1.0));
        for (size_t i = 0; i < numbers.size(); ++i) {
            RectF rect(50 + i * 50, 150, 40, numbers[i] * 20);
            rect.draw(ColorF(0.3, 0.6, 0.9));
            FontAsset(U"Regular")(numbers[i]).drawAt(rect.center(), ColorF(1.0));
        }
        
        // ì§ìˆ˜ ì œê³± ê²°ê³¼
        FontAsset(U"Regular")(U"ì§ìˆ˜ ì œê³± ê²°ê³¼:").draw(50, 250, ColorF(1.0));
        int i = 0;
        for (int n : evenSquares) {
            RectF rect(50 + i * 70, 300, 60, Math::Sqrt(n) * 10);
            rect.draw(ColorF(0.9, 0.3, 0.3));
            FontAsset(U"Regular")(n).drawAt(rect.center(), ColorF(1.0));
            ++i;
        }
        
        // 3ì˜ ë°°ìˆ˜ ì‹œê°í™”
        FontAsset(U"Regular")(U"3ì˜ ë°°ìˆ˜ (1-20):").draw(50, 400, ColorF(1.0));
        i = 0;
        for (int n : numberSequence) {
            Circle(70 + i * 60, 450, 25).draw(ColorF(0.3, 0.9, 0.6));
            FontAsset(U"Regular")(n).drawAt(70 + i * 60, 450, ColorF(1.0));
            ++i;
        }
    }
}
```

### 7.2 std::expectedì™€ std::optional

```cpp
#include <expected>
#include <optional>
#include <stdexcept>
#include <Siv3D.hpp>

// ì—ëŸ¬ ì¢…ë¥˜
enum class Error {
    DivisionByZero,
    OutOfRange,
    InvalidInput
};

// std::expectedë¥¼ ì‚¬ìš©í•œ ì•ˆì „í•œ ë‚˜ëˆ„ê¸°
std::expected<double, Error> safeDivide(double a, double b) {
    if (b == 0.0) {
        return std::unexpected(Error::DivisionByZero);
    }
    return a / b;
}

// std::optionalì„ ì‚¬ìš©í•œ ì œê³±ê·¼ ê³„ì‚°
std::optional<double> safeSqrt(double x) {
    if (x < 0.0) {
        return std::nullopt;
    }
    return std::sqrt(x);
}

void Main()
{
    // std::expected ì˜ˆì œ
    Print << U"std::expected ì˜ˆì œ (safeDivide):";
    
    auto result1 = safeDivide(10.0, 2.0);
    if (result1) {
        Print << U"10 / 2 = " << *result1;
    }
    
    auto result2 = safeDivide(10.0, 0.0);
    if (!result2) {
        Print << U"ì˜¤ë¥˜ ë°œìƒ: 0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
    }
    
    // std::optional ì˜ˆì œ
    Print << U"\nstd::optional ì˜ˆì œ (safeSqrt):";
    
    auto sqrt1 = safeSqrt(16.0);
    if (sqrt1) {
        Print << U"âˆš16 = " << *sqrt1;
    }
    
    auto sqrt2 = safeSqrt(-4.0);
    if (!sqrt2) {
        Print << U"ì˜¤ë¥˜ ë°œìƒ: ìŒìˆ˜ì˜ ì œê³±ê·¼ì„ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
    }
    
    // ê³ ê¸‰ ì˜ˆì œ: ë³µì¡í•œ ê³„ì‚° chain
    auto complexCalc = [](double x) -> std::expected<double, Error> {
        auto sqrtResult = safeSqrt(x);
        if (!sqrtResult) {
            return std::unexpected(Error::InvalidInput);
        }
        
        auto divResult = safeDivide(10.0, *sqrtResult);
        if (!divResult) {
            return divResult.error();
        }
        
        return *divResult * 2.0;
    };
    
    Print << U"\në³µì¡í•œ ê³„ì‚° ì²´ì¸:";
    
    auto result3 = complexCalc(16.0);
    if (result3) {
        Print << U"complexCalc(16.0) = " << *result3;
    }
    
    auto result4 = complexCalc(-4.0);
    if (!result4) {
        Print << U"complexCalc(-4.0)ì—ì„œ ì˜¤ë¥˜ ë°œìƒ";
    }

    while (System::Update())
    {
        FontAsset(U"Regular")(U"C++23 ì˜¤ë¥˜ ì²˜ë¦¬ ê¸°ëŠ¥").draw(50, 50, ColorF(1.0));
        
        // std::expected ì‹œê°í™”
        FontAsset(U"Regular")(U"std::expected ì˜ˆì œ").draw(50, 100, ColorF(1.0));
        
        RectF divRect1(50, 150, 200, 60);
        divRect1.draw(result1 ? ColorF(0.3, 0.9, 0.3) : ColorF(0.9, 0.3, 0.3));
        FontAsset(U"Regular")(U"10 / 2 = {}"_fmt(result1 ? ToString(*result1) : U"ì˜¤ë¥˜"))
            .drawAt(divRect1.center(), ColorF(1.0));
            
        RectF divRect2(300, 150, 200, 60);
        divRect2.draw(result2 ? ColorF(0.3, 0.9, 0.3) : ColorF(0.9, 0.3, 0.3));
        FontAsset(U"Regular")(U"10 / 0 = {}"_fmt(result2 ? ToString(*result2) : U"ì˜¤ë¥˜"))
            .drawAt(divRect2.center(), ColorF(1.0));
            
        // std::optional ì‹œê°í™”
        FontAsset(U"Regular")(U"std::optional ì˜ˆì œ").draw(50, 250, ColorF(1.0));
        
        RectF sqrtRect1(50, 300, 200, 60);
        sqrtRect1.draw(sqrt1 ? ColorF(0.3, 0.9, 0.3) : ColorF(0.9, 0.3, 0.3));
        FontAsset(U"Regular")(U"âˆš16 = {}"_fmt(sqrt1 ? ToString(*sqrt1) : U"ì˜¤ë¥˜"))
            .drawAt(sqrtRect1.center(), ColorF(1.0));
            
        RectF sqrtRect2(300, 300, 200, 60);
        sqrtRect2.draw(sqrt2 ? ColorF(0.3, 0.9, 0.3) : ColorF(0.9, 0.3, 0.3));
        FontAsset(U"Regular")(U"âˆš-4 = {}"_fmt(sqrt2 ? ToString(*sqrt2) : U"ì˜¤ë¥˜"))
            .drawAt(sqrtRect2.center(), ColorF(1.0));
            
        // ë³µì¡í•œ ê³„ì‚° ì²´ì¸ ì‹œê°í™”
        FontAsset(U"Regular")(U"ë³µì¡í•œ ê³„ì‚° ì²´ì¸").draw(50, 400, ColorF(1.0));
        
        RectF calcRect1(50, 450, 200, 60);
        calcRect1.draw(result3 ? ColorF(0.3, 0.9, 0.3) : ColorF(0.9, 0.3, 0.3));
        FontAsset(U"Regular")(U"complexCalc(16) = {}"_fmt(result3 ? ToString(*result3) : U"ì˜¤ë¥˜"))
            .drawAt(calcRect1.center(), ColorF(1.0));
            
        RectF calcRect2(300, 450, 200, 60);
        calcRect2.draw(result4 ? ColorF(0.3, 0.9, 0.3) : ColorF(0.9, 0.3, 0.3));
        FontAsset(U"Regular")(U"complexCalc(-4) = {}"_fmt(result4 ? ToString(*result4) : U"ì˜¤ë¥˜"))
            .drawAt(calcRect2.center(), ColorF(1.0));
    }
}
```
  

## ê²°ë¡ 
STLì€ C++ í”„ë¡œê·¸ë˜ë°ì—ì„œ í•„ìˆ˜ì ì¸ ë„êµ¬ë‹¤. ê° ì»¨í…Œì´ë„ˆì˜ íŠ¹ì„±ì„ ì´í•´í•˜ê³  ì ì ˆí•œ ìƒí™©ì—ì„œ ì‚¬ìš©í•˜ë©´ íš¨ìœ¨ì ì´ê³  ì•ˆì „í•œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

**ì„ íƒ ê°€ì´ë“œë¼ì¸:**

- **ë¹ ë¥¸ ì„ì˜ ì ‘ê·¼**ì´ í•„ìš”í•˜ë©´ â†’ `vector`
- **ì–‘ìª½ ëì—ì„œ ì‚½ì…/ì‚­ì œ**ê°€ ë¹ˆë²ˆí•˜ë©´ â†’ `deque`  
- **ì¤‘ê°„ ì‚½ì…/ì‚­ì œ**ê°€ ë¹ˆë²ˆí•˜ë©´ â†’ `list`
- **í‚¤-ê°’ ìŒì„ ì •ë ¬ëœ ìˆœì„œ**ë¡œ ìœ ì§€í•˜ë ¤ë©´ â†’ `map`
- **í‚¤-ê°’ ìŒì„ ë¹ ë¥´ê²Œ ì ‘ê·¼**í•˜ë ¤ë©´ â†’ `unordered_map`
- **ìœ ì¼í•œ ê°’ë“¤ì„ ì •ë ¬**í•´ì„œ ì €ì¥í•˜ë ¤ë©´ â†’ `set`
- **ìœ ì¼í•œ ê°’ë“¤ì„ ë¹ ë¥´ê²Œ ê²€ìƒ‰**í•˜ë ¤ë©´ â†’ `unordered_set`

  
Siv3Dì™€ STLì„ í•¨ê»˜ ì‚¬ìš©í•˜ë©´ ì§ê´€ì ì´ê³  íš¨ìœ¨ì ì¸ ê²Œì„ê³¼ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì¥ì—ì„œ ë°°ìš´ ê¸°ìˆ ë“¤ì€ ëª¨ë“  C++ í”„ë¡œê·¸ë˜ë°ì— ì ìš©í•  ìˆ˜ ìˆìœ¼ë©°, íŠ¹íˆ ê²Œì„ ê°œë°œì—ì„œ ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤.

ì•ìœ¼ë¡œ ë” ê¹Šì´ ìˆëŠ” í•™ìŠµì„ ìœ„í•´ ë‹¤ì–‘í•œ STL ì•Œê³ ë¦¬ì¦˜ê³¼ ì»¨í…Œì´ë„ˆ ì¡°í•©ì„ ì‹¤í—˜í•´ ë³´ê³ , ìì‹ ë§Œì˜ ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì— ì ìš©í•´ ë³´ì„¸ìš”.


