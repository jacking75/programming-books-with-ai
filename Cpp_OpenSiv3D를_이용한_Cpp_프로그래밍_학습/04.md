# OpenSiv3D를 이용한 C++ 프로그래밍 학습
  
저자: 최흥배, Claude AI  
  
C++ 프로그래밍 언어를 배우는 것에 중점을 두되, Siv3D 프레임워크를 활용하여 시각적으로 흥미로운 예제를 통해 학습 효과를 높이도록 설계 되었다. 단순한 콘솔 프로그램 대신 그래픽, 소리, 상호작용을 포함한 프로그램을 만들며 C++의 개념을 익힐 수 있다.  
  
필요 소프트웨어:  
- Windows 10 이상
- Visual Studio 2022 이상   
  
-----    
    
# Chapter.4: 배열과 컬렉션
      
## 배열과 컬렉션 개요
프로그래밍에서 여러 개의 데이터를 효율적으로 관리하는 것은 매우 중요하다. C++에서는 이를 위해 다양한 종류의 배열과 컬렉션을 제공한다. 이번 장에서는 다음 컨셉들을 배운다:

- 정적 배열과 동적 배열
- `std::vector` 컨테이너
- 문자열 처리
- 반복자를 이용한 컬렉션 순회
  

## 4.1 C++ 배열

### 정적 배열
정적 배열은 선언 시점에 크기가 고정되며, 스택 메모리에 할당된다.

```cpp
// 기본 선언 방식
int scores[5] = {100, 95, 80, 75, 90};

// C++17부터는 타입 추론 가능
auto numbers = std::array{1, 2, 3, 4, 5};

// 배열 요소 접근
int firstScore = scores[0];  // 첫 번째 요소 (인덱스는 0부터 시작)
scores[3] = 85;             // 4번째 요소 값 변경
```

### std::array (C++11 이상)
정적 배열을 대체하는 안전한 컨테이너이다.

```cpp
#include <array>

std::array<int, 5> scores = {100, 95, 80, 75, 90};

// 크기와 요소 접근
std::cout << "배열 크기: " << scores.size() << std::endl;
std::cout << "첫 번째 요소: " << scores.front() << std::endl;
std::cout << "마지막 요소: " << scores.back() << std::endl;

// 범위 검사 메소드
int safeValue = scores.at(2);  // 인덱스가 범위를 벗어나면 예외 발생
```

### 다차원 배열

```cpp
// 2차원 배열
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// std::array를 사용한 2차원 배열
std::array<std::array<int, 4>, 3> matrix2 = {{
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
}};
```

### C++23의 배열 관련 새로운 기능: `std::to_array`
C++20부터 도입되어 C++23에서 개선된 `std::to_array`를 사용하면 C 스타일 배열을 `std::array`로 쉽게 변환할 수 있다.

```cpp
int cArray[] = {1, 2, 3, 4, 5};
auto stdArray = std::to_array(cArray);  // std::array<int, 5>로 변환
```
 

## 4.2 std::vector
`std::vector`는 C++의 동적 배열 컨테이너로 크기가 자동으로 조절됩니다. 메모리 할당은 힙에서 이루어진다.

### 기본 사용법

```cpp
#include <vector>

// 빈 벡터 생성
std::vector<int> numbers;

// 초기값으로 벡터 생성
std::vector<int> scores = {100, 95, 80, 75, 90};

// 특정 크기와 초기값으로 벡터 생성
std::vector<int> zeros(5, 0);  // 5개의 0으로 초기화된 벡터

// 요소 추가
numbers.push_back(10);
numbers.push_back(20);
numbers.emplace_back(30);  // 객체를 직접 생성하며 추가 (더 효율적)

// 요소 접근
int firstNumber = numbers[0];      // 인덱스로 접근 (범위 검사 없음)
int safeNumber = numbers.at(1);    // at()으로 접근 (범위 검사 있음)
int lastNumber = numbers.back();   // 마지막 요소

// 크기 관련 메소드
std::cout << "벡터 크기: " << numbers.size() << std::endl;
std::cout << "벡터 용량: " << numbers.capacity() << std::endl;

// 요소 삭제
numbers.pop_back();  // 마지막 요소 제거
numbers.clear();     // 모든 요소 제거
```

### 벡터 순회하기

```cpp
std::vector<int> scores = {100, 95, 80, 75, 90};

// 인덱스를 사용한 전통적인 방법
for (size_t i = 0; i < scores.size(); ++i) {
    std::cout << scores[i] << " ";
}

// 범위 기반 for 루프 (C++11 이상)
for (int score : scores) {
    std::cout << score << " ";
}

// 반복자를 사용한 방법
for (auto it = scores.begin(); it != scores.end(); ++it) {
    std::cout << *it << " ";
}
```

### 벡터 메소드

```cpp
std::vector<int> numbers = {5, 2, 8, 1, 9};

// 벡터 정렬
std::sort(numbers.begin(), numbers.end());  // 오름차순 정렬
// 결과: {1, 2, 5, 8, 9}

// 벡터 뒤집기
std::reverse(numbers.begin(), numbers.end());
// 결과: {9, 8, 5, 2, 1}

// 특정 위치에 요소 삽입
auto it = numbers.begin() + 2;  // 3번째 위치
numbers.insert(it, 7);
// 결과: {9, 8, 7, 5, 2, 1}

// 특정 위치의 요소 삭제
it = numbers.begin() + 1;  // 2번째 위치
numbers.erase(it);
// 결과: {9, 7, 5, 2, 1}

// 벡터 크기 조정
numbers.resize(3);  // 처음 3개 요소만 유지
// 결과: {9, 7, 5}
```

### C++23의 vector 관련 새로운 기능: `std::ranges`
C++20부터 도입되어 C++23에서 확장된 `std::ranges`를 사용하면 벡터와 다른 컨테이너를 더 쉽게 다룰 수 있다.

```cpp
#include <ranges>
#include <algorithm>

std::vector<int> numbers = {5, 2, 8, 1, 9};

// 정렬
std::ranges::sort(numbers);

// 필터링과 변환 (C++20 이상)
auto even_numbers = numbers | std::views::filter([](int n) { return n % 2 == 0; });
// 결과: 2, 8 (짝수만 포함)

auto squared = numbers | std::views::transform([](int n) { return n * n; });
// 결과: 25, 4, 64, 1, 81
```
  

## 4.3 문자열 처리
C++에서는 문자열을 다루기 위한 여러 클래스와 기능을 제공한다.

### std::string

```cpp
#include <string>

// 문자열 생성
std::string greeting = "안녕하세요";
std::string name = "홍길동";

// 문자열 연결
std::string message = greeting + "! " + name + "님";

// 문자열 길이
std::cout << "메시지 길이: " << message.length() << std::endl;
std::cout << "메시지 크기: " << message.size() << std::endl;  // length()와 동일

// 부분 문자열 추출
std::string substring = message.substr(6, 3);  // 6번째 위치부터 3글자

// 문자열 검색
size_t pos = message.find("홍길동");  // "홍길동"의 시작 위치 찾기
if (pos != std::string::npos) {  // 찾지 못하면 std::string::npos 반환
    std::cout << "찾았습니다: " << pos << "번 위치" << std::endl;
}

// 문자열 치환
message.replace(pos, 3, "김철수");  // "홍길동"을 "김철수"로 교체
```

### std::string_view (C++17 이상)
`std::string_view`는 문자열의 읽기 전용 뷰로, 복사 없이 효율적으로 문자열을 참조한다.

```cpp
#include <string_view>

void printUppercase(std::string_view str) {
    for (char c : str) {
        std::cout << static_cast<char>(std::toupper(c));
    }
    std::cout << std::endl;
}

std::string message = "안녕하세요";
printUppercase(message);  // 복사 없이 문자열 전달
printUppercase("반갑습니다");  // 리터럴도 직접 전달 가능
```

### C++23의 문자열 관련 새로운 기능: `std::basic_string::contains`
C++23에서는 문자열에 특정 부분 문자열이 포함되어 있는지 쉽게 확인할 수 있다.

```cpp
std::string message = "안녕하세요, 홍길동님";

// 특정 문자열 포함 여부 확인
if (message.contains("홍길동")) {
    std::cout << "홍길동이 메시지에 포함되어 있습니다." << std::endl;
}

// Siv3D의
if (message.starts_with("안녕")) {
    std::cout << "인사말로 시작합니다." << std::endl;
}

if (message.ends_with("님")) {
    std::cout << "존칭으로 끝납니다." << std::endl;
}
```
  

## 4.4 반복자(iterator)
반복자는 컨테이너의 요소에 순차적으로 접근하는 방법을 제공한다.

### 반복자 기본 개념

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

// 벡터의 시작과 끝 반복자
auto begin_it = numbers.begin();  // 첫 번째 요소를 가리킴
auto end_it = numbers.end();      // 마지막 요소 다음 위치를 가리킴

// 반복자를 사용한 순회
for (auto it = begin_it; it != end_it; ++it) {
    std::cout << *it << " ";  // 반복자가 가리키는, 내용 접근을 위해 * 연산자 사용
}
std::cout << std::endl;

// 반복자를 사용한 요소 수정
for (auto it = numbers.begin(); it != numbers.end(); ++it) {
    *it *= 2;  // 각 요소를 2배로
}
```

### 반복자 종류

```cpp
// 정방향 반복자
std::vector<int>::iterator it1 = numbers.begin();

// 역방향 반복자
std::vector<int>::reverse_iterator it2 = numbers.rbegin();
for (auto it = numbers.rbegin(); it != numbers.rend(); ++it) {
    std::cout << *it << " ";  // 역순으로 출력
}

// 상수 반복자 (요소 수정 불가)
std::vector<int>::const_iterator it3 = numbers.cbegin();
// *it3 = 10;  // 컴파일 오류: 상수 반복자로는 수정 불가
```

### 반복자 연산

```cpp
std::vector<int> numbers = {10, 20, 30, 40, 50};
auto it = numbers.begin();

// 반복자 이동
it += 2;        // 2칸 앞으로 이동 (현재 30을 가리킴)
auto next_it = it + 1;  // 다음 위치의 반복자 (40을 가리킴)
auto prev_it = it - 1;  // 이전 위치의 반복자 (20을 가리킴)

// 반복자 간 거리
auto distance = std::distance(numbers.begin(), it);  // 2
```

### C++23의 반복자 관련 새로운 기능: `std::views::zip`
C++23에서는 여러 컨테이너를 동시에 순회할 수 있는 `std::views::zip`이 추가되었다.  

```cpp
#include <ranges>

std::vector<std::string> names = {"홍길동", "김철수", "이영희"};
std::vector<int> scores = {95, 88, 76};

// 두 벡터를 동시에 순회
// for (auto [name, score] : std::views::zip(names, scores)) {
//     std::cout << name << ": " << score << "점" << std::endl;
// }

// C++23의 zip이 아직 지원되지 않는 경우, 기존 방식으로 구현
for (size_t i = 0; i < names.size() && i < scores.size(); ++i) {
    std::cout << names[i] << ": " << scores[i] << "점" << std::endl;
}
```
  
-----  

## 4.5 Siv3D 예제: 물체 배열 관리 게임
이제 배운 개념들을 활용하여 Siv3D로 간단한 물체 배열 관리 게임을 만들어 보겠다. 이 게임은 화면에 나타나는 원들을 클릭하여 제거하는 간단한 게임이다.

```cpp
#include <Siv3D.hpp>

// 게임에서 사용할 원 객체 구조체
struct GameCircle {
    Circle circle;   // 원의 형태
    ColorF color;    // 원의 색상
    int points;      // 원의 점수
    double speed;    // 원의 이동 속도
    bool isActive;   // 활성화 상태
    
    // 원 업데이트 메소드
    void update() {
        // 원을 아래로 이동
        circle.y += speed;
        
        // 화면 밖으로 나가면 비활성화
        if (circle.y - circle.r > Scene::Height()) {
            isActive = false;
        }
    }
    
    // 원 그리기 메소드
    void draw() const {
        circle.draw(color);
        
        // 원 안에 점수 표시
        FontAsset(U"GameFont")(points).drawAt(circle.center, ColorF(1.0));
    }
    
    // 클릭 확인 메소드
    bool isClicked() const {
        return circle.leftClicked();
    }
};

void Main() 
{
    // 윈도우 제목 설정
    Window::SetTitle(U"원 클릭 게임");
    
    // 배경색 설정
    Scene::SetBackground(ColorF(0.2, 0.3, 0.4));
    
    // 폰트 등록
    FontAsset::Register(U"GameFont", 24, Typeface::CJK_Regular_KR);
    FontAsset::Register(U"ScoreFont", 36, Typeface::CJK_Regular_KR);
    
    // 게임 상태 변수
    int score = 0;
    double gameTime = 30.0;  // 게임 시간 (초)
    
    // 원들을 관리할 벡터
    std::vector<GameCircle> circles;
    
    // 난수 생성기 초기화
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> colorDist(0.0, 1.0);
    std::uniform_int_distribution<> pointsDist(10, 50);
    std::uniform_real_distribution<> radiusDist(30.0, 60.0);
    std::uniform_real_distribution<> speedDist(2.0, 5.0);
    std::uniform_real_distribution<> xPosDist(100.0, 700.0);
    
    // 게임 루프
    while (System::Update()) {
        // 게임 시간 업데이트
        gameTime -= Scene::DeltaTime();
        
        // 시간이 남아있는 경우 게임 진행
        if (gameTime > 0) {
            // 일정 확률로 새 원 생성
            if (RandomBool(0.05)) {
                GameCircle newCircle;
                newCircle.circle = Circle(xPosDist(gen), 0, radiusDist(gen));
                newCircle.color = ColorF(colorDist(gen), colorDist(gen), colorDist(gen), 0.8);
                newCircle.points = pointsDist(gen);
                newCircle.speed = speedDist(gen);
                newCircle.isActive = true;
                
                circles.push_back(newCircle);
            }
            
            // 각 원 업데이트 및 그리기
            for (auto& circle : circles) {
                if (circle.isActive) {
                    circle.update();
                    circle.draw();
                    
                    // 클릭 확인
                    if (circle.isClicked()) {
                        score += circle.points;
                        circle.isActive = false;
                    }
                }
            }
            
            // 비활성화된 원들 제거 (erase-remove 패턴)
            circles.erase(
                std::remove_if(circles.begin(), circles.end(),
                    [](const GameCircle& c) { return !c.isActive; }),
                circles.end()
            );
            
            // 현재 원의 개수 정보 표시
            FontAsset(U"GameFont")(U"원 개수: {}"_fmt(circles.size())).draw(20, 20, ColorF(1.0));
            
            // 점수 및 남은 시간 표시
            FontAsset(U"ScoreFont")(U"점수: {}"_fmt(score)).draw(20, 60, ColorF(1.0, 0.8, 0.2));
            FontAsset(U"GameFont")(U"남은 시간: {:.1f}"_fmt(gameTime)).draw(20, 110, ColorF(1.0));
        }
        // 게임 종료
        else {
            // 게임 결과 화면
            FontAsset(U"ScoreFont")(U"게임 종료!").drawAt(Scene::Center().movedBy(0, -50), ColorF(1.0));
            FontAsset(U"ScoreFont")(U"최종 점수: {}"_fmt(score)).drawAt(Scene::Center().movedBy(0, 0), ColorF(1.0, 0.8, 0.2));
            FontAsset(U"GameFont")(U"다시 하려면 R 키를 누르세요").drawAt(Scene::Center().movedBy(0, 50), ColorF(1.0));
            
            // R 키를 누르면 게임 재시작
            if (KeyR.down()) {
                score = 0;
                gameTime = 30.0;
                circles.clear();
            }
        }
    }
}
```
  
### 코드 설명
- `GameCircle` 구조체를 정의하여 게임에서 사용할 원 객체의 속성과 메소드를 캡슐화했다.
- `std::vector<GameCircle>`을 사용하여 여러 원 객체를 효율적으로 관리한다.
- 반복문을 사용하여 모든 원을 업데이트하고 그린다.
- `std::remove_if`와 `erase`를 조합한 "erase-remove 패턴"을 사용하여 비활성화된 원들을 벡터에서 제거한다.
- 난수 생성기를 사용하여 원의 다양한 속성을 랜덤하게 설정한다.
  

## 4.6 Siv3D 예제: 파티클 시스템
이번에는 벡터를 활용하여 간단한 파티클 시스템을 구현해 보겠다.

```cpp
#include <Siv3D.hpp>

// 파티클 구조체 정의
struct Particle {
	Vec2 position;      // 위치
	Vec2 velocity;      // 속도
	ColorF color;       // 색상
	double size;        // 크기
	double lifeTime;    // 생존 시간
	double maxLifeTime; // 최대 생존 시간

	// 생성자
	Particle(const Vec2& pos, const Vec2& vel, const ColorF& col, double sz, double life)
		: position(pos), velocity(vel), color(col), size(sz), lifeTime(life), maxLifeTime(life) {
	}

	// 업데이트 메소드
	bool update(double deltaTime) {
		// 위치 업데이트
		position += velocity * deltaTime;

		// 중력 효과 추가
		velocity.y += 100.0 * deltaTime;

		// 공기 저항 효과
		velocity *= 0.98;

		// 생존 시간 감소
		lifeTime -= deltaTime;

		// 파티클이 살아있는지 여부 반환
		return lifeTime > 0;
	}

	// 그리기 메소드
	void draw() const {
		// 생존 시간에 따른 투명도 계산
		double alpha = lifeTime / maxLifeTime;

		// 원으로 파티클 그리기
		Circle(position, size).draw(ColorF(color, alpha));
	}
};

void Main() {
	// 윈도우 제목 설정
	Window::SetTitle(U"파티클 시스템");

	// 배경색 설정
	Scene::SetBackground(ColorF(0.1, 0.1, 0.1));

	FontAsset::Register(U"GameFont", 24, Typeface::CJK_Regular_KR);

	// 파티클을 저장할 벡터
	std::vector<Particle> particles;

	// 마지막 폭발 시간 기록용 변수
	double lastExplosionTime = 0;

	// 난수 생성기 초기화
	std::random_device rd;
	std::mt19937 gen(rd());

	// 게임 루프
	while (System::Update()) {
		// 현재 프레임의 deltaTime 가져오기
		const double deltaTime = Scene::DeltaTime();

		// 마우스 왼쪽 버튼 클릭 또는 5초마다 자동 폭발
		if (MouseL.down() || (Scene::Time() - lastExplosionTime > 5.0)) {
			// 마지막 폭발 시간 갱신
			lastExplosionTime = Scene::Time();

			// 폭발 위치 (마우스 클릭 시 마우스 위치, 자동 폭발 시 랜덤 위치)
			Vec2 explosionPos = MouseL.down() ? Cursor::Pos() : RandomVec2(Scene::Rect());

			// 다수의 파티클 생성
			std::uniform_real_distribution<> angleDist(0.0, Math::TwoPi);
			std::uniform_real_distribution<> speedDist(100.0, 300.0);
			std::uniform_real_distribution<> sizeDist(3.0, 8.0);
			std::uniform_real_distribution<> lifeDist(1.0, 3.0);

			// 새 파티클 추가
			for (int i = 0; i < 100; ++i) {
				// 랜덤 각도와 속도로 파티클 방향 결정
				double angle = angleDist(gen);
				double speed = speedDist(gen);
				Vec2 velocity(std::cos(angle) * speed, std::sin(angle) * speed);

				// HSV 색상 공간을 사용하여 무지개 색상 생성
				ColorF color = HSV(i * 3.6, 0.8, 1.0);

				// 파티클 생성 및 벡터에 추가
				particles.emplace_back(
					explosionPos,
					velocity,
					color,
					sizeDist(gen),
					lifeDist(gen)
				);
			}
		}

		// 모든 파티클 업데이트 및 그리기
		for (auto it = particles.begin(); it != particles.end();) {
			// 파티클 업데이트 후 살아있는지 확인
			if (it->update(deltaTime)) {
				// 파티클 그리기
				it->draw();
				++it;
			}
			else {
				// 수명이 다한 파티클 제거
				it = particles.erase(it);
			}
		}

		// 현재 파티클 수와 FPS 표시
		FontAsset(U"GameFont")(U"파티클 수: {}"_fmt(particles.size())).draw(20, 20, ColorF(1.0));
		FontAsset(U"GameFont")(U"FPS: {}"_fmt(Profiler::FPS())).draw(20, 60, ColorF(1.0));

		// 도움말 표시
		FontAsset(U"GameFont")(U"마우스 클릭으로 폭발 생성").draw(20, Scene::Height() - 40, ColorF(0.7));
	}
}

```

### 코드 설명
- `Particle` 구조체를 정의하여 각 파티클의 속성과 동작을 캡슐화했다.
- `std::vector<Particle>`을 사용하여 수많은 파티클을 효율적으로 관리한다.
- 반복자를 사용하여 벡터를 순회하며 수명이 다한 파티클을 제거한다.
- `emplace_back()`을 사용하여 파티클 객체를 효율적으로 생성하고 벡터에 추가한다.
- 물리적인 효과(중력, 공기 저항)를 구현하여 현실감 있는 파티클 움직임을 만들었다.
  

## 4.7 Siv3D 예제: 문자열 처리 게임
마지막으로, 문자열 처리를 활용한 간단한 타자 연습 게임을 만들어 보겠다.

```cpp
#include <Siv3D.hpp>

void Main()
{
	// 윈도우 제목 설정
	Window::SetTitle(U"타자 연습 게임");

	// 배경색 설정
	Scene::SetBackground(ColorF(0.2, 0.2, 0.2));

	// 폰트 등록
	FontAsset::Register(U"Title", 36, Typeface::CJK_Regular_KR);
	FontAsset::Register(U"Text", 24, Typeface::CJK_Regular_KR);
	FontAsset::Register(U"Info", 18, Typeface::CJK_Regular_KR);

	// 단어 목록
	const Array<String> wordList = {
		U"hello", U"world", U"code", U"game", U"play",
		U"learn", U"study", U"create", U"build", U"design",
		U"keyboard", U"mouse", U"screen", U"window", U"button",
		U"music", U"sound", U"color", U"shape", U"circle"
	};

	// 게임 상태 변수
	String currentWord;          // 현재 표시 단어
	String typedWord;            // 사용자가 입력한 단어
	int score = 0;               // 점수
	int wordsCompleted = 0;      // 완료한 단어 수
	double timeLimit = 30.0;     // 게임 시간
	double currentTime = 0.0;    // 현재 경과 시간
	bool gameActive = false;     // 게임 활성화 상태

	// 단어 구름 (배경에 표시되는 단어들)
	struct WordCloud {
		String word;
		Vec2 position;
		double speed;
		ColorF color;
	};

	// 단어 구름 벡터
	std::vector<WordCloud> wordCloud;

	// 단어 구름 초기화
	for (int i = 0; i < 20; ++i) {
		WordCloud cloud;
		cloud.word = wordList[Random(wordList.size() - 1)];
		cloud.position = RandomVec2(Scene::Rect());
		cloud.speed = Random(20.0, 40.0);
		cloud.color = HSV(Random(0, 360), 0.3, 0.7);
		wordCloud.push_back(cloud);
	}

	// 새 단어 선택 함수
	auto selectNewWord = [&]() {
		int index = Random(wordList.size() - 1);
		currentWord = wordList[index];
		typedWord.clear();
		};

	// 게임 시작 함수
	auto startGame = [&]() {
		score = 0;
		wordsCompleted = 0;
		currentTime = 0.0;
		gameActive = true;
		selectNewWord();
		};

	// 게임 루프
	while (System::Update()) {
		// 배경에 단어 구름 그리기
		for (auto& cloud : wordCloud) {
			// 단어 이동
			cloud.position.x += cloud.speed * Scene::DeltaTime();

			// 화면 밖으로 나가면 반대편에서 다시 등장
			if (cloud.position.x > Scene::Width() + 100) {
				cloud.position.x = -100;
				cloud.position.y = Random(Scene::Height());
			}

			// 단어 그리기
			FontAsset(U"Info")(cloud.word).draw(cloud.position, cloud.color);
		}

		// 게임 활성화 상태인 경우
		if (gameActive) {
			// 시간 업데이트
			currentTime += Scene::DeltaTime();

			// 시간이 다 되면 게임 종료
			if (currentTime >= timeLimit) {
				gameActive = false;
			}

			// 키보드 입력 처리
			const String input = TextInput::GetRawInput();
			if (!input.isEmpty()) {
				typedWord += input;

				// 입력한 단어가 현재 단어보다 길면 자르기
				if (typedWord.length() > currentWord.length()) {
					typedWord = typedWord.substr(0, currentWord.length());
				}

				// 단어를 정확히 입력했으면 점수 추가 및 새 단어 선택
				if (typedWord == currentWord) {
					score += currentWord.length() * 10;
					wordsCompleted++;
					selectNewWord();
				}
			}

			// 백스페이스 처리
			if (KeyBackspace.down() && !typedWord.isEmpty()) {
				typedWord.pop_back();
			}

			// 현재 단어와 입력 단어 표시
			FontAsset(U"Title")(currentWord).drawAt(Scene::Center().movedBy(0, -50), ColorF(0.9));

			// 입력 중인 단어 표시 (일치 여부에 따라 색상 변경)
			for (size_t i = 0; i < currentWord.length(); ++i) {
				const bool correct = i < typedWord.length() && typedWord[i] == currentWord[i];
				const ColorF color = correct ? ColorF(0.3, 1.0, 0.3) : ColorF(1.0, 0.3, 0.3);

				if (i < typedWord.length()) {
					// 입력한 부분
					FontAsset(U"Text")(currentWord[i]).draw(Scene::Center().x - currentWord.length() * 12 + i * 24, Scene::Center().y, color);
				}
				else {
					// 아직 입력하지 않은 부분
					FontAsset(U"Text")(currentWord[i]).draw(Scene::Center().x - currentWord.length() * 12 + i * 24, Scene::Center().y, ColorF(0.5));
				}
			}

			// 게임 정보 표시
			FontAsset(U"Info")(U"남은 시간: {:.1f}초"_fmt(timeLimit - currentTime)).draw(20, 20, ColorF(1.0));
			FontAsset(U"Info")(U"점수: {}"_fmt(score)).draw(20, 50, ColorF(1.0, 0.8, 0.2));
			FontAsset(U"Info")(U"완료한 단어: {}"_fmt(wordsCompleted)).draw(20, 80, ColorF(1.0));
		}
		// 게임 종료 상태
		else {
			// 시작 화면 또는 결과 화면
			if (currentTime == 0.0) {
				// 게임 시작 화면
				FontAsset(U"Title")(U"타자 연습 게임").drawAt(Scene::Center().movedBy(0, -80), ColorF(1.0, 0.8, 0.2));
				FontAsset(U"Text")(U"스페이스 바를 눌러 게임 시작").drawAt(Scene::Center(), ColorF(0.9));

				// 스페이스 바를 누르면 게임 시작
				if (KeySpace.down()) {
					startGame();
				}
			}
			else {
				// 게임 결과 화면
				FontAsset(U"Title")(U"게임 종료!").drawAt(Scene::Center().movedBy(0, -100), ColorF(1.0));
				FontAsset(U"Text")(U"최종 점수: {}"_fmt(score)).drawAt(Scene::Center().movedBy(0, -50), ColorF(1.0, 0.8, 0.2));
				FontAsset(U"Text")(U"완료한 단어: {} (평균 {:.1f}초/단어)"_fmt(
					wordsCompleted, wordsCompleted > 0 ? timeLimit / wordsCompleted : 0.0)
				).drawAt(Scene::Center(), ColorF(0.9));
				FontAsset(U"Text")(U"스페이스 바를 눌러 다시 시작").drawAt(Scene::Center().movedBy(0, 50), ColorF(0.7));

				// 스페이스 바를 누르면 게임 재시작
				if (KeySpace.down()) {
					startGame();
				}
			}
		}
	}
}
```

### 코드 설명
- 단어 목록을 `Array<String>` 컨테이너로 관리한다.
- 사용자 입력(`typedWord`)과 현재 단어(`currentWord`)를 비교하여 타이핑 정확도를 확인한다.
- 배경에 움직이는 단어 구름을 구현하기 위해 `WordCloud` 구조체와 `std::vector`를 사용한다.
- 람다 함수(`selectNewWord`, `startGame`)를 사용하여 코드를 모듈화했다.
- 문자열 메소드(`length()`, `substr()`, `pop_back()`)를 활용하여 사용자 입력을 처리한다.
    
-----  
  
## 4.8 연습 문제
1. **물체 배열 게임 확장하기**:
   - 다양한 모양의 객체(삼각형, 사각형 등)를 추가하세요.
   - 특수 효과를 가진 보너스 아이템을 구현하세요.

2. **파티클 시스템 개선하기**:
   - 다양한 파티클 효과(불꽃, 물방울, 연기 등)를 구현하세요.
   - 파티클이 장애물과 충돌하도록 물리 시스템을 추가하세요.

3. **타자 게임 확장하기**:
   - 난이도 선택 기능을 추가하세요(쉬움, 보통, 어려움).
   - 멀티플레이어 모드를 구현하세요(한 플레이어는 화살표 키, 다른 플레이어는 WASD).

4. **메모리 관리 실험하기**:
   - 세 가지 예제에서 사용된 컨테이너의 메모리 사용량을 측정하고 비교하세요.
   - 대량의 객체(10,000개 이상)를 효율적으로 관리하는 방법을 연구하세요.
  

이번 장에서는 C++의 배열과 컬렉션에 대해 배우고, Siv3D를 활용하여 실제 예제를 구현해 보았다. 이러한 개념들은 게임 개발과 그래픽 애플리케이션에서 매우 중요하며, 효율적인 데이터 관리의 기초가 된다. 다음 장에서는 클래스와 객체지향 프로그래밍에 대해 배워보겠다.  


