# OpenSiv3Dë¥¼ ì´ìš©í•œ C++ í”„ë¡œê·¸ë˜ë° í•™ìŠµ
  
ì €ì: ìµœí¥ë°°, Claude AI  
  
C++ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¥¼ ë°°ìš°ëŠ” ê²ƒì— ì¤‘ì ì„ ë‘ë˜, Siv3D í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•˜ì—¬ ì‹œê°ì ìœ¼ë¡œ í¥ë¯¸ë¡œìš´ ì˜ˆì œë¥¼ í†µí•´ í•™ìŠµ íš¨ê³¼ë¥¼ ë†’ì´ë„ë¡ ì„¤ê³„ ë˜ì—ˆë‹¤. ë‹¨ìˆœí•œ ì½˜ì†” í”„ë¡œê·¸ë¨ ëŒ€ì‹  ê·¸ë˜í”½, ì†Œë¦¬, ìƒí˜¸ì‘ìš©ì„ í¬í•¨í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ë©° C++ì˜ ê°œë…ì„ ìµí ìˆ˜ ìˆë‹¤.  
  
í•„ìš” ì†Œí”„íŠ¸ì›¨ì–´:  
- Windows 10 ì´ìƒ
- Visual Studio 2022 ì´ìƒ   
  
-----    
    
# Chapter.05: ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë° ê¸°ì´ˆ

ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°(OOP)ì€ í˜„ëŒ€ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œì˜ í•µì‹¬ íŒ¨ëŸ¬ë‹¤ì„ì´ë‹¤. C++ëŠ” ì´ëŸ¬í•œ ê°ì²´ì§€í–¥ ê°œë…ì„ ì™„ë²½í•˜ê²Œ ì§€ì›í•˜ë©°, Siv3DëŠ” ì´ëŸ¬í•œ ê°œë…ì„ ì‹œê°ì ì´ê³  ì¬ë¯¸ìˆê²Œ í•™ìŠµí•  ìˆ˜ ìˆëŠ” í™˜ê²½ì„ ì œê³µí•œë‹¤.
  

## 5.1 í´ë˜ìŠ¤ì™€ ê°ì²´

### ê¸°ë³¸ ê°œë…
**í´ë˜ìŠ¤(Class)** ëŠ” ë°ì´í„°ì™€ í•´ë‹¹ ë°ì´í„°ë¥¼ ì¡°ì‘í•˜ëŠ” í•¨ìˆ˜ë¥¼ í•˜ë‚˜ë¡œ ë¬¶ëŠ” ì‚¬ìš©ì ì •ì˜ ë°ì´í„° íƒ€ì…ì´ë‹¤. **ê°ì²´(Object)** ëŠ” í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ì´ë‹¤.

```cpp
// ê¸°ë³¸ì ì¸ í´ë˜ìŠ¤ ì •ì˜
class Player {
public:
    String name;
    Vec2 position{0, 0};
    double speed{5.0};
    
    void move(Vec2 direction) {
        position += direction * speed;
    }
};

// ê°ì²´ ìƒì„± ë° ì‚¬ìš©
Player player1;
player1.name = U"í”Œë ˆì´ì–´1";
player1.move(Vec2{1, 0}); // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
```

### Siv3D í™œìš© ì˜ˆì œ: ê²Œì„ ìºë¦­í„° í´ë˜ìŠ¤

```cpp
#include <Siv3D.hpp>

class Character 
{
public:
    String name;
    Vec2 position;
    Texture texture;
    double speed;
    
    // ìºë¦­í„° ê·¸ë¦¬ê¸°
    void draw() const {
        texture.drawAt(position);
    }
    
    // ìºë¦­í„° ì´ë™
    void moveByKeys() {
        if (KeyW.pressed()) position.y -= speed;
        if (KeyS.pressed()) position.y += speed;
        if (KeyA.pressed()) position.x -= speed;
        if (KeyD.pressed()) position.x += speed;
    }
};

void Main() 
{
    Scene::SetBackground(ColorF{0.8, 0.9, 1.0});
    
    // ìºë¦­í„° ê°ì²´ ìƒì„±
    Character player;
    player.name = U"ì£¼ì¸ê³µ";
    player.position = Scene::Center();
    player.texture = Texture{U"ğŸ§™"_emoji};
    player.speed = 5.0;
    
    while (System::Update()) {
        // ìºë¦­í„° ì´ë™ ë° ê·¸ë¦¬ê¸°
        player.moveByKeys();
        player.draw();
        
        // í˜„ì¬ ìœ„ì¹˜ í‘œì‹œ
        FontAsset(U"Regular")(U"Position: ({:.1f}, {:.1f})"_fmt(player.position.x, player.position.y))
            .draw(20, 20, ColorF{0.25});
    }
}
```   
  
ì‹¤í–‰ í™”ë©´: 
![](./images/012.png)   
    

## 5.2 ìº¡ìŠí™”

### ê¸°ë³¸ ê°œë…
**ìº¡ìŠí™”(Encapsulation)** ëŠ” ë°ì´í„°(ì†ì„±)ì™€ í•´ë‹¹ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë©”ì„œë“œë¥¼ í•˜ë‚˜ì˜ ë‹¨ìœ„ë¡œ ë¬¶ê³ , ê°ì²´ì˜ ë‚´ë¶€ ìƒíƒœë¥¼ ì™¸ë¶€ì—ì„œ ì§ì ‘ ì ‘ê·¼í•˜ì§€ ëª»í•˜ê²Œ í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

```cpp
class BankAccount 
{
private:
    String owner;
    double balance;
    
public:
    // ìƒì„±ì
    BankAccount(const String& ownerName, double initialBalance)
        : owner(ownerName), balance(initialBalance) {}
    
    // ì…ê¸ˆ
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
    
    // ì¶œê¸ˆ
    bool withdraw(double amount) {
        if (amount > 0 && balance >= amount) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    // ì”ì•¡ í™•ì¸
    double getBalance() const {
        return balance;
    }
};
```

### Siv3D í™œìš© ì˜ˆì œ: ì¶©ëŒ ê°ì§€ ê¸°ëŠ¥ì´ ìˆëŠ” ë¬¼ì²´ í´ë˜ìŠ¤

```cpp
#include <Siv3D.hpp>

class CollisionObject 
{
private:
    Vec2 position;
    double radius;
    ColorF color;
    bool isColliding = false;
    
public:
    // ìƒì„±ì
    CollisionObject(const Vec2& pos, double r, const ColorF& col)
        : position(pos), radius(r), color(col) {}
    
    // ìœ„ì¹˜ ì„¤ì •
    void setPosition(const Vec2& newPos) {
        position = newPos;
    }
    
    // ìœ„ì¹˜ ì–»ê¸°
    Vec2 getPosition() const {
        return position;
    }
    
    // ë°˜ì§€ë¦„ ì–»ê¸°
    double getRadius() const {
        return radius;
    }
    
    // ì¶©ëŒ ìƒíƒœ ì„¤ì •
    void setColliding(bool state) {
        isColliding = state;
    }
    
    // ê°ì²´ ê·¸ë¦¬ê¸°
    void draw() const {
        Circle{position, radius}.draw(isColliding ? ColorF{1.0, 0.3, 0.3, 0.8} : color);
    }
    
    // ë‹¤ë¥¸ ê°ì²´ì™€ ì¶©ëŒ ê²€ì‚¬
    bool checkCollision(const CollisionObject& other) const {
        return position.distanceFrom(other.position) < (radius + other.radius);
    }
};

void Main() 
{
    Scene::SetBackground(ColorF{0.2, 0.3, 0.4});
    
    // ë¬¼ì²´ ìƒì„±
    CollisionObject player{Scene::Center(), 30, ColorF{0.8, 0.6, 0.2}};
    Array<CollisionObject> objects;
    
    // ëœë¤í•œ ìœ„ì¹˜ì— ë¬¼ì²´ 10ê°œ ìƒì„±
    for (int i = 0; i < 10; ++i) {
        objects << CollisionObject{
            RandomVec2(Scene::Rect().stretched(-50)),
            Random(15.0, 40.0),
            ColorF{Random(0.2, 0.9), Random(0.2, 0.9), Random(0.2, 0.9)}
        };
    }
    
    while (System::Update()) {
        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¡œ í”Œë ˆì´ì–´ ì´ë™
        player.setPosition(Cursor::Pos());
        
        // ì¶©ëŒ ì²´í¬
        for (auto& obj : objects) {
            bool collision = player.checkCollision(obj);
            obj.setColliding(collision);
        }
        
        // ë¬¼ì²´ ê·¸ë¦¬ê¸°
        for (const auto& obj : objects) {
            obj.draw();
        }
        player.draw();
    }
}
```  
  
ì‹¤í–‰ í™”ë©´: 
![](./images/014.png)   
  
  
## 5.3 ìƒì„±ìì™€ ì†Œë©¸ì

### ê¸°ë³¸ ê°œë…
**ìƒì„±ì(Constructor)** ëŠ” ê°ì²´ê°€ ìƒì„±ë  ë•Œ ìë™ìœ¼ë¡œ í˜¸ì¶œë˜ëŠ” íŠ¹ë³„í•œ ë©¤ë²„ í•¨ìˆ˜ë¡œ, ê°ì²´ë¥¼ ì´ˆê¸°í™”í•˜ëŠ” ì—­í• ì„ í•œë‹¤.  
**ì†Œë©¸ì(Destructor)** ëŠ” ê°ì²´ê°€ ì†Œë©¸ë  ë•Œ ìë™ìœ¼ë¡œ í˜¸ì¶œë˜ëŠ” íŠ¹ë³„í•œ ë©¤ë²„ í•¨ìˆ˜ë¡œ, ê°ì²´ê°€ ì‚¬ìš©í•œ ìì›ì„ ì •ë¦¬í•œë‹¤.  

```cpp
class Resource 
{
private:
    String resourceName;
    bool* allocated = nullptr;
    
public:
    // ê¸°ë³¸ ìƒì„±ì
    Resource() : resourceName(U"Unknown") {
        Print << U"ê¸°ë³¸ ìƒì„±ì í˜¸ì¶œë¨";
    }
    
    // ë§¤ê°œë³€ìˆ˜ ìˆëŠ” ìƒì„±ì
    Resource(const String& name) : resourceName(name) {
        Print << resourceName << U" ìƒì„±ì í˜¸ì¶œë¨";
        allocated = new bool{true};
    }
    
    // ë³µì‚¬ ìƒì„±ì
    Resource(const Resource& other) : resourceName(other.resourceName + U"_copy") {
        Print << resourceName << U" ë³µì‚¬ ìƒì„±ì í˜¸ì¶œë¨";
        if (other.allocated) {
            allocated = new bool{*other.allocated};
        }
    }
    
    // ì´ë™ ìƒì„±ì (C++11 ì´ìƒ)
    Resource(Resource&& other) noexcept : resourceName(std::move(other.resourceName)) {
        Print << resourceName << U" ì´ë™ ìƒì„±ì í˜¸ì¶œë¨";
        allocated = other.allocated;
        other.allocated = nullptr;
    }
    
    // ì†Œë©¸ì
    ~Resource() {
        Print << resourceName << U" ì†Œë©¸ì í˜¸ì¶œë¨";
        delete allocated;
    }
    
    String getName() const {
        return resourceName;
    }
};
```

### Siv3D í™œìš© ì˜ˆì œ: ê²Œì„ ê°ì²´ ìƒì„± ë° ì†Œë©¸

```cpp
#include <Siv3D.hpp>

class GameObject 
{
private:
    String name;
    Vec2 position;
    Texture texture;
    double lifeTime;
    double creationTime;
    
public:
    // ìƒì„±ì
    GameObject(const String& objectName, const Vec2& pos, const Texture& tex, double life = 5.0)
        : name(objectName), position(pos), texture(tex), lifeTime(life), creationTime(Scene::Time()) {
        Print << name << U" ê°ì²´ ìƒì„±ë¨";
    }
    
    // ì†Œë©¸ì
    ~GameObject() {
        Print << name << U" ê°ì²´ ì†Œë©¸ë¨";
    }
    
    // ê°ì²´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
    bool update() {
        double elapsed = Scene::Time() - creationTime;
        double alpha = 1.0 - Min(elapsed / lifeTime, 1.0);
        
        if (alpha <= 0) {
            return false; // ìˆ˜ëª…ì´ ë‹¤í•˜ë©´ false ë°˜í™˜
        }
        
        // ê°ì²´ ê·¸ë¦¬ê¸°
        texture.drawAt(position, ColorF{1.0, 1.0, 1.0, alpha});
        FontAsset(U"Regular")(name).drawAt(position.movedBy(0, -40), ColorF{0.2, 0.2, 0.2, alpha});
        
        // ë‚¨ì€ ìˆ˜ëª… í‘œì‹œ
        RectF{position.x - 25, position.y + 30, 50 * (1.0 - elapsed / lifeTime), 5}
            .draw(ColorF{0.3, 0.8, 0.3, alpha});
            
        return true;
    }
};

void Main() 
{
    Scene::SetBackground(ColorF{0.6, 0.7, 0.8});
    
    FontAsset::Register(U"Regular", FontMethod::MSDF, 18, Typeface::CJK_Regular_KR);
    
    // ì‚¬ìš©í•  ì´ëª¨ì§€ í…ìŠ¤ì²˜ ë¯¸ë¦¬ ë¡œë“œ
    const Array<Texture> textures = {
        Texture{U"ğŸ¶"_emoji}, Texture{U"ğŸ±"_emoji}, Texture{U"ğŸ­"_emoji},
        Texture{U"ğŸ°"_emoji}, Texture{U"ğŸ¦Š"_emoji}, Texture{U"ğŸ»"_emoji}
    };
    
    // GameObject ê°ì²´ë¥¼ ê´€ë¦¬í•  ë°°ì—´
    Array<std::unique_ptr<GameObject>> gameObjects;
    
    while (System::Update()) 
    {
        // ë§ˆìš°ìŠ¤ ì™¼ìª½ ë²„íŠ¼ìœ¼ë¡œ ê°ì²´ ìƒì„±
        if (MouseL.down()) {
            int index = Random(textures.size() - 1);
            String name = U"ê°ì²´_" + Format(gameObjects.size() + 1);
            gameObjects << std::make_unique<GameObject>(
                name, Cursor::Pos(), textures[index], Random(3.0, 8.0)
            );
        }
        
        // ëª¨ë“  ê°ì²´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
        for (auto it = gameObjects.begin(); it != gameObjects.end();) {
            if ((*it)->update()) {
                ++it; // ê°ì²´ê°€ ì•„ì§ ì‚´ì•„ìˆìœ¼ë©´ ë‹¤ìŒìœ¼ë¡œ
            } else {
                it = gameObjects.erase(it); // ê°ì²´ ìˆ˜ëª…ì´ ë‹¤í•˜ë©´ ì œê±°
            }
        }
        
        // í˜„ì¬ ê°ì²´ ìˆ˜ í‘œì‹œ
        FontAsset(U"Regular")(U"í˜„ì¬ ê°ì²´ ìˆ˜: {}"_fmt(gameObjects.size())).draw(20, 20, ColorF{0.25});
        FontAsset(U"Regular")(U"í´ë¦­í•˜ì—¬ ê°ì²´ ìƒì„±").draw(20, 50, ColorF{0.25});
    }
}
```  
  
ì‹¤í–‰ í™”ë©´:  
![](./images/015.png)    


## 5.4 ì ‘ê·¼ ì œì–´ì

### ê¸°ë³¸ ê°œë…
C++ëŠ” ì„¸ ê°€ì§€ ì ‘ê·¼ ì œì–´ìë¥¼ ì œê³µí•©ë‹ˆë‹¤:
- **private**: í•´ë‹¹ í´ë˜ìŠ¤ ë‚´ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥
- **protected**: í•´ë‹¹ í´ë˜ìŠ¤ì™€ íŒŒìƒ í´ë˜ìŠ¤ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥
- **public**: ì–´ë””ì—ì„œë‚˜ ì ‘ê·¼ ê°€ëŠ¥

```cpp
class Person 
{
private:
    String name;
    int age;
    
protected:
    void updateAge(int newAge) {
        if (newAge >= 0) {
            age = newAge;
        }
    }
    
public:
    Person(const String& personName, int personAge)
        : name(personName), age(personAge) {}
    
    String getName() const {
        return name;
    }
    
    int getAge() const {
        return age;
    }
    
    void setName(const String& newName) {
        name = newName;
    }
    
    void birthday() {
        updateAge(age + 1);
    }
};
```

### Siv3D í™œìš© ì˜ˆì œ: ê°„ë‹¨í•œ ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ

```cpp
#include <Siv3D.hpp>

// ì•„ì´í…œ í´ë˜ìŠ¤
class Item 
{
private:
    String name;
    String description;
    Texture icon;
    int value;
    
public:
    Item(const String& itemName, const String& itemDesc, const Texture& itemIcon, int itemValue)
        : name(itemName), description(itemDesc), icon(itemIcon), value(itemValue) {}
    
    String getName() const { return name; }
    String getDescription() const { return description; }
    const Texture& getIcon() const { return icon; }
    int getValue() const { return value; }
};

// ì¸ë²¤í† ë¦¬ í´ë˜ìŠ¤
class Inventory 
{
private:
    Array<Item> items;
    size_t capacity;
    
    // ì„ íƒëœ ì•„ì´í…œ ì¸ë±ìŠ¤
    Optional<size_t> selectedItemIndex;
    
public:
    Inventory(size_t maxCapacity = 20) : capacity(maxCapacity) {}
    
    // ì•„ì´í…œ ì¶”ê°€
    bool addItem(const Item& item) {
        if (items.size() >= capacity) {
            return false;
        }
        items << item;
        return true;
    }
    
    // ì•„ì´í…œ ì œê±°
    bool removeItem(size_t index) {
        if (index >= items.size()) {
            return false;
        }
        items.erase(items.begin() + index);
        if (selectedItemIndex && *selectedItemIndex == index) {
            selectedItemIndex.reset();
        } else if (selectedItemIndex && *selectedItemIndex > index) {
            *selectedItemIndex -= 1;
        }
        return true;
    }
    
    // ì¸ë²¤í† ë¦¬ ê·¸ë¦¬ê¸°
    void draw(const Vec2& position, double itemSize = 60.0) {
        const double margin = 10.0;
        const int itemsPerRow = 5;
        
        for (size_t i = 0; i < items.size(); ++i) {
            const int row = static_cast<int>(i) / itemsPerRow;
            const int col = static_cast<int>(i) % itemsPerRow;
            
            const Vec2 itemPos{
                position.x + col * (itemSize + margin),
                position.y + row * (itemSize + margin)
            };
            
            const RectF itemRect{itemPos, itemSize, itemSize};
            
            // ì•„ì´í…œ ìŠ¬ë¡¯ ë°°ê²½
            if (selectedItemIndex && *selectedItemIndex == i) {
                // ì„ íƒëœ ì•„ì´í…œì€ ê°•ì¡° í‘œì‹œ
                itemRect.draw(ColorF{0.3, 0.6, 0.9, 0.7});
            } else {
                // ì¼ë°˜ ì•„ì´í…œ ìŠ¬ë¡¯
                itemRect.draw(ColorF{0.2, 0.2, 0.2, 0.5});
            }
            
            // ì•„ì´í…œ ì•„ì´ì½˜
            items[i].getIcon().resized(itemSize * 0.8).drawAt(itemRect.center());
            
            // ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ ì•„ì´í…œ ì´ë¦„ í‘œì‹œ
            if (itemRect.mouseOver()) {
                Tooltip::Show(items[i].getName() + U"\n" + items[i].getDescription(),
                    Cursor::Pos().movedBy(10, 10));
                
                // í´ë¦­ ì‹œ ì•„ì´í…œ ì„ íƒ
                if (MouseL.down()) {
                    if (selectedItemIndex && *selectedItemIndex == i) {
                        selectedItemIndex.reset(); // ê°™ì€ ì•„ì´í…œ ë‹¤ì‹œ í´ë¦­ ì‹œ ì„ íƒ í•´ì œ
                    } else {
                        selectedItemIndex = i;
                    }
                }
            }
        }
        
        // ë¹ˆ ìŠ¬ë¡¯ ê·¸ë¦¬ê¸° (ìµœëŒ€ ìš©ëŸ‰ê¹Œì§€)
        for (size_t i = items.size(); i < capacity; ++i) {
            const int row = static_cast<int>(i) / itemsPerRow;
            const int col = static_cast<int>(i) % itemsPerRow;
            
            const RectF emptySlot{
                position.x + col * (itemSize + margin),
                position.y + row * (itemSize + margin),
                itemSize, itemSize
            };
            
            emptySlot.drawFrame(1, 0, ColorF{0.5, 0.5, 0.5, 0.5});
        }
        
        // ì„ íƒëœ ì•„ì´í…œì´ ìˆìœ¼ë©´ ìƒì„¸ ì •ë³´ í‘œì‹œ
        if (selectedItemIndex) {
            const Item& selectedItem = items[*selectedItemIndex];
            const RectF detailRect{
                position.x,
                position.y + ((capacity + itemsPerRow - 1) / itemsPerRow) * (itemSize + margin) + margin,
                itemsPerRow * (itemSize + margin) - margin,
                100
            };
            
            detailRect.draw(ColorF{0.1, 0.1, 0.1, 0.7});
            
            FontAsset(U"Regular")(selectedItem.getName())
                .draw(detailRect.pos.movedBy(10, 10), ColorF{1.0});
                
            FontAsset(U"Regular")(selectedItem.getDescription())
                .draw(detailRect.pos.movedBy(10, 40), ColorF{0.8});
                
            FontAsset(U"Regular")(U"ê°€ì¹˜: {}"_fmt(selectedItem.getValue()))
                .draw(detailRect.pos.movedBy(10, 70), ColorF{0.7, 0.9, 0.7});
                
            // ì œê±° ë²„íŠ¼
            const RectF removeButton{
                detailRect.rightX() - 80, detailRect.bottomY() - 30,
                70, 25
            };
            
            if (removeButton.mouseOver()) {
                removeButton.draw(ColorF{0.8, 0.2, 0.2, 0.8});
                if (MouseL.down()) {
                    removeItem(*selectedItemIndex);
                }
            } else {
                removeButton.draw(ColorF{0.7, 0.2, 0.2, 0.6});
            }
            
            FontAsset(U"Regular")(U"ì œê±°").drawAt(removeButton.center(), ColorF{1.0});
        }
    }
    
    // í˜„ì¬ ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ìˆ˜
    size_t size() const {
        return items.size();
    }
    
    // ì¸ë²¤í† ë¦¬ê°€ ê°€ë“ ì°¼ëŠ”ì§€ í™•ì¸
    bool isFull() const {
        return items.size() >= capacity;
    }
};

void Main() 
{
    Scene::SetBackground(ColorF{0.3, 0.4, 0.5});

    FontAsset::Register(U"Regular", FontMethod::MSDF, 18, Typeface::CJK_Regular_KR);
    
    // ì•„ì´í…œ ì•„ì´ì½˜ í…ìŠ¤ì²˜
    const Array<std::pair<String, Texture>> itemIcons = {
        {U"ê²€", Texture{U"ğŸ—¡ï¸"_emoji}},
        {U"í™œ", Texture{U"ğŸ¹"_emoji}},
        {U"ë°©íŒ¨", Texture{U"ğŸ›¡ï¸"_emoji}},
        {U"ëª¨ì", Texture{U"ğŸ©"_emoji}},
        {U"ê°€ë°©", Texture{U"ğŸ‘œ"_emoji}},
        {U"ë¬¼ì•½", Texture{U"ğŸ§ª"_emoji}},
        {U"ë°˜ì§€", Texture{U"ğŸ’"_emoji}},
        {U"ì±…", Texture{U"ğŸ“š"_emoji}},
        {U"ì§€ë„", Texture{U"ğŸ—ºï¸"_emoji}},
        {U"ì—´ì‡ ", Texture{U"ğŸ”‘"_emoji}}
    };
    
    // ì•„ì´í…œ ì„¤ëª…
    const Array<String> descriptions = {
        U"ê°•ë ¥í•œ ê³µê²©ë ¥ì„ ê°€ì§„ ë¬´ê¸°ì…ë‹ˆë‹¤.",
        U"ì›ê±°ë¦¬ ê³µê²©ì´ ê°€ëŠ¥í•œ ì¥ë¹„ì…ë‹ˆë‹¤.",
        U"ë°©ì–´ë ¥ì„ ë†’ì—¬ì£¼ëŠ” ì¥ë¹„ì…ë‹ˆë‹¤.",
        U"ë§ˆë²• ì €í•­ë ¥ì„ ë†’ì—¬ì£¼ëŠ” ì¥ë¹„ì…ë‹ˆë‹¤.",
        U"ì•„ì´í…œì„ ë” ë§ì´ ì†Œì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        U"ì²´ë ¥ì„ íšŒë³µì‹œì¼œì£¼ëŠ” ë¬¼ì•½ì…ë‹ˆë‹¤.",
        U"íŠ¹ìˆ˜í•œ ëŠ¥ë ¥ì„ ë¶€ì—¬í•˜ëŠ” ë§ˆë²• ì•„ì´í…œì…ë‹ˆë‹¤.",
        U"ìƒˆë¡œìš´ ìŠ¤í‚¬ì„ ë°°ìš¸ ìˆ˜ ìˆëŠ” ì±…ì…ë‹ˆë‹¤.",
        U"ë¯¸ì§€ì˜ ì˜ì—­ì„ í‘œì‹œí•˜ëŠ” ì§€ë„ì…ë‹ˆë‹¤.",
        U"íŠ¹ë³„í•œ ë¬¸ì„ ì—´ ìˆ˜ ìˆëŠ” ì—´ì‡ ì…ë‹ˆë‹¤."
    };
    
    // ì¸ë²¤í† ë¦¬ ìƒì„±
    Inventory inventory{15};
    
    while (System::Update()) {
        // ì¸ë²¤í† ë¦¬ ê·¸ë¦¬ê¸°
        inventory.draw(Vec2{50, 50});
        
        // ëœë¤ ì•„ì´í…œ ì¶”ê°€ ë²„íŠ¼
        RectF addButton{50, 480, 180, 40};
        
        if (addButton.mouseOver()) {
            addButton.draw(ColorF{0.4, 0.6, 0.4, 0.8});
            if (MouseL.down() && !inventory.isFull()) {
                // ëœë¤ ì•„ì´í…œ ìƒì„±
                int index = Random(itemIcons.size() - 1);
                Item newItem{
                    itemIcons[index].first,
                    descriptions[index],
                    itemIcons[index].second,
                    Random(10, 500)
                };
                inventory.addItem(newItem);
            }
        } else {
            addButton.draw(ColorF{0.3, 0.5, 0.3, 0.6});
        }
        
        FontAsset(U"Regular")(U"ëœë¤ ì•„ì´í…œ ì¶”ê°€").drawAt(addButton.center(), ColorF{1.0});
        
        // ì¸ë²¤í† ë¦¬ ìƒíƒœ í‘œì‹œ
        FontAsset(U"Regular")(U"ì¸ë²¤í† ë¦¬: {}/{}"_fmt(inventory.size(), 15))
            .draw(50, 540, ColorF{0.9});
    }
}
```
  

## 5.5 ì¢…í•© ì˜ˆì œ: ê°„ë‹¨í•œ 2D ê²Œì„
ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°ì˜ ëª¨ë“  í•µì‹¬ ê°œë…ì„ í™œìš©í•˜ì—¬ ê°„ë‹¨í•œ 2D ìŠˆíŒ… ê²Œì„ì„ ë§Œë“¤ì–´ ë³´ê² ë‹¤. ì´ ì˜ˆì œì—ì„œëŠ” í´ë˜ìŠ¤, ìƒì†, ìº¡ìŠí™”, ë‹¤í˜•ì„±, ìƒì„±ì/ì†Œë©¸ìë¥¼ ëª¨ë‘ í™œìš©í•œë‹¤.

```cpp
#include <Siv3D.hpp>

// ê²Œì„ ì—”í‹°í‹°ì˜ ê¸°ë³¸ í´ë˜ìŠ¤
class Entity 
{
protected:
    Vec2 position;
    Vec2 velocity;
    double radius;
    ColorF color;
    
public:
    Entity(const Vec2& pos, double r, const ColorF& col)
        : position(pos), velocity(Vec2{0, 0}), radius(r), color(col) {}
    
    virtual ~Entity() {}
    
    virtual void update() {
        position += velocity;
    }
    
    virtual void draw() const {
        Circle{position, radius}.draw(color);
    }
    
    Circle getCollider() const {
        return Circle{position, radius};
    }
    
    Vec2 getPosition() const {
        return position;
    }
    
    void setVelocity(const Vec2& vel) {
        velocity = vel;
    }
    
    virtual void onCollision(Entity* other) {
        // ê¸°ë³¸ ì¶©ëŒ ì²˜ë¦¬
    }
};

// í”Œë ˆì´ì–´ í´ë˜ìŠ¤
class Player : public Entity 
{
private:
    double shootCooldown = 0;
    int health = 3;
    int score = 0;
    
public:
    Player(const Vec2& pos)
        : Entity(pos, 30, ColorF{0.2, 0.6, 0.9}) {}
    
    void update() override {
        // í‚¤ë³´ë“œ ì…ë ¥ìœ¼ë¡œ ì´ë™
        Vec2 direction{0, 0};
        
        if (KeyW.pressed()) direction.y -= 1;
        if (KeyS.pressed()) direction.y += 1;
        if (KeyA.pressed()) direction.x -= 1;
        if (KeyD.pressed()) direction.x += 1;
        
        if (!direction.isZero()) {
            direction = direction.normalized();
        }
        
        velocity = direction * 5.0;
        
        // í™”ë©´ ê²½ê³„ ì²˜ë¦¬
        position += velocity;
        position.x = Clamp(position.x, radius, Scene::Width() - radius);
        position.y = Clamp(position.y, radius, Scene::Height() - radius);
        
        // ë°œì‚¬ ì¿¨ë‹¤ìš´ ê°ì†Œ
        if (shootCooldown > 0) {
            shootCooldown -= Scene::DeltaTime();
        }
    }
    
    void draw() const override {
        // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        Circle{position, radius}.draw(color);
        
        // ì²´ë ¥ í‘œì‹œ
        for (int i = 0; i < health; ++i) {
            Circle{30 + i * 30.0, 30, 10}.draw(ColorF{0.9, 0.3, 0.3});
        }
        
        // ì ìˆ˜ í‘œì‹œ
        FontAsset(U"Regular")(U"ì ìˆ˜: {}"_fmt(score)).draw(Scene::Width() - 150, 20, ColorF{1.0});
    }
    
    bool canShoot() const {
        return shootCooldown <= 0;
    }
    
    void resetShootCooldown() {
        shootCooldown = 0.2; // 0.2ì´ˆ ì¿¨ë‹¤ìš´
    }
    
    void increaseScore(int points) {
        score += points;
    }
    
    void takeDamage() {
        if (health > 0) {
            health--;
        }
    }
    
    int getHealth() const {
        return health;
    }
    
    int getScore() const {
        return score;
    }
};

// ì´ì•Œ í´ë˜ìŠ¤
class Bullet : public Entity 
{
private:
    bool isPlayerBullet;
    double lifetime = 2.0; // 2ì´ˆ í›„ ì‚¬ë¼ì§
    
public:
    Bullet(const Vec2& pos, const Vec2& vel, bool playerBullet)
        : Entity(pos, 8, playerBullet ? ColorF{0.9, 0.9, 0.2} : ColorF{0.9, 0.3, 0.3})
        , isPlayerBullet(playerBullet) {
        setVelocity(vel);
    }
    
    void update() override {
        Entity::update();
        
        // ìˆ˜ëª… ê°ì†Œ
        lifetime -= Scene::DeltaTime();
    }
    
    bool isExpired() const {
        return lifetime <= 0 || 
               position.x < 0 || position.x > Scene::Width() ||
               position.y < 0 || position.y > Scene::Height();
    }
    
    bool isFromPlayer() const {
        return isPlayerBullet;
    }
};

// ì  í´ë˜ìŠ¤
class Enemy : public Entity 
{
private:
    double shootInterval;
    double timeSinceLastShot = 0;
    int points;
    
public:
    Enemy(const Vec2& pos, double speed, const ColorF& col, double shootRate, int pointValue)
        : Entity(pos, 25, col), shootInterval(shootRate), points(pointValue) {
        velocity = Vec2{0, speed};
    }
    
    void update() override {
        Entity::update();
        
        // ì´ì•Œ ë°œì‚¬ íƒ€ì´ë° ì—…ë°ì´íŠ¸
        timeSinceLastShot += Scene::DeltaTime();
    }
    
    bool canShoot() const {
        return timeSinceLastShot >= shootInterval;
    }
    
    void resetShootTimer() {
        timeSinceLastShot = 0;
    }
    
    bool isOffScreen() const {
        return position.y - radius > Scene::Height();
    }
    
    int getPoints() const {
        return points;
    }
};

// ê²Œì„ ë©”ì¸ í•¨ìˆ˜
void Main() 
{
    Scene::SetBackground(ColorF{0.05, 0.05, 0.1});
    
    // í°íŠ¸ ë“±ë¡
    FontAsset::Register(U"Regular", FontMethod::MSDF, 24, Typeface::CJK_Regular_KR);
    
    // í”Œë ˆì´ì–´ ìƒì„±
    Player player{Vec2{Scene::Width() / 2, Scene::Height() - 100}};
    
    // ê²Œì„ ì˜¤ë¸Œì íŠ¸ ì»¨í…Œì´ë„ˆ
    Array<std::unique_ptr<Bullet>> bullets;
    Array<std::unique_ptr<Enemy>> enemies;
    
    // ê²Œì„ ìƒíƒœ
    bool gameOver = false;
    double lastEnemySpawnTime = 0;
    double enemySpawnInterval = 1.0; // 1ì´ˆë§ˆë‹¤ ì  ìƒì„±
    
    while (System::Update()) {
        if (!gameOver) {
            // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸
            player.update();
            
            // ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ì´ì•Œ ë°œì‚¬
            if (KeySpace.down() && player.canShoot()) {
                bullets << std::make_unique<Bullet>(
                    player.getPosition(), Vec2{0, -10}, true
                );
                player.resetShootCooldown();
            }
            
            // ì  ìƒì„±
            if (Scene::Time() - lastEnemySpawnTime > enemySpawnInterval) {
                const double x = Random(50.0, Scene::Width() - 50.0);
                const double speed = Random(2.0, 4.0);
                const double shootRate = Random(1.0, 3.0);
                const ColorF color{Random(0.5, 0.9), Random(0.2, 0.5), Random(0.2, 0.5)};
                
                enemies << std::make_unique<Enemy>(
                    Vec2{x, -30}, speed, color, shootRate, 100
                );
                
                lastEnemySpawnTime = Scene::Time();
                enemySpawnInterval = Max(0.5, enemySpawnInterval - 0.01); // ì ì  ë¹¨ë¼ì§
            }
            
            // ì  ì—…ë°ì´íŠ¸ ë° ì´ì•Œ ë°œì‚¬
            for (auto& enemy : enemies) {
                enemy->update();
                
                if (enemy->canShoot()) {
                    bullets << std::make_unique<Bullet>(
                        enemy->getPosition(), Vec2{0, 5}, false
                    );
                    enemy->resetShootTimer();
                }
            }
            
            // ì´ì•Œ ì—…ë°ì´íŠ¸
            for (auto& bullet : bullets) {
                bullet->update();
            }
            
            // ì¶©ëŒ ê²€ì‚¬: í”Œë ˆì´ì–´ ì´ì•Œ vs ì 
            for (auto itBullet = bullets.begin(); itBullet != bullets.end();) {
                bool bulletRemoved = false;
                
                if ((*itBullet)->isFromPlayer()) {
                    for (auto itEnemy = enemies.begin(); itEnemy != enemies.end();) {
                        if ((*itBullet)->getCollider().intersects((*itEnemy)->getCollider())) {
                            // ì ìˆ˜ ì¦ê°€
                            player.increaseScore((*itEnemy)->getPoints());
                            
                            // ì  ì œê±°
                            itEnemy = enemies.erase(itEnemy);
                            
                            // ì´ì•Œ ì œê±°
                            itBullet = bullets.erase(itBullet);
                            bulletRemoved = true;
                            break;
                        } else {
                            ++itEnemy;
                        }
                    }
                } else { // ì  ì´ì•Œ vs í”Œë ˆì´ì–´
                    if ((*itBullet)->getCollider().intersects(player.getCollider())) {
                        player.takeDamage();
                        itBullet = bullets.erase(itBullet);
                        bulletRemoved = true;
                        
                        // ì²´ë ¥ì´ 0ì´ ë˜ë©´ ê²Œì„ ì˜¤ë²„
                        if (player.getHealth() <= 0) {
                            gameOver = true;
                        }
                    }
                }
                
                if (!bulletRemoved) {
                    if ((*itBullet)->isExpired()) {
                        itBullet = bullets.erase(itBullet);
                    } else {
                        ++itBullet;
                    }
                }
            }
            
            // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì  ì œê±°
            enemies.remove_if([](const std::unique_ptr<Enemy>& enemy) {
                return enemy->isOffScreen();
            });
            
            // í”Œë ˆì´ì–´ì™€ ì  ì¶©ëŒ ê²€ì‚¬
            for (auto itEnemy = enemies.begin(); itEnemy != enemies.end();) {
                if ((*itEnemy)->getCollider().intersects(player.getCollider())) {
                    player.takeDamage();
                    itEnemy = enemies.erase(itEnemy);
                    
                    // ì²´ë ¥ì´ 0ì´ ë˜ë©´ ê²Œì„ ì˜¤ë²„
                    if (player.getHealth() <= 0) {
                        gameOver = true;
                    }
                } else {
                    ++itEnemy;
                }
            }
        }
        
        // ê²Œì„ ì˜¤ë¸Œì íŠ¸ ê·¸ë¦¬ê¸°
        for (const auto& bullet : bullets) {
            bullet->draw();
        }
        
        for (const auto& enemy : enemies) {
            enemy->draw();
        }
        
        player.draw();
        
        // ê²Œì„ ì˜¤ë²„ í™”ë©´
        if (gameOver) {
            const RectF gameOverRect{Scene::Center().movedBy(-200, -100), 400, 200};
            gameOverRect.draw(ColorF{0.0, 0.0, 0.0, 0.8});
            
            FontAsset(U"Regular")(U"ê²Œì„ ì˜¤ë²„").drawAt(gameOverRect.center().movedBy(0, -40), ColorF{1.0});
            FontAsset(U"Regular")(U"ìµœì¢… ì ìˆ˜: {}"_fmt(player.getScore())).drawAt(gameOverRect.center(), ColorF{1.0});
            
            const RectF restartButton{Scene::Center().movedBy(-80, 40), 160, 40};
            
            if (restartButton.mouseOver()) {
                restartButton.draw(ColorF{0.4, 0.6, 0.4, 0.8});
                if (MouseL.down()) {
                    // ê²Œì„ ì¬ì‹œì‘
                    player = Player{Vec2{Scene::Width() / 2, Scene::Height() - 100}};
                    bullets.clear();
                    enemies.clear();
                    gameOver = false;
                    lastEnemySpawnTime = Scene::Time();
                    enemySpawnInterval = 1.0;
                }
            } else {
                restartButton.draw(ColorF{0.3, 0.5, 0.3, 0.6});
            }
            
            FontAsset(U"Regular")(U"ë‹¤ì‹œ ì‹œì‘").drawAt(restartButton.center(), ColorF{1.0});
        }
        
        // ì¡°ì‘ ì•ˆë‚´
        if (!gameOver) {
            FontAsset(U"Regular")(U"WASD: ì´ë™, Space: ë°œì‚¬").draw(20, Scene::Height() - 40, ColorF{0.7});
        }
    }
}
```  
  
ì‹¤í–‰ í™”ë©´:  
![](./images/016.png)     


ì½”ë“œ ì„¤ëª…    
  
### 1. ì½”ë“œì˜ í•µì‹¬ êµ¬ì¡°: í´ë˜ìŠ¤ì™€ ìƒì†
ì´ ì½”ë“œëŠ” **ê°ì²´ ì§€í–¥ í”„ë¡œê·¸ë˜ë°(OOP)**ì´ë¼ëŠ” ë°©ì‹ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆë‹¤. ì–´ë ¤ìš´ ë§ ê°™ì§€ë§Œ, 'ì„¤ê³„ë„'ì™€ 'ì‹¤ì œ ë¬¼ê±´'ì˜ ê´€ê³„ë¡œ ìƒê°í•˜ë©´ ì‰½ë‹¤.  

  * **í´ë˜ìŠ¤(Class):** 'ì„¤ê³„ë„'ì— í•´ë‹¹í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 'ìë™ì°¨ ì„¤ê³„ë„'ê°€ ìˆë‹¤ë©´, ì—¬ê¸°ì—ëŠ” "ë°”í€´ 4ê°œ, í•¸ë“¤ 1ê°œ, ì†ë„ë¥¼ ë‚¸ë‹¤"ì™€ ê°™ì€ ì •ë³´ê°€ ë“¤ì–´ìˆë‹¤.
  * **ê°ì²´(Object):** 'ì„¤ê³„ë„'ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ 'ì‹¤ì œ ë¬¼ê±´'ì´ë‹¤. 'ìë™ì°¨ ì„¤ê³„ë„'ë¡œ íŒŒë€ìƒ‰ ìë™ì°¨, ë¹¨ê°„ìƒ‰ ìë™ì°¨ë¥¼ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê²ƒì²˜ëŸ¼.

ì´ ì½”ë“œì—ëŠ” `Entity`, `Player`, `Bullet`, `Enemy`ë¼ëŠ” 4ê°œì˜ ì£¼ìš” ì„¤ê³„ë„(í´ë˜ìŠ¤)ê°€ ìˆë‹¤. ì—¬ê¸°ì„œ ê°€ì¥ ì¤‘ìš”í•œ ê°œë…ì€ **ìƒì†**ì´ë‹¤.  
  
**ìƒì†(Inheritance)**ì´ë€, ê¸°ì¡´ ì„¤ê³„ë„ë¥¼ ë¬¼ë ¤ë°›ì•„ ë” êµ¬ì²´ì ì¸ ì„¤ê³„ë„ë¥¼ ë§Œë“œëŠ” ê²ƒì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 'ìë™ì°¨ ì„¤ê³„ë„'ë¥¼ ìƒì†ë°›ì•„ 'íŠ¸ëŸ­ ì„¤ê³„ë„'ë¥¼ ë§Œë“¤ë©´, íŠ¸ëŸ­ì€ ìë™ì°¨ì˜ ê¸°ë³¸ ê¸°ëŠ¥ì„ ëª¨ë‘ ê°€ì§€ë©´ì„œ 'ì§ì„ ì‹£ëŠ”ë‹¤'ëŠ” íŠ¹ë³„í•œ ê¸°ëŠ¥ì´ ì¶”ê°€ëœë‹¤.  
  
ì´ ì½”ë“œì˜ ìƒì† ê´€ê³„ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.  

```mermaid
graph TD
    A["Entity (ê²Œì„ ì† ëª¨ë“  ê²ƒ)"] --> B["Player (í”Œë ˆì´ì–´)"]
    A --> C["Bullet (ì´ì•Œ)"]
    A --> D["Enemy (ì )"]
```

`Player`, `Bullet`, `Enemy`ëŠ” ëª¨ë‘ `Entity`ë¼ëŠ” ê¸°ë³¸ ì„¤ê³„ë„ë¥¼ ë¬¼ë ¤ë°›ì•˜ë‹¤. ê·¸ë˜ì„œ ì…‹ ë‹¤ **ìœ„ì¹˜, ì†ë„, í¬ê¸°, ìƒ‰ìƒ** ê°™ì€ ê³µí†µëœ íŠ¹ì§•ì„ ê°€ì§€ê³  ìˆë‹¤.

  
### 2. í´ë˜ìŠ¤ë³„ ìƒì„¸ ì„¤ëª… ëœ¯ì–´ë³´ê¸°
ì´ì œ ê° ì„¤ê³„ë„(í´ë˜ìŠ¤)ê°€ ì–´ë–¤ ì—­í• ì„ í•˜ëŠ”ì§€ ìì„¸íˆ ì•Œì•„ë³´ì  

#### `Entity` í´ë˜ìŠ¤: ëª¨ë“  ê°ì²´ì˜ ì¡°ìƒ ğŸ‘´
ì´ í´ë˜ìŠ¤ëŠ” ê²Œì„ì— ë“±ì¥í•˜ëŠ” ëª¨ë“  ê°ì²´(í”Œë ˆì´ì–´, ì , ì´ì•Œ)ì˜ **ê¸°ë³¸ ë¼ˆëŒ€**ì´ë‹¤.  

  * **ì£¼ìš” ë³€ìˆ˜:**
      * `position`: í™”ë©´ì—ì„œì˜ ìœ„ì¹˜ (x, y ì¢Œí‘œ)
      * `velocity`: ì›€ì§ì´ëŠ” ì†ë„ì™€ ë°©í–¥
      * `radius`: ê°ì²´ì˜ í¬ê¸° (ë°˜ì§€ë¦„)
      * `color`: ê°ì²´ì˜ ìƒ‰ìƒ
  * **ì£¼ìš” í•¨ìˆ˜(ê¸°ëŠ¥):**
      * `update()`: ë§¤ ìˆœê°„ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•œë‹¤. ê¸°ë³¸ì ìœ¼ë¡œëŠ” `position`ì— `velocity`ë¥¼ ë”í•´ì„œ ì›€ì§ì´ê²Œ ë§Œë“ ë‹¤.
      * `draw()`: í™”ë©´ì— ìê¸° ìì‹ (ì›)ì„ ê·¸ë¦°ë‹¤.
      * `getCollider()`: ì¶©ëŒ ê²€ì‚¬ë¥¼ ìœ„í•œ ë²”ìœ„ë¥¼ ì•Œë ¤ì¤€ë‹¤.  
  
`Entity`ëŠ” "ê²Œì„ì— ë‚˜ì˜¤ëŠ” ê±´ ì¼ë‹¨ ì›€ì§ì´ê³ , í™”ë©´ì— ê·¸ë ¤ì ¸ì•¼ í•´\!"ë¼ëŠ” ê¸°ë³¸ ê·œì¹™ì„ ì •í•´ì£¼ëŠ” ì—­í• ì„ í•œë‹¤.

#### `Player` í´ë˜ìŠ¤: ìš°ë¦¬ê°€ ì¡°ì¢…í•  ì£¼ì¸ê³µ ğŸ¦¸â€â™€ï¸
`Entity`ë¥¼ ìƒì†ë°›ì•„ ë§Œë“¤ì–´ì§„ **í”Œë ˆì´ì–´**ì´ë‹¤. `Entity`ì˜ ê¸°ë³¸ ê¸°ëŠ¥ì— í”Œë ˆì´ì–´ë§Œì˜ íŠ¹ë³„í•œ ê¸°ëŠ¥ì´ ì¶”ê°€ëì—ˆë‹¤.  
  
  * **ì¶”ê°€ëœ ë³€ìˆ˜:**
      * `health`: ì²´ë ¥ (ëª©ìˆ¨)
      * `score`: ì ìˆ˜
      * `shootCooldown`: ì´ì•Œì„ ìœ ë’¤ ë‹¤ìŒ ì´ì•Œì„ ì  ë•Œê¹Œì§€ì˜ ëŒ€ê¸° ì‹œê°„
  * **íŠ¹ë³„í•œ ê¸°ëŠ¥ (ê¸°ì¡´ ê¸°ëŠ¥ ë³€ê²½):**
      * `update()`: `Entity`ì˜ ë‹¨ìˆœí•œ ì›€ì§ì„ ëŒ€ì‹ , **í‚¤ë³´ë“œ(W, A, S, D) ì…ë ¥**ì„ ë°›ì•„ ì›€ì§ì¸ë‹¤. ë˜ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ëª»í•˜ê²Œ ì²˜ë¦¬í•œë‹¤.
      * `draw()`: ìê¸° ìì‹ ì„ ê·¸ë¦¬ëŠ” ê²ƒ ì™¸ì—, í™”ë©´ì— **ì²´ë ¥ê³¼ ì ìˆ˜**ë„ í•¨ê»˜ í‘œì‹œí•œë‹¤.
  * **ìƒˆë¡œìš´ ê¸°ëŠ¥:**
      * `canShoot()`: ì§€ê¸ˆ ì´ì•Œì„ ì  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
      * `takeDamage()`: ì ì—ê²Œ ë§ì•˜ì„ ë•Œ ì²´ë ¥ì„ ê¹ëŠ”ë‹¤.

#### `Bullet` í´ë˜ìŠ¤: ë¬´ê¸° ğŸ”«
ì—­ì‹œ `Entity`ë¥¼ ìƒì†ë°›ì€ **ì´ì•Œ**ì´ë‹¤.

  * **ì¶”ê°€ëœ ë³€ìˆ˜:**
      * `isPlayerBullet`: **í”Œë ˆì´ì–´ê°€ ìœ ì´ì•Œì¸ì§€, ì ì´ ìœ ì´ì•Œì¸ì§€** êµ¬ë¶„í•œë‹¤. (ìƒ‰ê¹”ë„ ì´ê±¸ë¡œ ê²°ì •!)
      * `lifetime`: ì´ì•Œì´ ì¼ì • ì‹œê°„(2ì´ˆ)ì´ ì§€ë‚˜ë©´ ì €ì ˆë¡œ ì‚¬ë¼ì§€ê²Œ ë§Œë“ ë‹¤.
  * **íŠ¹ë³„í•œ ê¸°ëŠ¥:**
      * `update()`: ê¸°ë³¸ ì›€ì§ì„ì— ë”í•´ `lifetime`ì„ ê³„ì† ì¤„ì—¬ë‚˜ê°„ë‹¤.
      * `isExpired()`: ì´ì•Œì´ ì‚¬ë¼ì ¸ì•¼ í•  ë•Œì¸ì§€(`lifetime`ì´ ë‹¤ ëê±°ë‚˜ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°”ì„ ë•Œ) ì•Œë ¤ì¤€ë‹¤.  

#### `Enemy` í´ë˜ìŠ¤: ìš°ë¦¬ì˜ ì  ğŸ‘¾
`Entity`ë¥¼ ìƒì†ë°›ì€ **ì **ì´ë‹¤.

  * **ì¶”ê°€ëœ ë³€ìˆ˜:**
      * `shootInterval`: ì–¼ë§ˆë‚˜ ìì£¼ ì´ì•Œì„ ì ì§€ ê²°ì •í•˜ëŠ” ì‹œê°„ ê°„ê²©ì´ë‹¤.
      * `points`: ì´ ì ì„ ë¬¼ë¦¬ì¹˜ë©´ ì–»ëŠ” ì ìˆ˜ì´ë‹¤.
  * **íŠ¹ë³„í•œ ê¸°ëŠ¥:**
      * `update()`: ê¸°ë³¸ì ìœ¼ë¡œ ì•„ë˜ë¡œë§Œ ì›€ì§ì´ê³ , ì´ì•Œ ì  íƒ€ì´ë°ì„ ê³„ì† ê³„ì‚°í•œë‹¤.
      * `canShoot()`: ì´ì•Œ ì  ë•Œê°€ ëëŠ”ì§€ ì•Œë ¤ì¤€ë‹¤.
      * `isOffScreen()`: í™”ë©´ ë°–ìœ¼ë¡œ ì™„ì „íˆ ë‚˜ê°”ëŠ”ì§€ í™•ì¸í•œë‹¤.

### 3. ê²Œì„ì˜ ì‹¤ì œ ì§„í–‰: `Main()` í•¨ìˆ˜ ğŸ¬
ì´ê³³ì´ ë°”ë¡œ ê²Œì„ì˜ ëª¨ë“  ê²ƒì´ ì‹¤ì œë¡œ ì¼ì–´ë‚˜ëŠ” **ë©”ì¸ ë¬´ëŒ€**ì´ë‹¤. `while (System::Update())` ë¼ëŠ” ë°˜ë³µë¬¸ ì•ˆì—ì„œ ê²Œì„ì´ ê³„ì† ì§„í–‰ëœë‹¤.

ê²Œì„ì€ í¬ê²Œ ì•„ë˜ì˜ ìˆœì„œë¡œ ë§¤ ìˆœê°„(1ì´ˆì— 60ë²ˆ) ë°˜ë³µëœë‹¤.

```
+------------------------------------------+
|            ê²Œì„ ë£¨í”„ (ë§¤ í”„ë ˆì„ ë°˜ë³µ)      |
+------------------------------------------+
|                                          |
|  1. ìƒíƒœ ì—…ë°ì´íŠ¸ (Update)                 |
|     - í”Œë ˆì´ì–´ ì›€ì§ì„ (í‚¤ë³´ë“œ ì…ë ¥)          |
|     - ì´ì•Œ ë°œì‚¬ (ìŠ¤í˜ì´ìŠ¤ë°”)                |
|     - ìƒˆë¡œìš´ ì  ìƒì„±                       |
|     - ëª¨ë“  ì , ì´ì•Œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸            |
|                                          |
|  2. ì¶©ëŒ ê²€ì‚¬ (Collision Check)           |
|     - ë‚´ ì´ì•Œ vs ì                        |
|     - ì  ì´ì•Œ vs ë‚˜                       |
|     - ì  vs ë‚˜                            |
|     - (ì¶©ëŒ ì‹œ ì²´ë ¥ ê°ì†Œ, ì ìˆ˜ ì¦ê°€, ê°ì²´ ì‚­ì œ) |
|                                          |
|  3. ì •ë¦¬ (Cleanup)                        |
|     - í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ê°ì²´ë“¤ ì‚­ì œ           |
|                                          |
|  4. ê·¸ë¦¬ê¸° (Draw)                         |
|     - ë°°ê²½, í”Œë ˆì´ì–´, ì , ì´ì•Œ, UI ê·¸ë¦¬ê¸°    |
|                                          |
+------------------------------------------+
```

#### í•µì‹¬ ë¡œì§ ìš”ì•½

  * **ê°ì²´ ê´€ë¦¬:** `bullets`ì™€ `enemies`ë¼ëŠ” ëª©ë¡(ë°°ì—´)ì— ëª¨ë“  ì´ì•Œê³¼ ì ì„ ë‹´ì•„ë‘ê³  í•œ ë²ˆì— ê´€ë¦¬í•œë‹¤. `std::unique_ptr`ëŠ” ê°ì²´ê°€ í•„ìš” ì—†ì–´ì¡Œì„ ë•Œ ìë™ìœ¼ë¡œ ë©”ëª¨ë¦¬ì—ì„œ ì§€ì›Œì£¼ëŠ” í¸ë¦¬í•œ ë„êµ¬ì´ë‹¤.
  * **ì¶©ëŒ ê²€ì‚¬:** `getCollider().intersects(...)` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ë‘ ì›(ê°ì²´)ì´ ì„œë¡œ ê²¹ì¹˜ëŠ”ì§€ ê²€ì‚¬í•œë‹¤. ê²¹ì¹˜ë©´ ì¶©ëŒí•œ ê±°ë‹¤!
  * **ê²Œì„ ì˜¤ë²„ ë° ì¬ì‹œì‘:** í”Œë ˆì´ì–´ì˜ `health`ê°€ 0ì´ ë˜ë©´ `gameOver` ìƒíƒœê°€ ë˜ê³ , ê²Œì„ ì˜¤ë²„ í™”ë©´ì´ ë‚˜íƒ€ë‚œë‹¤. "ë‹¤ì‹œ ì‹œì‘" ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ëª¨ë“  ë³€ìˆ˜ì™€ ê°ì²´ ëª©ë¡ì„ ì´ˆê¸° ìƒíƒœë¡œ ë˜ëŒë ¤ ê²Œì„ì„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•œë‹¤.
  
ì´ ì½”ë“œëŠ” ê°ì²´ ì§€í–¥ì˜ ê¸°ë³¸ ê°œë…ì„ í™œìš©í•˜ì—¬ ê° ìš”ì†Œ(í”Œë ˆì´ì–´, ì , ì´ì•Œ)ì˜ ì—­í• ê³¼ ì±…ì„ì„ ëª…í™•í•˜ê²Œ ë‚˜ëˆˆ ì¢‹ì€ ì˜ˆì‹œì´ë‹¤. ì´ êµ¬ì¡°ë¥¼ ì´í•´í•˜ë©´ ì•ìœ¼ë¡œ ë” ë³µì¡í•œ ê²Œì„ë„ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤! ğŸ˜Š
    

    
## ê²°ë¡ 
ì´ë²ˆ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” C++ì˜ ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë° ê¸°ë³¸ ê°œë…ë“¤ì„ Siv3Dë¥¼ í™œìš©í•˜ì—¬ ë°°ì› ë‹¤. í´ë˜ìŠ¤ì™€ ê°ì²´, ìº¡ìŠí™”, ìƒì„±ìì™€ ì†Œë©¸ì, ì ‘ê·¼ ì œì–´ì ë“±ì˜ ê°œë…ì„ ì‹œê°ì ì´ê³  ì¸í„°ë™í‹°ë¸Œí•œ ì˜ˆì œë¥¼ í†µí•´ í•™ìŠµí–ˆë‹¤.

ì´ëŸ¬í•œ ê°ì²´ì§€í–¥ ê°œë…ë“¤ì€ ë³µì¡í•œ ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¡°í™”í•˜ê³ , ì½”ë“œ ì¬ì‚¬ìš©ì„±ì„ ë†’ì´ë©°, ìœ ì§€ë³´ìˆ˜ë¥¼ ì‰½ê²Œ ë§Œë“œëŠ” ë° í•„ìˆ˜ì ì´ë‹¤. Siv3Dì˜ ì§ê´€ì ì¸ APIì™€ ê²°í•©í•˜ë©´ ì°½ì˜ì ì¸ C++ í”„ë¡œê·¸ë˜ë°ì´ ë”ìš± ì¦ê²ê³  íš¨ìœ¨ì ìœ¼ë¡œ ëœë‹¤.  
  
ë‹¤ìŒ ë‹¨ê³„ë¡œëŠ” ìƒì†ê³¼ ë‹¤í˜•ì„±, ì—°ì‚°ì ì˜¤ë²„ë¡œë”©, í…œí”Œë¦¿ ë“± C++ì˜ ë” ê³ ê¸‰ ê°ì²´ì§€í–¥ ê¸°ëŠ¥ì„ í•™ìŠµí•˜ê³ , ë” ë³µì¡í•œ ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•  ìˆ˜ ìˆë‹¤.    

