# 게임 서버 개발자를 위한 최신 Win32 API 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  

# Chapter 9. 보안과 권한 관리
게임 서버 개발에서 보안은 매우 중요한 요소이다. 플레이어 데이터 보호, 서버 리소스 접근 제어, 악성 공격 방어 등을 위해 Windows의 보안 시스템을 제대로 이해하고 활용해야 한다. 이번 장에서는 Win32 API를 사용한 보안과 권한 관리에 대해 알아보겠다.

## 9.1 Access Token과 사용자 권한

### 9.1.1 Windows 보안 모델 이해
Windows 보안 시스템은 다음과 같은 구조로 동작한다:

```
    Windows 보안 아키텍처
            ↓
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    사용자       │ →  │  Access Token   │ →  │   보안 객체     │
│ (User/Service)  │    │  - 사용자 SID   │    │ - 파일/폴더     │
│                 │    │  - 그룹 SID     │    │ - 레지스트리    │
│                 │    │  - 권한         │    │ - 프로세스      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
        ↓                      ↓                      ↓
    인증 (Authentication)   권한 확인          접근 제어 (ACL)
```

### 9.1.2 Access Token 정보 조회
게임 서버에서 현재 실행 중인 프로세스의 권한을 확인하는 것은 중요하다:

```cpp
// SecurityManager.h
#pragma once
#include <windows.h>
#include <sddl.h>
#include <iostream>
#include <string>
#include <vector>
#include <memory>

#pragma comment(lib, "advapi32.lib")

class SecurityManager {
private:
    HANDLE m_hToken;
    
public:
    SecurityManager();
    ~SecurityManager();
    
    bool Initialize();
    void DisplayCurrentUserInfo();
    void DisplayTokenPrivileges();
    void DisplayTokenGroups();
    
    // 권한 확인 및 조작
    bool HasPrivilege(LPCWSTR privilegeName);
    bool EnablePrivilege(LPCWSTR privilegeName);
    bool IsUserAdmin();
    bool IsElevated();
    
    // 게임 서버 보안 검사
    bool CheckGameServerSecurity();
    void DisplaySecurityReport();
    
private:
    std::string SidToString(PSID pSid);
    std::string GetUserNameFromSid(PSID pSid);
    void DisplayPrivilege(LUID_AND_ATTRIBUTES privilege);
};
```

```cpp
// SecurityManager.cpp
#include "SecurityManager.h"

SecurityManager::SecurityManager() : m_hToken(NULL) {
}

SecurityManager::~SecurityManager() {
    if (m_hToken) {
        CloseHandle(m_hToken);
    }
}

bool SecurityManager::Initialize() {
    // 현재 프로세스의 토큰 얻기
    if (!OpenProcessToken(GetCurrentProcess(), 
                         TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, 
                         &m_hToken)) {
        std::cout << "토큰 열기 실패: " << GetLastError() << std::endl;
        return false;
    }
    
    return true;
}

void SecurityManager::DisplayCurrentUserInfo() {
    if (!m_hToken) {
        std::cout << "토큰이 초기화되지 않았습니다.\n";
        return;
    }
    
    DWORD dwSize = 0;
    
    // 토큰 사용자 정보 크기 얻기
    GetTokenInformation(m_hToken, TokenUser, NULL, 0, &dwSize);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        std::cout << "토큰 정보 크기 조회 실패\n";
        return;
    }
    
    // 메모리 할당 및 정보 얻기
    auto pTokenUser = std::make_unique<BYTE[]>(dwSize);
    if (!GetTokenInformation(m_hToken, TokenUser, 
                           pTokenUser.get(), dwSize, &dwSize)) {
        std::cout << "토큰 사용자 정보 조회 실패: " << GetLastError() << std::endl;
        return;
    }
    
    TOKEN_USER* pUser = reinterpret_cast<TOKEN_USER*>(pTokenUser.get());
    
    std::cout << "\n";
    std::cout << "╔══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║                    현재 사용자 정보                           ║\n";
    std::cout << "╠══════════════════════════════════════════════════════════════╣\n";
    
    std::cout << "║ 사용자 SID: " << SidToString(pUser->User.Sid) << std::endl;
    std::cout << "║ 사용자 이름: " << GetUserNameFromSid(pUser->User.Sid) << std::endl;
    std::cout << "║ 관리자 권한: " << (IsUserAdmin() ? "예" : "아니오") << std::endl;
    std::cout << "║ 상승된 권한: " << (IsElevated() ? "예" : "아니오") << std::endl;
    
    std::cout << "╚══════════════════════════════════════════════════════════════╝\n";
}

void SecurityManager::DisplayTokenPrivileges() {
    if (!m_hToken) return;
    
    DWORD dwSize = 0;
    
    // 토큰 권한 정보 크기 얻기
    GetTokenInformation(m_hToken, TokenPrivileges, NULL, 0, &dwSize);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        std::cout << "토큰 권한 크기 조회 실패\n";
        return;
    }
    
    // 메모리 할당 및 정보 얻기
    auto pTokenPrivileges = std::make_unique<BYTE[]>(dwSize);
    if (!GetTokenInformation(m_hToken, TokenPrivileges, 
                           pTokenPrivileges.get(), dwSize, &dwSize)) {
        std::cout << "토큰 권한 정보 조회 실패: " << GetLastError() << std::endl;
        return;
    }
    
    TOKEN_PRIVILEGES* pPrivileges = 
        reinterpret_cast<TOKEN_PRIVILEGES*>(pTokenPrivileges.get());
    
    std::cout << "\n";
    std::cout << "╔══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║                      토큰 권한 정보                           ║\n";
    std::cout << "╠══════════════════════════════════════════════════════════════╣\n";
    
    std::cout << "║ 총 권한 수: " << pPrivileges->PrivilegeCount << std::endl;
    std::cout << "║" << std::endl;
    
    for (DWORD i = 0; i < pPrivileges->PrivilegeCount; ++i) {
        DisplayPrivilege(pPrivileges->Privileges[i]);
    }
    
    std::cout << "╚══════════════════════════════════════════════════════════════╝\n";
}

void SecurityManager::DisplayPrivilege(LUID_AND_ATTRIBUTES privilege) {
    WCHAR privilegeName[256];
    DWORD nameSize = sizeof(privilegeName) / sizeof(WCHAR);
    
    if (LookupPrivilegeName(NULL, &privilege.Luid, privilegeName, &nameSize)) {
        std::wcout << L"║ ├─ " << privilegeName;
        
        // 권한 상태 표시
        if (privilege.Attributes & SE_PRIVILEGE_ENABLED) {
            std::cout << " (활성화)";
        } else if (privilege.Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT) {
            std::cout << " (기본 활성화)";
        } else {
            std::cout << " (비활성화)";
        }
        
        std::cout << std::endl;
    }
}

bool SecurityManager::HasPrivilege(LPCWSTR privilegeName) {
    if (!m_hToken) return false;
    
    LUID privilegeLuid;
    if (!LookupPrivilegeValue(NULL, privilegeName, &privilegeLuid)) {
        return false;
    }
    
    PRIVILEGE_SET privilegeSet;
    privilegeSet.PrivilegeCount = 1;
    privilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    privilegeSet.Privilege[0].Luid = privilegeLuid;
    privilegeSet.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
    
    BOOL hasPrivilege = FALSE;
    if (!PrivilegeCheck(m_hToken, &privilegeSet, &hasPrivilege)) {
        return false;
    }
    
    return hasPrivilege == TRUE;
}

bool SecurityManager::EnablePrivilege(LPCWSTR privilegeName) {
    if (!m_hToken) return false;
    
    LUID privilegeLuid;
    if (!LookupPrivilegeValue(NULL, privilegeName, &privilegeLuid)) {
        std::cout << "권한 LUID 조회 실패: " << GetLastError() << std::endl;
        return false;
    }
    
    TOKEN_PRIVILEGES tokenPrivileges;
    tokenPrivileges.PrivilegeCount = 1;
    tokenPrivileges.Privileges[0].Luid = privilegeLuid;
    tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    
    if (!AdjustTokenPrivileges(m_hToken, FALSE, &tokenPrivileges, 
                              sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
        std::cout << "권한 조정 실패: " << GetLastError() << std::endl;
        return false;
    }
    
    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
        std::cout << "일부 권한이 할당되지 않았습니다.\n";
        return false;
    }
    
    return true;
}

bool SecurityManager::IsUserAdmin() {
    if (!m_hToken) return false;
    
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PSID adminGroup = NULL;
    
    if (!AllocateAndInitializeSid(&ntAuthority, 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0, 0, 0, 0, 0, 0,
                                 &adminGroup)) {
        return false;
    }
    
    BOOL isAdmin = FALSE;
    CheckTokenMembership(m_hToken, adminGroup, &isAdmin);
    
    FreeSid(adminGroup);
    return isAdmin == TRUE;
}

bool SecurityManager::IsElevated() {
    if (!m_hToken) return false;
    
    TOKEN_ELEVATION elevation;
    DWORD dwSize = sizeof(TOKEN_ELEVATION);
    
    if (!GetTokenInformation(m_hToken, TokenElevation, 
                           &elevation, dwSize, &dwSize)) {
        return false;
    }
    
    return elevation.TokenIsElevated != 0;
}

std::string SecurityManager::SidToString(PSID pSid) {
    LPWSTR sidString = NULL;
    if (ConvertSidToStringSid(pSid, &sidString)) {
        // Wide string을 multibyte로 변환
        int len = WideCharToMultiByte(CP_UTF8, 0, sidString, -1, 
                                     NULL, 0, NULL, NULL);
        std::string result(len, 0);
        WideCharToMultiByte(CP_UTF8, 0, sidString, -1, 
                           &result[0], len, NULL, NULL);
        result.resize(len - 1); // null terminator 제거
        
        LocalFree(sidString);
        return result;
    }
    return "Unknown";
}

std::string SecurityManager::GetUserNameFromSid(PSID pSid) {
    WCHAR userName[256];
    WCHAR domainName[256];
    DWORD userNameSize = sizeof(userName) / sizeof(WCHAR);
    DWORD domainNameSize = sizeof(domainName) / sizeof(WCHAR);
    SID_NAME_USE sidType;
    
    if (LookupAccountSid(NULL, pSid, userName, &userNameSize,
                        domainName, &domainNameSize, &sidType)) {
        // Wide string을 multibyte로 변환
        int len = WideCharToMultiByte(CP_UTF8, 0, userName, -1, 
                                     NULL, 0, NULL, NULL);
        std::string result(len, 0);
        WideCharToMultiByte(CP_UTF8, 0, userName, -1, 
                           &result[0], len, NULL, NULL);
        result.resize(len - 1);
        return result;
    }
    
    return "Unknown";
}
```

### 9.1.3 보안 검사 및 보고
게임 서버가 안전하게 실행되고 있는지 확인하는 기능을 구현해보겠다:

```cpp
bool SecurityManager::CheckGameServerSecurity() {
    std::cout << "\n게임 서버 보안 검사를 시작합니다...\n";
    
    bool isSecure = true;
    
    // 1. 관리자 권한으로 실행되지 않아야 함 (보안상 권장)
    if (IsUserAdmin() && IsElevated()) {
        std::cout << "⚠️  경고: 게임 서버가 관리자 권한으로 실행 중입니다.\n";
        std::cout << "   보안상 일반 사용자 권한으로 실행하는 것을 권장합니다.\n";
        isSecure = false;
    }
    
    // 2. 필요한 권한 확인
    std::vector<LPCWSTR> requiredPrivileges = {
        SE_CREATE_GLOBAL_NAME,  // 전역 객체 생성
        SE_INCREASE_QUOTA_NAME, // 메모리 할당량 증가
        SE_LOCK_MEMORY_NAME     // 메모리 잠금 (선택적)
    };
    
    for (auto privilege : requiredPrivileges) {
        if (!HasPrivilege(privilege)) {
            std::wcout << L"⚠️  경고: 필요한 권한이 없습니다: " << privilege << std::endl;
            isSecure = false;
        }
    }
    
    // 3. 위험한 권한 확인
    std::vector<LPCWSTR> dangerousPrivileges = {
        SE_DEBUG_NAME,          // 디버그 권한
        SE_TCB_NAME,           // TCB 권한
        SE_LOAD_DRIVER_NAME    // 드라이버 로드
    };
    
    for (auto privilege : dangerousPrivileges) {
        if (HasPrivilege(privilege)) {
            std::wcout << L"⚠️  경고: 위험한 권한이 활성화되어 있습니다: " 
                      << privilege << std::endl;
            isSecure = false;
        }
    }
    
    return isSecure;
}

void SecurityManager::DisplaySecurityReport() {
    std::cout << "\n";
    std::cout << "╔══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║                    게임 서버 보안 보고서                      ║\n";
    std::cout << "╠══════════════════════════════════════════════════════════════╣\n";
    
    // 현재 사용자 정보
    DisplayCurrentUserInfo();
    
    // 보안 검사 결과
    bool isSecure = CheckGameServerSecurity();
    
    std::cout << "║" << std::endl;
    std::cout << "║ 전체 보안 상태: " << (isSecure ? "✅ 안전" : "⚠️  주의 필요") << std::endl;
    
    if (!isSecure) {
        std::cout << "║" << std::endl;
        std::cout << "║ 권장사항:" << std::endl;
        std::cout << "║ - 최소 권한 원칙 적용" << std::endl;
        std::cout << "║ - 전용 서비스 계정 사용" << std::endl;
        std::cout << "║ - 정기적인 보안 감사 실시" << std::endl;
    }
    
    std::cout << "╚══════════════════════════════════════════════════════════════╝\n";
}
```
  


## 9.2 프로세스 권한 상승 (UAC)

### 9.2.1 UAC (User Account Control) 이해
UAC는 Windows Vista부터 도입된 보안 기능으로, 다음과 같이 동작한다:

```
    UAC 동작 흐름
         ↓
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ 애플리케이션    │ →  │   UAC 확인      │ →  │   권한 상승     │
│ 권한 상승 요청  │    │ - 사용자 확인   │    │ - 새 토큰 생성  │
│                 │    │ - 관리자 그룹   │    │ - 높은 무결성   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
        ↓                      ↓                      ↓
   관리자 작업 필요         보안 프롬프트           상승된 권한으로 실행
```

### 9.2.2 권한 상승 구현
게임 서버가 특정 작업을 위해 권한 상승이 필요한 경우를 위한 구현이다:

```cpp
// ElevationManager.h
#pragma once
#include <windows.h>
#include <shellapi.h>
#include <iostream>
#include <string>

class ElevationManager {
public:
    // 현재 프로세스가 상승된 권한을 가지고 있는지 확인
    static bool IsElevated();
    
    // 현재 프로세스를 상승된 권한으로 재시작
    static bool RestartAsElevated();
    
    // 특정 실행 파일을 상승된 권한으로 실행
    static bool RunAsElevated(const std::wstring& exePath, 
                             const std::wstring& parameters = L"");
    
    // 권한 상승이 가능한지 확인
    static bool CanElevate();
    
    // 게임 서버 설치를 위한 권한 상승
    static bool ElevateForInstallation();
    
    // UAC 상태 확인
    static void DisplayUACStatus();
    
private:
    static bool IsUACEnabled();
    static bool IsRunAsAdministrator();
};
```

```cpp
// ElevationManager.cpp
#include "ElevationManager.h"

bool ElevationManager::IsElevated() {
    HANDLE hToken = NULL;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        return false;
    }
    
    TOKEN_ELEVATION elevation;
    DWORD dwSize = sizeof(TOKEN_ELEVATION);
    
    bool isElevated = false;
    if (GetTokenInformation(hToken, TokenElevation, 
                           &elevation, dwSize, &dwSize)) {
        isElevated = (elevation.TokenIsElevated != 0);
    }
    
    CloseHandle(hToken);
    return isElevated;
}

bool ElevationManager::RestartAsElevated() {
    if (IsElevated()) {
        std::cout << "이미 상승된 권한으로 실행 중입니다.\n";
        return true;
    }
    
    WCHAR exePath[MAX_PATH];
    if (!GetModuleFileName(NULL, exePath, MAX_PATH)) {
        std::cout << "실행 파일 경로 획득 실패: " << GetLastError() << std::endl;
        return false;
    }
    
    // ShellExecute를 사용해 "runas"로 재실행
    SHELLEXECUTEINFO sei = { sizeof(sei) };
    sei.lpVerb = L"runas";
    sei.lpFile = exePath;
    sei.hwnd = NULL;
    sei.nShow = SW_NORMAL;
    
    if (!ShellExecuteEx(&sei)) {
        DWORD error = GetLastError();
        if (error == ERROR_CANCELLED) {
            std::cout << "사용자가 권한 상승을 취소했습니다.\n";
        } else {
            std::cout << "권한 상승 실패: " << error << std::endl;
        }
        return false;
    }
    
    std::cout << "상승된 권한으로 재시작 중...\n";
    return true;
}

bool ElevationManager::RunAsElevated(const std::wstring& exePath, 
                                    const std::wstring& parameters) {
    SHELLEXECUTEINFO sei = { sizeof(sei) };
    sei.lpVerb = L"runas";
    sei.lpFile = exePath.c_str();
    sei.lpParameters = parameters.empty() ? NULL : parameters.c_str();
    sei.hwnd = NULL;
    sei.nShow = SW_NORMAL;
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    
    if (!ShellExecuteEx(&sei)) {
        DWORD error = GetLastError();
        std::cout << "상승된 실행 실패: " << error << std::endl;
        return false;
    }
    
    if (sei.hProcess) {
        std::cout << "상승된 권한으로 프로세스 시작됨. PID: " 
                  << GetProcessId(sei.hProcess) << std::endl;
        CloseHandle(sei.hProcess);
    }
    
    return true;
}

bool ElevationManager::CanElevate() {
    // UAC가 비활성화되어 있거나 이미 관리자인 경우
    if (!IsUACEnabled()) {
        return IsRunAsAdministrator();
    }
    
    // UAC가 활성화되어 있으면 권한 상승 가능
    return true;
}

bool ElevationManager::ElevateForInstallation() {
    std::cout << "\n게임 서버 설치를 위한 권한 상승이 필요합니다.\n";
    std::cout << "다음 작업을 수행하려면 관리자 권한이 필요합니다:\n";
    std::cout << "- 서비스 등록\n";
    std::cout << "- 방화벽 규칙 추가\n";
    std::cout << "- 시스템 디렉토리 접근\n\n";
    
    if (IsElevated()) {
        std::cout << "✅ 이미 적절한 권한을 가지고 있습니다.\n";
        return true;
    }
    
    std::cout << "권한 상승을 시도합니다...\n";
    return RestartAsElevated();
}

void ElevationManager::DisplayUACStatus() {
    std::cout << "\n";
    std::cout << "╔══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║                      UAC 상태 정보                           ║\n";
    std::cout << "╠══════════════════════════════════════════════════════════════╣\n";
    
    std::cout << "║ UAC 활성화: " << (IsUACEnabled() ? "예" : "아니오") << std::endl;
    std::cout << "║ 관리자 실행: " << (IsRunAsAdministrator() ? "예" : "아니오") << std::endl;
    std::cout << "║ 권한 상승됨: " << (IsElevated() ? "예" : "아니오") << std::endl;
    std::cout << "║ 권한 상승 가능: " << (CanElevate() ? "예" : "아니오") << std::endl;
    
    if (!IsElevated() && IsUACEnabled()) {
        std::cout << "║" << std::endl;
        std::cout << "║ 참고: 관리자 권한이 필요한 작업을 수행하려면" << std::endl;
        std::cout << "║       권한 상승이 필요합니다." << std::endl;
    }
    
    std::cout << "╚══════════════════════════════════════════════════════════════╝\n";
}

bool ElevationManager::IsUACEnabled() {
    HKEY hKey;
    DWORD dwValue = 0;
    DWORD dwSize = sizeof(DWORD);
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
                    0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        
        RegQueryValueEx(hKey, L"EnableLUA", NULL, NULL, 
                       (LPBYTE)&dwValue, &dwSize);
        RegCloseKey(hKey);
    }
    
    return dwValue != 0;
}

bool ElevationManager::IsRunAsAdministrator() {
    HANDLE hToken = NULL;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        return false;
    }
    
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PSID adminGroup = NULL;
    
    bool isAdmin = false;
    if (AllocateAndInitializeSid(&ntAuthority, 2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS,
                                0, 0, 0, 0, 0, 0,
                                &adminGroup)) {
        
        BOOL isMember = FALSE;
        if (CheckTokenMembership(hToken, adminGroup, &isMember)) {
            isAdmin = (isMember == TRUE);
        }
        
        FreeSid(adminGroup);
    }
    
    CloseHandle(hToken);
    return isAdmin;
}
```
  


## 9.3 서비스 계정 관리

### 9.3.1 서비스 계정의 중요성
게임 서버를 Windows 서비스로 실행할 때는 적절한 서비스 계정을 사용해야 한다:

```
    서비스 계정 종류
         ↓
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  LocalSystem    │    │  LocalService   │    │  NetworkService │
│ - 최고 권한     │    │ - 제한된 권한   │    │ - 네트워크 접근 │
│ - 보안 위험     │    │ - 로컬만 접근   │    │ - 중간 권한     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
        ↓                      ↓                      ↓
    시스템 서비스 전용         로컬 서비스용          네트워크 서비스용

┌─────────────────┐
│  사용자 정의    │
│ - 맞춤 권한     │
│ - 최소 권한     │ ← 게임 서버 권장
│ - 높은 보안     │
└─────────────────┘
```

### 9.3.2 서비스 계정 관리 구현

```cpp
// ServiceAccountManager.h
#pragma once
#include <windows.h>
#include <lm.h>
#include <iostream>
#include <string>
#include <vector>

#pragma comment(lib, "netapi32.lib")

class ServiceAccountManager {
private:
    std::wstring m_serverName;
    
public:
    ServiceAccountManager(const std::wstring& serverName = L"");
    ~ServiceAccountManager();
    
    // 사용자 계정 관리
    bool CreateServiceAccount(const std::wstring& username, 
                             const std::wstring& password,
                             const std::wstring& fullName = L"");
    bool DeleteServiceAccount(const std::wstring& username);
    bool SetAccountPassword(const std::wstring& username, 
                           const std::wstring& newPassword);
    
    // 권한 관리
    bool GrantLogonAsService(const std::wstring& username);
    bool GrantLogonAsServiceBatch(const std::wstring& username);
    bool SetAccountRights(const std::wstring& username, 
                         const std::vector<std::wstring>& rights);
    
    // 정보 조회
    void DisplayAccountInfo(const std::wstring& username);
    void DisplayServiceAccounts();
    
    // 게임 서버용 계정 생성
    bool CreateGameServerAccount(const std::wstring& username, 
                                const std::wstring& password);
    
private:
    bool AddUserToGroup(const std::wstring& username, 
                       const std::wstring& groupName);
    std::wstring GenerateSecurePassword();
    bool ValidatePassword(const std::wstring& password);
};
```

```cpp
// ServiceAccountManager.cpp
#include "ServiceAccountManager.h"
#include <random>
#include <sddl.h>

ServiceAccountManager::ServiceAccountManager(const std::wstring& serverName) 
    : m_serverName(serverName) {
}

ServiceAccountManager::~ServiceAccountManager() {
}

bool ServiceAccountManager::CreateServiceAccount(const std::wstring& username, 
                                                 const std::wstring& password,
                                                 const std::wstring& fullName) {
    USER_INFO_3 userInfo;
    ZeroMemory(&userInfo, sizeof(USER_INFO_3));
    
    userInfo.usri3_name = const_cast<LPWSTR>(username.c_str());
    userInfo.usri3_password = const_cast<LPWSTR>(password.c_str());
    userInfo.usri3_priv = USER_PRIV_USER;
    userInfo.usri3_flags = UF_NORMAL_ACCOUNT | UF_DONT_EXPIRE_PASSWD;
    userInfo.usri3_acct_expires = TIMEQ_FOREVER;
    userInfo.usri3_max_storage = USER_MAXSTORAGE_UNLIMITED;
    
    if (!fullName.empty()) {
        userInfo.usri3_full_name = const_cast<LPWSTR>(fullName.c_str());
    }
    
    // 서비스 계정 생성
    DWORD dwError = NetUserAdd(
        m_serverName.empty() ? NULL : m_serverName.c_str(),
        3,
        (LPBYTE)&userInfo,
        NULL
    );
    
    if (dwError != NERR_Success) {
        std::wcout << L"사용자 계정 생성 실패: " << dwError << std::endl;
        return false;
    }
    
    std::wcout << L"서비스 계정 '" << username << L"' 생성 완료" << std::endl;
    
    // 기본 권한 설정
    return GrantLogonAsService(username);
}

bool ServiceAccountManager::GrantLogonAsService(const std::wstring& username) {
    LSA_HANDLE policyHandle;
    LSA_OBJECT_ATTRIBUTES objectAttributes;
    ZeroMemory(&objectAttributes, sizeof(LSA_OBJECT_ATTRIBUTES));
    
    // LSA 정책 핸들 열기
    NTSTATUS status = LsaOpenPolicy(
        NULL,
        &objectAttributes,
        POLICY_ALL_ACCESS,
        &policyHandle
    );
    
    if (status != STATUS_SUCCESS) {
        std::cout << "LSA 정책 열기 실패: " << LsaNtStatusToWinError(status) << std::endl;
        return false;
    }
    
    // 사용자 SID 얻기
    PSID userSid = NULL;
    SID_NAME_USE sidType;
    DWORD sidSize = 0;
    DWORD domainSize = 0;
    
    // 필요한 버퍼 크기 얻기
    LookupAccountName(NULL, username.c_str(), NULL, &sidSize, 
                     NULL, &domainSize, &sidType);
    
    userSid = (PSID)LocalAlloc(LPTR, sidSize);
    LPWSTR domainName = (LPWSTR)LocalAlloc(LPTR, domainSize * sizeof(WCHAR));
    
    if (!LookupAccountName(NULL, username.c_str(), userSid, &sidSize,
                          domainName, &domainSize, &sidType)) {
        std::cout << "계정 SID 조회 실패: " << GetLastError() << std::endl;
        LocalFree(userSid);
        LocalFree(domainName);
        LsaClose(policyHandle);
        return false;
    }
    
    // "서비스로 로그온" 권한 부여
    LSA_UNICODE_STRING rightString;
    WCHAR rightName[] = L"SeServiceLogonRight";
    rightString.Buffer = rightName;
    rightString.Length = (USHORT)((wcslen(rightName)) * sizeof(WCHAR));
    rightString.MaximumLength = rightString.Length + sizeof(WCHAR);
    
    status = LsaAddAccountRights(policyHandle, userSid, &rightString, 1);
    
    bool success = (status == STATUS_SUCCESS);
    if (success) {
        std::wcout << L"'" << username << L"'에 서비스 로그온 권한 부여 완료" << std::endl;
    } else {
        std::cout << "서비스 로그온 권한 부여 실패: " 
                  << LsaNtStatusToWinError(status) << std::endl;
    }
    
    // 리소스 정리
    LocalFree(userSid);
    LocalFree(domainName);
    LsaClose(policyHandle);
    
    return success;
}

bool ServiceAccountManager::CreateGameServerAccount(const std::wstring& username, 
                                                   const std::wstring& password) {
    std::wcout << L"\n게임 서버용 서비스 계정을 생성합니다..." << std::endl;
    
    // 패스워드 유효성 검사
    if (!ValidatePassword(password)) {
        std::cout << "패스워드가 보안 정책을 만족하지 않습니다." << std::endl;
        return false;
    }
    
    // 서비스 계정 생성
    if (!CreateServiceAccount(username, password, L"Game Server Service Account")) {
        return false;
    }
    
    // 게임 서버에 필요한 추가 권한 설정
    std::vector<std::wstring> requiredRights = {
        L"SeServiceLogonRight",      // 서비스로 로그온
        L"SeBatchLogonRight",        // 배치로 로그온  
        L"SeIncreaseQuotaPrivilege", // 메모리 할당량 증가
        L"SeCreateGlobalPrivilege"   // 전역 객체 생성
    };
    
    if (!SetAccountRights(username, requiredRights)) {
        std::wcout << L"일부 권한 설정에 실패했습니다." << std::endl;
    }
    
    std::wcout << L"\n게임 서버 계정 설정 완료:" << std::endl;
    std::wcout << L"- 계정명: " << username << std::endl;
    std::wcout << L"- 서비스로 로그온 가능" << std::endl;
    std::wcout << L"- 최소 권한으로 제한됨" << std::endl;
    
    return true;
}

bool ServiceAccountManager::SetAccountRights(const std::wstring& username, 
                                            const std::vector<std::wstring>& rights) {
    LSA_HANDLE policyHandle;
    LSA_OBJECT_ATTRIBUTES objectAttributes;
    ZeroMemory(&objectAttributes, sizeof(LSA_OBJECT_ATTRIBUTES));
    
    NTSTATUS status = LsaOpenPolicy(NULL, &objectAttributes, 
                                   POLICY_ALL_ACCESS, &policyHandle);
    if (status != STATUS_SUCCESS) {
        return false;
    }
    
    // 사용자 SID 얻기 (이전 코드와 동일)
    PSID userSid = NULL;
    SID_NAME_USE sidType;
    DWORD sidSize = 0;
    DWORD domainSize = 0;
    
    LookupAccountName(NULL, username.c_str(), NULL, &sidSize, 
                     NULL, &domainSize, &sidType);
    
    userSid = (PSID)LocalAlloc(LPTR, sidSize);
    LPWSTR domainName = (LPWSTR)LocalAlloc(LPTR, domainSize * sizeof(WCHAR));
    
    if (!LookupAccountName(NULL, username.c_str(), userSid, &sidSize,
                          domainName, &domainSize, &sidType)) {
        LocalFree(userSid);
        LocalFree(domainName);
        LsaClose(policyHandle);
        return false;
    }
    
    // 각 권한을 개별적으로 설정
    bool allSuccess = true;
    for (const auto& right : rights) {
        LSA_UNICODE_STRING rightString;
        rightString.Buffer = const_cast<PWSTR>(right.c_str());
        rightString.Length = (USHORT)(right.length() * sizeof(WCHAR));
        rightString.MaximumLength = rightString.Length + sizeof(WCHAR);
        
        status = LsaAddAccountRights(policyHandle, userSid, &rightString, 1);
        if (status != STATUS_SUCCESS) {
            std::wcout << L"권한 설정 실패: " << right << std::endl;
            allSuccess = false;
        }
    }
    
    LocalFree(userSid);
    LocalFree(domainName);
    LsaClose(policyHandle);
    
    return allSuccess;
}

void ServiceAccountManager::DisplayAccountInfo(const std::wstring& username) {
    USER_INFO_3* pUserInfo = NULL;
    NET_API_STATUS status = NetUserGetInfo(
        m_serverName.empty() ? NULL : m_serverName.c_str(),
        username.c_str(),
        3,
        (LPBYTE*)&pUserInfo
    );
    
    if (status != NERR_Success) {
        std::wcout << L"사용자 정보 조회 실패: " << username << std::endl;
        return;
    }
    
    std::wcout << L"\n";
    std::wcout << L"╔══════════════════════════════════════════════════════════════╗\n";
    std::wcout << L"║                    서비스 계정 정보                           ║\n";
    std::wcout << L"╠══════════════════════════════════════════════════════════════╣\n";
    
    std::wcout << L"║ 계정명: " << pUserInfo->usri3_name << std::endl;
    std::wcout << L"║ 전체 이름: " << (pUserInfo->usri3_full_name ? 
                                    pUserInfo->usri3_full_name : L"N/A") << std::endl;
    
    std::wcout << L"║ 계정 상태: ";
    if (pUserInfo->usri3_flags & UF_ACCOUNTDISABLE) {
        std::wcout << L"비활성화";
    } else {
        std::wcout << L"활성화";
    }
    std::wcout << std::endl;
    
    std::wcout << L"║ 패스워드 만료: ";
    if (pUserInfo->usri3_flags & UF_DONT_EXPIRE_PASSWD) {
        std::wcout << L"만료되지 않음";
    } else {
        std::wcout << L"만료 가능";
    }
    std::wcout << std::endl;
    
    std::wcout << L"║ 권한 수준: ";
    switch (pUserInfo->usri3_priv) {
        case USER_PRIV_GUEST: std::wcout << L"게스트"; break;
        case USER_PRIV_USER: std::wcout << L"일반 사용자"; break;
        case USER_PRIV_ADMIN: std::wcout << L"관리자"; break;
        default: std::wcout << L"알 수 없음"; break;
    }
    std::wcout << std::endl;
    
    std::wcout << L"╚══════════════════════════════════════════════════════════════╝\n";
    
    NetApiBufferFree(pUserInfo);
}

bool ServiceAccountManager::ValidatePassword(const std::wstring& password) {
    // 기본 패스워드 정책 검사
    if (password.length() < 8) {
        std::cout << "패스워드는 최소 8자 이상이어야 합니다." << std::endl;
        return false;
    }
    
    bool hasUpper = false, hasLower = false, hasDigit = false, hasSpecial = false;
    
    for (wchar_t c : password) {
        if (c >= L'A' && c <= L'Z') hasUpper = true;
        else if (c >= L'a' && c <= L'z') hasLower = true;
        else if (c >= L'0' && c <= L'9') hasDigit = true;
        else if (c >= L'!' && c <= L'/') hasSpecial = true;
    }
    
    if (!hasUpper || !hasLower || !hasDigit || !hasSpecial) {
        std::cout << "패스워드는 대문자, 소문자, 숫자, 특수문자를 각각 포함해야 합니다." << std::endl;
        return false;
    }
    
    return true;
}

std::wstring ServiceAccountManager::GenerateSecurePassword() {
    const std::wstring chars = 
        L"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
    
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, chars.length() - 1);
    
    std::wstring password;
    password.reserve(16);
    
    for (int i = 0; i < 16; ++i) {
        password += chars[dis(gen)];
    }
    
    return password;
}
```
  

  
## 9.4 게임 서버 보안 고려사항

### 9.4.1 종합적인 보안 전략
게임 서버의 보안은 다층 방어 전략을 사용해야 한다:

```
    게임 서버 보안 아키텍처
              ↓
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   네트워크      │    │   애플리케이션  │    │   시스템        │
│ - 방화벽        │    │ - 입력 검증     │    │ - 접근 제어     │
│ - DDoS 방어     │    │ - 암호화        │    │ - 권한 최소화   │
│ - 트래픽 필터   │    │ - 인증/인가     │    │ - 감사 로깅     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
        ↓                      ↓                      ↓
    1차 방어선              2차 방어선             3차 방어선
```

### 9.4.2 보안 모니터링 시스템

```cpp
// GameServerSecurityMonitor.h
#pragma once
#include <windows.h>
#include <wtsapi32.h>
#include <iostream>
#include <string>
#include <vector>
#include <chrono>
#include <thread>
#include <atomic>
#include <mutex>
#include <fstream>

#pragma comment(lib, "wtsapi32.lib")

struct SecurityEvent {
    std::chrono::system_clock::time_point timestamp;
    std::string eventType;
    std::string description;
    int severity; // 1=Info, 2=Warning, 3=Critical
};

class GameServerSecurityMonitor {
private:
    std::atomic<bool> m_running;
    std::thread m_monitorThread;
    std::vector<SecurityEvent> m_securityLog;
    std::mutex m_logMutex;
    
    // 모니터링 설정
    bool m_monitorLogons;
    bool m_monitorProcesses;
    bool m_monitorNetwork;
    bool m_monitorFileAccess;
    
    // 임계값
    int m_maxFailedLogons;
    int m_maxProcesses;
    
public:
    GameServerSecurityMonitor();
    ~GameServerSecurityMonitor();
    
    bool Initialize();
    void StartMonitoring();
    void StopMonitoring();
    
    // 설정
    void SetMonitoringOptions(bool logons, bool processes, 
                             bool network, bool fileAccess);
    void SetThresholds(int maxFailedLogons, int maxProcesses);
    
    // 로깅 및 보고
    void LogSecurityEvent(const std::string& eventType, 
                         const std::string& description, 
                         int severity);
    void DisplaySecurityLog();
    void ExportSecurityLog(const std::string& filename);
    
    // 특정 보안 검사
    bool CheckSuspiciousActivity();
    void PerformSecurityAudit();
    void DisplaySecurityDashboard();
    
private:
    void MonitoringLoop();
    void CheckLogonSessions();
    void CheckRunningProcesses();
    void CheckNetworkConnections();
    void CheckFileSystemActivity();
    
    // 알림 시스템
    void SendAlert(const SecurityEvent& event);
    void WriteToEventLog(const SecurityEvent& event);
};
```

```cpp
// GameServerSecurityMonitor.cpp
#include "GameServerSecurityMonitor.h"

GameServerSecurityMonitor::GameServerSecurityMonitor()
    : m_running(false)
    , m_monitorLogons(true)
    , m_monitorProcesses(true)
    , m_monitorNetwork(true)
    , m_monitorFileAccess(false)
    , m_maxFailedLogons(5)
    , m_maxProcesses(100) {
}

GameServerSecurityMonitor::~GameServerSecurityMonitor() {
    StopMonitoring();
}

bool GameServerSecurityMonitor::Initialize() {
    LogSecurityEvent("System", "보안 모니터링 시스템 초기화", 1);
    return true;
}

void GameServerSecurityMonitor::StartMonitoring() {
    if (m_running.load()) {
        return;
    }
    
    m_running.store(true);
    m_monitorThread = std::thread(&GameServerSecurityMonitor::MonitoringLoop, this);
    
    LogSecurityEvent("System", "보안 모니터링 시작", 1);
    std::cout << "게임 서버 보안 모니터링이 시작되었습니다.\n";
}

void GameServerSecurityMonitor::StopMonitoring() {
    if (!m_running.load()) {
        return;
    }
    
    m_running.store(false);
    if (m_monitorThread.joinable()) {
        m_monitorThread.join();
    }
    
    LogSecurityEvent("System", "보안 모니터링 중지", 1);
    std::cout << "보안 모니터링이 중지되었습니다.\n";
}

void GameServerSecurityMonitor::MonitoringLoop() {
    while (m_running.load()) {
        try {
            if (m_monitorLogons) {
                CheckLogonSessions();
            }
            
            if (m_monitorProcesses) {
                CheckRunningProcesses();
            }
            
            if (m_monitorNetwork) {
                CheckNetworkConnections();
            }
            
            if (m_monitorFileAccess) {
                CheckFileSystemActivity();
            }
            
            // 의심스러운 활동 검사
            if (CheckSuspiciousActivity()) {
                LogSecurityEvent("Security", "의심스러운 활동 감지", 3);
            }
            
        } catch (const std::exception& e) {
            LogSecurityEvent("Error", 
                           std::string("모니터링 중 오류 발생: ") + e.what(), 2);
        }
        
        // 30초마다 검사
        std::this_thread::sleep_for(std::chrono::seconds(30));
    }
}

void GameServerSecurityMonitor::CheckLogonSessions() {
    PWTS_SESSION_INFO pSessionInfo = NULL;
    DWORD sessionCount = 0;
    
    if (!WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, 
                             &pSessionInfo, &sessionCount)) {
        return;
    }
    
    static DWORD lastSessionCount = 0;
    
    if (sessionCount != lastSessionCount) {
        std::string description = "로그온 세션 변경: " + 
                                std::to_string(sessionCount) + "개 활성 세션";
        LogSecurityEvent("Logon", description, 1);
        lastSessionCount = sessionCount;
    }
    
    // 비정상적인 세션 검사
    for (DWORD i = 0; i < sessionCount; ++i) {
        if (pSessionInfo[i].State == WTSActive) {
            LPWSTR pUserName = NULL;
            DWORD bytesReturned = 0;
            
            if (WTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,
                                          pSessionInfo[i].SessionId,
                                          WTSUserName,
                                          &pUserName,
                                          &bytesReturned)) {
                
                // 관리자 계정으로 로그온 검사
                if (wcscmp(pUserName, L"Administrator") == 0) {
                    LogSecurityEvent("Logon", "관리자 계정 로그온 감지", 2);
                }
                
                WTSFreeMemory(pUserName);
            }
        }
    }
    
    WTSFreeMemory(pSessionInfo);
}

void GameServerSecurityMonitor::CheckRunningProcesses() {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return;
    }
    
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    
    int processCount = 0;
    std::vector<std::string> suspiciousProcesses;
    
    if (Process32First(hSnapshot, &pe32)) {
        do {
            processCount++;
            
            // 의심스러운 프로세스 이름 검사
            std::string processName = pe32.szExeFile;
            std::transform(processName.begin(), processName.end(), 
                          processName.begin(), ::tolower);
            
            // 일반적으로 악성코드가 사용하는 이름들
            std::vector<std::string> suspiciousNames = {
                "cmd.exe", "powershell.exe", "net.exe", "netsh.exe",
                "reg.exe", "regedit.exe", "tasklist.exe", "taskkill.exe"
            };
            
            for (const auto& suspicious : suspiciousNames) {
                if (processName.find(suspicious) != std::string::npos) {
                    suspiciousProcesses.push_back(processName);
                    break;
                }
            }
            
        } while (Process32Next(hSnapshot, &pe32));
    }
    
    CloseHandle(hSnapshot);
    
    // 프로세스 수 임계값 검사
    if (processCount > m_maxProcesses) {
        std::string description = "높은 프로세스 수 감지: " + 
                                std::to_string(processCount) + "개";
        LogSecurityEvent("Process", description, 2);
    }
    
    // 의심스러운 프로세스 보고
    for (const auto& process : suspiciousProcesses) {
        std::string description = "의심스러운 프로세스: " + process;
        LogSecurityEvent("Process", description, 2);
    }
}

void GameServerSecurityMonitor::PerformSecurityAudit() {
    std::cout << "\n게임 서버 보안 감사를 수행합니다...\n";
    
    // 1. 현재 사용자 권한 검사
    SecurityManager secMgr;
    if (secMgr.Initialize()) {
        secMgr.CheckGameServerSecurity();
    }
    
    // 2. UAC 상태 검사
    ElevationManager::DisplayUACStatus();
    
    // 3. 네트워크 포트 검사
    std::cout << "\n네트워크 포트 보안 검사:\n";
    // TODO: 열린 포트 검사 구현
    
    // 4. 파일 시스템 권한 검사
    std::cout << "\n파일 시스템 보안 검사:\n";
    // TODO: 중요 파일/폴더 권한 검사 구현
    
    // 5. 레지스트리 보안 검사
    std::cout << "\n레지스트리 보안 검사:\n";
    // TODO: 중요 레지스트리 키 권한 검사 구현
    
    LogSecurityEvent("Audit", "보안 감사 완료", 1);
}

void GameServerSecurityMonitor::DisplaySecurityDashboard() {
    std::lock_guard<std::mutex> lock(m_logMutex);
    
    std::cout << "\n";
    std::cout << "╔══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║                  게임 서버 보안 대시보드                      ║\n";
    std::cout << "╠══════════════════════════════════════════════════════════════╣\n";
    
    // 최근 24시간 이벤트 통계
    auto now = std::chrono::system_clock::now();
    auto dayAgo = now - std::chrono::hours(24);
    
    int totalEvents = 0;
    int warningEvents = 0;
    int criticalEvents = 0;
    
    for (const auto& event : m_securityLog) {
        if (event.timestamp >= dayAgo) {
            totalEvents++;
            if (event.severity == 2) warningEvents++;
            else if (event.severity == 3) criticalEvents++;
        }
    }
    
    std::cout << "║ 최근 24시간 보안 이벤트:" << std::endl;
    std::cout << "║ ├─ 전체: " << totalEvents << "개" << std::endl;
    std::cout << "║ ├─ 경고: " << warningEvents << "개" << std::endl;
    std::cout << "║ └─ 위험: " << criticalEvents << "개" << std::endl;
    std::cout << "║" << std::endl;
    
    // 보안 상태 표시
    std::string securityStatus = "정상";
    if (criticalEvents > 0) {
        securityStatus = "⚠️  위험";
    } else if (warningEvents > 5) {
        securityStatus = "⚠️  주의";
    }
    
    std::cout << "║ 현재 보안 상태: " << securityStatus << std::endl;
    std::cout << "║ 모니터링 상태: " << (m_running.load() ? "활성" : "비활성") << std::endl;
    
    std::cout << "╚══════════════════════════════════════════════════════════════╝\n";
    
    // 최근 중요 이벤트 표시
    if (criticalEvents > 0 || warningEvents > 0) {
        std::cout << "\n최근 중요 이벤트:\n";
        int shown = 0;
        for (auto it = m_securityLog.rbegin(); 
             it != m_securityLog.rend() && shown < 5; ++it) {
            if (it->timestamp >= dayAgo && it->severity >= 2) {
                auto timeT = std::chrono::system_clock::to_time_t(it->timestamp);
                std::cout << "- [" << std::put_time(std::localtime(&timeT), "%H:%M:%S")
                          << "] " << it->description << std::endl;
                shown++;
            }
        }
    }
}

void GameServerSecurityMonitor::LogSecurityEvent(const std::string& eventType, 
                                                 const std::string& description, 
                                                 int severity) {
    std::lock_guard<std::mutex> lock(m_logMutex);
    
    SecurityEvent event;
    event.timestamp = std::chrono::system_clock::now();
    event.eventType = eventType;
    event.description = description;
    event.severity = severity;
    
    m_securityLog.push_back(event);
    
    // 로그 크기 제한 (최근 1000개만 유지)
    if (m_securityLog.size() > 1000) {
        m_securityLog.erase(m_securityLog.begin());
    }
    
    // 심각한 이벤트는 즉시 표시
    if (severity >= 3) {
        auto timeT = std::chrono::system_clock::to_time_t(event.timestamp);
        std::cout << "🚨 CRITICAL: [" 
                  << std::put_time(std::localtime(&timeT), "%H:%M:%S")
                  << "] " << description << std::endl;
    }
}

bool GameServerSecurityMonitor::CheckSuspiciousActivity() {
    // 여기서는 간단한 예시만 구현
    std::lock_guard<std::mutex> lock(m_logMutex);
    
    // 최근 5분간 경고 이벤트가 10개 이상이면 의심스러운 활동으로 판단
    auto now = std::chrono::system_clock::now();
    auto fiveMinAgo = now - std::chrono::minutes(5);
    
    int warningCount = 0;
    for (const auto& event : m_securityLog) {
        if (event.timestamp >= fiveMinAgo && event.severity >= 2) {
            warningCount++;
        }
    }
    
    return warningCount >= 10;
}
```

### 9.4.3 통합 사용 예제
모든 보안 기능을 통합한 사용 예제이다:

```cpp
// main.cpp
#include "SecurityManager.h"
#include "ElevationManager.h"
#include "ServiceAccountManager.h"
#include "GameServerSecurityMonitor.h"
#include <iostream>
#include <conio.h>

void DisplaySecurityMenu() {
    std::cout << "\n";
    std::cout << "╔══════════════════════════════════════════════════════════════╗\n";
    std::cout << "║                 게임 서버 보안 관리 도구                      ║\n";
    std::cout << "╠══════════════════════════════════════════════════════════════╣\n";
    std::cout << "║ 1. 현재 보안 상태 확인                                       ║\n";
    std::cout << "║ 2. Access Token 정보 조회                                    ║\n";
    std::cout << "║ 3. 권한 상승 (UAC) 테스트                                    ║\n";
    std::cout << "║ 4. 서비스 계정 생성                                          ║\n";
    std::cout << "║ 5. 보안 감사 수행                                            ║\n";
    std::cout << "║ 6. 실시간 보안 모니터링                                      ║\n";
    std::cout << "║ 7. 종합 보안 보고서                                          ║\n";
    std::cout << "║ 0. 종료                                                      ║\n";
    std::cout << "╚══════════════════════════════════════════════════════════════╝\n";
    std::cout << "선택하세요: ";
}

int main() {
    SetConsoleOutputCP(CP_UTF8);
    
    std::cout << "게임 서버 보안 관리 도구를 시작합니다...\n";
    
    SecurityManager securityMgr;
    ServiceAccountManager serviceMgr;
    GameServerSecurityMonitor securityMonitor;
    
    // 기본 초기화
    securityMgr.Initialize();
    securityMonitor.Initialize();
    
    int choice;
    do {
        DisplaySecurityMenu();
        std::cin >> choice;
        
        switch (choice) {
            case 1:
                std::cout << "\n=== 현재 보안 상태 확인 ===\n";
                securityMgr.DisplaySecurityReport();
                break;
                
            case 2:
                std::cout << "\n=== Access Token 정보 ===\n";
                securityMgr.DisplayCurrentUserInfo();
                securityMgr.DisplayTokenPrivileges();
                break;
                
            case 3:
                std::cout << "\n=== UAC 권한 상승 테스트 ===\n";
                ElevationManager::DisplayUACStatus();
                
                if (!ElevationManager::IsElevated()) {
                    std::cout << "\n권한 상승을 테스트하시겠습니까? (y/n): ";
                    char response;
                    std::cin >> response;
                    if (response == 'y' || response == 'Y') {
                        ElevationManager::RestartAsElevated();
                    }
                }
                break;
                
            case 4:
                std::cout << "\n=== 서비스 계정 생성 ===\n";
                {
                    std::wstring username, password;
                    std::wcout << L"계정명: ";
                    std::wcin >> username;
                    std::wcout << L"패스워드: ";
                    std::wcin >> password;
                    
                    if (serviceMgr.CreateGameServerAccount(username, password)) {
                        serviceMgr.DisplayAccountInfo(username);
                    }
                }
                break;
                
            case 5:
                std::cout << "\n=== 보안 감사 수행 ===\n";
                securityMonitor.PerformSecurityAudit();
                break;
                
            case 6:
                std::cout << "\n=== 실시간 보안 모니터링 ===\n";
                securityMonitor.StartMonitoring();
                std::cout << "모니터링이 시작되었습니다. 아무 키나 누르면 중지합니다...\n";
                
                // 대시보드 표시
                for (int i = 0; i < 10; ++i) {
                    std::this_thread::sleep_for(std::chrono::seconds(3));
                    system("cls");
                    securityMonitor.DisplaySecurityDashboard();
                    
                    if (_kbhit()) {
                        _getch();
                        break;
                    }
                }
                
                securityMonitor.StopMonitoring();
                break;
                
            case 7:
                std::cout << "\n=== 종합 보안 보고서 ===\n";
                securityMgr.DisplaySecurityReport();
                ElevationManager::DisplayUACStatus();
                securityMonitor.DisplaySecurityDashboard();
                break;
                
            case 0:
                std::cout << "보안 관리 도구를 종료합니다.\n";
                break;
                
            default:
                std::cout << "잘못된 선택입니다.\n";
                break;
        }
        
        if (choice != 0 && choice != 6) {
            std::cout << "\n계속하려면 아무 키나 누르세요...";
            _getch();
        }
        
    } while (choice != 0);
    
    return 0;
}
```
  


## 요약
이번 장에서는 게임 서버 개발에 필요한 Windows 보안과 권한 관리에 대해 학습했다. Access Token을 통한 사용자 권한 확인, UAC를 이용한 권한 상승, 서비스 계정 관리, 그리고 종합적인 보안 모니터링 시스템까지 다뤘다.

주요 학습 내용:
- Windows 보안 모델과 Access Token의 구조 및 활용
- UAC (User Account Control)를 통한 안전한 권한 상승 방법
- 게임 서버용 서비스 계정 생성 및 권한 관리
- 실시간 보안 모니터링과 위협 탐지 시스템
- 최소 권한 원칙과 다층 방어 전략의 적용

게임 서버의 보안은 단순히 기술적인 구현을 넘어서 운영 정책과 모니터링 체계까지 포함하는 종합적인 접근이 필요하다. 다음 장에서는 게임 서버를 Windows 서비스로 구현하는 방법에 대해 알아보겠다.  