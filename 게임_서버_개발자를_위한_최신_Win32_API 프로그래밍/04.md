# 게임 서버 개발자를 위한 최신 Win32 API 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  

# Chapter 4. 프로세스와 스레드
게임 서버에서 멀티스레딩은 필수적이다. 동시에 여러 플레이어의 요청을 처리하고, 게임 로직을 실행하며, 네트워크 통신을 관리하기 위해서는 효율적인 스레드 관리가 중요하다. 이 장에서는 Win32 API를 사용한 스레드 프로그래밍의 핵심 기술들을 학습하겠다.

## 4.1 스레드 생성 및 관리

### 4.1.1 CreateThread - 기본 스레드 생성
Win32에서 스레드를 생성하는 가장 기본적인 방법은 `CreateThread` 함수를 사용하는 것이다.

```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include <atomic>
#include <memory>

// 스레드 컨텍스트 구조체
struct ThreadContext {
    int threadId;
    std::atomic<bool>* running;
    std::atomic<int>* sharedCounter;
    HANDLE completionEvent;
    
    ThreadContext(int id, std::atomic<bool>* run, std::atomic<int>* counter) 
        : threadId(id), running(run), sharedCounter(counter) {
        completionEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
    }
    
    ~ThreadContext() {
        if (completionEvent != nullptr) {
            CloseHandle(completionEvent);
        }
    }
};

// 워커 스레드 함수
DWORD WINAPI WorkerThreadProc(LPVOID lpParam) {
    auto context = static_cast<ThreadContext*>(lpParam);
    
    std::cout << "워커 스레드 " << context->threadId << " 시작됨 (TID: " 
              << GetCurrentThreadId() << ")" << std::endl;
    
    /*
    ┌─────────────────────────────────────────┐
    │           Worker Thread Lifecycle       │
    ├─────────────────────────────────────────┤
    │                                         │
    │  ┌─────────────────────────────────┐    │
    │  │        Thread Started           │    │
    │  └──────────────┬──────────────────┘    │
    │                 │                       │
    │                 ▼                       │
    │  ┌─────────────────────────────────┐    │
    │  │     Process Game Logic          │    │
    │  │   (while running == true)       │    │
    │  └──────────────┬──────────────────┘    │
    │                 │                       │
    │                 ▼                       │
    │  ┌─────────────────────────────────┐    │
    │  │      Cleanup & Signal           │    │
    │  │      Completion Event           │    │
    │  └─────────────────────────────────┘    │
    └─────────────────────────────────────────┘
    */
    
    // 게임 로직 시뮬레이션
    while (context->running->load()) {
        // 작업 수행 (예: 플레이어 상태 업데이트)
        int currentValue = context->sharedCounter->fetch_add(1);
        
        if (currentValue % 1000 == 0) {
            std::cout << "스레드 " << context->threadId 
                      << " - 처리된 작업: " << currentValue << std::endl;
        }
        
        // CPU 사용률 조절
        Sleep(1);
    }
    
    // 완료 신호
    SetEvent(context->completionEvent);
    
    std::cout << "워커 스레드 " << context->threadId << " 종료됨" << std::endl;
    return 0;
}

class BasicThreadManager {
private:
    std::vector<HANDLE> m_threads;
    std::vector<std::unique_ptr<ThreadContext>> m_contexts;
    std::atomic<bool> m_running;
    std::atomic<int> m_sharedCounter;
    
public:
    BasicThreadManager() : m_running(false), m_sharedCounter(0) {}
    
    ~BasicThreadManager() {
        Stop();
    }
    
    bool Start(int threadCount) {
        if (m_running.load()) {
            return false; // 이미 실행 중
        }
        
        m_running = true;
        m_sharedCounter = 0;
        
        // 스레드 생성
        for (int i = 0; i < threadCount; ++i) {
            auto context = std::make_unique<ThreadContext>(i, &m_running, &m_sharedCounter);
            
            HANDLE hThread = CreateThread(
                nullptr,                    // 보안 속성
                0,                         // 스택 크기 (기본값)
                WorkerThreadProc,          // 스레드 함수
                context.get(),             // 매개변수
                0,                         // 생성 플래그
                nullptr                    // 스레드 ID (옵션)
            );
            
            if (hThread == nullptr) {
                std::cout << "스레드 " << i << " 생성 실패: " << GetLastError() << std::endl;
                continue;
            }
            
            m_threads.push_back(hThread);
            m_contexts.push_back(std::move(context));
        }
        
        std::cout << m_threads.size() << "개의 워커 스레드가 시작되었습니다." << std::endl;
        return !m_threads.empty();
    }
    
    void Stop() {
        if (!m_running.load()) {
            return;
        }
        
        std::cout << "스레드 중지 신호 전송..." << std::endl;
        m_running = false;
        
        // 모든 스레드 완료 대기
        WaitForMultipleThreads();
        
        // 리소스 정리
        CleanupThreads();
        
        std::cout << "총 처리된 작업 수: " << m_sharedCounter.load() << std::endl;
    }
    
    void WaitForCompletion(DWORD timeoutMs = INFINITE) {
        WaitForMultipleThreads(timeoutMs);
    }
    
private:
    void WaitForMultipleThreads(DWORD timeoutMs = INFINITE) {
        if (m_threads.empty()) return;
        
        // 모든 스레드 핸들을 대기
        DWORD result = WaitForMultipleObjects(
            static_cast<DWORD>(m_threads.size()),
            m_threads.data(),
            TRUE,          // 모든 객체가 신호 상태가 될 때까지 대기
            timeoutMs
        );
        
        switch (result) {
            case WAIT_OBJECT_0:
                std::cout << "모든 스레드가 정상 종료되었습니다." << std::endl;
                break;
            case WAIT_TIMEOUT:
                std::cout << "스레드 종료 대기 시간 초과" << std::endl;
                break;
            case WAIT_FAILED:
                std::cout << "스레드 대기 실패: " << GetLastError() << std::endl;
                break;
        }
    }
    
    void CleanupThreads() {
        for (HANDLE hThread : m_threads) {
            if (hThread != nullptr) {
                CloseHandle(hThread);
            }
        }
        
        m_threads.clear();
        m_contexts.clear();
    }
};
```
   
이 코드는 **Win32 API의 `CreateThread` 함수를 사용하여 스레드를 생성하고 관리하는 기본적인 방법**을 보여주는 예제이다.
멀티스레딩은 프로그램이 여러 작업을 동시에 수행하도록 만들어 CPU 사용 효율을 높이는 기술이다.
이 예제에서는 여러 개의 “워커 스레드(Worker Thread)”를 생성해 **공유된 카운터 값을 증가시키는 작업을 병렬로 수행**하도록 구성되어 있다.
게임 서버나 실시간 시스템에서 **여러 개의 동시 작업을 효율적으로 처리해야 할 때** 자주 사용되는 기본적인 구조다.

#### 1. ThreadContext 구조체 — 스레드 정보 관리

```cpp
struct ThreadContext {
    int threadId;
    std::atomic<bool>* running;
    std::atomic<int>* sharedCounter;
    HANDLE completionEvent;
    
    ThreadContext(int id, std::atomic<bool>* run, std::atomic<int>* counter) 
        : threadId(id), running(run), sharedCounter(counter) {
        completionEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
    }
    
    ~ThreadContext() {
        if (completionEvent != nullptr) {
            CloseHandle(completionEvent);
        }
    }
};
```

이 구조체는 **각 스레드의 실행 상태와 공유 데이터에 대한 참조를 저장**한다.

* `threadId`: 스레드 번호를 식별하기 위한 ID이다.
* `running`: 프로그램 전체의 실행 여부를 제어하는 플래그이다. `false`가 되면 스레드 루프가 종료된다.
* `sharedCounter`: 여러 스레드가 공유하는 원자적(atomic) 카운터이다. 스레드 안전하게 증가시킬 수 있다.
* `completionEvent`: 스레드가 종료되었음을 알리기 위한 이벤트 핸들이다.

생성자에서는 `CreateEvent`로 이벤트 객체를 만들고, 소멸자에서는 `CloseHandle`로 자원을 해제한다.


#### 2. WorkerThreadProc 함수 — 스레드의 실제 동작

```cpp
DWORD WINAPI WorkerThreadProc(LPVOID lpParam) {
    auto context = static_cast<ThreadContext*>(lpParam);
    
    std::cout << "워커 스레드 " << context->threadId << " 시작됨 (TID: " 
              << GetCurrentThreadId() << ")" << std::endl;
    
    while (context->running->load()) {
        int currentValue = context->sharedCounter->fetch_add(1);
        
        if (currentValue % 1000 == 0) {
            std::cout << "스레드 " << context->threadId 
                      << " - 처리된 작업: " << currentValue << std::endl;
        }
        Sleep(1);
    }
    
    SetEvent(context->completionEvent);
    std::cout << "워커 스레드 " << context->threadId << " 종료됨" << std::endl;
    return 0;
}
```

이 함수는 `CreateThread`로 생성된 **각 워커 스레드가 실제로 수행할 코드**이다.
`ThreadContext`를 전달받아 다음과 같은 흐름으로 동작한다.

1. 스레드가 시작될 때 로그를 출력한다.
2. `running`이 `true`인 동안 반복문을 실행한다.
3. `sharedCounter`를 원자적으로 1씩 증가시킨다.
4. 1000번 단위로 현재 상태를 출력한다.
5. `Sleep(1)`을 통해 CPU 점유율을 조절한다.
6. `running`이 `false`가 되면 반복을 종료하고, `SetEvent`로 종료를 알린다.


#### 3. BasicThreadManager 클래스 — 스레드 전체 관리

```cpp
class BasicThreadManager {
private:
    std::vector<HANDLE> m_threads;
    std::vector<std::unique_ptr<ThreadContext>> m_contexts;
    std::atomic<bool> m_running;
    std::atomic<int> m_sharedCounter;
```

이 클래스는 여러 스레드를 통합 관리하는 역할을 한다.

* `m_threads`: 각 스레드의 핸들을 보관한다.
* `m_contexts`: 스레드별로 생성된 `ThreadContext`를 스마트 포인터로 관리한다.
* `m_running`: 전체 스레드의 실행 상태를 제어하는 전역 플래그이다.
* `m_sharedCounter`: 모든 스레드가 공유하는 작업 카운터이다.


#### 4. 스레드 시작 함수

```cpp
bool Start(int threadCount) {
    if (m_running.load()) {
        return false;
    }

    m_running = true;
    m_sharedCounter = 0;

    for (int i = 0; i < threadCount; ++i) {
        auto context = std::make_unique<ThreadContext>(i, &m_running, &m_sharedCounter);
        HANDLE hThread = CreateThread(nullptr, 0, WorkerThreadProc, context.get(), 0, nullptr);
        ...
    }
}
```

`Start` 함수는 지정된 개수(`threadCount`)만큼 스레드를 생성한다.
각 스레드는 `WorkerThreadProc`을 실행하며, `ThreadContext`를 매개변수로 전달받는다.
`CreateThread` 호출이 실패하면 오류를 출력하고, 성공한 스레드의 핸들을 리스트에 저장한다.

모든 스레드가 생성되면 `"N개의 워커 스레드가 시작되었습니다."`라는 메시지를 출력한다.


#### 5. 스레드 종료 및 정리

```cpp
void Stop() {
    if (!m_running.load()) {
        return;
    }

    std::cout << "스레드 중지 신호 전송..." << std::endl;
    m_running = false;

    WaitForMultipleThreads();
    CleanupThreads();

    std::cout << "총 처리된 작업 수: " << m_sharedCounter.load() << std::endl;
}
```

`Stop` 함수는 스레드 실행을 중지하고 모든 스레드가 종료될 때까지 기다린다.

* `m_running`을 `false`로 설정해 각 스레드의 루프를 종료시킨다.
* `WaitForMultipleThreads()`로 모든 스레드가 완료될 때까지 대기한다.
* `CleanupThreads()`로 스레드 핸들과 컨텍스트를 정리한다.


#### 6. 스레드 대기 및 리소스 해제

```cpp
void WaitForMultipleThreads(DWORD timeoutMs = INFINITE) {
    DWORD result = WaitForMultipleObjects(
        static_cast<DWORD>(m_threads.size()),
        m_threads.data(),
        TRUE,
        timeoutMs
    );
}
```

`WaitForMultipleObjects`를 사용하여 모든 스레드가 신호 상태가 될 때까지 기다린다.
이 함수는 여러 스레드의 종료를 한 번에 감시할 수 있는 Win32의 유용한 동기화 함수이다.
대기 결과에 따라 **정상 종료**, **시간 초과**, **오류 발생**을 구분해 로그를 출력한다.

이후 `CleanupThreads()`에서는 스레드 핸들을 닫고 벡터를 비운다.

#### 7. 요약
이 예제는 **Win32 API의 기본적인 스레드 생성, 실행, 종료, 동기화 과정**을 단계별로 보여준다.
핵심 포인트는 다음과 같다.

* `CreateThread`로 스레드 생성
* `std::atomic`을 이용한 안전한 공유 데이터 접근
* `Event` 객체를 통한 스레드 종료 신호 전달
* `WaitForMultipleObjects`를 통한 전체 스레드 종료 대기

이 코드는 게임 서버나 엔진 개발에서 **병렬 처리 구조를 이해하고 실습하는 기초 예제**로 활용하기에 적합하다.


### 4.1.2 WaitForSingleObject와 스레드 동기화
스레드 간의 동기화는 게임 서버에서 매우 중요하다.

```cpp
#include <chrono>
#include <queue>
#include <mutex>

// 게임 이벤트 구조체
struct GameEvent {
    int playerId;
    std::string eventType;
    std::string data;
    std::chrono::steady_clock::time_point timestamp;
    
    GameEvent(int id, const std::string& type, const std::string& eventData)
        : playerId(id), eventType(type), data(eventData) {
        timestamp = std::chrono::steady_clock::now();
    }
};

class GameEventProcessor {
private:
    std::queue<GameEvent> m_eventQueue;
    std::mutex m_queueMutex;
    HANDLE m_eventAvailable;
    HANDLE m_processorThread;
    std::atomic<bool> m_running;
    
public:
    GameEventProcessor() : m_processorThread(nullptr), m_running(false) {
        // 수동 리셋 이벤트 생성
        m_eventAvailable = CreateEvent(nullptr, FALSE, FALSE, nullptr);
        if (m_eventAvailable == nullptr) {
            throw std::runtime_error("이벤트 객체 생성 실패");
        }
    }
    
    ~GameEventProcessor() {
        Stop();
        if (m_eventAvailable != nullptr) {
            CloseHandle(m_eventAvailable);
        }
    }
    
    bool Start() {
        if (m_running.load()) return false;
        
        m_running = true;
        
        // 이벤트 처리 스레드 생성
        m_processorThread = CreateThread(
            nullptr, 0, ProcessorThreadProc, this, 0, nullptr);
        
        if (m_processorThread == nullptr) {
            m_running = false;
            return false;
        }
        
        std::cout << "게임 이벤트 프로세서 시작됨" << std::endl;
        return true;
    }
    
    void Stop() {
        if (!m_running.load()) return;
        
        m_running = false;
        
        // 프로세서 스레드가 깨어나도록 이벤트 신호
        SetEvent(m_eventAvailable);
        
        if (m_processorThread != nullptr) {
            // 스레드 종료 대기 (최대 5초)
            DWORD waitResult = WaitForSingleObject(m_processorThread, 5000);
            
            switch (waitResult) {
                case WAIT_OBJECT_0:
                    std::cout << "이벤트 프로세서가 정상 종료되었습니다." << std::endl;
                    break;
                case WAIT_TIMEOUT:
                    std::cout << "이벤트 프로세서 강제 종료" << std::endl;
                    TerminateThread(m_processorThread, 1);
                    break;
                case WAIT_FAILED:
                    std::cout << "스레드 대기 실패: " << GetLastError() << std::endl;
                    break;
            }
            
            CloseHandle(m_processorThread);
            m_processorThread = nullptr;
        }
    }
    
    void AddEvent(const GameEvent& event) {
        {
            std::lock_guard<std::mutex> lock(m_queueMutex);
            m_eventQueue.push(event);
        }
        
        // 이벤트 처리 스레드에게 신호
        SetEvent(m_eventAvailable);
    }
    
private:
    static DWORD WINAPI ProcessorThreadProc(LPVOID lpParam) {
        auto processor = static_cast<GameEventProcessor*>(lpParam);
        return processor->ProcessorThreadLoop();
    }
    
    DWORD ProcessorThreadLoop() {
        std::cout << "이벤트 처리 스레드 시작 (TID: " << GetCurrentThreadId() << ")" << std::endl;
        
        while (m_running.load()) {
            // 이벤트 대기 (최대 1초)
            DWORD waitResult = WaitForSingleObject(m_eventAvailable, 1000);
            
            switch (waitResult) {
                case WAIT_OBJECT_0:
                    // 이벤트가 신호 상태 - 큐에서 이벤트 처리
                    ProcessEvents();
                    break;
                    
                case WAIT_TIMEOUT:
                    // 타임아웃 - 주기적인 작업 수행
                    PerformPeriodicTasks();
                    break;
                    
                case WAIT_FAILED:
                    std::cout << "이벤트 대기 실패: " << GetLastError() << std::endl;
                    return 1;
            }
        }
        
        // 종료 전 남은 이벤트 처리
        ProcessEvents();
        
        std::cout << "이벤트 처리 스레드 종료" << std::endl;
        return 0;
    }
    
    void ProcessEvents() {
        std::lock_guard<std::mutex> lock(m_queueMutex);
        
        while (!m_eventQueue.empty()) {
            GameEvent event = m_eventQueue.front();
            m_eventQueue.pop();
            
            ProcessSingleEvent(event);
        }
    }
    
    void ProcessSingleEvent(const GameEvent& event) {
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            now - event.timestamp).count();
        
        std::cout << "[이벤트 처리] 플레이어 " << event.playerId 
                  << " - " << event.eventType 
                  << " (지연: " << elapsed << "ms)" << std::endl;
        
        // 실제 게임 이벤트 처리 로직
        if (event.eventType == "PLAYER_MOVE") {
            HandlePlayerMove(event);
        } else if (event.eventType == "PLAYER_ATTACK") {
            HandlePlayerAttack(event);
        } else if (event.eventType == "PLAYER_CHAT") {
            HandlePlayerChat(event);
        }
    }
    
    void HandlePlayerMove(const GameEvent& event) {
        // 플레이어 이동 처리
        std::cout << "  → 플레이어 이동 처리: " << event.data << std::endl;
    }
    
    void HandlePlayerAttack(const GameEvent& event) {
        // 플레이어 공격 처리
        std::cout << "  → 플레이어 공격 처리: " << event.data << std::endl;
    }
    
    void HandlePlayerChat(const GameEvent& event) {
        // 채팅 메시지 처리
        std::cout << "  → 채팅 메시지 처리: " << event.data << std::endl;
    }
    
    void PerformPeriodicTasks() {
        // 주기적인 작업 (예: 하트비트, 통계 업데이트)
        static int taskCounter = 0;
        if (++taskCounter % 10 == 0) {
            std::cout << "[주기 작업] 시스템 상태 체크..." << std::endl;
        }
    }
};
```
   
이번 예제는 **Win32 API의 `WaitForSingleObject` 함수를 이용해 스레드 간 동기화를 구현하는 방법**을 보여준다.
멀티스레드 환경에서는 여러 스레드가 동시에 공유 자원에 접근하거나 작업을 수행할 수 있기 때문에, **스레드 간의 순서와 타이밍을 적절히 제어하는 동기화 기법**이 필수적이다.
특히 **게임 서버**처럼 실시간으로 수많은 이벤트를 처리해야 하는 프로그램에서는, 스레드 간 동기화가 안정적인 동작을 보장하는 핵심 요소가 된다.

이 코드는 `GameEventProcessor`라는 클래스를 통해 **이벤트 큐를 기반으로 동작하는 스레드형 이벤트 처리 시스템**을 구현한 예제다.
핵심적으로 `WaitForSingleObject`를 사용하여 **새로운 이벤트가 도착했을 때만 스레드를 깨워서 처리**하도록 한다.

#### 1. GameEvent 구조체 — 이벤트 데이터 표현

```cpp
struct GameEvent {
    int playerId;
    std::string eventType;
    std::string data;
    std::chrono::steady_clock::time_point timestamp;
    
    GameEvent(int id, const std::string& type, const std::string& eventData)
        : playerId(id), eventType(type), data(eventData) {
        timestamp = std::chrono::steady_clock::now();
    }
};
```

이 구조체는 **게임 내에서 발생하는 이벤트의 정보를 담는 역할**을 한다.
각 이벤트에는 다음과 같은 정보가 포함된다.

* `playerId`: 이벤트를 발생시킨 플레이어의 ID
* `eventType`: 이벤트의 종류 (예: 이동, 공격, 채팅 등)
* `data`: 이벤트의 세부 데이터 (예: 좌표, 공격 대상 등)
* `timestamp`: 이벤트가 발생한 시각

이 구조체는 이벤트 처리 시 **시간 지연 계산 및 로그 출력**에도 사용된다.

#### 2. GameEventProcessor 클래스 — 이벤트 처리 시스템의 핵심

```cpp
class GameEventProcessor {
private:
    std::queue<GameEvent> m_eventQueue;
    std::mutex m_queueMutex;
    HANDLE m_eventAvailable;
    HANDLE m_processorThread;
    std::atomic<bool> m_running;
```

이 클래스는 **이벤트 큐를 관리하고 이를 비동기적으로 처리하는 스레드를 운영**한다.

* `m_eventQueue`: 처리할 이벤트들이 저장되는 큐
* `m_queueMutex`: 이벤트 큐 접근 시 경쟁 상태를 방지하기 위한 뮤텍스
* `m_eventAvailable`: 이벤트가 도착했음을 알리는 Win32 이벤트 객체
* `m_processorThread`: 이벤트를 처리하는 워커 스레드
* `m_running`: 스레드 실행 여부를 제어하는 플래그

#### 3. 생성자와 소멸자 — 이벤트 객체 초기화

```cpp
GameEventProcessor() {
    m_eventAvailable = CreateEvent(nullptr, FALSE, FALSE, nullptr);
    if (m_eventAvailable == nullptr) {
        throw std::runtime_error("이벤트 객체 생성 실패");
    }
}
```

`CreateEvent`는 Win32의 이벤트 객체를 생성하는 함수다.
여기서는 **자동 리셋(auto-reset)** 모드(`FALSE`)로 생성되어, 한 번 신호가 전달되면 자동으로 다시 비신호 상태로 돌아간다.
이벤트 객체는 스레드 간 신호 전달에 사용되며, 새로운 이벤트가 추가될 때마다 `SetEvent`로 신호를 보낸다.

소멸자에서는 `Stop()`을 호출하여 스레드를 종료시키고, `CloseHandle`로 이벤트 객체를 정리한다.

#### 4. 스레드 시작 및 종료

```cpp
bool Start() {
    m_running = true;
    m_processorThread = CreateThread(nullptr, 0, ProcessorThreadProc, this, 0, nullptr);
}
```

`Start()`는 이벤트를 처리할 스레드를 생성한다.
스레드는 `ProcessorThreadProc` 함수를 시작점으로 실행되며, 이 함수는 다시 `ProcessorThreadLoop()`를 호출한다.

```cpp
void Stop() {
    m_running = false;
    SetEvent(m_eventAvailable); // 스레드를 깨운다
    WaitForSingleObject(m_processorThread, 5000);
}
```

`Stop()`에서는 실행 플래그를 `false`로 바꾸고, **스레드가 깨어나 종료 루틴으로 진입할 수 있도록 이벤트 신호를 보낸다.**
그 후 `WaitForSingleObject`를 이용해 최대 5초 동안 스레드가 종료될 때까지 기다린다.

* 정상 종료 시 `"이벤트 프로세서가 정상 종료되었습니다."` 출력
* 시간 초과 시 `TerminateThread`로 강제 종료
* 실패 시 `GetLastError`로 오류 확인

#### 5. 이벤트 추가 — 스레드 간 신호 전달

```cpp
void AddEvent(const GameEvent& event) {
    {
        std::lock_guard<std::mutex> lock(m_queueMutex);
        m_eventQueue.push(event);
    }
    SetEvent(m_eventAvailable);
}
```

`AddEvent()`는 외부에서 발생한 이벤트를 큐에 추가한다.
뮤텍스로 큐를 보호하면서 이벤트를 안전하게 넣고, `SetEvent()`를 호출하여 **이벤트 처리 스레드를 깨운다.**
이 덕분에 스레드는 이벤트가 생길 때만 깨어나서 불필요한 CPU 자원을 낭비하지 않는다.

#### 6. ProcessorThreadLoop — 이벤트 처리 루프

```cpp
DWORD ProcessorThreadLoop() {
    while (m_running.load()) {
        DWORD waitResult = WaitForSingleObject(m_eventAvailable, 1000);
        switch (waitResult) {
            case WAIT_OBJECT_0: ProcessEvents(); break;
            case WAIT_TIMEOUT: PerformPeriodicTasks(); break;
            case WAIT_FAILED: return 1;
        }
    }
    ProcessEvents();
    return 0;
}
```

이 부분이 **스레드 동기화의 핵심 로직**이다.
`WaitForSingleObject`는 지정된 이벤트(`m_eventAvailable`)가 신호 상태가 될 때까지 대기한다.

* `WAIT_OBJECT_0`: 이벤트가 발생했음을 의미하므로, `ProcessEvents()`로 이벤트 큐를 처리한다.
* `WAIT_TIMEOUT`: 일정 시간 동안 이벤트가 없을 경우, `PerformPeriodicTasks()`로 주기적 작업을 수행한다.
* `WAIT_FAILED`: 오류 발생 시 스레드를 종료한다.

즉, 이 루프는 “**이벤트가 발생할 때만 깨어나는 효율적인 대기 구조**”를 구현한다.

#### 7. 이벤트 처리 과정

```cpp
void ProcessEvents() {
    std::lock_guard<std::mutex> lock(m_queueMutex);
    while (!m_eventQueue.empty()) {
        GameEvent event = m_eventQueue.front();
        m_eventQueue.pop();
        ProcessSingleEvent(event);
    }
}
```

이 함수는 큐에 쌓인 이벤트들을 모두 꺼내어 처리한다.
뮤텍스로 큐를 보호하여 스레드 안전성을 유지한다.

```cpp
void ProcessSingleEvent(const GameEvent& event) {
    auto elapsed = ...;
    std::cout << "[이벤트 처리] 플레이어 " << event.playerId 
              << " - " << event.eventType 
              << " (지연: " << elapsed << "ms)" << std::endl;
    
    if (event.eventType == "PLAYER_MOVE") HandlePlayerMove(event);
    else if (event.eventType == "PLAYER_ATTACK") HandlePlayerAttack(event);
    else if (event.eventType == "PLAYER_CHAT") HandlePlayerChat(event);
}
```

이 함수는 이벤트의 종류에 따라 **플레이어 이동, 공격, 채팅 등 실제 게임 로직을 호출**한다.
또한 이벤트가 발생한 시점과 처리 시점의 지연 시간을 계산하여 출력한다.

#### 8. 주기적 작업 수행

```cpp
void PerformPeriodicTasks() {
    static int taskCounter = 0;
    if (++taskCounter % 10 == 0) {
        std::cout << "[주기 작업] 시스템 상태 체크..." << std::endl;
    }
}
```

이 함수는 **이벤트가 없을 때 주기적으로 수행할 관리 작업**을 처리한다.
예를 들어 서버 상태 점검, 통계 갱신, 하트비트 전송 같은 작업이 여기에 들어간다.
`WaitForSingleObject`의 타임아웃(여기서는 1초)을 이용해 이런 주기적 처리를 자연스럽게 구현한다.


#### 9. 요약
이 예제는 **스레드 동기화의 대표적인 방식인 `WaitForSingleObject`를 활용한 이벤트 기반 처리 구조**를 보여준다.
핵심 포인트는 다음과 같다.

* `CreateEvent`로 이벤트 객체를 생성하고 `SetEvent`로 신호를 보낸다.
* `WaitForSingleObject`로 스레드가 효율적으로 이벤트를 기다린다.
* 스레드는 **이벤트가 발생할 때만 깨어나고**, 나머지 시간에는 대기 상태를 유지한다.
* 주기적 타임아웃을 통해 **하트비트나 백그라운드 작업을 병행**할 수 있다.

이 구조는 **게임 서버, 실시간 이벤트 처리기, 네트워크 메시지 큐** 등에서 널리 사용되는 기초적인 동기화 패턴이다.
학생들은 이 코드를 통해 **이벤트 기반 스레드 설계의 핵심 개념**을 명확히 이해할 수 있다.


</br>     

## 4.2 스레드 풀 활용 (ThreadPool API)
Windows Vista 이후부터 사용 가능한 스레드 풀 API는 더욱 효율적인 스레드 관리를 제공한다.

### 4.2.1 기본 스레드 풀 사용법

```cpp
#include <functional>
#include <random>

// 작업 항목 구조체
struct WorkItem {
    int taskId;
    std::string taskData;
    std::function<void(const WorkItem&)> callback;
    
    WorkItem(int id, const std::string& data) 
        : taskId(id), taskData(data) {}
};

class ThreadPoolManager {
private:
    PTP_POOL m_pool;
    PTP_CLEANUP_GROUP m_cleanupGroup;
    TP_CALLBACK_ENVIRON m_environ;
    std::atomic<int> m_completedTasks;
    std::atomic<int> m_totalTasks;
    
public:
    ThreadPoolManager() : m_pool(nullptr), m_cleanupGroup(nullptr), 
                          m_completedTasks(0), m_totalTasks(0) {
        InitializeThreadpoolEnvironment(&m_environ);
    }
    
    ~ThreadPoolManager() {
        Cleanup();
    }
    
    bool Initialize(DWORD minThreads = 2, DWORD maxThreads = 8) {
        // 스레드 풀 생성
        m_pool = CreateThreadpool(nullptr);
        if (m_pool == nullptr) {
            std::cout << "스레드 풀 생성 실패: " << GetLastError() << std::endl;
            return false;
        }
        
        // 스레드 수 설정
        SetThreadpoolThreadMinimum(m_pool, minThreads);
        SetThreadpoolThreadMaximum(m_pool, maxThreads);
        
        // 정리 그룹 생성
        m_cleanupGroup = CreateThreadpoolCleanupGroup();
        if (m_cleanupGroup == nullptr) {
            std::cout << "정리 그룹 생성 실패: " << GetLastError() << std::endl;
            CloseThreadpool(m_pool);
            m_pool = nullptr;
            return false;
        }
        
        // 환경 설정
        SetThreadpoolCallbackPool(&m_environ, m_pool);
        SetThreadpoolCallbackCleanupGroup(&m_environ, m_cleanupGroup, nullptr);
        
        std::cout << "스레드 풀 초기화 완료 (최소: " << minThreads 
                  << ", 최대: " << maxThreads << ")" << std::endl;
        
        /*
        ┌─────────────────────────────────────────┐
        │          Thread Pool Architecture       │
        ├─────────────────────────────────────────┤
        │                                         │
        │  ┌─────────────────────────────────┐    │
        │  │        Thread Pool             │    │
        │  │   ┌─────┐ ┌─────┐ ┌─────┐      │    │
        │  │   │ T1  │ │ T2  │ │ T3  │ ...  │    │
        │  │   └─────┘ └─────┘ └─────┘      │    │
        │  └─────────────────────────────────┘    │
        │                 │                       │
        │                 ▼                       │
        │  ┌─────────────────────────────────┐    │
        │  │         Work Queue              │    │
        │  │  [Task1] [Task2] [Task3] ...    │    │
        │  └─────────────────────────────────┘    │
        │                 │                       │
        │                 ▼                       │
        │  ┌─────────────────────────────────┐    │
        │  │      Cleanup Group              │    │
        │  │   (Resource Management)         │    │
        │  └─────────────────────────────────┘    │
        └─────────────────────────────────────────┘
        */
        
        return true;
    }
    
    bool SubmitWork(std::unique_ptr<WorkItem> workItem) {
        if (m_pool == nullptr) {
            return false;
        }
        
        // 작업 항목을 스레드 풀에 제출
        PTP_WORK work = CreateThreadpoolWork(WorkCallback, workItem.release(), &m_environ);
        if (work == nullptr) {
            std::cout << "작업 생성 실패: " << GetLastError() << std::endl;
            return false;
        }
        
        SubmitThreadpoolWork(work);
        m_totalTasks.fetch_add(1);
        
        return true;
    }
    
    bool SubmitTimer(DWORD delayMs, std::function<void()> timerCallback) {
        if (m_pool == nullptr) {
            return false;
        }
        
        // 타이머 콜백을 위한 래퍼 생성
        auto wrapper = new std::function<void()>(timerCallback);
        
        PTP_TIMER timer = CreateThreadpoolTimer(TimerCallback, wrapper, &m_environ);
        if (timer == nullptr) {
            delete wrapper;
            return false;
        }
        
        // 타이머 시작 (delayMs 후 한 번 실행)
        ULARGE_INTEGER dueTime;
        dueTime.QuadPart = -(static_cast<LONGLONG>(delayMs) * 10000); // 100ns 단위
        
        FILETIME ft;
        ft.dwLowDateTime = dueTime.LowPart;
        ft.dwHighDateTime = dueTime.HighPart;
        
        SetThreadpoolTimer(timer, &ft, 0, 0);
        
        return true;
    }
    
    void WaitForCompletion() {
        if (m_cleanupGroup != nullptr) {
            CloseThreadpoolCleanupGroupMembers(m_cleanupGroup, FALSE, nullptr);
        }
    }
    
    void GetStatistics(int& completed, int& total) {
        completed = m_completedTasks.load();
        total = m_totalTasks.load();
    }
    
private:
    static void CALLBACK WorkCallback(PTP_CALLBACK_INSTANCE instance, PVOID context, PTP_WORK work) {
        auto workItem = static_cast<WorkItem*>(context);
        auto manager = GetManagerFromWork(work);
        
        std::cout << "[작업 시작] Task " << workItem->taskId 
                  << " (스레드: " << GetCurrentThreadId() << ")" << std::endl;
        
        try {
            // 실제 작업 처리
            ProcessWorkItem(*workItem);
            
            // 콜백 호출 (있는 경우)
            if (workItem->callback) {
                workItem->callback(*workItem);
            }
        } catch (const std::exception& e) {
            std::cout << "작업 처리 중 예외 발생: " << e.what() << std::endl;
        }
        
        if (manager) {
            manager->m_completedTasks.fetch_add(1);
        }
        
        std::cout << "[작업 완료] Task " << workItem->taskId << std::endl;
        
        delete workItem;
        CloseThreadpoolWork(work);
    }
    
    static void CALLBACK TimerCallback(PTP_CALLBACK_INSTANCE instance, PVOID context, PTP_TIMER timer) {
        auto callback = static_cast<std::function<void()>*>(context);
        
        try {
            (*callback)();
        } catch (const std::exception& e) {
            std::cout << "타이머 콜백 실행 중 예외: " << e.what() << std::endl;
        }
        
        delete callback;
        CloseThreadpoolTimer(timer);
    }
    
    static void ProcessWorkItem(const WorkItem& item) {
        // 게임 서버 작업 시뮬레이션
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(100, 500);
        
        int processingTime = dis(gen);
        Sleep(processingTime);
        
        std::cout << "  → 작업 데이터 처리: " << item.taskData 
                  << " (처리 시간: " << processingTime << "ms)" << std::endl;
    }
    
    static ThreadPoolManager* GetManagerFromWork(PTP_WORK work) {
        // 실제 구현에서는 더 안전한 방법을 사용해야 함
        return nullptr;
    }
    
    void Cleanup() {
        if (m_cleanupGroup != nullptr) {
            CloseThreadpoolCleanupGroupMembers(m_cleanupGroup, FALSE, nullptr);
            CloseThreadpoolCleanupGroup(m_cleanupGroup);
            m_cleanupGroup = nullptr;
        }
        
        if (m_pool != nullptr) {
            CloseThreadpool(m_pool);
            m_pool = nullptr;
        }
        
        DestroyThreadpoolEnvironment(&m_environ);
    }
};

// 게임 서버용 작업 스케줄러
class GameTaskScheduler {
private:
    ThreadPoolManager m_threadPool;
    std::atomic<int> m_nextTaskId;
    
public:
    GameTaskScheduler() : m_nextTaskId(1) {}
    
    bool Initialize() {
        return m_threadPool.Initialize(4, 16);
    }
    
    void SchedulePlayerUpdate(int playerId, const std::string& updateData) {
        auto task = std::make_unique<WorkItem>(m_nextTaskId++, 
            "PlayerUpdate:" + std::to_string(playerId) + ":" + updateData);
        
        task->callback = [this](const WorkItem& item) {
            std::cout << "플레이어 업데이트 완료: " << item.taskData << std::endl;
        };
        
        m_threadPool.SubmitWork(std::move(task));
    }
    
    void ScheduleGameLogic() {
        auto task = std::make_unique<WorkItem>(m_nextTaskId++, "GameLogicUpdate");
        
        task->callback = [this](const WorkItem& item) {
            // 다음 게임 로직 업데이트 스케줄링 (60 FPS)
            m_threadPool.SubmitTimer(16, [this]() { ScheduleGameLogic(); });
        };
        
        m_threadPool.SubmitWork(std::move(task));
    }
    
    void ScheduleDatabaseOperation(const std::string& query) {
        auto task = std::make_unique<WorkItem>(m_nextTaskId++, "DB:" + query);
        
        task->callback = [](const WorkItem& item) {
            std::cout << "데이터베이스 작업 완료: " << item.taskData << std::endl;
        };
        
        m_threadPool.SubmitWork(std::move(task));
    }
    
    void WaitForAllTasks() {
        m_threadPool.WaitForCompletion();
    }
    
    void PrintStatistics() {
        int completed, total;
        m_threadPool.GetStatistics(completed, total);
        std::cout << "작업 통계 - 완료: " << completed << "/" << total << std::endl;
    }
};
```

### 4.2.2 I/O 컴플리션 포트와 스레드 풀 연동

```cpp
class IOCPThreadPoolIntegration {
private:
    HANDLE m_iocp;
    ThreadPoolManager m_threadPool;
    std::atomic<bool> m_running;
    std::vector<HANDLE> m_iocpThreads;
    
public:
    IOCPThreadPoolIntegration() : m_iocp(nullptr), m_running(false) {}
    
    ~IOCPThreadPoolIntegration() {
        Stop();
    }
    
    bool Start(int iocpThreads = 4) {
        // IOCP 생성
        m_iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, nullptr, 0, iocpThreads);
        if (m_iocp == nullptr) {
            return false;
        }
        
        // 스레드 풀 초기화
        if (!m_threadPool.Initialize()) {
            CloseHandle(m_iocp);
            m_iocp = nullptr;
            return false;
        }
        
        m_running = true;
        
        // IOCP 워커 스레드 생성
        for (int i = 0; i < iocpThreads; ++i) {
            HANDLE hThread = CreateThread(nullptr, 0, IOCPWorkerThread, this, 0, nullptr);
            if (hThread != nullptr) {
                m_iocpThreads.push_back(hThread);
            }
        }
        
        std::cout << "IOCP-ThreadPool 통합 시스템 시작" << std::endl;
        return true;
    }
    
    void Stop() {
        if (!m_running.load()) return;
        
        m_running = false;
        
        // IOCP 워커 스레드들에게 종료 신호
        for (size_t i = 0; i < m_iocpThreads.size(); ++i) {
            PostQueuedCompletionStatus(m_iocp, 0, 0, nullptr);
        }
        
        // 모든 IOCP 스레드 대기
        if (!m_iocpThreads.empty()) {
            WaitForMultipleObjects(
                static_cast<DWORD>(m_iocpThreads.size()),
                m_iocpThreads.data(),
                TRUE,
                5000
            );
        }
        
        // 리소스 정리
        for (HANDLE hThread : m_iocpThreads) {
            CloseHandle(hThread);
        }
        m_iocpThreads.clear();
        
        if (m_iocp != nullptr) {
            CloseHandle(m_iocp);
            m_iocp = nullptr;
        }
    }
    
private:
    static DWORD WINAPI IOCPWorkerThread(LPVOID lpParam) {
        auto integration = static_cast<IOCPThreadPoolIntegration*>(lpParam);
        return integration->IOCPWorkerLoop();
    }
    
    DWORD IOCPWorkerLoop() {
        std::cout << "IOCP 워커 스레드 시작 (TID: " << GetCurrentThreadId() << ")" << std::endl;
        
        while (m_running.load()) {
            DWORD bytesTransferred;
            ULONG_PTR completionKey;
            LPOVERLAPPED overlapped;
            
            BOOL result = GetQueuedCompletionStatus(
                m_iocp,
                &bytesTransferred,
                &completionKey,
                &overlapped,
                1000 // 1초 타임아웃
            );
            
            if (!result && overlapped == nullptr) {
                // 타임아웃 또는 종료 신호
                continue;
            }
            
            if (overlapped == nullptr && completionKey == 0) {
                // 종료 신호
                break;
            }
            
            // I/O 완료 처리를 스레드 풀에 위임
            auto task = std::make_unique<WorkItem>(
                static_cast<int>(completionKey),
                "IOCompletion:" + std::to_string(bytesTransferred)
            );
            
            task->callback = [this](const WorkItem& item) {
                ProcessIOCompletion(item);
            };
            
            m_threadPool.SubmitWork(std::move(task));
        }
        
        std::cout << "IOCP 워커 스레드 종료" << std::endl;
        return 0;
    }
    
    void ProcessIOCompletion(const WorkItem& item) {
        std::cout << "I/O 완료 처리: " << item.taskData 
                  << " (처리 스레드: " << GetCurrentThreadId() << ")" << std::endl;
        
        // 실제 네트워크 데이터 처리 로직
        // 예: 패킷 파싱, 게임 로직 실행 등
    }
};
```
    

</br>         

## 4.3 프로세스 간 통신 기초
게임 서버는 종종 여러 프로세스로 구성된다. 로그인 서버, 게임 서버, 데이터베이스 서버 등이 통신해야 한다.

### 4.3.1 명명된 파이프를 이용한 IPC

```cpp
#include <string>
#include <sstream>

// 게임 서버 간 메시지 구조체
struct InterServerMessage {
    DWORD messageType;
    DWORD dataSize;
    char data[1024];
    
    InterServerMessage(DWORD type = 0, const std::string& messageData = "") 
        : messageType(type), dataSize(0) {
        if (!messageData.empty() && messageData.size() < sizeof(data)) {
            strcpy_s(data, sizeof(data), messageData.c_str());
            dataSize = static_cast<DWORD>(messageData.size());
        }
    }
};

// 메시지 타입 정의
enum class MessageType : DWORD {
    PLAYER_LOGIN = 1,
    PLAYER_LOGOUT = 2,
    PLAYER_MOVE = 3,
    SERVER_STATUS = 4,
    SHUTDOWN = 5
};

class NamedPipeServer {
private:
    std::wstring m_pipeName;
    HANDLE m_pipe;
    std::atomic<bool> m_running;
    std::thread m_serverThread;
    
public:
    NamedPipeServer(const std::wstring& pipeName) 
        : m_pipeName(pipeName), m_pipe(INVALID_HANDLE_VALUE), m_running(false) {}
    
    ~NamedPipeServer() {
        Stop();
    }
    
    bool Start() {
        if (m_running.load()) return false;
        
        m_running = true;
        m_serverThread = std::thread([this]() { ServerThread(); });
        
        std::wcout << L"명명된 파이프 서버 시작: " << m_pipeName << std::endl;
        return true;
    }
    
    void Stop() {
        if (!m_running.load()) return;
        
        m_running = false;
        
        // 파이프 닫기
        if (m_pipe != INVALID_HANDLE_VALUE) {
            CloseHandle(m_pipe);
            m_pipe = INVALID_HANDLE_VALUE;
        }
        
        if (m_serverThread.joinable()) {
            m_serverThread.join();
        }
        
        std::wcout << L"명명된 파이프 서버 중지" << std::endl;
    }
    
private:
    void ServerThread() {
        /*
        ┌─────────────────────────────────────────┐
        │         Named Pipe Server Flow          │
        ├─────────────────────────────────────────┤
        │                                         │
        │  ┌─────────────────────────────────┐    │
        │  │      Create Named Pipe          │    │
        │  └──────────────┬──────────────────┘    │
        │                 │                       │
        │                 ▼                       │
        │  ┌─────────────────────────────────┐    │
        │  │    Wait for Client Connection   │    │
        │  └──────────────┬──────────────────┘    │
        │                 │                       │
        │                 ▼                       │
        │  ┌─────────────────────────────────┐    │
        │  │     Process Client Messages     │    │
        │  └──────────────┬──────────────────┘    │
        │                 │                       │
        │                 ▼                       │
        │  ┌─────────────────────────────────┐    │
        │  │      Disconnect & Cleanup       │    │
        │  └─────────────────────────────────┘    │
        └─────────────────────────────────────────┘
        */
        
        while (m_running.load()) {
            // 명명된 파이프 생성
            m_pipe = CreateNamedPipeW(
                m_pipeName.c_str(),
                PIPE_ACCESS_DUPLEX,
                PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
                1,                          // 최대 인스턴스 수
                sizeof(InterServerMessage), // 출력 버퍼 크기
                sizeof(InterServerMessage), // 입력 버퍼 크기
                0,                          // 기본 타임아웃
                nullptr                     // 보안 속성
            );
            
            if (m_pipe == INVALID_HANDLE_VALUE) {
                std::wcout << L"파이프 생성 실패: " << GetLastError() << std::endl;
                break;
            }
            
            // 클라이언트 연결 대기
            if (ConnectNamedPipe(m_pipe, nullptr) || GetLastError() == ERROR_PIPE_CONNECTED) {
                std::wcout << L"클라이언트 연결됨" << std::endl;
                HandleClient();
            }
            
            DisconnectNamedPipe(m_pipe);
            CloseHandle(m_pipe);
            m_pipe = INVALID_HANDLE_VALUE;
        }
    }
    
    void HandleClient() {
        InterServerMessage message;
        DWORD bytesRead;
        
        while (m_running.load()) {
            // 메시지 읽기
            if (!ReadFile(m_pipe, &message, sizeof(message), &bytesRead, nullptr)) {
                DWORD error = GetLastError();
                if (error == ERROR_BROKEN_PIPE) {
                    std::wcout << L"클라이언트 연결 끊어짐" << std::endl;
                } else {
                    std::wcout << L"메시지 읽기 실패: " << error << std::endl;
                }
                break;
            }
            
            // 메시지 처리
            ProcessMessage(message);
            
            // 응답 전송
            InterServerMessage response = CreateResponse(message);
            DWORD bytesWritten;
            WriteFile(m_pipe, &response, sizeof(response), &bytesWritten, nullptr);
        }
    }
    
    void ProcessMessage(const InterServerMessage& message) {
        MessageType msgType = static_cast<MessageType>(message.messageType);
        
        switch (msgType) {
            case MessageType::PLAYER_LOGIN:
                std::cout << "플레이어 로그인: " << message.data << std::endl;
                break;
                
            case MessageType::PLAYER_LOGOUT:
                std::cout << "플레이어 로그아웃: " << message.data << std::endl;
                break;
                
            case MessageType::PLAYER_MOVE:
                std::cout << "플레이어 이동: " << message.data << std::endl;
                break;
                
            case MessageType::SERVER_STATUS:
                std::cout << "서버 상태 요청" << std::endl;
                break;
                
            case MessageType::SHUTDOWN:
                std::cout << "종료 요청 받음" << std::endl;
                m_running = false;
                break;
                
            default:
                std::cout << "알 수 없는 메시지 타입: " << message.messageType << std::endl;
                break;
        }
    }
    
    InterServerMessage CreateResponse(const InterServerMessage& request) {
        MessageType msgType = static_cast<MessageType>(request.messageType);
        
        switch (msgType) {
            case MessageType::SERVER_STATUS:
                return InterServerMessage(static_cast<DWORD>(msgType), 
                    "Server OK - Players: 150, CPU: 45%");
                
            default:
                return InterServerMessage(static_cast<DWORD>(msgType), "ACK");
        }
    }
};

class NamedPipeClient {
private:
    std::wstring m_pipeName;
    HANDLE m_pipe;
    
public:
    NamedPipeClient(const std::wstring& pipeName) 
        : m_pipeName(pipeName), m_pipe(INVALID_HANDLE_VALUE) {}
    
    ~NamedPipeClient() {
        Disconnect();
    }
    
    bool Connect(DWORD timeoutMs = 5000) {
        // 파이프 서버 대기
        if (!WaitNamedPipeW(m_pipeName.c_str(), timeoutMs)) {
            std::wcout << L"파이프 서버 대기 실패: " << GetLastError() << std::endl;
            return false;
        }
        
        // 파이프에 연결
        m_pipe = CreateFileW(
            m_pipeName.c_str(),
            GENERIC_READ | GENERIC_WRITE,
            0,
            nullptr,
            OPEN_EXISTING,
            0,
            nullptr
        );
        
        if (m_pipe == INVALID_HANDLE_VALUE) {
            std::wcout << L"파이프 연결 실패: " << GetLastError() << std::endl;
            return false;
        }
        
        // 메시지 모드 설정
        DWORD mode = PIPE_READMODE_MESSAGE;
        SetNamedPipeHandleState(m_pipe, &mode, nullptr, nullptr);
        
        std::wcout << L"파이프 서버에 연결됨" << std::endl;
        return true;
    }
    
    void Disconnect() {
        if (m_pipe != INVALID_HANDLE_VALUE) {
            CloseHandle(m_pipe);
            m_pipe = INVALID_HANDLE_VALUE;
        }
    }
    
    bool SendMessage(const InterServerMessage& message, InterServerMessage* response = nullptr) {
        if (m_pipe == INVALID_HANDLE_VALUE) {
            return false;
        }
        
        // 메시지 전송
        DWORD bytesWritten;
        if (!WriteFile(m_pipe, &message, sizeof(message), &bytesWritten, nullptr)) {
            std::wcout << L"메시지 전송 실패: " << GetLastError() << std::endl;
            return false;
        }
        
        // 응답 받기 (옵션)
        if (response != nullptr) {
            DWORD bytesRead;
            if (!ReadFile(m_pipe, response, sizeof(*response), &bytesRead, nullptr)) {
                std::wcout << L"응답 읽기 실패: " << GetLastError() << std::endl;
                return false;
            }
        }
        
        return true;
    }
};
```  
   
이번 예제는 **서로 다른 프로세스 간 데이터를 주고받는 방법**, 즉 **IPC(Inter-Process Communication, 프로세스 간 통신)** 중 하나인 **명명된 파이프(Named Pipe)** 를 이용하는 방법을 설명한다.
게임 서버나 백엔드 시스템에서는 **다른 서버나 관리 툴 간 메시지를 교환해야 하는 경우**가 많다.
예를 들어, **게임 서버와 모니터링 툴이 통신하여 서버 상태를 조회하거나**, **게이트웨이 서버와 게임 존 서버가 플레이어 데이터를 주고받는 상황** 등이 있다.
이때 “명명된 파이프”는 **운영체제에서 제공하는 안정적인 통신 채널**로, **TCP/IP를 사용하지 않고도 프로세스 간 데이터를 교환할 수 있는 간단한 방법**이다.

#### 1. InterServerMessage 구조체 — 서버 간 메시지 정의

```cpp
struct InterServerMessage {
    DWORD messageType;
    DWORD dataSize;
    char data[1024];
    
    InterServerMessage(DWORD type = 0, const std::string& messageData = "") 
        : messageType(type), dataSize(0) {
        if (!messageData.empty() && messageData.size() < sizeof(data)) {
            strcpy_s(data, sizeof(data), messageData.c_str());
            dataSize = static_cast<DWORD>(messageData.size());
        }
    }
};
```

이 구조체는 서버 간 주고받는 **기본 메시지 형식**을 정의한다.

* `messageType`: 메시지의 종류를 구분하기 위한 코드이다.
* `dataSize`: 데이터의 실제 길이이다.
* `data`: 전송할 문자열 또는 데이터 버퍼이다.

예를 들어 `PLAYER_LOGIN`, `SERVER_STATUS` 같은 메시지 타입이 정의될 수 있다.
생성자에서는 문자열 데이터의 길이를 확인한 뒤, 안전하게 복사(`strcpy_s`)한다.


#### 2. 메시지 타입 정의 — 서버 간 명령 구분

```cpp
enum class MessageType : DWORD {
    PLAYER_LOGIN = 1,
    PLAYER_LOGOUT = 2,
    PLAYER_MOVE = 3,
    SERVER_STATUS = 4,
    SHUTDOWN = 5
};
```

이 열거형은 서버 간 주고받을 명령의 종류를 정의한다.
각 타입은 `InterServerMessage`의 `messageType` 필드와 연결된다.
예를 들어 클라이언트가 `PLAYER_LOGIN` 메시지를 보내면 서버는 로그인 처리 로직을 수행한다.


#### 3. NamedPipeServer 클래스 — 파이프 서버 구현
명명된 파이프 서버는 **하나의 프로세스가 파이프를 생성하고, 다른 프로세스의 연결 요청을 받아들이는 역할**을 한다.

##### (1) 기본 구성

```cpp
class NamedPipeServer {
private:
    std::wstring m_pipeName;
    HANDLE m_pipe;
    std::atomic<bool> m_running;
    std::thread m_serverThread;
```

* `m_pipeName`: 파이프의 이름. 클라이언트는 이 이름을 이용해 서버에 연결한다.
* `m_pipe`: 실제 파이프 핸들이다.
* `m_running`: 서버 실행 여부를 제어하는 플래그이다.
* `m_serverThread`: 서버의 메인 루프를 실행하는 스레드이다.

##### (2) 서버 시작과 종료

```cpp
bool Start() {
    m_running = true;
    m_serverThread = std::thread([this]() { ServerThread(); });
}
```

`Start()`는 별도의 스레드에서 서버 루프(`ServerThread`)를 실행한다.
이 스레드는 파이프를 생성하고 클라이언트 연결을 기다리며 메시지를 처리한다.

```cpp
void Stop() {
    m_running = false;
    if (m_pipe != INVALID_HANDLE_VALUE) CloseHandle(m_pipe);
    if (m_serverThread.joinable()) m_serverThread.join();
}
```

`Stop()`은 서버 실행을 중단하고 파이프와 스레드를 정리한다.


#### 4. ServerThread — 파이프 서버의 동작 흐름

```cpp
m_pipe = CreateNamedPipeW(
    m_pipeName.c_str(),
    PIPE_ACCESS_DUPLEX,
    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
    1, sizeof(InterServerMessage), sizeof(InterServerMessage), 0, nullptr
);
```

`CreateNamedPipeW` 함수는 **양방향(duplex)** 통신이 가능한 명명된 파이프를 생성한다.

* `PIPE_ACCESS_DUPLEX`: 읽기와 쓰기가 모두 가능하다.
* `PIPE_TYPE_MESSAGE`: 메시지 단위로 통신한다.
* `PIPE_WAIT`: 동기 모드로 동작한다.

```cpp
if (ConnectNamedPipe(m_pipe, nullptr) || GetLastError() == ERROR_PIPE_CONNECTED) {
    std::wcout << L"클라이언트 연결됨" << std::endl;
    HandleClient();
}
```

`ConnectNamedPipe`는 **클라이언트의 연결을 기다리는 부분**이다.
연결이 성공하면 `HandleClient()`를 호출해 메시지를 주고받는다.


#### 5. HandleClient — 메시지 수신과 응답 처리

```cpp
if (!ReadFile(m_pipe, &message, sizeof(message), &bytesRead, nullptr)) {
    DWORD error = GetLastError();
    if (error == ERROR_BROKEN_PIPE) {
        std::wcout << L"클라이언트 연결 끊어짐" << std::endl;
    }
    break;
}
```

`ReadFile`을 통해 클라이언트가 보낸 메시지를 읽는다.

* 클라이언트가 연결을 끊으면 `ERROR_BROKEN_PIPE` 오류가 발생한다.
* 읽은 메시지는 `ProcessMessage()` 함수에서 처리된다.

```cpp
InterServerMessage response = CreateResponse(message);
WriteFile(m_pipe, &response, sizeof(response), &bytesWritten, nullptr);
```

처리 후 서버는 클라이언트에게 **응답 메시지**를 다시 전송한다.

#### 6. 메시지 처리 — ProcessMessage 함수

```cpp
void ProcessMessage(const InterServerMessage& message) {
    switch (static_cast<MessageType>(message.messageType)) {
        case MessageType::PLAYER_LOGIN:
            std::cout << "플레이어 로그인: " << message.data << std::endl;
            break;
        case MessageType::SERVER_STATUS:
            std::cout << "서버 상태 요청" << std::endl;
            break;
        case MessageType::SHUTDOWN:
            std::cout << "종료 요청 받음" << std::endl;
            m_running = false;
            break;
    }
}
```

이 함수는 메시지 타입에 따라 **다른 행동을 수행**한다.
예를 들어 `PLAYER_LOGIN`이면 로그인 로그를 남기고, `SHUTDOWN`이면 서버를 종료시킨다.

응답은 `CreateResponse()` 함수에서 생성한다.

#### 7. CreateResponse — 서버 응답 메시지 생성

```cpp
InterServerMessage CreateResponse(const InterServerMessage& request) {
    if (request.messageType == static_cast<DWORD>(MessageType::SERVER_STATUS)) {
        return InterServerMessage(static_cast<DWORD>(MessageType::SERVER_STATUS),
            "Server OK - Players: 150, CPU: 45%");
    }
    return InterServerMessage(request.messageType, "ACK");
}
```

서버 상태 요청에 대해서는 서버의 현재 상태를 문자열로 응답하고,
그 외의 메시지에는 단순히 `"ACK"`(수신 확인) 메시지를 돌려준다.

#### 8. NamedPipeClient 클래스 — 클라이언트 구현
명명된 파이프 클라이언트는 **서버가 만들어 둔 파이프에 연결하여 메시지를 전송하는 역할**을 한다.

##### (1) 서버 연결

```cpp
if (!WaitNamedPipeW(m_pipeName.c_str(), timeoutMs)) {
    std::wcout << L"파이프 서버 대기 실패" << std::endl;
    return false;
}

m_pipe = CreateFileW(m_pipeName.c_str(), GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, nullptr);
```

* `WaitNamedPipeW`: 지정된 이름의 파이프가 준비될 때까지 대기한다.
* `CreateFileW`: 파이프 서버에 실제로 연결한다.

연결 후에는 메시지 모드를 설정한다.

```cpp
DWORD mode = PIPE_READMODE_MESSAGE;
SetNamedPipeHandleState(m_pipe, &mode, nullptr, nullptr);
```

##### (2) 메시지 전송과 응답 수신

```cpp
bool SendMessage(const InterServerMessage& message, InterServerMessage* response = nullptr) {
    WriteFile(m_pipe, &message, sizeof(message), &bytesWritten, nullptr);
    if (response != nullptr) {
        ReadFile(m_pipe, response, sizeof(*response), &bytesRead, nullptr);
    }
}
```

`WriteFile`을 이용해 메시지를 서버로 보낸다.
서버가 응답을 보낼 경우, `ReadFile`로 수신한다.


#### 9. 전체 동작 흐름 요약
이 예제의 전체 흐름은 다음과 같다.

```
┌──────────────────────────────────────┐
│        Named Pipe IPC Flow           │
├──────────────────────────────────────┤
│ 1. 서버: CreateNamedPipe             │
│ 2. 클라이언트: WaitNamedPipe & Connect│
│ 3. 서버: ConnectNamedPipe → 연결 수락 │
│ 4. 클라이언트 → 서버 : 메시지 전송   │
│ 5. 서버 → 클라이언트 : 응답 전송     │
│ 6. 연결 종료 및 자원 정리            │
└──────────────────────────────────────┘
```

#### 10. 마무리
이 코드는 **명명된 파이프를 이용한 기본적인 IPC 구조**를 명확하게 보여준다.
핵심 포인트는 다음과 같다.

* `CreateNamedPipe`로 서버 파이프 생성
* `ConnectNamedPipe`로 클라이언트 연결 대기
* `ReadFile` / `WriteFile`을 통한 메시지 교환
* `WaitNamedPipe` + `CreateFile`로 클라이언트 연결
* 양방향 통신이 가능하므로 요청-응답 구조를 쉽게 구성 가능

이 구조는 **같은 컴퓨터 내의 프로세스 간 통신**에 매우 효율적이며,
게임 서버 간 상태 공유나 모니터링 시스템 구축 시에도 활용할 수 있다.
학생들은 이 코드를 통해 **운영체제 수준의 IPC 구조와 동작 원리**를 이해할 수 있다.


### 4.3.2 공유 메모리를 이용한 고성능 IPC

```cpp
template<typename T>
class SharedMemoryManager {
private:
    std::wstring m_name;
    HANDLE m_fileMapping;
    T* m_data;
    HANDLE m_mutex;
    size_t m_size;
    
public:
    SharedMemoryManager(const std::wstring& name, size_t elementCount = 1) 
        : m_name(name), m_fileMapping(nullptr), m_data(nullptr), 
          m_mutex(nullptr), m_size(sizeof(T) * elementCount) {}
    
    ~SharedMemoryManager() {
        Cleanup();
    }
    
    bool Create() {
        // 파일 매핑 생성
        m_fileMapping = CreateFileMappingW(
            INVALID_HANDLE_VALUE,
            nullptr,
            PAGE_READWRITE,
            0,
            static_cast<DWORD>(m_size),
            m_name.c_str()
        );
        
        if (m_fileMapping == nullptr) {
            std::wcout << L"파일 매핑 생성 실패: " << GetLastError() << std::endl;
            return false;
        }
        
        // 메모리 매핑
        m_data = static_cast<T*>(MapViewOfFile(
            m_fileMapping,
            FILE_MAP_ALL_ACCESS,
            0, 0, 0
        ));
        
        if (m_data == nullptr) {
            std::wcout << L"메모리 매핑 실패: " << GetLastError() << std::endl;
            CloseHandle(m_fileMapping);
            m_fileMapping = nullptr;
            return false;
        }
        
        // 동기화 뮤텍스 생성
        std::wstring mutexName = m_name + L"_Mutex";
        m_mutex = CreateMutexW(nullptr, FALSE, mutexName.c_str());
        
        // 메모리 초기화 (새로 생성된 경우만)
        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            memset(m_data, 0, m_size);
            std::wcout << L"새로운 공유 메모리 생성: " << m_name << std::endl;
        } else {
            std::wcout << L"기존 공유 메모리에 연결: " << m_name << std::endl;
        }
        
        return true;
    }
    
    bool Open() {
        // 기존 파일 매핑 열기
        m_fileMapping = OpenFileMappingW(
            FILE_MAP_ALL_ACCESS,
            FALSE,
            m_name.c_str()
        );
        
        if (m_fileMapping == nullptr) {
            std::wcout << L"파일 매핑 열기 실패: " << GetLastError() << std::endl;
            return false;
        }
        
        // 메모리 매핑
        m_data = static_cast<T*>(MapViewOfFile(
            m_fileMapping,
            FILE_MAP_ALL_ACCESS,
            0, 0, 0
        ));
        
        if (m_data == nullptr) {
            std::wcout << L"메모리 매핑 실패: " << GetLastError() << std::endl;
            CloseHandle(m_fileMapping);
            m_fileMapping = nullptr;
            return false;
        }
        
        // 동기화 뮤텍스 열기
        std::wstring mutexName = m_name + L"_Mutex";
        m_mutex = OpenMutexW(MUTEX_ALL_ACCESS, FALSE, mutexName.c_str());
        
        std::wcout << L"공유 메모리 연결 완료: " << m_name << std::endl;
        return true;
    }
    
    template<typename Func>
    bool AccessData(Func&& func, DWORD timeoutMs = 5000) {
        if (m_data == nullptr || m_mutex == nullptr) {
            return false;
        }
        
        // 뮤텍스 잠금
        DWORD waitResult = WaitForSingleObject(m_mutex, timeoutMs);
        if (waitResult != WAIT_OBJECT_0) {
            std::wcout << L"뮤텍스 잠금 실패: " << waitResult << std::endl;
            return false;
        }
        
        try {
            // 사용자 함수 호출
            func(m_data);
        } catch (...) {
            ReleaseMutex(m_mutex);
            throw;
        }
        
        ReleaseMutex(m_mutex);
        return true;
    }
    
    T* GetData() { return m_data; }
    
private:
    void Cleanup() {
        if (m_data != nullptr) {
            UnmapViewOfFile(m_data);
            m_data = nullptr;
        }
        
        if (m_fileMapping != nullptr) {
            CloseHandle(m_fileMapping);
            m_fileMapping = nullptr;
        }
        
        if (m_mutex != nullptr) {
            CloseHandle(m_mutex);
            m_mutex = nullptr;
        }
    }
};

// 게임 서버 상태 정보 구조체
struct GameServerStatus {
    DWORD playerCount;
    DWORD maxPlayers;
    float cpuUsage;
    ULONGLONG memoryUsage;
    SYSTEMTIME lastUpdate;
    char serverName[64];
    bool isRunning;
    
    GameServerStatus() {
        memset(this, 0, sizeof(*this));
        isRunning = false;
    }
};

class GameServerMonitor {
private:
    SharedMemoryManager<GameServerStatus> m_sharedStatus;
    std::thread m_updateThread;
    std::atomic<bool> m_running;
    
public:
    GameServerMonitor() : m_sharedStatus(L"GameServerStatus"), m_running(false) {}
    
    bool StartAsServer(const std::string& serverName) {
        if (!m_sharedStatus.Create()) {
            return false;
        }
        
        // 초기 상태 설정
        m_sharedStatus.AccessData([&serverName](GameServerStatus* status) {
            strcpy_s(status->serverName, sizeof(status->serverName), serverName.c_str());
            status->isRunning = true;
            status->maxPlayers = 1000;
            GetSystemTime(&status->lastUpdate);
        });
        
        m_running = true;
        m_updateThread = std::thread([this]() { UpdateLoop(); });
        
        std::cout << "게임 서버 모니터 시작 (서버 모드)" << std::endl;
        return true;
    }
    
    bool StartAsClient() {
        if (!m_sharedStatus.Open()) {
            return false;
        }
        
        std::cout << "게임 서버 모니터 시작 (클라이언트 모드)" << std::endl;
        return true;
    }
    
    void Stop() {
        if (!m_running.load()) return;
        
        m_running = false;
        
        if (m_updateThread.joinable()) {
            m_updateThread.join();
        }
        
        // 서버 종료 상태 업데이트
        m_sharedStatus.AccessData([](GameServerStatus* status) {
            status->isRunning = false;
        });
    }
    
    void PrintStatus() {
        m_sharedStatus.AccessData([](GameServerStatus* status) {
            std::cout << "\n=== 게임 서버 상태 ===" << std::endl;
            std::cout << "서버명: " << status->serverName << std::endl;
            std::cout << "실행 상태: " << (status->isRunning ? "실행중" : "중지됨") << std::endl;
            std::cout << "플레이어: " << status->playerCount << "/" << status->maxPlayers << std::endl;
            std::cout << "CPU 사용률: " << status->cpuUsage << "%" << std::endl;
            std::cout << "메모리 사용량: " << status->memoryUsage / (1024*1024) << " MB" << std::endl;
            std::cout << "마지막 업데이트: " 
                      << status->lastUpdate.wHour << ":" 
                      << status->lastUpdate.wMinute << ":" 
                      << status->lastUpdate.wSecond << std::endl;
        });
    }
    
    void UpdatePlayerCount(DWORD newCount) {
        m_sharedStatus.AccessData([newCount](GameServerStatus* status) {
            status->playerCount = newCount;
            GetSystemTime(&status->lastUpdate);
        });
    }
    
private:
    void UpdateLoop() {
        /*
        ┌─────────────────────────────────────────┐
        │        Shared Memory Monitoring         │
        ├─────────────────────────────────────────┤
        │                                         │
        │  ┌─────────────────────────────────┐    │
        │  │     Collect System Info         │    │
        │  │   - CPU Usage                   │    │
        │  │   - Memory Usage                │    │
        │  │   - Player Count                │    │
        │  └──────────────┬──────────────────┘    │
        │                 │                       │
        │                 ▼                       │
        │  ┌─────────────────────────────────┐    │
        │  │   Update Shared Memory          │    │
        │  │   (Thread-Safe Access)          │    │
        │  └──────────────┬──────────────────┘    │
        │                 │                       │
        │                 ▼                       │
        │  ┌─────────────────────────────────┐    │
        │  │      Wait for Next Update       │    │
        │  │       (1 second interval)       │    │
        │  └─────────────────────────────────┘    │
        └─────────────────────────────────────────┘
        */
        
        while (m_running.load()) {
            // 시스템 정보 수집
            float cpuUsage = GetCPUUsage();
            ULONGLONG memoryUsage = GetMemoryUsage();
            
            // 공유 메모리 업데이트
            m_sharedStatus.AccessData([cpuUsage, memoryUsage](GameServerStatus* status) {
                status->cpuUsage = cpuUsage;
                status->memoryUsage = memoryUsage;
                GetSystemTime(&status->lastUpdate);
            });
            
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }
    
    float GetCPUUsage() {
        // 실제 CPU 사용률 계산 (시뮬레이션)
        static std::random_device rd;
        static std::mt19937 gen(rd());
        static std::uniform_real_distribution<float> dis(10.0f, 80.0f);
        
        return dis(gen);
    }
    
    ULONGLONG GetMemoryUsage() {
        PROCESS_MEMORY_COUNTERS pmc;
        if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc))) {
            return pmc.WorkingSetSize;
        }
        return 0;
    }
};
```
    
이번 예제는 **공유 메모리(Shared Memory)** 를 이용한 **프로세스 간 통신(IPC, Inter-Process Communication)** 방법을 다룬다.
앞서 살펴본 **명명된 파이프(Named Pipe)** 가 요청과 응답이 순차적으로 이루어지는 메시지 기반 구조라면,
**공유 메모리 방식은 여러 프로세스가 동일한 메모리 공간을 직접 공유**하여 **매우 빠른 데이터 교환**이 가능하다는 특징이 있다.

게임 서버 환경에서는 서버 모듈 간의 상태 공유(예: 모니터링 시스템, 부하 분석기, 로깅 서버 등)에 자주 사용된다.
이 코드는 **서버 프로세스가 주기적으로 공유 메모리에 상태를 기록하고**,
**클라이언트 프로세스가 이 메모리에서 실시간으로 읽어오는 구조**를 보여준다.


#### 1. SharedMemoryManager 클래스 — 공유 메모리의 생성과 접근 관리
이 클래스는 **공유 메모리의 생성, 열기, 접근, 동기화**를 모두 담당한다.
템플릿으로 설계되어 있기 때문에 `T`형 데이터를 어떤 구조체로 지정하든 그대로 사용할 수 있다.

##### (1) 기본 구성

```cpp
template<typename T>
class SharedMemoryManager {
private:
    std::wstring m_name;
    HANDLE m_fileMapping;
    T* m_data;
    HANDLE m_mutex;
    size_t m_size;
```

* `m_name`: 공유 메모리의 이름이다. 프로세스 간 식별을 위해 이름이 동일해야 한다.
* `m_fileMapping`: 실제 공유 메모리를 가리키는 파일 매핑 객체 핸들이다.
* `m_data`: 매핑된 메모리의 포인터로, 여기서 실제 데이터를 읽고 쓴다.
* `m_mutex`: 여러 프로세스가 동시에 접근하지 않도록 보호하는 동기화 도구이다.
* `m_size`: 공유 메모리의 크기(바이트 단위)이다.

##### (2) Create — 새로운 공유 메모리 생성

```cpp
m_fileMapping = CreateFileMappingW(
    INVALID_HANDLE_VALUE,
    nullptr,
    PAGE_READWRITE,
    0,
    static_cast<DWORD>(m_size),
    m_name.c_str()
);
```

`CreateFileMappingW`는 **파일이 아닌 메모리 기반의 파일 매핑 객체를 생성**한다.
여기서 `INVALID_HANDLE_VALUE`를 사용했기 때문에 실제 파일 없이 **순수한 메모리 공유 영역**을 만든다.

```cpp
m_data = static_cast<T*>(MapViewOfFile(m_fileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0));
```

이 부분은 매핑된 메모리를 현재 프로세스 주소 공간에 연결하여,
`m_data` 포인터를 통해 구조체처럼 접근할 수 있게 한다.

```cpp
m_mutex = CreateMutexW(nullptr, FALSE, mutexName.c_str());
```

공유 메모리를 여러 프로세스가 동시에 쓰지 않도록 **뮤텍스(Mutex)** 를 생성한다.
뮤텍스는 이름이 `_Mutex`로 끝나는 별도 시스템 객체로 만들어진다.

##### (3) Open — 기존 공유 메모리 열기

```cpp
m_fileMapping = OpenFileMappingW(FILE_MAP_ALL_ACCESS, FALSE, m_name.c_str());
m_data = static_cast<T*>(MapViewOfFile(m_fileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0));
m_mutex = OpenMutexW(MUTEX_ALL_ACCESS, FALSE, mutexName.c_str());
```

다른 프로세스(예: 모니터링 프로그램)는 이미 생성된 공유 메모리에 접근하기 위해 `OpenFileMappingW`를 사용한다.
즉, **서버가 `Create()`로 만든 공유 메모리에 클라이언트가 `Open()`으로 연결**한다.

##### (4) AccessData — 안전한 데이터 접근

```cpp
template<typename Func>
bool AccessData(Func&& func, DWORD timeoutMs = 5000) {
    DWORD waitResult = WaitForSingleObject(m_mutex, timeoutMs);
    func(m_data);
    ReleaseMutex(m_mutex);
}
```

이 함수는 내부적으로 **뮤텍스를 잠그고 사용자가 전달한 함수(func)를 실행**한 뒤,
작업이 끝나면 다시 뮤텍스를 해제한다.
이 방식은 **데이터 접근을 안전하게 보호하면서 코드의 가독성도 높인다.**

#### 2. GameServerStatus 구조체 — 공유되는 데이터 정의

```cpp
struct GameServerStatus {
    DWORD playerCount;
    DWORD maxPlayers;
    float cpuUsage;
    ULONGLONG memoryUsage;
    SYSTEMTIME lastUpdate;
    char serverName[64];
    bool isRunning;
};
```

이 구조체는 **게임 서버의 상태 정보를 표현하는 데이터 묶음**이다.
공유 메모리를 통해 서버와 모니터링 클라이언트가 이 구조체를 함께 참조한다.

포함된 정보는 다음과 같다.

* `playerCount`: 현재 접속 중인 플레이어 수
* `maxPlayers`: 최대 허용 플레이어 수
* `cpuUsage`: CPU 사용률(%)
* `memoryUsage`: 메모리 사용량
* `lastUpdate`: 마지막 업데이트 시간
* `serverName`: 서버 이름
* `isRunning`: 서버 실행 여부

#### 3. GameServerMonitor 클래스 — 서버와 클라이언트의 역할
이 클래스는 공유 메모리를 활용하여 **서버 상태를 갱신하거나 읽어오는 역할**을 한다.
즉, 하나의 프로그램이 “서버 모드”로 실행될 수도 있고,
다른 하나가 “클라이언트 모드”로 실행되어 서버의 상태를 모니터링할 수도 있다.

##### (1) 서버 모드 시작

```cpp
bool StartAsServer(const std::string& serverName) {
    m_sharedStatus.Create();
    m_sharedStatus.AccessData([&serverName](GameServerStatus* status) {
        strcpy_s(status->serverName, sizeof(status->serverName), serverName.c_str());
        status->isRunning = true;
        status->maxPlayers = 1000;
        GetSystemTime(&status->lastUpdate);
    });
    m_updateThread = std::thread([this]() { UpdateLoop(); });
}
```

서버 모드에서는 먼저 공유 메모리를 생성하고,
기본 서버 상태(이름, 최대 인원 등)를 설정한 뒤 **`UpdateLoop()` 스레드를 시작**한다.
이 스레드는 주기적으로 CPU/메모리 정보를 수집해 공유 메모리에 갱신한다.

##### (2) 클라이언트 모드 시작

```cpp
bool StartAsClient() {
    m_sharedStatus.Open();
}
```

클라이언트 모드는 기존에 만들어진 공유 메모리에 접근하여 데이터를 읽는다.
이 과정에서 별도의 네트워크 연결 없이도 **실시간 서버 상태를 확인할 수 있다.**

##### (3) 서버 상태 업데이트 루프

```cpp
void UpdateLoop() {
    while (m_running.load()) {
        float cpuUsage = GetCPUUsage();
        ULONGLONG memoryUsage = GetMemoryUsage();
        m_sharedStatus.AccessData([cpuUsage, memoryUsage](GameServerStatus* status) {
            status->cpuUsage = cpuUsage;
            status->memoryUsage = memoryUsage;
            GetSystemTime(&status->lastUpdate);
        });
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
```

이 루프는 1초마다 다음과 같은 작업을 반복한다.

1. CPU 사용률과 메모리 사용량을 측정한다.
2. 뮤텍스를 잠그고 공유 메모리에 값을 갱신한다.
3. 타임스탬프(`lastUpdate`)를 현재 시간으로 갱신한다.

이 과정을 통해 다른 프로세스(모니터링 툴)는 언제든 최신 상태를 읽을 수 있다.

##### (4) 서버 상태 출력

```cpp
void PrintStatus() {
    m_sharedStatus.AccessData([](GameServerStatus* status) {
        std::cout << "서버명: " << status->serverName << std::endl;
        std::cout << "플레이어: " << status->playerCount << "/" << status->maxPlayers << std::endl;
        ...
    });
}
```

클라이언트 프로그램은 `PrintStatus()` 함수를 통해 **공유 메모리에 저장된 서버의 현재 상태를 출력**한다.
실제 모니터링 툴에서는 이 데이터를 기반으로 **UI 갱신, 경고 알림, 통계 시각화** 등을 구현할 수 있다.


#### 4. CPU와 메모리 사용량 측정

```cpp
float GetCPUUsage() { ... }
ULONGLONG GetMemoryUsage() { ... }
```

* `GetCPUUsage()`는 임의의 값을 생성하는 시뮬레이션 함수이다.
* `GetMemoryUsage()`는 현재 프로세스의 메모리 사용량을 가져오는 함수로,
  `GetProcessMemoryInfo()` API를 사용한다.


#### 5. 전체 구조 요약
이 예제의 전체 동작 흐름은 다음과 같다.

```
┌───────────────────────────────────────────────┐
│       Shared Memory IPC Communication         │
├───────────────────────────────────────────────┤
│ 1. 서버: CreateFileMapping → MapViewOfFile    │
│ 2. 클라이언트: OpenFileMapping → MapViewOfFile│
│ 3. 서버: 데이터 갱신 (AccessData + Mutex)     │
│ 4. 클라이언트: 데이터 읽기 (AccessData)       │
│ 5. 서버 종료 시: isRunning = false 설정       │
└───────────────────────────────────────────────┘
```

#### 6. 요약
이 예제는 **공유 메모리를 이용한 고성능 IPC 구조**를 구현한 대표적인 사례이다.
핵심 포인트는 다음과 같다.

* `CreateFileMapping` / `MapViewOfFile`을 이용해 여러 프로세스가 동일한 메모리 공간을 공유한다.
* `Mutex`를 이용해 **여러 프로세스가 동시에 데이터를 변경하지 않도록 동기화**한다.
* 네트워크 통신이 없기 때문에 **매우 빠른 데이터 교환 속도**를 제공한다.
* 서버-클라이언트 모델처럼 **데이터 생산자(서버)** 와 **소비자(클라이언트)** 구조로 동작한다.

이 구조는 **게임 서버 상태 모니터링, 실시간 데이터 수집, 분석 도구 연동** 등
다양한 고성능 시스템 설계에 활용할 수 있다.
이 코드를 통해 **운영체제 수준에서의 메모리 공유와 동기화의 원리**를 이해할 수 있다.


</br>   

## 4.4 스레드 동기화 객체들

### 4.4.1 Critical Section vs Mutex

```cpp
#include <chrono>

class PerformanceTest {
private:
    static const int ITERATIONS = 1000000;
    static const int THREAD_COUNT = 4;
    
    // Critical Section 테스트용
    CRITICAL_SECTION m_criticalSection;
    int m_criticalSectionCounter = 0;
    
    // Mutex 테스트용
    HANDLE m_mutex;
    int m_mutexCounter = 0;
    
public:
    PerformanceTest() {
        InitializeCriticalSection(&m_criticalSection);
        m_mutex = CreateMutex(nullptr, FALSE, nullptr);
    }
    
    ~PerformanceTest() {
        DeleteCriticalSection(&m_criticalSection);
        if (m_mutex != nullptr) {
            CloseHandle(m_mutex);
        }
    }
    
    void RunPerformanceComparison() {
        std::cout << "\n=== Critical Section vs Mutex 성능 비교 ===" << std::endl;
        
        // Critical Section 테스트
        auto start = std::chrono::high_resolution_clock::now();
        TestCriticalSection();
        auto end = std::chrono::high_resolution_clock::now();
        
        auto criticalSectionTime = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        // Mutex 테스트
        start = std::chrono::high_resolution_clock::now();
        TestMutex();
        end = std::chrono::high_resolution_clock::now();
        
        auto mutexTime = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        // 결과 출력
        std::cout << "Critical Section: " << criticalSectionTime.count() << "ms" << std::endl;
        std::cout << "Mutex: " << mutexTime.count() << "ms" << std::endl;
        std::cout << "성능 차이: " << (mutexTime.count() / (float)criticalSectionTime.count()) << "배" << std::endl;
        
        /*
        ┌─────────────────────────────────────────┐
        │    Critical Section vs Mutex Comparison │
        ├─────────────────────────────────────────┤
        │                                         │
        │  Critical Section:                      │
        │  ✓ 빠른 성능 (사용자 모드)              │
        │  ✓ 낮은 오버헤드                       │
        │  ✗ 같은 프로세스 내에서만 사용 가능    │
        │                                         │
        │  Mutex:                                 │
        │  ✓ 프로세스 간 동기화 가능              │
        │  ✓ 더 많은 기능 (타임아웃 등)          │
        │  ✗ 느린 성능 (커널 모드 전환)          │
        │                                         │
        │  권장사항:                              │
        │  - 같은 프로세스 내: Critical Section   │
        │  - 프로세스 간: Mutex                   │
        └─────────────────────────────────────────┘
        */
    }
    
private:
    void TestCriticalSection() {
        std::vector<std::thread> threads;
        
        for (int i = 0; i < THREAD_COUNT; ++i) {
            threads.emplace_back([this]() {
                for (int j = 0; j < ITERATIONS / THREAD_COUNT; ++j) {
                    EnterCriticalSection(&m_criticalSection);
                    m_criticalSectionCounter++;
                    LeaveCriticalSection(&m_criticalSection);
                }
            });
        }
        
        for (auto& thread : threads) {
            thread.join();
        }
        
        std::cout << "Critical Section 최종 값: " << m_criticalSectionCounter << std::endl;
    }
    
    void TestMutex() {
        std::vector<std::thread> threads;
        
        for (int i = 0; i < THREAD_COUNT; ++i) {
            threads.emplace_back([this]() {
                for (int j = 0; j < ITERATIONS / THREAD_COUNT; ++j) {
                    WaitForSingleObject(m_mutex, INFINITE);
                    m_mutexCounter++;
                    ReleaseMutex(m_mutex);
                }
            });
        }
        
        for (auto& thread : threads) {
            thread.join();
        }
        
        std::cout << "Mutex 최종 값: " << m_mutexCounter << std::endl;
    }
};
```

### 4.4.2 Event 객체를 이용한 스레드 조정

```cpp
class GameServerController {
private:
    HANDLE m_startEvent;
    HANDLE m_stopEvent;
    HANDLE m_pauseEvent;
    std::vector<std::thread> m_gameThreads;
    std::atomic<bool> m_running;
    std::atomic<bool> m_paused;
    
public:
    GameServerController() : m_running(false), m_paused(false) {
        // 이벤트 객체 생성
        m_startEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);  // Manual reset
        m_stopEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);   // Manual reset
        m_pauseEvent = CreateEvent(nullptr, TRUE, TRUE, nullptr);   // Manual reset, initially signaled
        
        if (m_startEvent == nullptr || m_stopEvent == nullptr || m_pauseEvent == nullptr) {
            throw std::runtime_error("이벤트 객체 생성 실패");
        }
    }
    
    ~GameServerController() {
        Stop();
        
        if (m_startEvent != nullptr) CloseHandle(m_startEvent);
        if (m_stopEvent != nullptr) CloseHandle(m_stopEvent);
        if (m_pauseEvent != nullptr) CloseHandle(m_pauseEvent);
    }
    
    bool Start(int threadCount = 4) {
        if (m_running.load()) return false;
        
        m_running = true;
        m_paused = false;
        
        // 이벤트 초기화
        ResetEvent(m_stopEvent);
        SetEvent(m_startEvent);
        SetEvent(m_pauseEvent);
        
        // 게임 스레드들 생성
        for (int i = 0; i < threadCount; ++i) {
            m_gameThreads.emplace_back([this, i]() { GameThread(i); });
        }
        
        std::cout << "게임 서버 시작됨 (" << threadCount << "개 스레드)" << std::endl;
        return true;
    }
    
    void Stop() {
        if (!m_running.load()) return;
        
        m_running = false;
        
        // 중지 이벤트 신호
        SetEvent(m_stopEvent);
        
        // 모든 게임 스레드 대기
        for (auto& thread : m_gameThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        
        m_gameThreads.clear();
        std::cout << "게임 서버 중지됨" << std::endl;
    }
    
    void Pause() {
        if (!m_running.load() || m_paused.load()) return;
        
        m_paused = true;
        ResetEvent(m_pauseEvent);
        
        std::cout << "게임 서버 일시 정지" << std::endl;
    }
    
    void Resume() {
        if (!m_running.load() || !m_paused.load()) return;
        
        m_paused = false;
        SetEvent(m_pauseEvent);
        
        std::cout << "게임 서버 재개" << std::endl;
    }
    
private:
    void GameThread(int threadId) {
        std::cout << "게임 스레드 " << threadId << " 시작 (TID: " << GetCurrentThreadId() << ")" << std::endl;
        
        // 시작 이벤트 대기
        WaitForSingleObject(m_startEvent, INFINITE);
        
        while (m_running.load()) {
            // 일시정지 확인
            WaitForSingleObject(m_pauseEvent, INFINITE);
            
            if (!m_running.load()) break;
            
            // 게임 로직 실행
            ProcessGameLogic(threadId);
            
            // 중지 신호 확인 (논블로킹)
            if (WaitForSingleObject(m_stopEvent, 0) == WAIT_OBJECT_0) {
                break;
            }
            
            Sleep(16); // ~60 FPS
        }
        
        std::cout << "게임 스레드 " << threadId << " 종료" << std::endl;
    }
    
    void ProcessGameLogic(int threadId) {
        static std::atomic<int> frameCounter(0);
        int currentFrame = frameCounter.fetch_add(1);
        
        if (currentFrame % 60 == 0) { // 1초마다
            std::cout << "스레드 " << threadId << " - 프레임 " << currentFrame << std::endl;
        }
        
        // 실제 게임 로직 시뮬레이션
        // 예: 플레이어 위치 업데이트, AI 처리, 물리 시뮬레이션 등
    }
};
```
    
이 코드는 **게임 서버의 여러 스레드를 효율적으로 제어하기 위해 이벤트(Event) 객체를 사용하는 예제**이다.
게임 서버는 여러 개의 스레드가 동시에 동작하면서 플레이어의 입력 처리, AI 연산, 물리 연산 등을 수행한다.
하지만 서버를 **시작(Start)**, **일시정지(Pause)**, **재개(Resume)**, **중지(Stop)** 시키는 과정에서 스레드 간의 상태를 일관되게 유지해야 한다.
이를 위해 **Windows API의 이벤트 객체(HANDLE)** 를 사용해 스레드들의 실행 흐름을 제어한다.

이 예제에서는 다음 세 가지 이벤트 객체를 이용한다.

* `m_startEvent`: 서버 시작 신호
* `m_stopEvent`: 서버 종료 신호
* `m_pauseEvent`: 일시정지 및 재개 제어 신호

#### 1. 클래스 구성과 이벤트 객체 초기화

```cpp
HANDLE m_startEvent;
HANDLE m_stopEvent;
HANDLE m_pauseEvent;
std::vector<std::thread> m_gameThreads;
std::atomic<bool> m_running;
std::atomic<bool> m_paused;
```

`GameServerController` 클래스는 위와 같은 멤버를 가진다.
이벤트 객체는 스레드 간 동기화를 위해 사용되며, `atomic` 변수는 멀티스레드 환경에서의 안전한 상태 플래그로 사용된다.

이벤트 객체는 생성자에서 다음과 같이 초기화된다.

```cpp
m_startEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
m_stopEvent  = CreateEvent(nullptr, TRUE, FALSE, nullptr);
m_pauseEvent = CreateEvent(nullptr, TRUE, TRUE, nullptr);
```

* `TRUE`: 수동 리셋(Manual Reset) 방식
* `FALSE` 또는 `TRUE`: 초기 상태가 비신호(unsignaled)인지, 신호(signaled) 상태인지 지정

즉, `m_startEvent`와 `m_stopEvent`는 처음에는 비활성 상태이며,
`m_pauseEvent`는 처음에 신호 상태로 설정되어 있어 스레드가 바로 실행될 수 있다.


#### 2. 서버 시작 (Start)

```cpp
bool Start(int threadCount = 4) {
    if (m_running.load()) return false;
    m_running = true;
    m_paused = false;
    ResetEvent(m_stopEvent);
    SetEvent(m_startEvent);
    SetEvent(m_pauseEvent);
    for (int i = 0; i < threadCount; ++i) {
        m_gameThreads.emplace_back([this, i]() { GameThread(i); });
    }
}
```

서버를 시작하면 다음 순서로 동작한다.

1. 이미 실행 중인지 확인한다.
2. `m_running`을 `true`로 설정하고 서버가 동작 중임을 표시한다.
3. 이벤트를 초기화 및 설정한다.

   * `m_stopEvent`는 리셋되어 중지 신호를 제거한다.
   * `m_startEvent`와 `m_pauseEvent`는 신호 상태로 설정되어 스레드가 진행 가능함을 의미한다.
4. 지정한 개수의 게임 스레드를 생성한다.


#### 3. 서버 중지 (Stop)

```cpp
void Stop() {
    if (!m_running.load()) return;
    m_running = false;
    SetEvent(m_stopEvent);
    for (auto& thread : m_gameThreads) {
        if (thread.joinable()) thread.join();
    }
    m_gameThreads.clear();
}
```

서버를 중지할 때는 `m_running`을 `false`로 변경하고,
`m_stopEvent`에 신호를 보내 모든 스레드가 종료를 감지하도록 한다.
각 스레드는 `WaitForSingleObject`를 통해 이 신호를 감지하고 반복문을 빠져나온다.
모든 스레드가 종료될 때까지 `join()`으로 대기한다.


#### 4. 일시정지 (Pause) 및 재개 (Resume)

```cpp
void Pause() {
    if (!m_running.load() || m_paused.load()) return;
    m_paused = true;
    ResetEvent(m_pauseEvent);
}

void Resume() {
    if (!m_running.load() || !m_paused.load()) return;
    m_paused = false;
    SetEvent(m_pauseEvent);
}
```

일시정지 시에는 `m_pauseEvent`를 **리셋(Reset)** 하여 비신호 상태로 만든다.
이 상태에서 스레드는 `WaitForSingleObject(m_pauseEvent, INFINITE)` 부분에서 대기하게 된다.
다시 재개할 때는 `SetEvent(m_pauseEvent)`로 신호 상태로 바꾸어 스레드들이 다시 실행되게 한다.


#### 5. 스레드 함수 (GameThread)

```cpp
void GameThread(int threadId) {
    WaitForSingleObject(m_startEvent, INFINITE);
    while (m_running.load()) {
        WaitForSingleObject(m_pauseEvent, INFINITE);
        if (!m_running.load()) break;
        ProcessGameLogic(threadId);
        if (WaitForSingleObject(m_stopEvent, 0) == WAIT_OBJECT_0) break;
        Sleep(16);
    }
}
```

각 스레드는 `m_startEvent`가 신호 상태가 될 때까지 대기한다.
그 이후에는 반복문을 돌며 다음을 수행한다.

1. `m_pauseEvent` 신호를 기다린다 (일시정지 상태일 때는 여기서 멈춘다).
2. 게임 로직(`ProcessGameLogic`)을 수행한다.
3. `m_stopEvent`가 신호 상태이면 즉시 종료한다.
4. 약 16ms 대기하여 약 60FPS 속도로 실행되게 한다.


#### 6. 게임 로직 처리

```cpp
void ProcessGameLogic(int threadId) {
    static std::atomic<int> frameCounter(0);
    int currentFrame = frameCounter.fetch_add(1);
    if (currentFrame % 60 == 0) {
        std::cout << "스레드 " << threadId << " - 프레임 " << currentFrame << std::endl;
    }
}
```

여기서는 단순한 프레임 카운터를 통해 1초(60프레임)마다 로그를 출력한다.
실제 게임 서버에서는 이 부분에 **플레이어 상태 갱신**, **AI 계산**, **충돌 처리**, **네트워크 메시지 송수신** 등의 로직이 들어간다.


#### 정리
이 코드는 **Windows 이벤트 객체를 활용하여 게임 서버 스레드의 실행 흐름을 안전하고 직관적으로 제어하는 방법**을 보여준다.
특히 `WaitForSingleObject`, `SetEvent`, `ResetEvent` 함수를 이용해 **스레드 간 동기화**를 구현했다.
이러한 방식은 서버 제어뿐만 아니라, **병렬 처리 시스템, 비동기 이벤트 처리, 멀티스레드 렌더링 엔진 등**에서도 폭넓게 활용될 수 있다.



</br>  

## 4.5 실습 예제: 종합 멀티스레드 게임 서버
지금까지 학습한 내용을 종합하여 완전한 멀티스레드 게임 서버를 구현해보겠다.

```cpp
class ComprehensiveGameServer {
private:
    // 스레드 관리
    BasicThreadManager m_threadManager;
    ThreadPoolManager m_threadPool;
    GameEventProcessor m_eventProcessor;
    GameTaskScheduler m_taskScheduler;
    
    // IPC
    NamedPipeServer m_pipeServer;
    GameServerMonitor m_monitor;
    
    // 제어
    GameServerController m_controller;
    
    // 상태
    std::atomic<bool> m_running;
    
public:
    ComprehensiveGameServer() 
        : m_pipeServer(L"\\\\.\\pipe\\GameServer"), m_running(false) {}
    
    bool Initialize() {
        std::cout << "=== 게임 서버 초기화 ===" << std::endl;
        
        // 스레드 풀 초기화
        if (!m_threadPool.Initialize()) {
            std::cout << "스레드 풀 초기화 실패" << std::endl;
            return false;
        }
        
        // 작업 스케줄러 초기화
        if (!m_taskScheduler.Initialize()) {
            std::cout << "작업 스케줄러 초기화 실패" << std::endl;
            return false;
        }
        
        // 이벤트 프로세서 시작
        if (!m_eventProcessor.Start()) {
            std::cout << "이벤트 프로세서 시작 실패" << std::endl;
            return false;
        }
        
        // 모니터링 시스템 시작
        if (!m_monitor.StartAsServer("MainGameServer")) {
            std::cout << "모니터링 시스템 시작 실패" << std::endl;
            return false;
        }
        
        // 명명된 파이프 서버 시작
        if (!m_pipeServer.Start()) {
            std::cout << "파이프 서버 시작 실패" << std::endl;
            return false;
        }
        
        std::cout << "게임 서버 초기화 완료" << std::endl;
        return true;
    }
    
    bool Start() {
        if (m_running.load()) return false;
        
        std::cout << "\n=== 게임 서버 시작 ===" << std::endl;
        
        m_running = true;
        
        // 기본 워커 스레드 시작
        if (!m_threadManager.Start(4)) {
            std::cout << "워커 스레드 시작 실패" << std::endl;
            return false;
        }
        
        // 게임 제어 스레드 시작
        if (!m_controller.Start(2)) {
            std::cout << "게임 제어 스레드 시작 실패" << std::endl;
            return false;
        }
        
        // 초기 작업들 스케줄링
        ScheduleInitialTasks();
        
        // 테스트 이벤트 생성
        GenerateTestEvents();
        
        std::cout << "게임 서버 시작 완료" << std::endl;
        return true;
    }
    
    void Run() {
        std::cout << "\n게임 서버 실행 중..." << std::endl;
        std::cout << "명령어: status, pause, resume, stop" << std::endl;
        
        std::string command;
        while (m_running.load() && std::cin >> command) {
            if (command == "status") {
                PrintStatus();
            } else if (command == "pause") {
                m_controller.Pause();
            } else if (command == "resume") {
                m_controller.Resume();
            } else if (command == "stop") {
                break;
            } else {
                std::cout << "알 수 없는 명령어: " << command << std::endl;
            }
        }
    }
    
    void Stop() {
        if (!m_running.load()) return;
        
        std::cout << "\n=== 게임 서버 중지 ===" << std::endl;
        
        m_running = false;
        
        // 각 컴포넌트 중지 (역순)
        m_controller.Stop();
        m_threadManager.Stop();
        m_pipeServer.Stop();
        m_monitor.Stop();
        m_eventProcessor.Stop();
        m_taskScheduler.WaitForAllTasks();
        
        std::cout << "게임 서버 중지 완료" << std::endl;
    }
    
private:
    void ScheduleInitialTasks() {
        // 초기 게임 로직 작업들
        m_taskScheduler.ScheduleGameLogic();
        
        // 데이터베이스 작업
        m_taskScheduler.ScheduleDatabaseOperation("SELECT * FROM players WHERE online = 1");
        
        // 플레이어 업데이트 작업
        for (int i = 1; i <= 10; ++i) {
            m_taskScheduler.SchedulePlayerUpdate(i, "InitialPosition:100,200");
        }
    }
    
    void GenerateTestEvents() {
        // 테스트용 게임 이벤트 생성
        std::thread([this]() {
            for (int i = 1; i <= 20; ++i) {
                m_eventProcessor.AddEvent(GameEvent(i, "PLAYER_LOGIN", "Player" + std::to_string(i)));
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                
                m_eventProcessor.AddEvent(GameEvent(i, "PLAYER_MOVE", "100,200"));
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
                
                if (i % 5 == 0) {
                    m_eventProcessor.AddEvent(GameEvent(i, "PLAYER_CHAT", "Hello World!"));
                }
                
                // 모니터링 정보 업데이트
                m_monitor.UpdatePlayerCount(i);
            }
        }).detach();
    }
    
    void PrintStatus() {
        std::cout << "\n=== 게임 서버 상태 ===" << std::endl;
        
        // 작업 통계
        m_taskScheduler.PrintStatistics();
        
        // 모니터링 정보
        m_monitor.PrintStatus();
        
        std::cout << "======================" << std::endl;
    }
};

// 메인 함수
int main() {
    try {
        // 성능 비교 테스트
        PerformanceTest perfTest;
        perfTest.RunPerformanceComparison();
        
        // 종합 게임 서버 테스트
        ComprehensiveGameServer gameServer;
        
        if (gameServer.Initialize() && gameServer.Start()) {
            gameServer.Run();
            gameServer.Stop();
        }
        
    } catch (const std::exception& e) {
        std::cout << "오류 발생: " << e.what() << std::endl;
        return 1;
    }
    
    std::cout << "\n프로그램 종료" << std::endl;
    return 0;
}
```

이 장에서는 게임 서버 개발에 필수적인 멀티스레딩 기술들을 다뤘다. 기본적인 스레드 생성부터 고급 스레드 풀 활용, 프로세스 간 통신, 그리고 다양한 동기화 객체들까지 포괄적으로 학습했다. 다음 장에서는 더욱 고급한 동기화 기법과 성능 최적화 방법을 알아보겠다.



 