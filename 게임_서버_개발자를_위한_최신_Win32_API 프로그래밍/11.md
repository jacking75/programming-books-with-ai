# ê²Œì„ ì„œë²„ ê°œë°œìë¥¼ ìœ„í•œ ìµœì‹  Win32 API í”„ë¡œê·¸ë˜ë°  

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  

# Chapter 11. COMê³¼ WinRT
ëª¨ë˜ Windows ê°œë°œì—ì„œëŠ” ì „í†µì ì¸ Win32 API ì™¸ì—ë„ COM(Component Object Model)ê³¼ WinRT(Windows Runtime)ë¥¼ í†µí•´ ë” ê°•ë ¥í•˜ê³  í˜„ëŒ€ì ì¸ ê¸°ëŠ¥ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤. ê²Œì„ ì„œë²„ ê°œë°œì—ì„œëŠ” íŠ¹íˆ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§, ì„±ëŠ¥ ë¶„ì„, ë„¤íŠ¸ì›Œí¬ ê´€ë¦¬ ë“±ì˜ ì˜ì—­ì—ì„œ ì´ëŸ¬í•œ ê¸°ìˆ ë“¤ì´ ìœ ìš©í•˜ë‹¤.

## 11.1 COM ê¸°ì´ˆ ê°œë…

### 11.1.1 COM ì•„í‚¤í…ì²˜ ì´í•´
COMì€ ë°”ì´ë„ˆë¦¬ í‘œì¤€ìœ¼ë¡œ, ë‹¤ì–‘í•œ ì–¸ì–´ì™€ í”Œë«í¼ ê°„ì˜ ìƒí˜¸ ìš´ìš©ì„±ì„ ì œê³µí•œë‹¤.

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           Application Layer             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚    Client   â”‚  â”‚   COM Server    â”‚  â”‚
    â”‚  â”‚ Application â”‚  â”‚   Component     â”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚             â”‚    COM Infrastructure    â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚         COM Library (Ole32.dll)     â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚          Operating System              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 11.1.2 ê¸°ë³¸ COM ì¸í„°í˜ì´ìŠ¤ í™œìš©
ë‹¤ìŒì€ ì‹œìŠ¤í…œ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ëŠ” WMI(Windows Management Instrumentation) COM ê°ì²´ ì‚¬ìš© ì˜ˆì œì´ë‹¤:

```cpp
#include <windows.h>
#include <comdef.h>
#include <wbemidl.h>
#include <iostream>
#include <string>
#include <vector>

#pragma comment(lib, "wbemuuid.lib")

class COMHelper {
public:
    static bool Initialize() {
        HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
        if (FAILED(hr)) {
            std::wcout << L"Failed to initialize COM library. Error: 0x" 
                      << std::hex << hr << std::endl;
            return false;
        }

        // COM ë³´ì•ˆ ì„¤ì •
        hr = CoInitializeSecurity(
            nullptr,                    // ë³´ì•ˆ ì„œìˆ ì
            -1,                         // COM ì¸ì¦ ì„œë¹„ìŠ¤
            nullptr,                    // ì¸ì¦ ì„œë¹„ìŠ¤
            nullptr,                    // ì˜ˆì•½ë¨
            RPC_C_AUTHN_LEVEL_NONE,     // ê¸°ë³¸ ì¸ì¦ ë ˆë²¨
            RPC_C_IMP_LEVEL_IMPERSONATE,// ê¸°ë³¸ ìœ„ì„ ë ˆë²¨
            nullptr,                    // ì¸ì¦ ì •ë³´
            EOAC_NONE,                  // ì¶”ê°€ ê¸°ëŠ¥
            nullptr);                   // ì˜ˆì•½ë¨

        if (FAILED(hr)) {
            std::wcout << L"Failed to initialize security. Error: 0x" 
                      << std::hex << hr << std::endl;
            CoUninitialize();
            return false;
        }

        return true;
    }

    static void Cleanup() {
        CoUninitialize();
    }
};

class WMIQuery {
private:
    IWbemLocator* m_pLoc = nullptr;
    IWbemServices* m_pSvc = nullptr;
    bool m_initialized = false;

public:
    WMIQuery() = default;
    ~WMIQuery() { Cleanup(); }

    bool Initialize() {
        // WMI ë¡œì¼€ì´í„° ìƒì„±
        HRESULT hr = CoCreateInstance(
            CLSID_WbemLocator,
            0,
            CLSCTX_INPROC_SERVER,
            IID_IWbemLocator,
            (LPVOID*)&m_pLoc);

        if (FAILED(hr)) {
            std::wcout << L"Failed to create IWbemLocator object. Error: 0x" 
                      << std::hex << hr << std::endl;
            return false;
        }

        // WMI ì„œë¹„ìŠ¤ì— ì—°ê²°
        hr = m_pLoc->ConnectServer(
            _bstr_t(L"ROOT\\CIMV2"),    // WMI ë„¤ì„ìŠ¤í˜ì´ìŠ¤
            nullptr,                    // ì‚¬ìš©ì ì´ë¦„
            nullptr,                    // íŒ¨ìŠ¤ì›Œë“œ
            0,                          // ë¡œì¼€ì¼
            NULL,                       // ë³´ì•ˆ í”Œë˜ê·¸
            0,                          // ê¶Œí•œ
            0,                          // ì»¨í…ìŠ¤íŠ¸ ê°ì²´
            &m_pSvc);                   // IWbemServices í”„ë¡ì‹œ

        if (FAILED(hr)) {
            std::wcout << L"Could not connect to WMI. Error: 0x" 
                      << std::hex << hr << std::endl;
            m_pLoc->Release();
            m_pLoc = nullptr;
            return false;
        }

        // WMI ì—°ê²°ì˜ ë³´ì•ˆ ë ˆë²¨ ì„¤ì •
        hr = CoSetProxyBlanket(
            m_pSvc,                     // ì¸í„°í˜ì´ìŠ¤ í¬ì¸í„°
            RPC_C_AUTHN_WINNT,          // ì¸ì¦ ì„œë¹„ìŠ¤
            RPC_C_AUTHZ_NONE,           // ê¶Œí•œ ë¶€ì—¬ ì„œë¹„ìŠ¤
            nullptr,                    // ì„œë²„ ì£¼ì²´ ì´ë¦„
            RPC_C_AUTHN_LEVEL_CALL,     // ì¸ì¦ ë ˆë²¨
            RPC_C_IMP_LEVEL_IMPERSONATE,// ìœ„ì„ ë ˆë²¨
            nullptr,                    // í´ë¼ì´ì–¸íŠ¸ ID
            EOAC_NONE);                 // í”„ë¡ì‹œ ê¸°ëŠ¥

        if (FAILED(hr)) {
            std::wcout << L"Could not set proxy blanket. Error: 0x" 
                      << std::hex << hr << std::endl;
            m_pSvc->Release();
            m_pLoc->Release();
            m_pSvc = nullptr;
            m_pLoc = nullptr;
            return false;
        }

        m_initialized = true;
        return true;
    }

    struct ProcessInfo {
        std::wstring name;
        DWORD processId;
        DWORD parentProcessId;
        ULONGLONG workingSetSize;
        ULONGLONG virtualSize;
        std::wstring commandLine;
    };

    std::vector<ProcessInfo> GetProcessList() {
        std::vector<ProcessInfo> processes;
        
        if (!m_initialized) return processes;

        IEnumWbemClassObject* pEnumerator = nullptr;
        HRESULT hr = m_pSvc->ExecQuery(
            bstr_t("WQL"),
            bstr_t("SELECT * FROM Win32_Process"),
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            nullptr,
            &pEnumerator);

        if (FAILED(hr)) {
            std::wcout << L"Query failed. Error: 0x" << std::hex << hr << std::endl;
            return processes;
        }

        IWbemClassObject* pclsObj = nullptr;
        ULONG uReturn = 0;

        while (pEnumerator) {
            hr = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
            if (0 == uReturn) break;

            ProcessInfo info;
            VARIANT vtProp;

            // í”„ë¡œì„¸ìŠ¤ ì´ë¦„
            hr = pclsObj->Get(L"Name", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
                info.name = vtProp.bstrVal;
            }
            VariantClear(&vtProp);

            // í”„ë¡œì„¸ìŠ¤ ID
            hr = pclsObj->Get(L"ProcessId", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_I4) {
                info.processId = vtProp.ulVal;
            }
            VariantClear(&vtProp);

            // ë¶€ëª¨ í”„ë¡œì„¸ìŠ¤ ID
            hr = pclsObj->Get(L"ParentProcessId", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_I4) {
                info.parentProcessId = vtProp.ulVal;
            }
            VariantClear(&vtProp);

            // ì›Œí‚¹ì…‹ í¬ê¸°
            hr = pclsObj->Get(L"WorkingSetSize", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
                info.workingSetSize = _wtoi64(vtProp.bstrVal);
            }
            VariantClear(&vtProp);

            // ê°€ìƒ ë©”ëª¨ë¦¬ í¬ê¸°
            hr = pclsObj->Get(L"VirtualSize", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
                info.virtualSize = _wtoi64(vtProp.bstrVal);
            }
            VariantClear(&vtProp);

            // ëª…ë ¹ì¤„
            hr = pclsObj->Get(L"CommandLine", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
                info.commandLine = vtProp.bstrVal;
            }
            VariantClear(&vtProp);

            processes.push_back(info);
            pclsObj->Release();
        }

        pEnumerator->Release();
        return processes;
    }

    struct NetworkAdapterInfo {
        std::wstring name;
        std::wstring description;
        std::wstring macAddress;
        ULONGLONG bytesReceived;
        ULONGLONG bytesSent;
        bool isConnected;
    };

    std::vector<NetworkAdapterInfo> GetNetworkAdapters() {
        std::vector<NetworkAdapterInfo> adapters;
        
        if (!m_initialized) return adapters;

        IEnumWbemClassObject* pEnumerator = nullptr;
        HRESULT hr = m_pSvc->ExecQuery(
            bstr_t("WQL"),
            bstr_t("SELECT * FROM Win32_NetworkAdapter WHERE NetEnabled=True"),
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            nullptr,
            &pEnumerator);

        if (FAILED(hr)) return adapters;

        IWbemClassObject* pclsObj = nullptr;
        ULONG uReturn = 0;

        while (pEnumerator) {
            hr = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
            if (0 == uReturn) break;

            NetworkAdapterInfo info;
            VARIANT vtProp;

            // ì–´ëŒ‘í„° ì´ë¦„
            hr = pclsObj->Get(L"Name", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
                info.name = vtProp.bstrVal;
            }
            VariantClear(&vtProp);

            // ì„¤ëª…
            hr = pclsObj->Get(L"Description", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
                info.description = vtProp.bstrVal;
            }
            VariantClear(&vtProp);

            // MAC ì£¼ì†Œ
            hr = pclsObj->Get(L"MACAddress", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
                info.macAddress = vtProp.bstrVal;
            }
            VariantClear(&vtProp);

            // ì—°ê²° ìƒíƒœ
            hr = pclsObj->Get(L"NetConnectionStatus", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_I4) {
                info.isConnected = (vtProp.ulVal == 2); // 2 = Connected
            }
            VariantClear(&vtProp);

            adapters.push_back(info);
            pclsObj->Release();
        }

        pEnumerator->Release();
        return adapters;
    }

private:
    void Cleanup() {
        if (m_pSvc) {
            m_pSvc->Release();
            m_pSvc = nullptr;
        }
        if (m_pLoc) {
            m_pLoc->Release();
            m_pLoc = nullptr;
        }
        m_initialized = false;
    }
};
```

### 11.1.3 ì‹¤ì œ ì‚¬ìš© ì˜ˆì œ

```cpp
// GameServerMonitor.cpp - COMì„ í™œìš©í•œ ê²Œì„ ì„œë²„ ëª¨ë‹ˆí„°ë§
#include "WMIQuery.h"
#include <iostream>
#include <iomanip>
#include <algorithm>

class GameServerMonitor {
private:
    WMIQuery m_wmi;
    std::wstring m_gameServerProcessName;

public:
    bool Initialize(const std::wstring& processName) {
        m_gameServerProcessName = processName;
        return m_wmi.Initialize();
    }

    void ShowGameServerStatus() {
        auto processes = m_wmi.GetProcessList();
        
        std::wcout << L"\n=== Game Server Process Information ===" << std::endl;
        std::wcout << std::setw(10) << L"PID" 
                   << std::setw(20) << L"Name"
                   << std::setw(15) << L"Memory (MB)"
                   << std::setw(15) << L"Virtual (MB)" << std::endl;
        std::wcout << std::wstring(60, L'-') << std::endl;

        bool found = false;
        for (const auto& proc : processes) {
            if (proc.name.find(m_gameServerProcessName) != std::wstring::npos) {
                found = true;
                std::wcout << std::setw(10) << proc.processId
                           << std::setw(20) << proc.name
                           << std::setw(15) << (proc.workingSetSize / 1024 / 1024)
                           << std::setw(15) << (proc.virtualSize / 1024 / 1024) 
                           << std::endl;
            }
        }

        if (!found) {
            std::wcout << L"Game server process not found!" << std::endl;
        }
    }

    void ShowNetworkStatus() {
        auto adapters = m_wmi.GetNetworkAdapters();
        
        std::wcout << L"\n=== Network Adapter Information ===" << std::endl;
        
        for (const auto& adapter : adapters) {
            std::wcout << L"Name: " << adapter.name << std::endl;
            std::wcout << L"Description: " << adapter.description << std::endl;
            std::wcout << L"MAC Address: " << adapter.macAddress << std::endl;
            std::wcout << L"Status: " << (adapter.isConnected ? L"Connected" : L"Disconnected") 
                       << std::endl;
            std::wcout << std::wstring(50, L'-') << std::endl;
        }
    }

    void MonitorPerformance() {
        std::wcout << L"Starting performance monitoring..." << std::endl;
        
        for (int i = 0; i < 10; ++i) {
            auto processes = m_wmi.GetProcessList();
            
            ULONGLONG totalMemory = 0;
            int gameServerCount = 0;
            
            for (const auto& proc : processes) {
                if (proc.name.find(m_gameServerProcessName) != std::wstring::npos) {
                    totalMemory += proc.workingSetSize;
                    gameServerCount++;
                }
            }
            
            std::wcout << L"[" << std::setw(2) << i + 1 << L"/10] "
                       << L"Game Servers: " << gameServerCount
                       << L", Total Memory: " << (totalMemory / 1024 / 1024) << L" MB"
                       << std::endl;
            
            Sleep(2000); // 2ì´ˆ ê°„ê²©
        }
    }
};

int main() {
    // COM ì´ˆê¸°í™”
    if (!COMHelper::Initialize()) {
        return 1;
    }

    GameServerMonitor monitor;
    if (!monitor.Initialize(L"GameServer")) {
        std::wcout << L"Failed to initialize WMI query" << std::endl;
        COMHelper::Cleanup();
        return 1;
    }

    // ë©”ë‰´ ì‹œìŠ¤í…œ
    int choice;
    do {
        std::wcout << L"\n=== Game Server Monitor ===" << std::endl;
        std::wcout << L"1. Show Game Server Status" << std::endl;
        std::wcout << L"2. Show Network Status" << std::endl;
        std::wcout << L"3. Monitor Performance" << std::endl;
        std::wcout << L"0. Exit" << std::endl;
        std::wcout << L"Enter choice: ";
        
        std::wcin >> choice;

        switch (choice) {
        case 1:
            monitor.ShowGameServerStatus();
            break;
        case 2:
            monitor.ShowNetworkStatus();
            break;
        case 3:
            monitor.MonitorPerformance();
            break;
        case 0:
            std::wcout << L"Exiting..." << std::endl;
            break;
        default:
            std::wcout << L"Invalid choice!" << std::endl;
            break;
        }
    } while (choice != 0);

    COMHelper::Cleanup();
    return 0;
}
```
  
</br>  
  

## 11.2 WinRT API í™œìš©

### 11.2.1 WinRT ì•„í‚¤í…ì²˜ ì†Œê°œ
WinRTëŠ” Windows 8ë¶€í„° ë„ì…ëœ ìƒˆë¡œìš´ API ê³„ì¸µìœ¼ë¡œ, í˜„ëŒ€ì ì´ê³  íƒ€ì… ì•ˆì „í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•œë‹¤.

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        Application Layer               â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚   C++/WinRT â”‚  â”‚   C#/.NET       â”‚  â”‚
    â”‚  â”‚ Application â”‚  â”‚  Application    â”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚           Language Projections          â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚    C++/WinRT    â”‚    .NET/WinRT   â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚         Windows Runtime (WinRT)         â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚ Windows.Foundation | Windows.System â”‚ â”‚
    â”‚  â”‚ Windows.Storage   | Windows.Network â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚              Win32 APIs                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 11.2.2 C++/WinRT ê¸°ì´ˆ ì‚¬ìš©ë²•
ë¨¼ì € C++/WinRTë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì„¤ì •ì´ í•„ìš”í•˜ë‹¤:  

```cpp
// pch.h ë˜ëŠ” í—¤ë” íŒŒì¼ì— ì¶”ê°€
#include <winrt/base.h>
#include <winrt/Windows.Foundation.h>
#include <winrt/Windows.Foundation.Collections.h>
#include <winrt/Windows.System.h>
#include <winrt/Windows.Storage.h>
#include <winrt/Windows.Networking.h>
#include <winrt/Windows.Networking.Sockets.h>
#include <winrt/Windows.Web.Http.h>

using namespace winrt;
using namespace Windows::Foundation;
using namespace Windows::System;
using namespace Windows::Storage;
using namespace Windows::Networking;
using namespace Windows::Networking::Sockets;
```

### 11.2.3 ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘

```cpp
#include <winrt/Windows.System.h>
#include <winrt/Windows.System.Diagnostics.h>
#include <winrt/Windows.ApplicationModel.h>
#include <iostream>
#include <iomanip>

using namespace winrt;
using namespace Windows::System;
using namespace Windows::System::Diagnostics;

class WinRTSystemInfo {
public:
    struct SystemResourceInfo {
        uint64_t totalPhysicalMemory;
        uint64_t availablePhysicalMemory;
        uint64_t totalVirtualMemory;
        uint64_t availableVirtualMemory;
        double cpuUsage;
        uint32_t processorCount;
    };

    static SystemResourceInfo GetSystemResources() {
        SystemResourceInfo info{};

        // ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
        auto memoryReport = MemoryManager::GetAppMemoryReport();
        info.totalPhysicalMemory = memoryReport.TotalCommitLimit();
        info.availablePhysicalMemory = memoryReport.AvailableCommitLimit();

        // í”„ë¡œì„¸ì„œ ì •ë³´
        info.processorCount = std::thread::hardware_concurrency();

        return info;
    }

    static void PrintSystemInfo() {
        std::wcout << L"\n=== System Information (WinRT) ===" << std::endl;

        // ë””ë°”ì´ìŠ¤ íŒ¨ë°€ë¦¬ ì •ë³´
        auto deviceFamily = Windows::System::Profile::AnalyticsInfo::VersionInfo().DeviceFamily();
        std::wcout << L"Device Family: " << std::wstring_view(deviceFamily) << std::endl;

        // í”„ë¡œì„¸ì„œ ì•„í‚¤í…ì²˜
        auto architecture = Windows::System::Profile::AnalyticsInfo::DeviceForm();
        std::wcout << L"Device Form: " << std::wstring_view(architecture) << std::endl;

        // ë©”ëª¨ë¦¬ ì •ë³´
        auto memoryReport = MemoryManager::GetAppMemoryReport();
        std::wcout << L"Current Memory Usage: " 
                   << (memoryReport.PrivateCommitUsage() / 1024 / 1024) << L" MB" << std::endl;
        std::wcout << L"Memory Usage Limit: " 
                   << (memoryReport.TotalCommitLimit() / 1024 / 1024) << L" MB" << std::endl;

        // ì „ë ¥ ìƒíƒœ
        auto powerManager = PowerManager::EnergySaverStatus();
        std::wcout << L"Energy Saver Status: ";
        switch (powerManager) {
        case EnergySaverStatus::Disabled:
            std::wcout << L"Disabled"; break;
        case EnergySaverStatus::Off:
            std::wcout << L"Off"; break;
        case EnergySaverStatus::On:
            std::wcout << L"On"; break;
        default:
            std::wcout << L"Unknown"; break;
        }
        std::wcout << std::endl;

        // ë°°í„°ë¦¬ ìƒíƒœ (ë…¸íŠ¸ë¶/íƒœë¸”ë¦¿ì˜ ê²½ìš°)
        auto batteryReport = PowerManager::BatteryStatus();
        std::wcout << L"Battery Status: ";
        switch (batteryReport) {
        case BatteryStatus::NotPresent:
            std::wcout << L"Not Present"; break;
        case BatteryStatus::Discharging:
            std::wcout << L"Discharging"; break;
        case BatteryStatus::Idle:
            std::wcout << L"Idle"; break;
        case BatteryStatus::Charging:
            std::wcout << L"Charging"; break;
        default:
            std::wcout << L"Unknown"; break;
        }
        std::wcout << std::endl;
    }

    // ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ì •ë³´ (UWP ì œí•œ ë‚´ì—ì„œ)
    static void PrintProcessDiagnostics() {
        std::wcout << L"\n=== Process Diagnostics ===" << std::endl;

        // í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ ì§„ë‹¨ ì •ë³´
        auto processInfo = ProcessDiagnosticInfo::GetForCurrentProcess();
        if (processInfo) {
            std::wcout << L"Process ID: " << processInfo.ProcessId() << std::endl;
            std::wcout << L"Executable Name: " 
                       << std::wstring_view(processInfo.ExecutableFileName()) << std::endl;

            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
            auto memoryUsage = processInfo.MemoryUsage();
            if (memoryUsage) {
                auto report = memoryUsage.GetReport();
                std::wcout << L"Working Set: " 
                           << (report.WorkingSetSizeInBytes() / 1024 / 1024) << L" MB" << std::endl;
                std::wcout << L"Private Memory: " 
                           << (report.PrivateWorkingSetSizeInBytes() / 1024 / 1024) << L" MB" << std::endl;
                std::wcout << L"Virtual Memory: " 
                           << (report.VirtualMemorySizeInBytes() / 1024 / 1024) << L" MB" << std::endl;
            }

            // CPU ì‚¬ìš©ëŸ‰
            auto cpuUsage = processInfo.CpuUsage();
            if (cpuUsage) {
                auto report = cpuUsage.GetReport();
                auto kernelTime = report.KernelTime().count();
                auto userTime = report.UserTime().count();
                
                std::wcout << L"Kernel Time: " << kernelTime << L" ticks" << std::endl;
                std::wcout << L"User Time: " << userTime << L" ticks" << std::endl;
            }

            // ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰
            auto diskUsage = processInfo.DiskUsage();
            if (diskUsage) {
                auto report = diskUsage.GetReport();
                std::wcout << L"Bytes Read: " << report.BytesReadCount() << std::endl;
                std::wcout << L"Bytes Written: " << report.BytesWrittenCount() << std::endl;
                std::wcout << L"Read Operations: " << report.ReadOperationCount() << std::endl;
                std::wcout << L"Write Operations: " << report.WriteOperationCount() << std::endl;
            }
        }
    }
};
```
   
ì´ ì½”ë“œëŠ” **Windows 10 ì´í›„ì˜ WinRT(Windows Runtime) APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹œìŠ¤í…œì˜ ìì› ë° í”„ë¡œì„¸ìŠ¤ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ëŠ” ì˜ˆì œ**ì´ë‹¤.
ê²Œì„ ì„œë²„ë‚˜ ë°ìŠ¤í¬í†± ì• í”Œë¦¬ì¼€ì´ì…˜, ë˜ëŠ” UWP ì•±ì—ì„œ **í˜„ì¬ ì¥ì¹˜ì˜ ì„±ëŠ¥ ìƒíƒœë‚˜ ë¦¬ì†ŒìŠ¤ ì ìœ ìœ¨ì„ í™•ì¸í•˜ê¸° ìœ„í•´** ì‚¬ìš©í•œë‹¤.

ì¦‰, ì´ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì—ì„œ ìœ ìš©í•˜ë‹¤.

* ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ í™˜ê²½(ì˜ˆ: PC, ë…¸íŠ¸ë¶, íƒœë¸”ë¦¿)ì— ë”°ë¥¸ ë™ì‘ ìµœì í™”ê°€ í•„ìš”í•  ë•Œ
* ë©”ëª¨ë¦¬, CPU, ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ì„ ëª¨ë‹ˆí„°ë§í•˜ì—¬ ì„±ëŠ¥ íŠœë‹ì„ í•˜ê³  ì‹¶ì„ ë•Œ
* ë°°í„°ë¦¬ë‚˜ ì „ë ¥ ìƒíƒœì— ë”°ë¼ ë™ì‘ ëª¨ë“œë¥¼ ë‹¤ë¥´ê²Œ í•˜ê³  ì‹¶ì„ ë•Œ


#### 1ï¸âƒ£ í´ë˜ìŠ¤ êµ¬ì¡°ì™€ ì—­í• 
ì½”ë“œëŠ” `WinRTSystemInfo`ë¼ëŠ” í´ë˜ìŠ¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°, ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ì™€ í”„ë¡œì„¸ìŠ¤ ìƒíƒœë¥¼ ì½ëŠ” ì—¬ëŸ¬ ì •ì  ë©”ì„œë“œë¥¼ ì œê³µí•œë‹¤.

```cpp
class WinRTSystemInfo {
public:
    struct SystemResourceInfo {
        uint64_t totalPhysicalMemory;
        uint64_t availablePhysicalMemory;
        uint64_t totalVirtualMemory;
        uint64_t availableVirtualMemory;
        double cpuUsage;
        uint32_t processorCount;
    };

    static SystemResourceInfo GetSystemResources();
    static void PrintSystemInfo();
    static void PrintProcessDiagnostics();
};
```

ì´ í´ë˜ìŠ¤ì˜ ê´€ê³„ë¥¼ ë„ì‹í™”í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```mermaid
classDiagram
    class WinRTSystemInfo {
        +GetSystemResources() : SystemResourceInfo
        +PrintSystemInfo() : void
        +PrintProcessDiagnostics() : void
    }

    class SystemResourceInfo {
        +uint64_t totalPhysicalMemory
        +uint64_t availablePhysicalMemory
        +uint64_t totalVirtualMemory
        +uint64_t availableVirtualMemory
        +double cpuUsage
        +uint32_t processorCount
    }

    WinRTSystemInfo --> SystemResourceInfo
```


#### 2ï¸âƒ£ ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì •ë³´ ìˆ˜ì§‘ (`GetSystemResources`)

```cpp
static SystemResourceInfo GetSystemResources() {
    SystemResourceInfo info{};

    auto memoryReport = MemoryManager::GetAppMemoryReport();
    info.totalPhysicalMemory = memoryReport.TotalCommitLimit();
    info.availablePhysicalMemory = memoryReport.AvailableCommitLimit();
    info.processorCount = std::thread::hardware_concurrency();

    return info;
}
```

ì´ í•¨ìˆ˜ëŠ” **í˜„ì¬ ì‹œìŠ¤í…œì˜ ë©”ëª¨ë¦¬ì™€ CPU ì •ë³´ë¥¼ ìˆ˜ì§‘**í•œë‹¤.

* `MemoryManager::GetAppMemoryReport()` : í˜„ì¬ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš© í•œë„ì™€ ë‚¨ì€ ì–‘ì„ ë°˜í™˜í•œë‹¤.
* `std::thread::hardware_concurrency()` : ì‹œìŠ¤í…œì˜ CPU(ë…¼ë¦¬ ì½”ì–´) ê°œìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤.

ì´ í•¨ìˆ˜ëŠ” `SystemResourceInfo` êµ¬ì¡°ì²´ë¥¼ ë°˜í™˜í•˜ì—¬, ë‹¤ë¥¸ ì½”ë“œì—ì„œ ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ìƒíƒœë¥¼ ì‰½ê²Œ ì°¸ì¡°í•  ìˆ˜ ìˆê²Œ í•œë‹¤.

ASCII íë¦„ë„ë¡œ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```
[GetSystemResources()]
     â”‚
     â”œâ”€> [ë©”ëª¨ë¦¬ ë³´ê³ ì„œ ìˆ˜ì§‘]
     â”‚       â”œâ”€ TotalCommitLimit()
     â”‚       â””â”€ AvailableCommitLimit()
     â”‚
     â””â”€> [CPU ê°œìˆ˜ í™•ì¸ â†’ hardware_concurrency()]
```


#### 3ï¸âƒ£ ì‹œìŠ¤í…œ ì •ë³´ ì¶œë ¥ (`PrintSystemInfo`)

ì´ í•¨ìˆ˜ëŠ” **ì¥ì¹˜ì™€ ìš´ì˜ì²´ì œ ê´€ë ¨ ì •ë³´ë¥¼ ì½˜ì†”ì— ì¶œë ¥**í•œë‹¤.

```cpp
static void PrintSystemInfo() {
    std::wcout << L"\n=== System Information (WinRT) ===" << std::endl;

    // ë””ë°”ì´ìŠ¤ íŒ¨ë°€ë¦¬ (Desktop, Mobile ë“±)
    auto deviceFamily = Windows::System::Profile::AnalyticsInfo::VersionInfo().DeviceFamily();
    std::wcout << L"Device Family: " << std::wstring_view(deviceFamily) << std::endl;

    // ì¥ì¹˜ í˜•íƒœ (Desktop, Tablet ë“±)
    auto architecture = Windows::System::Profile::AnalyticsInfo::DeviceForm();
    std::wcout << L"Device Form: " << std::wstring_view(architecture) << std::endl;
```

ì´ ë¶€ë¶„ì—ì„œëŠ” **ê¸°ê¸°ì˜ ì¢…ë¥˜(ì˜ˆ: Desktop, Xbox, HoloLens ë“±)**ë¥¼ ì‹ë³„í•œë‹¤.
`AnalyticsInfo::VersionInfo()`ì™€ `DeviceForm()`ì€ WinRTì—ì„œ ì¥ì¹˜ í˜•íƒœë¥¼ ì‹ë³„í•˜ëŠ” ë° ìì£¼ ì“°ì´ëŠ” APIë‹¤.

ë‹¤ìŒì€ ë©”ëª¨ë¦¬ ë° ì „ì› ê´€ë ¨ ì •ë³´ ì¶œë ¥ ë¶€ë¶„ì´ë‹¤.

```cpp
    auto memoryReport = MemoryManager::GetAppMemoryReport();
    std::wcout << L"Current Memory Usage: " 
               << (memoryReport.PrivateCommitUsage() / 1024 / 1024) << L" MB" << std::endl;
    std::wcout << L"Memory Usage Limit: " 
               << (memoryReport.TotalCommitLimit() / 1024 / 1024) << L" MB" << std::endl;
```

* `PrivateCommitUsage()` : í˜„ì¬ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ì‚¬ìš©í•˜ëŠ” ë¬¼ë¦¬ì  ë©”ëª¨ë¦¬ì˜ ì–‘ì´ë‹¤.
* `TotalCommitLimit()` : ì‹œìŠ¤í…œì´ í—ˆìš©í•˜ëŠ” ìµœëŒ€ ë©”ëª¨ë¦¬ í•œë„ì´ë‹¤.

ì „ë ¥ ìƒíƒœì™€ ë°°í„°ë¦¬ ìƒíƒœë„ í•¨ê»˜ ì¶œë ¥í•œë‹¤.

```cpp
    auto powerManager = PowerManager::EnergySaverStatus();
    std::wcout << L"Energy Saver Status: ..."

    auto batteryReport = PowerManager::BatteryStatus();
    std::wcout << L"Battery Status: ..."
```

ì´ ë¶€ë¶„ì€ **ì „ë ¥ ì ˆì•½ ëª¨ë“œ ì—¬ë¶€**ì™€ **ë°°í„°ë¦¬ ì¶©ì „ ìƒíƒœ**ë¥¼ ë³´ì—¬ì¤€ë‹¤.
ì´ë¥¼ í†µí•´ í”„ë¡œê·¸ë¨ì´ â€œì ˆì „ ëª¨ë“œì—ì„œëŠ” ë¬´ê±°ìš´ ì‘ì—…ì„ í”¼í•´ì•¼ê² ë‹¤â€ ê°™ì€ ê²°ì •ì„ ë‚´ë¦´ ìˆ˜ ìˆë‹¤.


#### 4ï¸âƒ£ í”„ë¡œì„¸ìŠ¤ ì§„ë‹¨ ì •ë³´ (`PrintProcessDiagnostics`)
ì´ í•¨ìˆ˜ëŠ” **í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ í”„ë¡œì„¸ìŠ¤ì˜ ìƒì„¸ ì§„ë‹¨ ì •ë³´ë¥¼ ì¶œë ¥**í•œë‹¤.

```cpp
auto processInfo = ProcessDiagnosticInfo::GetForCurrentProcess();
if (processInfo) {
    std::wcout << L"Process ID: " << processInfo.ProcessId() << std::endl;
    std::wcout << L"Executable Name: " 
               << std::wstring_view(processInfo.ExecutableFileName()) << std::endl;
```

ë¨¼ì €, `GetForCurrentProcess()`ë¥¼ í†µí•´ í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ í•¸ë“¤ì„ ê°€ì ¸ì˜¨ë‹¤.
ê·¸ë‹¤ìŒ ë©”ëª¨ë¦¬, CPU, ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ì„ ê°ê° ì¶œë ¥í•œë‹¤.
  
##### ğŸ§  ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰

```cpp
auto report = memoryUsage.GetReport();
std::wcout << L"Working Set: " << (report.WorkingSetSizeInBytes() / 1024 / 1024) << L" MB";
std::wcout << L"Private Memory: " << (report.PrivateWorkingSetSizeInBytes() / 1024 / 1024) << L" MB";
std::wcout << L"Virtual Memory: " << (report.VirtualMemorySizeInBytes() / 1024 / 1024) << L" MB";
```

* **Working Set**: í˜„ì¬ í”„ë¡œì„¸ìŠ¤ê°€ ì‹¤ì œë¡œ ì‚¬ìš©í•˜ëŠ” ë¬¼ë¦¬ ë©”ëª¨ë¦¬
* **Private Memory**: ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì™€ ê³µìœ í•˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬
* **Virtual Memory**: ê°€ìƒ ë©”ëª¨ë¦¬ ê³µê°„ í¬ê¸°
  
##### âš™ï¸ CPU ì‚¬ìš©ëŸ‰

```cpp
auto report = cpuUsage.GetReport();
auto kernelTime = report.KernelTime().count();
auto userTime = report.UserTime().count();
```

* **Kernel Time**: ìš´ì˜ì²´ì œ ì»¤ë„ì—ì„œ ì‹¤í–‰ëœ CPU ì‹œê°„
* **User Time**: ì‚¬ìš©ì ì½”ë“œì—ì„œ ì‚¬ìš©ëœ CPU ì‹œê°„

ì´ ë‘ ìˆ˜ì¹˜ë¥¼ í†µí•´ í”„ë¡œê·¸ë¨ì´ CPU ìì›ì„ ì–¼ë§ˆë‚˜ ì ìœ í•˜ê³  ìˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆë‹¤.
  
##### ğŸ’¾ ë””ìŠ¤í¬ I/O ì‚¬ìš©ëŸ‰

```cpp
auto report = diskUsage.GetReport();
std::wcout << L"Bytes Read: " << report.BytesReadCount();
std::wcout << L"Bytes Written: " << report.BytesWrittenCount();
```

* **BytesReadCount / BytesWrittenCount**: íŒŒì¼ ì…ì¶œë ¥ëŸ‰ì„ ë‚˜íƒ€ë‚¸ë‹¤.
  ì´ëŠ” ê²Œì„ ì„œë²„ì˜ ë¡œë”© ì‹œìŠ¤í…œì´ë‚˜ ë°ì´í„°ë² ì´ìŠ¤ I/O ì„±ëŠ¥ ì ê²€ì— ìœ ìš©í•˜ë‹¤.

  
#### âœ… ì •ë¦¬

| í•­ëª©                          | ê¸°ëŠ¥                                |
| --------------------------- | --------------------------------- |
| **GetSystemResources**      | CPU ê°œìˆ˜ì™€ ë©”ëª¨ë¦¬ ì‚¬ìš© í•œë„ë¥¼ ìˆ˜ì§‘í•œë‹¤           |
| **PrintSystemInfo**         | ì¥ì¹˜ ì¢…ë¥˜, ë©”ëª¨ë¦¬, ì „ë ¥, ë°°í„°ë¦¬ ìƒíƒœë¥¼ ì¶œë ¥í•œë‹¤      |
| **PrintProcessDiagnostics** | í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬Â·CPUÂ·ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ì„ ìƒì„¸ ì¶œë ¥í•œë‹¤ |
| **í™œìš© ëª©ì **                   | ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§, ìì› ì œí•œ ê°ì§€, ìµœì í™” ê¸°ì¤€ ë°ì´í„° í™•ë³´  |

  
#### ğŸ’¡ ì „ì²´ ë™ì‘ íë¦„ ìš”ì•½

```mermaid
flowchart TD
    A[Start] --> B[GetSystemResources()]
    B --> C[PrintSystemInfo()]
    C --> D[PrintProcessDiagnostics()]
    D --> E[Display All Information in Console]
```

ì´ ì½”ë“œëŠ” **Windows í™˜ê²½ì—ì„œ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì‹¤í–‰ í™˜ê²½ì„ ì •ëŸ‰ì ìœ¼ë¡œ íŒŒì•…í•˜ê¸° ìœ„í•œ ê¸°ë³¸ ë„êµ¬**ì´ë‹¤.
ì´ë¥¼ ì´ìš©í•˜ë©´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë‚˜ ê³¼ë„í•œ CPU ì ìœ  ê°™ì€ ë¬¸ì œë¥¼ ì‚¬ì „ì— íŒŒì•…í•˜ê³ , **ì•ˆì •ì ì¸ ì‹œìŠ¤í…œ ì„±ëŠ¥ ìœ ì§€ì— ë„ì›€ì„ ì¤„ ìˆ˜ ìˆë‹¤**.
  
  

### 11.2.4 ë„¤íŠ¸ì›Œí¬ ê´€ë ¨ WinRT API

```cpp
#include <winrt/Windows.Networking.h>
#include <winrt/Windows.Networking.Connectivity.h>
#include <winrt/Windows.Web.Http.h>

using namespace Windows::Networking;
using namespace Windows::Networking::Connectivity;
using namespace Windows::Web::Http;

class WinRTNetworkManager {
public:
    struct NetworkInfo {
        std::wstring profileName;
        std::wstring adapterType;
        bool isConnected;
        bool isWwanConnection;
        bool isWlanConnection;
        NetworkConnectivityLevel connectivityLevel;
        uint64_t inboundBits;
        uint64_t outboundBits;
    };

    static std::vector<NetworkInfo> GetNetworkProfiles() {
        std::vector<NetworkInfo> profiles;

        try {
            auto networkProfiles = NetworkInformation::GetConnectionProfiles();
            
            for (auto profile : networkProfiles) {
                NetworkInfo info;
                
                // í”„ë¡œí•„ ì´ë¦„
                if (profile.ProfileName().empty()) {
                    info.profileName = L"Unknown";
                } else {
                    info.profileName = profile.ProfileName().c_str();
                }

                // ì—°ê²° ìƒíƒœ
                info.connectivityLevel = profile.GetNetworkConnectivityLevel();
                info.isConnected = (info.connectivityLevel == NetworkConnectivityLevel::InternetAccess);

                // ì–´ëŒ‘í„° ì •ë³´
                auto adapter = profile.NetworkAdapter();
                if (adapter) {
                    info.adapterType = std::wstring(adapter.NetworkAdapterId().c_str());
                    
                    // ì—°ê²° íƒ€ì… í™•ì¸
                    info.isWwanConnection = profile.IsWwanConnectionProfile();
                    info.isWlanConnection = profile.IsWlanConnectionProfile();
                }

                // ë°ì´í„° ì‚¬ìš©ëŸ‰ (ê°€ëŠ¥í•œ ê²½ìš°)
                auto dataUsage = profile.GetLocalUsage(
                    DateTime::clock::now() - std::chrono::hours(24),  // 24ì‹œê°„ ì „ë¶€í„°
                    DateTime::clock::now());                           // í˜„ì¬ê¹Œì§€
                
                if (dataUsage) {
                    info.inboundBits = dataUsage.BytesReceived();
                    info.outboundBits = dataUsage.BytesSent();
                }

                profiles.push_back(info);
            }
        }
        catch (hresult_error const& ex) {
            std::wcout << L"Error getting network profiles: " 
                       << std::wstring_view(ex.message()) << std::endl;
        }

        return profiles;
    }

    static void PrintNetworkInfo() {
        std::wcout << L"\n=== Network Information (WinRT) ===" << std::endl;

        auto profiles = GetNetworkProfiles();
        
        for (const auto& profile : profiles) {
            std::wcout << L"Profile: " << profile.profileName << std::endl;
            std::wcout << L"Connected: " << (profile.isConnected ? L"Yes" : L"No") << std::endl;
            std::wcout << L"WLAN: " << (profile.isWlanConnection ? L"Yes" : L"No") << std::endl;
            std::wcout << L"WWAN: " << (profile.isWwanConnection ? L"Yes" : L"No") << std::endl;
            
            std::wcout << L"Connectivity Level: ";
            switch (profile.connectivityLevel) {
            case NetworkConnectivityLevel::None:
                std::wcout << L"None"; break;
            case NetworkConnectivityLevel::LocalAccess:
                std::wcout << L"Local Access"; break;
            case NetworkConnectivityLevel::ConstrainedInternetAccess:
                std::wcout << L"Constrained Internet"; break;
            case NetworkConnectivityLevel::InternetAccess:
                std::wcout << L"Internet Access"; break;
            }
            std::wcout << std::endl;

            if (profile.inboundBits > 0 || profile.outboundBits > 0) {
                std::wcout << L"Data Usage (24h): " 
                           << L"Received=" << (profile.inboundBits / 1024 / 1024) << L"MB, "
                           << L"Sent=" << (profile.outboundBits / 1024 / 1024) << L"MB" 
                           << std::endl;
            }
            
            std::wcout << std::wstring(50, L'-') << std::endl;
        }
    }

    // ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€ê²½ ëª¨ë‹ˆí„°ë§
    static void StartNetworkMonitoring() {
        std::wcout << L"Starting network monitoring..." << std::endl;

        // ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ ë“±ë¡
        NetworkInformation::NetworkStatusChanged([](auto const&) {
            std::wcout << L"[" << GetCurrentTimeString() << L"] "
                       << L"Network status changed!" << std::endl;
            
            // ê°„ë‹¨í•œ ì—°ê²° ìƒíƒœ ì²´í¬
            auto profiles = GetNetworkProfiles();
            bool hasInternet = false;
            
            for (const auto& profile : profiles) {
                if (profile.connectivityLevel == NetworkConnectivityLevel::InternetAccess) {
                    hasInternet = true;
                    break;
                }
            }
            
            std::wcout << L"Internet Access: " << (hasInternet ? L"Available" : L"Not Available") 
                       << std::endl;
        });

        std::wcout << L"Network monitoring started. Press Enter to stop..." << std::endl;
        std::cin.get();
    }

private:
    static std::wstring GetCurrentTimeString() {
        SYSTEMTIME st;
        GetLocalTime(&st);
        
        wchar_t timeStr[64];
        swprintf_s(timeStr, L"%02d:%02d:%02d", st.wHour, st.wMinute, st.wSecond);
        return timeStr;
    }
};
```
    
ì´ ì½”ë“œëŠ” **Windows 10 ì´ìƒì˜ í™˜ê²½ì—ì„œ WinRT(Windows Runtime) APIë¥¼ ì‚¬ìš©í•˜ì—¬ ë„¤íŠ¸ì›Œí¬ ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ê³  ëª¨ë‹ˆí„°ë§í•˜ëŠ” í”„ë¡œê·¸ë¨**ì´ë‹¤.
ì¦‰, ì»´í“¨í„°ê°€ ì–´ë–¤ ë„¤íŠ¸ì›Œí¬ì— ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€, ë¬´ì„ (WLAN)ì¸ì§€ ì´ë™í†µì‹ (WWAN)ì¸ì§€, ì¸í„°ë„·ì— ì ‘ê·¼ ê°€ëŠ¥í•œ ìƒíƒœì¸ì§€ ë“±ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

ë˜í•œ, **ìµœê·¼ 24ì‹œê°„ ë™ì•ˆì˜ ë°ì´í„° ì‚¬ìš©ëŸ‰(ì†¡ì‹ /ìˆ˜ì‹ ëŸ‰)**ì„ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìœ¼ë©°, ë„¤íŠ¸ì›Œí¬ ìƒíƒœê°€ ë³€ê²½ë  ë•Œ ì´ë²¤íŠ¸ë¥¼ ë°›ì•„ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ ë°˜ì‘í•  ìˆ˜ë„ ìˆë‹¤.
ì´ ì½”ë“œëŠ” **ì„œë²„ë‚˜ í´ë¼ì´ì–¸íŠ¸ í”„ë¡œê·¸ë¨ì´ ë„¤íŠ¸ì›Œí¬ ìƒíƒœì— ë”°ë¼ ë™ì‘ì„ ë‹¤ë¥´ê²Œ í•´ì•¼ í•  ë•Œ** ìœ ìš©í•˜ê²Œ ì‚¬ìš©ëœë‹¤.


#### 1ï¸âƒ£ í´ë˜ìŠ¤ êµ¬ì¡° ë° ì—­í• 

```cpp
class WinRTNetworkManager {
public:
    struct NetworkInfo { ... };
    static std::vector<NetworkInfo> GetNetworkProfiles();
    static void PrintNetworkInfo();
    static void StartNetworkMonitoring();
private:
    static std::wstring GetCurrentTimeString();
};
```

`WinRTNetworkManager`ëŠ” ë„¤íŠ¸ì›Œí¬ ê´€ë ¨ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ê³  ì¶œë ¥í•˜ë©°, ìƒíƒœ ë³€í™”ë¥¼ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ê¸°ëŠ¥ì„ ê°€ì§„ë‹¤.

ê° êµ¬ì„±ì˜ ì—­í• ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

| êµ¬ì„± ìš”ì†Œ                      | ì—­í•                       |
| -------------------------- | ----------------------- |
| `NetworkInfo`              | ë„¤íŠ¸ì›Œí¬ í”„ë¡œí•„(ì—°ê²°) ì •ë³´ë¥¼ ë‹´ëŠ” êµ¬ì¡°ì²´ |
| `GetNetworkProfiles()`     | ì‹œìŠ¤í…œì˜ ëª¨ë“  ë„¤íŠ¸ì›Œí¬ í”„ë¡œí•„ì„ ê°€ì ¸ì˜´   |
| `PrintNetworkInfo()`       | ë„¤íŠ¸ì›Œí¬ ì •ë³´ë¥¼ ì½˜ì†”ì— ì¶œë ¥í•¨        |
| `StartNetworkMonitoring()` | ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•¨     |
| `GetCurrentTimeString()`   | í˜„ì¬ ì‹œê°„ì„ ë¬¸ìì—´ë¡œ ë°˜í™˜í•¨         |

ì•„ë˜ëŠ” í´ë˜ìŠ¤ êµ¬ì„±ì˜ ë‹¤ì´ì–´ê·¸ë¨ì´ë‹¤.

```mermaid
classDiagram
    class WinRTNetworkManager {
        +GetNetworkProfiles() : vector<NetworkInfo>
        +PrintNetworkInfo() : void
        +StartNetworkMonitoring() : void
        -GetCurrentTimeString() : wstring
    }

    class NetworkInfo {
        +wstring profileName
        +wstring adapterType
        +bool isConnected
        +bool isWwanConnection
        +bool isWlanConnection
        +NetworkConnectivityLevel connectivityLevel
        +uint64_t inboundBits
        +uint64_t outboundBits
    }

    WinRTNetworkManager --> NetworkInfo
```


#### 2ï¸âƒ£ ë„¤íŠ¸ì›Œí¬ í”„ë¡œí•„ ì •ë³´ ìˆ˜ì§‘ (`GetNetworkProfiles`)

```cpp
auto networkProfiles = NetworkInformation::GetConnectionProfiles();
```

ì´ ì½”ë“œëŠ” ì‹œìŠ¤í…œì— ì¡´ì¬í•˜ëŠ” ëª¨ë“  ë„¤íŠ¸ì›Œí¬ ì—°ê²° í”„ë¡œí•„ì„ ê°€ì ¸ì˜¨ë‹¤.
ê° í”„ë¡œí•„ì€ ìœ ì„ (LAN), ë¬´ì„ (Wi-Fi), ì´ë™í†µì‹ (WWAN) ë“±ì˜ ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ ì˜ë¯¸í•œë‹¤.
  
##### ğŸ’¡ ë„¤íŠ¸ì›Œí¬ í”„ë¡œí•„ ì •ë³´ ìˆ˜ì§‘ ê³¼ì •

1. `ProfileName()`ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ ì´ë¦„(SSID ë“±)ì„ ê°€ì ¸ì˜¨ë‹¤.
2. `GetNetworkConnectivityLevel()`ë¡œ ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•œë‹¤.

   * `InternetAccess`: ì¸í„°ë„·ì— ì—°ê²°ë¨
   * `LocalAccess`: ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ë§Œ ì—°ê²°ë¨
   * `None`: ì—°ê²°ë˜ì§€ ì•ŠìŒ
3. `NetworkAdapter()`ë¥¼ í†µí•´ ì–´ëŒ‘í„° ì •ë³´(ë¬¼ë¦¬ ì¥ì¹˜) ì ‘ê·¼
4. `IsWlanConnectionProfile()` / `IsWwanConnectionProfile()`ë¡œ ë¬´ì„ /ì´ë™í†µì‹  ì—¬ë¶€ í™•ì¸
5. `GetLocalUsage()`ë¡œ 24ì‹œê°„ ë™ì•ˆ ì†¡ì‹ /ìˆ˜ì‹ ëœ ë°ì´í„°ëŸ‰ì„ ì¡°íšŒ

ì´ ê³¼ì •ì„ ASCII íë¦„ë„ë¡œ í‘œí˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```
[GetConnectionProfiles()]
       â”‚
       â”œâ”€> ProfileName() â”€â”€â”€> ë„¤íŠ¸ì›Œí¬ ì´ë¦„
       â”œâ”€> GetNetworkConnectivityLevel() â”€â”€â”€> ì—°ê²° ìƒíƒœ
       â”œâ”€> NetworkAdapter() â”€â”€â”€> ì–´ëŒ‘í„° íƒ€ì…
       â”œâ”€> IsWlanConnectionProfile() â”€â”€â”€> ë¬´ì„  ì—¬ë¶€
       â”œâ”€> IsWwanConnectionProfile() â”€â”€â”€> ì´ë™í†µì‹  ì—¬ë¶€
       â””â”€> GetLocalUsage() â”€â”€â”€> ë°ì´í„° ì‚¬ìš©ëŸ‰(24ì‹œê°„)
```


#### 3ï¸âƒ£ ë„¤íŠ¸ì›Œí¬ ì •ë³´ ì¶œë ¥ (`PrintNetworkInfo`)

```cpp
auto profiles = GetNetworkProfiles();

for (const auto& profile : profiles) {
    std::wcout << L"Profile: " << profile.profileName << std::endl;
    std::wcout << L"Connected: " << (profile.isConnected ? L"Yes" : L"No") << std::endl;
    std::wcout << L"WLAN: " << (profile.isWlanConnection ? L"Yes" : L"No") << std::endl;
    std::wcout << L"WWAN: " << (profile.isWwanConnection ? L"Yes" : L"No") << std::endl;
```

ì´ ë¶€ë¶„ì€ **ê°€ì ¸ì˜¨ ë„¤íŠ¸ì›Œí¬ í”„ë¡œí•„ì„ í•˜ë‚˜ì”© ì¶œë ¥**í•œë‹¤.
ë„¤íŠ¸ì›Œí¬ê°€ ì¸í„°ë„·ì— ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€, ë¬´ì„ ì¸ì§€, ì´ë™í†µì‹ ì¸ì§€ ë“±ì„ í‘œì‹œí•œë‹¤.

ë‹¤ìŒìœ¼ë¡œ ì—°ê²° ìˆ˜ì¤€(`NetworkConnectivityLevel`)ì„ í•´ì„í•´ì„œ ë¬¸ìì—´ë¡œ ì¶œë ¥í•œë‹¤.

```cpp
switch (profile.connectivityLevel) {
    case NetworkConnectivityLevel::None:
        std::wcout << L"None"; break;
    case NetworkConnectivityLevel::LocalAccess:
        std::wcout << L"Local Access"; break;
    case NetworkConnectivityLevel::InternetAccess:
        std::wcout << L"Internet Access"; break;
}
```

ë§ˆì§€ë§‰ìœ¼ë¡œ 24ì‹œê°„ ë™ì•ˆì˜ ë°ì´í„° ì‚¬ìš©ëŸ‰ì„ MB ë‹¨ìœ„ë¡œ ë³´ì—¬ì¤€ë‹¤.

```cpp
std::wcout << L"Data Usage (24h): "
           << L"Received=" << (profile.inboundBits / 1024 / 1024) << L"MB, "
           << L"Sent=" << (profile.outboundBits / 1024 / 1024) << L"MB";
```

  
#### 4ï¸âƒ£ ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€ê²½ ëª¨ë‹ˆí„°ë§ (`StartNetworkMonitoring`)

```cpp
NetworkInformation::NetworkStatusChanged([](auto const&) {
    std::wcout << L"Network status changed!" << std::endl;
});
```

ì´ ì½”ë“œëŠ” **ì´ë²¤íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™”ë¥¼ ê°ì§€**í•œë‹¤.
ì¦‰, ì¸í„°ë„· ì—°ê²°ì´ ëŠê¸°ê±°ë‚˜ Wi-Fiê°€ ë³€ê²½ë  ë•Œ ìë™ìœ¼ë¡œ í˜¸ì¶œëœë‹¤.

ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ë©´ ë‹¤ìŒ ìˆœì„œë¡œ ë™ì‘í•œë‹¤.

1. í˜„ì¬ ì‹œê° ì¶œë ¥
2. ë‹¤ì‹œ `GetNetworkProfiles()`ë¥¼ í˜¸ì¶œí•˜ì—¬ ìµœì‹  ìƒíƒœ í™•ì¸
3. ì¸í„°ë„· ì ‘ê·¼ ê°€ëŠ¥ ì—¬ë¶€(`InternetAccess`) íŒë‹¨
4. ê²°ê³¼ë¥¼ ì½˜ì†”ì— ì¶œë ¥

  
ì´ ê¸°ëŠ¥ì€ ì˜ˆë¥¼ ë“¤ì–´ **ì„œë²„ê°€ ìë™ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ ë³µêµ¬ë¥¼ ê°ì§€í•´ì•¼ í•˜ëŠ” ê²½ìš°**ì— ìœ ìš©í•˜ë‹¤.


#### 5ï¸âƒ£ í˜„ì¬ ì‹œê°„ ë¬¸ìì—´ (`GetCurrentTimeString`)

```cpp
SYSTEMTIME st;
GetLocalTime(&st);
swprintf_s(timeStr, L"%02d:%02d:%02d", st.wHour, st.wMinute, st.wSecond);
```

ì´ í•¨ìˆ˜ëŠ” ë¡œê·¸ ì¶œë ¥ìš©ìœ¼ë¡œ í˜„ì¬ ì‹œê°„ì„ `HH:MM:SS` í˜•íƒœë¡œ ë°˜í™˜í•œë‹¤.
ë„¤íŠ¸ì›Œí¬ ë³€ê²½ ì‹œì ì„ ë¡œê·¸ë¡œ ë‚¨ê¸¸ ë•Œ ì‚¬ìš©ëœë‹¤.

  
#### âœ… ì •ë¦¬

| êµ¬ë¶„                           | ì„¤ëª…                          |
| ---------------------------- | --------------------------- |
| **GetNetworkProfiles()**     | ë„¤íŠ¸ì›Œí¬ í”„ë¡œí•„ê³¼ ì—°ê²° ìƒíƒœë¥¼ ìˆ˜ì§‘í•œë‹¤       |
| **PrintNetworkInfo()**       | ìˆ˜ì§‘ëœ ë„¤íŠ¸ì›Œí¬ ì •ë³´ë¥¼ ì½˜ì†”ì— ë³´ê¸° ì¢‹ê²Œ ì¶œë ¥í•œë‹¤ |
| **StartNetworkMonitoring()** | ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™”ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì‹œí•œë‹¤      |
| **GetCurrentTimeString()**   | ë¡œê·¸ìš© ì‹œê°„ ë¬¸ìì—´ì„ ìƒì„±í•œë‹¤            |

  
#### ğŸ’¡ ì „ì²´ êµ¬ì¡° ìš”ì•½

```mermaid
flowchart TD
    A["Start"] --> B["GetNetworkProfiles()"]
    B --> C["PrintNetworkInfo()"]
    C --> D["StartNetworkMonitoring()"]
    D --> E["NetworkStatusChanged ì´ë²¤íŠ¸ ê°ì§€"]
    E --> F["ìƒíƒœ ì¶œë ¥ ë° ì¸í„°ë„· ì—°ê²° ì¬í™•ì¸"]
```
  

ì´ í”„ë¡œê·¸ë¨ì€ **WinRT APIë¥¼ í™œìš©í•˜ì—¬ ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ ì‰½ê²Œ ê°ì‹œí•  ìˆ˜ ìˆëŠ” ì‹¤ìŠµ ì˜ˆì œ**ì´ë‹¤.
ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œëŠ” ì´ ì½”ë“œë¥¼ ì‘ìš©í•˜ì—¬

* ì—°ê²°ì´ ëŠê¸°ë©´ ì¬ì‹œë„ ë¡œì§ ìˆ˜í–‰,
* ë°ì´í„° ì‚¬ìš©ëŸ‰ì´ ë§ìœ¼ë©´ ê²½ê³  ì¶œë ¥,
* ëª¨ë°”ì¼ í™˜ê²½ì—ì„œëŠ” ì ˆì „ ëª¨ë“œ ì „í™˜

ê°™ì€ ê¸°ëŠ¥ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

ì¦‰, ì´ ì½”ë“œëŠ” **â€œë„¤íŠ¸ì›Œí¬ ìƒíƒœì— ë”°ë¼ ìœ ì—°í•˜ê²Œ ë°˜ì‘í•˜ëŠ” ìŠ¤ë§ˆíŠ¸í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“œëŠ” ê¸°ì´ˆâ€**ê°€ ë˜ëŠ” ì˜ˆì œì´ë‹¤.
  
  
</br>  

## 11.3 Windows Runtime ì¸í„°í˜ì´ìŠ¤

### 11.3.1 ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°
WinRTì˜ ê°•ë ¥í•œ ê¸°ëŠ¥ ì¤‘ í•˜ë‚˜ëŠ” ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ì§€ì›ì´ë‹¤:

```cpp
#include <winrt/Windows.Web.Http.h>
#include <winrt/Windows.Storage.h>
#include <winrt/Windows.Storage.Streams.h>

using namespace Windows::Web::Http;
using namespace Windows::Storage;
using namespace Windows::Storage::Streams;

class AsyncGameServerUtils {
public:
    // HTTP ìš”ì²­ì„ í†µí•œ ì„œë²„ ìƒíƒœ ì²´í¬
    static IAsyncOperation<bool> CheckServerStatusAsync(std::wstring const& serverUrl) {
        try {
            HttpClient httpClient;
            auto uri = Uri(serverUrl);
            
            auto response = co_await httpClient.GetAsync(uri);
            
            if (response.IsSuccessStatusCode()) {
                auto content = co_await response.Content().ReadAsStringAsync();
                std::wcout << L"Server Response: " << std::wstring_view(content) << std::endl;
                co_return true;
            } else {
                std::wcout << L"Server Error: " << static_cast<int>(response.StatusCode()) << std::endl;
                co_return false;
            }
        }
        catch (hresult_error const& ex) {
            std::wcout << L"HTTP Error: " << std::wstring_view(ex.message()) << std::endl;
            co_return false;
        }
    }

    // íŒŒì¼ ë¹„ë™ê¸° ì½ê¸°
    static IAsyncOperation<std::wstring> ReadConfigFileAsync(std::wstring const& fileName) {
        try {
            auto localFolder = ApplicationData::Current().LocalFolder();
            auto file = co_await localFolder.GetFileAsync(fileName);
            auto content = co_await FileIO::ReadTextAsync(file);
            
            co_return std::wstring(content);
        }
        catch (hresult_error const& ex) {
            std::wcout << L"File Read Error: " << std::wstring_view(ex.message()) << std::endl;
            co_return std::wstring{};
        }
    }

    // íŒŒì¼ ë¹„ë™ê¸° ì“°ê¸°
    static IAsyncAction WriteLogFileAsync(std::wstring const& fileName, std::wstring const& logData) {
        try {
            auto localFolder = ApplicationData::Current().LocalFolder();
            auto file = co_await localFolder.CreateFileAsync(fileName, CreationCollisionOption::ReplaceExisting);
            
            co_await FileIO::WriteTextAsync(file, logData);
            std::wcout << L"Log written to: " << std::wstring_view(fileName) << std::endl;
        }
        catch (hresult_error const& ex) {
            std::wcout << L"File Write Error: " << std::wstring_view(ex.message()) << std::endl;
        }
    }

    // ë³‘ë ¬ ì„œë²„ ìƒíƒœ ì²´í¬
    static IAsyncAction CheckMultipleServersAsync(std::vector<std::wstring> const& serverUrls) {
        std::vector<IAsyncOperation<bool>> tasks;
        
        // ëª¨ë“  ì„œë²„ì— ëŒ€í•´ ë¹„ë™ê¸° ìš”ì²­ ì‹œì‘
        for (auto const& url : serverUrls) {
            tasks.push_back(CheckServerStatusAsync(url));
        }

        std::wcout << L"Checking " << tasks.size() << L" servers..." << std::endl;

        // ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
        for (size_t i = 0; i < tasks.size(); ++i) {
            bool result = co_await tasks[i];
            std::wcout << L"Server " << (i + 1) << L": " 
                       << (result ? L"Online" : L"Offline") << std::endl;
        }

        std::wcout << L"All server checks completed!" << std::endl;
    }
};

// ì‚¬ìš© ì˜ˆì œ
void RunAsyncExample() {
    std::wcout << L"=== Async Operations Example ===" << std::endl;

    // ë‹¨ì¼ ì„œë²„ ì²´í¬
    auto checkTask = AsyncGameServerUtils::CheckServerStatusAsync(L"http://example.com/api/status");
    
    // ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ ê²°ê³¼ ëŒ€ê¸° (ì‹¤ì œë¡œëŠ” ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŒ)
    auto result = checkTask.get();
    std::wcout << L"Server check result: " << (result ? L"Success" : L"Failed") << std::endl;

    // ë‹¤ì¤‘ ì„œë²„ ì²´í¬
    std::vector<std::wstring> servers = {
        L"http://server1.example.com/status",
        L"http://server2.example.com/status",
        L"http://server3.example.com/status"
    };

    auto multiCheckTask = AsyncGameServerUtils::CheckMultipleServersAsync(servers);
    multiCheckTask.get(); // ì™„ë£Œ ëŒ€ê¸°

    // ì„¤ì • íŒŒì¼ ì½ê¸°
    auto configTask = AsyncGameServerUtils::ReadConfigFileAsync(L"gameserver.config");
    auto config = configTask.get();
    
    if (!config.empty()) {
        std::wcout << L"Config loaded: " << config.substr(0, 100) << L"..." << std::endl;
    }

    // ë¡œê·¸ íŒŒì¼ ì“°ê¸°
    auto logData = L"[" + GetCurrentTimeString() + L"] Server monitoring completed\n";
    auto writeTask = AsyncGameServerUtils::WriteLogFileAsync(L"monitor.log", logData);
    writeTask.get();
}
```
  
ì´ ì½”ë“œëŠ” **WinRT(Windows Runtime)**ì˜ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ê¸°ëŠ¥ì„ í™œìš©í•˜ì—¬

* ì„œë²„ ìƒíƒœë¥¼ HTTPë¡œ í™•ì¸í•˜ê³ ,
* ì„¤ì • íŒŒì¼ì„ ì½ê±°ë‚˜,
* ë¡œê·¸ íŒŒì¼ì„ ê¸°ë¡í•˜ë©°,
* ì—¬ëŸ¬ ì„œë²„ë¥¼ ë™ì‹œì— ê²€ì‚¬í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•œ ì˜ˆì œì´ë‹¤.

ì¦‰, **"ì…ì¶œë ¥(I/O) ì‘ì—…ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ í”„ë¡œê·¸ë¨ì˜ ì‘ë‹µì„±ì„ ìœ ì§€í•˜ëŠ” ë°©ë²•"**ì„ ë³´ì—¬ì£¼ëŠ” ì½”ë“œì´ë‹¤.

ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì€ ì„œë²„, í´ë¼ì´ì–¸íŠ¸, UI í”„ë¡œê·¸ë¨ ë“±ì—ì„œ í•„ìˆ˜ì ì¸ ê¸°ë²•ìœ¼ë¡œ,
CPUëŠ” **ëŒ€ê¸° ì‹œê°„ ì—†ì´ ë‹¤ë¥¸ ì¼ì„ ê³„ì† ìˆ˜í–‰**í•  ìˆ˜ ìˆê²Œ ë§Œë“¤ì–´ì¤€ë‹¤.


#### 1ï¸âƒ£ í´ë˜ìŠ¤ êµ¬ì¡° ë° í•µì‹¬ ê°œë…
ë¨¼ì € ì „ì²´ êµ¬ì¡°ë¥¼ ì‚´í´ë³´ì.

```cpp
class AsyncGameServerUtils {
public:
    static IAsyncOperation<bool> CheckServerStatusAsync(std::wstring const& serverUrl);
    static IAsyncOperation<std::wstring> ReadConfigFileAsync(std::wstring const& fileName);
    static IAsyncAction WriteLogFileAsync(std::wstring const& fileName, std::wstring const& logData);
    static IAsyncAction CheckMultipleServersAsync(std::vector<std::wstring> const& serverUrls);
};
```

| ë©”ì„œë“œ ì´ë¦„                      | ë°˜í™˜ íƒ€ì…                           | ê¸°ëŠ¥ ìš”ì•½                 |
| --------------------------- | ------------------------------- | --------------------- |
| `CheckServerStatusAsync`    | `IAsyncOperation<bool>`         | ì„œë²„ì— HTTP ìš”ì²­ì„ ë³´ë‚´ ìƒíƒœ í™•ì¸ |
| `ReadConfigFileAsync`       | `IAsyncOperation<std::wstring>` | ì„¤ì • íŒŒì¼ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì½ìŒ      |
| `WriteLogFileAsync`         | `IAsyncAction`                  | ë¡œê·¸ íŒŒì¼ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì €ì¥      |
| `CheckMultipleServersAsync` | `IAsyncAction`                  | ì—¬ëŸ¬ ì„œë²„ë¥¼ ë³‘ë ¬ë¡œ ê²€ì‚¬         |

`IAsyncOperation<T>`ëŠ” **ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜**ë¥¼ ë‚˜íƒ€ë‚´ë©°,
ê²°ê³¼ê°€ ìˆì„ ê²½ìš° `T` í˜•ì‹ì˜ ê°’ì„ ë°˜í™˜í•œë‹¤.

ì•„ë˜ëŠ” ì´ í´ë˜ìŠ¤ì˜ êµ¬ì¡°ë¥¼ ê°„ë‹¨íˆ ì‹œê°í™”í•œ ê²ƒì´ë‹¤.

```mermaid
classDiagram
    class AsyncGameServerUtils {
        +CheckServerStatusAsync(url) IAsyncOperation<bool>
        +ReadConfigFileAsync(fileName) IAsyncOperation<wstring>
        +WriteLogFileAsync(fileName, data) IAsyncAction
        +CheckMultipleServersAsync(urls) IAsyncAction
    }
```


#### 2ï¸âƒ£ ì„œë²„ ìƒíƒœ ë¹„ë™ê¸° ì²´í¬ (`CheckServerStatusAsync`)
ì´ í•¨ìˆ˜ëŠ” HTTP ìš”ì²­ì„ ë³´ë‚´ **ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë‹µí•˜ëŠ”ì§€ í™•ì¸**í•œë‹¤.

```cpp
HttpClient httpClient;
auto uri = Uri(serverUrl);
auto response = co_await httpClient.GetAsync(uri);
```

* `HttpClient` ê°ì²´ë¡œ ì„œë²„ì— GET ìš”ì²­ì„ ë³´ë‚¸ë‹¤.
* `co_await` í‚¤ì›Œë“œëŠ” **ë¹„ë™ê¸° ì‘ì—…ì„ ê¸°ë‹¤ë¦¬ëŠ” ì§€ì **ì´ë‹¤.
  ì´ í‚¤ì›Œë“œê°€ ë‚˜ì˜¤ë©´ í•¨ìˆ˜ ì‹¤í–‰ì´ ì¼ì‹œ ì¤‘ë‹¨ë˜ê³ ,
  ìš”ì²­ì´ ì™„ë£Œë˜ë©´ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´ì–´ì§„ë‹¤.

```cpp
if (response.IsSuccessStatusCode()) {
    auto content = co_await response.Content().ReadAsStringAsync();
    std::wcout << L"Server Response: " << std::wstring_view(content);
    co_return true;
}
```

`co_return`ì€ ë¹„ë™ê¸° í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ì„ ì „ë‹¬í•˜ëŠ” ëª…ë ¹ì´ë‹¤.
ì¦‰, **ì„±ê³µ ì‹œ true**, ì‹¤íŒ¨ ì‹œ falseë¥¼ ë°˜í™˜í•œë‹¤.


#### 3ï¸âƒ£ ì„¤ì • íŒŒì¼ ë¹„ë™ê¸° ì½ê¸° (`ReadConfigFileAsync`)
ì´ í•¨ìˆ˜ëŠ” ë¡œì»¬ í´ë”ì˜ íŒŒì¼ì„ **ë¸”ë¡œí‚¹ ì—†ì´ ì½ì–´ì˜¤ëŠ” ì˜ˆì œ**ì´ë‹¤.

```cpp
auto localFolder = ApplicationData::Current().LocalFolder();
auto file = co_await localFolder.GetFileAsync(fileName);
auto content = co_await FileIO::ReadTextAsync(file);
```

* `ApplicationData::Current().LocalFolder()`ëŠ” ì•±ì˜ ë¡œì»¬ ë°ì´í„° í´ë”ë¥¼ ê°€ë¦¬í‚¨ë‹¤.
* `GetFileAsync()`ì™€ `ReadTextAsync()`ëŠ” ë‘˜ ë‹¤ ë¹„ë™ê¸° í•¨ìˆ˜ì´ë¯€ë¡œ
  íŒŒì¼ì´ ì»¤ë„ í”„ë¡œê·¸ë¨ì´ ë©ˆì¶”ì§€ ì•ŠëŠ”ë‹¤.

ASCII ìˆœì„œë¥¼ ë³´ë©´ ì•„ë˜ì™€ ê°™ë‹¤.

```
[íŒŒì¼ ìš”ì²­] â†’ [íŒŒì¼ í•¸ë“¤ íšë“] â†’ [íŒŒì¼ ì½ê¸° ìš”ì²­] â†’ [ê²°ê³¼ ìˆ˜ì‹  í›„ ë³µê·€]
```

ì¦‰, í”„ë¡œê·¸ë¨ì€ íŒŒì¼ì´ ì½íˆëŠ” ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—…(ì˜ˆ: UI ì—…ë°ì´íŠ¸, ë„¤íŠ¸ì›Œí¬ í†µì‹ )ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.


#### 4ï¸âƒ£ ë¡œê·¸ íŒŒì¼ ë¹„ë™ê¸° ì“°ê¸° (`WriteLogFileAsync`)

```cpp
auto localFolder = ApplicationData::Current().LocalFolder();
auto file = co_await localFolder.CreateFileAsync(fileName, CreationCollisionOption::ReplaceExisting);
co_await FileIO::WriteTextAsync(file, logData);
```

ì´ í•¨ìˆ˜ëŠ” **ê¸°ì¡´ íŒŒì¼ì„ ë®ì–´ì“°ë©° ë¡œê·¸ ë°ì´í„°ë¥¼ ê¸°ë¡**í•œë‹¤.
ëª¨ë“  ì‘ì—…ì´ `co_await`ë¡œ ì²˜ë¦¬ë˜ê¸° ë•Œë¬¸ì—, íŒŒì¼ ìƒì„± ë° ì“°ê¸° ê³¼ì •ì´ ëë‚  ë•Œê¹Œì§€
UI ìŠ¤ë ˆë“œë‚˜ ë©”ì¸ ë£¨í”„ê°€ ë©ˆì¶”ì§€ ì•ŠëŠ”ë‹¤.

  
#### 5ï¸âƒ£ ë³‘ë ¬ ì„œë²„ ìƒíƒœ ì²´í¬ (`CheckMultipleServersAsync`)
ì´ í•¨ìˆ˜ëŠ” **ì—¬ëŸ¬ ì„œë²„ë¥¼ ë™ì‹œì— ê²€ì‚¬í•˜ëŠ” ë¹„ë™ê¸° ë³‘ë ¬ ì²˜ë¦¬ ì˜ˆì œ**ì´ë‹¤.

```cpp
std::vector<IAsyncOperation<bool>> tasks;

for (auto const& url : serverUrls) {
    tasks.push_back(CheckServerStatusAsync(url));
}
```

ì„œë²„ ëª©ë¡ì„ ìˆœíšŒí•˜ë©´ì„œ ê° ì„œë²„ì— ëŒ€í•œ ë¹„ë™ê¸° ìš”ì²­ì„ ë™ì‹œì— ì‹œì‘í•œë‹¤.
ì¦‰, ê° ìš”ì²­ì€ ë³‘ë ¬ë¡œ ì‹¤í–‰ë˜ì–´ ì „ì²´ ì²˜ë¦¬ ì†ë„ê°€ ë§¤ìš° ë¹ ë¥´ë‹¤.

```cpp
for (size_t i = 0; i < tasks.size(); ++i) {
    bool result = co_await tasks[i];
    std::wcout << L"Server " << (i + 1) << L": " 
               << (result ? L"Online" : L"Offline") << std::endl;
}
```

* ëª¨ë“  ìš”ì²­ì´ ëë‚  ë•Œê¹Œì§€ `co_await`ë¡œ ìˆœì°¨ ëŒ€ê¸°í•˜ë©° ê²°ê³¼ë¥¼ í™•ì¸í•œë‹¤.
* ê° ì„œë²„ì˜ ìƒíƒœ(Online/Offline)ë¥¼ ì¶œë ¥í•œë‹¤.

ì´ ê³¼ì •ì„ ë„ì‹ìœ¼ë¡œ í‘œí˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```mermaid
sequenceDiagram
    participant Main
    participant Server1
    participant Server2
    participant Server3

    Main->>Server1: CheckServerStatusAsync()
    Main->>Server2: CheckServerStatusAsync()
    Main->>Server3: CheckServerStatusAsync()
    Note over Main: ë™ì‹œì— ìš”ì²­ ë°œì†¡

    Server1-->>Main: ì‘ë‹µ ìˆ˜ì‹ 
    Server2-->>Main: ì‘ë‹µ ìˆ˜ì‹ 
    Server3-->>Main: ì‘ë‹µ ìˆ˜ì‹ 
    Main->>Main: ëª¨ë“  ì„œë²„ ê²°ê³¼ ì¶œë ¥
```

  
#### 6ï¸âƒ£ ì˜ˆì œ ì‹¤í–‰ (`RunAsyncExample`)
ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ í•¨ìˆ˜ëŠ” ì•ì—ì„œ ë§Œë“  ê¸°ëŠ¥ë“¤ì„ ì‹¤ì œë¡œ ì‹¤í–‰í•˜ëŠ” ì˜ˆì œì´ë‹¤.

```cpp
auto checkTask = AsyncGameServerUtils::CheckServerStatusAsync(L"http://example.com/api/status");
auto result = checkTask.get();
```

* `.get()`ì€ ë¹„ë™ê¸° í•¨ìˆ˜ì˜ ê²°ê³¼ë¥¼ **ë™ê¸°ì ìœ¼ë¡œ ê¸°ë‹¤ë¦¬ëŠ” í•¨ìˆ˜**ì´ë‹¤.
  ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ `.get()` ëŒ€ì‹  `co_await`ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

ì´í›„,

* ì—¬ëŸ¬ ì„œë²„ë¥¼ ë™ì‹œì— ê²€ì‚¬í•˜ê³ ,
* ì„¤ì • íŒŒì¼ì„ ì½ìœ¼ë©°,
* ë¡œê·¸ íŒŒì¼ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ê¸°ë¡í•œë‹¤.


#### âœ… ì •ë¦¬

| êµ¬ë¶„                           | ì„¤ëª…                         |
| ---------------------------- | -------------------------- |
| **ë¹„ë™ê¸° HTTP ìš”ì²­**              | ì„œë²„ì˜ ìƒíƒœë¥¼ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ìœ¼ë¡œ í™•ì¸í•¨      |
| **ë¹„ë™ê¸° íŒŒì¼ ì½ê¸°**                | ì„¤ì • íŒŒì¼ì„ ì½ì„ ë•Œ í”„ë¡œê·¸ë¨ì´ ë©ˆì¶”ì§€ ì•ŠìŒ   |
| **ë¹„ë™ê¸° íŒŒì¼ ì“°ê¸°**                | ë¡œê·¸ë¥¼ ì €ì¥í•˜ë©´ì„œ ë‹¤ë¥¸ ì‘ì—…ì„ ë™ì‹œì— ìˆ˜í–‰ ê°€ëŠ¥ |
| **ë³‘ë ¬ ì²˜ë¦¬**                    | ì—¬ëŸ¬ ì„œë²„ë¥¼ ë™ì‹œì— ê²€ì‚¬í•˜ì—¬ ì‹œê°„ ë‹¨ì¶•      |
| **`co_await` / `co_return`** | ë¹„ë™ê¸° ì‘ì—…ì˜ ì¼ì‹œ ì¤‘ë‹¨ ë° ê²°ê³¼ ë°˜í™˜ì„ ì²˜ë¦¬í•¨ |

---

#### ğŸ’¡ ë¹„ë™ê¸° ë™ì‘ì˜ íë¦„ ìš”ì•½

```mermaid
flowchart TD
    A[ì‚¬ìš©ì ì…ë ¥] --> B[CheckServerStatusAsync í˜¸ì¶œ]
    B --> C[HTTP ìš”ì²­ ì „ì†¡]
    C -->|ì‘ë‹µ ëŒ€ê¸° ì¤‘| D[ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰ ê°€ëŠ¥]
    D --> E[ì‘ë‹µ ìˆ˜ì‹  í›„ ì´ì–´ì„œ ì‹¤í–‰]
    E --> F[ê²°ê³¼ ì¶œë ¥ ë° ë¡œê·¸ ê¸°ë¡]
```

ì´ ì½”ë“œëŠ” **â€œWinRTì˜ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ëª¨ë¸(co_await)â€**ì„ ì‹¤ì œë¡œ ì²´í—˜í•  ìˆ˜ ìˆëŠ” ì¢‹ì€ ì˜ˆì œì´ë‹¤.
ì´ ë°©ì‹ì€ íŠ¹íˆ ì„œë²„ë‚˜ ê²Œì„ í´ë¼ì´ì–¸íŠ¸ì²˜ëŸ¼
ë„¤íŠ¸ì›Œí¬Â·íŒŒì¼ I/Oê°€ ìì£¼ ë°œìƒí•˜ëŠ” í”„ë¡œê·¸ë¨ì—ì„œ ë§¤ìš° ìœ ìš©í•˜ë‹¤.

ì¦‰, ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì€ **"ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  íš¨ìœ¨ì ìœ¼ë¡œ ì¼í•˜ëŠ” ë°©ë²•"**ì´ë©°,
WinRTëŠ” ì´ë¥¼ C++ì—ì„œë„ ìì—°ìŠ¤ëŸ½ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë„ë¡ ë•ëŠ” ê°•ë ¥í•œ ë„êµ¬ë‹¤.



### 11.3.2 ì´ë²¤íŠ¸ ì²˜ë¦¬
WinRTì˜ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì„ í™œìš©í•œ ì˜ˆì œì´ë‹¤:

```cpp
#include <winrt/Windows.System.Power.h>
#include <winrt/Windows.ApplicationModel.h>

using namespace Windows::System::Power;
using namespace Windows::ApplicationModel;

class WinRTEventHandler {
private:
    event_token m_powerToken;
    event_token m_memoryToken;
    bool m_monitoring = false;

public:
    void StartEventMonitoring() {
        if (m_monitoring) return;

        std::wcout << L"Starting event monitoring..." << std::endl;

        // ì „ë ¥ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸
        m_powerToken = PowerManager::EnergySaverStatusChanged([this](auto const&, auto const&) {
            auto status = PowerManager::EnergySaverStatus();
            std::wcout << L"[Event] Energy Saver Status Changed: ";
            switch (status) {
            case EnergySaverStatus::Disabled:
                std::wcout << L"Disabled"; break;
            case EnergySaverStatus::Off:
                std::wcout << L"Off"; break;
            case EnergySaverStatus::On:
                std::wcout << L"On - Game server should reduce performance"; break;
            }
            std::wcout << std::endl;
        });

        // ë©”ëª¨ë¦¬ ì••ë°• ì´ë²¤íŠ¸
        m_memoryToken = MemoryManager::AppMemoryUsageIncreased([this](auto const&, auto const&) {
            auto level = MemoryManager::AppMemoryUsageLevel();
            std::wcout << L"[Event] Memory Usage Level Changed: ";
            switch (level) {
            case AppMemoryUsageLevel::Low:
                std::wcout << L"Low"; break;
            case AppMemoryUsageLevel::Medium:
                std::wcout << L"Medium"; break;
            case AppMemoryUsageLevel::High:
                std::wcout << L"High - Consider reducing memory usage"; break;
            case AppMemoryUsageLevel::OverLimit:
                std::wcout << L"Over Limit - Critical memory situation!"; break;
            }
            std::wcout << std::endl;

            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™” ì‹œë„
            if (level >= AppMemoryUsageLevel::High) {
                OptimizeMemoryUsage();
            }
        });

        m_monitoring = true;
        std::wcout << L"Event monitoring started successfully!" << std::endl;
    }

    void StopEventMonitoring() {
        if (!m_monitoring) return;

        // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì œê±°
        PowerManager::EnergySaverStatusChanged(m_powerToken);
        MemoryManager::AppMemoryUsageIncreased(m_memoryToken);

        m_monitoring = false;
        std::wcout << L"Event monitoring stopped." << std::endl;
    }

private:
    void OptimizeMemoryUsage() {
        std::wcout << L"[Optimization] Attempting to reduce memory usage..." << std::endl;
        
        // ì‹¤ì œ ê²Œì„ ì„œë²„ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìµœì í™”ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
        // - ìºì‹œ ì •ë¦¬
        // - ë¹„í™œì„± ì—°ê²° í•´ì œ
        // - ì„ì‹œ ë°ì´í„° ì •ë¦¬
        // - GC ê°•ì œ ì‹¤í–‰ (ê´€ë¦¬ ì½”ë“œì˜ ê²½ìš°)
        
        auto memoryReport = MemoryManager::GetAppMemoryReport();
        std::wcout << L"Current memory usage: " 
                   << (memoryReport.PrivateCommitUsage() / 1024 / 1024) << L" MB" << std::endl;
    }
};
```
    
ì´ë²ˆ ì½”ë“œëŠ” **WinRT(Windows Runtime)**ì˜ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì„ í™œìš©í•´
ì‹œìŠ¤í…œì˜ **ì „ë ¥ ìƒíƒœ(Power)**ì™€ **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰(Memory)** ë³€í™”ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì§€í•˜ê³  ëŒ€ì‘í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì£¼ëŠ” ì˜ˆì œì´ë‹¤.

ì¦‰, ì´ ì½”ë“œëŠ” **ê²Œì„ ì„œë²„ë‚˜ ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ê°€ ì‹œìŠ¤í…œ ìì› ë³€í™”ë¥¼ ìë™ìœ¼ë¡œ ê°ì‹œí•˜ê³ , í•„ìš”í•œ ê²½ìš° ëŒ€ì‘í•˜ë„ë¡ ì„¤ê³„í•˜ëŠ” ë°©ë²•**ì„ ì„¤ëª…í•˜ê¸° ìœ„í•œ ê²ƒì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´,

* ë…¸íŠ¸ë¶ì´ ì ˆì „ ëª¨ë“œ(Energy Saver Mode)ë¡œ ì „í™˜ë˜ë©´, ê²Œì„ ì„œë²„ì˜ ì²˜ë¦¬ëŸ‰ì„ ì¤„ì—¬ì•¼ í•˜ê³ 
* ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ë†’ì•„ì§€ë©´, ìºì‹œë‚˜ ì„ì‹œ ë°ì´í„°ë¥¼ ì •ë¦¬í•´ì•¼ í•œë‹¤.

ì´ í”„ë¡œê·¸ë¨ì€ ë°”ë¡œ ê·¸ëŸ¬í•œ **ì´ë²¤íŠ¸ ê¸°ë°˜ ìì› ê´€ë¦¬ì˜ ê¸°ì´ˆ êµ¬ì¡°**ë¥¼ ë³´ì—¬ì¤€ë‹¤.


#### 1ï¸âƒ£ í´ë˜ìŠ¤ êµ¬ì¡° ê°œìš”
ë¨¼ì € ì „ì²´ í´ë˜ìŠ¤ì˜ êµ¬ì¡°ë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ì.

```cpp
class WinRTEventHandler {
private:
    event_token m_powerToken;
    event_token m_memoryToken;
    bool m_monitoring = false;

public:
    void StartEventMonitoring();
    void StopEventMonitoring();

private:
    void OptimizeMemoryUsage();
};
```

ì´ í´ë˜ìŠ¤ëŠ” í¬ê²Œ ì„¸ ê°€ì§€ ì—­í• ì„ ë‹´ë‹¹í•œë‹¤.

| êµ¬ì„± ìš”ì†Œ                    | ì—­í•                    |
| ------------------------ | -------------------- |
| `StartEventMonitoring()` | ì „ë ¥ ë° ë©”ëª¨ë¦¬ ì´ë²¤íŠ¸ ê°ì‹œ ì‹œì‘   |
| `StopEventMonitoring()`  | ì´ë²¤íŠ¸ ê°ì‹œ ì¤‘ë‹¨ ë° ë¦¬ì†ŒìŠ¤ í•´ì œ   |
| `OptimizeMemoryUsage()`  | ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ë†’ì„ ë•Œ ìµœì í™” ìˆ˜í–‰ |

ë‹¤ìŒì€ í´ë˜ìŠ¤ êµ¬ì¡°ë¥¼ ë„ì‹í™”í•œ ê²ƒì´ë‹¤.

```mermaid
classDiagram
    class WinRTEventHandler {
        - event_token m_powerToken
        - event_token m_memoryToken
        - bool m_monitoring
        + StartEventMonitoring() : void
        + StopEventMonitoring() : void
        - OptimizeMemoryUsage() : void
    }
```


#### 2ï¸âƒ£ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (`StartEventMonitoring`)
ì´ í•¨ìˆ˜ëŠ” ì‹œìŠ¤í…œì˜ ìƒíƒœ ë³€í™”ë¥¼ ê°ì‹œí•˜ê¸° ìœ„í•œ **ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ë“±ë¡í•˜ëŠ” í•¨ìˆ˜**ì´ë‹¤.

```cpp
void StartEventMonitoring() {
    if (m_monitoring) return;
    std::wcout << L"Starting event monitoring..." << std::endl;
```

`m_monitoring` í”Œë˜ê·¸ëŠ” ì¤‘ë³µ ë“±ë¡ì„ ë°©ì§€í•˜ê¸° ìœ„í•œ ì¥ì¹˜ì´ë‹¤.
ì´ì œ ì „ë ¥ ìƒíƒœì™€ ë©”ëª¨ë¦¬ ìƒíƒœ ì´ë²¤íŠ¸ë¥¼ ë“±ë¡í•œë‹¤.


##### âš¡ ì „ë ¥ ìƒíƒœ ë³€í™” ê°ì§€

```cpp
m_powerToken = PowerManager::EnergySaverStatusChanged([this](auto const&, auto const&) {
    auto status = PowerManager::EnergySaverStatus();
    std::wcout << L"[Event] Energy Saver Status Changed: ";
```

ì´ ì½”ë“œëŠ” **ì „ë ¥ ì ˆì•½ ëª¨ë“œ(Energy Saver)**ì˜ ìƒíƒœê°€ ë³€í•  ë•Œë§ˆë‹¤ í˜¸ì¶œë˜ëŠ” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì´ë‹¤.
ìœˆë„ìš° ì‹œìŠ¤í…œì€ ì „ì› ì„¤ì •ì´ ë°”ë€” ë•Œ(ì˜ˆ: ì „ì› ì–´ëŒ‘í„° ë¶„ë¦¬, ë°°í„°ë¦¬ ì ˆì „ ëª¨ë“œ ì§„ì… ë“±)
ìë™ìœ¼ë¡œ ì´ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¨ë‹¤.

```cpp
switch (status) {
case EnergySaverStatus::Disabled:
    std::wcout << L"Disabled"; break;
case EnergySaverStatus::Off:
    std::wcout << L"Off"; break;
case EnergySaverStatus::On:
    std::wcout << L"On - Game server should reduce performance"; break;
}
```

* **Disabled**: ì ˆì „ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë¨
* **Off**: ì ˆì „ ëª¨ë“œê°€ êº¼ì§ (ì¼ë°˜ ì „ë ¥ ëª¨ë“œ)
* **On**: ì ˆì „ ëª¨ë“œê°€ ì¼œì§ â€”> ì„œë²„ëŠ” ì„±ëŠ¥ì„ ë‚®ì¶°ì•¼ í•¨

ì¦‰, â€œì ˆì „ ëª¨ë“œ ê°ì§€ â†’ ì„±ëŠ¥ ì¡°ì •â€ì˜ íë¦„ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆë‹¤.


##### ğŸ§  ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€ ê°ì§€

```cpp
m_memoryToken = MemoryManager::AppMemoryUsageIncreased([this](auto const&, auto const&) {
    auto level = MemoryManager::AppMemoryUsageLevel();
    std::wcout << L"[Event] Memory Usage Level Changed: ";
```

ì´ ë¶€ë¶„ì€ **í˜„ì¬ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¦ê°€í–ˆì„ ë•Œ í˜¸ì¶œë˜ëŠ” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ**ì´ë‹¤.

```cpp
switch (level) {
case AppMemoryUsageLevel::Low:
    std::wcout << L"Low"; break;
case AppMemoryUsageLevel::Medium:
    std::wcout << L"Medium"; break;
case AppMemoryUsageLevel::High:
    std::wcout << L"High - Consider reducing memory usage"; break;
case AppMemoryUsageLevel::OverLimit:
    std::wcout << L"Over Limit - Critical memory situation!"; break;
}
```

* **Low**: ì—¬ìœ  ìˆìŒ
* **Medium**: ì ë‹¹í•œ ì‚¬ìš©ëŸ‰
* **High**: ë©”ëª¨ë¦¬ ë¶€ì¡± ê²½ê³  â€”> ìºì‹œ ì •ë¦¬ ë“± í•„ìš”
* **OverLimit**: ì‹¬ê°í•œ ë©”ëª¨ë¦¬ ë¶€ì¡± â€”> ê¸´ê¸‰ ì¡°ì¹˜ í•„ìš”

ë§Œì•½ ìˆ˜ì¤€ì´ `High` ì´ìƒì´ë©´ ë‹¤ìŒ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤.

```cpp
if (level >= AppMemoryUsageLevel::High) {
    OptimizeMemoryUsage();
}
```

ì´ë ‡ê²Œ ì´ë²¤íŠ¸ ê¸°ë°˜ìœ¼ë¡œ **ìë™ ë©”ëª¨ë¦¬ ìµœì í™”**ê°€ ì´ë£¨ì–´ì§„ë‹¤.


#### 3ï¸âƒ£ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ (`StopEventMonitoring`)

```cpp
void StopEventMonitoring() {
    if (!m_monitoring) return;

    PowerManager::EnergySaverStatusChanged(m_powerToken);
    MemoryManager::AppMemoryUsageIncreased(m_memoryToken);

    m_monitoring = false;
    std::wcout << L"Event monitoring stopped." << std::endl;
}
```

ì´ í•¨ìˆ˜ëŠ” **ë“±ë¡ëœ ì´ë²¤íŠ¸ë¥¼ í•´ì œ**í•˜ì—¬ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•œë‹¤.
WinRTì˜ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì—ì„œëŠ” `event_token`ì„ ì‚¬ìš©í•˜ì—¬ ë“±ë¡ëœ ë¦¬ìŠ¤ë„ˆë¥¼ ì¶”ì í•˜ê¸° ë•Œë¬¸ì—,
ì •ë¦¬ ì‹œ ë°˜ë“œì‹œ í† í°ì„ ì´ìš©í•´ ì´ë²¤íŠ¸ë¥¼ ì œê±°í•´ì•¼ í•œë‹¤.


#### 4ï¸âƒ£ ë©”ëª¨ë¦¬ ìµœì í™” ì²˜ë¦¬ (`OptimizeMemoryUsage`)

```cpp
void OptimizeMemoryUsage() {
    std::wcout << L"[Optimization] Attempting to reduce memory usage..." << std::endl;
```

ì´ í•¨ìˆ˜ëŠ” ë©”ëª¨ë¦¬ ë¶€ì¡± ì´ë²¤íŠ¸ ë°œìƒ ì‹œ í˜¸ì¶œëœë‹¤.
ì‹¤ì œ ì„œë²„ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

* ìºì‹œ ë°ì´í„° ì •ë¦¬
* ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì„¸ì…˜ ì—°ê²° í•´ì œ
* ì„ì‹œ ê°ì²´ë‚˜ ë¦¬ì†ŒìŠ¤ í•´ì œ
* GC(ê°€ë¹„ì§€ ì»¬ë ‰ì…˜) ê°•ì œ ì‹¤í–‰ (C# ë“± ê´€ë¦¬ ì½”ë“œì—ì„œ)

ê·¸ë¦¬ê³  í˜„ì¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¶œë ¥í•œë‹¤.

```cpp
auto memoryReport = MemoryManager::GetAppMemoryReport();
std::wcout << L"Current memory usage: " 
           << (memoryReport.PrivateCommitUsage() / 1024 / 1024) << L" MB" << std::endl;
```


#### âš™ï¸ ì´ë²¤íŠ¸ íë¦„ ìš”ì•½
ì•„ë˜ëŠ” ì´ í”„ë¡œê·¸ë¨ì˜ ì´ë²¤íŠ¸ íë¦„ì„ ë‹¨ìˆœí™”í•œ ë‹¤ì´ì–´ê·¸ë¨ì´ë‹¤.

```mermaid
flowchart TD
    A["StartEventMonitoring()"] --> B["EnergySaverStatusChanged ë“±ë¡"]
    A --> C["AppMemoryUsageIncreased ë“±ë¡"]
    B --> D["ì „ë ¥ ìƒíƒœ ë³€ê²½ ê°ì§€"]
    C --> E["ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€ ê°ì§€"]
    E --> F["OptimizeMemoryUsage() í˜¸ì¶œ"]
    F --> G["ë©”ëª¨ë¦¬ ì •ë¦¬ ë° ë¦¬í¬íŠ¸ ì¶œë ¥"]
```

ì´ íë¦„ì—ì„œ ë³¼ ìˆ˜ ìˆë“¯,
ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ë©´ í”„ë¡œê·¸ë¨ì€ ìë™ìœ¼ë¡œ ì½œë°±ì„ ì‹¤í–‰í•˜ê³ ,
í•„ìš” ì‹œ ì¦‰ì‹œ ëŒ€ì‘í•œë‹¤.


#### âœ… ì •ë¦¬

| êµ¬ë¶„                                         | ì„¤ëª…                           |
| ------------------------------------------ | ---------------------------- |
| **PowerManager::EnergySaverStatusChanged** | ì „ë ¥ ì ˆì•½ ëª¨ë“œ ìƒíƒœ ë³€í™”ë¥¼ ê°ì§€           |
| **MemoryManager::AppMemoryUsageIncreased** | ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¦ê°€í–ˆì„ ë•Œ í˜¸ì¶œ           |
| **event_token**                            | ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì¶”ì í•˜ê³  ì œê±°í•˜ëŠ” ë° ì‚¬ìš©      |
| **OptimizeMemoryUsage()**                  | ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ë†’ì„ ë•Œ ìºì‹œ ì •ë¦¬ ë“± ìµœì í™” ìˆ˜í–‰ |
| **Start / Stop ëª¨ë“ˆí™”**                       | ì´ë²¤íŠ¸ ê°ì‹œì˜ ì‹œì‘ê³¼ ì¢…ë£Œë¥¼ ëª…í™•íˆ ê´€ë¦¬       |


#### ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸

* WinRTì˜ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì€ **ì‹œìŠ¤í…œ ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì‹œí•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ê°•ë ¥í•œ ê¸°ëŠ¥**ì´ë‹¤.
* ì´ë²¤íŠ¸ ê¸°ë°˜ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë©´, ë£¨í”„ë¥¼ ëŒë©° ìƒíƒœë¥¼ ë°˜ë³µ í™•ì¸í•˜ëŠ” **Polling ë°©ì‹ë³´ë‹¤ í›¨ì”¬ íš¨ìœ¨ì **ì´ë‹¤.
* ì‹¤ì œ ì„œë²„ì—ì„œëŠ” ì´ êµ¬ì¡°ë¥¼ í™œìš©í•´ **ì „ë ¥Â·ë©”ëª¨ë¦¬Â·ë„¤íŠ¸ì›Œí¬ ìƒíƒœì— ë”°ë¼ ìë™ìœ¼ë¡œ ìì› ê´€ë¦¬ ë¡œì§ì„ ì ìš©**í•  ìˆ˜ ìˆë‹¤.


ê²°êµ­ ì´ ì½”ë“œëŠ”,
**"ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ì— ë°˜ì‘í•˜ëŠ” ì§€ëŠ¥í˜• ì„œë²„ ê´€ë¦¬ êµ¬ì¡°ì˜ ê¸°ì´ˆ"**ë¥¼ ë³´ì—¬ì£¼ëŠ” ì˜ˆì œì´ë‹¤.
ì¦‰, í”„ë¡œê·¸ë¨ì´ ë‹¨ìˆœíˆ ë™ì‘í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ **í™˜ê²½ì„ ê°ì§€í•˜ê³  ìŠ¤ìŠ¤ë¡œ ëŒ€ì‘í•˜ëŠ” êµ¬ì¡°ë¥¼ ë§Œë“œëŠ” ì²« ë‹¨ê³„**ë¼ê³  í•  ìˆ˜ ìˆë‹¤.


</br>  

## 11.4 ëª¨ë˜ Windows APIì™€ì˜ ì—°ë™

### 11.4.1 Win32ì™€ WinRT í˜¼í•© ì‚¬ìš©

```cpp
// ModernGameServer.cpp - Win32ì™€ WinRT APIë¥¼ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ” ì˜ˆì œ
#include <windows.h>
#include <winrt/base.h>
#include <winrt/Windows.System.h>
#include <winrt/Windows.ApplicationModel.h>
#include <iostream>
#include <memory>

using namespace winrt;
using namespace Windows::System;

class HybridGameServerManager {
private:
    HANDLE m_serverProcess = nullptr;
    std::unique_ptr<WinRTEventHandler> m_eventHandler;
    bool m_useWinRTFeatures = false;

public:
    HybridGameServerManager() {
        // WinRT ì´ˆê¸°í™” ì‹œë„
        try {
            init_apartment();
            m_eventHandler = std::make_unique<WinRTEventHandler>();
            m_useWinRTFeatures = true;
            std::wcout << L"WinRT features enabled" << std::endl;
        }
        catch (...) {
            std::wcout << L"WinRT initialization failed, using Win32 only" << std::endl;
            m_useWinRTFeatures = false;
        }
    }

    ~HybridGameServerManager() {
        Cleanup();
    }

    bool StartGameServer(const std::wstring& serverPath) {
        // Win32 APIë¥¼ ì‚¬ìš©í•œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
        STARTUPINFO si = {};
        PROCESS_INFORMATION pi = {};
        si.cb = sizeof(si);

        std::wstring cmdLine = serverPath;
        
        if (!CreateProcess(
            nullptr,
            cmdLine.data(),
            nullptr,
            nullptr,
            FALSE,
            0,
            nullptr,
            nullptr,
            &si,
            &pi)) {
            
            std::wcout << L"Failed to start game server. Error: " << GetLastError() << std::endl;
            return false;
        }

        m_serverProcess = pi.hProcess;
        CloseHandle(pi.hThread);

        std::wcout << L"Game server started with PID: " << pi.dwProcessId << std::endl;

        // WinRT ê¸°ëŠ¥ì´ ì‚¬ìš© ê°€ëŠ¥í•˜ë©´ ê³ ê¸‰ ëª¨ë‹ˆí„°ë§ ì‹œì‘
        if (m_useWinRTFeatures) {
            m_eventHandler->StartEventMonitoring();
            StartAdvancedMonitoring();
        }

        return true;
    }

    void MonitorServer() {
        if (!m_serverProcess) return;

        std::wcout << L"Starting server monitoring..." << std::endl;

        while (true) {
            // Win32 APIë¥¼ ì‚¬ìš©í•œ ê¸°ë³¸ í”„ë¡œì„¸ìŠ¤ ëª¨ë‹ˆí„°ë§
            DWORD exitCode;
            if (!GetExitCodeProcess(m_serverProcess, &exitCode)) {
                std::wcout << L"Failed to get process status" << std::endl;
                break;
            }

            if (exitCode != STILL_ACTIVE) {
                std::wcout << L"Game server process has terminated with code: " << exitCode << std::endl;
                break;
            }

            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (Win32)
            PROCESS_MEMORY_COUNTERS pmc;
            if (GetProcessMemoryInfo(m_serverProcess, &pmc, sizeof(pmc))) {
                auto workingSetMB = pmc.WorkingSetSize / 1024 / 1024;
                std::wcout << L"Server Memory Usage: " << workingSetMB << L" MB";

                // WinRTë¥¼ ì‚¬ìš©í•œ ì¶”ê°€ ì •ë³´ (ê°€ëŠ¥í•œ ê²½ìš°)
                if (m_useWinRTFeatures) {
                    auto memoryReport = MemoryManager::GetAppMemoryReport();
                    auto systemMemoryMB = memoryReport.TotalCommitLimit() / 1024 / 1024;
                    auto usagePercent = (double)workingSetMB / systemMemoryMB * 100.0;
                    std::wcout << L" (" << std::fixed << std::setprecision(1) << usagePercent << L"% of system)";
                }
                std::wcout << std::endl;
            }

            Sleep(5000); // 5ì´ˆ ê°„ê²©
        }
    }

    void StopServer() {
        if (m_serverProcess) {
            std::wcout << L"Stopping game server..." << std::endl;
            
            // ë¨¼ì € ì •ìƒ ì¢…ë£Œ ì‹œë„
            if (!TerminateProcess(m_serverProcess, 0)) {
                std::wcout << L"Failed to terminate process. Error: " << GetLastError() << std::endl;
            } else {
                // í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ëŒ€ê¸°
                WaitForSingleObject(m_serverProcess, 10000); // 10ì´ˆ ëŒ€ê¸°
                std::wcout << L"Game server stopped" << std::endl;
            }
        }

        if (m_useWinRTFeatures && m_eventHandler) {
            m_eventHandler->StopEventMonitoring();
        }
    }

private:
    void StartAdvancedMonitoring() {
        std::wcout << L"Starting advanced WinRT monitoring..." << std::endl;
        
        // ë°°í„°ë¦¬ ìƒíƒœ ëª¨ë‹ˆí„°ë§ (ë…¸íŠ¸ë¶ í™˜ê²½)
        auto batteryStatus = PowerManager::BatteryStatus();
        if (batteryStatus != BatteryStatus::NotPresent) {
            std::wcout << L"Battery monitoring enabled" << std::endl;
        }

        // ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ëª¨ë‹ˆí„°ë§
        WinRTNetworkManager::StartNetworkMonitoring();
    }

    void Cleanup() {
        if (m_serverProcess) {
            CloseHandle(m_serverProcess);
            m_serverProcess = nullptr;
        }
    }
};

// ì‹¤ì œ ì‚¬ìš© ì˜ˆì œ
int main() {
    std::wcout << L"=== Hybrid Game Server Manager ===" << std::endl;

    HybridGameServerManager manager;
    
    // ê²Œì„ ì„œë²„ ì‹¤í–‰ íŒŒì¼ ê²½ë¡œ
    std::wstring serverPath = L"C:\\GameServer\\GameServer.exe";
    
    if (manager.StartGameServer(serverPath)) {
        std::wcout << L"Press Enter to start monitoring, or 'q' to quit immediately..." << std::endl;
        
        char input;
        std::cin >> input;
        
        if (input != 'q' && input != 'Q') {
            manager.MonitorServer();
        }
        
        manager.StopServer();
    }

    std::wcout << L"Program terminated." << std::endl;
    return 0;
}
```

### 11.4.2 í¬ë¡œìŠ¤ í”Œë«í¼ í˜¸í™˜ì„± ê³ ë ¤

```cpp
// CrossPlatformHelper.h - í”Œë«í¼ë³„ ê¸°ëŠ¥ ì¶”ìƒí™”
#pragma once

#include <string>
#include <memory>

class IPlatformHelper {
public:
    virtual ~IPlatformHelper() = default;
    
    virtual bool InitializePlatform() = 0;
    virtual void CleanupPlatform() = 0;
    
    virtual std::wstring GetSystemInfo() = 0;
    virtual bool IsFeatureAvailable(const std::wstring& feature) = 0;
    virtual void StartSystemMonitoring() = 0;
    virtual void StopSystemMonitoring() = 0;
};

// Windows êµ¬í˜„
class WindowsPlatformHelper : public IPlatformHelper {
private:
    bool m_winrtAvailable = false;
    std::unique_ptr<WinRTEventHandler> m_eventHandler;

public:
    bool InitializePlatform() override {
        try {
            winrt::init_apartment();
            m_eventHandler = std::make_unique<WinRTEventHandler>();
            m_winrtAvailable = true;
            return true;
        }
        catch (...) {
            m_winrtAvailable = false;
            return true; // Win32ë§Œìœ¼ë¡œë„ ë™ì‘ ê°€ëŠ¥
        }
    }

    void CleanupPlatform() override {
        if (m_eventHandler) {
            m_eventHandler->StopEventMonitoring();
            m_eventHandler.reset();
        }
    }

    std::wstring GetSystemInfo() override {
        std::wstring info = L"Windows Platform\n";
        
        if (m_winrtAvailable) {
            info += L"WinRT: Available\n";
            // WinRT APIë¥¼ ì‚¬ìš©í•œ ìƒì„¸ ì •ë³´
            WinRTSystemInfo::PrintSystemInfo();
        } else {
            info += L"WinRT: Not Available (using Win32 only)\n";
            // Win32 APIë§Œì„ ì‚¬ìš©í•œ ì •ë³´
        }
        
        return info;
    }

    bool IsFeatureAvailable(const std::wstring& feature) override {
        if (feature == L"WinRT") {
            return m_winrtAvailable;
        } else if (feature == L"Win32") {
            return true;
        }
        return false;
    }

    void StartSystemMonitoring() override {
        if (m_winrtAvailable && m_eventHandler) {
            m_eventHandler->StartEventMonitoring();
        }
    }

    void StopSystemMonitoring() override {
        if (m_eventHandler) {
            m_eventHandler->StopEventMonitoring();
        }
    }
};

// í”Œë«í¼ íŒ©í† ë¦¬
class PlatformFactory {
public:
    static std::unique_ptr<IPlatformHelper> CreatePlatformHelper() {
#ifdef _WIN32
        return std::make_unique<WindowsPlatformHelper>();
#else
        // ë‹¤ë¥¸ í”Œë«í¼ êµ¬í˜„
        return nullptr;
#endif
    }
};

// ì‚¬ìš© ì˜ˆì œ
void CrossPlatformExample() {
    auto platform = PlatformFactory::CreatePlatformHelper();
    
    if (!platform) {
        std::wcout << L"Unsupported platform" << std::endl;
        return;
    }

    if (platform->InitializePlatform()) {
        std::wcout << platform->GetSystemInfo() << std::endl;
        
        if (platform->IsFeatureAvailable(L"WinRT")) {
            std::wcout << L"Using modern Windows features" << std::endl;
            platform->StartSystemMonitoring();
        } else {
            std::wcout << L"Using legacy Windows features" << std::endl;
        }

        // ê²Œì„ ì„œë²„ ë¡œì§ ì‹¤í–‰...
        
        platform->StopSystemMonitoring();
        platform->CleanupPlatform();
    }
}
```

ì´ ì¥ì—ì„œëŠ” COMê³¼ WinRTë¥¼ í™œìš©í•˜ì—¬ ê²Œì„ ì„œë²„ì—ì„œ í˜„ëŒ€ì ì¸ Windows APIë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë¤˜ë‹¤. 

ì£¼ìš” ë‚´ìš©:
- COM ê¸°ì´ˆ ê°œë…ê³¼ WMIë¥¼ í†µí•œ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§
- WinRT APIë¥¼ í™œìš©í•œ í˜„ëŒ€ì ì¸ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘
- ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ê³¼ ì´ë²¤íŠ¸ ì²˜ë¦¬
- Win32ì™€ WinRTì˜ í˜¼í•© ì‚¬ìš©ë²•
- í¬ë¡œìŠ¤ í”Œë«í¼ í˜¸í™˜ì„± ê³ ë ¤ì‚¬í•­


 