# 게임 서버 개발자를 위한 최신 Win32 API 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  

# Chapter 1. Win32 API 기초
Win32 API는 Windows 운영체제의 핵심 프로그래밍 인터페이스로, 게임 서버 개발에서 시스템 리소스에 직접 접근하고 최적의 성능을 얻기 위해 반드시 이해해야 하는 기술이다. 이 장에서는 Win32 API의 기본 개념부터 실무에서 자주 마주치는 패턴들까지 체계적으로 학습한다.

```
    ┌─────────────────────────────────────────────────────────────┐
    │                    Win32 API 구조                           │
    │                                                             │
    │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
    │  │  Application    │  │   Win32 API     │  │   Kernel    │ │
    │  │   (게임서버)     │  │                 │  │             │ │
    │  │                 │◄─┤• CreateFile     │◄─┤• 파일시스템  │ │
    │  │                 │  │• VirtualAlloc   │  │• 메모리관리  │ │
    │  │                 │  │• CreateThread   │  │• 스케줄러    │ │
    │  │                 │  │• GetLastError   │  │• 에러관리    │ │
    │  └─────────────────┘  └─────────────────┘  └─────────────┘ │
    │           │                     │                  │        │
    │           └─────────────────────┼──────────────────┘        │
    │                                 │                           │
    │                    ┌─────────────────┐                      │
    │                    │  User32.dll     │                      │
    │                    │  Kernel32.dll   │                      │
    │                    │  Advapi32.dll   │                      │
    │                    │  Ws2_32.dll     │                      │
    │                    └─────────────────┘                      │
    └─────────────────────────────────────────────────────────────┘
```
  

## 2.1 Win32 API 개요 및 역사

### Win32 API의 탄생과 발전
Win32 API는 1990년대 초 Windows NT와 함께 도입된 32비트 Windows 프로그래밍 인터페이스이다. 현재는 64비트 시스템에서도 호환성을 유지하며 Windows의 핵심 API로 자리잡고 있다.

```
Win32 API 발전 타임라인:
═══════════════════════════════════════════════════════════

1990년대     2000년대     2010년대     2020년대
    │            │            │            │
    ▼            ▼            ▼            ▼
Windows NT   Windows XP   Windows 7   Windows 11
Win32 도입   64비트 지원   UAC 도입    Modern API
기본 API     WOW64       보안 강화    WinRT 통합
```

### 게임 서버에서 Win32 API가 중요한 이유

**1. 직접적인 시스템 제어:**
```cpp
// 예시: 메모리를 직접 관리하여 성능 최적화
void* AllocateGameMemory(size_t size) {
    // malloc 대신 VirtualAlloc 사용으로 더 정확한 메모리 제어
    return VirtualAlloc(nullptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}
```

**2. 최적의 성능:**
- C 런타임 라이브러리의 오버헤드 없이 직접 OS 커널과 통신
- 게임 서버의 실시간 요구사항 충족

**3. 세밀한 리소스 관리:**
- 스레드, 메모리, 파일 핸들 등의 정밀한 제어
- 리소스 누수 방지 및 최적화

### Win32 API 명명 규칙과 구조

```cpp
// Win32 API 함수의 일반적인 패턴
RETURN_TYPE FunctionNameA/W(
    PARAMETER_TYPE parameter1,
    PARAMETER_TYPE parameter2,
    // ...
);

// 예시들:
HANDLE CreateFileW(
    LPCWSTR lpFileName,        // 파일명 (Wide char)
    DWORD dwDesiredAccess,     // 접근 권한
    DWORD dwShareMode,         // 공유 모드
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
);

BOOL CloseHandle(HANDLE hObject);
DWORD GetLastError(VOID);
```
  

## 2.2 데이터 타입과 호출 규약

### Win32 기본 데이터 타입
Win32 API는 플랫폼 독립성과 명확성을 위해 고유한 데이터 타입을 정의한다.

```cpp
// 기본 정수 타입
typedef unsigned long       DWORD;    // 32비트 부호없는 정수
typedef unsigned short      WORD;     // 16비트 부호없는 정수  
typedef unsigned char       BYTE;     // 8비트 부호없는 정수
typedef long                LONG;     // 32비트 부호있는 정수
typedef int                 INT;      // 정수
typedef unsigned int        UINT;     // 부호없는 정수

// 64비트 타입 (Windows XP 이후)
typedef unsigned long long  DWORD64;  // 64비트 부호없는 정수
typedef long long          LONG64;   // 64비트 부호있는 정수
typedef __int64            LONGLONG;  // 64비트 정수

// 포인터 타입
typedef void*              LPVOID;   // void 포인터
typedef const void*        LPCVOID;  // const void 포인터
typedef DWORD*             LPDWORD;  // DWORD 포인터

// 불리언 타입
typedef int                BOOL;     // TRUE(1) 또는 FALSE(0)
#define TRUE               1
#define FALSE              0

// 핸들 타입 (리소스 식별자)
typedef void*              HANDLE;   // 일반 핸들
typedef HANDLE             HFILE;    // 파일 핸들
typedef HANDLE             HKEY;     // 레지스트리 키 핸들

// 게임 서버에서 자주 사용하는 타입 예시
class GameServer {
private:
    HANDLE m_hLogFile;        // 로그 파일 핸들
    HANDLE m_hStopEvent;      // 서버 종료 이벤트
    DWORD m_dwThreadCount;    // 스레드 개수
    LONGLONG m_llStartTime;   // 서버 시작 시간
    
public:
    BOOL Initialize(LPCWSTR logFileName);
    DWORD GetUptime() const;
    void Shutdown();
};
```

### 문자열 타입 체계
Win32 API는 ANSI와 Unicode 문자열을 모두 지원한다:

```cpp
// ANSI 문자열 타입
typedef char*              LPSTR;    // ANSI 문자열 포인터
typedef const char*        LPCSTR;   // const ANSI 문자열 포인터

// Unicode 문자열 타입  
typedef wchar_t*           LPWSTR;   // Wide 문자열 포인터
typedef const wchar_t*     LPCWSTR;  // const Wide 문자열 포인터

// 조건부 매크로 (UNICODE 정의 여부에 따라)
#ifdef UNICODE
    typedef LPWSTR         LPTSTR;   // Unicode일 때
    typedef LPCWSTR        LPCTSTR;
    #define TEXT(quote)    L##quote
#else
    typedef LPSTR          LPTSTR;   // ANSI일 때
    typedef LPCSTR         LPCTSTR;
    #define TEXT(quote)    quote
#endif

// 게임 서버에서의 사용 예시
class GameLogger {
public:
    void WriteLog(LPCWSTR message) {
        // Unicode 전용 함수 사용 (권장)
        WriteFile(m_hLogFile, message, 
                 lstrlenW(message) * sizeof(wchar_t), 
                 nullptr, nullptr);
    }
    
    void WriteLogA(LPCSTR message) {
        // ANSI 버전 (호환성용)
        WriteFile(m_hLogFile, message, 
                 lstrlenA(message), 
                 nullptr, nullptr);
    }
};
```

### 호출 규약 (Calling Conventions)
Win32 API는 특정 호출 규약을 따른다:

```cpp
// Win32 API 호출 규약
#define WINAPI __stdcall     // 표준 호출 규약
#define CALLBACK __stdcall   // 콜백 함수용

// 함수 포인터 정의 예시
typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(LPVOID lpThreadParameter);

// 콜백 함수 정의
DWORD WINAPI WorkerThreadProc(LPVOID lpParam) {
    GameServer* pServer = static_cast<GameServer*>(lpParam);
    
    while (pServer->IsRunning()) {
        // 작업 수행
        pServer->ProcessTasks();
        Sleep(10);
    }
    
    return 0;
}

// 스레드 생성
HANDLE CreateWorkerThread(GameServer* pServer) {
    return CreateThread(
        nullptr,                // 보안 속성
        0,                     // 스택 크기 (기본값)
        WorkerThreadProc,      // 스레드 함수
        pServer,               // 매개변수
        0,                     // 생성 플래그
        nullptr                // 스레드 ID
    );
}
```
  

## 2.3 에러 처리 패턴 (GetLastError, HRESULT)

### GetLastError()를 이용한 에러 처리
Win32 API 함수들은 실패 시 특정 값을 반환하고, 자세한 에러 코드는 `GetLastError()`로 조회할 수 있다.

```cpp
#include <iostream>
#include <string>

// 에러 메시지를 문자열로 변환하는 유틸리티 함수
std::wstring GetErrorMessage(DWORD errorCode) {
    LPWSTR messageBuffer = nullptr;
    
    DWORD size = FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        nullptr,
        errorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        reinterpret_cast<LPWSTR>(&messageBuffer),
        0,
        nullptr
    );
    
    std::wstring message(messageBuffer, size);
    LocalFree(messageBuffer);
    
    return message;
}

// 안전한 파일 열기 함수
HANDLE SafeCreateFile(LPCWSTR fileName, DWORD access, DWORD shareMode) {
    HANDLE hFile = CreateFileW(
        fileName,
        access,
        shareMode,
        nullptr,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        nullptr
    );
    
    if (hFile == INVALID_HANDLE_VALUE) {
        DWORD error = GetLastError();
        std::wcout << L"파일 열기 실패: " << fileName << std::endl;
        std::wcout << L"에러 코드: " << error << std::endl;
        std::wcout << L"에러 메시지: " << GetErrorMessage(error) << std::endl;
        return nullptr;
    }
    
    return hFile;
}

// 게임 서버에서의 에러 처리 패턴
class GameFileManager {
private:
    HANDLE m_hDataFile;
    HANDLE m_hLogFile;
    
public:
    BOOL Initialize(LPCWSTR dataFileName, LPCWSTR logFileName) {
        // 데이터 파일 열기
        m_hDataFile = SafeCreateFile(dataFileName, GENERIC_READ, FILE_SHARE_READ);
        if (!m_hDataFile) {
            LogError(L"데이터 파일 초기화 실패");
            return FALSE;
        }
        
        // 로그 파일 생성/열기
        m_hLogFile = CreateFileW(
            logFileName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            nullptr,
            CREATE_ALWAYS,  // 항상 새로 생성
            FILE_ATTRIBUTE_NORMAL,
            nullptr
        );
        
        if (m_hLogFile == INVALID_HANDLE_VALUE) {
            DWORD error = GetLastError();
            std::wcout << L"로그 파일 생성 실패: " << GetErrorMessage(error) << std::endl;
            CloseHandle(m_hDataFile);
            m_hDataFile = nullptr;
            return FALSE;
        }
        
        LogInfo(L"파일 매니저 초기화 완료");
        return TRUE;
    }
    
    void LogError(LPCWSTR message) {
        if (m_hLogFile) {
            std::wstring logEntry = L"[ERROR] " + std::wstring(message) + L"\r\n";
            DWORD bytesWritten;
            WriteFile(m_hLogFile, logEntry.c_str(), 
                     static_cast<DWORD>(logEntry.length() * sizeof(wchar_t)), 
                     &bytesWritten, nullptr);
        }
    }
    
    void LogInfo(LPCWSTR message) {
        if (m_hLogFile) {
            std::wstring logEntry = L"[INFO] " + std::wstring(message) + L"\r\n";
            DWORD bytesWritten;
            WriteFile(m_hLogFile, logEntry.c_str(), 
                     static_cast<DWORD>(logEntry.length() * sizeof(wchar_t)), 
                     &bytesWritten, nullptr);
        }
    }
};
```

### HRESULT를 이용한 COM 스타일 에러 처리
일부 Windows API는 HRESULT를 반환하여 성공/실패와 에러 정보를 함께 제공한다:

```cpp
#include <comdef.h>  // _com_error 클래스용

// HRESULT 성공/실패 매크로
// SUCCEEDED(hr) - 성공 여부 확인
// FAILED(hr) - 실패 여부 확인
// HRESULT_CODE(hr) - 에러 코드 추출

class GameCOMManager {
public:
    BOOL InitializeCOM() {
        // COM 라이브러리 초기화
        HRESULT hr = CoInitializeEx(nullptr, COINIT_MULTITHREADED);
        
        if (FAILED(hr)) {
            std::wcout << L"COM 초기화 실패: 0x" << std::hex << hr << std::endl;
            
            // HRESULT에서 에러 메시지 추출
            _com_error err(hr);
            std::wcout << L"에러 메시지: " << err.ErrorMessage() << std::endl;
            
            return FALSE;
        }
        
        std::wcout << L"COM 초기화 성공" << std::endl;
        return TRUE;
    }
    
    void Cleanup() {
        CoUninitialize();
    }
};

// 복합적인 에러 처리 클래스
class GameErrorHandler {
public:
    // Win32 에러 체크 매크로
    #define CHECK_WIN32(expr, action) \
        do { \
            if (!(expr)) { \
                DWORD error = GetLastError(); \
                LogWin32Error(L#expr, error, __FILE__, __LINE__); \
                action; \
            } \
        } while(0)
    
    // HRESULT 체크 매크로
    #define CHECK_HRESULT(expr, action) \
        do { \
            HRESULT hr = (expr); \
            if (FAILED(hr)) { \
                LogHRESULTError(L#expr, hr, __FILE__, __LINE__); \
                action; \
            } \
        } while(0)
    
private:
    static void LogWin32Error(LPCWSTR expression, DWORD error, LPCSTR file, int line) {
        std::wcout << L"Win32 Error in " << file << L":" << line << std::endl;
        std::wcout << L"Expression: " << expression << std::endl;
        std::wcout << L"Error Code: " << error << std::endl;
        std::wcout << L"Message: " << GetErrorMessage(error) << std::endl;
    }
    
    static void LogHRESULTError(LPCWSTR expression, HRESULT hr, LPCSTR file, int line) {
        std::wcout << L"HRESULT Error in " << file << L":" << line << std::endl;
        std::wcout << L"Expression: " << expression << std::endl;
        std::wcout << L"HRESULT: 0x" << std::hex << hr << std::endl;
        
        _com_error err(hr);
        std::wcout << L"Message: " << err.ErrorMessage() << std::endl;
    }
};

// 사용 예시
void GameServerExample() {
    GameErrorHandler errorHandler;
    
    // Win32 API 에러 체크
    HANDLE hEvent = CreateEventW(nullptr, TRUE, FALSE, L"GameServerEvent");
    CHECK_WIN32(hEvent != nullptr, return);
    
    // COM API 에러 체크  
    CHECK_HRESULT(CoInitialize(nullptr), return);
    
    // 정상 처리...
    
    CloseHandle(hEvent);
    CoUninitialize();
}
```
  

## 2.4 Unicode vs ANSI 문자열 처리

### Unicode 사용의 중요성
현대 게임 서버는 다국어 지원이 필수이므로 Unicode 사용이 권장된다:

```cpp
// 나쁜 예 - ANSI 사용
char playerName[] = "플레이어1";  // 한글이 깨질 수 있음

// 좋은 예 - Unicode 사용
wchar_t playerName[] = L"플레이어1";  // 모든 언어 지원
```

### 문자열 변환 함수들

```cpp
#include <string>
#include <locale>
#include <codecvt>

class GameStringUtils {
public:
    // ANSI → Unicode 변환
    static std::wstring AnsiToUnicode(const std::string& ansiStr) {
        if (ansiStr.empty()) return std::wstring();
        
        int size = MultiByteToWideChar(CP_ACP, 0, ansiStr.c_str(), -1, nullptr, 0);
        std::wstring wideStr(size - 1, 0);
        MultiByteToWideChar(CP_ACP, 0, ansiStr.c_str(), -1, &wideStr[0], size);
        
        return wideStr;
    }
    
    // Unicode → ANSI 변환
    static std::string UnicodeToAnsi(const std::wstring& wideStr) {
        if (wideStr.empty()) return std::string();
        
        int size = WideCharToMultiByte(CP_ACP, 0, wideStr.c_str(), -1, nullptr, 0, nullptr, nullptr);
        std::string ansiStr(size - 1, 0);
        WideCharToMultiByte(CP_ACP, 0, wideStr.c_str(), -1, &ansiStr[0], size, nullptr, nullptr);
        
        return ansiStr;
    }
    
    // UTF-8 → Unicode 변환 (네트워크 통신에서 자주 사용)
    static std::wstring UTF8ToUnicode(const std::string& utf8Str) {
        if (utf8Str.empty()) return std::wstring();
        
        int size = MultiByteToWideChar(CP_UTF8, 0, utf8Str.c_str(), -1, nullptr, 0);
        std::wstring wideStr(size - 1, 0);
        MultiByteToWideChar(CP_UTF8, 0, utf8Str.c_str(), -1, &wideStr[0], size);
        
        return wideStr;
    }
    
    // Unicode → UTF-8 변환
    static std::string UnicodeToUTF8(const std::wstring& wideStr) {
        if (wideStr.empty()) return std::string();
        
        int size = WideCharToMultiByte(CP_UTF8, 0, wideStr.c_str(), -1, nullptr, 0, nullptr, nullptr);
        std::string utf8Str(size - 1, 0);
        WideCharToMultiByte(CP_UTF8, 0, wideStr.c_str(), -1, &utf8Str[0], size, nullptr, nullptr);
        
        return utf8Str;
    }
};

// 게임 서버 패킷 처리 예시
struct GamePacket {
    DWORD packetType;
    WORD nameLength;
    wchar_t playerName[32];  // Unicode로 저장
    // ... 기타 필드들
};

class GamePacketProcessor {
public:
    void ProcessLoginPacket(const char* utf8Data, DWORD dataSize) {
        // 네트워크에서 받은 UTF-8 데이터를 Unicode로 변환
        std::string utf8PlayerName(utf8Data, dataSize);
        std::wstring unicodePlayerName = GameStringUtils::UTF8ToUnicode(utf8PlayerName);
        
        // 게임 내부에서는 Unicode 사용
        ProcessPlayerLogin(unicodePlayerName);
    }
    
    void SendPlayerName(const std::wstring& playerName) {
        // 클라이언트로 전송할 때는 UTF-8로 변환
        std::string utf8Name = GameStringUtils::UnicodeToUTF8(playerName);
        
        // 네트워크로 전송
        SendToClient(utf8Name.c_str(), static_cast<DWORD>(utf8Name.length()));
    }
    
private:
    void ProcessPlayerLogin(const std::wstring& playerName) {
        std::wcout << L"플레이어 로그인: " << playerName << std::endl;
        
        // 로그 파일에 Unicode로 기록
        WriteLogW(L"Player logged in: " + playerName);
    }
    
    void SendToClient(const char* data, DWORD size) {
        // 실제 네트워크 전송 코드
    }
    
    void WriteLogW(const std::wstring& message) {
        // Unicode 로그 기록
    }
};
```

### 안전한 문자열 처리

```cpp
// 버퍼 오버플로우 방지를 위한 안전한 문자열 함수들
class SafeStringOps {
public:
    // 안전한 문자열 복사
    static BOOL SafeStringCopy(wchar_t* dest, size_t destSize, const wchar_t* src) {
        if (!dest || !src || destSize == 0) return FALSE;
        
        HRESULT hr = StringCchCopyW(dest, destSize, src);
        return SUCCEEDED(hr);
    }
    
    // 안전한 문자열 연결
    static BOOL SafeStringConcat(wchar_t* dest, size_t destSize, const wchar_t* src) {
        if (!dest || !src || destSize == 0) return FALSE;
        
        HRESULT hr = StringCchCatW(dest, destSize, src);
        return SUCCEEDED(hr);
    }
    
    // 안전한 문자열 포맷팅
    template<typename... Args>
    static BOOL SafeStringFormat(wchar_t* dest, size_t destSize, const wchar_t* format, Args... args) {
        if (!dest || !format || destSize == 0) return FALSE;
        
        HRESULT hr = StringCchPrintfW(dest, destSize, format, args...);
        return SUCCEEDED(hr);
    }
};

// 게임 서버에서의 활용 예시
class GamePlayer {
private:
    wchar_t m_playerName[64];
    wchar_t m_guildName[32];
    DWORD m_playerId;
    
public:
    BOOL SetPlayerName(const wchar_t* name) {
        return SafeStringOps::SafeStringCopy(m_playerName, ARRAYSIZE(m_playerName), name);
    }
    
    BOOL SetGuildName(const wchar_t* guild) {
        return SafeStringOps::SafeStringCopy(m_guildName, ARRAYSIZE(m_guildName), guild);
    }
    
    std::wstring GetDisplayName() const {
        wchar_t displayName[128];
        
        if (wcslen(m_guildName) > 0) {
            // 길드가 있으면 "길드명] 플레이어명" 형식
            SafeStringOps::SafeStringFormat(displayName, ARRAYSIZE(displayName), 
                                          L"%s] %s", m_guildName, m_playerName);
        } else {
            // 길드가 없으면 플레이어명만
            SafeStringOps::SafeStringCopy(displayName, ARRAYSIZE(displayName), m_playerName);
        }
        
        return std::wstring(displayName);
    }
};
```
  

## 실전 예제: 게임 서버 기초 클래스
지금까지 학습한 내용을 종합하여 간단한 게임 서버 기초 클래스를 만들어보겠다:

```cpp
// GameServerBase.h
#pragma once
#include <windows.h>
#include <iostream>
#include <string>
#include <memory>

class GameServerBase {
private:
    HANDLE m_hStopEvent;      // 서버 종료 신호
    HANDLE m_hLogFile;        // 로그 파일 핸들
    DWORD m_dwStartTime;      // 서버 시작 시간
    std::wstring m_serverName; // 서버 이름
    BOOL m_bInitialized;      // 초기화 상태
    
    // 에러 메시지 변환 헬퍼
    std::wstring GetLastErrorMessage() const {
        DWORD error = GetLastError();
        LPWSTR messageBuffer = nullptr;
        
        FormatMessageW(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            nullptr, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            reinterpret_cast<LPWSTR>(&messageBuffer), 0, nullptr
        );
        
        std::wstring message(messageBuffer ? messageBuffer : L"Unknown error");
        if (messageBuffer) LocalFree(messageBuffer);
        
        return message;
    }
    
public:
    GameServerBase(const std::wstring& serverName) 
        : m_serverName(serverName)
        , m_hStopEvent(nullptr)
        , m_hLogFile(INVALID_HANDLE_VALUE)
        , m_dwStartTime(0)
        , m_bInitialized(FALSE) {
    }
    
    virtual ~GameServerBase() {
        Shutdown();
    }
    
    // 서버 초기화
    BOOL Initialize(const std::wstring& logFileName) {
        if (m_bInitialized) {
            WriteLog(L"WARNING", L"서버가 이미 초기화됨");
            return TRUE;
        }
        
        // 종료 이벤트 생성
        m_hStopEvent = CreateEventW(nullptr, TRUE, FALSE, nullptr);
        if (!m_hStopEvent) {
            std::wcout << L"이벤트 생성 실패: " << GetLastErrorMessage() << std::endl;
            return FALSE;
        }
        
        // 로그 파일 생성
        m_hLogFile = CreateFileW(
            logFileName.c_str(),
            GENERIC_WRITE,
            FILE_SHARE_READ,
            nullptr,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            nullptr
        );
        
        if (m_hLogFile == INVALID_HANDLE_VALUE) {
            std::wcout << L"로그 파일 생성 실패: " << GetLastErrorMessage() << std::endl;
            CloseHandle(m_hStopEvent);
            m_hStopEvent = nullptr;
            return FALSE;
        }
        
        m_dwStartTime = GetTickCount();
        m_bInitialized = TRUE;
        
        WriteLog(L"INFO", L"서버 초기화 완료: " + m_serverName);
        return TRUE;
    }
    
    // 서버 실행
    virtual void Run() {
        if (!m_bInitialized) {
            std::wcout << L"서버가 초기화되지 않음" << std::endl;
            return;
        }
        
        WriteLog(L"INFO", L"서버 시작");
        
        // 메인 루프
        while (WaitForSingleObject(m_hStopEvent, 100) == WAIT_TIMEOUT) {
            // 가상 함수로 구체적인 게임 로직 위임
            if (!ProcessGameLogic()) {
                WriteLog(L"ERROR", L"게임 로직 처리 중 오류 발생");
                break;
            }
        }
        
        WriteLog(L"INFO", L"서버 종료");
    }
    
    // 서버 종료
    void Stop() {
        if (m_hStopEvent) {
            SetEvent(m_hStopEvent);
            WriteLog(L"INFO", L"서버 종료 신호 전송");
        }
    }
    
    // 서버 정리
    void Shutdown() {
        if (m_hStopEvent) {
            CloseHandle(m_hStopEvent);
            m_hStopEvent = nullptr;
        }
        
        if (m_hLogFile != INVALID_HANDLE_VALUE) {
            CloseHandle(m_hLogFile);
            m_hLogFile = INVALID_HANDLE_VALUE;
        }
        
        m_bInitialized = FALSE;
    }
    
    // 업타임 반환 (밀리초)
    DWORD GetUptime() const {
        if (!m_bInitialized) return 0;
        return GetTickCount() - m_dwStartTime;
    }
    
    // 로그 기록
    void WriteLog(const std::wstring& level, const std::wstring& message) {
        if (m_hLogFile == INVALID_HANDLE_VALUE) return;
        
        // 현재 시간 구하기
        SYSTEMTIME st;
        GetLocalTime(&st);
        
        // 로그 포맷: [YYYY-MM-DD HH:MM:SS] [LEVEL] MESSAGE
        wchar_t timeBuffer[64];
        StringCchPrintfW(timeBuffer, ARRAYSIZE(timeBuffer),
                        L"[%04d-%02d-%02d %02d:%02d:%02d] [%s] %s\r\n",
                        st.wYear, st.wMonth, st.wDay,
                        st.wHour, st.wMinute, st.wSecond,
                        level.c_str(), message.c_str());
        
        DWORD bytesWritten;
        WriteFile(m_hLogFile, timeBuffer, 
                 static_cast<DWORD>(wcslen(timeBuffer) * sizeof(wchar_t)),
                 &bytesWritten, nullptr);
        
        // 콘솔에도 출력
        std::wcout << timeBuffer;
    }
    
protected:
    // 파생 클래스에서 구현할 가상 함수
    virtual BOOL ProcessGameLogic() = 0;
    
    // 유틸리티 함수들
    BOOL IsRunning() const {
        return m_hStopEvent && 
               WaitForSingleObject(m_hStopEvent, 0) == WAIT_TIMEOUT;
    }
};

// 구체적인 게임 서버 구현 예시
class SimpleGameServer : public GameServerBase {
private:
    DWORD m_dwPlayerCount;
    
public:
    SimpleGameServer() : GameServerBase(L"SimpleGameServer"), m_dwPlayerCount(0) {}
    
protected:
    virtual BOOL ProcessGameLogic() override {
        // 간단한 게임 로직 시뮬레이션
        static DWORD lastUpdate = GetTickCount();
        DWORD currentTime = GetTickCount();
        
        if (currentTime - lastUpdate >= 5000) {  // 5초마다
            // 플레이어 수 랜덤 변경 (시뮬레이션)
            m_dwPlayerCount = (m_dwPlayerCount + (rand() % 3 - 1)) % 100;
            
            wchar_t statusMsg[128];
            StringCchPrintfW(statusMsg, ARRAYSIZE(statusMsg),
                           L"현재 접속자 수: %d, 업타임: %d초",
                           m_dwPlayerCount, GetUptime() / 1000);
            
            WriteLog(L"STATUS", statusMsg);
            lastUpdate = currentTime;
        }
        
        return TRUE;
    }
};

// 사용 예시
int wmain(int argc, wchar_t* argv[]) {
    std::wcout << L"=== 게임 서버 Win32 API 기초 데모 ===" << std::endl;
    
    SimpleGameServer server;
    
    if (!server.Initialize(L"gameserver.log")) {
        std::wcout << L"서버 초기화 실패" << std::endl;
        return 1;
    }
    
    std::wcout << L"서버가 시작되었습니다. 'q'를 입력하면 종료됩니다." << std::endl;
    
    // 별도 스레드에서 서버 실행
    std::thread serverThread([&server]() {
        server.Run();
    });
    
    // 사용자 입력 대기
    char input;
    while (std::cin >> input && input != 'q') {
        // 계속 대기
    }
    
    server.Stop();
    serverThread.join();
    
    std::wcout << L"서버가 종료되었습니다." << std::endl;
    return 0;
}
```

이 장에서는 Win32 API의 기초적인 개념들을 학습했다. 다음 장부터는 이 기초 지식을 바탕으로 메모리 관리, 파일 시스템, 스레드 프로그래밍 등 게임 서버 개발에 핵심적인 시스템 프로그래밍 기법들을 깊이 있게 다루겠다.


