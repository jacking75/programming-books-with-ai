# 게임 서버 개발자를 위한 최신 Win32 API 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  

# Chapter 2. 메모리 관리
게임 서버에서 메모리 관리는 성능과 안정성을 결정하는 핵심 요소이다. 수천 명의 플레이어가 동시에 접속하는 환경에서는 효율적인 메모리 할당과 해제, 메모리 누수 방지, 그리고 캐시 친화적인 메모리 사용 패턴이 필수적이다. 이 장에서는 Win32 API를 활용한 고성능 메모리 관리 기법을 실무 중심으로 다룬다.

```
    ┌─────────────────────────────────────────────────────────────┐
    │                 Windows 메모리 계층 구조                      │
    │                                                             │
    │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐  │
    │  │   Application   │  │    Win32 API    │  │   Kernel    │  │
    │  │   (게임서버)     │  │                 │  │             │  │
    │  │                 │◄─┤• VirtualAlloc   │◄─┤• VMM        │  │
    │  │ Player Objects  │  │• HeapAlloc      │  │• Page Mgr   │  │
    │  │ Game Data       │  │• MapViewOfFile  │  │• Cache Mgr  │  │
    │  │ Network Buffers │  │• LocalAlloc     │  │• File Sys   │  │
    │  └─────────────────┘  └─────────────────┘  └─────────────┘  │
    │                                                             │
    │  Virtual Memory (4GB on 32bit, 16TB+ on 64bit)              │
    │  ┌─────────────────────────────────────────────────────┐    │
    │  │ [Stack] [Heap] [Code] [Data] [Memory Mapped Files]  │    │
    │  └─────────────────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────────────────┘
```
  

## 3.1 VirtualAlloc/VirtualFree를 이용한 대용량 메모리 관리

### VirtualAlloc의 개념과 장점
`VirtualAlloc`은 Windows의 가상 메모리 관리자와 직접 통신하여 메모리를 할당하는 저수준 API이다. 게임 서버에서는 다음과 같은 장점 때문에 자주 사용된다:

- **큰 블록 할당**: 메가바이트 단위의 대용량 메모리를 효율적으로 할당
- **페이지 단위 제어**: 4KB 페이지 단위로 세밀한 메모리 제어 가능
- **지연 커밋**: 필요한 시점에만 물리 메모리 할당 (Lazy Allocation)
- **메모리 보호**: 페이지별 접근 권한 설정 가능

```cpp
// VirtualAlloc 함수 시그니처
LPVOID VirtualAlloc(
    LPVOID lpAddress,        // 시작 주소 (보통 NULL)
    SIZE_T dwSize,           // 할당할 크기 (바이트)
    DWORD flAllocationType,  // 할당 타입
    DWORD flProtect          // 메모리 보호 설정
);

// 할당 타입 플래그
// MEM_COMMIT   - 물리 메모리와 연결된 가상 메모리 할당
// MEM_RESERVE  - 가상 주소 공간만 예약 (물리 메모리 할당 안함)
// MEM_RESET    - 페이지를 초기화하지 않음을 알림

// 보호 설정
// PAGE_READWRITE    - 읽기/쓰기 가능
// PAGE_READONLY     - 읽기 전용
// PAGE_NOACCESS     - 접근 불가
// PAGE_GUARD        - 가드 페이지 (접근시 예외 발생)
```

### 게임 서버용 대용량 메모리 할당자 구현

```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include <mutex>
#include <unordered_map>

class GameVirtualAllocator {
private:
    struct AllocationInfo {
        LPVOID baseAddress;
        SIZE_T size;
        DWORD allocationType;
        DWORD protection;
        DWORD timestamp;
    };
    
    std::mutex m_mutex;
    std::unordered_map<LPVOID, AllocationInfo> m_allocations;
    SIZE_T m_totalAllocated;
    SIZE_T m_totalCommitted;
    
public:
    GameVirtualAllocator() : m_totalAllocated(0), m_totalCommitted(0) {}
    
    ~GameVirtualAllocator() {
        FreeAllAllocations();
    }
    
    // 대용량 메모리 블록 할당
    LPVOID AllocateLargeBlock(SIZE_T size, BOOL commitNow = TRUE) {
        // 페이지 크기로 정렬
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo);
        SIZE_T alignedSize = (size + sysInfo.dwPageSize - 1) & ~(sysInfo.dwPageSize - 1);
        
        DWORD allocType = MEM_RESERVE;
        if (commitNow) {
            allocType |= MEM_COMMIT;
        }
        
        LPVOID memory = VirtualAlloc(
            nullptr,                // 시스템이 주소 선택
            alignedSize,
            allocType,
            PAGE_READWRITE
        );
        
        if (memory == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"VirtualAlloc 실패: " << error << std::endl;
            return nullptr;
        }
        
        // 할당 정보 추가
        std::lock_guard<std::mutex> lock(m_mutex);
        AllocationInfo info = {
            memory,
            alignedSize,
            allocType,
            PAGE_READWRITE,
            GetTickCount()
        };
        m_allocations[memory] = info;
        m_totalAllocated += alignedSize;
        
        if (commitNow) {
            m_totalCommitted += alignedSize;
        }
        
        std::wcout << L"할당 완료: " << memory 
                  << L", 크기: " << alignedSize / 1024 << L"KB" << std::endl;
        
        return memory;
    }
    
    // 지연 커밋 (Reserve된 메모리를 실제로 커밋)
    BOOL CommitMemory(LPVOID baseAddress, SIZE_T size) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_allocations.find(baseAddress);
        if (it == m_allocations.end()) {
            std::wcout << L"잘못된 주소: " << baseAddress << std::endl;
            return FALSE;
        }
        
        LPVOID result = VirtualAlloc(
            baseAddress,
            size,
            MEM_COMMIT,
            PAGE_READWRITE
        );
        
        if (result == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"커밋 실패: " << error << std::endl;
            return FALSE;
        }
        
        m_totalCommitted += size;
        std::wcout << L"커밋 완료: " << baseAddress 
                  << L", 크기: " << size / 1024 << L"KB" << std::endl;
        
        return TRUE;
    }
    
    // 메모리 해제
    BOOL FreeMemory(LPVOID memory) {
        if (memory == nullptr) return FALSE;
        
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_allocations.find(memory);
        if (it == m_allocations.end()) {
            std::wcout << L"해제할 메모리를 찾을 수 없음: " << memory << std::endl;
            return FALSE;
        }
        
        SIZE_T size = it->second.size;
        
        if (!VirtualFree(memory, 0, MEM_RELEASE)) {
            DWORD error = GetLastError();
            std::wcout << L"VirtualFree 실패: " << error << std::endl;
            return FALSE;
        }
        
        m_totalAllocated -= size;
        m_totalCommitted -= size;  // 간단화를 위해
        m_allocations.erase(it);
        
        std::wcout << L"해제 완료: " << memory 
                  << L", 크기: " << size / 1024 << L"KB" << std::endl;
        
        return TRUE;
    }
    
    // 모든 할당 해제
    void FreeAllAllocations() {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        for (auto& pair : m_allocations) {
            VirtualFree(pair.first, 0, MEM_RELEASE);
        }
        
        m_allocations.clear();
        m_totalAllocated = 0;
        m_totalCommitted = 0;
    }
    
    // 메모리 사용량 정보
    void PrintMemoryStats() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        std::wcout << L"\n=== 메모리 사용량 통계 ===" << std::endl;
        std::wcout << L"총 할당량: " << m_totalAllocated / 1024 << L"KB" << std::endl;
        std::wcout << L"커밋된 양: " << m_totalCommitted / 1024 << L"KB" << std::endl;
        std::wcout << L"할당 블록 수: " << m_allocations.size() << std::endl;
        
        // 시스템 메모리 정보
        MEMORYSTATUSEX memStatus;
        memStatus.dwLength = sizeof(memStatus);
        if (GlobalMemoryStatusEx(&memStatus)) {
            std::wcout << L"시스템 총 물리 메모리: " 
                      << memStatus.ullTotalPhys / (1024 * 1024) << L"MB" << std::endl;
            std::wcout << L"사용 가능한 물리 메모리: " 
                      << memStatus.ullAvailPhys / (1024 * 1024) << L"MB" << std::endl;
        }
    }
};

// 게임 서버에서의 사용 예시
class GameWorldData {
private:
    GameVirtualAllocator m_allocator;
    LPVOID m_worldBuffer;
    LPVOID m_playerBuffer;
    LPVOID m_npcBuffer;
    
    static const SIZE_T WORLD_DATA_SIZE = 64 * 1024 * 1024;   // 64MB
    static const SIZE_T PLAYER_DATA_SIZE = 32 * 1024 * 1024;  // 32MB
    static const SIZE_T NPC_DATA_SIZE = 16 * 1024 * 1024;     // 16MB
    
public:
    BOOL Initialize() {
        std::wcout << L"게임 월드 데이터 초기화 중..." << std::endl;
        
        // 월드 데이터용 메모리 할당 (즉시 커밋)
        m_worldBuffer = m_allocator.AllocateLargeBlock(WORLD_DATA_SIZE, TRUE);
        if (!m_worldBuffer) {
            std::wcout << L"월드 데이터 메모리 할당 실패" << std::endl;
            return FALSE;
        }
        
        // 플레이어 데이터용 메모리 예약 (지연 커밋)
        m_playerBuffer = m_allocator.AllocateLargeBlock(PLAYER_DATA_SIZE, FALSE);
        if (!m_playerBuffer) {
            std::wcout << L"플레이어 데이터 메모리 예약 실패" << std::endl;
            return FALSE;
        }
        
        // NPC 데이터용 메모리 할당
        m_npcBuffer = m_allocator.AllocateLargeBlock(NPC_DATA_SIZE, TRUE);
        if (!m_npcBuffer) {
            std::wcout << L"NPC 데이터 메모리 할당 실패" << std::endl;
            return FALSE;
        }
        
        // 월드 데이터 초기화
        ZeroMemory(m_worldBuffer, WORLD_DATA_SIZE);
        ZeroMemory(m_npcBuffer, NPC_DATA_SIZE);
        
        std::wcout << L"게임 월드 데이터 초기화 완료" << std::endl;
        m_allocator.PrintMemoryStats();
        
        return TRUE;
    }
    
    // 플레이어 접속 시 메모리 커밋
    BOOL OnPlayerConnect(DWORD playerId) {
        // 플레이어 하나당 1KB 가정
        SIZE_T playerSize = 1024;
        SIZE_T offset = (playerId % 32768) * playerSize;  // 최대 32K 플레이어
        
        if (offset + playerSize > PLAYER_DATA_SIZE) {
            std::wcout << L"플레이어 버퍼 초과: " << playerId << std::endl;
            return FALSE;
        }
        
        // 필요한 페이지만 커밋
        LPVOID playerMemory = static_cast<char*>(m_playerBuffer) + offset;
        return m_allocator.CommitMemory(playerMemory, playerSize);
    }
    
    void Cleanup() {
        m_allocator.FreeAllAllocations();
        m_worldBuffer = nullptr;
        m_playerBuffer = nullptr;
        m_npcBuffer = nullptr;
    }
    
    void* GetWorldData() { return m_worldBuffer; }
    void* GetPlayerData() { return m_playerBuffer; }
    void* GetNPCData() { return m_npcBuffer; }
};
```
    
이 코드는 Windows의 가상 메모리 API를 활용하여 게임 서버에서 대용량 메모리를 효율적으로 관리하는 클래스 구현이다. 

#### GameVirtualAllocator 클래스 - 핵심 메모리 관리자

```cpp
class GameVirtualAllocator {
private:
    struct AllocationInfo {
        LPVOID baseAddress;
        SIZE_T size;
        DWORD allocationType;
        DWORD protection;
        DWORD timestamp;
    };
    
    std::mutex m_mutex;
    std::unordered_map<LPVOID, AllocationInfo> m_allocations;
    SIZE_T m_totalAllocated;
    SIZE_T m_totalCommitted;
};
```

이 부분은 메모리 할당자의 기본 구조를 정의한다. `AllocationInfo` 구조체는 각 메모리 블록의 메타데이터를 저장하며, 기본 주소, 크기, 할당 타입, 보호 속성, 타임스탐프를 포함한다. `m_mutex`는 멀티스레드 환경에서 동시성을 제어하고, `m_allocations` 맵은 할당된 모든 메모리 블록을 추적한다. `m_totalAllocated`와 `m_totalCommitted`는 전체 메모리 사용량을 기록한다.

#### AllocateLargeBlock 함수 - 대용량 메모리 할당

```cpp
LPVOID AllocateLargeBlock(SIZE_T size, BOOL commitNow = TRUE) {
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    SIZE_T alignedSize = (size + sysInfo.dwPageSize - 1) & ~(sysInfo.dwPageSize - 1);
    
    DWORD allocType = MEM_RESERVE;
    if (commitNow) {
        allocType |= MEM_COMMIT;
    }
    
    LPVOID memory = VirtualAlloc(
        nullptr,
        alignedSize,
        allocType,
        PAGE_READWRITE
    );
    
    // ... 에러 처리 및 메타데이터 저장
}
```

이 함수는 대용량 메모리 블록을 할당한다. 먼저 시스템 페이지 크기에 맞춰 메모리 크기를 정렬하며, `commitNow` 파라미터가 참이면 즉시 물리 메모리를 할당(MEM_RESERVE | MEM_COMMIT)하고, 거짓이면 주소 공간만 예약(MEM_RESERVE)한다. 이는 대용량 메모리가 필요하지만 즉시 사용하지 않을 때 메모리를 절약할 수 있게 한다.

#### CommitMemory 함수 - 지연 커밋 구현

```cpp
BOOL CommitMemory(LPVOID baseAddress, SIZE_T size) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_allocations.find(baseAddress);
    if (it == m_allocations.end()) {
        std::wcout << L"잘못된 주소: " << baseAddress << std::endl;
        return FALSE;
    }
    
    LPVOID result = VirtualAlloc(
        baseAddress,
        size,
        MEM_COMMIT,
        PAGE_READWRITE
    );
    
    // ... 결과 처리
}
```

지연 커밋 기능을 제공한다. 이미 예약된 메모리 영역에 대해 필요할 때만 실제 물리 메모리를 할당한다. 예약된 주소가 유효한지 확인한 후 `MEM_COMMIT` 플래그로 해당 영역의 물리 메모리를 할당한다.

#### FreeMemory 함수 - 메모리 해제

```cpp
BOOL FreeMemory(LPVOID memory) {
    if (memory == nullptr) return FALSE;
    
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_allocations.find(memory);
    if (it == m_allocations.end()) {
        return FALSE;
    }
    
    SIZE_T size = it->second.size;
    
    if (!VirtualFree(memory, 0, MEM_RELEASE)) {
        return FALSE;
    }
    
    m_totalAllocated -= size;
    m_totalCommitted -= size;
    m_allocations.erase(it);
}
```

할당된 메모리를 해제한다. 먼저 메모리 블록이 할당 맵에 존재하는지 확인하고, `VirtualFree`로 메모리를 반환한 후 메타데이터를 업데이트한다. 뮤텍스로 보호되어 스레드 안전성을 보장한다.

#### PrintMemoryStats 함수 - 메모리 통계

```cpp
void PrintMemoryStats() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    std::wcout << L"\n=== 메모리 사용량 통계 ===" << std::endl;
    std::wcout << L"총 할당량: " << m_totalAllocated / 1024 << L"KB" << std::endl;
    std::wcout << L"커밋된 양: " << m_totalCommitted / 1024 << L"KB" << std::endl;
    std::wcout << L"할당 블록 수: " << m_allocations.size() << std::endl;
    
    MEMORYSTATUSEX memStatus;
    memStatus.dwLength = sizeof(memStatus);
    if (GlobalMemoryStatusEx(&memStatus)) {
        // ... 시스템 메모리 정보 출력
    }
}
```

할당자의 메모리 사용량과 시스템 전체 메모리 상태를 출력한다. 할당된 메모리, 커밋된 메모리, 할당 블록 개수와 함께 시스템의 총 물리 메모리와 사용 가능한 메모리를 보여준다.

#### GameWorldData 클래스 - 실제 사용 예시

```cpp
class GameWorldData {
private:
    GameVirtualAllocator m_allocator;
    LPVOID m_worldBuffer;
    LPVOID m_playerBuffer;
    LPVOID m_npcBuffer;
    
    static const SIZE_T WORLD_DATA_SIZE = 64 * 1024 * 1024;
    static const SIZE_T PLAYER_DATA_SIZE = 32 * 1024 * 1024;
    static const SIZE_T NPC_DATA_SIZE = 16 * 1024 * 1024;
};
```

게임 월드의 실제 데이터를 관리하는 클래스이다. 월드 데이터(64MB), 플레이어 데이터(32MB), NPC 데이터(16MB)를 별도의 메모리 버퍼로 관리한다.

#### Initialize 함수 - 초기화 로직

```cpp
BOOL Initialize() {
    m_worldBuffer = m_allocator.AllocateLargeBlock(WORLD_DATA_SIZE, TRUE);
    m_playerBuffer = m_allocator.AllocateLargeBlock(PLAYER_DATA_SIZE, FALSE);
    m_npcBuffer = m_allocator.AllocateLargeBlock(NPC_DATA_SIZE, TRUE);
    
    ZeroMemory(m_worldBuffer, WORLD_DATA_SIZE);
    ZeroMemory(m_npcBuffer, NPC_DATA_SIZE);
    
    m_allocator.PrintMemoryStats();
    return TRUE;
}
```

게임 서버 초기화 시 필요한 메모리 버퍼를 할당한다. 월드와 NPC 데이터는 즉시 필요하므로 `commitNow = TRUE`로 할당하고, 플레이어 데이터는 플레이어 접속 시까지 필요 없으므로 `commitNow = FALSE`로 주소 공간만 예약한다.

#### OnPlayerConnect 함수 - 동적 메모리 커밋

```cpp
BOOL OnPlayerConnect(DWORD playerId) {
    SIZE_T playerSize = 1024;
    SIZE_T offset = (playerId % 32768) * playerSize;
    
    if (offset + playerSize > PLAYER_DATA_SIZE) {
        return FALSE;
    }
    
    LPVOID playerMemory = static_cast<char*>(m_playerBuffer) + offset;
    return m_allocator.CommitMemory(playerMemory, playerSize);
}
```

플레이어가 게임에 접속할 때 호출되는 함수이다. 플레이어별로 1KB의 메모리를 필요로 하며, 플레이어의 ID를 기반으로 예약된 플레이어 버퍼 내에서 오프셋을 계산한 후 해당 영역을 실제로 커밋한다. 이를 통해 최대 32,000명의 플레이어를 지원할 수 있다.

#### 핵심 설계 원칙
이 구현의 주요 특징은 세 가지이다. 첫째, Windows 가상 메모리의 Reserve와 Commit을 분리하여 대용량 메모리를 효율적으로 관리한다. 둘째, 뮤텍스를 활용한 스레드 안전성 보장으로 멀티스레드 게임 서버 환경에 적합하다. 셋째, 메모리 메타데이터 추적으로 메모리 누수를 방지하고 통계 정보를 제공한다. 이는 많은 동시 사용자를 처리하는 게임 서버에서 메모리를 효율적으로 할당하고 관리하기 위한 패턴을 보여준다.    
  
</br>  
  

## 3.2 힙 관리 (HeapCreate, HeapAlloc)

### 프로세스 힙과 프라이빗 힙
Windows는 각 프로세스마다 기본 힙(Default Heap)을 제공하지만, 게임 서버에서는 용도별로 별도의 힙을 생성하여 사용하는 것이 효율적이다.

```
    힙 관리 구조:
    ═══════════════════════════════════════════════════════════
    
    Process Memory Space
    ┌─────────────────────────────────────────────────────┐
    │                                                     │
    │  Default Heap        Custom Heaps                   │
    │  ┌─────────────┐    ┌─────────────┐                │
    │  │• CRT malloc │    │ Game Object │                │
    │  │• new/delete │    │    Heap     │                │
    │  │• LocalAlloc │    └─────────────┘                │
    │  └─────────────┘    ┌─────────────┐                │
    │                     │ Network     │                │
    │                     │ Buffer Heap │                │
    │                     └─────────────┘                │
    │                     ┌─────────────┐                │
    │                     │ Temporary   │                │
    │                     │ Data Heap   │                │
    │                     └─────────────┘                │
    └─────────────────────────────────────────────────────┘
```

### 게임 서버용 힙 관리자 구현

```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <mutex>
#include <string>

class GameHeapManager {
public:
    enum class HeapType {
        GAME_OBJECTS,    // 게임 오브젝트용
        NETWORK_BUFFERS, // 네트워크 버퍼용
        TEMPORARY_DATA,  // 임시 데이터용
        LOG_DATA        // 로그 데이터용
    };
    
private:
    struct HeapInfo {
        HANDLE hHeap;
        std::wstring name;
        SIZE_T totalAllocated;
        SIZE_T allocationCount;
        DWORD creationFlags;
        SIZE_T initialSize;
        SIZE_T maxSize;
    };
    
    std::mutex m_mutex;
    std::unordered_map<HeapType, HeapInfo> m_heaps;
    std::unordered_map<LPVOID, HeapType> m_allocationMap;
    
public:
    GameHeapManager() = default;
    
    ~GameHeapManager() {
        DestroyAllHeaps();
    }
    
    // 힙 생성
    BOOL CreateGameHeap(HeapType type, const std::wstring& name, 
                       SIZE_T initialSize, SIZE_T maxSize = 0, 
                       DWORD flags = 0) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_heaps.find(type) != m_heaps.end()) {
            std::wcout << L"힙이 이미 존재함: " << name << std::endl;
            return FALSE;
        }
        
        // 기본 플래그 설정
        DWORD heapFlags = flags;
        if (type == HeapType::NETWORK_BUFFERS) {
            // 네트워크 버퍼는 직렬화 비활성화로 성능 향상
            heapFlags |= HEAP_NO_SERIALIZE;
        }
        
        HANDLE hHeap = HeapCreate(heapFlags, initialSize, maxSize);
        if (hHeap == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"힙 생성 실패: " << name << L", 에러: " << error << std::endl;
            return FALSE;
        }
        
        HeapInfo info = {
            hHeap,
            name,
            0,      // totalAllocated
            0,      // allocationCount
            heapFlags,
            initialSize,
            maxSize
        };
        
        m_heaps[type] = info;
        
        std::wcout << L"힙 생성 완료: " << name 
                  << L", 초기 크기: " << initialSize / 1024 << L"KB" << std::endl;
        
        return TRUE;
    }
    
    // 메모리 할당
    LPVOID AllocateFromHeap(HeapType type, SIZE_T size, BOOL zeroMemory = TRUE) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_heaps.find(type);
        if (it == m_heaps.end()) {
            std::wcout << L"힙을 찾을 수 없음: " << static_cast<int>(type) << std::endl;
            return nullptr;
        }
        
        DWORD flags = zeroMemory ? HEAP_ZERO_MEMORY : 0;
        LPVOID memory = HeapAlloc(it->second.hHeap, flags, size);
        
        if (memory == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"힙 할당 실패: " << it->second.name 
                      << L", 크기: " << size << L", 에러: " << error << std::endl;
            return nullptr;
        }
        
        // 통계 업데이트
        it->second.totalAllocated += size;
        it->second.allocationCount++;
        m_allocationMap[memory] = type;
        
        return memory;
    }
    
    // 메모리 재할당
    LPVOID ReallocateFromHeap(LPVOID memory, SIZE_T newSize) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto allocIt = m_allocationMap.find(memory);
        if (allocIt == m_allocationMap.end()) {
            std::wcout << L"재할당할 메모리를 찾을 수 없음: " << memory << std::endl;
            return nullptr;
        }
        
        HeapType type = allocIt->second;
        auto heapIt = m_heaps.find(type);
        if (heapIt == m_heaps.end()) {
            return nullptr;
        }
        
        LPVOID newMemory = HeapReAlloc(heapIt->second.hHeap, HEAP_ZERO_MEMORY, memory, newSize);
        
        if (newMemory == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"힙 재할당 실패: " << heapIt->second.name 
                      << L", 새 크기: " << newSize << L", 에러: " << error << std::endl;
            return nullptr;
        }
        
        // 주소가 변경된 경우 맵 업데이트
        if (newMemory != memory) {
            m_allocationMap.erase(allocIt);
            m_allocationMap[newMemory] = type;
        }
        
        return newMemory;
    }
    
    // 메모리 해제
    BOOL FreeFromHeap(LPVOID memory) {
        if (memory == nullptr) return TRUE;
        
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto allocIt = m_allocationMap.find(memory);
        if (allocIt == m_allocationMap.end()) {
            std::wcout << L"해제할 메모리를 찾을 수 없음: " << memory << std::endl;
            return FALSE;
        }
        
        HeapType type = allocIt->second;
        auto heapIt = m_heaps.find(type);
        if (heapIt == m_heaps.end()) {
            return FALSE;
        }
        
        if (!HeapFree(heapIt->second.hHeap, 0, memory)) {
            DWORD error = GetLastError();
            std::wcout << L"힙 해제 실패: " << heapIt->second.name 
                      << L", 에러: " << error << std::endl;
            return FALSE;
        }
        
        heapIt->second.allocationCount--;
        m_allocationMap.erase(allocIt);
        
        return TRUE;
    }
    
    // 힙 압축 (조각 모음)
    BOOL CompactHeap(HeapType type) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_heaps.find(type);
        if (it == m_heaps.end()) {
            return FALSE;
        }
        
        SIZE_T compactedSize = HeapCompact(it->second.hHeap, 0);
        
        std::wcout << L"힙 압축 완료: " << it->second.name 
                  << L", 압축된 크기: " << compactedSize << L" bytes" << std::endl;
        
        return compactedSize != 0;
    }
    
    // 힙 검증 (디버그 빌드에서만)
    BOOL ValidateHeap(HeapType type) {
        #ifdef _DEBUG
            std::lock_guard<std::mutex> lock(m_mutex);
            
            auto it = m_heaps.find(type);
            if (it == m_heaps.end()) {
                return FALSE;
            }
            
            BOOL isValid = HeapValidate(it->second.hHeap, 0, nullptr);
            
            if (!isValid) {
                std::wcout << L"힙 검증 실패: " << it->second.name << std::endl;
            }
            
            return isValid;
        #else
            return TRUE;  // Release 빌드에서는 항상 성공
        #endif
    }
    
    // 힙 통계 출력
    void PrintHeapStats() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        std::wcout << L"\n=== 힙 사용량 통계 ===" << std::endl;
        
        for (const auto& pair : m_heaps) {
            const HeapInfo& info = pair.second;
            
            // 힙 크기 정보 가져오기
            PROCESS_HEAP_ENTRY entry;
            entry.lpData = nullptr;
            
            SIZE_T totalSize = 0;
            SIZE_T usedSize = 0;
            DWORD blockCount = 0;
            
            while (HeapWalk(info.hHeap, &entry)) {
                if (entry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
                    usedSize += entry.cbData;
                }
                totalSize += entry.cbData;
                blockCount++;
            }
            
            std::wcout << L"힙: " << info.name << std::endl;
            std::wcout << L"  총 크기: " << totalSize / 1024 << L"KB" << std::endl;
            std::wcout << L"  사용 중: " << usedSize / 1024 << L"KB" << std::endl;
            std::wcout << L"  할당 수: " << info.allocationCount << std::endl;
            std::wcout << L"  블록 수: " << blockCount << std::endl;
            std::wcout << L"  플래그: 0x" << std::hex << info.creationFlags << std::dec << std::endl;
            std::wcout << std::endl;
        }
    }
    
    // 모든 힙 파괴
    void DestroyAllHeaps() {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        for (auto& pair : m_heaps) {
            HeapDestroy(pair.second.hHeap);
            std::wcout << L"힙 파괴: " << pair.second.name << std::endl;
        }
        
        m_heaps.clear();
        m_allocationMap.clear();
    }
    
    // 특정 힙의 핸들 반환 (고급 사용자용)
    HANDLE GetHeapHandle(HeapType type) const {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_heaps.find(type);
        return (it != m_heaps.end()) ? it->second.hHeap : nullptr;
    }
};

// 게임 오브젝트용 스마트 포인터
template<typename T>
class GameHeapPtr {
private:
    T* m_ptr;
    GameHeapManager* m_heapManager;
    GameHeapManager::HeapType m_heapType;
    
public:
    GameHeapPtr(GameHeapManager* heapMgr, GameHeapManager::HeapType type)
        : m_ptr(nullptr), m_heapManager(heapMgr), m_heapType(type) {}
    
    ~GameHeapPtr() {
        Reset();
    }
    
    // 복사 금지
    GameHeapPtr(const GameHeapPtr&) = delete;
    GameHeapPtr& operator=(const GameHeapPtr&) = delete;
    
    // 이동 생성자
    GameHeapPtr(GameHeapPtr&& other) noexcept
        : m_ptr(other.m_ptr), m_heapManager(other.m_heapManager), m_heapType(other.m_heapType) {
        other.m_ptr = nullptr;
    }
    
    // 이동 대입 연산자
    GameHeapPtr& operator=(GameHeapPtr&& other) noexcept {
        if (this != &other) {
            Reset();
            m_ptr = other.m_ptr;
            m_heapManager = other.m_heapManager;
            m_heapType = other.m_heapType;
            other.m_ptr = nullptr;
        }
        return *this;
    }
    
    // 객체 생성
    template<typename... Args>
    BOOL Create(Args&&... args) {
        Reset();
        
        m_ptr = static_cast<T*>(m_heapManager->AllocateFromHeap(m_heapType, sizeof(T)));
        if (m_ptr == nullptr) {
            return FALSE;
        }
        
        // placement new로 생성자 호출
        new(m_ptr) T(std::forward<Args>(args)...);
        return TRUE;
    }
    
    // 메모리 해제
    void Reset() {
        if (m_ptr) {
            m_ptr->~T();  // 소멸자 호출
            m_heapManager->FreeFromHeap(m_ptr);
            m_ptr = nullptr;
        }
    }
    
    // 접근 연산자
    T* operator->() { return m_ptr; }
    const T* operator->() const { return m_ptr; }
    T& operator*() { return *m_ptr; }
    const T& operator*() const { return *m_ptr; }
    
    // 포인터 반환
    T* Get() { return m_ptr; }
    const T* Get() const { return m_ptr; }
    
    // 유효성 검사
    BOOL IsValid() const { return m_ptr != nullptr; }
    operator bool() const { return IsValid(); }
};

// 사용 예시
struct GamePlayer {
    DWORD playerId;
    wchar_t playerName[32];
    FLOAT posX, posY, posZ;
    DWORD level;
    
    GamePlayer(DWORD id, const wchar_t* name) : playerId(id), level(1) {
        wcscpy_s(playerName, name);
        posX = posY = posZ = 0.0f;
    }
    
    ~GamePlayer() {
        std::wcout << L"플레이어 소멸: " << playerName << std::endl;
    }
};

// 게임 서버 힙 사용 예시
void DemonstrateHeapUsage() {
    std::wcout << L"=== 게임 서버 힙 관리 데모 ===" << std::endl;
    
    GameHeapManager heapManager;
    
    // 각종 힙 생성
    heapManager.CreateGameHeap(GameHeapManager::HeapType::GAME_OBJECTS, 
                              L"GameObjects", 1024 * 1024, 10 * 1024 * 1024);  // 1MB ~ 10MB
    
    heapManager.CreateGameHeap(GameHeapManager::HeapType::NETWORK_BUFFERS, 
                              L"NetworkBuffers", 512 * 1024, 5 * 1024 * 1024, 
                              HEAP_NO_SERIALIZE);  // 512KB ~ 5MB, 직렬화 비활성화
    
    heapManager.CreateGameHeap(GameHeapManager::HeapType::TEMPORARY_DATA, 
                              L"TempData", 256 * 1024, 2 * 1024 * 1024);  // 256KB ~ 2MB
    
    // 게임 플레이어 객체 생성
    std::vector<GameHeapPtr<GamePlayer>> players;
    
    for (int i = 0; i < 10; ++i) {
        GameHeapPtr<GamePlayer> player(&heapManager, GameHeapManager::HeapType::GAME_OBJECTS);
        
        wchar_t name[32];
        swprintf_s(name, L"Player%d", i + 1);
        
        if (player.Create(i + 1, name)) {
            player->level = (i % 5) + 1;
            player->posX = static_cast<float>(i * 10);
            players.push_back(std::move(player));
        }
    }
    
    // 네트워크 버퍼 할당
    std::vector<LPVOID> networkBuffers;
    for (int i = 0; i < 5; ++i) {
        LPVOID buffer = heapManager.AllocateFromHeap(
            GameHeapManager::HeapType::NETWORK_BUFFERS, 1024);
        if (buffer) {
            networkBuffers.push_back(buffer);
        }
    }
    
    // 힙 상태 출력
    heapManager.PrintHeapStats();
    
    // 힙 검증 (디버그 빌드에서만)
    heapManager.ValidateHeap(GameHeapManager::HeapType::GAME_OBJECTS);
    heapManager.ValidateHeap(GameHeapManager::HeapType::NETWORK_BUFFERS);
    
    // 네트워크 버퍼 해제
    for (LPVOID buffer : networkBuffers) {
        heapManager.FreeFromHeap(buffer);
    }
    
    // 힙 압축
    heapManager.CompactHeap(GameHeapManager::HeapType::NETWORK_BUFFERS);
    
    std::wcout << L"데모 완료 - 자동으로 정리됩니다..." << std::endl;
    
    // players 벡터와 heapManager가 소멸되면서 자동으로 정리됨
}
```
    
이 코드는 Windows의 힙 API를 활용하여 게임 서버에서 메모리를 효율적으로 관리하는 시스템을 구현한다. 복잡한 코드를 부분별로 나누어 설명한다.


#### GameHeapManager 클래스 - 기본 구조. 열거형과 구조체 정의

```cpp
class GameHeapManager {
public:
    enum class HeapType {
        GAME_OBJECTS,
        NETWORK_BUFFERS,
        TEMPORARY_DATA,
        LOG_DATA
    };
    
private:
    struct HeapInfo {
        HANDLE hHeap;
        std::wstring name;
        SIZE_T totalAllocated;
        SIZE_T allocationCount;
        DWORD creationFlags;
        SIZE_T initialSize;
        SIZE_T maxSize;
    };
    
    std::mutex m_mutex;
    std::unordered_map<HeapType, HeapInfo> m_heaps;
    std::unordered_map<LPVOID, HeapType> m_allocationMap;
};
```

게임 서버에서 용도별로 힙을 관리한다. `HeapType` 열거형은 게임 오브젝트, 네트워크 버퍼, 임시 데이터, 로그 데이터 등 네 가지 용도를 정의한다. `HeapInfo` 구조체는 각 힙의 메타데이터를 저장하며 힙 핸들, 이름, 할당량, 할당 횟수, 플래그, 초기 크기, 최대 크기를 포함한다. `m_mutex`는 멀티스레드 환경에서의 동기화를 담당하고, `m_heaps`는 유형별 힙 정보를 관리하며, `m_allocationMap`은 메모리 포인터와 해당 힙 유형의 매핑을 유지한다.

#### GameHeapManager 클래스 - 기본 구조. 힙 생성 함수

```cpp
BOOL CreateGameHeap(HeapType type, const std::wstring& name, 
                   SIZE_T initialSize, SIZE_T maxSize = 0, 
                   DWORD flags = 0) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (m_heaps.find(type) != m_heaps.end()) {
        std::wcout << L"힙이 이미 존재함: " << name << std::endl;
        return FALSE;
    }
    
    DWORD heapFlags = flags;
    if (type == HeapType::NETWORK_BUFFERS) {
        heapFlags |= HEAP_NO_SERIALIZE;
    }
    
    HANDLE hHeap = HeapCreate(heapFlags, initialSize, maxSize);
    if (hHeap == nullptr) {
        DWORD error = GetLastError();
        std::wcout << L"힙 생성 실패: " << name << L", 에러: " << error << std::endl;
        return FALSE;
    }
    
    HeapInfo info = {hHeap, name, 0, 0, heapFlags, initialSize, maxSize};
    m_heaps[type] = info;
    
    std::wcout << L"힙 생성 완료: " << name 
              << L", 초기 크기: " << initialSize / 1024 << L"KB" << std::endl;
    
    return TRUE;
}
```

새로운 힙을 생성한다. 동일한 유형의 힙이 이미 존재하는지 확인하고, 네트워크 버퍼 힙에는 `HEAP_NO_SERIALIZE` 플래그를 자동으로 추가하여 성능을 향상한다. `HeapCreate` 함수로 힙을 생성하고 성공 여부를 확인한 후 메타데이터를 저장한다.


#### 메모리 할당 관련 함수. 메모리 할당

```cpp
LPVOID AllocateFromHeap(HeapType type, SIZE_T size, BOOL zeroMemory = TRUE) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_heaps.find(type);
    if (it == m_heaps.end()) {
        std::wcout << L"힙을 찾을 수 없음: " << static_cast<int>(type) << std::endl;
        return nullptr;
    }
    
    DWORD flags = zeroMemory ? HEAP_ZERO_MEMORY : 0;
    LPVOID memory = HeapAlloc(it->second.hHeap, flags, size);
    
    if (memory == nullptr) {
        DWORD error = GetLastError();
        std::wcout << L"힙 할당 실패: " << it->second.name 
                  << L", 크기: " << size << L", 에러: " << error << std::endl;
        return nullptr;
    }
    
    it->second.totalAllocated += size;
    it->second.allocationCount++;
    m_allocationMap[memory] = type;
    
    return memory;
}
```

특정 힙에서 메모리를 할당한다. 해당 유형의 힙이 존재하는지 확인하고, `zeroMemory` 파라미터에 따라 할당된 메모리를 0으로 초기화할지 결정한다. `HeapAlloc`으로 메모리를 할당하고 실패 시 오류를 출력한다. 할당 성공 시 통계 정보를 업데이트하고 메모리 포인터를 할당맵에 등록한다.

#### 메모리 할당 관련 함수. 메모리 재할당

```cpp
LPVOID ReallocateFromHeap(LPVOID memory, SIZE_T newSize) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto allocIt = m_allocationMap.find(memory);
    if (allocIt == m_allocationMap.end()) {
        std::wcout << L"재할당할 메모리를 찾을 수 없음: " << memory << std::endl;
        return nullptr;
    }
    
    HeapType type = allocIt->second;
    auto heapIt = m_heaps.find(type);
    if (heapIt == m_heaps.end()) {
        return nullptr;
    }
    
    LPVOID newMemory = HeapReAlloc(heapIt->second.hHeap, HEAP_ZERO_MEMORY, 
                                   memory, newSize);
    
    if (newMemory == nullptr) {
        DWORD error = GetLastError();
        std::wcout << L"힙 재할당 실패: " << heapIt->second.name 
                  << L", 새 크기: " << newSize << L", 에러: " << error << std::endl;
        return nullptr;
    }
    
    if (newMemory != memory) {
        m_allocationMap.erase(allocIt);
        m_allocationMap[newMemory] = type;
    }
    
    return newMemory;
}
```

이미 할당된 메모리의 크기를 변경한다. 메모리 포인터가 할당맵에 존재하는지 확인하고 해당 힙을 찾는다. `HeapReAlloc`으로 재할당을 시도하며, 주소가 변경된 경우 할당맵을 갱신한다.

#### 메모리 할당 관련 함수. 메모리 해제

```cpp
BOOL FreeFromHeap(LPVOID memory) {
    if (memory == nullptr) return TRUE;
    
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto allocIt = m_allocationMap.find(memory);
    if (allocIt == m_allocationMap.end()) {
        std::wcout << L"해제할 메모리를 찾을 수 없음: " << memory << std::endl;
        return FALSE;
    }
    
    HeapType type = allocIt->second;
    auto heapIt = m_heaps.find(type);
    if (heapIt == m_heaps.end()) {
        return FALSE;
    }
    
    if (!HeapFree(heapIt->second.hHeap, 0, memory)) {
        DWORD error = GetLastError();
        std::wcout << L"힙 해제 실패: " << heapIt->second.name 
                  << L", 에러: " << error << std::endl;
        return FALSE;
    }
    
    heapIt->second.allocationCount--;
    m_allocationMap.erase(allocIt);
    
    return TRUE;
}
```

메모리를 해제한다. 먼저 null 포인터 확인 후 할당맵에서 메모리를 검색하고 해당 힙을 찾는다. `HeapFree`로 메모리를 해제하고 통계를 업데이트한 후 할당맵에서 제거한다.


#### 힙 유지보수 함수. 힙 압축

```cpp
BOOL CompactHeap(HeapType type) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_heaps.find(type);
    if (it == m_heaps.end()) {
        return FALSE;
    }
    
    SIZE_T compactedSize = HeapCompact(it->second.hHeap, 0);
    
    std::wcout << L"힙 압축 완료: " << it->second.name 
              << L", 압축된 크기: " << compactedSize << L" bytes" << std::endl;
    
    return compactedSize != 0;
}
```

힙의 조각 모음을 수행한다. `HeapCompact`는 할당되지 않은 공간을 병합하여 메모리 단편화를 줄인다.

#### 힙 유지보수 함수. 힙 검증

```cpp
BOOL ValidateHeap(HeapType type) {
    #ifdef _DEBUG
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_heaps.find(type);
        if (it == m_heaps.end()) {
            return FALSE;
        }
        
        BOOL isValid = HeapValidate(it->second.hHeap, 0, nullptr);
        
        if (!isValid) {
            std::wcout << L"힙 검증 실패: " << it->second.name << std::endl;
        }
        
        return isValid;
    #else
        return TRUE;
    #endif
}
```

디버그 빌드에서만 힙의 무결성을 검증한다. 메모리 손상이나 오류를 감지할 수 있다.

#### 힙 유지보수 함수. 힙 통계 출력

```cpp
void PrintHeapStats() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    std::wcout << L"\n=== 힙 사용량 통계 ===" << std::endl;
    
    for (const auto& pair : m_heaps) {
        const HeapInfo& info = pair.second;
        
        PROCESS_HEAP_ENTRY entry;
        entry.lpData = nullptr;
        
        SIZE_T totalSize = 0;
        SIZE_T usedSize = 0;
        DWORD blockCount = 0;
        
        while (HeapWalk(info.hHeap, &entry)) {
            if (entry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
                usedSize += entry.cbData;
            }
            totalSize += entry.cbData;
            blockCount++;
        }
        
        std::wcout << L"힙: " << info.name << std::endl;
        std::wcout << L"  총 크기: " << totalSize / 1024 << L"KB" << std::endl;
        std::wcout << L"  사용 중: " << usedSize / 1024 << L"KB" << std::endl;
        std::wcout << L"  할당 수: " << info.allocationCount << std::endl;
        std::wcout << L"  블록 수: " << blockCount << std::endl;
    }
}
```

모든 힙의 상세 통계를 출력한다. `HeapWalk`를 사용하여 각 블록을 순회하며 사용 중인 메모리와 전체 메모리 크기를 계산한다.


#### GameHeapPtr - 스마트 포인터 구현. 기본 구조와 생성자

```cpp
template<typename T>
class GameHeapPtr {
private:
    T* m_ptr;
    GameHeapManager* m_heapManager;
    GameHeapManager::HeapType m_heapType;
    
public:
    GameHeapPtr(GameHeapManager* heapMgr, GameHeapManager::HeapType type)
        : m_ptr(nullptr), m_heapManager(heapMgr), m_heapType(type) {}
    
    ~GameHeapPtr() {
        Reset();
    }
    
    GameHeapPtr(const GameHeapPtr&) = delete;
    GameHeapPtr& operator=(const GameHeapPtr&) = delete;
    
    GameHeapPtr(GameHeapPtr&& other) noexcept
        : m_ptr(other.m_ptr), m_heapManager(other.m_heapManager), 
          m_heapType(other.m_heapType) {
        other.m_ptr = nullptr;
    }
    
    GameHeapPtr& operator=(GameHeapPtr&& other) noexcept {
        if (this != &other) {
            Reset();
            m_ptr = other.m_ptr;
            m_heapManager = other.m_heapManager;
            m_heapType = other.m_heapType;
            other.m_ptr = nullptr;
        }
        return *this;
    }
};
```

게임 객체용 스마트 포인터를 구현한다. 복사는 금지하고 이동만 허용하여 메모리 소유권을 명확히 한다.

#### GameHeapPtr - 스마트 포인터 구현. 객체 생성 및 해제

```cpp
template<typename... Args>
BOOL Create(Args&&... args) {
    Reset();
    
    m_ptr = static_cast<T*>(m_heapManager->AllocateFromHeap(m_heapType, sizeof(T)));
    if (m_ptr == nullptr) {
        return FALSE;
    }
    
    new(m_ptr) T(std::forward<Args>(args)...);
    return TRUE;
}

void Reset() {
    if (m_ptr) {
        m_ptr->~T();
        m_heapManager->FreeFromHeap(m_ptr);
        m_ptr = nullptr;
    }
}
```

`Create` 함수는 힙에서 메모리를 할당한 후 placement new로 객체를 생성한다. 가변 인자 템플릿을 사용하여 생성자 파라미터를 전달한다. `Reset`은 명시적으로 소멸자를 호출한 후 메모리를 해제한다.

#### GameHeapPtr - 스마트 포인터 구현. 접근 연산자

```cpp
T* operator->() { return m_ptr; }
const T* operator->() const { return m_ptr; }
T& operator*() { return *m_ptr; }
const T& operator*() const { return *m_ptr; }

T* Get() { return m_ptr; }
const T* Get() const { return m_ptr; }

BOOL IsValid() const { return m_ptr != nullptr; }
operator bool() const { return IsValid(); }
```

포인터처럼 사용할 수 있도록 연산자를 오버로드한다.


#### 사용 예시. GamePlayer 구조체

```cpp
struct GamePlayer {
    DWORD playerId;
    wchar_t playerName[32];
    FLOAT posX, posY, posZ;
    DWORD level;
    
    GamePlayer(DWORD id, const wchar_t* name) : playerId(id), level(1) {
        wcscpy_s(playerName, name);
        posX = posY = posZ = 0.0f;
    }
    
    ~GamePlayer() {
        std::wcout << L"플레이어 소멸: " << playerName << std::endl;
    }
};
```

게임 플레이어 객체를 정의한다. 생성자와 소멸자를 통해 초기화와 정리가 자동으로 이루어진다.

#### 사용 예시. 데모 함수

```cpp
void DemonstrateHeapUsage() {
    std::wcout << L"=== 게임 서버 힙 관리 데모 ===" << std::endl;
    
    GameHeapManager heapManager;
    
    heapManager.CreateGameHeap(GameHeapManager::HeapType::GAME_OBJECTS, 
                              L"GameObjects", 1024 * 1024, 10 * 1024 * 1024);
    
    heapManager.CreateGameHeap(GameHeapManager::HeapType::NETWORK_BUFFERS, 
                              L"NetworkBuffers", 512 * 1024, 5 * 1024 * 1024, 
                              HEAP_NO_SERIALIZE);
    
    heapManager.CreateGameHeap(GameHeapManager::HeapType::TEMPORARY_DATA, 
                              L"TempData", 256 * 1024, 2 * 1024 * 1024);
    
    std::vector<GameHeapPtr<GamePlayer>> players;
    
    for (int i = 0; i < 10; ++i) {
        GameHeapPtr<GamePlayer> player(&heapManager, GameHeapManager::HeapType::GAME_OBJECTS);
        
        wchar_t name[32];
        swprintf_s(name, L"Player%d", i + 1);
        
        if (player.Create(i + 1, name)) {
            player->level = (i % 5) + 1;
            player->posX = static_cast<float>(i * 10);
            players.push_back(std::move(player));
        }
    }
    
    std::vector<LPVOID> networkBuffers;
    for (int i = 0; i < 5; ++i) {
        LPVOID buffer = heapManager.AllocateFromHeap(
            GameHeapManager::HeapType::NETWORK_BUFFERS, 1024);
        if (buffer) {
            networkBuffers.push_back(buffer);
        }
    }
    
    heapManager.PrintHeapStats();
    
    heapManager.ValidateHeap(GameHeapManager::HeapType::GAME_OBJECTS);
    heapManager.ValidateHeap(GameHeapManager::HeapType::NETWORK_BUFFERS);
    
    for (LPVOID buffer : networkBuffers) {
        heapManager.FreeFromHeap(buffer);
    }
    
    heapManager.CompactHeap(GameHeapManager::HeapType::NETWORK_BUFFERS);
    
    std::wcout << L"데모 완료 - 자동으로 정리됩니다..." << std::endl;
}
```

실제 게임 서버 환경을 시뮬레이션한다. 용도별 힙을 생성하고, 스마트 포인터로 플레이어 객체를 관리하며, 네트워크 버퍼를 할당한 후 통계를 확인하고 정리한다. 모든 객체가 스코프를 벗어나면서 자동으로 메모리가 해제된다.

#### 핵심 설계 원칙
이 구현의 주요 장점은 세 가지이다. 첫째, 용도별로 독립적인 힙을 관리하여 메모리 단편화를 줄이고 캐시 지역성을 향상한다. 둘째, 스마트 포인터를 통해 메모리 누수를 자동으로 방지한다. 셋째, 뮤텍스 기반 동기화로 멀티스레드 게임 서버에서 안전한 메모리 관리를 보장한다.    
  
</br>  


## 3.3 메모리 매핑 파일 (CreateFileMapping, MapViewOfFile)

### 메모리 매핑 파일의 개념
메모리 매핑 파일은 파일을 메모리 주소 공간에 직접 매핑하여 파일 I/O를 메모리 접근처럼 처리할 수 있게 해주는 기술이다. 게임 서버에서는 다음과 같은 용도로 활용됩니다:

- **대용량 게임 데이터 로딩**: 지형, 텍스처, 사운드 등
- **프로세스 간 데이터 공유**: 여러 서버 프로세스 간 공유 메모리
- **로그 파일 관리**: 고성능 로그 기록
- **캐시 시스템**: 디스크 기반 캐시

```
    메모리 매핑 파일 구조:
    ═══════════════════════════════════════════════════════════
    
    Physical File on Disk        Virtual Memory Space
    ┌─────────────────────┐     ┌─────────────────────┐
    │ [Header]            │───▶│ 0x10000000          │
    │ [Game Data Block 1] │     │ [Header]            │
    │ [Game Data Block 2] │     │ [Game Data Block 1] │
    │ [Game Data Block 3] │     │ [Game Data Block 2] │
    │ [...]               │     │ [Game Data Block 3] │
    │ [EOF]               │     │ [...]               │
    └─────────────────────┘     └─────────────────────┘
                                         │
                                         ▼
                                 Application Access
                                 (일반 메모리처럼 사용)
```

### 게임 서버용 메모리 매핑 파일 관리자

```cpp
#include <windows.h>
#include <iostream>
#include <string>
#include <unordered_map>
#include <mutex>
#include <vector>

class GameMemoryMappedFile {
private:
    struct MappingInfo {
        HANDLE hFile;
        HANDLE hMapping;
        LPVOID pViewOfFile;
        SIZE_T fileSize;
        std::wstring fileName;
        DWORD accessMode;
        BOOL isSharedMemory;
    };
    
    std::mutex m_mutex;
    std::unordered_map<std::wstring, MappingInfo> m_mappings;
    
public:
    GameMemoryMappedFile() = default;
    
    ~GameMemoryMappedFile() {
        UnmapAllFiles();
    }
    
    // 파일을 메모리에 매핑
    LPVOID MapFile(const std::wstring& fileName, DWORD accessMode = GENERIC_READ,
                   SIZE_T maxSize = 0, const std::wstring& mappingName = L"") {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_mappings.find(fileName) != m_mappings.end()) {
            std::wcout << L"파일이 이미 매핑됨: " << fileName << std::endl;
            return m_mappings[fileName].pViewOfFile;
        }
        
        // 파일 열기
        DWORD fileAccess = accessMode;
        DWORD shareMode = (accessMode == GENERIC_READ) ? FILE_SHARE_READ : 0;
        DWORD creation = (accessMode & GENERIC_WRITE) ? OPEN_ALWAYS : OPEN_EXISTING;
        
        HANDLE hFile = CreateFileW(
            fileName.c_str(),
            fileAccess,
            shareMode,
            nullptr,
            creation,
            FILE_ATTRIBUTE_NORMAL,
            nullptr
        );
        
        if (hFile == INVALID_HANDLE_VALUE) {
            DWORD error = GetLastError();
            std::wcout << L"파일 열기 실패: " << fileName << L", 에러: " << error << std::endl;
            return nullptr;
        }
        
        // 파일 크기 확인
        LARGE_INTEGER fileSize;
        if (!GetFileSizeEx(hFile, &fileSize)) {
            DWORD error = GetLastError();
            std::wcout << L"파일 크기 확인 실패: " << error << std::endl;
            CloseHandle(hFile);
            return nullptr;
        }
        
        SIZE_T mapSize = maxSize > 0 ? maxSize : fileSize.QuadPart;
        if (mapSize == 0) {
            std::wcout << L"파일 크기가 0이거나 maxSize가 설정되지 않음" << std::endl;
            CloseHandle(hFile);
            return nullptr;
        }
        
        // 매핑 보호 속성 설정
        DWORD protect = PAGE_READONLY;
        DWORD mapAccess = FILE_MAP_READ;
        
        if (accessMode & GENERIC_WRITE) {
            protect = PAGE_READWRITE;
            mapAccess = FILE_MAP_WRITE;
        }
        
        // 파일 매핑 객체 생성
        HANDLE hMapping = CreateFileMappingW(
            hFile,
            nullptr,
            protect,
            static_cast<DWORD>(mapSize >> 32),  // 상위 32비트
            static_cast<DWORD>(mapSize & 0xFFFFFFFF),  // 하위 32비트
            mappingName.empty() ? nullptr : mappingName.c_str()
        );
        
        if (hMapping == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"파일 매핑 생성 실패: " << error << std::endl;
            CloseHandle(hFile);
            return nullptr;
        }
        
        // 뷰 매핑
        LPVOID pView = MapViewOfFile(
            hMapping,
            mapAccess,
            0,  // 오프셋 상위 32비트
            0,  // 오프셋 하위 32비트
            mapSize
        );
        
        if (pView == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"뷰 매핑 실패: " << error << std::endl;
            CloseHandle(hMapping);
            CloseHandle(hFile);
            return nullptr;
        }
        
        // 매핑 정보 저장
        MappingInfo info = {
            hFile,
            hMapping,
            pView,
            mapSize,
            fileName,
            accessMode,
            !mappingName.empty()
        };
        
        m_mappings[fileName] = info;
        
        std::wcout << L"파일 매핑 완료: " << fileName 
                  << L", 크기: " << mapSize / 1024 << L"KB"
                  << L", 주소: " << pView << std::endl;
        
        return pView;
    }
    
    // 공유 메모리 생성 (파일 없이)
    LPVOID CreateSharedMemory(const std::wstring& name, SIZE_T size, 
                             BOOL createNew = TRUE) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        DWORD creation = createNew ? CREATE_ALWAYS : OPEN_EXISTING;
        
        // 페이지 파일 기반 매핑 생성
        HANDLE hMapping = CreateFileMappingW(
            INVALID_HANDLE_VALUE,  // 페이지 파일 사용
            nullptr,
            PAGE_READWRITE,
            static_cast<DWORD>(size >> 32),
            static_cast<DWORD>(size & 0xFFFFFFFF),
            name.c_str()
        );
        
        if (hMapping == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"공유 메모리 생성 실패: " << name << L", 에러: " << error << std::endl;
            return nullptr;
        }
        
        // 이미 존재하는 매핑인지 확인
        BOOL alreadyExists = (GetLastError() == ERROR_ALREADY_EXISTS);
        
        LPVOID pView = MapViewOfFile(
            hMapping,
            FILE_MAP_ALL_ACCESS,
            0, 0, size
        );
        
        if (pView == nullptr) {
            DWORD error = GetLastError();
            std::wcout << L"공유 메모리 뷰 매핑 실패: " << error << std::endl;
            CloseHandle(hMapping);
            return nullptr;
        }
        
        // 매핑 정보 저장
        MappingInfo info = {
            INVALID_HANDLE_VALUE,  // 파일 핸들 없음
            hMapping,
            pView,
            size,
            name,
            GENERIC_READ | GENERIC_WRITE,
            TRUE
        };
        
        m_mappings[name] = info;
        
        std::wcout << (alreadyExists ? L"기존 공유 메모리 열기: " : L"새 공유 메모리 생성: ")
                  << name << L", 크기: " << size / 1024 << L"KB" << std::endl;
        
        // 새로 생성한 경우 0으로 초기화
        if (!alreadyExists) {
            ZeroMemory(pView, size);
        }
        
        return pView;
    }
    
    // 파일 매핑 해제
    BOOL UnmapFile(const std::wstring& fileName) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_mappings.find(fileName);
        if (it == m_mappings.end()) {
            std::wcout << L"매핑되지 않은 파일: " << fileName << std::endl;
            return FALSE;
        }
        
        const MappingInfo& info = it->second;
        
        // 뷰 해제
        if (info.pViewOfFile) {
            if (!UnmapViewOfFile(info.pViewOfFile)) {
                DWORD error = GetLastError();
                std::wcout << L"뷰 해제 실패: " << error << std::endl;
            }
        }
        
        // 매핑 객체 해제
        if (info.hMapping) {
            CloseHandle(info.hMapping);
        }
        
        // 파일 핸들 해제
        if (info.hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(info.hFile);
        }
        
        m_mappings.erase(it);
        
        std::wcout << L"파일 매핑 해제: " << fileName << std::endl;
        return TRUE;
    }
    
    // 매핑된 메모리 플러시 (변경사항을 디스크에 기록)
    BOOL FlushMapping(const std::wstring& fileName, SIZE_T offset = 0, SIZE_T size = 0) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_mappings.find(fileName);
        if (it == m_mappings.end()) {
            return FALSE;
        }
        
        const MappingInfo& info = it->second;
        SIZE_T flushSize = (size == 0) ? info.fileSize : size;
        
        LPVOID flushAddr = static_cast<char*>(info.pViewOfFile) + offset;
        
        if (!FlushViewOfFile(flushAddr, flushSize)) {
            DWORD error = GetLastError();
            std::wcout << L"메모리 플러시 실패: " << error << std::endl;
            return FALSE;
        }
        
        return TRUE;
    }
    
    // 매핑된 파일 포인터 반환
    LPVOID GetMappedPointer(const std::wstring& fileName) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_mappings.find(fileName);
        return (it != m_mappings.end()) ? it->second.pViewOfFile : nullptr;
    }
    
    // 매핑된 파일 크기 반환
    SIZE_T GetMappedSize(const std::wstring& fileName) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        auto it = m_mappings.find(fileName);
        return (it != m_mappings.end()) ? it->second.fileSize : 0;
    }
    
    // 모든 매핑 해제
    void UnmapAllFiles() {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        for (auto& pair : m_mappings) {
            const MappingInfo& info = pair.second;
            
            if (info.pViewOfFile) {
                UnmapViewOfFile(info.pViewOfFile);
            }
            
            if (info.hMapping) {
                CloseHandle(info.hMapping);
            }
            
            if (info.hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(info.hFile);
            }
        }
        
        m_mappings.clear();
        std::wcout << L"모든 파일 매핑 해제 완료" << std::endl;
    }
    
    // 매핑 상태 출력
    void PrintMappingStats() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        std::wcout << L"\n=== 메모리 매핑 파일 상태 ===" << std::endl;
        
        SIZE_T totalSize = 0;
        for (const auto& pair : m_mappings) {
            const MappingInfo& info = pair.second;
            
            std::wcout << L"파일: " << pair.first << std::endl;
            std::wcout << L"  크기: " << info.fileSize / 1024 << L"KB" << std::endl;
            std::wcout << L"  주소: " << info.pViewOfFile << std::endl;
            std::wcout << L"  접근 모드: " << 
                (info.accessMode & GENERIC_WRITE ? L"읽기/쓰기" : L"읽기 전용") << std::endl;
            std::wcout << L"  공유 메모리: " << (info.isSharedMemory ? L"예" : L"아니오") << std::endl;
            std::wcout << std::endl;
            
            totalSize += info.fileSize;
        }
        
        std::wcout << L"총 매핑된 크기: " << totalSize / 1024 << L"KB" << std::endl;
        std::wcout << L"매핑된 파일 수: " << m_mappings.size() << std::endl;
    }
};

// 게임 데이터 구조체 예시
#pragma pack(push, 1)  // 패킹 설정으로 정확한 파일 형식 보장
struct GameMapHeader {
    DWORD signature;        // 'GMAP'
    DWORD version;
    DWORD width;
    DWORD height;
    DWORD tileCount;
    DWORD objectCount;
    DWORD reserved[10];
};

struct GameMapTile {
    WORD tileId;
    BYTE elevation;
    BYTE flags;
};

struct GameMapObject {
    DWORD objectId;
    FLOAT posX, posY, posZ;
    FLOAT rotX, rotY, rotZ;
    DWORD properties;
};
#pragma pack(pop)

// 게임 맵 로더 클래스
class GameMapLoader {
private:
    GameMemoryMappedFile m_mappedFile;
    const GameMapHeader* m_header;
    const GameMapTile* m_tiles;
    const GameMapObject* m_objects;
    
public:
    BOOL LoadMap(const std::wstring& mapFileName) {
        // 맵 파일을 메모리에 매핑
        LPVOID pMapData = m_mappedFile.MapFile(mapFileName, GENERIC_READ);
        if (!pMapData) {
            std::wcout << L"맵 파일 로딩 실패: " << mapFileName << std::endl;
            return FALSE;
        }
        
        // 헤더 검증
        m_header = static_cast<const GameMapHeader*>(pMapData);
        if (m_header->signature != 'PAMG') {  // 'GMAP' 역순
            std::wcout << L"잘못된 맵 파일 시그니처" << std::endl;
            return FALSE;
        }
        
        if (m_header->version != 1) {
            std::wcout << L"지원하지 않는 맵 파일 버전: " << m_header->version << std::endl;
            return FALSE;
        }
        
        // 타일 데이터 포인터 설정
        m_tiles = reinterpret_cast<const GameMapTile*>(
            static_cast<const char*>(pMapData) + sizeof(GameMapHeader));
        
        // 오브젝트 데이터 포인터 설정
        m_objects = reinterpret_cast<const GameMapObject*>(
            static_cast<const char*>(pMapData) + sizeof(GameMapHeader) +
            sizeof(GameMapTile) * m_header->tileCount);
        
        std::wcout << L"맵 로딩 완료: " << mapFileName << std::endl;
        std::wcout << L"  크기: " << m_header->width << L"x" << m_header->height << std::endl;
        std::wcout << L"  타일 수: " << m_header->tileCount << std::endl;
        std::wcout << L"  오브젝트 수: " << m_header->objectCount << std::endl;
        
        return TRUE;
    }
    
    // 타일 정보 가져오기
    const GameMapTile* GetTile(DWORD x, DWORD y) const {
        if (!m_header || x >= m_header->width || y >= m_header->height) {
            return nullptr;
        }
        
        DWORD index = y * m_header->width + x;
        return &m_tiles[index];
    }
    
    // 오브젝트 정보 가져오기
    const GameMapObject* GetObject(DWORD index) const {
        if (!m_header || index >= m_header->objectCount) {
            return nullptr;
        }
        
        return &m_objects[index];
    }
    
    // 맵 정보 반환
    DWORD GetWidth() const { return m_header ? m_header->width : 0; }
    DWORD GetHeight() const { return m_header ? m_header->height : 0; }
    DWORD GetTileCount() const { return m_header ? m_header->tileCount : 0; }
    DWORD GetObjectCount() const { return m_header ? m_header->objectCount : 0; }
};

// 프로세스 간 통신용 공유 메모리
struct SharedGameState {
    DWORD totalPlayers;
    DWORD totalNPCs;
    DWORD serverStatus;  // 0: 정지, 1: 실행 중, 2: 셧다운 중
    LARGE_INTEGER lastUpdateTime;
    wchar_t statusMessage[256];
};

class GameServerSharedData {
private:
    GameMemoryMappedFile m_mappedFile;
    SharedGameState* m_sharedState;
    
public:
    BOOL Initialize(const std::wstring& sharedName, BOOL isMainServer = TRUE) {
        // 공유 메모리 생성 또는 열기
        SIZE_T sharedSize = sizeof(SharedGameState);
        m_sharedState = static_cast<SharedGameState*>(
            m_mappedFile.CreateSharedMemory(sharedName, sharedSize, isMainServer));
        
        if (!m_sharedState) {
            std::wcout << L"공유 메모리 초기화 실패" << std::endl;
            return FALSE;
        }
        
        if (isMainServer) {
            // 메인 서버인 경우 초기화
            m_sharedState->totalPlayers = 0;
            m_sharedState->totalNPCs = 0;
            m_sharedState->serverStatus = 1;  // 실행 중
            QueryPerformanceCounter(&m_sharedState->lastUpdateTime);
            wcscpy_s(m_sharedState->statusMessage, L"서버 시작됨");
        }
        
        std::wcout << L"공유 데이터 초기화 완료: " << sharedName << std::endl;
        return TRUE;
    }
    
    void UpdatePlayerCount(DWORD count) {
        if (m_sharedState) {
            InterlockedExchange(&m_sharedState->totalPlayers, count);
            QueryPerformanceCounter(&m_sharedState->lastUpdateTime);
        }
    }
    
    void UpdateStatusMessage(const std::wstring& message) {
        if (m_sharedState) {
            wcscpy_s(m_sharedState->statusMessage, message.c_str());
            QueryPerformanceCounter(&m_sharedState->lastUpdateTime);
        }
    }
    
    DWORD GetPlayerCount() const {
        return m_sharedState ? m_sharedState->totalPlayers : 0;
    }
    
    std::wstring GetStatusMessage() const {
        return m_sharedState ? std::wstring(m_sharedState->statusMessage) : L"";
    }
    
    DWORD GetServerStatus() const {
        return m_sharedState ? m_sharedState->serverStatus : 0;
    }
};
```

#### 게임 서버용 메모리 매핑 파일 관리자 개요
이 코드는 Windows API를 활용하여 파일을 메모리에 매핑하고 프로세스 간 공유 메모리를 관리하는 게임 서버용 유틸리티 클래스들을 구현한다. 메모리 매핑 파일(Memory-Mapped File)은 파일의 내용을 프로세스의 가상 메모리 공간에 직접 매핑하여 파일 I/O 성능을 극대화하는 기법이다.


#### 핵심 클래스 구조
코드는 크게 세 가지 주요 클래스로 구성된다.

**GameMemoryMappedFile**: 메모리 매핑 파일의 생성, 관리, 해제를 담당하는 핵심 클래스다.

**GameMapLoader**: 게임 맵 파일을 메모리에 로드하고 타일 및 오브젝트 데이터에 접근하는 클래스다.

**GameServerSharedData**: 프로세스 간 통신을 위한 공유 메모리를 관리하는 클래스다.

#### GameMemoryMappedFile 클래스 - 데이터 구조

```cpp
struct MappingInfo {
    HANDLE hFile;
    HANDLE hMapping;
    LPVOID pViewOfFile;
    SIZE_T fileSize;
    std::wstring fileName;
    DWORD accessMode;
    BOOL isSharedMemory;
};

std::mutex m_mutex;
std::unordered_map<std::wstring, MappingInfo> m_mappings;
```

**MappingInfo 구조체**: 각 매핑된 파일의 정보를 저장한다. 파일 핸들, 매핑 객체 핸들, 매핑된 메모리 주소, 파일 크기, 파일명, 접근 모드, 공유 메모리 여부를 포함한다.

**m_mutex**: 멀티스레드 환경에서 안전한 접근을 보장하기 위한 뮤텍스다.

**m_mappings**: 파일명을 키로 하여 매핑 정보를 저장하는 해시맵이다.

#### GameMemoryMappedFile 클래스 - 파일 매핑 함수

```cpp
LPVOID MapFile(const std::wstring& fileName, DWORD accessMode = GENERIC_READ,
               SIZE_T maxSize = 0, const std::wstring& mappingName = L"") {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // 이미 매핑된 파일인지 확인
    if (m_mappings.find(fileName) != m_mappings.end()) {
        return m_mappings[fileName].pViewOfFile;
    }
    
    // 파일 열기
    HANDLE hFile = CreateFileW(fileName.c_str(), fileAccess, shareMode,
                               nullptr, creation, FILE_ATTRIBUTE_NORMAL, nullptr);
    
    // 파일 크기 확인
    LARGE_INTEGER fileSize;
    GetFileSizeEx(hFile, &fileSize);
    SIZE_T mapSize = maxSize > 0 ? maxSize : fileSize.QuadPart;
    
    // 매핑 객체 생성
    HANDLE hMapping = CreateFileMappingW(hFile, nullptr, protect,
                                         static_cast<DWORD>(mapSize >> 32),
                                         static_cast<DWORD>(mapSize & 0xFFFFFFFF),
                                         mappingName.empty() ? nullptr : mappingName.c_str());
    
    // 뷰 매핑
    LPVOID pView = MapViewOfFile(hMapping, mapAccess, 0, 0, mapSize);
    
    // 매핑 정보 저장
    m_mappings[fileName] = { hFile, hMapping, pView, mapSize, fileName, accessMode, !mappingName.empty() };
    
    return pView;
}
```

이 함수는 파일을 메모리에 매핑하는 핵심 로직을 구현한다. CreateFileW로 파일을 열고, CreateFileMappingW로 매핑 객체를 생성하며, MapViewOfFile로 실제 메모리 뷰를 생성한다. 매핑된 메모리 주소를 반환하여 직접 메모리 접근이 가능하게 한다.

#### GameMemoryMappedFile 클래스 - 공유 메모리 생성

```cpp
LPVOID CreateSharedMemory(const std::wstring& name, SIZE_T size, BOOL createNew = TRUE) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // 페이지 파일 기반 매핑 생성
    HANDLE hMapping = CreateFileMappingW(
        INVALID_HANDLE_VALUE,  // 페이지 파일 사용
        nullptr,
        PAGE_READWRITE,
        static_cast<DWORD>(size >> 32),
        static_cast<DWORD>(size & 0xFFFFFFFF),
        name.c_str()
    );
    
    BOOL alreadyExists = (GetLastError() == ERROR_ALREADY_EXISTS);
    
    LPVOID pView = MapViewOfFile(hMapping, FILE_MAP_ALL_ACCESS, 0, 0, size);
    
    // 새로 생성한 경우 0으로 초기화
    if (!alreadyExists) {
        ZeroMemory(pView, size);
    }
    
    return pView;
}
```

이 함수는 파일 없이 페이지 파일 기반의 공유 메모리를 생성한다. INVALID_HANDLE_VALUE를 전달하여 실제 파일이 아닌 시스템 페이지 파일을 사용한다. 이름 있는 매핑 객체를 생성하여 다른 프로세스에서도 같은 이름으로 접근할 수 있게 한다.

#### GameMemoryMappedFile 클래스 - 메모리 플러시 및 해제

```cpp
BOOL FlushMapping(const std::wstring& fileName, SIZE_T offset = 0, SIZE_T size = 0) {
    auto it = m_mappings.find(fileName);
    if (it == m_mappings.end()) return FALSE;
    
    const MappingInfo& info = it->second;
    SIZE_T flushSize = (size == 0) ? info.fileSize : size;
    LPVOID flushAddr = static_cast<char*>(info.pViewOfFile) + offset;
    
    return FlushViewOfFile(flushAddr, flushSize);
}

BOOL UnmapFile(const std::wstring& fileName) {
    auto it = m_mappings.find(fileName);
    if (it == m_mappings.end()) return FALSE;
    
    const MappingInfo& info = it->second;
    
    if (info.pViewOfFile) UnmapViewOfFile(info.pViewOfFile);
    if (info.hMapping) CloseHandle(info.hMapping);
    if (info.hFile != INVALID_HANDLE_VALUE) CloseHandle(info.hFile);
    
    m_mappings.erase(it);
    return TRUE;
}
```

**FlushMapping**: 메모리에 기록된 변경사항을 디스크에 강제로 기록한다. FlushViewOfFile API를 사용하여 지정된 영역의 데이터를 동기화한다.

**UnmapFile**: 매핑을 해제하고 관련된 모든 핸들을 닫는다. 뷰 해제, 매핑 객체 해제, 파일 핸들 해제 순서로 진행된다.

#### 게임 데이터 구조체

```cpp
#pragma pack(push, 1)
struct GameMapHeader {
    DWORD signature;        // 'GMAP'
    DWORD version;
    DWORD width;
    DWORD height;
    DWORD tileCount;
    DWORD objectCount;
    DWORD reserved[10];
};

struct GameMapTile {
    WORD tileId;
    BYTE elevation;
    BYTE flags;
};

struct GameMapObject {
    DWORD objectId;
    FLOAT posX, posY, posZ;
    FLOAT rotX, rotY, rotZ;
    DWORD properties;
};
#pragma pack(pop)
```

게임 맵 파일의 구조를 정의한다. `#pragma pack(push, 1)`을 사용하여 구조체 패딩을 제거하고 정확한 바이트 단위로 데이터를 정렬한다. 이는 파일 형식과 메모리 구조를 일치시켜 직접적인 캐스팅을 가능하게 한다.

**GameMapHeader**: 맵 파일의 시그니처, 버전, 크기 정보를 담는다.

**GameMapTile**: 각 타일의 ID, 높이, 플래그 정보를 저장한다.

**GameMapObject**: 맵에 배치된 오브젝트의 위치, 회전, 속성을 저장한다.

#### GameMapLoader 클래스 - 맵 로딩

```cpp
BOOL LoadMap(const std::wstring& mapFileName) {
    LPVOID pMapData = m_mappedFile.MapFile(mapFileName, GENERIC_READ);
    if (!pMapData) return FALSE;
    
    // 헤더 검증
    m_header = static_cast<const GameMapHeader*>(pMapData);
    if (m_header->signature != 'PAMG') return FALSE;  // 'GMAP' 역순
    if (m_header->version != 1) return FALSE;
    
    // 타일 데이터 포인터 설정
    m_tiles = reinterpret_cast<const GameMapTile*>(
        static_cast<const char*>(pMapData) + sizeof(GameMapHeader));
    
    // 오브젝트 데이터 포인터 설정
    m_objects = reinterpret_cast<const GameMapObject*>(
        static_cast<const char*>(pMapData) + sizeof(GameMapHeader) +
        sizeof(GameMapTile) * m_header->tileCount);
    
    return TRUE;
}
```

맵 파일을 메모리에 매핑하고 각 데이터 섹션에 대한 포인터를 설정한다. 파일 시그니처와 버전을 검증하여 올바른 파일인지 확인한다. 메모리 매핑을 사용하기 때문에 전체 파일을 읽지 않고도 필요한 부분에 즉시 접근할 수 있다.

#### GameMapLoader 클래스 - 데이터 접근

```cpp
const GameMapTile* GetTile(DWORD x, DWORD y) const {
    if (!m_header || x >= m_header->width || y >= m_header->height) {
        return nullptr;
    }
    
    DWORD index = y * m_header->width + x;
    return &m_tiles[index];
}

const GameMapObject* GetObject(DWORD index) const {
    if (!m_header || index >= m_header->objectCount) {
        return nullptr;
    }
    
    return &m_objects[index];
}
```

2차원 좌표를 1차원 인덱스로 변환하여 타일 데이터에 접근한다. 메모리 매핑 덕분에 배열 인덱싱만으로 파일 데이터에 직접 접근할 수 있어 매우 빠른 성능을 제공한다. 경계 검사를 통해 잘못된 접근을 방지한다.

#### 공유 게임 상태 구조체

```cpp
struct SharedGameState {
    DWORD totalPlayers;
    DWORD totalNPCs;
    DWORD serverStatus;  // 0: 정지, 1: 실행 중, 2: 셧다운 중
    LARGE_INTEGER lastUpdateTime;
    wchar_t statusMessage[256];
};
```

프로세스 간 공유할 게임 서버의 상태 정보를 정의한다. 플레이어 수, NPC 수, 서버 상태, 마지막 업데이트 시간, 상태 메시지를 포함한다. 이 구조체는 공유 메모리에 저장되어 여러 프로세스가 동시에 읽고 쓸 수 있다.

#### GameServerSharedData 클래스

```cpp
BOOL Initialize(const std::wstring& sharedName, BOOL isMainServer = TRUE) {
    SIZE_T sharedSize = sizeof(SharedGameState);
    m_sharedState = static_cast<SharedGameState*>(
        m_mappedFile.CreateSharedMemory(sharedName, sharedSize, isMainServer));
    
    if (isMainServer) {
        m_sharedState->totalPlayers = 0;
        m_sharedState->totalNPCs = 0;
        m_sharedState->serverStatus = 1;
        QueryPerformanceCounter(&m_sharedState->lastUpdateTime);
        wcscpy_s(m_sharedState->statusMessage, L"서버 시작됨");
    }
    
    return TRUE;
}

void UpdatePlayerCount(DWORD count) {
    if (m_sharedState) {
        InterlockedExchange(&m_sharedState->totalPlayers, count);
        QueryPerformanceCounter(&m_sharedState->lastUpdateTime);
    }
}
```

프로세스 간 통신을 위한 공유 메모리를 초기화하고 관리한다. 메인 서버는 공유 메모리를 생성하고 초기화하며, 클라이언트 프로세스는 기존 공유 메모리를 연다. InterlockedExchange를 사용하여 스레드 안전한 업데이트를 수행한다.


#### 전체 코드의 활용 시나리오
이 코드는 게임 서버에서 다음과 같이 활용될 수 있다.

**대용량 맵 파일 로딩**: 수십 MB 크기의 맵 파일을 메모리 매핑으로 로드하여 빠른 접근 속도를 제공한다.

**프로세스 간 데이터 공유**: 메인 게임 서버와 로그 서버, 모니터링 툴 등이 공유 메모리를 통해 실시간으로 데이터를 교환한다.

**효율적인 메모리 관리**: 필요한 부분만 실제 메모리에 로드되는 페이징 메커니즘을 활용하여 메모리 사용을 최적화한다.

**멀티스레드 안전성**: 뮤텍스와 인터락 함수를 사용하여 여러 스레드에서 안전하게 데이터에 접근할 수 있다.  
 

</br>      

## 3.4 게임 서버를 위한 메모리 풀 구현

### 메모리 풀의 필요성
게임 서버에서는 객체의 생성과 소멸이 매우 빈번하게 발생한다. 매번 동적 할당을 수행하면 다음과 같은 문제가 발생할 수 있다:

- **성능 저하**: malloc/free의 오버헤드
- **메모리 단편화**: 힙 메모리의 조각화
- **예측 불가능한 지연**: 가비지 컬렉션이나 힙 관리로 인한 지연
- **메모리 누수**: 복잡한 생명주기 관리

메모리 풀은 이러한 문제를 해결하기 위해 미리 할당된 메모리 블록을 재사용하는 기법이다.

```
    메모리 풀 구조:
    ═══════════════════════════════════════════════════════════
    
    Memory Pool Layout:
    ┌─────────────────────────────────────────────────────┐
    │ Pool Header │ Block │ Block │ Block │ ... │ Block   │
    │             │   1   │   2   │   3   │     │   N     │
    └─────────────────────────────────────────────────────┘
           │
           ▼
    Free List (Stack):
    ┌─────┐    ┌─────┐    ┌─────┐
    │ Blk │───▶│ Blk │───▶│ Blk │───▶ NULL
    │  5  │    │  3  │    │  1  │
    └─────┘    └─────┘    └─────┘
      ▲
      │
    Top of Stack
```
  

### 고성능 메모리 풀. 메모리 풀 핵심 구현 (MemoryPool.h)
스레드로부터 안전한(thread-safe) 기본 메모리 풀이다.

```cpp
#pragma once

#include <windows.h>
#include <iostream>
#include <vector>
#include <mutex>
#include <atomic>
#include <type_traits> // for std::forward

// 메모리 풀 통계
struct PoolStats {
    std::atomic<SIZE_T> totalAllocations{0};
    std::atomic<SIZE_T> totalDeallocations{0};
    std::atomic<SIZE_T> currentAllocations{0};
    std::atomic<SIZE_T> peakAllocations{0};
    std::atomic<SIZE_T> poolHits{0};      // 풀에서 성공한 할당
    std::atomic<SIZE_T> poolMisses{0};    // 풀이 비어서 실패한 할당 (새 청크 할당 시도)
};

/**
 * @brief 템플릿 기반 고성능 메모리 풀 (스레드 안전)
 * @details
 * - VirtualAlloc을 사용하여 큰 메모리 '청크(Chunk)'를 할당받습니다.
 * - 각 청크를 고정된 크기의 '블록(Block)'으로 분할합니다.
 * - 사용 가능한 블록은 '자유 리스트(Free List)'라는 단일 연결 리스트로 관리합니다.
 * - 할당(Allocate) 시 자유 리스트에서 블록 하나를 떼어내고, 해제(Deallocate) 시 다시 리스트에 붙입니다.
 * - 자유 리스트가 비면 새 청크를 할당합니다.
 * - std::mutex를 사용하여 멀티스레드 환경에서 안전하게 동작합니다.
 */
template<typename T>
class GameObjectPool {
private:
    // 풀 블록 헤더 (각 블록 앞에 붙는 관리 정보)
    struct PoolBlock {
        PoolBlock* next;        // 다음 자유 블록
        #ifdef _DEBUG
            DWORD signature;    // 디버그용 시그니처
            DWORD allocId;      // 할당 ID
        #endif
    };
    
    // 풀 청크 (VirtualAlloc으로 할당받는 큰 메모리 블록)
    struct PoolChunk {
        LPVOID memory;
        SIZE_T size;
        PoolChunk* next;
    };
    
    mutable std::mutex m_mutex;     // 풀 접근 동기화를 위한 뮤텍스
    PoolBlock* m_freeHead;          // 자유 블록 리스트 헤드
    PoolChunk* m_chunks;            // 할당된 청크 리스트
    SIZE_T m_blockSize;             // 각 블록의 크기 (헤더 + 객체 + 패딩)
    SIZE_T m_blocksPerChunk;        // 청크당 블록 수
    SIZE_T m_chunkSize;             // 청크 크기
    SIZE_T m_totalBlocks;           // 총 블록 수
    SIZE_T m_freeBlocks;            // 자유 블록 수
    PoolStats m_stats;              // 통계
    
    #ifdef _DEBUG
        std::atomic<DWORD> m_allocCounter{1};
        static constexpr DWORD BLOCK_SIGNATURE = 0xDEADBEEF;
    #endif
    
    // 새 청크 할당 (내부 함수, 락이 이미 잡힌 상태에서 호출되어야 함)
    BOOL AllocateNewChunk() {
        SIZE_T chunkSize = m_chunkSize;
        
        // VirtualAlloc으로 큰 블록 할당
        LPVOID chunkMemory = VirtualAlloc(
            nullptr,
            chunkSize,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE
        );
        
        if (!chunkMemory) {
            DWORD error = GetLastError();
            std::wcout << L"청크 할당 실패: " << error << std::endl;
            return FALSE;
        }
        
        // 청크 관리 정보 추가
        PoolChunk* newChunk = static_cast<PoolChunk*>(malloc(sizeof(PoolChunk)));
        if (!newChunk) {
            VirtualFree(chunkMemory, 0, MEM_RELEASE);
            return FALSE;
        }
        
        newChunk->memory = chunkMemory;
        newChunk->size = chunkSize;
        newChunk->next = m_chunks;
        m_chunks = newChunk;
        
        // 블록들을 자유 리스트에 추가
        char* blockPtr = static_cast<char*>(chunkMemory);
        for (SIZE_T i = 0; i < m_blocksPerChunk; ++i) {
            PoolBlock* block = reinterpret_cast<PoolBlock*>(blockPtr);
            block->next = m_freeHead;
            
            #ifdef _DEBUG
                block->signature = BLOCK_SIGNATURE;
                block->allocId = 0;
            #endif
            
            m_freeHead = block;
            blockPtr += m_blockSize;
        }
        
        m_totalBlocks += m_blocksPerChunk;
        m_freeBlocks += m_blocksPerChunk;
        
        std::wcout << L"새 청크 할당: " << chunkSize / 1024 << L"KB, "
                 << L"블록 수: " << m_blocksPerChunk << std::endl;
        
        return TRUE;
    }
    
public:
    // 생성자
    explicit GameObjectPool(SIZE_T initialBlocks = 1000, SIZE_T blocksPerChunk = 1000)
        : m_freeHead(nullptr)
        , m_chunks(nullptr)
        , m_blocksPerChunk(blocksPerChunk)
        , m_totalBlocks(0)
        , m_freeBlocks(0) {
        
        // 블록 크기 계산 (헤더 + 객체 크기, 포인터 크기로 정렬)
        SIZE_T objectSize = sizeof(T);
        SIZE_T headerSize = sizeof(PoolBlock);
        // 정렬(Alignment)을 위해 (헤더 + 객체) 크기를 포인터 크기의 배수로 맞춤
        SIZE_T alignedSize = (headerSize + objectSize + sizeof(void*) - 1) & ~(sizeof(void*) - 1);
        
        m_blockSize = alignedSize;
        m_chunkSize = m_blockSize * m_blocksPerChunk;
        
        std::wcout << L"=== 메모리 풀 초기화 (" << typeid(T).name() << L") ===" << std::endl;
        std::wcout << L"객체 크기: " << objectSize << L" bytes" << std::endl;
        std::wcout << L"블록 크기: " << m_blockSize << L" bytes" << std::endl;
        std::wcout << L"청크당 블록 수: " << m_blocksPerChunk << std::endl;
        std::wcout << L"청크 크기: " << m_chunkSize / 1024 << L"KB" << std::endl;
        
        // 초기 청크 할당
        SIZE_T initialChunks = (initialBlocks + m_blocksPerChunk - 1) / m_blocksPerChunk;
        for (SIZE_T i = 0; i < initialChunks; ++i) {
            if (!AllocateNewChunk()) {
                std::wcout << L"초기 청크 할당 실패" << std::endl;
                break;
            }
        }
    }
    
    // 소멸자
    ~GameObjectPool() {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        // 모든 청크 해제
        PoolChunk* chunk = m_chunks;
        while (chunk) {
            PoolChunk* next = chunk->next;
            VirtualFree(chunk->memory, 0, MEM_RELEASE);
            free(chunk); // 청크 관리 구조체 해제
            chunk = next;
        }
        
        PrintStats();
    }
    
    /**
     * @brief 메모리 블록만 할당 (생성자 호출 안 함)
     */
    T* Allocate() {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        // 자유 블록이 없으면 새 청크 할당
        if (!m_freeHead) {
            m_stats.poolMisses.fetch_add(1);
            if (!AllocateNewChunk()) {
                return nullptr;
            }
        }
        
        // 자유 리스트에서 블록 가져오기
        PoolBlock* block = m_freeHead;
        m_freeHead = block->next;
        m_freeBlocks--;
        
        #ifdef _DEBUG
            if (block->signature != BLOCK_SIGNATURE) {
                std::wcout << L"블록 시그니처 오류!" << std::endl;
                __debugbreak();
            }
            block->allocId = m_allocCounter.fetch_add(1);
        #endif
        
        // 객체 포인터 반환 (헤더 다음 위치)
        T* object = reinterpret_cast<T*>(reinterpret_cast<char*>(block) + sizeof(PoolBlock));
        
        // 통계 업데이트
        m_stats.totalAllocations.fetch_add(1);
        m_stats.poolHits.fetch_add(1);
        SIZE_T current = m_stats.currentAllocations.fetch_add(1) + 1;
        
        // 최대 동시 할당 수 업데이트 (CAS)
        SIZE_T peak = m_stats.peakAllocations.load();
        while (current > peak && !m_stats.peakAllocations.compare_exchange_weak(peak, current)) {
            // 다른 스레드가 peak를 변경했을 수 있으므로 다시 시도
        }
        
        return object;
    }
    
    /**
     * @brief 메모리 블록만 해제 (소멸자 호출 안 함)
     */
    void Deallocate(T* object) {
        if (!object) return;
        
        std::lock_guard<std::mutex> lock(m_mutex);
        
        // 블록 헤더 위치 계산
        PoolBlock* block = reinterpret_cast<PoolBlock*>(
            reinterpret_cast<char*>(object) - sizeof(PoolBlock));
        
        #ifdef _DEBUG
            if (block->signature != BLOCK_SIGNATURE) {
                std::wcout << L"잘못된 포인터 또는 이중 해제: " << object << std::endl;
                __debugbreak();
                return;
            }
            
            // 디버그 빌드에서는 해제된 메모리를 특정 패턴으로 채움
            memset(object, 0xDD, sizeof(T));
            block->allocId = 0; // 할당 ID 리셋
        #endif
        
        // 자유 리스트에 추가
        block->next = m_freeHead;
        m_freeHead = block;
        m_freeBlocks++;
        
        // 통계 업데이트
        m_stats.totalDeallocations.fetch_add(1);
        m_stats.currentAllocations.fetch_sub(1);
    }
    
    /**
     * @brief 객체 생성 (메모리 할당 + 생성자 호출)
     */
    template<typename... Args>
    T* Create(Args&&... args) {
        T* object = Allocate();
        if (object) {
            // placement new로 생성자 호출
            new(object) T(std::forward<Args>(args)...);
        }
        return object;
    }
    
    /**
     * @brief 객체 파괴 (소멸자 호출 + 메모리 해제)
     */
    void Destroy(T* object) {
        if (object) {
            object->~T(); // 명시적 소멸자 호출
            Deallocate(object);
        }
    }
    
    // 통계 정보 반환
    PoolStats GetStats() const {
        return m_stats;
    }
    
    SIZE_T GetTotalBlocks() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_totalBlocks;
    }
    
    SIZE_T GetFreeBlocks() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_freeBlocks;
    }
    
    SIZE_T GetUsedBlocks() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_totalBlocks - m_freeBlocks;
    }
    
    // 통계 출력
    void PrintStats() const {
        std::wcout << L"\n--- 풀 통계 (" << typeid(T).name() << L") ---" << std::endl;
        std::wcout << L"총 할당: " << m_stats.totalAllocations.load() << std::endl;
        std::wcout << L"총 해제: " << m_stats.totalDeallocations.load() << std::endl;
        std::wcout << L"현재 사용 중: " << m_stats.currentAllocations.load() << std::endl;
        std::wcout << L"최대 동시 사용: " << m_stats.peakAllocations.load() << std::endl;
        std::wcout << L"풀 히트: " << m_stats.poolHits.load() << std::endl;
        std::wcout << L"풀 미스(청크 확장): " << m_stats.poolMisses.load() << std::endl;
        std::wcout << L"총 블록 수: " << GetTotalBlocks() << std::endl;
        std::wcout << L"사용 중 블록: " << GetUsedBlocks() << std::endl;
        std::wcout << L"자유 블록: " << GetFreeBlocks() << std::endl;
    }
};
```
  
이 코드는 게임 서버나 실시간 애플리케이션에서 **객체 생성과 해제 비용을 줄이기 위한 고성능, 스레드 안전한 메모리 풀** 구현이다.
자주 생성·소멸되는 객체(예: 총알, 몬스터, 이펙트 등)에 대해 `new`와 `delete`를 반복 호출하면 성능 저하와 메모리 단편화가 발생한다.
이를 해결하기 위해 미리 할당된 큰 메모리 청크를 고정 크기 블록으로 나누고, 객체를 재활용하는 방식으로 동작한다.


#### 1.1 핵심 개념

* **Chunk(청크)**: `VirtualAlloc`을 통해 OS로부터 직접 확보한 큰 메모리 덩어리다.
* **Block(블록)**: 청크를 일정한 크기로 분할한 단위로, 하나의 객체(`T`)가 들어가는 공간이다.
* **Free List(자유 리스트)**: 사용 가능한 블록을 연결 리스트 형태로 관리한다.
* **Thread Safety**: `std::mutex`로 동시 접근을 제어한다.


#### 2.1 `PoolStats`
메모리 풀의 통계를 추적한다.

```cpp
struct PoolStats {
    std::atomic<SIZE_T> totalAllocations;
    std::atomic<SIZE_T> totalDeallocations;
    std::atomic<SIZE_T> currentAllocations;
    std::atomic<SIZE_T> peakAllocations;
    std::atomic<SIZE_T> poolHits;
    std::atomic<SIZE_T> poolMisses;
};
```

* `poolHits`: 풀에서 성공적으로 블록을 가져온 횟수
* `poolMisses`: 자유 블록이 없어 새 청크를 할당한 횟수

#### 2.2 `PoolBlock`
각 블록의 헤더로, 다음 블록의 포인터를 가진다.
디버그 모드에서는 블록 무결성 검증용 시그니처(`0xDEADBEEF`)와 할당 ID를 포함한다.

```cpp
struct PoolBlock {
    PoolBlock* next;
    #ifdef _DEBUG
        DWORD signature;
        DWORD allocId;
    #endif
};
```

#### 2.3 `PoolChunk`
하나의 청크를 나타내며, VirtualAlloc으로 확보한 메모리 주소와 크기를 관리한다.

```cpp
struct PoolChunk {
    LPVOID memory;
    SIZE_T size;
    PoolChunk* next;
};
```


#### 3. 생성자 및 초기화 과정
생성자는 초기 블록 수(`initialBlocks`)와 청크당 블록 수(`blocksPerChunk`)를 받아 초기 청크를 미리 확보한다.

```cpp
explicit GameObjectPool(SIZE_T initialBlocks = 1000, SIZE_T blocksPerChunk = 1000)
```

* 객체 크기(`sizeof(T)`)와 헤더 크기를 합산하여 정렬된 블록 크기를 계산한다.
* `AllocateNewChunk()`를 호출하여 초기 청크를 확보하고 자유 리스트를 채운다.

출력 예시:

```
=== 메모리 풀 초기화 (MyObject) ===
객체 크기: 64 bytes
블록 크기: 80 bytes
청크당 블록 수: 1000
청크 크기: 78KB
```

#### 4. 청크 할당 (`AllocateNewChunk`)
자유 블록이 부족할 때 새로운 청크를 확보한다.
`VirtualAlloc`으로 연속된 메모리를 얻고, 이를 블록 단위로 분리해 자유 리스트에 추가한다.

```cpp
BOOL AllocateNewChunk() {
    LPVOID chunkMemory = VirtualAlloc(nullptr, m_chunkSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    ...
    for (SIZE_T i = 0; i < m_blocksPerChunk; ++i) {
        PoolBlock* block = reinterpret_cast<PoolBlock*>(blockPtr);
        block->next = m_freeHead;
        m_freeHead = block;
        blockPtr += m_blockSize;
    }
}
```

* 실패 시 오류 코드(`GetLastError()`)를 출력한다.
* 성공 시 `m_freeHead`를 갱신하고, 통계를 업데이트한다.

#### 5. 메모리 할당 (`Allocate`)
자유 블록 리스트에서 하나를 꺼내 사용한다.
자유 블록이 없으면 `AllocateNewChunk()`로 청크를 추가한다.

```cpp
T* Allocate() {
    std::lock_guard<std::mutex> lock(m_mutex);
    if (!m_freeHead) {
        m_stats.poolMisses.fetch_add(1);
        AllocateNewChunk();
    }

    PoolBlock* block = m_freeHead;
    m_freeHead = block->next;
    T* object = reinterpret_cast<T*>(reinterpret_cast<char*>(block) + sizeof(PoolBlock));
    ...
    return object;
}
```

* `m_stats`를 통해 할당 횟수 및 피크 사용량을 추적한다.
* 디버그 모드에서는 시그니처 검증 및 할당 ID 증가를 수행한다.

#### 6. 메모리 해제 (`Deallocate`)
객체 주소로부터 블록 헤더를 역으로 계산하고, 자유 리스트에 반환한다.

```cpp
void Deallocate(T* object) {
    if (!object) return;
    std::lock_guard<std::mutex> lock(m_mutex);
    PoolBlock* block = reinterpret_cast<PoolBlock*>(
        reinterpret_cast<char*>(object) - sizeof(PoolBlock));
    ...
    block->next = m_freeHead;
    m_freeHead = block;
}
```

* 디버그 빌드에서는 해제된 영역을 `0xDD`로 덮어 메모리 오염을 탐지한다.
* 통계(`totalDeallocations`, `currentAllocations`)를 갱신한다.

#### 객체 생성 및 소멸 7.1 `Create()`
메모리만 확보하는 `Allocate()` 후 placement new를 호출한다.

```cpp
template<typename... Args>
T* Create(Args&&... args) {
    T* object = Allocate();
    if (object)
        new(object) T(std::forward<Args>(args)...);
    return object;
}
```

#### 객체 생성 및 소멸 7.2 `Destroy()`
소멸자를 명시적으로 호출한 뒤 `Deallocate()`로 반환한다.

```cpp
void Destroy(T* object) {
    if (object) {
        object->~T();
        Deallocate(object);
    }
}
```

#### 8. 통계 및 디버그 출력
`PrintStats()`는 현재 풀의 상태를 출력한다.

```cpp
void PrintStats() const {
    std::wcout << L"총 할당: " << m_stats.totalAllocations.load() << std::endl;
    ...
}
```

출력 예시:

```
--- 풀 통계 (MyObject) ---
총 할당: 1200
총 해제: 1180
현재 사용 중: 20
최대 동시 사용: 40
풀 히트: 1190
풀 미스(청크 확장): 1
총 블록 수: 2000
```


#### 9. 사용 예시

```cpp
GameObjectPool<MyObject> pool(1000);

MyObject* obj = pool.Create(10, 20);
pool.Destroy(obj);
pool.PrintStats();
```

* **Create/Destroy**로 객체 생성·소멸 관리가 가능하다.
* 게임 서버의 반복적인 객체 재사용에 적합하다.
* 스레드 환경에서도 안전하게 동작한다.


#### 요약
이 `GameObjectPool` 클래스는 **게임 엔진 또는 서버의 동적 객체 관리 효율을 극대화**하기 위한 메모리 풀 구현이다.
`VirtualAlloc` 기반으로 대규모 연속 메모리를 관리하며,
객체 재사용을 통해 **할당 비용 최소화**, **단편화 방지**, **스레드 안전성 보장**을 달성한다.
  



### 고성능 메모릴 풀. 스레드 로컬 풀 (ThreadLocalPool.h)
이 클래스는 `MemoryPool.h`에 의존한다.

```cpp
#pragma once

#include "MemoryPool.h" // 위에서 정의한 GameObjectPool
#include <vector>
#include <mutex>

/**
 * @brief 스레드 로컬(TLS) 메모리 풀
 * @details
 * - 각 스레드가 자신만의 GameObjectPool 인스턴스를 소유합니다. (thread_local 키워드 사용)
 * - 스레드 내에서의 할당/해제는 락(lock)이 필요 없습니다. (성능 향상)
 * - 다른 스레드로 객체를 전달하여 해제하는 것은 금지됩니다. (반드시 할당한 스레드에서 해제)
 * - 모든 스레드의 풀을 관리하기 위한 전역 리스트(s_allPools)가 필요하며,
 * 이 리스트에 접근할 때만 전역 락(s_globalMutex)을 사용합니다.
 */
template<typename T>
class ThreadLocalPool {
private:
    // thread_local: 각 스레드마다 고유한 t_localPool 포인터를 가짐
    thread_local static GameObjectPool<T>* t_localPool;
    
    // 모든 스레드의 풀을 추적하기 위한 전역 변수들
    static std::mutex s_globalMutex;
    static std::vector<GameObjectPool<T>*> s_allPools;

    // 현재 스레드의 풀을 초기화하는 함수
    static void InitThreadLocalPool() {
        if (!t_localPool) {
            std::lock_guard<std::mutex> lock(s_globalMutex);
            // 이 스레드를 위한 새 풀 생성
            t_localPool = new GameObjectPool<T>(500); // 스레드당 500개
            s_allPools.push_back(t_localPool);
        }
    }
    
public:
    static T* Allocate() {
        InitThreadLocalPool();
        return t_localPool->Allocate();
    }
    
    static void Deallocate(T* object) {
        if (t_localPool) {
            t_localPool->Deallocate(object);
        }
    }
    
    template<typename... Args>
    static T* Create(Args&&... args) {
        InitThreadLocalPool();
        return t_localPool->Create(std::forward<Args>(args)...);
    }
    
    static void Destroy(T* object) {
        if (t_localPool) {
            t_localPool->Destroy(object);
        }
    }
    
    // 모든 스레드의 풀 통계를 합산하여 출력
    static void PrintAllStats() {
        std::lock_guard<std::mutex> lock(s_globalMutex);
        
        std::wcout << L"\n=== 전체 스레드 로컬 풀 통계 (" << typeid(T).name() << L") ===" << std::endl;
        std::wcout << L"총 스레드 풀 수: " << s_allPools.size() << std::endl;

        PoolStats totalStats;
        SIZE_T totalBlocks = 0;
        SIZE_T totalFreeBlocks = 0;

        for (auto* pool : s_allPools) {
            PoolStats stats = pool->GetStats();
            totalStats.totalAllocations += stats.totalAllocations.load();
            totalStats.totalDeallocations += stats.totalDeallocations.load();
            totalStats.currentAllocations += stats.currentAllocations.load();
            totalStats.poolHits += stats.poolHits.load();
            totalStats.poolMisses += stats.poolMisses.load();
            
            // Peak는 개별 풀의 최대값을 추적
            SIZE_T peak = stats.peakAllocations.load();
            if (peak > totalStats.peakAllocations.load()) {
                totalStats.peakAllocations = peak;
            }

            totalBlocks += pool->GetTotalBlocks();
            totalFreeBlocks += pool->GetFreeBlocks();
        }
        
        std::wcout << L"총 할당: " << totalStats.totalAllocations.load() << std::endl;
        std::wcout << L"총 해제: " << totalStats.totalDeallocations.load() << std::endl;
        std::wcout << L"현재 사용 중: " << totalStats.currentAllocations.load() << std::endl;
        std::wcout << L"최대 동시 사용(합산 아님): " << totalStats.peakAllocations.load() << std::endl;
        std::wcout << L"총 블록 수: " << totalBlocks << std::endl;
        std::wcout << L"총 자유 블록 수: " << totalFreeBlocks << std::endl;
    }
    
    // 프로그램 종료 시 모든 스레드 풀을 정리
    static void CleanupAllPools() {
        std::lock_guard<std::mutex> lock(s_globalMutex);
        
        for (auto* pool : s_allPools) {
            delete pool;
        }
        s_allPools.clear();
        t_localPool = nullptr; // 현재 스레드 것도 정리
    }
};

// 정적(static) 멤버 변수 정의
template<typename T>
thread_local GameObjectPool<T>* ThreadLocalPool<T>::t_localPool = nullptr;

template<typename T>
std::mutex ThreadLocalPool<T>::s_globalMutex;

template<typename T>
std::vector<GameObjectPool<T>*> ThreadLocalPool<T>::s_allPools;
```
    
이 코드는 **멀티스레드 환경에서 객체를 빠르고 안전하게 관리하기 위한 “스레드 로컬 메모리 풀(Thread-Local Memory Pool)” 구현**이다.
`MemoryPool.h`에서 정의한 `GameObjectPool`을 기반으로, **스레드마다 독립적인 풀을 가지고**, 락 경쟁 없이 고성능으로 메모리를 관리하도록 설계되었다.


#### 1.1 왜 스레드 로컬 메모리 풀이 필요한가
기본 메모리 풀(`GameObjectPool`)은 스레드 안전하지만, 내부적으로 `std::mutex`를 사용하여 락(lock)을 걸기 때문에 다중 스레드가 동시에 접근하면 성능 저하가 발생할 수 있다.
이를 개선하기 위해 **각 스레드가 자신만의 메모리 풀을 가지게** 하여, **자기 스레드 안에서는 락이 필요 없도록** 만든 것이 `ThreadLocalPool`이다.

즉, 이 클래스는 다음과 같은 상황에서 사용된다:

* 다중 스레드에서 자주 객체를 생성·파괴해야 할 때
* 각 스레드가 독립적으로 객체를 관리할 때
* 스레드 간 객체 전달이 거의 없을 때

#### 2. 주요 특징 요약

| 특징        | 설명                                         |
| --------- | ------------------------------------------ |
| 스레드 독립성   | `thread_local` 키워드를 사용하여 스레드마다 고유한 풀을 생성한다 |
| 락 프리 할당   | 같은 스레드 내에서는 락이 필요 없어 빠르다                   |
| 전역 관리 지원  | 모든 스레드 풀을 모아 통계를 출력하거나 정리할 수 있다            |
| 안전한 해제 규칙 | 객체는 반드시 **할당한 스레드에서 해제**해야 한다              |


#### 3.1 정적(thread_local) 멤버

```cpp
thread_local static GameObjectPool<T>* t_localPool;
```

* 각 스레드마다 독립적인 포인터를 가진다.
* 즉, A 스레드와 B 스레드가 동시에 실행되어도 각각 `t_localPool`이 따로 존재한다.

#### 3.2 전역 관리 변수

```cpp
static std::mutex s_globalMutex;
static std::vector<GameObjectPool<T>*> s_allPools;
```

* **모든 스레드의 풀 목록**을 저장하는 `s_allPools` 벡터와
  **이 목록에 접근할 때 사용하는 전역 락** `s_globalMutex`를 가진다.
* 스레드 로컬 풀 자체의 할당/해제에는 락이 필요 없지만,
  새로운 풀을 등록하거나 전체 통계를 출력할 때는 락을 사용한다.


#### 4. 스레드 초기화 과정

스레드에서 처음으로 메모리를 할당하려 하면 `InitThreadLocalPool()`이 호출된다.

```cpp
static void InitThreadLocalPool() {
    if (!t_localPool) {
        std::lock_guard<std::mutex> lock(s_globalMutex);
        t_localPool = new GameObjectPool<T>(500);
        s_allPools.push_back(t_localPool);
    }
}
```

* 현재 스레드에 풀(`t_localPool`)이 없으면 새로 생성한다.
* 스레드당 500개의 블록을 가진 `GameObjectPool`을 만든다.
* 이 풀을 전역 목록에 추가한다.

이 과정은 한 스레드당 한 번만 실행된다.

#### 5.1 할당 (`Allocate`)

```cpp
static T* Allocate() {
    InitThreadLocalPool();
    return t_localPool->Allocate();
}
```

* 현재 스레드의 로컬 풀에서 객체 메모리를 하나 가져온다.
* 락이 필요 없으므로 매우 빠르다.

#### 5.2 해제 (`Deallocate`)

```cpp
static void Deallocate(T* object) {
    if (t_localPool) {
        t_localPool->Deallocate(object);
    }
}
```

* 해당 객체를 같은 스레드의 풀로 되돌린다.
* **다른 스레드에서 해제하면 정의되지 않은 동작**을 일으킬 수 있다.

#### 5.3 객체 생성과 소멸 (`Create`, `Destroy`)

```cpp
template<typename... Args>
static T* Create(Args&&... args) {
    InitThreadLocalPool();
    return t_localPool->Create(std::forward<Args>(args)...);
}

static void Destroy(T* object) {
    if (t_localPool) {
        t_localPool->Destroy(object);
    }
}
```

* `Create()`는 `placement new`를 통해 생성자를 직접 호출한다.
* `Destroy()`는 소멸자를 명시적으로 호출하고 메모리를 반환한다.


#### 6. 전체 통계 출력 (`PrintAllStats`)
모든 스레드의 풀 상태를 합산하여 출력한다.
이때는 여러 스레드의 리스트에 접근해야 하므로 전역 락을 사용한다.

```cpp
static void PrintAllStats() {
    std::lock_guard<std::mutex> lock(s_globalMutex);
    std::wcout << L"총 스레드 풀 수: " << s_allPools.size() << std::endl;
    ...
}
```

출력 예시:

```
=== 전체 스레드 로컬 풀 통계 (MyObject) ===
총 스레드 풀 수: 4
총 할당: 10000
총 해제: 9950
현재 사용 중: 50
최대 동시 사용(합산 아님): 80
총 블록 수: 2000
총 자유 블록 수: 1950
```

#### 7. 모든 풀 정리 (`CleanupAllPools`)
프로그램 종료 시 메모리 누수를 방지하기 위해 모든 풀을 삭제한다.

```cpp
static void CleanupAllPools() {
    std::lock_guard<std::mutex> lock(s_globalMutex);
    for (auto* pool : s_allPools) {
        delete pool;
    }
    s_allPools.clear();
    t_localPool = nullptr;
}
```

이 함수는 **모든 스레드의 풀을 안전하게 해제**하고 정리한다.

#### 8. 사용 예시

```cpp
void WorkerThread() {
    for (int i = 0; i < 1000; ++i) {
        auto* obj = ThreadLocalPool<MyObject>::Create(i);
        ThreadLocalPool<MyObject>::Destroy(obj);
    }
}

int main() {
    std::thread t1(WorkerThread);
    std::thread t2(WorkerThread);
    t1.join();
    t2.join();

    ThreadLocalPool<MyObject>::PrintAllStats();
    ThreadLocalPool<MyObject>::CleanupAllPools();
}
```

* 각 스레드는 자신의 풀을 가지고 독립적으로 객체를 관리한다.
* 메모리 락 경합이 없으므로 매우 빠르다.
* 실행 후 전체 통계를 출력할 수 있다.

#### 9. 정리
`ThreadLocalPool`은 **멀티스레드 환경에서의 메모리 관리 효율을 극대화하기 위한 설계**다.

* 스레드마다 독립적인 풀을 생성하여 락을 최소화하고,
* 전역적으로 통계와 정리를 지원하여 안정성을 보장한다.
* 단, **객체는 반드시 생성한 스레드에서 해제해야** 한다.

이 방식은 게임 서버, 물리 엔진, 네트워크 패킷 처리 등
**스레드별로 독립된 작업이 반복되는 시스템에서 가장 큰 효과를 발휘한다.**

  

### 두 종류의 풀을 테스트
두 종류의 풀을 테스트하는 예제 코드이다.

```cpp
// (이 파일은 MemoryPool.h와 ThreadLocalPool.h를 포함한다고 가정합니다)
#include "ThreadLocalPool.h" // 이 파일이 MemoryPool.h를 이미 포함함
#include <thread> // ThreadLocalPool 테스트를 위해 추가

// 테스트용 게임 객체들
struct GamePlayer {
    DWORD playerId;
    wchar_t name[32];
    FLOAT x, y, z;
    DWORD level;
    DWORD experience;
    
    GamePlayer(DWORD id = 0, const wchar_t* playerName = L"Unknown") 
        : playerId(id), level(1), experience(0), x(0), y(0), z(0) {
        if (playerName) {
            wcscpy_s(name, playerName);
        }
    }
    
    ~GamePlayer() {
        // 소멸자 (특별한 작업 없음)
    }
};

struct GameBullet {
    FLOAT x, y, z;
    FLOAT velocityX, velocityY, velocityZ;
    DWORD damage;
    DWORD ownerId;
    FLOAT timeToLive;
    
    GameBullet(FLOAT startX = 0, FLOAT startY = 0, FLOAT startZ = 0)
        : x(startX), y(startY), z(startZ)
        , velocityX(0), velocityY(0), velocityZ(0)
        , damage(10), ownerId(0), timeToLive(5.0f) {
    }
};

/**
 * @brief 테스트 1: 기본 GameObjectPool (전역 락 사용)
 */
void DemonstrateMemoryPool() {
    std::wcout << L"=======================================" << std::endl;
    std::wcout << L"=== 기본 GameObjectPool 데모 시작 ===" << std::endl;
    std::wcout << L"=======================================" << std::endl;
    
    // 플레이어 풀 생성 (초기 100개)
    GameObjectPool<GamePlayer> playerPool(100); 
    // 총알 풀 생성 (초기 1000개)
    GameObjectPool<GameBullet> bulletPool(1000);
    
    auto start = GetTickCount64();
    
    std::vector<GamePlayer*> players;
    std::vector<GameBullet*> bullets;
    
    // 플레이어 50명 생성
    for (int i = 0; i < 50; ++i) {
        wchar_t name[32];
        swprintf_s(name, L"Player%d", i + 1);
        
        GamePlayer* player = playerPool.Create(i + 1, name);
        if (player) {
            players.push_back(player);
        }
    }
    
    // 총알 500발 생성
    for (int i = 0; i < 500; ++i) {
        GameBullet* bullet = bulletPool.Create(static_cast<float>(i), 0.f, 0.f);
        if (bullet) {
            bullets.push_back(bullet);
        }
    }
    
    auto end = GetTickCount64();
    
    std::wcout << L"\n객체 생성 완료: " << (end - start) << L"ms" << std::endl;
    std::wcout << L"생성된 플레이어: " << players.size() << std::endl;
    std::wcout << L"생성된 총알: " << bullets.size() << std::endl;
    
    playerPool.PrintStats();
    bulletPool.PrintStats();
    
    // 일부 객체 해제
    for (size_t i = 0; i < players.size(); i += 2) {
        playerPool.Destroy(players[i]);
        players[i] = nullptr;
    }
    
    std::wcout << L"\n일부 객체 해제 후 통계:" << std::endl;
    playerPool.PrintStats();
    
    // 남은 객체들 해제
    for (GamePlayer* player : players) {
        playerPool.Destroy(player); // nullptr을 Destroy해도 안전함
    }
    for (GameBullet* bullet : bullets) {
        bulletPool.Destroy(bullet);
    }
    
    std::wcout << L"\n모든 객체 해제 후 최종 통계:" << std::endl;
    // (소멸자가 호출되면서 자동으로 통계 출력)
}


/**
 * @brief 테스트 2: ThreadLocalPool (스레드별 풀, 락 경합 없음)
 */
void DemonstrateThreadLocalPool() {
    std::wcout << L"\n==========================================" << std::endl;
    std::wcout << L"=== 스레드 로컬(TLS) 풀 데모 시작 ===" << std::endl;
    std::wcout << L"==========================================" << std::endl;
    
    constexpr int NUM_THREADS = 4;
    constexpr int ALLOCS_PER_THREAD = 10000; // 스레드당 1만개 할당
    
    std::vector<std::thread> threads;
    
    // 각 스레드가 수행할 작업
    auto work = [&]() {
        std::vector<GameBullet*> bullets;
        bullets.reserve(ALLOCS_PER_THREAD);
        
        // 1. 할당
        for(int i=0; i < ALLOCS_PER_THREAD; ++i) {
            bullets.push_back(ThreadLocalPool<GameBullet>::Create(1.f, 2.f, 3.f));
        }
        
        // 2. 해제 (할당한 스레드에서 해제해야 함)
        for(GameBullet* b : bullets) {
            ThreadLocalPool<GameBullet>::Destroy(b);
        }
    };
    
    auto start = GetTickCount64();
    
    // 스레드 생성 및 실행
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads.emplace_back(work);
    }
    
    // 모든 스레드가 종료될 때까지 대기
    for (auto& t : threads) {
        t.join();
    }
    
    auto end = GetTickCount64();
    std::wcout << L"\nTLS 풀 테스트 완료 (" << NUM_THREADS << L"개 스레드, 총 " 
             << (NUM_THREADS * ALLOCS_PER_THREAD) << L"개 객체): " 
             << (end - start) << L"ms" << std::endl;

    // 모든 스레드의 통계 출력
    ThreadLocalPool<GameBullet>::PrintAllStats();
    
    // 모든 풀 정리
    ThreadLocalPool<GameBullet>::CleanupAllPools();
    ThreadLocalPool<GamePlayer>::CleanupAllPools(); // 사용 안했어도 정리
}


int wmain() {
    // 테스트 1: 기본 메모리 풀 실행
    DemonstrateMemoryPool();

    // 테스트 2: 스레드 로컬 메모리 풀 실행
    DemonstrateThreadLocalPool();
    
    std::wcout << L"\n모든 데모 완료. 종료합니다." << std::endl;
    return 0;
}
```  
  

```cpp

// 사용 예시
int wmain() {
    std::wcout << L"=== 통합 메모리 관리 시스템 데모 ===" << std::endl;
    
    // 전역 메모리 관리자 초기화
    g_memoryManager = std::make_unique<GameMemoryManager>();
    
    if (!g_memoryManager->Initialize()) {
        std::wcout << L"메모리 관리자 초기화 실패" << std::endl;
        return 1;
    }
    
    // 게임 시뮬레이션
    std::vector<GamePlayer*> players;
    std::vector<GameBullet*> bullets;
    
    // 플레이어 생성
    for (int i = 0; i < 100; ++i) {
        wchar_t name[32];
        swprintf_s(name, L"Player%d", i + 1);
        
        GamePlayer* player = CreateGamePlayer(i + 1, name);
        if (player) {
            players.push_back(player);
        }
    }
    
    // 총알 대량 생성/해제 (시뮬레이션)
    for (int round = 0; round < 10; ++round) {
        // 총알 생성
        for (int i = 0; i < 1000; ++i) {
            GameBullet* bullet = CreateGameBullet(
                static_cast<float>(i % 100),
                static_cast<float>(i / 100),
                static_cast<float>(round * 10)
            );
            if (bullet) {
                bullets.push_back(bullet);
            }
        }
        
        // 일부 총알 해제
        for (size_t i = 0; i < bullets.size() / 2; ++i) {
            DestroyGameBullet(bullets[i]);
        }
        bullets.erase(bullets.begin(), bullets.begin() + bullets.size() / 2);
        
        std::wcout << L"라운드 " << round + 1 << L" 완료, 남은 총알: " << bullets.size() << std::endl;
    }
    
    // 메모리 압축 테스트
    g_memoryManager->CompactMemory();
    
    // 최종 통계
    g_memoryManager->PrintGlobalStats();
    
    // 정리
    for (GamePlayer* player : players) {
        DestroyGamePlayer(player);
    }
    
    for (GameBullet* bullet : bullets) {
        DestroyGameBullet(bullet);
    }
    
    g_memoryManager.reset();
    
    std::wcout << L"데모 완료" << std::endl;
    return 0;
}
```

이번 장에서는 Win32 API를 활용한 고성능 메모리 관리 기법들을 학습했다. 다음 장에서는 파일 시스템과 I/O 최적화 기법을 다루어 게임 서버의 데이터 처리 성능을 향상시키는 방법을 알아보겠다.


 