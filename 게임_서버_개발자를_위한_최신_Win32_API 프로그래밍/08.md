# ê²Œì„ ì„œë²„ ê°œë°œìë¥¼ ìœ„í•œ ìµœì‹  Win32 API í”„ë¡œê·¸ë˜ë°  

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  

# Chapter 8. ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘
ê²Œì„ ì„œë²„ ê°œë°œì—ì„œ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ì€ ì„œë²„ì˜ ìƒíƒœë¥¼ íŒŒì•…í•˜ê³ , ìµœì ì˜ ì„±ëŠ¥ì„ ìœ ì§€í•˜ë©°, ë¬¸ì œë¥¼ ì‚¬ì „ì— ì˜ˆë°©í•˜ëŠ” í•µì‹¬ ìš”ì†Œì´ë‹¤. ì´ë²ˆ ì¥ì—ì„œëŠ” Win32 APIë¥¼ í™œìš©í•˜ì—¬ ë‹¤ì–‘í•œ ì‹œìŠ¤í…œ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ê³  ëª¨ë‹ˆí„°ë§í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ë‹¤.

## 8.1 GetSystemInfoë¥¼ í†µí•œ í•˜ë“œì›¨ì–´ ì •ë³´

### 8.1.1 ì‹œìŠ¤í…œ ì •ë³´ì˜ ì¤‘ìš”ì„±
ê²Œì„ ì„œë²„ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì´ìœ ë¡œ ì‹œìŠ¤í…œ ì •ë³´ë¥¼ íŒŒì•…í•´ì•¼ í•œë‹¤:

```
    ê²Œì„ ì„œë²„
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CPU ì •ë³´       â”‚ â†’   â”‚   ë©”ëª¨ë¦¬ ì •ë³´    â”‚ â†’    â”‚   ì‹œìŠ¤í…œ ì„¤ì •    â”‚
â”‚ - ì½”ì–´ ìˆ˜        â”‚     â”‚ - ë¬¼ë¦¬ ë©”ëª¨ë¦¬    â”‚      â”‚ - í˜ì´ì§€ í¬ê¸°    â”‚
â”‚ - ì•„í‚¤í…ì²˜       â”‚     â”‚ - ê°€ìš© ë©”ëª¨ë¦¬    â”‚      â”‚ - í”„ë¡œì„¸ì„œ ìˆ˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“                       â†“                       â†“
    ìŠ¤ë ˆë“œ í’€ í¬ê¸° ê²°ì •      ë©”ëª¨ë¦¬ í• ë‹¹ ì „ëµ         ìµœì í™” ì „ëµ ìˆ˜ë¦½
```
  
### 8.1.2 GetSystemInfo í•¨ìˆ˜ í™œìš©
`GetSystemInfo` í•¨ìˆ˜ëŠ” ì‹œìŠ¤í…œì˜ ê¸°ë³¸ì ì¸ í•˜ë“œì›¨ì–´ ì •ë³´ë¥¼ ì œê³µí•œë‹¤:

```cpp
// SystemInfoCollector.h
#pragma once
#include <windows.h>
#include <iostream>
#include <string>
#include <iomanip>

class SystemInfoCollector {
private:
    SYSTEM_INFO m_systemInfo;
    
public:
    SystemInfoCollector();
    void CollectBasicSystemInfo();
    void DisplaySystemInfo() const;
    
    // ê²Œì„ ì„œë²„ ìµœì í™”ë¥¼ ìœ„í•œ ì •ë³´ ì¶”ì¶œ
    DWORD GetOptimalThreadCount() const;
    SIZE_T GetPageSize() const;
    DWORD GetProcessorCount() const;
    std::string GetProcessorArchitecture() const;
};
```

```cpp
// SystemInfoCollector.cpp
#include "SystemInfoCollector.h"

SystemInfoCollector::SystemInfoCollector() {
    ZeroMemory(&m_systemInfo, sizeof(SYSTEM_INFO));
}

void SystemInfoCollector::CollectBasicSystemInfo() {
    GetSystemInfo(&m_systemInfo);
}

void SystemInfoCollector::DisplaySystemInfo() const {
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                     ì‹œìŠ¤í…œ ì •ë³´ ë³´ê³ ì„œ                        â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    
    std::cout << "â•‘ í”„ë¡œì„¸ì„œ ì•„í‚¤í…ì²˜: " << std::setw(39) << std::left 
              << GetProcessorArchitecture() << " â•‘\n";
    
    std::cout << "â•‘ í”„ë¡œì„¸ì„œ ìˆ˜:       " << std::setw(39) << std::left 
              << m_systemInfo.dwNumberOfProcessors << " â•‘\n";
    
    std::cout << "â•‘ í˜ì´ì§€ í¬ê¸°:       " << std::setw(34) << std::left 
              << (m_systemInfo.dwPageSize / 1024) << " KB  â•‘\n";
    
    std::cout << "â•‘ ìµœì†Œ ì£¼ì†Œ:         0x" << std::setw(36) << std::left 
              << std::hex << (uintptr_t)m_systemInfo.lpMinimumApplicationAddress 
              << std::dec << " â•‘\n";
    
    std::cout << "â•‘ ìµœëŒ€ ì£¼ì†Œ:         0x" << std::setw(36) << std::left 
              << std::hex << (uintptr_t)m_systemInfo.lpMaximumApplicationAddress 
              << std::dec << " â•‘\n";
    
    std::cout << "â•‘ í™œì„± í”„ë¡œì„¸ì„œ ë§ˆìŠ¤í¬: 0x" << std::setw(34) << std::left 
              << std::hex << m_systemInfo.dwActiveProcessorMask << std::dec << " â•‘\n";
    
    std::cout << "â•‘ í• ë‹¹ ë‹¨ìœ„:         " << std::setw(34) << std::left 
              << (m_systemInfo.dwAllocationGranularity / 1024) << " KB  â•‘\n";
    
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
}

DWORD SystemInfoCollector::GetOptimalThreadCount() const {
    // ê²Œì„ ì„œë²„ì—ì„œëŠ” ë³´í†µ CPU ì½”ì–´ ìˆ˜ì˜ 2ë°° ì •ë„ì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©
    return m_systemInfo.dwNumberOfProcessors * 2;
}

SIZE_T SystemInfoCollector::GetPageSize() const {
    return m_systemInfo.dwPageSize;
}

DWORD SystemInfoCollector::GetProcessorCount() const {
    return m_systemInfo.dwNumberOfProcessors;
}

std::string SystemInfoCollector::GetProcessorArchitecture() const {
    switch (m_systemInfo.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_AMD64:
            return "x64 (AMD64)";
        case PROCESSOR_ARCHITECTURE_ARM:
            return "ARM";
        case PROCESSOR_ARCHITECTURE_ARM64:
            return "ARM64";
        case PROCESSOR_ARCHITECTURE_IA64:
            return "Intel Itanium (IA64)";
        case PROCESSOR_ARCHITECTURE_INTEL:
            return "x86 (Intel)";
        default:
            return "Unknown";
    }
}
```
  
**Windows APIì˜ `GetSystemInfo()` í•¨ìˆ˜**ë¥¼ í™œìš©í•´ ì‹œìŠ¤í…œì˜ ê¸°ë³¸ í•˜ë“œì›¨ì–´ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ê³  í‘œì‹œí•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¬ë‹¤.
`GetSystemInfo`ëŠ” ìš´ì˜ì²´ì œì—ì„œ ì œê³µí•˜ëŠ” í•¨ìˆ˜ë¡œ, **CPU ì•„í‚¤í…ì²˜, í”„ë¡œì„¸ì„œ ìˆ˜, ë©”ëª¨ë¦¬ í˜ì´ì§€ í¬ê¸°, ì£¼ì†Œ ë²”ìœ„ ë“±**ì˜ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤.

ì´ í•¨ìˆ˜ëŠ” íŠ¹íˆ **ê²Œì„ ì„œë²„ë‚˜ ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë¨ì˜ ì„±ëŠ¥ ìµœì í™”**ì—ì„œ ìœ ìš©í•˜ë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì„œë²„ì˜ CPU ì½”ì–´ ìˆ˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìŠ¤ë ˆë“œ í’€ í¬ê¸°ë¥¼ ê²°ì •í•  ìˆ˜ ìˆê³ , í˜ì´ì§€ í¬ê¸°(Page Size)ë¥¼ ì´ìš©í•´ ë©”ëª¨ë¦¬ ê´€ë¦¬ ë‹¨ìœ„ë¥¼ ì¡°ì •í•  ìˆ˜ë„ ìˆë‹¤.


ì•„ë˜ í´ë˜ìŠ¤ëŠ” `SystemInfoCollector`ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì„¤ê³„ë˜ì–´ ìˆë‹¤.
ì´ í´ë˜ìŠ¤ëŠ” ì‹œìŠ¤í…œ ì •ë³´ë¥¼ ìˆ˜ì§‘(`CollectBasicSystemInfo`)í•˜ê³ , ì½˜ì†”ì— ë³´ê¸° ì¢‹ê²Œ ì¶œë ¥(`DisplaySystemInfo`)í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

```mermaid
classDiagram
    class SystemInfoCollector {
        - SYSTEM_INFO m_systemInfo
        + SystemInfoCollector()
        + void CollectBasicSystemInfo()
        + void DisplaySystemInfo() const
        + DWORD GetOptimalThreadCount() const
        + SIZE_T GetPageSize() const
        + DWORD GetProcessorCount() const
        + std::string GetProcessorArchitecture() const
    }
```


#### 1ï¸âƒ£ í—¤ë” íŒŒì¼ (SystemInfoCollector.h)
ì´ íŒŒì¼ì€ í´ë˜ìŠ¤ì˜ **ì¸í„°í˜ì´ìŠ¤ ì •ì˜**ë¥¼ í¬í•¨í•œë‹¤.

```cpp
#pragma once
#include <windows.h>
#include <iostream>
#include <string>
#include <iomanip>

class SystemInfoCollector {
private:
    SYSTEM_INFO m_systemInfo;   // Windows ì‹œìŠ¤í…œ ì •ë³´ êµ¬ì¡°ì²´
    
public:
    SystemInfoCollector();
    void CollectBasicSystemInfo();
    void DisplaySystemInfo() const;
    
    DWORD GetOptimalThreadCount() const;
    SIZE_T GetPageSize() const;
    DWORD GetProcessorCount() const;
    std::string GetProcessorArchitecture() const;
};
```

**í•µì‹¬ í¬ì¸íŠ¸**

* `SYSTEM_INFO`ëŠ” Windows APIì—ì„œ ì œê³µí•˜ëŠ” êµ¬ì¡°ì²´ë¡œ, CPU ë° ë©”ëª¨ë¦¬ ê´€ë ¨ ì •ë³´ë¥¼ ë‹´ëŠ”ë‹¤.
* `CollectBasicSystemInfo()`ëŠ” ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ê³ ,
  `DisplaySystemInfo()`ëŠ” ì´ë¥¼ ì‹œê°ì ìœ¼ë¡œ ì¶œë ¥í•œë‹¤.
* ë‚˜ë¨¸ì§€ `Get` í•¨ìˆ˜ë“¤ì€ ê²Œì„ ì„œë²„ ìµœì í™”ë¥¼ ìœ„í•´ ê°œë³„ í•­ëª©ì„ ì†ì‰½ê²Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë„ë¡ ì œê³µëœë‹¤.


#### 2ï¸âƒ£ ìƒì„±ì ë° ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘

```cpp
SystemInfoCollector::SystemInfoCollector() {
    ZeroMemory(&m_systemInfo, sizeof(SYSTEM_INFO));
}

void SystemInfoCollector::CollectBasicSystemInfo() {
    GetSystemInfo(&m_systemInfo);
}
```

**ì„¤ëª…**

* ìƒì„±ìì—ì„œëŠ” êµ¬ì¡°ì²´ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•œë‹¤.
* `GetSystemInfo()`ë¥¼ í˜¸ì¶œí•˜ë©´ ìš´ì˜ì²´ì œê°€ í˜„ì¬ ì‹œìŠ¤í…œì˜ ì •ë³´ë¥¼ ì±„ì›Œ ë„£ëŠ”ë‹¤.

ì¦‰, ì´ ì‹œì ì—ì„œ `m_systemInfo`ëŠ” CPU ìˆ˜, í˜ì´ì§€ í¬ê¸°, ë©”ëª¨ë¦¬ ì£¼ì†Œ ë“± ë‹¤ì–‘í•œ ì •ë³´ë¥¼ ë‹´ê²Œ ëœë‹¤.


#### 3ï¸âƒ£ ì‹œìŠ¤í…œ ì •ë³´ ì¶œë ¥

```cpp
void SystemInfoCollector::DisplaySystemInfo() const {
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                     ì‹œìŠ¤í…œ ì •ë³´ ë³´ê³ ì„œ                        â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    
    std::cout << "â•‘ í”„ë¡œì„¸ì„œ ì•„í‚¤í…ì²˜: " << std::setw(39) << std::left 
              << GetProcessorArchitecture() << " â•‘\n";
    
    std::cout << "â•‘ í”„ë¡œì„¸ì„œ ìˆ˜:       " << std::setw(39) << std::left 
              << m_systemInfo.dwNumberOfProcessors << " â•‘\n";
    
    std::cout << "â•‘ í˜ì´ì§€ í¬ê¸°:       " << std::setw(34) << std::left 
              << (m_systemInfo.dwPageSize / 1024) << " KB  â•‘\n";
    
    std::cout << "â•‘ ìµœì†Œ ì£¼ì†Œ:         0x" << std::setw(36) << std::left 
              << std::hex << (uintptr_t)m_systemInfo.lpMinimumApplicationAddress 
              << std::dec << " â•‘\n";
    
    std::cout << "â•‘ ìµœëŒ€ ì£¼ì†Œ:         0x" << std::setw(36) << std::left 
              << std::hex << (uintptr_t)m_systemInfo.lpMaximumApplicationAddress 
              << std::dec << " â•‘\n";
    
    std::cout << "â•‘ í™œì„± í”„ë¡œì„¸ì„œ ë§ˆìŠ¤í¬: 0x" << std::setw(34) << std::left 
              << std::hex << m_systemInfo.dwActiveProcessorMask << std::dec << " â•‘\n";
    
    std::cout << "â•‘ í• ë‹¹ ë‹¨ìœ„:         " << std::setw(34) << std::left 
              << (m_systemInfo.dwAllocationGranularity / 1024) << " KB  â•‘\n";
    
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
}
```

**ì„¤ëª…**

* ì½˜ì†”ì— ê¹”ë”í•œ ë°•ìŠ¤ í˜•íƒœì˜ ë³´ê³ ì„œë¥¼ ì¶œë ¥í•œë‹¤.
* `std::setw`ì™€ `std::left`ë¥¼ ì‚¬ìš©í•´ ì—´ ì •ë ¬ì„ ë§ì¶˜ë‹¤.
* `std::hex` / `std::dec`ë¥¼ ì´ìš©í•´ 16ì§„ìˆ˜ ì£¼ì†Œë¥¼ í‘œì‹œí•œë‹¤.
* ì¶œë ¥ ì˜ˆì‹œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     ì‹œìŠ¤í…œ ì •ë³´ ë³´ê³ ì„œ                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ í”„ë¡œì„¸ì„œ ì•„í‚¤í…ì²˜: x64 (AMD64)                              â•‘
â•‘ í”„ë¡œì„¸ì„œ ìˆ˜:       8                                        â•‘
â•‘ í˜ì´ì§€ í¬ê¸°:       4 KB                                     â•‘
â•‘ ìµœì†Œ ì£¼ì†Œ:         0x0000000000010000                       â•‘
â•‘ ìµœëŒ€ ì£¼ì†Œ:         0x00007FFFFFFEFFFF                       â•‘
â•‘ í™œì„± í”„ë¡œì„¸ì„œ ë§ˆìŠ¤í¬: 0xFF                                 â•‘
â•‘ í• ë‹¹ ë‹¨ìœ„:         64 KB                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```


#### 4ï¸âƒ£ ê²Œì„ ì„œë²„ ìµœì í™” ê´€ë ¨ í•¨ìˆ˜

```cpp
DWORD SystemInfoCollector::GetOptimalThreadCount() const {
    // ê²Œì„ ì„œë²„ì—ì„œëŠ” ë³´í†µ CPU ì½”ì–´ ìˆ˜ì˜ 2ë°° ì •ë„ì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©
    return m_systemInfo.dwNumberOfProcessors * 2;
}

SIZE_T SystemInfoCollector::GetPageSize() const {
    return m_systemInfo.dwPageSize;
}

DWORD SystemInfoCollector::GetProcessorCount() const {
    return m_systemInfo.dwNumberOfProcessors;
}
```

**ì„¤ëª…**

* `GetOptimalThreadCount()`ëŠ” CPU ì½”ì–´ ìˆ˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìŠ¤ë ˆë“œ ìˆ˜ë¥¼ ê³„ì‚°í•œë‹¤.
  â†’ ë³´í†µ ê²Œì„ ì„œë²„ì—ì„œëŠ” **ì½”ì–´ ìˆ˜ Ã— 2** ì •ë„ê°€ íš¨ìœ¨ì ì´ë‹¤.
* `GetPageSize()`ëŠ” ë©”ëª¨ë¦¬ í˜ì´ì§€ ë‹¨ìœ„ë¥¼ ë°˜í™˜í•˜ì—¬ ë©”ëª¨ë¦¬ í’€ ê´€ë¦¬ì— í™œìš©í•  ìˆ˜ ìˆë‹¤.


#### 5ï¸âƒ£ CPU ì•„í‚¤í…ì²˜ íŒë³„

```cpp
std::string SystemInfoCollector::GetProcessorArchitecture() const {
    switch (m_systemInfo.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_AMD64:
            return "x64 (AMD64)";
        case PROCESSOR_ARCHITECTURE_ARM:
            return "ARM";
        case PROCESSOR_ARCHITECTURE_ARM64:
            return "ARM64";
        case PROCESSOR_ARCHITECTURE_IA64:
            return "Intel Itanium (IA64)";
        case PROCESSOR_ARCHITECTURE_INTEL:
            return "x86 (Intel)";
        default:
            return "Unknown";
    }
}
```

**ì„¤ëª…**

* ì‹œìŠ¤í…œì˜ CPU ì•„í‚¤í…ì²˜ë¥¼ ë¬¸ìì—´ í˜•íƒœë¡œ ë°˜í™˜í•œë‹¤.
* ì´ë¥¼ í†µí•´ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ ì¤‘ì¸ í™˜ê²½ì„ êµ¬ì²´ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.


#### ğŸ§  ì •ë¦¬

| í•­ëª©                            | ì˜ë¯¸                | í™œìš© ì˜ˆì‹œ            |
| ----------------------------- | ----------------- | ---------------- |
| `dwNumberOfProcessors`        | CPU ì½”ì–´ ìˆ˜          | ìŠ¤ë ˆë“œ í’€ í¬ê¸° ì„¤ì •      |
| `dwPageSize`                  | ë©”ëª¨ë¦¬ í˜ì´ì§€ í¬ê¸°        | ë©”ëª¨ë¦¬ í’€ ìµœì í™”        |
| `lpMinimumApplicationAddress` | í”„ë¡œì„¸ìŠ¤ ì ‘ê·¼ ê°€ëŠ¥í•œ ìµœì†Œ ì£¼ì†Œ | ë©”ëª¨ë¦¬ ë§¤í•‘ í™•ì¸        |
| `lpMaximumApplicationAddress` | í”„ë¡œì„¸ìŠ¤ ì ‘ê·¼ ê°€ëŠ¥í•œ ìµœëŒ€ ì£¼ì†Œ | ê°€ìƒ ë©”ëª¨ë¦¬ í•œê³„ í™•ì¸     |
| `dwAllocationGranularity`     | ë©”ëª¨ë¦¬ í• ë‹¹ ë‹¨ìœ„         | íŒŒì¼ ë§¤í•‘ ì‹œ ë¸”ë¡ í¬ê¸° ì¡°ì • |
  
  
`GetSystemInfo()` í•¨ìˆ˜ëŠ” Windows ê¸°ë°˜ì˜ ê²Œì„ ì„œë²„ë‚˜ ì‹œìŠ¤í…œ ê´€ë¦¬ í”„ë¡œê·¸ë¨ì—ì„œ ë§¤ìš° ìœ ìš©í•œ APIë‹¤.
ì´ë¥¼ í†µí•´ **CPU ì•„í‚¤í…ì²˜, ì½”ì–´ ìˆ˜, í˜ì´ì§€ í¬ê¸°** ë“± í•˜ë“œì›¨ì–´ íŠ¹ì„±ì„ íŒŒì•…í•  ìˆ˜ ìˆìœ¼ë©°,
ì´ ì •ë³´ë¥¼ í™œìš©í•´ **ìŠ¤ë ˆë“œ í’€ í¬ê¸° ì¡°ì •, ë©”ëª¨ë¦¬ í’€ ê´€ë¦¬, ìµœì í™” ì •ì±… ì„¤ê³„** ë“±ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

ì¦‰, ì´ í´ë˜ìŠ¤ëŠ” ì„œë²„ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ëŠ” í™˜ê²½ì„ ìŠ¤ìŠ¤ë¡œ ë¶„ì„í•˜ì—¬
ìµœì ì˜ ì„±ëŠ¥ì„ ë‚¼ ìˆ˜ ìˆë„ë¡ ë•ëŠ” ê¸°ì´ˆì ì¸ ì‹œìŠ¤í…œ ì§„ë‹¨ ë„êµ¬ë¼ê³  í•  ìˆ˜ ìˆë‹¤.

  
### 8.1.3 ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
ê²Œì„ ì„œë²„ì—ì„œëŠ” ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì§€ì†ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•´ì•¼ í•œë‹¤:

```cpp
// MemoryInfoCollector.h
#pragma once
#include <windows.h>
#include <psapi.h>
#include <iostream>
#include <iomanip>

#pragma comment(lib, "psapi.lib")

class MemoryInfoCollector {
private:
    MEMORYSTATUSEX m_memoryStatus;
    PROCESS_MEMORY_COUNTERS_EX m_processMemory;
    
public:
    MemoryInfoCollector();
    void CollectMemoryInfo();
    void DisplayMemoryInfo() const;
    
    // ê²Œì„ ì„œë²„ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ìœ„í•œ ì •ë³´
    double GetMemoryUsagePercent() const;
    SIZE_T GetAvailablePhysicalMemory() const;
    SIZE_T GetProcessWorkingSet() const;
    bool IsMemoryPressureHigh() const;
};
```

```cpp
// MemoryInfoCollector.cpp
#include "MemoryInfoCollector.h"

MemoryInfoCollector::MemoryInfoCollector() {
    m_memoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
    ZeroMemory(&m_processMemory, sizeof(PROCESS_MEMORY_COUNTERS_EX));
}

void MemoryInfoCollector::CollectMemoryInfo() {
    // ì „ì²´ ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ ì •ë³´
    GlobalMemoryStatusEx(&m_memoryStatus);
    
    // í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ì •ë³´
    HANDLE hProcess = GetCurrentProcess();
    GetProcessMemoryInfo(hProcess, 
                        (PROCESS_MEMORY_COUNTERS*)&m_processMemory, 
                        sizeof(PROCESS_MEMORY_COUNTERS_EX));
}

void MemoryInfoCollector::DisplayMemoryInfo() const {
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                     ë©”ëª¨ë¦¬ ì •ë³´ ë³´ê³ ì„œ                        â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    
    // ë¬¼ë¦¬ ë©”ëª¨ë¦¬ ì •ë³´
    std::cout << "â•‘ ì „ì²´ ë¬¼ë¦¬ ë©”ëª¨ë¦¬:   " << std::setw(30) << std::left 
              << (m_memoryStatus.ullTotalPhys / (1024 * 1024)) << " MB      â•‘\n";
    
    std::cout << "â•‘ ì‚¬ìš© ê°€ëŠ¥ ë¬¼ë¦¬:     " << std::setw(30) << std::left 
              << (m_memoryStatus.ullAvailPhys / (1024 * 1024)) << " MB      â•‘\n";
    
    std::cout << "â•‘ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ :      " << std::setw(30) << std::left 
              << m_memoryStatus.dwMemoryLoad << " %       â•‘\n";
    
    // ê°€ìƒ ë©”ëª¨ë¦¬ ì •ë³´  
    std::cout << "â•‘ ì „ì²´ ê°€ìƒ ë©”ëª¨ë¦¬:   " << std::setw(30) << std::left 
              << (m_memoryStatus.ullTotalVirtual / (1024 * 1024)) << " MB      â•‘\n";
    
    std::cout << "â•‘ ì‚¬ìš© ê°€ëŠ¥ ê°€ìƒ:     " << std::setw(30) << std::left 
              << (m_memoryStatus.ullAvailVirtual / (1024 * 1024)) << " MB      â•‘\n";
    
    // í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ ì •ë³´
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    std::cout << "â•‘ í”„ë¡œì„¸ìŠ¤ ì›Œí‚¹ì…‹:    " << std::setw(30) << std::left 
              << (m_processMemory.WorkingSetSize / (1024 * 1024)) << " MB      â•‘\n";
    
    std::cout << "â•‘ í”„ë¡œì„¸ìŠ¤ í”¼í¬ ì›Œí‚¹ì…‹: " << std::setw(28) << std::left 
              << (m_processMemory.PeakWorkingSetSize / (1024 * 1024)) << " MB      â•‘\n";
    
    std::cout << "â•‘ í˜ì´ì§€íŒŒì¼ ì‚¬ìš©ëŸ‰:  " << std::setw(30) << std::left 
              << (m_processMemory.PagefileUsage / (1024 * 1024)) << " MB      â•‘\n";
    
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    
    // ë©”ëª¨ë¦¬ ì••ë°• ìƒí™© í‘œì‹œ
    if (IsMemoryPressureHigh()) {
        std::cout << "\nâš ï¸  ê²½ê³ : ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤! (>" << 80 << "%)\n";
    }
}

double MemoryInfoCollector::GetMemoryUsagePercent() const {
    return static_cast<double>(m_memoryStatus.dwMemoryLoad);
}

SIZE_T MemoryInfoCollector::GetAvailablePhysicalMemory() const {
    return m_memoryStatus.ullAvailPhys;
}

SIZE_T MemoryInfoCollector::GetProcessWorkingSet() const {
    return m_processMemory.WorkingSetSize;
}

bool MemoryInfoCollector::IsMemoryPressureHigh() const {
    return m_memoryStatus.dwMemoryLoad > 80;
}
```
   
ê²Œì„ ì„œë²„ë‚˜ ëŒ€ê·œëª¨ ì˜¨ë¼ì¸ ì‹œìŠ¤í…œì—ì„œëŠ” **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì§€ì†ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§**í•´ì•¼ í•œë‹¤.
ë©”ëª¨ë¦¬ëŠ” í•œì •ëœ ìì›ì´ê¸° ë•Œë¬¸ì—, ê³¼ë„í•œ ì‚¬ìš©ì´ë‚˜ ëˆ„ìˆ˜(memory leak)ê°€ ë°œìƒí•˜ë©´ ì„œë²„ì˜ ì•ˆì •ì„±ì´ ê¸‰ê²©íˆ ë–¨ì–´ì§„ë‹¤.
ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ë¿ë§Œ ì•„ë‹ˆë¼ **í˜„ì¬ í”„ë¡œì„¸ìŠ¤ê°€ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ëŸ‰**ê¹Œì§€ ì •ê¸°ì ìœ¼ë¡œ ì ê²€í•´ì•¼ í•œë‹¤.

ì´ë²ˆ ì˜ˆì œëŠ” Windows APIë¥¼ ì´ìš©í•´ ì´ëŸ¬í•œ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ê³ , ë³´ê¸° ì¢‹ì€ í˜•íƒœë¡œ ì¶œë ¥í•˜ëŠ” `MemoryInfoCollector` í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•œ ì½”ë“œì´ë‹¤.

ì´ í´ë˜ìŠ¤ëŠ” ì‹œìŠ¤í…œ ì „ì²´ì™€ í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ì •ë³´ë¥¼ ëª¨ë‘ ìˆ˜ì§‘í•œë‹¤.
ì•„ë˜ëŠ” í´ë˜ìŠ¤ êµ¬ì¡°ë¥¼ ë‚˜íƒ€ë‚¸ ë‹¤ì´ì–´ê·¸ë¨ì´ë‹¤.

```mermaid
classDiagram
    class MemoryInfoCollector {
        - MEMORYSTATUSEX m_memoryStatus
        - PROCESS_MEMORY_COUNTERS_EX m_processMemory
        + MemoryInfoCollector()
        + void CollectMemoryInfo()
        + void DisplayMemoryInfo() const
        + double GetMemoryUsagePercent() const
        + SIZE_T GetAvailablePhysicalMemory() const
        + SIZE_T GetProcessWorkingSet() const
        + bool IsMemoryPressureHigh() const
    }
```

* `MEMORYSTATUSEX`: ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ ë‹´ëŠ” êµ¬ì¡°ì²´ì´ë‹¤.
* `PROCESS_MEMORY_COUNTERS_EX`: í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤(ì„œë²„ í”„ë¡œê·¸ë¨)ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ë‹´ëŠ”ë‹¤.


#### 1ï¸âƒ£ í—¤ë” íŒŒì¼ êµ¬ì¡° (MemoryInfoCollector.h)

```cpp
#pragma once
#include <windows.h>
#include <psapi.h>
#include <iostream>
#include <iomanip>

#pragma comment(lib, "psapi.lib")

class MemoryInfoCollector {
private:
    MEMORYSTATUSEX m_memoryStatus;
    PROCESS_MEMORY_COUNTERS_EX m_processMemory;
    
public:
    MemoryInfoCollector();
    void CollectMemoryInfo();
    void DisplayMemoryInfo() const;
    
    double GetMemoryUsagePercent() const;
    SIZE_T GetAvailablePhysicalMemory() const;
    SIZE_T GetProcessWorkingSet() const;
    bool IsMemoryPressureHigh() const;
};
```

**ì„¤ëª…**

* `psapi.h` í—¤ë”ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì–»ê¸° ìœ„í•œ í•¨ìˆ˜(`GetProcessMemoryInfo`)ë¥¼ ì œê³µí•œë‹¤.
* `#pragma comment(lib, "psapi.lib")`ëŠ” í•´ë‹¹ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§ì»¤ì— ìë™ìœ¼ë¡œ ì¶”ê°€í•˜ë„ë¡ í•œë‹¤.
* ì´ í´ë˜ìŠ¤ëŠ” ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬(`m_memoryStatus`)ì™€ í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬(`m_processMemory`)ë¥¼ í•¨ê»˜ ê´€ë¦¬í•œë‹¤.


#### 2ï¸âƒ£ ìƒì„±ìì™€ ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘

```cpp
MemoryInfoCollector::MemoryInfoCollector() {
    m_memoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
    ZeroMemory(&m_processMemory, sizeof(PROCESS_MEMORY_COUNTERS_EX));
}

void MemoryInfoCollector::CollectMemoryInfo() {
    GlobalMemoryStatusEx(&m_memoryStatus);
    
    HANDLE hProcess = GetCurrentProcess();
    GetProcessMemoryInfo(hProcess, 
                        (PROCESS_MEMORY_COUNTERS*)&m_processMemory, 
                        sizeof(PROCESS_MEMORY_COUNTERS_EX));
}
```

**ì„¤ëª…**

* `GlobalMemoryStatusEx()`ëŠ” ì‹œìŠ¤í…œ ì „ì²´ì˜ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ ê°€ì ¸ì˜¨ë‹¤.
  (ì˜ˆ: ì „ì²´ ë¬¼ë¦¬ ë©”ëª¨ë¦¬, ì‚¬ìš© ê°€ëŠ¥ ë©”ëª¨ë¦¬, ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ë“±)
* `GetProcessMemoryInfo()`ëŠ” í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œê·¸ë¨ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš© í˜„í™©ì„ ê°€ì ¸ì˜¨ë‹¤.
* ì´ ë‘ í•¨ìˆ˜ë¥¼ í†µí•´ **â€œì‹œìŠ¤í…œ ìˆ˜ì¤€â€ê³¼ â€œí”„ë¡œì„¸ìŠ¤ ìˆ˜ì¤€â€ì˜ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ ëª¨ë‘ í™•ì¸**í•  ìˆ˜ ìˆë‹¤.


#### 3ï¸âƒ£ ë©”ëª¨ë¦¬ ì •ë³´ ì¶œë ¥

```cpp
void MemoryInfoCollector::DisplayMemoryInfo() const {
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                     ë©”ëª¨ë¦¬ ì •ë³´ ë³´ê³ ì„œ                        â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    
    std::cout << "â•‘ ì „ì²´ ë¬¼ë¦¬ ë©”ëª¨ë¦¬:   " << std::setw(30) << std::left 
              << (m_memoryStatus.ullTotalPhys / (1024 * 1024)) << " MB      â•‘\n";
    
    std::cout << "â•‘ ì‚¬ìš© ê°€ëŠ¥ ë¬¼ë¦¬:     " << std::setw(30) << std::left 
              << (m_memoryStatus.ullAvailPhys / (1024 * 1024)) << " MB      â•‘\n";
    
    std::cout << "â•‘ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ :      " << std::setw(30) << std::left 
              << m_memoryStatus.dwMemoryLoad << " %       â•‘\n";
```

**ì„¤ëª… (1/2)**

* ë¬¼ë¦¬ ë©”ëª¨ë¦¬ ì •ë³´(ì „ì²´, ë‚¨ì€ ì–‘, ì‚¬ìš©ë¥ )ë¥¼ í‘œì‹œí•œë‹¤.
* `ullTotalPhys`ì™€ `ullAvailPhys`ëŠ” ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ì œê³µë˜ë¯€ë¡œ MBë¡œ ë³€í™˜í•œë‹¤.
* `dwMemoryLoad`ëŠ” ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ (%)ì´ë‹¤.

**ì„¤ëª… (2/2)**
ê°€ìƒ ë©”ëª¨ë¦¬ ë° í”„ë¡œì„¸ìŠ¤ ì •ë³´ë„ ì´ì–´ì„œ ì¶œë ¥í•œë‹¤.

```cpp
    std::cout << "â•‘ ì „ì²´ ê°€ìƒ ë©”ëª¨ë¦¬:   " << std::setw(30) << std::left 
              << (m_memoryStatus.ullTotalVirtual / (1024 * 1024)) << " MB      â•‘\n";
    std::cout << "â•‘ ì‚¬ìš© ê°€ëŠ¥ ê°€ìƒ:     " << std::setw(30) << std::left 
              << (m_memoryStatus.ullAvailVirtual / (1024 * 1024)) << " MB      â•‘\n";

    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    std::cout << "â•‘ í”„ë¡œì„¸ìŠ¤ ì›Œí‚¹ì…‹:    " << std::setw(30) << std::left 
              << (m_processMemory.WorkingSetSize / (1024 * 1024)) << " MB      â•‘\n";
    std::cout << "â•‘ í”„ë¡œì„¸ìŠ¤ í”¼í¬ ì›Œí‚¹ì…‹: " << std::setw(28) << std::left 
              << (m_processMemory.PeakWorkingSetSize / (1024 * 1024)) << " MB      â•‘\n";
    std::cout << "â•‘ í˜ì´ì§€íŒŒì¼ ì‚¬ìš©ëŸ‰:  " << std::setw(30) << std::left 
              << (m_processMemory.PagefileUsage / (1024 * 1024)) << " MB      â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    
    if (IsMemoryPressureHigh()) {
        std::cout << "\nâš ï¸  ê²½ê³ : ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤! (>" << 80 << "%)\n";
    }
}
```

**ì¶œë ¥ ì˜ˆì‹œ**

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     ë©”ëª¨ë¦¬ ì •ë³´ ë³´ê³ ì„œ                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ì „ì²´ ë¬¼ë¦¬ ë©”ëª¨ë¦¬:   16384 MB                                 â•‘
â•‘ ì‚¬ìš© ê°€ëŠ¥ ë¬¼ë¦¬:     8250 MB                                  â•‘
â•‘ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ :      49 %                                     â•‘
â•‘ ì „ì²´ ê°€ìƒ ë©”ëª¨ë¦¬:   134217728 MB                             â•‘
â•‘ ì‚¬ìš© ê°€ëŠ¥ ê°€ìƒ:     134216320 MB                             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ í”„ë¡œì„¸ìŠ¤ ì›Œí‚¹ì…‹:    250 MB                                   â•‘
â•‘ í”„ë¡œì„¸ìŠ¤ í”¼í¬ ì›Œí‚¹ì…‹: 310 MB                                 â•‘
â•‘ í˜ì´ì§€íŒŒì¼ ì‚¬ìš©ëŸ‰:  400 MB                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```


#### 4ï¸âƒ£ ë©”ëª¨ë¦¬ ê´€ë ¨ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤

```cpp
double MemoryInfoCollector::GetMemoryUsagePercent() const {
    return static_cast<double>(m_memoryStatus.dwMemoryLoad);
}

SIZE_T MemoryInfoCollector::GetAvailablePhysicalMemory() const {
    return m_memoryStatus.ullAvailPhys;
}

SIZE_T MemoryInfoCollector::GetProcessWorkingSet() const {
    return m_processMemory.WorkingSetSize;
}

bool MemoryInfoCollector::IsMemoryPressureHigh() const {
    return m_memoryStatus.dwMemoryLoad > 80;
}
```

**ì„¤ëª…**

* `GetMemoryUsagePercent()` : ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì„ ë°˜í™˜í•œë‹¤.
* `GetAvailablePhysicalMemory()` : í˜„ì¬ ì‚¬ìš© ê°€ëŠ¥í•œ ë¬¼ë¦¬ ë©”ëª¨ë¦¬ì˜ ë°”ì´íŠ¸ ìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤.
* `GetProcessWorkingSet()` : í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ ì›Œí‚¹ì…‹(ì‹¤ì œ ë©”ëª¨ë¦¬ ìƒì£¼ëŸ‰)ì„ ë°˜í™˜í•œë‹¤.
* `IsMemoryPressureHigh()` : ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ 80%ë¥¼ ë„˜ëŠ”ì§€ ê²€ì‚¬í•´, ê³¼ë„í•œ ë¶€í•˜ ìƒíƒœì¸ì§€ íŒë‹¨í•œë‹¤.


#### ğŸ§  ì „ì²´ ë™ì‘ íë¦„ ìš”ì•½
ì•„ë˜ ASCII ë‹¤ì´ì–´ê·¸ë¨ì€ `MemoryInfoCollector`ì˜ ë™ì‘ ê³¼ì •ì„ ë‚˜íƒ€ë‚¸ ê²ƒì´ë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MemoryInfoCollector ìƒì„±ì   â”‚
â”‚ (êµ¬ì¡°ì²´ ì´ˆê¸°í™”)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CollectMemoryInfo() í˜¸ì¶œ     â”‚
â”‚ â”œâ”€ GlobalMemoryStatusEx()   â”‚
â”‚ â””â”€ GetProcessMemoryInfo()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DisplayMemoryInfo() ì¶œë ¥     â”‚
â”‚ â”œâ”€ ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ ì •ë³´ í‘œì‹œ     â”‚
â”‚ â”œâ”€ í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ ì •ë³´ í‘œì‹œ   â”‚
â”‚ â””â”€ ê²½ê³  ë©”ì‹œì§€ ì¶œë ¥ (ì¡°ê±´ë¶€)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


#### ğŸ¯ ê²°ë¡ 
`MemoryInfoCollector` í´ë˜ìŠ¤ëŠ” ê²Œì„ ì„œë²„ì˜ **ì•ˆì •ì„±ê³¼ íš¨ìœ¨ì„±ì„ ìœ ì§€í•˜ê¸° ìœ„í•œ í•µì‹¬ ë„êµ¬**ì´ë‹¤.
ì´ í´ë˜ìŠ¤ë¥¼ í†µí•´ ê°œë°œìëŠ”

* ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì„ íŒŒì•…í•˜ê³ ,
* ì„œë²„ í”„ë¡œì„¸ìŠ¤ì˜ ì‹¤ì œ ë©”ëª¨ë¦¬ ì ìœ ëŸ‰ì„ ëª¨ë‹ˆí„°ë§í•˜ë©°,
* ê³¼ë„í•œ ë©”ëª¨ë¦¬ ì‚¬ìš© ì‹œ ì¦‰ì‹œ ê²½ê³ ë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆë‹¤.

ê²°êµ­ ì´ ì½”ë“œëŠ” ë‹¨ìˆœí•œ ì •ë³´ ìˆ˜ì§‘ê¸°ê°€ ì•„ë‹ˆë¼,
**ê²Œì„ ì„œë²„ì˜ ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì§„ë‹¨í•˜ê³  ì¥ì• ë¥¼ ì˜ˆë°©í•˜ëŠ” ì•ˆì „ ì¥ì¹˜**ë¼ê³  í•  ìˆ˜ ìˆë‹¤.


</br>  
  

## 8.2 WMIë¥¼ ì´ìš©í•œ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§

### 8.2.1 WMI (Windows Management Instrumentation) ì†Œê°œ
WMIëŠ” Windows ì‹œìŠ¤í…œì˜ ê´€ë¦¬ ì •ë³´ì— ì•¡ì„¸ìŠ¤í•  ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ì¸í„°í˜ì´ìŠ¤ì´ë‹¤:

```
    WMI ì•„í‚¤í…ì²˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   WMI Client    â”‚ â† ìš°ë¦¬ì˜ ê²Œì„ ì„œë²„ ì• í”Œë¦¬ì¼€ì´ì…˜
â”‚  (Game Server)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ COM Interface
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   WMI Service   â”‚ â† Windows Management Service  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WMI Providers  â”‚ â† ì‹œìŠ¤í…œ ì •ë³´ ì œê³µìë“¤
â”‚ - Registry      â”‚
â”‚ - File System   â”‚  
â”‚ - Performance   â”‚
â”‚ - Network       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.2.2 WMIë¥¼ ì´ìš©í•œ CPU ì •ë³´ ìˆ˜ì§‘

```cpp
// WMISystemMonitor.h
#pragma once
#include <windows.h>
#include <comdef.h>
#include <Wbemidl.h>
#include <iostream>
#include <string>
#include <vector>

#pragma comment(lib, "wbemuuid.lib")

class WMISystemMonitor {
private:
    IWbemLocator* m_pLoc;
    IWbemServices* m_pSvc;
    bool m_bInitialized;
    
public:
    WMISystemMonitor();
    ~WMISystemMonitor();
    
    bool Initialize();
    void Cleanup();
    
    // CPU ì •ë³´ ìˆ˜ì§‘
    void GetCPUInfo();
    void GetCPUUsage();
    
    // ì‹œìŠ¤í…œ í”„ë¡œì„¸ìŠ¤ ì •ë³´
    void GetRunningProcesses();
    
    // ë„¤íŠ¸ì›Œí¬ ì •ë³´
    void GetNetworkAdapters();
    
private:
    std::string BSTRToString(BSTR bstr);
    void DisplayCPUInfo(IWbemClassObject* pclsObj);
};
```

```cpp
// WMISystemMonitor.cpp
#include "WMISystemMonitor.h"

WMISystemMonitor::WMISystemMonitor() 
    : m_pLoc(nullptr), m_pSvc(nullptr), m_bInitialized(false) {
}

WMISystemMonitor::~WMISystemMonitor() {
    Cleanup();
}

bool WMISystemMonitor::Initialize() {
    HRESULT hres;
    
    // COM ì´ˆê¸°í™”
    hres = CoInitializeEx(0, COINIT_MULTITHREADED);
    if (FAILED(hres)) {
        std::cout << "COM ì´ˆê¸°í™” ì‹¤íŒ¨: 0x" << std::hex << hres << std::endl;
        return false;
    }
    
    // COM ë³´ì•ˆ ì´ˆê¸°í™”
    hres = CoInitializeSecurity(
        NULL,
        -1,                          // COM authentication
        NULL,                        // Authentication services
        NULL,                        // Reserved
        RPC_C_AUTHN_LEVEL_NONE,      // Default authentication 
        RPC_C_IMP_LEVEL_IMPERSONATE, // Default Impersonation  
        NULL,                        // Authentication info
        EOAC_NONE,                   // Additional capabilities 
        NULL                         // Reserved
    );
    
    if (FAILED(hres)) {
        std::cout << "COM ë³´ì•ˆ ì´ˆê¸°í™” ì‹¤íŒ¨: 0x" << std::hex << hres << std::endl;
        CoUninitialize();
        return false;
    }
    
    // WMI Locator ìƒì„±
    hres = CoCreateInstance(
        CLSID_WbemLocator,
        0,
        CLSCTX_INPROC_SERVER,
        IID_IWbemLocator, 
        (LPVOID*)&m_pLoc
    );
    
    if (FAILED(hres)) {
        std::cout << "WMI Locator ìƒì„± ì‹¤íŒ¨: 0x" << std::hex << hres << std::endl;
        CoUninitialize();
        return false;
    }
    
    // WMI ì„œë¹„ìŠ¤ ì—°ê²°
    hres = m_pLoc->ConnectServer(
        _bstr_t(L"ROOT\\CIMV2"), // WMI namespace
        NULL,                    // User name
        NULL,                    // User password
        0,                       // Locale
        NULL,                    // Security flags
        0,                       // Authority
        0,                       // Context object 
        &m_pSvc                  // pointer to IWbemServices proxy
    );
    
    if (FAILED(hres)) {
        std::cout << "WMI ì„œë¹„ìŠ¤ ì—°ê²° ì‹¤íŒ¨: 0x" << std::hex << hres << std::endl;
        m_pLoc->Release();
        CoUninitialize();
        return false;
    }
    
    // í”„ë¡ì‹œ ë³´ì•ˆ ì„¤ì •
    hres = CoSetProxyBlanket(
        m_pSvc,                        // Indicates the proxy to set
        RPC_C_AUTHN_WINNT,            // RPC_C_AUTHN_xxx
        RPC_C_AUTHZ_NONE,             // RPC_C_AUTHZ_xxx
        NULL,                         // Server principal name 
        RPC_C_AUTHN_LEVEL_CALL,       // RPC_C_AUTHN_LEVEL_xxx 
        RPC_C_IMP_LEVEL_IMPERSONATE,  // RPC_C_IMP_LEVEL_xxx
        NULL,                         // client identity
        EOAC_NONE                     // proxy capabilities 
    );
    
    if (FAILED(hres)) {
        std::cout << "í”„ë¡ì‹œ ë³´ì•ˆ ì„¤ì • ì‹¤íŒ¨: 0x" << std::hex << hres << std::endl;
        m_pSvc->Release();
        m_pLoc->Release();
        CoUninitialize();
        return false;
    }
    
    m_bInitialized = true;
    return true;
}

void WMISystemMonitor::GetCPUInfo() {
    if (!m_bInitialized) {
        std::cout << "WMIê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n";
        return;
    }
    
    HRESULT hres;
    IEnumWbemClassObject* pEnumerator = NULL;
    
    // CPU ì •ë³´ ì¿¼ë¦¬
    hres = m_pSvc->ExecQuery(
        bstr_t("WQL"),
        bstr_t("SELECT * FROM Win32_Processor"),
        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
        NULL,
        &pEnumerator
    );
    
    if (FAILED(hres)) {
        std::cout << "CPU ì •ë³´ ì¿¼ë¦¬ ì‹¤íŒ¨: 0x" << std::hex << hres << std::endl;
        return;
    }
    
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                      CPU ì •ë³´ (WMI)                         â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    
    IWbemClassObject *pclsObj = NULL;
    ULONG uReturn = 0;
    
    while (pEnumerator) {
        HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
        
        if (0 == uReturn) {
            break;
        }
        
        DisplayCPUInfo(pclsObj);
        pclsObj->Release();
    }
    
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    
    pEnumerator->Release();
}

void WMISystemMonitor::DisplayCPUInfo(IWbemClassObject* pclsObj) {
    VARIANT vtProp;
    
    // CPU ì´ë¦„
    HRESULT hr = pclsObj->Get(L"Name", 0, &vtProp, 0, 0);
    if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
        std::cout << "â•‘ CPU ì´ë¦„: " << BSTRToString(vtProp.bstrVal) << std::endl;
    }
    VariantClear(&vtProp);
    
    // ì œì¡°ì‚¬
    hr = pclsObj->Get(L"Manufacturer", 0, &vtProp, 0, 0);
    if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
        std::cout << "â•‘ ì œì¡°ì‚¬: " << BSTRToString(vtProp.bstrVal) << std::endl;
    }
    VariantClear(&vtProp);
    
    // ì½”ì–´ ìˆ˜
    hr = pclsObj->Get(L"NumberOfCores", 0, &vtProp, 0, 0);
    if (SUCCEEDED(hr)) {
        std::cout << "â•‘ ì½”ì–´ ìˆ˜: " << vtProp.uintVal << std::endl;
    }
    VariantClear(&vtProp);
    
    // ë…¼ë¦¬ í”„ë¡œì„¸ì„œ ìˆ˜
    hr = pclsObj->Get(L"NumberOfLogicalProcessors", 0, &vtProp, 0, 0);
    if (SUCCEEDED(hr)) {
        std::cout << "â•‘ ë…¼ë¦¬ í”„ë¡œì„¸ì„œ ìˆ˜: " << vtProp.uintVal << std::endl;
    }
    VariantClear(&vtProp);
    
    // ìµœëŒ€ í´ëŸ­ ì†ë„
    hr = pclsObj->Get(L"MaxClockSpeed", 0, &vtProp, 0, 0);
    if (SUCCEEDED(hr)) {
        std::cout << "â•‘ ìµœëŒ€ í´ëŸ­ ì†ë„: " << vtProp.uintVal << " MHz" << std::endl;
    }
    VariantClear(&vtProp);
    
    // L3 ìºì‹œ í¬ê¸°
    hr = pclsObj->Get(L"L3CacheSize", 0, &vtProp, 0, 0);
    if (SUCCEEDED(hr)) {
        std::cout << "â•‘ L3 ìºì‹œ: " << vtProp.uintVal << " KB" << std::endl;
    }
    VariantClear(&vtProp);
}

std::string WMISystemMonitor::BSTRToString(BSTR bstr) {
    if (!bstr) return "";
    
    int len = WideCharToMultiByte(CP_UTF8, 0, bstr, -1, nullptr, 0, nullptr, nullptr);
    std::string result(len, 0);
    WideCharToMultiByte(CP_UTF8, 0, bstr, -1, &result[0], len, nullptr, nullptr);
    result.resize(len - 1); // null terminator ì œê±°
    return result;
}

void WMISystemMonitor::Cleanup() {
    if (m_pSvc) {
        m_pSvc->Release();
        m_pSvc = nullptr;
    }
    
    if (m_pLoc) {
        m_pLoc->Release();
        m_pLoc = nullptr;
    }
    
    if (m_bInitialized) {
        CoUninitialize();
        m_bInitialized = false;
    }
}
```
    
</br>  
  
## 8.3 ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘

### 8.3.1 ë„¤íŠ¸ì›Œí¬ ëª¨ë‹ˆí„°ë§ì˜ ì¤‘ìš”ì„±
ê²Œì„ ì„œë²„ì—ì„œ ë„¤íŠ¸ì›Œí¬ ìƒíƒœëŠ” ë§¤ìš° ì¤‘ìš”í•˜ë‹¤:

```
    ë„¤íŠ¸ì›Œí¬ ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ëŒ€ì—­í­ ì‚¬ìš©ëŸ‰   â”‚    â”‚   ì—°ê²° ìƒíƒœ     â”‚    â”‚  íŒ¨í‚· ì†ì‹¤ë¥     â”‚
â”‚ - ì†¡ì‹ /ìˆ˜ì‹      â”‚    â”‚ - í™œì„± ì—°ê²°     â”‚    â”‚ - ì—ëŸ¬ìœ¨        â”‚
â”‚ - í”¼í¬ ì‹œê°„ëŒ€   â”‚    â”‚ - ëŒ€ê¸° ì—°ê²°     â”‚    â”‚ - ì¬ì „ì†¡ë¥       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“                      â†“                      â†“
  ì„œë²„ ìš©ëŸ‰ ê³„íš        ì—°ê²° í’€ ê´€ë¦¬           ë„¤íŠ¸ì›Œí¬ ìµœì í™”
```

### 8.3.2 IP Helper APIë¥¼ ì´ìš©í•œ ë„¤íŠ¸ì›Œí¬ ì •ë³´ ìˆ˜ì§‘

```cpp
// NetworkInfoCollector.h
#pragma once
#include <windows.h>
#include <iphlpapi.h>
#include <iostream>
#include <vector>
#include <string>
#include <iomanip>

#pragma comment(lib, "iphlpapi.lib")

struct NetworkAdapterInfo {
    std::string friendlyName;
    std::string description;
    std::string physicalAddress;
    DWORD type;
    DWORD operStatus;
    ULONG64 bytesReceived;
    ULONG64 bytesSent;
    ULONG64 packetsReceived;
    ULONG64 packetsSent;
};

class NetworkInfoCollector {
private:
    std::vector<NetworkAdapterInfo> m_adapters;
    
public:
    NetworkInfoCollector();
    ~NetworkInfoCollector();
    
    bool CollectNetworkInfo();
    void DisplayNetworkInfo() const;
    void DisplayNetworkStatistics() const;
    
    // ê²Œì„ ì„œë²„ìš© ë„¤íŠ¸ì›Œí¬ ëª¨ë‹ˆí„°ë§
    ULONG64 GetTotalBytesReceived() const;
    ULONG64 GetTotalBytesSent() const;
    double GetNetworkUtilization(DWORD adapterIndex) const;
    
private:
    std::string GetAdapterTypeString(DWORD type) const;
    std::string GetOperStatusString(DWORD status) const;
    std::string FormatMacAddress(const BYTE* addr, DWORD length) const;
    std::string FormatBytes(ULONG64 bytes) const;
};
```

```cpp
// NetworkInfoCollector.cpp
#include "NetworkInfoCollector.h"

NetworkInfoCollector::NetworkInfoCollector() {
}

NetworkInfoCollector::~NetworkInfoCollector() {
}

bool NetworkInfoCollector::CollectNetworkInfo() {
    m_adapters.clear();
    
    // ì–´ëŒ‘í„° ì •ë³´ í¬ê¸° ì–»ê¸°
    DWORD dwSize = 0;
    DWORD dwRetVal = GetAdaptersAddresses(AF_UNSPEC, 
                                         GAA_FLAG_INCLUDE_PREFIX, 
                                         NULL, 
                                         NULL, 
                                         &dwSize);
    
    if (dwRetVal != ERROR_BUFFER_OVERFLOW) {
        std::cout << "GetAdaptersAddresses í¬ê¸° ì¡°íšŒ ì‹¤íŒ¨: " << dwRetVal << std::endl;
        return false;
    }
    
    // ë©”ëª¨ë¦¬ í• ë‹¹
    PIP_ADAPTER_ADDRESSES pAddresses = (IP_ADAPTER_ADDRESSES*)malloc(dwSize);
    if (!pAddresses) {
        std::cout << "ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨\n";
        return false;
    }
    
    // ì–´ëŒ‘í„° ì •ë³´ ìˆ˜ì§‘
    dwRetVal = GetAdaptersAddresses(AF_UNSPEC,
                                   GAA_FLAG_INCLUDE_PREFIX,
                                   NULL,
                                   pAddresses,
                                   &dwSize);
    
    if (dwRetVal != NO_ERROR) {
        std::cout << "GetAdaptersAddresses ì‹¤íŒ¨: " << dwRetVal << std::endl;
        free(pAddresses);
        return false;
    }
    
    // ì–´ëŒ‘í„° ì •ë³´ íŒŒì‹±
    PIP_ADAPTER_ADDRESSES pCurrAddresses = pAddresses;
    while (pCurrAddresses) {
        NetworkAdapterInfo info;
        
        // ì´ë¦„ ë³€í™˜ (Wide char to Multi-byte)
        if (pCurrAddresses->FriendlyName) {
            int len = WideCharToMultiByte(CP_UTF8, 0, 
                                        pCurrAddresses->FriendlyName, -1, 
                                        nullptr, 0, nullptr, nullptr);
            if (len > 0) {
                std::string temp(len, 0);
                WideCharToMultiByte(CP_UTF8, 0, 
                                  pCurrAddresses->FriendlyName, -1, 
                                  &temp[0], len, nullptr, nullptr);
                info.friendlyName = temp.c_str(); // null terminator ì œê±°
            }
        }
        
        info.description = pCurrAddresses->Description ? 
                          pCurrAddresses->Description : "Unknown";
        
        info.physicalAddress = FormatMacAddress(
            pCurrAddresses->PhysicalAddress,
            pCurrAddresses->PhysicalAddressLength
        );
        
        info.type = pCurrAddresses->IfType;
        info.operStatus = pCurrAddresses->OperStatus;
        
        // í†µê³„ ì •ë³´ëŠ” ë³„ë„ APIë¡œ ìˆ˜ì§‘
        MIB_IF_ROW2 ifRow;
        ZeroMemory(&ifRow, sizeof(MIB_IF_ROW2));
        ifRow.InterfaceIndex = pCurrAddresses->IfIndex;
        
        if (GetIfEntry2(&ifRow) == NO_ERROR) {
            info.bytesReceived = ifRow.InOctets;
            info.bytesSent = ifRow.OutOctets;
            info.packetsReceived = ifRow.InUcastPkts;
            info.packetsSent = ifRow.OutUcastPkts;
        }
        
        m_adapters.push_back(info);
        pCurrAddresses = pCurrAddresses->Next;
    }
    
    free(pAddresses);
    return true;
}

void NetworkInfoCollector::DisplayNetworkInfo() const {
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                   ë„¤íŠ¸ì›Œí¬ ì–´ëŒ‘í„° ì •ë³´                        â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    
    for (size_t i = 0; i < m_adapters.size(); ++i) {
        const auto& adapter = m_adapters[i];
        
        std::cout << "â•‘ ì–´ëŒ‘í„° #" << (i + 1) << std::endl;
        std::cout << "â•‘ â”œâ”€ ì´ë¦„: " << adapter.friendlyName << std::endl;
        std::cout << "â•‘ â”œâ”€ ì„¤ëª…: " << adapter.description << std::endl;
        std::cout << "â•‘ â”œâ”€ MAC ì£¼ì†Œ: " << adapter.physicalAddress << std::endl;
        std::cout << "â•‘ â”œâ”€ íƒ€ì…: " << GetAdapterTypeString(adapter.type) << std::endl;
        std::cout << "â•‘ â””â”€ ìƒíƒœ: " << GetOperStatusString(adapter.operStatus) << std::endl;
        
        if (i < m_adapters.size() - 1) {
            std::cout << "â•‘" << std::endl;
        }
    }
    
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
}

void NetworkInfoCollector::DisplayNetworkStatistics() const {
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                   ë„¤íŠ¸ì›Œí¬ í†µê³„ ì •ë³´                          â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    
    ULONG64 totalReceived = 0;
    ULONG64 totalSent = 0;
    
    for (size_t i = 0; i < m_adapters.size(); ++i) {
        const auto& adapter = m_adapters[i];
        
        // í™œì„± ì–´ëŒ‘í„°ë§Œ í‘œì‹œ
        if (adapter.operStatus == IfOperStatusUp) {
            std::cout << "â•‘ " << adapter.friendlyName << std::endl;
            std::cout << "â•‘ â”œâ”€ ìˆ˜ì‹ : " << FormatBytes(adapter.bytesReceived) 
                      << " (" << adapter.packetsReceived << " íŒ¨í‚·)" << std::endl;
            std::cout << "â•‘ â””â”€ ì†¡ì‹ : " << FormatBytes(adapter.bytesSent) 
                      << " (" << adapter.packetsSent << " íŒ¨í‚·)" << std::endl;
            std::cout << "â•‘" << std::endl;
            
            totalReceived += adapter.bytesReceived;
            totalSent += adapter.bytesSent;
        }
    }
    
    std::cout << "â•‘ ì „ì²´ í†µê³„:" << std::endl;
    std::cout << "â•‘ â”œâ”€ ì´ ìˆ˜ì‹ : " << FormatBytes(totalReceived) << std::endl;
    std::cout << "â•‘ â””â”€ ì´ ì†¡ì‹ : " << FormatBytes(totalSent) << std::endl;
    
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
}

std::string NetworkInfoCollector::GetAdapterTypeString(DWORD type) const {
    switch (type) {
        case IF_TYPE_ETHERNET_CSMACD: return "ì´ë”ë„·";
        case IF_TYPE_IEEE80211: return "ë¬´ì„  LAN";
        case IF_TYPE_SOFTWARE_LOOPBACK: return "ë£¨í”„ë°±";
        case IF_TYPE_TUNNEL: return "í„°ë„";
        case IF_TYPE_PPP: return "PPP";
        default: return "ê¸°íƒ€ (" + std::to_string(type) + ")";
    }
}

std::string NetworkInfoCollector::GetOperStatusString(DWORD status) const {
    switch (status) {
        case IfOperStatusUp: return "í™œì„±";
        case IfOperStatusDown: return "ë¹„í™œì„±";
        case IfOperStatusTesting: return "í…ŒìŠ¤íŠ¸ ì¤‘";
        case IfOperStatusUnknown: return "ì•Œ ìˆ˜ ì—†ìŒ";
        case IfOperStatusDormant: return "ëŒ€ê¸°";
        case IfOperStatusNotPresent: return "ì—†ìŒ";
        case IfOperStatusLowerLayerDown: return "í•˜ìœ„ ê³„ì¸µ ë‹¤ìš´";
        default: return "ì •ì˜ë˜ì§€ ì•ŠìŒ";
    }
}

std::string NetworkInfoCollector::FormatMacAddress(const BYTE* addr, DWORD length) const {
    if (!addr || length == 0) {
        return "N/A";
    }
    
    std::string result;
    for (DWORD i = 0; i < length; ++i) {
        if (i > 0) result += ":";
        
        char hex[3];
        sprintf_s(hex, "%02X", addr[i]);
        result += hex;
    }
    
    return result;
}

std::string NetworkInfoCollector::FormatBytes(ULONG64 bytes) const {
    const char* units[] = {"B", "KB", "MB", "GB", "TB"};
    double size = static_cast<double>(bytes);
    int unitIndex = 0;
    
    while (size >= 1024.0 && unitIndex < 4) {
        size /= 1024.0;
        unitIndex++;
    }
    
    char buffer[64];
    sprintf_s(buffer, "%.2f %s", size, units[unitIndex]);
    return std::string(buffer);
}

ULONG64 NetworkInfoCollector::GetTotalBytesReceived() const {
    ULONG64 total = 0;
    for (const auto& adapter : m_adapters) {
        if (adapter.operStatus == IfOperStatusUp) {
            total += adapter.bytesReceived;
        }
    }
    return total;
}

ULONG64 NetworkInfoCollector::GetTotalBytesSent() const {
    ULONG64 total = 0;
    for (const auto& adapter : m_adapters) {
        if (adapter.operStatus == IfOperStatusUp) {
            total += adapter.bytesSent;
        }
    }
    return total;
}
```
  
</br>  
  
## 8.4 ì‹¤ì‹œê°„ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ë„êµ¬ ì œì‘

### 8.4.1 ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì•„í‚¤í…ì²˜
ê²Œì„ ì„œë²„ë¥¼ ìœ„í•œ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•´ë³´ê² ë‹¤:

```
    ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ë°ì´í„° ìˆ˜ì§‘ê¸°  â”‚ â†’  â”‚   ë°ì´í„° ì €ì¥   â”‚ â†’  â”‚   ì•Œë¦¼ ì‹œìŠ¤í…œ   â”‚
â”‚ - CPU ì‚¬ìš©ë¥     â”‚    â”‚ - ë©”ëª¨ë¦¬ DB     â”‚    â”‚ - ì„ê³„ê°’ ê°ì‹œ   â”‚
â”‚ - ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  â”‚    â”‚ - ìˆœí™˜ ë²„í¼     â”‚    â”‚ - ë¡œê·¸ ê¸°ë¡     â”‚
â”‚ - ë„¤íŠ¸ì›Œí¬ I/O  â”‚    â”‚ - ì••ì¶• ì €ì¥     â”‚    â”‚ - ê´€ë¦¬ì í†µì§€   â”‚
â”‚ - ë””ìŠ¤í¬ I/O    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ì‹¤ì‹œê°„ ì¶œë ¥   â”‚
â”‚ - ì½˜ì†” ë””ìŠ¤í”Œë ˆì´â”‚
â”‚ - ì›¹ ëŒ€ì‹œë³´ë“œ   â”‚
â”‚ - ê·¸ë˜í”„ ì°¨íŠ¸   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.4.2 ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë„êµ¬ êµ¬í˜„

```cpp
// RealTimeMonitor.h
#pragma once
#include <windows.h>
#include <pdh.h>
#include <iostream>
#include <vector>
#include <string>
#include <thread>
#include <atomic>
#include <chrono>
#include <queue>
#include <mutex>
#include <iomanip>

#pragma comment(lib, "pdh.lib")

struct SystemMetrics {
    double cpuUsage;
    double memoryUsage;
    ULONG64 networkBytesReceived;
    ULONG64 networkBytesSent;
    double diskReadRate;
    double diskWriteRate;
    std::chrono::steady_clock::time_point timestamp;
};

class RealTimeMonitor {
private:
    // PDH í•¸ë“¤
    PDH_HQUERY m_hQuery;
    PDH_HCOUNTER m_hCpuCounter;
    PDH_HCOUNTER m_hMemoryCounter;
    PDH_HCOUNTER m_hNetworkRecvCounter;
    PDH_HCOUNTER m_hNetworkSentCounter;
    PDH_HCOUNTER m_hDiskReadCounter;
    PDH_HCOUNTER m_hDiskWriteCounter;
    
    // ëª¨ë‹ˆí„°ë§ ìƒíƒœ
    std::atomic<bool> m_running;
    std::thread m_monitorThread;
    
    // ë°ì´í„° ì €ì¥
    std::queue<SystemMetrics> m_metricsHistory;
    std::mutex m_historyMutex;
    size_t m_maxHistorySize;
    
    // ì•Œë¦¼ ì„ê³„ê°’
    double m_cpuThreshold;
    double m_memoryThreshold;
    
public:
    RealTimeMonitor();
    ~RealTimeMonitor();
    
    bool Initialize();
    void StartMonitoring();
    void StopMonitoring();
    void SetThresholds(double cpuThreshold, double memoryThreshold);
    
    // ì‹¤ì‹œê°„ ë°ì´í„° ì ‘ê·¼
    SystemMetrics GetCurrentMetrics();
    std::vector<SystemMetrics> GetHistoryMetrics(size_t count = 60);
    
    // ë””ìŠ¤í”Œë ˆì´
    void DisplayRealTimeStatus();
    void DisplayHistoryGraph();
    
private:
    void MonitoringLoop();
    bool CollectMetrics(SystemMetrics& metrics);
    void CheckThresholds(const SystemMetrics& metrics);
    void DisplayProgressBar(const std::string& label, double value, double max = 100.0);
    void ClearScreen();
    void GotoXY(int x, int y);
};
```

```cpp
// RealTimeMonitor.cpp
#include "RealTimeMonitor.h"

RealTimeMonitor::RealTimeMonitor() 
    : m_hQuery(NULL)
    , m_hCpuCounter(NULL)
    , m_hMemoryCounter(NULL)
    , m_hNetworkRecvCounter(NULL)
    , m_hNetworkSentCounter(NULL)
    , m_hDiskReadCounter(NULL)
    , m_hDiskWriteCounter(NULL)
    , m_running(false)
    , m_maxHistorySize(300)  // 5ë¶„ê°„ ë°ì´í„° (1ì´ˆ ê°„ê²©)
    , m_cpuThreshold(80.0)
    , m_memoryThreshold(85.0) {
}

RealTimeMonitor::~RealTimeMonitor() {
    StopMonitoring();
    
    if (m_hQuery) {
        PdhCloseQuery(m_hQuery);
    }
}

bool RealTimeMonitor::Initialize() {
    PDH_STATUS status;
    
    // PDH ì¿¼ë¦¬ ìƒì„±
    status = PdhOpenQuery(NULL, 0, &m_hQuery);
    if (status != ERROR_SUCCESS) {
        std::cout << "PDH ì¿¼ë¦¬ ìƒì„± ì‹¤íŒ¨: 0x" << std::hex << status << std::endl;
        return false;
    }
    
    // CPU ì‚¬ìš©ë¥  ì¹´ìš´í„°
    status = PdhAddEnglishCounter(m_hQuery, 
                                 L"\\Processor(_Total)\\% Processor Time", 
                                 0, 
                                 &m_hCpuCounter);
    if (status != ERROR_SUCCESS) {
        std::cout << "CPU ì¹´ìš´í„° ì¶”ê°€ ì‹¤íŒ¨: 0x" << std::hex << status << std::endl;
        return false;
    }
    
    // ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì¹´ìš´í„°
    status = PdhAddEnglishCounter(m_hQuery, 
                                 L"\\Memory\\% Committed Bytes In Use", 
                                 0, 
                                 &m_hMemoryCounter);
    if (status != ERROR_SUCCESS) {
        std::cout << "ë©”ëª¨ë¦¬ ì¹´ìš´í„° ì¶”ê°€ ì‹¤íŒ¨: 0x" << std::hex << status << std::endl;
        return false;
    }
    
    // ë„¤íŠ¸ì›Œí¬ ìˆ˜ì‹  ì¹´ìš´í„°
    status = PdhAddEnglishCounter(m_hQuery, 
                                 L"\\Network Interface(*)\\Bytes Received/sec", 
                                 0, 
                                 &m_hNetworkRecvCounter);
    if (status != ERROR_SUCCESS) {
        std::cout << "ë„¤íŠ¸ì›Œí¬ ìˆ˜ì‹  ì¹´ìš´í„° ì¶”ê°€ ì‹¤íŒ¨: 0x" << std::hex << status << std::endl;
    }
    
    // ë„¤íŠ¸ì›Œí¬ ì†¡ì‹  ì¹´ìš´í„°
    status = PdhAddEnglishCounter(m_hQuery, 
                                 L"\\Network Interface(*)\\Bytes Sent/sec", 
                                 0, 
                                 &m_hNetworkSentCounter);
    if (status != ERROR_SUCCESS) {
        std::cout << "ë„¤íŠ¸ì›Œí¬ ì†¡ì‹  ì¹´ìš´í„° ì¶”ê°€ ì‹¤íŒ¨: 0x" << std::hex << status << std::endl;
    }
    
    // ë””ìŠ¤í¬ ì½ê¸° ì¹´ìš´í„°
    status = PdhAddEnglishCounter(m_hQuery, 
                                 L"\\PhysicalDisk(_Total)\\Disk Read Bytes/sec", 
                                 0, 
                                 &m_hDiskReadCounter);
    if (status != ERROR_SUCCESS) {
        std::cout << "ë””ìŠ¤í¬ ì½ê¸° ì¹´ìš´í„° ì¶”ê°€ ì‹¤íŒ¨: 0x" << std::hex << status << std::endl;
    }
    
    // ë””ìŠ¤í¬ ì“°ê¸° ì¹´ìš´í„°
    status = PdhAddEnglishCounter(m_hQuery, 
                                 L"\\PhysicalDisk(_Total)\\Disk Write Bytes/sec", 
                                 0, 
                                 &m_hDiskWriteCounter);
    if (status != ERROR_SUCCESS) {
        std::cout << "ë””ìŠ¤í¬ ì“°ê¸° ì¹´ìš´í„° ì¶”ê°€ ì‹¤íŒ¨: 0x" << std::hex << status << std::endl;
    }
    
    // ì²« ë²ˆì§¸ ìƒ˜í”Œ ìˆ˜ì§‘ (ë² ì´ìŠ¤ë¼ì¸)
    status = PdhCollectQueryData(m_hQuery);
    if (status != ERROR_SUCCESS) {
        std::cout << "ì²« ë²ˆì§¸ ìƒ˜í”Œ ìˆ˜ì§‘ ì‹¤íŒ¨: 0x" << std::hex << status << std::endl;
        return false;
    }
    
    return true;
}

void RealTimeMonitor::StartMonitoring() {
    if (m_running.load()) {
        return;
    }
    
    m_running.store(true);
    m_monitorThread = std::thread(&RealTimeMonitor::MonitoringLoop, this);
    
    std::cout << "ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘ë¨...\n";
    std::cout << "ì¢…ë£Œí•˜ë ¤ë©´ Ctrl+Cë¥¼ ëˆ„ë¥´ì„¸ìš”.\n\n";
}

void RealTimeMonitor::StopMonitoring() {
    if (!m_running.load()) {
        return;
    }
    
    m_running.store(false);
    if (m_monitorThread.joinable()) {
        m_monitorThread.join();
    }
    
    std::cout << "\nì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€ë¨.\n";
}

void RealTimeMonitor::MonitoringLoop() {
    while (m_running.load()) {
        SystemMetrics metrics;
        
        if (CollectMetrics(metrics)) {
            // íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
            {
                std::lock_guard<std::mutex> lock(m_historyMutex);
                m_metricsHistory.push(metrics);
                
                // ìµœëŒ€ í¬ê¸° ì´ˆê³¼ì‹œ ì˜¤ë˜ëœ ë°ì´í„° ì œê±°
                while (m_metricsHistory.size() > m_maxHistorySize) {
                    m_metricsHistory.pop();
                }
            }
            
            // ì„ê³„ê°’ í™•ì¸
            CheckThresholds(metrics);
            
            // ì‹¤ì‹œê°„ ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸
            DisplayRealTimeStatus();
        }
        
        // 1ì´ˆ ëŒ€ê¸°
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

bool RealTimeMonitor::CollectMetrics(SystemMetrics& metrics) {
    PDH_STATUS status = PdhCollectQueryData(m_hQuery);
    if (status != ERROR_SUCCESS) {
        return false;
    }
    
    PDH_FMT_COUNTERVALUE counterValue;
    
    // CPU ì‚¬ìš©ë¥ 
    if (m_hCpuCounter) {
        status = PdhGetFormattedCounterValue(m_hCpuCounter, 
                                           PDH_FMT_DOUBLE, 
                                           NULL, 
                                           &counterValue);
        if (status == ERROR_SUCCESS) {
            metrics.cpuUsage = counterValue.doubleValue;
        }
    }
    
    // ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
    if (m_hMemoryCounter) {
        status = PdhGetFormattedCounterValue(m_hMemoryCounter, 
                                           PDH_FMT_DOUBLE, 
                                           NULL, 
                                           &counterValue);
        if (status == ERROR_SUCCESS) {
            metrics.memoryUsage = counterValue.doubleValue;
        }
    }
    
    // ë„¤íŠ¸ì›Œí¬ ìˆ˜ì‹ 
    if (m_hNetworkRecvCounter) {
        status = PdhGetFormattedCounterValue(m_hNetworkRecvCounter, 
                                           PDH_FMT_LARGE, 
                                           NULL, 
                                           &counterValue);
        if (status == ERROR_SUCCESS) {
            metrics.networkBytesReceived = counterValue.largeValue;
        }
    }
    
    // ë„¤íŠ¸ì›Œí¬ ì†¡ì‹ 
    if (m_hNetworkSentCounter) {
        status = PdhGetFormattedCounterValue(m_hNetworkSentCounter, 
                                           PDH_FMT_LARGE, 
                                           NULL, 
                                           &counterValue);
        if (status == ERROR_SUCCESS) {
            metrics.networkBytesSent = counterValue.largeValue;
        }
    }
    
    // ë””ìŠ¤í¬ ì½ê¸°
    if (m_hDiskReadCounter) {
        status = PdhGetFormattedCounterValue(m_hDiskReadCounter, 
                                           PDH_FMT_DOUBLE, 
                                           NULL, 
                                           &counterValue);
        if (status == ERROR_SUCCESS) {
            metrics.diskReadRate = counterValue.doubleValue;
        }
    }
    
    // ë””ìŠ¤í¬ ì“°ê¸°
    if (m_hDiskWriteCounter) {
        status = PdhGetFormattedCounterValue(m_hDiskWriteCounter, 
                                           PDH_FMT_DOUBLE, 
                                           NULL, 
                                           &counterValue);
        if (status == ERROR_SUCCESS) {
            metrics.diskWriteRate = counterValue.doubleValue;
        }
    }
    
    metrics.timestamp = std::chrono::steady_clock::now();
    return true;
}

void RealTimeMonitor::DisplayRealTimeStatus() {
    static int frameCount = 0;
    
    SystemMetrics current = GetCurrentMetrics();
    
    // í™”ë©´ ì§€ìš°ê¸° (ì»¤ì„œë¥¼ ë§¨ ìœ„ë¡œ)
    GotoXY(0, 0);
    
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                  ê²Œì„ ì„œë²„ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§                    â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    
    // CPU ì‚¬ìš©ë¥ 
    std::cout << "â•‘ CPU ì‚¬ìš©ë¥ :  ";
    DisplayProgressBar("", current.cpuUsage);
    std::cout << "â•‘\n";
    
    // ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
    std::cout << "â•‘ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : ";
    DisplayProgressBar("", current.memoryUsage);
    std::cout << "â•‘\n";
    
    std::cout << "â•‘                                                              â•‘\n";
    
    // ë„¤íŠ¸ì›Œí¬ I/O
    std::cout << "â•‘ ë„¤íŠ¸ì›Œí¬ ìˆ˜ì‹ : " << std::setw(15) << std::right 
              << (current.networkBytesReceived / 1024) << " KB/s" 
              << std::setw(25) << " " << "â•‘\n";
    
    std::cout << "â•‘ ë„¤íŠ¸ì›Œí¬ ì†¡ì‹ : " << std::setw(15) << std::right 
              << (current.networkBytesSent / 1024) << " KB/s" 
              << std::setw(25) << " " << "â•‘\n";
    
    std::cout << "â•‘                                                              â•‘\n";
    
    // ë””ìŠ¤í¬ I/O
    std::cout << "â•‘ ë””ìŠ¤í¬ ì½ê¸°:   " << std::setw(15) << std::right 
              << (current.diskReadRate / 1024) << " KB/s" 
              << std::setw(25) << " " << "â•‘\n";
    
    std::cout << "â•‘ ë””ìŠ¤í¬ ì“°ê¸°:   " << std::setw(15) << std::right 
              << (current.diskWriteRate / 1024) << " KB/s" 
              << std::setw(25) << " " << "â•‘\n";
    
    std::cout << "â•‘                                                              â•‘\n";
    
    // ìƒíƒœ í‘œì‹œ
    std::string status = "ì •ìƒ";
    if (current.cpuUsage > m_cpuThreshold || current.memoryUsage > m_memoryThreshold) {
        status = "âš ï¸  ê²½ê³ ";
    }
    
    std::cout << "â•‘ ì‹œìŠ¤í…œ ìƒíƒœ:   " << std::setw(15) << std::left << status 
              << std::setw(27) << " " << "â•‘\n";
    
    std::cout << "â•‘ ì—…ë°ì´íŠ¸:      " << std::setw(15) << std::left << (++frameCount) 
              << std::setw(27) << " " << "â•‘\n";
    
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    
    // ë²„í¼ í”ŒëŸ¬ì‹œ
    std::cout.flush();
}

void RealTimeMonitor::DisplayProgressBar(const std::string& label, double value, double max) {
    const int barWidth = 30;
    double percentage = (value / max) * 100.0;
    int filledLength = static_cast<int>((value / max) * barWidth);
    
    std::cout << "[";
    for (int i = 0; i < barWidth; ++i) {
        if (i < filledLength) {
            if (percentage > 80) {
                std::cout << "â–ˆ";  // ë†’ì€ ì‚¬ìš©ë¥  - ë¹¨ê°„ìƒ‰ ëŠë‚Œ
            } else if (percentage > 60) {
                std::cout << "â–“";  // ì¤‘ê°„ ì‚¬ìš©ë¥  - ë…¸ë€ìƒ‰ ëŠë‚Œ
            } else {
                std::cout << "â–’";  // ë‚®ì€ ì‚¬ìš©ë¥  - ì´ˆë¡ìƒ‰ ëŠë‚Œ
            }
        } else {
            std::cout << "â–‘";
        }
    }
    std::cout << "] " << std::setw(6) << std::fixed << std::setprecision(1) 
              << percentage << "%";
}

void RealTimeMonitor::CheckThresholds(const SystemMetrics& metrics) {
    static bool cpuWarningShown = false;
    static bool memoryWarningShown = false;
    
    // CPU ì„ê³„ê°’ í™•ì¸
    if (metrics.cpuUsage > m_cpuThreshold) {
        if (!cpuWarningShown) {
            std::cout << "\nâš ï¸  ê²½ê³ : CPU ì‚¬ìš©ë¥ ì´ " << m_cpuThreshold 
                      << "%ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤! (" << metrics.cpuUsage << "%)\n";
            cpuWarningShown = true;
        }
    } else {
        cpuWarningShown = false;
    }
    
    // ë©”ëª¨ë¦¬ ì„ê³„ê°’ í™•ì¸
    if (metrics.memoryUsage > m_memoryThreshold) {
        if (!memoryWarningShown) {
            std::cout << "\nâš ï¸  ê²½ê³ : ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ " << m_memoryThreshold 
                      << "%ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤! (" << metrics.memoryUsage << "%)\n";
            memoryWarningShown = true;
        }
    } else {
        memoryWarningShown = false;
    }
}

SystemMetrics RealTimeMonitor::GetCurrentMetrics() {
    std::lock_guard<std::mutex> lock(m_historyMutex);
    if (!m_metricsHistory.empty()) {
        return m_metricsHistory.back();
    }
    return SystemMetrics{};
}

void RealTimeMonitor::GotoXY(int x, int y) {
    COORD coord;
    coord.X = x;
    coord.Y = y;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
}

void RealTimeMonitor::SetThresholds(double cpuThreshold, double memoryThreshold) {
    m_cpuThreshold = cpuThreshold;
    m_memoryThreshold = memoryThreshold;
}
```

### 8.4.3 í†µí•© ì‚¬ìš© ì˜ˆì œ
ì´ì œ ëª¨ë“  ì»´í¬ë„ŒíŠ¸ë¥¼ í†µí•©í•˜ì—¬ ì‚¬ìš©í•˜ëŠ” ì˜ˆì œë¥¼ ë§Œë“¤ì–´ë³´ê² ë‹¤:

```cpp
// main.cpp
#include "SystemInfoCollector.h"
#include "MemoryInfoCollector.h"
#include "WMISystemMonitor.h"
#include "NetworkInfoCollector.h"
#include "RealTimeMonitor.h"
#include <iostream>
#include <conio.h>

void DisplayMenu() {
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘              ê²Œì„ ì„œë²„ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ ë„êµ¬                  â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    std::cout << "â•‘ 1. ê¸°ë³¸ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘                                     â•‘\n";
    std::cout << "â•‘ 2. ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘                                          â•‘\n";
    std::cout << "â•‘ 3. WMI CPU ì •ë³´ ìˆ˜ì§‘                                         â•‘\n";
    std::cout << "â•‘ 4. ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ ì •ë³´                                  â•‘\n";
    std::cout << "â•‘ 5. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘                                      â•‘\n";
    std::cout << "â•‘ 0. ì¢…ë£Œ                                                      â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    std::cout << "ì„ íƒí•˜ì„¸ìš”: ";
}

int main() {
    // ì½˜ì†” ì½”ë“œí˜ì´ì§€ë¥¼ UTF-8ë¡œ ì„¤ì • (í•œê¸€ ì¶œë ¥ ì§€ì›)
    SetConsoleOutputCP(CP_UTF8);
    
    std::cout << "ê²Œì„ ì„œë²„ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ ë„êµ¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...\n";
    
    SystemInfoCollector systemInfo;
    MemoryInfoCollector memoryInfo;
    WMISystemMonitor wmiMonitor;
    NetworkInfoCollector networkInfo;
    RealTimeMonitor realTimeMonitor;
    
    // ê¸°ë³¸ ì´ˆê¸°í™”
    systemInfo.CollectBasicSystemInfo();
    
    int choice;
    do {
        DisplayMenu();
        std::cin >> choice;
        
        switch (choice) {
            case 1:
                std::cout << "\n=== ê¸°ë³¸ ì‹œìŠ¤í…œ ì •ë³´ ===\n";
                systemInfo.DisplaySystemInfo();
                
                std::cout << "\nê²Œì„ ì„œë²„ ìµœì í™” ê¶Œì¥ì‚¬í•­:\n";
                std::cout << "- ê¶Œì¥ ìŠ¤ë ˆë“œ í’€ í¬ê¸°: " 
                          << systemInfo.GetOptimalThreadCount() << " ìŠ¤ë ˆë“œ\n";
                std::cout << "- í˜ì´ì§€ í¬ê¸°: " 
                          << (systemInfo.GetPageSize() / 1024) << " KB\n";
                std::cout << "- í”„ë¡œì„¸ì„œ ìˆ˜: " 
                          << systemInfo.GetProcessorCount() << " ê°œ\n";
                break;
                
            case 2:
                std::cout << "\n=== ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘ ===\n";
                memoryInfo.CollectMemoryInfo();
                memoryInfo.DisplayMemoryInfo();
                
                if (memoryInfo.IsMemoryPressureHigh()) {
                    std::cout << "\nğŸ’¡ ê¶Œì¥ì‚¬í•­: ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤. "
                              << "ë©”ëª¨ë¦¬ í• ë‹¹ ì „ëµì„ ê²€í† í•˜ì„¸ìš”.\n";
                }
                break;
                
            case 3:
                std::cout << "\n=== WMI CPU ì •ë³´ ===\n";
                if (wmiMonitor.Initialize()) {
                    wmiMonitor.GetCPUInfo();
                } else {
                    std::cout << "WMI ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n";
                }
                break;
                
            case 4:
                std::cout << "\n=== ë„¤íŠ¸ì›Œí¬ ì •ë³´ ===\n";
                if (networkInfo.CollectNetworkInfo()) {
                    networkInfo.DisplayNetworkInfo();
                    networkInfo.DisplayNetworkStatistics();
                } else {
                    std::cout << "ë„¤íŠ¸ì›Œí¬ ì •ë³´ ìˆ˜ì§‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n";
                }
                break;
                
            case 5:
                std::cout << "\n=== ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ===\n";
                if (realTimeMonitor.Initialize()) {
                    std::cout << "ì„ê³„ê°’ ì„¤ì • (ê¸°ë³¸ê°’: CPU 80%, ë©”ëª¨ë¦¬ 85%)\n";
                    std::cout << "CPU ì„ê³„ê°’ (%): ";
                    double cpuThreshold, memoryThreshold;
                    std::cin >> cpuThreshold;
                    std::cout << "ë©”ëª¨ë¦¬ ì„ê³„ê°’ (%): ";
                    std::cin >> memoryThreshold;
                    
                    realTimeMonitor.SetThresholds(cpuThreshold, memoryThreshold);
                    realTimeMonitor.StartMonitoring();
                    
                    std::cout << "ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ë©´ ëª¨ë‹ˆí„°ë§ì„ ì¤‘ì§€í•©ë‹ˆë‹¤...\n";
                    _getch();
                    realTimeMonitor.StopMonitoring();
                } else {
                    std::cout << "ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n";
                }
                break;
                
            case 0:
                std::cout << "í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.\n";
                break;
                
            default:
                std::cout << "ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤. ë‹¤ì‹œ ì„ íƒí•´ì£¼ì„¸ìš”.\n";
                break;
        }
        
        if (choice != 0 && choice != 5) {
            std::cout << "\nê³„ì†í•˜ë ¤ë©´ ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ì„¸ìš”...";
            _getch();
        }
        
    } while (choice != 0);
    
    return 0;
}
```
  
</br>  
  
## 8.5 ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­ê³¼ ìµœì í™”

### 8.5.1 ëª¨ë‹ˆí„°ë§ ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”
ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ì€ ì„±ëŠ¥ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìµœì í™”ê°€ í•„ìš”í•˜ë‹¤:

```cpp
// PerformanceOptimizedMonitor.h
#pragma once
#include <windows.h>
#include <atomic>
#include <thread>
#include <chrono>

class PerformanceOptimizedMonitor {
private:
    // ìƒ˜í”Œë§ ì£¼ê¸° ì¡°ì ˆ
    std::chrono::milliseconds m_samplingInterval;
    
    // ì ì‘ì  ëª¨ë‹ˆí„°ë§
    bool m_adaptiveMode;
    double m_cpuThreshold;
    
    // ìºì‹œëœ ì •ë³´
    mutable std::atomic<std::chrono::steady_clock::time_point> m_lastUpdate;
    mutable std::atomic<double> m_cachedCpuUsage;
    
public:
    PerformanceOptimizedMonitor() 
        : m_samplingInterval(1000)  // ê¸°ë³¸ 1ì´ˆ
        , m_adaptiveMode(true)
        , m_cpuThreshold(50.0) {
    }
    
    // ì ì‘ì  ìƒ˜í”Œë§ ì£¼ê¸° ì¡°ì ˆ
    void AdaptSamplingRate(double currentLoad) {
        if (!m_adaptiveMode) return;
        
        if (currentLoad > 80.0) {
            // ë†’ì€ ë¶€í•˜ì‹œ ë” ìì£¼ ëª¨ë‹ˆí„°ë§
            m_samplingInterval = std::chrono::milliseconds(500);
        } else if (currentLoad < 20.0) {
            // ë‚®ì€ ë¶€í•˜ì‹œ ëœ ìì£¼ ëª¨ë‹ˆí„°ë§  
            m_samplingInterval = std::chrono::milliseconds(5000);
        } else {
            // ë³´í†µ ë¶€í•˜ì‹œ ê¸°ë³¸ ì£¼ê¸°
            m_samplingInterval = std::chrono::milliseconds(1000);
        }
    }
    
    // ìºì‹œëœ ê°’ ì‚¬ìš©ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™”
    double GetCachedCpuUsage() const {
        auto now = std::chrono::steady_clock::now();
        auto lastUpdate = m_lastUpdate.load();
        
        // ìºì‹œê°€ ìœ íš¨í•œì§€ í™•ì¸ (1ì´ˆ ì´ë‚´)
        if (now - lastUpdate < std::chrono::seconds(1)) {
            return m_cachedCpuUsage.load();
        }
        
        // ìƒˆë¡œìš´ ê°’ ìˆ˜ì§‘ ë° ìºì‹œ ì—…ë°ì´íŠ¸
        double newValue = CollectCurrentCpuUsage();
        m_cachedCpuUsage.store(newValue);
        m_lastUpdate.store(now);
        
        return newValue;
    }
    
private:
    double CollectCurrentCpuUsage() const {
        // ì‹¤ì œ CPU ì‚¬ìš©ë¥  ìˆ˜ì§‘ êµ¬í˜„
        // (ì´ì „ì— êµ¬í˜„í•œ PDH ì½”ë“œ ì‚¬ìš©)
        return 0.0;
    }
};
```

### 8.5.2 ë°°ì¹˜ ìˆ˜ì§‘ ìµœì í™”
ì—¬ëŸ¬ ë©”íŠ¸ë¦­ì„ í•œ ë²ˆì— ìˆ˜ì§‘í•˜ì—¬ ì‹œìŠ¤í…œ í˜¸ì¶œ íšŸìˆ˜ë¥¼ ì¤„ì¸ë‹¤:

```cpp
// BatchMetricsCollector.h
#pragma once
#include <windows.h>
#include <vector>
#include <string>

struct BatchedMetrics {
    // ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
    double cpuUsage;
    double memoryUsage;
    ULONG64 networkIO;
    ULONG64 diskIO;
    
    // í”„ë¡œì„¸ìŠ¤ ë©”íŠ¸ë¦­
    SIZE_T processMemory;
    DWORD threadCount;
    ULONGLONG processTime;
    
    std::chrono::steady_clock::time_point timestamp;
};

class BatchMetricsCollector {
private:
    PDH_HQUERY m_hQuery;
    std::vector<PDH_HCOUNTER> m_counters;
    
public:
    BatchedMetrics CollectAllMetrics() {
        BatchedMetrics metrics{};
        
        // ë‹¨ì¼ PDH ì¿¼ë¦¬ë¡œ ëª¨ë“  ì¹´ìš´í„° ìˆ˜ì§‘
        PDH_STATUS status = PdhCollectQueryData(m_hQuery);
        if (status == ERROR_SUCCESS) {
            // ëª¨ë“  ì¹´ìš´í„° ê°’ì„ í•œ ë²ˆì— ì½ê¸°
            for (size_t i = 0; i < m_counters.size(); ++i) {
                PDH_FMT_COUNTERVALUE value;
                if (PdhGetFormattedCounterValue(m_counters[i], 
                                              PDH_FMT_DOUBLE, 
                                              NULL, 
                                              &value) == ERROR_SUCCESS) {
                    // ê° ë©”íŠ¸ë¦­ì— ê°’ í• ë‹¹
                    AssignMetricValue(metrics, i, value.doubleValue);
                }
            }
        }
        
        metrics.timestamp = std::chrono::steady_clock::now();
        return metrics;
    }
    
private:
    void AssignMetricValue(BatchedMetrics& metrics, size_t index, double value) {
        switch (index) {
            case 0: metrics.cpuUsage = value; break;
            case 1: metrics.memoryUsage = value; break;
            case 2: metrics.networkIO = static_cast<ULONG64>(value); break;
            case 3: metrics.diskIO = static_cast<ULONG64>(value); break;
            // ì¶”ê°€ ë©”íŠ¸ë¦­ë“¤...
        }
    }
};
```
  
</br>  
  
  
## ìš”ì•½
ì´ë²ˆ ì¥ì—ì„œëŠ” ê²Œì„ ì„œë²„ ê°œë°œì— í•„ìš”í•œ ë‹¤ì–‘í•œ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ ë°©ë²•ì„ í•™ìŠµí–ˆë‹¤. `GetSystemInfo`ë¥¼ í†µí•œ ê¸°ë³¸ í•˜ë“œì›¨ì–´ ì •ë³´ ìˆ˜ì§‘ë¶€í„° WMIë¥¼ ì´ìš©í•œ ê³ ê¸‰ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§, ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘, ê·¸ë¦¬ê³  ì‹¤ì‹œê°„ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ë„êµ¬ ì œì‘ê¹Œì§€ ë‹¤ë¤˜ë‹¤.

ì£¼ìš” í•™ìŠµ ë‚´ìš©:
- Win32 APIë¥¼ ì´ìš©í•œ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ì˜ ê¸°ë³¸ ì›ë¦¬
- WMI (Windows Management Instrumentation)ë¥¼ í™œìš©í•œ ìƒì„¸í•œ ì‹œìŠ¤í…œ ì •ë³´ ì¡°íšŒ
- IP Helper APIë¥¼ í†µí•œ ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ëª¨ë‹ˆí„°ë§
- PDH (Performance Data Helper)ë¥¼ ì´ìš©í•œ ì‹¤ì‹œê°„ ì„±ëŠ¥ ì¹´ìš´í„° ìˆ˜ì§‘
- ê²Œì„ ì„œë²„ ìš´ì˜ì— í•„ìš”í•œ ëª¨ë‹ˆí„°ë§ ì „ëµê³¼ ìµœì í™” ë°©ë²•

ì´ëŸ¬í•œ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ ê¸°ëŠ¥ì€ ê²Œì„ ì„œë²„ì˜ ì•ˆì •ì ì¸ ìš´ì˜ê³¼ ì„±ëŠ¥ ìµœì í™”ì— í•„ìˆ˜ì ì¸ ìš”ì†Œì´ë‹¤. ë‹¤ìŒ ì¥ì—ì„œëŠ” ë³´ì•ˆê³¼ ê¶Œí•œ ê´€ë¦¬ì— ëŒ€í•´ ì•Œì•„ë³´ê² ë‹¤.  