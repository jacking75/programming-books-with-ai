# 게임 서버 개발자를 위한 최신 Win32 API 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  

# Chapter 5. 동기화 객체 심화
게임 서버에서 동기화는 성능과 안정성을 좌우하는 핵심 요소이다. 이 장에서는 Win32 API의 고급 동기화 객체들을 심도 있게 다루며, 각각의 특성과 성능을 비교하고 실제 게임 서버 환경에서의 활용법을 학습하겠다.

## 5.1 Critical Section vs Mutex 성능 비교

### 5.1.1 심화 성능 분석 및 벤치마크
이전 장에서 간단히 다뤘던 Critical Section과 Mutex의 차이점을 더욱 자세히 분석해보겠다.

```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include <chrono>
#include <thread>
#include <atomic>
#include <random>

class AdvancedSyncBenchmark {
private:
    static constexpr int ITERATIONS = 10000000;
    static constexpr int THREAD_COUNTS[] = {1, 2, 4, 8, 16};
    static constexpr int TEST_ROUNDS = 5;
    
    // 테스트용 데이터
    struct SharedData {
        int counter;
        int checksum;
        char padding[64 - sizeof(int) * 2]; // 캐시 라인 패딩
    };
    
    SharedData m_criticalSectionData;
    SharedData m_mutexData;
    SharedData m_srwLockData;
    
    // 동기화 객체들
    CRITICAL_SECTION m_criticalSection;
    HANDLE m_mutex;
    SRWLOCK m_srwLock;
    
public:
    AdvancedSyncBenchmark() {
        InitializeCriticalSection(&m_criticalSection);
        m_mutex = CreateMutex(nullptr, FALSE, nullptr);
        InitializeSRWLock(&m_srwLock);
        
        memset(&m_criticalSectionData, 0, sizeof(m_criticalSectionData));
        memset(&m_mutexData, 0, sizeof(m_mutexData));
        memset(&m_srwLockData, 0, sizeof(m_srwLockData));
    }
    
    ~AdvancedSyncBenchmark() {
        DeleteCriticalSection(&m_criticalSection);
        if (m_mutex != nullptr) {
            CloseHandle(m_mutex);
        }
    }
    
    void RunComprehensiveBenchmark() {
        std::cout << "\n=== 동기화 객체 종합 성능 비교 ===" << std::endl;
        std::cout << "테스트 반복 횟수: " << ITERATIONS << std::endl;
        std::cout << "테스트 라운드: " << TEST_ROUNDS << std::endl;
        
        /*
        ┌─────────────────────────────────────────────────────────────┐
        │                  Synchronization Objects                     │
        ├─────────────────────────────────────────────────────────────┤
        │                                                             │
        │  Critical Section        Mutex                 SRWLock      │
        │  ┌─────────────────┐    ┌─────────────────┐   ┌──────────┐   │
        │  │   User Mode     │    │  Kernel Mode    │   │Fast Path │   │
        │  │   Fast Path     │    │  Slow Path      │   │Slow Path │   │
        │  │   Process Only  │    │  Cross Process  │   │Vista+    │   │
        │  └─────────────────┘    └─────────────────┘   └──────────┘   │
        │           │                       │                │         │
        │           ▼                       ▼                ▼         │
        │  ┌─────────────────┐    ┌─────────────────┐   ┌──────────┐   │
        │  │  Lowest Latency │    │ Highest Latency │   │ Balanced │   │
        │  │  Highest Thru.  │    │ Lowest Thru.    │   │ Modern   │   │
        │  └─────────────────┘    └─────────────────┘   └──────────┘   │
        └─────────────────────────────────────────────────────────────┘
        */
        
        for (int threadCount : THREAD_COUNTS) {
            std::cout << "\n--- " << threadCount << "개 스레드 테스트 ---" << std::endl;
            
            // 여러 라운드 테스트하여 평균 계산
            double criticalSectionAvg = 0;
            double mutexAvg = 0;
            double srwLockAvg = 0;
            
            for (int round = 0; round < TEST_ROUNDS; ++round) {
                criticalSectionAvg += TestCriticalSection(threadCount);
                mutexAvg += TestMutex(threadCount);
                srwLockAvg += TestSRWLock(threadCount);
            }
            
            criticalSectionAvg /= TEST_ROUNDS;
            mutexAvg /= TEST_ROUNDS;
            srwLockAvg /= TEST_ROUNDS;
            
            // 결과 출력
            std::cout << "Critical Section: " << static_cast<int>(criticalSectionAvg) << "ms" << std::endl;
            std::cout << "Mutex:           " << static_cast<int>(mutexAvg) << "ms" << std::endl;
            std::cout << "SRWLock:         " << static_cast<int>(srwLockAvg) << "ms" << std::endl;
            
            // 상대적 성능 비교
            double mutexRatio = mutexAvg / criticalSectionAvg;
            double srwRatio = srwLockAvg / criticalSectionAvg;
            
            std::cout << "Mutex는 Critical Section보다 " << std::fixed << std::setprecision(2) 
                      << mutexRatio << "배 느림" << std::endl;
            std::cout << "SRWLock는 Critical Section보다 " << std::fixed << std::setprecision(2) 
                      << srwRatio << "배 " << (srwRatio > 1.0 ? "느림" : "빠름") << std::endl;
        }
        
        // 메모리 가시성 테스트
        TestMemoryVisibility();
    }
    
private:
    double TestCriticalSection(int threadCount) {
        m_criticalSectionData.counter = 0;
        m_criticalSectionData.checksum = 0;
        
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<std::thread> threads;
        int iterationsPerThread = ITERATIONS / threadCount;
        
        for (int i = 0; i < threadCount; ++i) {
            threads.emplace_back([this, iterationsPerThread]() {
                for (int j = 0; j < iterationsPerThread; ++j) {
                    EnterCriticalSection(&m_criticalSection);
                    
                    // 실제 작업 시뮬레이션
                    m_criticalSectionData.counter++;
                    m_criticalSectionData.checksum += m_criticalSectionData.counter;
                    
                    LeaveCriticalSection(&m_criticalSection);
                }
            });
        }
        
        for (auto& thread : threads) {
            thread.join();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        // 데이터 무결성 검증
        int expectedCounter = ITERATIONS;
        long long expectedChecksum = static_cast<long long>(expectedCounter) * (expectedCounter + 1) / 2;
        
        if (m_criticalSectionData.counter != expectedCounter || 
            m_criticalSectionData.checksum != expectedChecksum) {
            std::cout << "Critical Section 데이터 무결성 오류!" << std::endl;
        }
        
        return duration.count();
    }
    
    double TestMutex(int threadCount) {
        m_mutexData.counter = 0;
        m_mutexData.checksum = 0;
        
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<std::thread> threads;
        int iterationsPerThread = ITERATIONS / threadCount;
        
        for (int i = 0; i < threadCount; ++i) {
            threads.emplace_back([this, iterationsPerThread]() {
                for (int j = 0; j < iterationsPerThread; ++j) {
                    WaitForSingleObject(m_mutex, INFINITE);
                    
                    // 실제 작업 시뮬레이션
                    m_mutexData.counter++;
                    m_mutexData.checksum += m_mutexData.counter;
                    
                    ReleaseMutex(m_mutex);
                }
            });
        }
        
        for (auto& thread : threads) {
            thread.join();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        return duration.count();
    }
    
    double TestSRWLock(int threadCount) {
        m_srwLockData.counter = 0;
        m_srwLockData.checksum = 0;
        
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<std::thread> threads;
        int iterationsPerThread = ITERATIONS / threadCount;
        
        for (int i = 0; i < threadCount; ++i) {
            threads.emplace_back([this, iterationsPerThread]() {
                for (int j = 0; j < iterationsPerThread; ++j) {
                    AcquireSRWLockExclusive(&m_srwLock);
                    
                    // 실제 작업 시뮬레이션
                    m_srwLockData.counter++;
                    m_srwLockData.checksum += m_srwLockData.counter;
                    
                    ReleaseSRWLockExclusive(&m_srwLock);
                }
            });
        }
        
        for (auto& thread : threads) {
            thread.join();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        return duration.count();
    }
    
    void TestMemoryVisibility() {
        std::cout << "\n=== 메모리 가시성 테스트 ===" << std::endl;
        
        const int TEST_ITERATIONS = 1000000;
        std::atomic<bool> ready{false};
        std::atomic<int> visibilityErrors{0};
        
        // Critical Section 메모리 가시성 테스트
        std::thread writer([this, &ready, TEST_ITERATIONS]() {
            for (int i = 0; i < TEST_ITERATIONS; ++i) {
                EnterCriticalSection(&m_criticalSection);
                m_criticalSectionData.counter = i;
                m_criticalSectionData.checksum = i * 2;
                LeaveCriticalSection(&m_criticalSection);
                
                if (i == 1000) ready = true; // 리더 시작 신호
            }
        });
        
        std::thread reader([this, &ready, &visibilityErrors, TEST_ITERATIONS]() {
            while (!ready.load()) std::this_thread::yield();
            
            int lastCounter = -1;
            for (int i = 0; i < TEST_ITERATIONS; ++i) {
                EnterCriticalSection(&m_criticalSection);
                int counter = m_criticalSectionData.counter;
                int checksum = m_criticalSectionData.checksum;
                LeaveCriticalSection(&m_criticalSection);
                
                // 일관성 검사
                if (checksum != counter * 2) {
                    visibilityErrors.fetch_add(1);
                }
                
                if (counter < lastCounter) {
                    visibilityErrors.fetch_add(1);
                }
                lastCounter = counter;
            }
        });
        
        writer.join();
        reader.join();
        
        std::cout << "메모리 가시성 오류 횟수: " << visibilityErrors.load() << std::endl;
    }
};
```

### 5.1.2 게임 서버 시나리오별 동기화 객체 선택

```cpp
// 게임 서버의 다양한 시나리오에 적합한 동기화 객체 선택 가이드
class GameServerSyncGuide {
private:
    // 플레이어 데이터 캐시 (고빈도 읽기/쓰기)
    struct PlayerData {
        int playerId;
        float x, y, z;
        int health;
        int score;
        std::chrono::steady_clock::time_point lastUpdate;
    };
    
    // 시나리오 1: 플레이어 위치 업데이트 (매우 빈번한 업데이트)
    class PlayerPositionManager {
    private:
        std::unordered_map<int, PlayerData> m_players;
        CRITICAL_SECTION m_cs; // 빠른 업데이트를 위해 Critical Section 사용
        
    public:
        PlayerPositionManager() {
            InitializeCriticalSection(&m_cs);
        }
        
        ~PlayerPositionManager() {
            DeleteCriticalSection(&m_cs);
        }
        
        void UpdatePosition(int playerId, float x, float y, float z) {
            EnterCriticalSection(&m_cs);
            
            auto& player = m_players[playerId];
            player.playerId = playerId;
            player.x = x;
            player.y = y;
            player.z = z;
            player.lastUpdate = std::chrono::steady_clock::now();
            
            LeaveCriticalSection(&m_cs);
        }
        
        bool GetPosition(int playerId, float& x, float& y, float& z) {
            EnterCriticalSection(&m_cs);
            
            auto it = m_players.find(playerId);
            if (it != m_players.end()) {
                x = it->second.x;
                y = it->second.y;
                z = it->second.z;
                LeaveCriticalSection(&m_cs);
                return true;
            }
            
            LeaveCriticalSection(&m_cs);
            return false;
        }
    };
    
    // 시나리오 2: 로그 메시지 큐 (프로세스 간 공유 필요)
    class CrossProcessLogQueue {
    private:
        HANDLE m_mutex; // 프로세스 간 동기화를 위해 Mutex 사용
        std::queue<std::string> m_logQueue;
        static constexpr size_t MAX_QUEUE_SIZE = 10000;
        
    public:
        CrossProcessLogQueue() {
            // 명명된 뮤텍스 생성 (프로세스 간 공유)
            m_mutex = CreateMutexW(nullptr, FALSE, L"GameServerLogMutex");
            if (m_mutex == nullptr) {
                throw std::runtime_error("뮤텍스 생성 실패");
            }
        }
        
        ~CrossProcessLogQueue() {
            if (m_mutex != nullptr) {
                CloseHandle(m_mutex);
            }
        }
        
        bool AddLog(const std::string& message, DWORD timeoutMs = 1000) {
            DWORD result = WaitForSingleObject(m_mutex, timeoutMs);
            if (result != WAIT_OBJECT_0) {
                return false; // 타임아웃 또는 오류
            }
            
            // 큐 크기 제한
            if (m_logQueue.size() >= MAX_QUEUE_SIZE) {
                m_logQueue.pop(); // 오래된 로그 제거
            }
            
            m_logQueue.push(message);
            
            ReleaseMutex(m_mutex);
            return true;
        }
        
        bool GetLog(std::string& message, DWORD timeoutMs = 1000) {
            DWORD result = WaitForSingleObject(m_mutex, timeoutMs);
            if (result != WAIT_OBJECT_0) {
                return false;
            }
            
            bool hasMessage = false;
            if (!m_logQueue.empty()) {
                message = m_logQueue.front();
                m_logQueue.pop();
                hasMessage = true;
            }
            
            ReleaseMutex(m_mutex);
            return hasMessage;
        }
    };
    
    // 시나리오 3: 게임 월드 상태 (읽기 빈번, 쓰기 드문 경우)
    class GameWorldState {
    private:
        struct WorldData {
            int weatherType;
            float temperature;
            bool dayTime;
            std::vector<int> globalBuffs;
        } m_worldData;
        
        SRWLOCK m_srwLock; // Reader-Writer Lock 사용
        
    public:
        GameWorldState() {
            InitializeSRWLock(&m_srwLock);
            
            // 초기값 설정
            m_worldData.weatherType = 0; // 맑음
            m_worldData.temperature = 25.0f;
            m_worldData.dayTime = true;
        }
        
        // 읽기 전용 접근 (여러 스레드가 동시에 가능)
        WorldData GetWorldState() {
            AcquireSRWLockShared(&m_srwLock);
            WorldData data = m_worldData;
            ReleaseSRWLockShared(&m_srwLock);
            return data;
        }
        
        // 쓰기 접근 (배타적)
        void UpdateWeather(int weatherType, float temperature) {
            AcquireSRWLockExclusive(&m_srwLock);
            m_worldData.weatherType = weatherType;
            m_worldData.temperature = temperature;
            ReleaseSRWLockExclusive(&m_srwLock);
        }
        
        void SetDayTime(bool isDayTime) {
            AcquireSRWLockExclusive(&m_srwLock);
            m_worldData.dayTime = isDayTime;
            ReleaseSRWLockExclusive(&m_srwLock);
        }
        
        void AddGlobalBuff(int buffId) {
            AcquireSRWLockExclusive(&m_srwLock);
            m_worldData.globalBuffs.push_back(buffId);
            ReleaseSRWLockExclusive(&m_srwLock);
        }
    };
    
public:
    void DemonstrateScenarios() {
        std::cout << "\n=== 게임 서버 시나리오별 동기화 객체 선택 ===" << std::endl;
        
        /*
        ┌─────────────────────────────────────────────────────────────┐
        │                 Synchronization Selection Guide             │
        ├─────────────────────────────────────────────────────────────┤
        │                                                             │
        │  High Frequency Updates    Cross Process       Read Heavy   │
        │  (Player Position)         (Logging)           (World Data) │
        │  ┌─────────────────┐      ┌─────────────────┐  ┌──────────┐ │
        │  │ Critical Section│      │     Mutex       │  │ SRWLock  │ │
        │  │                 │      │                 │  │          │ │
        │  │ ✓ Fastest       │      │ ✓ Cross Process │  │✓ Readers │ │
        │  │ ✓ Low Overhead  │      │ ✓ Named Object  │  │✓ Writers │ │
        │  │ ✗ Process Only  │      │ ✗ Slow          │  │✓ Scale   │ │
        │  └─────────────────┘      └─────────────────┘  └──────────┘ │
        └─────────────────────────────────────────────────────────────┘
        */
        
        // 시나리오 1: 플레이어 위치 업데이트 테스트
        TestPlayerPositionUpdates();
        
        // 시나리오 2: 크로스 프로세스 로깅 테스트
        TestCrossProcessLogging();
        
        // 시나리오 3: 게임 월드 상태 테스트
        TestGameWorldState();
    }
    
private:
    void TestPlayerPositionUpdates() {
        std::cout << "\n--- 플레이어 위치 업데이트 테스트 ---" << std::endl;
        
        PlayerPositionManager posManager;
        const int PLAYER_COUNT = 1000;
        const int UPDATES_PER_PLAYER = 1000;
        
        auto start = std::chrono::high_resolution_clock::now();
        
        // 여러 스레드에서 플레이어 위치 업데이트
        std::vector<std::thread> updateThreads;
        for (int t = 0; t < 4; ++t) {
            updateThreads.emplace_back([&posManager, t, PLAYER_COUNT, UPDATES_PER_PLAYER]() {
                std::random_device rd;
                std::mt19937 gen(rd() + t);
                std::uniform_real_distribution<float> posDis(-1000.0f, 1000.0f);
                std::uniform_int_distribution<int> playerDis(0, PLAYER_COUNT - 1);
                
                for (int i = 0; i < UPDATES_PER_PLAYER; ++i) {
                    int playerId = playerDis(gen);
                    float x = posDis(gen);
                    float y = posDis(gen);
                    float z = posDis(gen);
                    
                    posManager.UpdatePosition(playerId, x, y, z);
                }
            });
        }
        
        // 읽기 스레드
        std::atomic<int> readCount{0};
        std::vector<std::thread> readThreads;
        for (int t = 0; t < 2; ++t) {
            readThreads.emplace_back([&posManager, &readCount, PLAYER_COUNT]() {
                std::random_device rd;
                std::mt19937 gen(rd());
                std::uniform_int_distribution<int> playerDis(0, PLAYER_COUNT - 1);
                
                for (int i = 0; i < 5000; ++i) {
                    int playerId = playerDis(gen);
                    float x, y, z;
                    if (posManager.GetPosition(playerId, x, y, z)) {
                        readCount.fetch_add(1);
                    }
                }
            });
        }
        
        for (auto& thread : updateThreads) {
            thread.join();
        }
        for (auto& thread : readThreads) {
            thread.join();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << "총 " << PLAYER_COUNT * UPDATES_PER_PLAYER << "회 업데이트 완료" << std::endl;
        std::cout << "총 " << readCount.load() << "회 읽기 완료" << std::endl;
        std::cout << "소요 시간: " << duration.count() << "ms" << std::endl;
    }
    
    void TestCrossProcessLogging() {
        std::cout << "\n--- 크로스 프로세스 로깅 테스트 ---" << std::endl;
        
        try {
            CrossProcessLogQueue logQueue;
            const int LOG_COUNT = 1000;
            
            auto start = std::chrono::high_resolution_clock::now();
            
            // 로그 생성 스레드
            std::thread producer([&logQueue, LOG_COUNT]() {
                for (int i = 0; i < LOG_COUNT; ++i) {
                    std::string logMessage = "Log message " + std::to_string(i) + 
                                           " from thread " + std::to_string(GetCurrentThreadId());
                    
                    if (!logQueue.AddLog(logMessage, 100)) {
                        std::cout << "로그 추가 실패: " << i << std::endl;
                    }
                    
                    if (i % 100 == 0) {
                        Sleep(1); // 약간의 지연
                    }
                }
            });
            
            // 로그 소비 스레드
            std::atomic<int> processedLogs{0};
            std::thread consumer([&logQueue, &processedLogs]() {
                std::string message;
                while (processedLogs.load() < LOG_COUNT) {
                    if (logQueue.GetLog(message, 100)) {
                        processedLogs.fetch_add(1);
                        if (processedLogs.load() % 200 == 0) {
                            std::cout << "처리된 로그: " << processedLogs.load() << std::endl;
                        }
                    }
                }
            });
            
            producer.join();
            consumer.join();
            
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
            
            std::cout << "로그 처리 완료: " << processedLogs.load() << "/" << LOG_COUNT << std::endl;
            std::cout << "소요 시간: " << duration.count() << "ms" << std::endl;
            
        } catch (const std::exception& e) {
            std::cout << "크로스 프로세스 로깅 테스트 실패: " << e.what() << std::endl;
        }
    }
    
    void TestGameWorldState() {
        std::cout << "\n--- 게임 월드 상태 테스트 ---" << std::endl;
        
        GameWorldState worldState;
        const int READ_ITERATIONS = 100000;
        const int WRITE_ITERATIONS = 100;
        
        auto start = std::chrono::high_resolution_clock::now();
        
        // 다수의 읽기 스레드 (플레이어들이 월드 상태 조회)
        std::vector<std::thread> readers;
        std::atomic<int> totalReads{0};
        
        for (int t = 0; t < 8; ++t) {
            readers.emplace_back([&worldState, &totalReads, READ_ITERATIONS]() {
                for (int i = 0; i < READ_ITERATIONS / 8; ++i) {
                    auto data = worldState.GetWorldState();
                    totalReads.fetch_add(1);
                    
                    // 데이터 사용 시뮬레이션
                    volatile float temp = data.temperature;
                    volatile bool day = data.dayTime;
                    (void)temp;
                    (void)day;
                }
            });
        }
        
        // 소수의 쓰기 스레드 (게임 마스터가 월드 상태 변경)
        std::vector<std::thread> writers;
        
        // 날씨 변경 스레드
        writers.emplace_back([&worldState, WRITE_ITERATIONS]() {
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<int> weatherDis(0, 4);
            std::uniform_real_distribution<float> tempDis(-10.0f, 40.0f);
            
            for (int i = 0; i < WRITE_ITERATIONS; ++i) {
                worldState.UpdateWeather(weatherDis(gen), tempDis(gen));
                Sleep(10); // 날씨는 자주 바뀌지 않음
            }
        });
        
        // 낮/밤 전환 스레드
        writers.emplace_back([&worldState, WRITE_ITERATIONS]() {
            for (int i = 0; i < WRITE_ITERATIONS / 10; ++i) {
                worldState.SetDayTime(i % 2 == 0);
                Sleep(100); // 낮/밤은 더욱 드물게 변경
            }
        });
        
        // 글로벌 버프 추가 스레드
        writers.emplace_back([&worldState, WRITE_ITERATIONS]() {
            for (int i = 0; i < WRITE_ITERATIONS / 5; ++i) {
                worldState.AddGlobalBuff(1000 + i);
                Sleep(50);
            }
        });
        
        // 모든 스레드 완료 대기
        for (auto& reader : readers) {
            reader.join();
        }
        for (auto& writer : writers) {
            writer.join();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << "총 읽기 작업: " << totalReads.load() << std::endl;
        std::cout << "소요 시간: " << duration.count() << "ms" << std::endl;
        std::cout << "초당 읽기 작업: " << (totalReads.load() * 1000 / duration.count()) << std::endl;
    }
};
```
    
이 코드는 **게임 서버에서 발생하는 다양한 동시성 시나리오에 맞춰 적절한 동기화 객체를 선택하는 방법을 설명하기 위한 예제**이다.
게임 서버는 여러 스레드가 동시에 데이터를 읽고 쓰는 환경이므로, 잘못된 동기화 방식은 **데이터 무결성 문제나 성능 저하**를 일으킬 수 있다.
따라서 각 상황의 **데이터 접근 패턴(읽기/쓰기 빈도, 프로세스 간 공유 여부)**에 따라 알맞은 동기화 객체를 사용하는 것이 중요하다.

이 코드에서는 다음 세 가지 대표적인 시나리오를 다룬다.

1. **플레이어 위치 업데이트** – 매우 빈번한 쓰기/읽기가 발생하는 데이터
2. **로그 메시지 큐** – 여러 프로세스 간 공유되는 자원
3. **게임 월드 상태** – 읽기 빈도가 높고 쓰기는 드문 데이터


#### 1️⃣ 시나리오 1: 플레이어 위치 업데이트 (Critical Section)

#### 코드 요약

```cpp
class PlayerPositionManager {
private:
    std::unordered_map<int, PlayerData> m_players;
    CRITICAL_SECTION m_cs;
public:
    void UpdatePosition(int playerId, float x, float y, float z);
    bool GetPosition(int playerId, float& x, float& y, float& z);
};
```

이 클래스는 플레이어의 위치를 관리하는 매니저다.
여기서는 `CRITICAL_SECTION`을 사용해 다중 스레드 간 동시 접근을 제어한다.

#### 핵심 설명

* `CRITICAL_SECTION`은 **한 프로세스 내에서만 유효한 가벼운 락**이다.
* 매우 빠르고, **짧은 시간 동안 빈번한 업데이트**가 발생하는 경우에 적합하다.
* `EnterCriticalSection`과 `LeaveCriticalSection`으로 잠금과 해제를 수행한다.

이 방식은 CPU 캐시 친화적이고 오버헤드가 적기 때문에, **플레이어 좌표나 체력처럼 자주 갱신되는 데이터**를 보호하기에 적합하다.

#### 정리

| 항목     | 설명                     |
| ------ | ---------------------- |
| 동기화 객체 | `CRITICAL_SECTION`     |
| 사용 목적  | 단일 프로세스 내 빈번한 읽기/쓰기 보호 |
| 장점     | 빠름, 오버헤드 낮음            |
| 단점     | 프로세스 간 공유 불가           |


#### 2️⃣ 시나리오 2: 로그 메시지 큐 (Mutex)

#### 코드 요약

```cpp
class CrossProcessLogQueue {
private:
    HANDLE m_mutex;
    std::queue<std::string> m_logQueue;
public:
    bool AddLog(const std::string& message, DWORD timeoutMs = 1000);
    bool GetLog(std::string& message, DWORD timeoutMs = 1000);
};
```

이 클래스는 **서버 로그를 여러 프로세스가 동시에 접근할 수 있도록 관리하는 큐**를 구현한다.
`CreateMutexW`로 이름 있는 Mutex를 생성해, **프로세스 간 자원 접근을 동기화**한다.

#### 핵심 설명

* `Mutex`는 **프로세스 간 공유가 가능한 동기화 객체**이다.
* `WaitForSingleObject`로 락을 획득하고, `ReleaseMutex`로 해제한다.
* 타임아웃을 지정할 수 있어 **대기 시간 관리**도 가능하다.
* 큐 크기가 일정 이상이면 오래된 로그를 제거해 **메모리 과부하를 방지**한다.

#### 정리

| 항목     | 설명                     |
| ------ | ---------------------- |
| 동기화 객체 | `Mutex`                |
| 사용 목적  | 여러 프로세스 간 공유되는 자원 보호   |
| 장점     | 프로세스 간 사용 가능, 안전성 높음   |
| 단점     | 상대적으로 느림, 시스템 자원 사용 많음 |

#### 예시 시나리오

* 여러 서버 프로세스가 같은 로그 파일이나 콘솔에 로그를 남겨야 하는 경우
* 외부 모듈(예: CrashReporter, Watchdog)과 로그를 공유할 때

#### 3️⃣ 시나리오 3: 게임 월드 상태 (SRWLock)

#### 코드 요약

```cpp
class GameWorldState {
private:
    struct WorldData {
        int weatherType;
        float temperature;
        bool dayTime;
        std::vector<int> globalBuffs;
    } m_worldData;
    SRWLOCK m_srwLock;
public:
    WorldData GetWorldState();
    void UpdateWeather(int weatherType, float temperature);
    void SetDayTime(bool isDayTime);
    void AddGlobalBuff(int buffId);
};
```

이 클래스는 **게임 월드의 전체적인 상태(날씨, 시간, 버프 등)**를 관리한다.
이 데이터는 **읽기는 매우 빈번하지만, 쓰기는 드물게 발생**한다.

#### 핵심 설명

* `SRWLock`(Slim Reader/Writer Lock)은 **읽기-쓰기 구분이 가능한 락**이다.
* `AcquireSRWLockShared`는 다중 스레드가 동시에 읽을 수 있도록 허용한다.
* `AcquireSRWLockExclusive`는 쓰기 시 단 하나의 스레드만 접근하게 한다.
* 따라서 **읽기 병렬성을 높이면서 쓰기 충돌을 방지**할 수 있다.

#### 정리

| 항목     | 설명                            |
| ------ | ----------------------------- |
| 동기화 객체 | `SRWLock`                     |
| 사용 목적  | 읽기 빈번, 쓰기 드문 데이터 보호           |
| 장점     | 읽기 병렬성, 고성능                   |
| 단점     | Windows 전용, 오래된 시스템에서는 제한적 지원 |

#### 예시 시나리오

* 플레이어가 월드 정보를 자주 조회하지만, 서버가 날씨를 바꾸는 경우는 드문 상황
* 대규모 MMORPG의 환경 상태 관리


#### 4️⃣ 종합 비교표

| 시나리오     | 데이터 특성       | 동기화 객체             | 주요 특징                |
| -------- | ------------ | ------------------ | -------------------- |
| 플레이어 위치  | 쓰기/읽기 매우 빈번  | `CRITICAL_SECTION` | 빠르고 가벼움 (프로세스 내부 전용) |
| 로그 메시지 큐 | 프로세스 간 공유 필요 | `Mutex`            | 안정적이나 느림             |
| 게임 월드 상태 | 읽기 빈번, 쓰기 드묾 | `SRWLock`          | 읽기 병렬 처리 가능, 효율적     |


#### 5️⃣ 결론
게임 서버에서의 동기화 객체 선택은 **데이터 접근 패턴**에 따라 달라진다.

* **속도와 빈도**가 중요하다면 `CRITICAL_SECTION`을,
* **프로세스 간 자원 공유**가 필요하다면 `Mutex`를,
* **읽기 중심 데이터**라면 `SRWLock`을 선택하는 것이 합리적이다.

이와 같은 원칙을 적용하면 **성능과 안정성을 모두 확보한 서버 구조**를 설계할 수 있다.



</br>  

## 5.2 Semaphore와 Event 활용

### 5.2.1 Semaphore를 이용한 리소스 풀 관리
게임 서버에서 데이터베이스 연결, 네트워크 소켓 등 제한된 리소스를 관리할 때 Semaphore가 유용하다.

```cpp
#include <queue>
#include <memory>

// 데이터베이스 연결 시뮬레이션
class DatabaseConnection {
private:
    int m_connectionId;
    bool m_inUse;
    std::chrono::steady_clock::time_point m_createdTime;
    
public:
    DatabaseConnection(int id) : m_connectionId(id), m_inUse(false) {
        m_createdTime = std::chrono::steady_clock::now();
        
        // 연결 설정 시뮬레이션
        Sleep(100);
        std::cout << "DB 연결 " << m_connectionId << " 생성됨" << std::endl;
    }
    
    ~DatabaseConnection() {
        std::cout << "DB 연결 " << m_connectionId << " 소멸됨" << std::endl;
    }
    
    bool ExecuteQuery(const std::string& query) {
        if (m_inUse) return false;
        
        m_inUse = true;
        
        // 쿼리 실행 시뮬레이션
        std::cout << "DB 연결 " << m_connectionId << " 쿼리 실행: " << query << std::endl;
        Sleep(50 + (rand() % 100)); // 50-150ms 랜덤 지연
        
        m_inUse = false;
        return true;
    }
    
    int GetId() const { return m_connectionId; }
    bool IsInUse() const { return m_inUse; }
    
    std::chrono::milliseconds GetAge() const {
        auto now = std::chrono::steady_clock::now();
        return std::chrono::duration_cast<std::chrono::milliseconds>(now - m_createdTime);
    }
};

class DatabaseConnectionPool {
private:
    std::queue<std::unique_ptr<DatabaseConnection>> m_availableConnections;
    std::vector<std::unique_ptr<DatabaseConnection>> m_allConnections;
    HANDLE m_semaphore;
    CRITICAL_SECTION m_poolCS;
    
    int m_maxConnections;
    int m_currentConnections;
    std::atomic<int> m_totalQueries;
    std::atomic<int> m_successfulQueries;
    
public:
    DatabaseConnectionPool(int maxConnections = 10) 
        : m_maxConnections(maxConnections), m_currentConnections(0),
          m_totalQueries(0), m_successfulQueries(0) {
        
        // 세마포어 생성 (최대 연결 수만큼 허용)
        m_semaphore = CreateSemaphore(
            nullptr,                // 보안 속성
            maxConnections,         // 초기 카운트
            maxConnections,         // 최대 카운트
            nullptr                 // 이름
        );
        
        if (m_semaphore == nullptr) {
            throw std::runtime_error("세마포어 생성 실패");
        }
        
        InitializeCriticalSection(&m_poolCS);
        
        // 초기 연결들 생성
        for (int i = 0; i < maxConnections; ++i) {
            auto connection = std::make_unique<DatabaseConnection>(i + 1);
            m_availableConnections.push(std::move(connection));
        }
        m_currentConnections = maxConnections;
        
        std::cout << "데이터베이스 연결 풀 생성됨 (최대 " << maxConnections << "개 연결)" << std::endl;
        
        /*
        ┌─────────────────────────────────────────────────────────────┐
        │                Database Connection Pool                      │
        ├─────────────────────────────────────────────────────────────┤
        │                                                             │
        │        Semaphore (Count = Available Connections)            │
        │        ┌─────────────────────────────────────────┐          │
        │        │  Initial Count = Max Connections        │          │
        │        │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐        │          │
        │        │  │ DB1 │ │ DB2 │ │ DB3 │ │ ... │        │          │
        │        │  └─────┘ └─────┘ └─────┘ └─────┘        │          │
        │        └─────────────────────────────────────────┘          │
        │                         │                                   │
        │                         ▼                                   │
        │        ┌─────────────────────────────────────────┐          │
        │        │           Client Requests               │          │
        │        │                                         │          │
        │        │  Wait(Semaphore) → Get Connection       │          │
        │        │  Execute Query                          │          │
        │        │  Return Connection → Release(Semaphore) │          │
        │        └─────────────────────────────────────────┘          │
        └─────────────────────────────────────────────────────────────┘
        */
    }
    
    ~DatabaseConnectionPool() {
        if (m_semaphore != nullptr) {
            CloseHandle(m_semaphore);
        }
        DeleteCriticalSection(&m_poolCS);
        
        std::cout << "데이터베이스 연결 풀 소멸됨" << std::endl;
    }
    
    class ConnectionGuard {
    private:
        DatabaseConnectionPool* m_pool;
        DatabaseConnection* m_connection;
        
    public:
        ConnectionGuard(DatabaseConnectionPool* pool, DatabaseConnection* conn)
            : m_pool(pool), m_connection(conn) {}
        
        ~ConnectionGuard() {
            if (m_pool && m_connection) {
                m_pool->ReturnConnection(m_connection);
            }
        }
        
        DatabaseConnection* operator->() { return m_connection; }
        DatabaseConnection* Get() { return m_connection; }
        bool IsValid() const { return m_connection != nullptr; }
    };
    
    ConnectionGuard AcquireConnection(DWORD timeoutMs = 5000) {
        m_totalQueries.fetch_add(1);
        
        // 세마포어 대기 (사용 가능한 연결이 있을 때까지)
        DWORD waitResult = WaitForSingleObject(m_semaphore, timeoutMs);
        
        if (waitResult != WAIT_OBJECT_0) {
            std::cout << "연결 획득 실패 - ";
            if (waitResult == WAIT_TIMEOUT) {
                std::cout << "타임아웃" << std::endl;
            } else {
                std::cout << "오류 코드: " << GetLastError() << std::endl;
            }
            return ConnectionGuard(nullptr, nullptr);
        }
        
        // 연결 풀에서 연결 가져오기
        EnterCriticalSection(&m_poolCS);
        
        DatabaseConnection* connection = nullptr;
        if (!m_availableConnections.empty()) {
            connection = m_availableConnections.front().release();
            m_availableConnections.pop();
        }
        
        LeaveCriticalSection(&m_poolCS);
        
        if (connection == nullptr) {
            // 세마포어 카운트 복원
            ReleaseSemaphore(m_semaphore, 1, nullptr);
            std::cout << "연결 풀에서 연결을 가져올 수 없음" << std::endl;
            return ConnectionGuard(nullptr, nullptr);
        }
        
        return ConnectionGuard(this, connection);
    }
    
    void ReturnConnection(DatabaseConnection* connection) {
        if (connection == nullptr) return;
        
        EnterCriticalSection(&m_poolCS);
        m_availableConnections.push(std::unique_ptr<DatabaseConnection>(connection));
        LeaveCriticalSection(&m_poolCS);
        
        // 세마포어 카운트 증가 (사용 가능한 연결 수 증가)
        ReleaseSemaphore(m_semaphore, 1, nullptr);
        
        m_successfulQueries.fetch_add(1);
    }
    
    void PrintStatistics() {
        std::cout << "\n=== 연결 풀 통계 ===" << std::endl;
        std::cout << "총 요청 수: " << m_totalQueries.load() << std::endl;
        std::cout << "성공한 쿼리: " << m_successfulQueries.load() << std::endl;
        std::cout << "성공률: " << (m_successfulQueries.load() * 100.0 / m_totalQueries.load()) << "%" << std::endl;
        
        EnterCriticalSection(&m_poolCS);
        std::cout << "사용 가능한 연결: " << m_availableConnections.size() << "/" << m_maxConnections << std::endl;
        LeaveCriticalSection(&m_poolCS);
    }
};

// 세마포어 활용 예제
void TestDatabaseConnectionPool() {
    std::cout << "\n=== 데이터베이스 연결 풀 테스트 ===" << std::endl;
    
    DatabaseConnectionPool pool(5); // 최대 5개 연결
    
    // 동시에 많은 클라이언트가 DB 작업 요청
    std::vector<std::thread> clients;
    const int CLIENT_COUNT = 20;
    const int QUERIES_PER_CLIENT = 10;
    
    for (int clientId = 0; clientId < CLIENT_COUNT; ++clientId) {
        clients.emplace_back([&pool, clientId, QUERIES_PER_CLIENT]() {
            std::random_device rd;
            std::mt19937 gen(rd() + clientId);
            std::uniform_int_distribution<int> queryTypeDis(1, 4);
            
            for (int i = 0; i < QUERIES_PER_CLIENT; ++i) {
                // 연결 획득 시도
                auto connectionGuard = pool.AcquireConnection(2000); // 2초 타임아웃
                
                if (connectionGuard.IsValid()) {
                    // 쿼리 타입 결정
                    int queryType = queryTypeDis(gen);
                    std::string query;
                    
                    switch (queryType) {
                        case 1:
                            query = "SELECT * FROM players WHERE id = " + std::to_string(clientId);
                            break;
                        case 2:
                            query = "UPDATE player_stats SET score = score + 100 WHERE id = " + std::to_string(clientId);
                            break;
                        case 3:
                            query = "INSERT INTO game_events (player_id, event) VALUES (" + std::to_string(clientId) + ", 'LOGIN')";
                            break;
                        case 4:
                            query = "SELECT COUNT(*) FROM online_players";
                            break;
                    }
                    
                    // 쿼리 실행
                    connectionGuard->ExecuteQuery(query);
                    
                } else {
                    std::cout << "클라이언트 " << clientId << " 연결 획득 실패" << std::endl;
                }
                
                // 클라이언트 간 요청 간격
                Sleep(50 + (rand() % 100));
            }
        });
    }
    
    // 모든 클라이언트 완료 대기
    for (auto& client : clients) {
        client.join();
    }
    
    pool.PrintStatistics();
}
```
   
이 예제는 **게임 서버에서 제한된 리소스를 효율적으로 관리하기 위한 `Semaphore`(세마포어) 사용법을 설명하는 코드**이다.
게임 서버는 동시에 수많은 클라이언트 요청을 처리해야 하며, 그 과정에서 **데이터베이스 연결, 네트워크 소켓, 파일 핸들**과 같은 자원이 한정되어 있다.
따라서 서버는 이러한 자원을 **필요할 때만 빌려 쓰고, 사용이 끝나면 반납**해야 한다.
이때 유용하게 사용할 수 있는 것이 바로 **세마포어(Semaphore)**이다.

세마포어는 **동시에 접근할 수 있는 자원의 개수를 제한하는 동기화 객체**로,
여러 스레드가 경쟁적으로 자원을 사용하려 할 때 안전하게 접근을 제어한다.


#### 1️⃣ DatabaseConnection 클래스 – 리소스 단위 객체
먼저 `DatabaseConnection` 클래스는 실제 데이터베이스 연결을 시뮬레이션하는 객체다.
이 클래스는 **하나의 DB 연결 단위**를 나타내며, 생성·소멸 과정과 쿼리 실행을 단순화한 형태로 구현되어 있다.

```cpp
class DatabaseConnection {
private:
    int m_connectionId;
    bool m_inUse;
    std::chrono::steady_clock::time_point m_createdTime;
public:
    DatabaseConnection(int id);
    ~DatabaseConnection();
    bool ExecuteQuery(const std::string& query);
};
```

#### 주요 동작

* **생성자**: 연결 ID를 설정하고, 연결 생성 시간을 기록한다. (Sleep으로 지연 시뮬레이션)
* **소멸자**: 연결이 해제될 때 메시지를 출력한다.
* **ExecuteQuery()**: 실제 쿼리를 수행하는 것처럼 동작하며, 랜덤 지연을 통해 실행 시간을 흉내 낸다.

이 객체는 실서비스 환경이라면 DB 소켓이나 TCP 연결과 같은 실제 자원으로 대체될 수 있다.


#### 2️⃣ DatabaseConnectionPool 클래스 – 세마포어 기반 리소스 풀
`DatabaseConnectionPool`은 여러 개의 DB 연결을 미리 만들어 두고,
필요한 스레드가 요청할 때 하나씩 할당하고 반납받는 **리소스 풀(Resource Pool)** 구조를 담당한다.

```cpp
class DatabaseConnectionPool {
private:
    std::queue<std::unique_ptr<DatabaseConnection>> m_availableConnections;
    HANDLE m_semaphore;
    CRITICAL_SECTION m_poolCS;
    int m_maxConnections;
};
```

#### 핵심 구성 요소

* **`std::queue`**: 현재 사용 가능한 연결 객체들을 관리한다.
* **`CRITICAL_SECTION`**: 큐 접근을 보호하기 위한 뮤텍스 수준의 동기화 도구다.
* **`HANDLE m_semaphore`**: 사용 가능한 연결 수를 제한하는 세마포어다.
* **`m_maxConnections`**: 동시에 유지할 수 있는 최대 연결 개수다.

#### 생성자에서의 초기화

```cpp
m_semaphore = CreateSemaphore(nullptr, maxConnections, maxConnections, nullptr);
```

* 세마포어의 초기 카운트를 `maxConnections`로 설정한다.
* 즉, 풀에 최대 연결 수만큼의 “자원 토큰”이 주어진다.

이후 `DatabaseConnection` 객체들을 미리 생성하여 큐에 넣는다.
이렇게 하면 서버가 실행되자마자 즉시 DB 연결을 사용할 수 있게 된다.


#### 3️⃣ ConnectionGuard 클래스 – RAII 기반 자동 반납
리소스 반납을 깜빡 잊으면 심각한 누수가 발생할 수 있다.
이를 방지하기 위해 `ConnectionGuard`라는 **스코프 기반 자동 반환 객체**를 사용한다.

```cpp
class ConnectionGuard {
private:
    DatabaseConnectionPool* m_pool;
    DatabaseConnection* m_connection;
public:
    ~ConnectionGuard() {
        if (m_pool && m_connection)
            m_pool->ReturnConnection(m_connection);
    }
};
```

#### 설명

* `ConnectionGuard`는 연결을 얻은 시점에 생성되고,
  스코프를 벗어나면 자동으로 연결을 반환한다.
* 이는 **RAII(Resource Acquisition Is Initialization)** 패턴의 전형적인 활용 예다.

즉, 개발자가 `delete`나 `Release`를 호출하지 않아도, 객체가 소멸될 때 자동으로 정리된다.

#### 4️⃣ AcquireConnection() – 세마포어를 이용한 자원 획득
리소스를 사용할 때는 `AcquireConnection()`을 호출하여 세마포어를 대기한다.

```cpp
DWORD waitResult = WaitForSingleObject(m_semaphore, timeoutMs);
```

#### 동작 원리

1. 세마포어의 카운트가 **1 이상이면 즉시 자원 사용 가능**이다.
2. 카운트가 **0이면**, 다른 스레드가 자원을 반환할 때까지 **대기 상태**로 전환된다.
3. 지정된 `timeoutMs` 내에 자원을 얻지 못하면 실패한다.

#### 코드 예시

```cpp
auto guard = pool.AcquireConnection(5000);
if (guard.IsValid()) {
    guard->ExecuteQuery("SELECT * FROM players");
}
```

이 구문은 세마포어 카운트를 1 줄이고,
작업이 끝나면 `ConnectionGuard`의 소멸자에서 `ReturnConnection()`을 호출해
세마포어 카운트를 다시 증가시킨다.

즉, 세마포어가 “사용 중인 리소스 개수”를 관리한다.


#### 5️⃣ ReturnConnection() – 자원 반납 및 세마포어 해제
자원 사용이 끝나면 다음 과정이 자동 수행된다.

```cpp
ReleaseSemaphore(m_semaphore, 1, nullptr);
```

* 세마포어의 카운트를 증가시켜, 다른 스레드가 리소스를 획득할 수 있도록 한다.
* 동시에 `CRITICAL_SECTION`으로 보호된 큐에 반환된 연결을 다시 삽입한다.

이를 통해 “리소스 재활용”이 이루어진다.


#### 6️⃣ TestDatabaseConnectionPool() – 실제 시뮬레이션
마지막으로 `TestDatabaseConnectionPool()` 함수는
20개의 클라이언트 스레드가 5개의 DB 연결을 공유하며 동시에 작업하는 상황을 시뮬레이션한다.

```cpp
DatabaseConnectionPool pool(5);
const int CLIENT_COUNT = 20;
const int QUERIES_PER_CLIENT = 10;
```

#### 주요 동작

* 최대 5개의 연결만 동시에 사용 가능하다.
* 나머지 스레드는 세마포어 대기 상태로 들어가며,
  다른 스레드가 연결을 반납해야 다음 쿼리를 실행할 수 있다.
* 각 클라이언트는 다양한 쿼리(SELECT, UPDATE, INSERT 등)를 랜덤하게 실행한다.

마지막에 `pool.PrintStatistics()`를 통해 전체 통계를 출력한다.

```cpp
총 요청 수: 200
성공한 쿼리: 195
성공률: 97.5%
사용 가능한 연결: 5/5
```

#### 7️⃣ 전체 동작 요약 다이어그램

```
┌──────────────────────────────────────────────┐
│               Database Pool (Semaphore)      │
├──────────────────────────────────────────────┤
│ Semaphore Count = Available Connections (5)  │
│                                              │
│  Wait(Semaphore)  →  Get Connection          │
│  Execute Query     →  Return Connection       │
│  Release(Semaphore)                          │
└──────────────────────────────────────────────┘
```

#### 8️⃣ 결론
세마포어는 **동시에 사용할 수 있는 리소스의 개수를 제어하기 위한 강력한 도구**이다.
이 예제처럼 데이터베이스 연결, 파일 핸들, 소켓 등 **유한한 자원을 관리해야 하는 상황**에서 매우 효과적이다.

* `Critical Section`은 단일 프로세스 내 데이터 보호에 적합하고,
* `Mutex`는 프로세스 간 공유 자원 보호에 적합하며,
* `Semaphore`는 **자원 개수 자체를 제어**할 때 사용한다.

따라서 세마포어를 활용하면 **게임 서버의 안정성과 효율성을 동시에 확보할 수 있다.**



### 5.2.2 Event 객체를 이용한 복합 이벤트 처리
게임 서버에서 여러 조건이 동시에 만족되어야 하는 복잡한 시나리오를 Event 객체로 처리하는 방법을 알아보겠다.

```cpp
// 게임 세션 상태 관리
class GameSessionManager {
public:
    enum class SessionState {
        WAITING_FOR_PLAYERS,
        READY_TO_START,
        IN_PROGRESS,
        FINISHED
    };
    
private:
    // 각종 이벤트 객체들
    HANDLE m_allPlayersReady;     // 모든 플레이어 준비 완료
    HANDLE m_gameDataLoaded;      // 게임 데이터 로딩 완료
    HANDLE m_serverResourcesReady; // 서버 리소스 준비 완료
    HANDLE m_sessionStartEvent;   // 세션 시작 이벤트
    HANDLE m_sessionEndEvent;     // 세션 종료 이벤트
    
    // 게임 세션 정보
    struct SessionInfo {
        int sessionId;
        int maxPlayers;
        int currentPlayers;
        int readyPlayers;
        SessionState state;
        std::chrono::steady_clock::time_point startTime;
        std::vector<int> playerIds;
    } m_sessionInfo;
    
    CRITICAL_SECTION m_sessionCS;
    std::atomic<bool> m_running;
    std::thread m_sessionThread;
    
public:
    GameSessionManager(int sessionId, int maxPlayers) : m_running(false) {
        m_sessionInfo.sessionId = sessionId;
        m_sessionInfo.maxPlayers = maxPlayers;
        m_sessionInfo.currentPlayers = 0;
        m_sessionInfo.readyPlayers = 0;
        m_sessionInfo.state = SessionState::WAITING_FOR_PLAYERS;
        
        // 이벤트 객체들 생성
        m_allPlayersReady = CreateEvent(nullptr, TRUE, FALSE, nullptr);      // Manual reset
        m_gameDataLoaded = CreateEvent(nullptr, TRUE, FALSE, nullptr);       // Manual reset
        m_serverResourcesReady = CreateEvent(nullptr, TRUE, FALSE, nullptr); // Manual reset
        m_sessionStartEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);    // Manual reset
        m_sessionEndEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);      // Manual reset
        
        if (!m_allPlayersReady || !m_gameDataLoaded || !m_serverResourcesReady ||
            !m_sessionStartEvent || !m_sessionEndEvent) {
            throw std::runtime_error("이벤트 객체 생성 실패");
        }
        
        InitializeCriticalSection(&m_sessionCS);
        
        std::cout << "게임 세션 " << sessionId << " 생성됨 (최대 " << maxPlayers << "명)" << std::endl;
        
        /*
        ┌─────────────────────────────────────────────────────────────┐
        │                   Game Session Events                       │
        ├─────────────────────────────────────────────────────────────┤
        │                                                             │
        │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐  │
        │  │ Players Ready   │  │ Data Loaded     │  │ Resources   │  │
        │  │     Event       │  │     Event       │  │   Ready     │  │
        │  └─────────────────┘  └─────────────────┘  └─────────────┘  │
        │           │                    │                    │       │
        │           └────────────────────┼────────────────────┘       │
        │                                ▼                            │
        │                   ┌─────────────────────────────┐           │
        │                   │    WaitForMultipleObjects   │           │
        │                   │        (ALL events)         │           │
        │                   └─────────────────────────────┘           │
        │                                ▼                            │
        │                   ┌─────────────────────────────┐           │
        │                   │      Session Starts        │           │
        │                   └─────────────────────────────┘           │
        └─────────────────────────────────────────────────────────────┘
        */
    }
    
    ~GameSessionManager() {
        Stop();
        
        // 이벤트 객체들 정리
        if (m_allPlayersReady) CloseHandle(m_allPlayersReady);
        if (m_gameDataLoaded) CloseHandle(m_gameDataLoaded);
        if (m_serverResourcesReady) CloseHandle(m_serverResourcesReady);
        if (m_sessionStartEvent) CloseHandle(m_sessionStartEvent);
        if (m_sessionEndEvent) CloseHandle(m_sessionEndEvent);
        
        DeleteCriticalSection(&m_sessionCS);
        
        std::cout << "게임 세션 " << m_sessionInfo.sessionId << " 소멸됨" << std::endl;
    }
    
    bool Start() {
        if (m_running.load()) return false;
        
        m_running = true;
        m_sessionThread = std::thread([this]() { SessionLoop(); });
        
        // 서버 리소스 준비 시뮬레이션
        std::thread([this]() {
            Sleep(500); // 리소스 준비 시간
            SetEvent(m_serverResourcesReady);
            std::cout << "세션 " << m_sessionInfo.sessionId << " 서버 리소스 준비 완료" << std::endl;
        }).detach();
        
        // 게임 데이터 로딩 시뮬레이션
        std::thread([this]() {
            Sleep(800); // 데이터 로딩 시간
            SetEvent(m_gameDataLoaded);
            std::cout << "세션 " << m_sessionInfo.sessionId << " 게임 데이터 로딩 완료" << std::endl;
        }).detach();
        
        return true;
    }
    
    void Stop() {
        if (!m_running.load()) return;
        
        m_running = false;
        SetEvent(m_sessionEndEvent);
        
        if (m_sessionThread.joinable()) {
            m_sessionThread.join();
        }
    }
    
    bool AddPlayer(int playerId) {
        EnterCriticalSection(&m_sessionCS);
        
        bool success = false;
        if (m_sessionInfo.currentPlayers < m_sessionInfo.maxPlayers &&
            m_sessionInfo.state == SessionState::WAITING_FOR_PLAYERS) {
            
            m_sessionInfo.playerIds.push_back(playerId);
            m_sessionInfo.currentPlayers++;
            success = true;
            
            std::cout << "플레이어 " << playerId << " 세션 " << m_sessionInfo.sessionId 
                      << " 참가 (" << m_sessionInfo.currentPlayers << "/" 
                      << m_sessionInfo.maxPlayers << ")" << std::endl;
        }
        
        LeaveCriticalSection(&m_sessionCS);
        return success;
    }
    
    void PlayerReady(int playerId) {
        EnterCriticalSection(&m_sessionCS);
        
        // 플레이어가 세션에 있는지 확인
        auto it = std::find(m_sessionInfo.playerIds.begin(), 
                           m_sessionInfo.playerIds.end(), playerId);
        
        if (it != m_sessionInfo.playerIds.end()) {
            m_sessionInfo.readyPlayers++;
            
            std::cout << "플레이어 " << playerId << " 준비 완료 (" 
                      << m_sessionInfo.readyPlayers << "/" 
                      << m_sessionInfo.currentPlayers << ")" << std::endl;
            
            // 모든 플레이어가 준비되었는지 확인
            if (m_sessionInfo.readyPlayers >= m_sessionInfo.currentPlayers &&
                m_sessionInfo.currentPlayers >= 2) { // 최소 2명 필요
                SetEvent(m_allPlayersReady);
                std::cout << "세션 " << m_sessionInfo.sessionId << " 모든 플레이어 준비 완료" << std::endl;
            }
        }
        
        LeaveCriticalSection(&m_sessionCS);
    }
    
    SessionState GetState() const {
        return m_sessionInfo.state;
    }
    
private:
    void SessionLoop() {
        std::cout << "세션 " << m_sessionInfo.sessionId << " 루프 시작" << std::endl;
        
        while (m_running.load()) {
            // 세션 시작 조건 대기
            if (m_sessionInfo.state == SessionState::WAITING_FOR_PLAYERS) {
                WaitForSessionStart();
                if (!m_running.load()) break;
                
                // 세션 시작
                StartGameSession();
            }
            
            // 게임 진행
            if (m_sessionInfo.state == SessionState::IN_PROGRESS) {
                RunGameSession();
            }
            
            // 세션 종료 확인
            if (WaitForSingleObject(m_sessionEndEvent, 0) == WAIT_OBJECT_0) {
                break;
            }
            
            Sleep(100); // CPU 사용률 조절
        }
        
        std::cout << "세션 " << m_sessionInfo.sessionId << " 루프 종료" << std::endl;
    }
    
    void WaitForSessionStart() {
        std::cout << "세션 " << m_sessionInfo.sessionId << " 시작 조건 대기 중..." << std::endl;
        
        // 세션 시작에 필요한 모든 조건들
        HANDLE events[] = {
            m_allPlayersReady,
            m_gameDataLoaded,
            m_serverResourcesReady
        };
        
        // 모든 이벤트가 신호 상태가 될 때까지 대기
        DWORD result = WaitForMultipleObjects(
            3,              // 이벤트 개수
            events,         // 이벤트 배열
            TRUE,          // 모든 객체가 신호 상태가 되어야 함
            30000          // 30초 타임아웃
        );
        
        switch (result) {
            case WAIT_OBJECT_0:
                std::cout << "세션 " << m_sessionInfo.sessionId << " 시작 조건 모두 만족" << std::endl;
                m_sessionInfo.state = SessionState::READY_TO_START;
                break;
                
            case WAIT_TIMEOUT:
                std::cout << "세션 " << m_sessionInfo.sessionId << " 시작 대기 시간 초과" << std::endl;
                // 타임아웃 처리 로직 (예: 준비되지 않은 플레이어 제거)
                HandleSessionStartTimeout();
                break;
                
            case WAIT_FAILED:
                std::cout << "세션 " << m_sessionInfo.sessionId << " 시작 대기 실패: " 
                          << GetLastError() << std::endl;
                break;
        }
    }
    
    void StartGameSession() {
        EnterCriticalSection(&m_sessionCS);
        
        m_sessionInfo.state = SessionState::IN_PROGRESS;
        m_sessionInfo.startTime = std::chrono::steady_clock::now();
        
        LeaveCriticalSection(&m_sessionCS);
        
        SetEvent(m_sessionStartEvent);
        
        std::cout << "=== 게임 세션 " << m_sessionInfo.sessionId << " 시작! ===" << std::endl;
        std::cout << "참가 플레이어: ";
        for (int playerId : m_sessionInfo.playerIds) {
            std::cout << playerId << " ";
        }
        std::cout << std::endl;
    }
    
    void RunGameSession() {
        // 게임 세션 진행 시뮬레이션
        static int gameFrame = 0;
        gameFrame++;
        
        if (gameFrame % 600 == 0) { // 10초마다 (60FPS 기준)
            std::cout << "세션 " << m_sessionInfo.sessionId << " 게임 진행 중... (프레임: " << gameFrame << ")" << std::endl;
            
            // 게임 세션 종료 조건 확인 (예: 5분 후 종료)
            auto now = std::chrono::steady_clock::now();
            auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - m_sessionInfo.startTime);
            
            if (elapsed.count() > 300) { // 5분
                EndGameSession();
            }
        }
        
        Sleep(16); // ~60 FPS
    }
    
    void EndGameSession() {
        EnterCriticalSection(&m_sessionCS);
        m_sessionInfo.state = SessionState::FINISHED;
        LeaveCriticalSection(&m_sessionCS);
        
        std::cout << "=== 게임 세션 " << m_sessionInfo.sessionId << " 종료! ===" << std::endl;
        
        SetEvent(m_sessionEndEvent);
        m_running = false;
    }
    
    void HandleSessionStartTimeout() {
        std::cout << "세션 " << m_sessionInfo.sessionId << " 시작 타임아웃 처리" << std::endl;
        
        // 준비되지 않은 플레이어들 확인 및 제거
        EnterCriticalSection(&m_sessionCS);
        
        if (m_sessionInfo.readyPlayers < m_sessionInfo.currentPlayers) {
            std::cout << "준비되지 않은 플레이어들이 있어 세션을 재설정합니다." << std::endl;
            
            // 이벤트 리셋
            ResetEvent(m_allPlayersReady);
            
            // 필요시 플레이어 제거 로직 추가
        }
        
        LeaveCriticalSection(&m_sessionCS);
    }
};

// Event 활용 예제 테스트
void TestGameSessionManager() {
    std::cout << "\n=== 게임 세션 매니저 테스트 ===" << std::endl;
    
    GameSessionManager session(1001, 4); // 세션 ID 1001, 최대 4명
    
    if (!session.Start()) {
        std::cout << "세션 시작 실패" << std::endl;
        return;
    }
    
    // 플레이어들 참가 시뮬레이션
    std::vector<std::thread> playerThreads;
    
    for (int playerId = 1; playerId <= 6; ++playerId) { // 6명이 참가 시도 (4명만 받음)
        playerThreads.emplace_back([&session, playerId]() {
            // 플레이어 참가
            if (session.AddPlayer(playerId)) {
                // 랜덤한 시간 후 준비 완료
                Sleep(1000 + (rand() % 2000)); // 1-3초 대기
                session.PlayerReady(playerId);
            }
        });
    }
    
    // 세션 상태 모니터링
    std::thread monitor([&session]() {
        while (session.GetState() != GameSessionManager::SessionState::FINISHED) {
            Sleep(2000);
            
            auto state = session.GetState();
            std::cout << "[모니터] 현재 세션 상태: ";
            switch (state) {
                case GameSessionManager::SessionState::WAITING_FOR_PLAYERS:
                    std::cout << "플레이어 대기 중"; break;
                case GameSessionManager::SessionState::READY_TO_START:
                    std::cout << "시작 준비 완료"; break;
                case GameSessionManager::SessionState::IN_PROGRESS:
                    std::cout << "게임 진행 중"; break;
                case GameSessionManager::SessionState::FINISHED:
                    std::cout << "게임 종료"; break;
            }
            std::cout << std::endl;
        }
    });
    
    // 모든 스레드 완료 대기
    for (auto& thread : playerThreads) {
        thread.join();
    }
    
    // 10초 후 강제 종료
    Sleep(10000);
    session.Stop();
    
    if (monitor.joinable()) {
        monitor.join();
    }
    
    std::cout << "게임 세션 테스트 완료" << std::endl;
}
```
   
이 예제는 **게임 서버에서 여러 가지 조건이 동시에 만족될 때 세션을 시작하는 방법**을 다루고 있다.
게임 서버는 보통 여러 비동기 작업(예: 플레이어 준비, 데이터 로딩, 리소스 초기화)을 동시에 처리해야 하는데,
이러한 복합적인 조건을 단순한 `if` 문으로 관리하기 어렵다.
그래서 이 코드는 **Windows Event 객체**를 이용해 여러 조건이 모두 충족될 때 자동으로 세션을 시작하도록 설계되어 있다.

핵심적으로 이 코드는 다음과 같은 경우에 사용한다.

* 여러 개의 **비동기 이벤트(ready, loaded, resource ready)** 가 모두 완료되어야 다음 단계로 넘어가야 할 때
* 서버가 **게임 세션의 상태(대기 → 준비 → 진행 → 종료)** 를 명확히 관리해야 할 때
* **스레드 기반의 이벤트 동기화**를 구현해야 할 때


#### 1. 클래스 개요와 상태 정의

```cpp
class GameSessionManager {
public:
    enum class SessionState {
        WAITING_FOR_PLAYERS,
        READY_TO_START,
        IN_PROGRESS,
        FINISHED
    };
```

이 클래스는 **게임 세션의 생명주기**를 관리한다.
`SessionState` 열거형은 세션이 어떤 상태인지 구분하는 데 사용된다.

* `WAITING_FOR_PLAYERS`: 플레이어들이 모이는 중
* `READY_TO_START`: 모든 조건이 만족되어 시작 가능한 상태
* `IN_PROGRESS`: 실제 게임이 진행 중
* `FINISHED`: 세션이 종료된 상태


#### 2. 이벤트 객체와 세션 정보

```cpp
HANDLE m_allPlayersReady;
HANDLE m_gameDataLoaded;
HANDLE m_serverResourcesReady;
HANDLE m_sessionStartEvent;
HANDLE m_sessionEndEvent;
```

이 다섯 개의 핸들은 **Windows 커널 이벤트 객체**이다.
각 이벤트는 특정 조건이 충족되었을 때 `SetEvent()`로 신호를 보낸다.

* `m_allPlayersReady`: 모든 플레이어가 준비 완료됨
* `m_gameDataLoaded`: 게임 데이터 로딩 완료
* `m_serverResourcesReady`: 서버 리소스 준비 완료
* `m_sessionStartEvent`: 세션 시작
* `m_sessionEndEvent`: 세션 종료

이들은 `CreateEvent()`로 생성되며, 모두 **manual reset** 모드로 만들어진다.
즉, 한 번 신호가 발생하면 명시적으로 `ResetEvent()` 하기 전까지 유지된다.


#### 3. 세션 시작 및 리소스 초기화

```cpp
bool Start() {
    m_running = true;
    m_sessionThread = std::thread([this]() { SessionLoop(); });
```

세션을 시작하면 **전용 스레드**(`SessionLoop`)가 실행된다.
이 스레드는 세션의 상태를 감시하고, 세션 시작 조건이 충족될 때까지 기다린다.

```cpp
// 서버 리소스 준비 시뮬레이션
std::thread([this]() {
    Sleep(500);
    SetEvent(m_serverResourcesReady);
}).detach();

// 게임 데이터 로딩 시뮬레이션
std::thread([this]() {
    Sleep(800);
    SetEvent(m_gameDataLoaded);
}).detach();
```

위의 코드처럼 리소스 준비와 데이터 로딩은 각각 별도의 스레드에서 처리된다.
작업이 완료되면 `SetEvent()`를 호출해 “준비 완료” 신호를 보낸다.


#### 4. 플레이어 참가 및 준비 처리

```cpp
bool AddPlayer(int playerId);
void PlayerReady(int playerId);
```

* `AddPlayer()`는 플레이어가 세션에 참가할 때 호출된다.
  최대 인원을 초과하면 참가가 거부된다.

* `PlayerReady()`는 플레이어가 준비 완료했을 때 호출된다.
  모든 플레이어가 준비 완료되면 `SetEvent(m_allPlayersReady)`가 호출된다.

즉, `m_allPlayersReady` 이벤트는 **“모든 참가자 준비 완료”** 조건을 의미한다.


#### 5. 복합 이벤트 대기 (`WaitForMultipleObjects`)

```cpp
HANDLE events[] = {
    m_allPlayersReady,
    m_gameDataLoaded,
    m_serverResourcesReady
};

DWORD result = WaitForMultipleObjects(3, events, TRUE, 30000);
```

이 부분이 핵심이다.
`WaitForMultipleObjects()`는 **여러 이벤트 중 모든 이벤트가 신호 상태(=SetEvent 호출됨)** 가 될 때까지 대기한다.

* `TRUE`는 **모든 이벤트가 완료되어야** 반환됨을 의미한다.
* `30000`은 30초 타임아웃이다.

즉,

* 모든 플레이어가 준비되고(`m_allPlayersReady`),
* 게임 데이터가 로드되고(`m_gameDataLoaded`),
* 서버 리소스가 준비되면(`m_serverResourcesReady`),
  → 세션이 자동으로 시작된다.

타임아웃이 발생하면 `HandleSessionStartTimeout()`이 호출되어 재처리한다.


#### 6. 세션 실행 및 종료

세션이 시작되면 상태가 `IN_PROGRESS`로 바뀌고,
아래 루프에서 게임이 진행되는 동안 주기적으로 로그를 출력한다.

```cpp
void RunGameSession() {
    if (gameFrame % 600 == 0) {
        std::cout << "게임 진행 중..." << std::endl;
    }
}
```

일정 시간이 지나면 `EndGameSession()`이 호출되어 세션이 종료된다.
종료 시에는 `m_sessionEndEvent`가 `SetEvent()` 되어 루프를 빠져나간다.


#### 7. 테스트 함수

```cpp
void TestGameSessionManager() {
    GameSessionManager session(1001, 4);
    session.Start();

    // 6명의 플레이어가 동시에 참가 시도
    for (int playerId = 1; playerId <= 6; ++playerId) { ... }
}
```

테스트 함수는 여러 스레드를 통해 플레이어들이 동시에 참가하고 준비하는 상황을 시뮬레이션한다.
플레이어는 랜덤한 시간 후 준비 완료 신호를 보낸다.
세션은 모든 조건이 충족되면 자동으로 시작된다.


#### 8. 핵심 요약

| 구분                         | 역할                    |
| -------------------------- | --------------------- |
| `CreateEvent()`            | 이벤트 객체 생성             |
| `SetEvent()`               | 조건 충족 시 신호 발생         |
| `WaitForMultipleObjects()` | 여러 이벤트가 모두 완료될 때까지 대기 |
| `ResetEvent()`             | 이벤트 신호 초기화            |
| `SessionState`             | 세션의 현재 상태 관리          |

이 구조를 통해 **서버는 여러 비동기 조건이 동시에 만족되는 시점을 정확히 감지**할 수 있다.
이는 게임뿐 아니라 **멀티스레드 동기화, 네트워크 연결 관리, 자원 초기화 로직** 등에서도 자주 사용되는 패턴이다.

요약하자면, 이 코드는
“**서버가 여러 준비 신호를 기다렸다가, 모든 조건이 충족되면 세션을 시작하는 복합 이벤트 처리 예제**”이다.
`Event` 객체를 활용하면 복잡한 조건 분기를 깔끔하게 동기화할 수 있다.


</br>    
  
## 5.3 Reader-Writer Lock (SRWLock)
게임 서버에서 읽기가 빈번하고 쓰기가 드문 데이터 구조에 최적화된 SRWLock을 활용해보겠다.

```cpp
#include <unordered_map>
#include <shared_mutex> // C++17 표준 shared_mutex와 비교용

// 게임 월드 오브젝트 관리 시스템
class GameWorldObjectManager {
private:
    // 게임 오브젝트 정보
    struct GameObject {
        int objectId;
        float x, y, z;
        int objectType;
        int health;
        bool isActive;
        std::chrono::steady_clock::time_point lastUpdate;
        
        GameObject(int id, float px, float py, float pz, int type)
            : objectId(id), x(px), y(py), z(pz), objectType(type), 
              health(100), isActive(true) {
            lastUpdate = std::chrono::steady_clock::now();
        }
    };
    
    std::unordered_map<int, GameObject> m_objects;
    SRWLOCK m_objectsLock;
    
    // 통계 정보
    std::atomic<long long> m_readOperations;
    std::atomic<long long> m_writeOperations;
    std::atomic<long long> m_readTime;    // 마이크로초
    std::atomic<long long> m_writeTime;   // 마이크로초
    
public:
    GameWorldObjectManager() : m_readOperations(0), m_writeOperations(0),
                              m_readTime(0), m_writeTime(0) {
        InitializeSRWLock(&m_objectsLock);
        
        // 초기 오브젝트들 생성
        for (int i = 1; i <= 10000; ++i) {
            float x = static_cast<float>(rand() % 1000);
            float y = static_cast<float>(rand() % 1000);
            float z = static_cast<float>(rand() % 100);
            int type = rand() % 5;
            
            m_objects.emplace(i, GameObject(i, x, y, z, type));
        }
        
        std::cout << "게임 월드 오브젝트 매니저 초기화 완료 (" << m_objects.size() << "개 오브젝트)" << std::endl;
        
        /*
        ┌─────────────────────────────────────────────────────────────┐
        │                   SRWLock Architecture                      │
        ├─────────────────────────────────────────────────────────────┤
        │                                                             │
        │  Multiple Readers (Shared Access)                           │
        │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐           │
        │  │Reader 1 │ │Reader 2 │ │Reader 3 │ │Reader N │           │
        │  └─────────┘ └─────────┘ └─────────┘ └─────────┘           │
        │       │           │           │           │                 │
        │       └───────────┼───────────┼───────────┘                 │
        │                   ▼           ▼                             │
        │           ┌─────────────────────────────────┐               │
        │           │        Shared Data              │               │
        │           │    (Game Objects Map)           │               │
        │           └─────────────────────────────────┘               │
        │                           ▲                                 │
        │                           │                                 │
        │                   ┌─────────────┐                          │
        │                   │   Writer    │                          │
        │                   │ (Exclusive) │                          │
        │                   └─────────────┘                          │
        │                                                             │
        │  Benefits:                                                  │
        │  ✓ Multiple concurrent readers                              │
        │  ✓ Exclusive writer access                                  │
        │  ✓ Better performance for read-heavy workloads             │
        └─────────────────────────────────────────────────────────────┘
        */
    }
    
    // 읽기 전용 접근 - 여러 스레드가 동시에 가능
    bool GetObjectPosition(int objectId, float& x, float& y, float& z) {
        auto start = std::chrono::high_resolution_clock::now();
        
        AcquireSRWLockShared(&m_objectsLock);
        
        bool found = false;
        auto it = m_objects.find(objectId);
        if (it != m_objects.end() && it->second.isActive) {
            x = it->second.x;
            y = it->second.y;
            z = it->second.z;
            found = true;
        }
        
        ReleaseSRWLockShared(&m_objectsLock);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        m_readOperations.fetch_add(1);
        m_readTime.fetch_add(duration.count());
        
        return found;
    }
    
    // 범위 내 오브젝트 검색 (읽기 전용)
    std::vector<int> GetObjectsInRange(float centerX, float centerY, float radius) {
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<int> result;
        
        AcquireSRWLockShared(&m_objectsLock);
        
        float radiusSquared = radius * radius;
        for (const auto& pair : m_objects) {
            const GameObject& obj = pair.second;
            if (!obj.isActive) continue;
            
            float dx = obj.x - centerX;
            float dy = obj.y - centerY;
            float distanceSquared = dx * dx + dy * dy;
            
            if (distanceSquared <= radiusSquared) {
                result.push_back(obj.objectId);
            }
        }
        
        ReleaseSRWLockShared(&m_objectsLock);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        m_readOperations.fetch_add(1);
        m_readTime.fetch_add(duration.count());
        
        return result;
    }
    
    // 오브젝트 상태 정보 읽기
    bool GetObjectInfo(int objectId, GameObject& info) {
        auto start = std::chrono::high_resolution_clock::now();
        
        AcquireSRWLockShared(&m_objectsLock);
        
        bool found = false;
        auto it = m_objects.find(objectId);
        if (it != m_objects.end()) {
            info = it->second;
            found = true;
        }
        
        ReleaseSRWLockShared(&m_objectsLock);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        m_readOperations.fetch_add(1);
        m_readTime.fetch_add(duration.count());
        
        return found;
    }
    
    // 쓰기 접근 - 배타적 접근
    bool UpdateObjectPosition(int objectId, float newX, float newY, float newZ) {
        auto start = std::chrono::high_resolution_clock::now();
        
        AcquireSRWLockExclusive(&m_objectsLock);
        
        bool updated = false;
        auto it = m_objects.find(objectId);
        if (it != m_objects.end() && it->second.isActive) {
            it->second.x = newX;
            it->second.y = newY;
            it->second.z = newZ;
            it->second.lastUpdate = std::chrono::steady_clock::now();
            updated = true;
        }
        
        ReleaseSRWLockExclusive(&m_objectsLock);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        m_writeOperations.fetch_add(1);
        m_writeTime.fetch_add(duration.count());
        
        return updated;
    }
    
    // 새 오브젝트 추가
    bool AddObject(int objectId, float x, float y, float z, int type) {
        auto start = std::chrono::high_resolution_clock::now();
        
        AcquireSRWLockExclusive(&m_objectsLock);
        
        bool added = false;
        if (m_objects.find(objectId) == m_objects.end()) {
            m_objects.emplace(objectId, GameObject(objectId, x, y, z, type));
            added = true;
        }
        
        ReleaseSRWLockExclusive(&m_objectsLock);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        m_writeOperations.fetch_add(1);
        m_writeTime.fetch_add(duration.count());
        
        return added;
    }
    
    // 오브젝트 제거
    bool RemoveObject(int objectId) {
        auto start = std::chrono::high_resolution_clock::now();
        
        AcquireSRWLockExclusive(&m_objectsLock);
        
        bool removed = false;
        auto it = m_objects.find(objectId);
        if (it != m_objects.end()) {
            it->second.isActive = false; // 실제 삭제 대신 비활성화
            removed = true;
        }
        
        ReleaseSRWLockExclusive(&m_objectsLock);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        m_writeOperations.fetch_add(1);
        m_writeTime.fetch_add(duration.count());
        
        return removed;
    }
    
    // 일괄 업데이트 (쓰기)
    void UpdateMultipleObjects(const std::vector<std::pair<int, std::tuple<float, float, float>>>& updates) {
        auto start = std::chrono::high_resolution_clock::now();
        
        AcquireSRWLockExclusive(&m_objectsLock);
        
        for (const auto& update : updates) {
            int objectId = update.first;
            float x, y, z;
            std::tie(x, y, z) = update.second;
            
            auto it = m_objects.find(objectId);
            if (it != m_objects.end() && it->second.isActive) {
                it->second.x = x;
                it->second.y = y;
                it->second.z = z;
                it->second.lastUpdate = std::chrono::steady_clock::now();
            }
        }
        
        ReleaseSRWLockExclusive(&m_objectsLock);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        m_writeOperations.fetch_add(1);
        m_writeTime.fetch_add(duration.count());
    }
    
    // 통계 정보 출력
    void PrintStatistics() {
        long long reads = m_readOperations.load();
        long long writes = m_writeOperations.load();
        long long readTime = m_readTime.load();
        long long writeTime = m_writeTime.load();
        
        std::cout << "\n=== SRWLock 성능 통계 ===" << std::endl;
        std::cout << "읽기 작업 수: " << reads << std::endl;
        std::cout << "쓰기 작업 수: " << writes << std::endl;
        
        if (reads > 0) {
            std::cout << "평균 읽기 시간: " << (readTime / reads) << " μs" << std::endl;
        }
        if (writes > 0) {
            std::cout << "평균 쓰기 시간: " << (writeTime / writes) << " μs" << std::endl;
        }
        
        std::cout << "읽기/쓰기 비율: " << (reads * 100.0 / (reads + writes)) << "% / " 
                  << (writes * 100.0 / (reads + writes)) << "%" << std::endl;
        
        // 현재 활성 오브젝트 수
        AcquireSRWLockShared(&m_objectsLock);
        int activeCount = 0;
        for (const auto& pair : m_objects) {
            if (pair.second.isActive) activeCount++;
        }
        ReleaseSRWLockShared(&m_objectsLock);
        
        std::cout << "활성 오브젝트 수: " << activeCount << "/" << m_objects.size() << std::endl;
    }
    
    size_t GetObjectCount() const {
        AcquireSRWLockShared(&const_cast<SRWLOCK&>(m_objectsLock));
        size_t count = m_objects.size();
        ReleaseSRWLockShared(&const_cast<SRWLOCK&>(m_objectsLock));
        return count;
    }
};

// SRWLock 성능 테스트
void TestSRWLockPerformance() {
    std::cout << "\n=== SRWLock 성능 테스트 ===" << std::endl;
    
    GameWorldObjectManager objectManager;
    
    const int READER_THREADS = 8;
    const int WRITER_THREADS = 2;
    const int TEST_DURATION_SECONDS = 10;
    
    std::atomic<bool> testRunning{true};
    std::vector<std::thread> threads;
    
    // 읽기 전용 스레드들 (위치 조회)
    for (int i = 0; i < READER_THREADS; ++i) {
        threads.emplace_back([&objectManager, &testRunning, i]() {
            std::random_device rd;
            std::mt19937 gen(rd() + i);
            std::uniform_int_distribution<int> objectDis(1, 10000);
            std::uniform_real_distribution<float> posDis(0.0f, 1000.0f);
            
            while (testRunning.load()) {
                // 개별 오브젝트 위치 조회
                int objectId = objectDis(gen);
                float x, y, z;
                objectManager.GetObjectPosition(objectId, x, y, z);
                
                // 범위 검색
                if (rand() % 10 == 0) { // 10%는 범위 검색
                    float centerX = posDis(gen);
                    float centerY = posDis(gen);
                    auto nearbyObjects = objectManager.GetObjectsInRange(centerX, centerY, 50.0f);
                }
                
                // CPU 사용률 조절
                if (rand() % 1000 == 0) {
                    Sleep(1);
                }
            }
        });
    }
    
    // 쓰기 스레드들 (위치 업데이트)
    for (int i = 0; i < WRITER_THREADS; ++i) {
        threads.emplace_back([&objectManager, &testRunning, i]() {
            std::random_device rd;
            std::mt19937 gen(rd() + i + 1000);
            std::uniform_int_distribution<int> objectDis(1, 10000);
            std::uniform_real_distribution<float> posDis(0.0f, 1000.0f);
            
            while (testRunning.load()) {
                // 개별 오브젝트 위치 업데이트
                int objectId = objectDis(gen);
                float newX = posDis(gen);
                float newY = posDis(gen);
                float newZ = posDis(gen);
                
                objectManager.UpdateObjectPosition(objectId, newX, newY, newZ);
                
                // 일괄 업데이트 (가끔)
                if (rand() % 100 == 0) {
                    std::vector<std::pair<int, std::tuple<float, float, float>>> updates;
                    for (int j = 0; j < 10; ++j) {
                        int id = objectDis(gen);
                        float x = posDis(gen);
                        float y = posDis(gen);
                        float z = posDis(gen);
                        updates.emplace_back(id, std::make_tuple(x, y, z));
                    }
                    objectManager.UpdateMultipleObjects(updates);
                }
                
                // 쓰기는 더 느리게
                Sleep(5);
            }
        });
    }
    
    // 모니터링 스레드
    std::thread monitor([&objectManager, &testRunning]() {
        while (testRunning.load()) {
            Sleep(2000);
            objectManager.PrintStatistics();
        }
    });
    
    // 테스트 실행
    std::cout << "SRWLock 테스트 시작 (" << TEST_DURATION_SECONDS << "초간)" << std::endl;
    std::cout << "읽기 스레드: " << READER_THREADS << "개, 쓰기 스레드: " << WRITER_THREADS << "개" << std::endl;
    
    Sleep(TEST_DURATION_SECONDS * 1000);
    
    // 테스트 중지
    testRunning = false;
    
    // 모든 스레드 완료 대기
    for (auto& thread : threads) {
        thread.join();
    }
    
    if (monitor.joinable()) {
        monitor.join();
    }
    
    // 최종 통계
    objectManager.PrintStatistics();
}
```
   
이번 예제는 **읽기가 매우 많고 쓰기가 상대적으로 적은 게임 서버 환경**에서, 데이터를 안전하게 공유하기 위해 **SRWLock (Slim Reader/Writer Lock)** 을 사용하는 방법을 설명한다.
SRWLock은 **여러 스레드가 동시에 읽기(shared)** 를 수행할 수 있고, **쓰기(exclusive)** 시에는 단 하나의 스레드만 접근하도록 제어할 수 있는 동기화 메커니즘이다.

이 코드는 게임 서버에서 **게임 오브젝트(캐릭터, 몬스터, 아이템 등)** 를 관리할 때,
읽기 연산이 대부분을 차지하는 상황에서 높은 성능을 유지하기 위해 SRWLock을 사용하는 예시다.


### 1. SRWLock의 목적과 특징
SRWLock은 Windows에서 제공하는 **경량화된 Reader-Writer Lock**이다.
`CriticalSection`보다 가볍고, 다중 읽기 병행을 허용하여 **읽기 빈도가 높은 데이터 구조**에 적합하다.

* 여러 스레드가 동시에 읽을 수 있다 (공유 잠금, Shared Lock).
* 한 스레드만 쓸 수 있다 (배타 잠금, Exclusive Lock).
* 잠금 해제가 빠르고, 컨텍스트 스위칭이 적다.

아래 다이어그램은 SRWLock의 작동 구조를 시각적으로 표현한 것이다.

```
┌─────────────────────────────────────────────────────────────┐
│                   SRWLock Architecture                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Multiple Readers (Shared Access)                           │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐           │
│  │Reader 1 │ │Reader 2 │ │Reader 3 │ │Reader N │           │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘           │
│           │           │           │           │             │
│           └───────────┼───────────┼───────────┘             │
│                       ▼                                     │
│               ┌───────────────────────────┐                 │
│               │     Shared Data Map       │                 │
│               │ (Game Objects Map)        │                 │
│               └───────────────────────────┘                 │
│                       ▲                                     │
│                       │                                     │
│               ┌─────────────┐                              │
│               │   Writer    │                              │
│               │ (Exclusive) │                              │
│               └─────────────┘                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2. GameWorldObjectManager 클래스 개요

```cpp
class GameWorldObjectManager {
private:
    struct GameObject {
        int objectId;
        float x, y, z;
        int objectType;
        int health;
        bool isActive;
        std::chrono::steady_clock::time_point lastUpdate;
    };
    
    std::unordered_map<int, GameObject> m_objects;
    SRWLOCK m_objectsLock;
```

* `m_objects`: 게임 월드 내의 오브젝트들을 저장하는 해시맵이다.
* `m_objectsLock`: SRWLock 객체로, 오브젝트 데이터에 대한 동시 접근을 제어한다.
* `GameObject`: 위치, 체력, 활성 상태 등을 저장하는 기본 단위 구조체다.

`InitializeSRWLock()`으로 초기화 후, 수천 개의 오브젝트가 생성된다.
이는 실제 게임 환경에서 대규모 객체를 관리하는 상황을 시뮬레이션한다.


### 3. 읽기 작업 — 다중 스레드 병행 가능

#### (1) 단일 오브젝트 조회

```cpp
bool GetObjectPosition(int objectId, float& x, float& y, float& z) {
    AcquireSRWLockShared(&m_objectsLock);
    ...
    ReleaseSRWLockShared(&m_objectsLock);
}
```

* `AcquireSRWLockShared()`는 **공유 잠금(shared lock)** 을 획득한다.
  이 상태에서는 여러 스레드가 동시에 데이터를 읽을 수 있다.
* 오브젝트 위치를 읽은 뒤 `ReleaseSRWLockShared()`로 잠금을 해제한다.

이 접근 방식은 읽기 연산이 매우 많을 때 성능을 향상시킨다.

#### (2) 범위 내 오브젝트 검색

```cpp
std::vector<int> GetObjectsInRange(float centerX, float centerY, float radius)
```

여러 오브젝트를 순회하며 주어진 범위 내에 존재하는 ID를 찾는다.
읽기 전용이므로 `AcquireSRWLockShared()`로 접근한다.
이 역시 수많은 읽기 스레드가 동시에 안전하게 실행될 수 있다.

### 4. 쓰기 작업 — 배타적 접근

#### (1) 위치 업데이트

```cpp
bool UpdateObjectPosition(int objectId, float newX, float newY, float newZ) {
    AcquireSRWLockExclusive(&m_objectsLock);
    ...
    ReleaseSRWLockExclusive(&m_objectsLock);
}
```

* 쓰기 연산에서는 **배타 잠금(exclusive lock)** 을 획득한다.
* 쓰기 중에는 다른 스레드가 읽거나 쓸 수 없다.
* 업데이트 후 반드시 `ReleaseSRWLockExclusive()`로 해제해야 한다.

#### (2) 오브젝트 추가 및 제거

`AddObject()`와 `RemoveObject()`도 동일하게 배타적 접근을 사용한다.

* 추가 시: `m_objects.emplace()`로 새로운 오브젝트를 삽입한다.
* 제거 시: 실제 삭제 대신 `isActive = false`로 비활성화 처리한다.
  이렇게 하면 메모리 재할당을 피할 수 있어 효율적이다.

#### (3) 일괄 업데이트

`UpdateMultipleObjects()`는 여러 오브젝트를 한꺼번에 수정한다.
루프 내에서 배타 잠금을 유지하기 때문에, 중간에 다른 스레드가 접근할 수 없다.
  

### 5. 성능 측정과 통계 출력
코드에서는 읽기와 쓰기 작업의 **횟수와 시간**을 측정한다.

```cpp
std::atomic<long long> m_readOperations;
std::atomic<long long> m_writeOperations;
std::atomic<long long> m_readTime;
std::atomic<long long> m_writeTime;
```

각 함수 내에서 `fetch_add()`로 누적 통계를 기록하고,
`PrintStatistics()`에서 평균 처리 시간과 읽기/쓰기 비율을 출력한다.

예를 들어 출력 결과는 다음과 같다.

```
=== SRWLock 성능 통계 ===
읽기 작업 수: 500000
쓰기 작업 수: 20000
평균 읽기 시간: 8 μs
평균 쓰기 시간: 50 μs
읽기/쓰기 비율: 96% / 4%
활성 오브젝트 수: 9998/10000
```

이는 SRWLock이 **읽기 병행성이 높을수록 성능이 뛰어남**을 보여준다.


### 6. SRWLock 성능 테스트

```cpp
void TestSRWLockPerformance() {
    const int READER_THREADS = 8;
    const int WRITER_THREADS = 2;
    const int TEST_DURATION_SECONDS = 10;
```

* 8개의 **읽기 전용 스레드**와 2개의 **쓰기 스레드**를 생성한다.
* 각 스레드는 10초 동안 무작위 오브젝트를 읽거나 수정한다.
* 모니터링 스레드는 2초마다 통계 정보를 출력한다.

결과적으로 SRWLock은 다음과 같은 장점을 제공한다.

| 구분               | 내용                      |
| ---------------- | ----------------------- |
| **읽기 병행성**       | 여러 스레드가 동시에 읽기 가능       |
| **쓰기 독점성**       | 하나의 스레드만 수정 가능          |
| **낮은 오버헤드**      | CriticalSection보다 빠른 동작 |
| **읽기 중심 환경 최적화** | 게임 서버, 캐시 시스템 등에 적합     |


### 7. 결론
SRWLock은 **읽기 연산이 지배적인 환경에서 뛰어난 성능을 보이는 동기화 도구**이다.
게임 서버의 오브젝트 관리, 인벤토리 조회, 랭킹 데이터 접근 등
“**읽기 다수 / 쓰기 소수**” 구조에서 이상적인 선택이다.

이 예제의 핵심은 다음과 같다.

1. `AcquireSRWLockShared()` — 여러 스레드가 동시에 읽을 수 있다.
2. `AcquireSRWLockExclusive()` — 단 하나의 스레드만 쓸 수 있다.
3. 통계 측정을 통해 SRWLock의 효율성을 수치로 확인할 수 있다.

즉, SRWLock은 **다중 스레드 환경에서 데이터 일관성을 유지하면서도 읽기 성능을 극대화하는 방법**을 보여주는 훌륭한 예제이다.


</br>    

## 5.4 Condition Variable 패턴
게임 서버에서 이벤트 처리나 작업 큐 관리에 유용한 Condition Variable을 활용해보겠다.

```cpp
#include <queue>
#include <condition_variable>

// 게임 이벤트 큐 시스템 (Condition Variable 사용)
template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> m_queue;
    CRITICAL_SECTION m_cs;
    CONDITION_VARIABLE m_notEmpty;
    CONDITION_VARIABLE m_notFull;
    
    size_t m_maxSize;
    std::atomic<bool> m_shutdown;
    
public:
    ThreadSafeQueue(size_t maxSize = 1000) : m_maxSize(maxSize), m_shutdown(false) {
        InitializeCriticalSection(&m_cs);
        InitializeConditionVariable(&m_notEmpty);
        InitializeConditionVariable(&m_notFull);
        
        /*
        ┌─────────────────────────────────────────────────────────────┐
        │                Condition Variable Pattern                    │
        ├─────────────────────────────────────────────────────────────┤
        │                                                             │
        │  Producer Thread              Consumer Thread               │
        │  ┌─────────────────┐          ┌─────────────────┐           │
        │  │ Wait for Space  │          │ Wait for Item   │           │
        │  │ (NotFull CV)    │          │ (NotEmpty CV)   │           │
        │  └─────────────────┘          └─────────────────┘           │
        │           │                            │                    │
        │           ▼                            ▼                    │
        │  ┌─────────────────┐          ┌─────────────────┐           │
        │  │   Add Item      │          │  Remove Item    │           │
        │  │   to Queue      │          │  from Queue     │           │
        │  └─────────────────┘          └─────────────────┘           │
        │           │                            │                    │
        │           ▼                            ▼                    │
        │  ┌─────────────────┐          ┌─────────────────┐           │
        │  │ Signal NotEmpty │          │ Signal NotFull  │           │
        │  └─────────────────┘          └─────────────────┘           │
        │                                                             │
        │  Benefits:                                                  │
        │  ✓ Efficient waiting (no busy polling)                     │
        │  ✓ Automatic wake-up when condition changes                │
        │  ✓ Prevents spurious wake-ups                              │
        └─────────────────────────────────────────────────────────────┘
        */
    }
    
    ~ThreadSafeQueue() {
        Shutdown();
        DeleteCriticalSection(&m_cs);
    }
    
    bool Push(const T& item, DWORD timeoutMs = INFINITE) {
        EnterCriticalSection(&m_cs);
        
        // 큐가 가득 찰 때까지 대기
        while (m_queue.size() >= m_maxSize && !m_shutdown.load()) {
            if (!SleepConditionVariableCS(&m_notFull, &m_cs, timeoutMs)) {
                LeaveCriticalSection(&m_cs);
                return false; // 타임아웃 또는 오류
            }
        }
        
        if (m_shutdown.load()) {
            LeaveCriticalSection(&m_cs);
            return false;
        }
        
        bool wasEmpty = m_queue.empty();
        m_queue.push(item);
        
        // 큐가 비어있었다면 대기 중인 소비자들에게 신호
        if (wasEmpty) {
            WakeAllConditionVariable(&m_notEmpty);
        }
        
        LeaveCriticalSection(&m_cs);
        return true;
    }
    
    bool Pop(T& item, DWORD timeoutMs = INFINITE) {
        EnterCriticalSection(&m_cs);
        
        // 큐가 비어있는 동안 대기
        while (m_queue.empty() && !m_shutdown.load()) {
            if (!SleepConditionVariableCS(&m_notEmpty, &m_cs, timeoutMs)) {
                LeaveCriticalSection(&m_cs);
                return false; // 타임아웃 또는 오류
            }
        }
        
        if (m_shutdown.load() && m_queue.empty()) {
            LeaveCriticalSection(&m_cs);
            return false;
        }
        
        bool wasFull = (m_queue.size() >= m_maxSize);
        item = m_queue.front();
        m_queue.pop();
        
        // 큐가 가득 찼었다면 대기 중인 생산자들에게 신호
        if (wasFull) {
            WakeAllConditionVariable(&m_notFull);
        }
        
        LeaveCriticalSection(&m_cs);
        return true;
    }
    
    bool TryPop(T& item) {
        EnterCriticalSection(&m_cs);
        
        if (m_queue.empty()) {
            LeaveCriticalSection(&m_cs);
            return false;
        }
        
        item = m_queue.front();
        m_queue.pop();
        
        if (m_queue.size() == m_maxSize - 1) {
            WakeAllConditionVariable(&m_notFull);
        }
        
        LeaveCriticalSection(&m_cs);
        return true;
    }
    
    size_t Size() const {
        EnterCriticalSection(&const_cast<CRITICAL_SECTION&>(m_cs));
        size_t size = m_queue.size();
        LeaveCriticalSection(&const_cast<CRITICAL_SECTION&>(m_cs));
        return size;
    }
    
    bool Empty() const {
        return Size() == 0;
    }
    
    void Shutdown() {
        EnterCriticalSection(&m_cs);
        m_shutdown = true;
        WakeAllConditionVariable(&m_notEmpty);
        WakeAllConditionVariable(&m_notFull);
        LeaveCriticalSection(&m_cs);
    }
};

// 게임 이벤트 처리 시스템
class GameEventSystem {
public:
    enum class EventType {
        PLAYER_LOGIN,
        PLAYER_LOGOUT,
        PLAYER_MOVE,
        PLAYER_ATTACK,
        PLAYER_CHAT,
        SYSTEM_SHUTDOWN
    };
    
    struct GameEvent {
        EventType type;
        int playerId;
        std::string data;
        std::chrono::steady_clock::time_point timestamp;
        
        GameEvent(EventType t, int pid, const std::string& d)
            : type(t), playerId(pid), data(d) {
            timestamp = std::chrono::steady_clock::now();
        }
    };
    
private:
    ThreadSafeQueue<GameEvent> m_eventQueue;
    std::vector<std::thread> m_processorThreads;
    std::atomic<bool> m_running;
    
    // 이벤트 통계
    std::atomic<long long> m_totalEvents;
    std::atomic<long long> m_processedEvents;
    std::array<std::atomic<long long>, 6> m_eventTypeCounts; // EventType 개수만큼
    
public:
    GameEventSystem(size_t queueSize = 10000, int processorCount = 4) 
        : m_eventQueue(queueSize), m_running(false), 
          m_totalEvents(0), m_processedEvents(0) {
        
        // 이벤트 타입별 카운터 초기화
        for (auto& counter : m_eventTypeCounts) {
            counter = 0;
        }
    }
    
    ~GameEventSystem() {
        Stop();
    }
    
    bool Start(int processorCount = 4) {
        if (m_running.load()) return false;
        
        m_running = true;
        
        // 이벤트 처리 스레드들 시작
        for (int i = 0; i < processorCount; ++i) {
            m_processorThreads.emplace_back([this, i]() { ProcessorThread(i); });
        }
        
        std::cout << "게임 이벤트 시스템 시작됨 (" << processorCount << "개 처리기)" << std::endl;
        return true;
    }
    
    void Stop() {
        if (!m_running.load()) return;
        
        std::cout << "게임 이벤트 시스템 중지 중..." << std::endl;
        
        // 종료 이벤트 전송
        AddEvent(EventType::SYSTEM_SHUTDOWN, 0, "shutdown");
        
        m_running = false;
        m_eventQueue.Shutdown();
        
        // 모든 처리 스레드 완료 대기
        for (auto& thread : m_processorThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        
        m_processorThreads.clear();
        
        PrintStatistics();
        std::cout << "게임 이벤트 시스템 중지됨" << std::endl;
    }
    
    bool AddEvent(EventType type, int playerId, const std::string& data, DWORD timeoutMs = 1000) {
        if (!m_running.load() && type != EventType::SYSTEM_SHUTDOWN) {
            return false;
        }
        
        GameEvent event(type, playerId, data);
        
        if (m_eventQueue.Push(event, timeoutMs)) {
            m_totalEvents.fetch_add(1);
            m_eventTypeCounts[static_cast<int>(type)].fetch_add(1);
            return true;
        }
        
        return false;
    }
    
    void PrintStatistics() {
        std::cout << "\n=== 이벤트 시스템 통계 ===" << std::endl;
        std::cout << "총 이벤트 수: " << m_totalEvents.load() << std::endl;
        std::cout << "처리된 이벤트: " << m_processedEvents.load() << std::endl;
        std::cout << "대기 중인 이벤트: " << m_eventQueue.Size() << std::endl;
        
        const char* eventTypeNames[] = {
            "PLAYER_LOGIN", "PLAYER_LOGOUT", "PLAYER_MOVE",
            "PLAYER_ATTACK", "PLAYER_CHAT", "SYSTEM_SHUTDOWN"
        };
        
        std::cout << "\n이벤트 타입별 통계:" << std::endl;
        for (int i = 0; i < m_eventTypeCounts.size(); ++i) {
            long long count = m_eventTypeCounts[i].load();
            if (count > 0) {
                std::cout << "  " << eventTypeNames[i] << ": " << count << std::endl;
            }
        }
        
        if (m_totalEvents.load() > 0) {
            double processRate = (m_processedEvents.load() * 100.0) / m_totalEvents.load();
            std::cout << "처리율: " << std::fixed << std::setprecision(2) << processRate << "%" << std::endl;
        }
    }
    
private:
    void ProcessorThread(int threadId) {
        std::cout << "이벤트 처리 스레드 " << threadId << " 시작 (TID: " << GetCurrentThreadId() << ")" << std::endl;
        
        GameEvent event(EventType::PLAYER_LOGIN, 0, "");
        
        while (m_running.load()) {
            // 이벤트 대기 (최대 1초)
            if (m_eventQueue.Pop(event, 1000)) {
                ProcessEvent(event);
                m_processedEvents.fetch_add(1);
                
                // 종료 이벤트 확인
                if (event.type == EventType::SYSTEM_SHUTDOWN) {
                    break;
                }
            }
        }
        
        // 남은 이벤트들 처리
        while (m_eventQueue.TryPop(event)) {
            if (event.type != EventType::SYSTEM_SHUTDOWN) {
                ProcessEvent(event);
                m_processedEvents.fetch_add(1);
            }
        }
        
        std::cout << "이벤트 처리 스레드 " << threadId << " 종료" << std::endl;
    }
    
    void ProcessEvent(const GameEvent& event) {
        // 이벤트 처리 지연 시간 계산
        auto now = std::chrono::steady_clock::now();
        auto latency = std::chrono::duration_cast<std::chrono::milliseconds>(now - event.timestamp);
        
        // 이벤트 타입별 처리
        switch (event.type) {
            case EventType::PLAYER_LOGIN:
                HandlePlayerLogin(event);
                break;
                
            case EventType::PLAYER_LOGOUT:
                HandlePlayerLogout(event);
                break;
                
            case EventType::PLAYER_MOVE:
                HandlePlayerMove(event);
                break;
                
            case EventType::PLAYER_ATTACK:
                HandlePlayerAttack(event);
                break;
                
            case EventType::PLAYER_CHAT:
                HandlePlayerChat(event);
                break;
                
            case EventType::SYSTEM_SHUTDOWN:
                std::cout << "시스템 종료 이벤트 수신" << std::endl;
                break;
        }
        
        // 지연 시간이 긴 이벤트 로깅
        if (latency.count() > 100) { // 100ms 이상
            std::cout << "⚠️ 높은 지연 시간: " << latency.count() << "ms" << std::endl;
        }
    }
    
    void HandlePlayerLogin(const GameEvent& event) {
        // 로그인 처리 시뮬레이션
        Sleep(10 + (rand() % 20)); // 10-30ms
        
        if (event.playerId % 1000 == 0) {
            std::cout << "플레이어 " << event.playerId << " 로그인 처리 완료" << std::endl;
        }
    }
    
    void HandlePlayerLogout(const GameEvent& event) {
        // 로그아웃 처리 시뮬레이션
        Sleep(5 + (rand() % 10)); // 5-15ms
        
        if (event.playerId % 1000 == 0) {
            std::cout << "플레이어 " << event.playerId << " 로그아웃 처리 완료" << std::endl;
        }
    }
    
    void HandlePlayerMove(const GameEvent& event) {
        // 이동 처리 시뮬레이션 (빠른 처리)
        Sleep(1); // 1ms
    }
    
    void HandlePlayerAttack(const GameEvent& event) {
        // 공격 처리 시뮬레이션
        Sleep(5 + (rand() % 10)); // 5-15ms
    }
    
    void HandlePlayerChat(const GameEvent& event) {
        // 채팅 처리 시뮬레이션
        Sleep(2 + (rand() % 5)); // 2-7ms
    }
};

// Condition Variable 테스트
void TestConditionVariable() {
    std::cout << "\n=== Condition Variable 테스트 ===" << std::endl;
    
    GameEventSystem eventSystem(5000, 6); // 큐 크기 5000, 처리기 6개
    
    if (!eventSystem.Start()) {
        std::cout << "이벤트 시스템 시작 실패" << std::endl;
        return;
    }
    
    // 이벤트 생성 스레드들
    std::vector<std::thread> producers;
    std::atomic<bool> generating{true};
    
    // 플레이어 로그인/로그아웃 시뮬레이션
    producers.emplace_back([&eventSystem, &generating]() {
        int playerId = 1;
        while (generating.load()) {
            // 로그인
            eventSystem.AddEvent(GameEventSystem::EventType::PLAYER_LOGIN, playerId, 
                               "Player" + std::to_string(playerId));
            
            Sleep(50 + (rand() % 100)); // 50-150ms 간격
            
            // 일부 플레이어는 바로 로그아웃
            if (rand() % 10 < 3) {
                eventSystem.AddEvent(GameEventSystem::EventType::PLAYER_LOGOUT, playerId, "");
            }
            
            playerId++;
        }
    });
    
    // 플레이어 이동 시뮬레이션 (높은 빈도)
    producers.emplace_back([&eventSystem, &generating]() {
        while (generating.load()) {
            int playerId = 1 + (rand() % 1000);
            std::string position = std::to_string(rand() % 1000) + "," + 
                                 std::to_string(rand() % 1000) + "," + 
                                 std::to_string(rand() % 100);
            
            eventSystem.AddEvent(GameEventSystem::EventType::PLAYER_MOVE, playerId, position);
            
            Sleep(5 + (rand() % 10)); // 5-15ms 간격 (높은 빈도)
        }
    });
    
    // 플레이어 공격 시뮬레이션
    producers.emplace_back([&eventSystem, &generating]() {
        while (generating.load()) {
            int attackerId = 1 + (rand() % 1000);
            int targetId = 1 + (rand() % 1000);
            std::string attackData = "target:" + std::to_string(targetId) + ",damage:50";
            
            eventSystem.AddEvent(GameEventSystem::EventType::PLAYER_ATTACK, attackerId, attackData);
            
            Sleep(100 + (rand() % 200)); // 100-300ms 간격
        }
    });
    
    // 채팅 메시지 시뮬레이션
    producers.emplace_back([&eventSystem, &generating]() {
        const std::vector<std::string> messages = {
            "Hello everyone!", "How are you?", "Great game!", 
            "Anyone want to team up?", "Good luck!", "GG WP!"
        };
        
        while (generating.load()) {
            int playerId = 1 + (rand() % 1000);
            std::string message = messages[rand() % messages.size()];
            
            eventSystem.AddEvent(GameEventSystem::EventType::PLAYER_CHAT, playerId, message);
            
            Sleep(500 + (rand() % 1500)); // 500-2000ms 간격
        }
    });
    
    // 통계 출력 스레드
    std::thread monitor([&eventSystem, &generating]() {
        while (generating.load()) {
            Sleep(3000);
            eventSystem.PrintStatistics();
        }
    });
    
    // 10초간 테스트 실행
    std::cout << "Condition Variable 테스트 실행 중 (10초)..." << std::endl;
    Sleep(10000);
    
    // 이벤트 생성 중지
    generating = false;
    
    // 생산자 스레드들 완료 대기
    for (auto& producer : producers) {
        producer.join();
    }
    
    if (monitor.joinable()) {
        monitor.join();
    }
    
    // 이벤트 시스템 중지
    eventSystem.Stop();
}
```
   
이번 예제는 **게임 서버에서 발생하는 이벤트들을 안전하게 큐(Queue)로 관리하고**,
생산자(Producer)와 소비자(Consumer) 스레드가 효율적으로 협력하도록 만드는 **Condition Variable 패턴**을 다룬다.

Condition Variable은 “**조건이 충족될 때만 스레드를 깨우는 동기화 도구**”이다.
즉, 큐가 비었을 때 소비자가 기다리고, 큐가 꽉 찼을 때 생산자가 잠시 멈추는 방식으로,
**불필요한 CPU 낭비(바쁜 대기, busy waiting)를 완전히 없앤다.**

이 구조는 **게임 이벤트 처리 시스템**, **작업 큐(job queue)**, **로깅 시스템** 등에서 자주 사용된다.


### 1. Condition Variable의 개념과 작동 구조
Condition Variable은 보통 **뮤텍스(Critical Section)** 와 함께 사용된다.
뮤텍스로 데이터 접근을 보호하면서, 특정 조건이 만족되지 않으면 스레드를 **자동으로 기다리게(sleep)** 한다.

```
┌─────────────────────────────────────────────────────────────┐
│                Condition Variable Pattern                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Producer Thread              Consumer Thread               │
│  ┌─────────────────┐          ┌─────────────────┐           │
│  │ Wait for Space  │          │ Wait for Item   │           │
│  │ (NotFull CV)    │          │ (NotEmpty CV)   │           │
│  └─────────────────┘          └─────────────────┘           │
│           │                            │                    │
│           ▼                            ▼                    │
│  ┌─────────────────┐          ┌─────────────────┐           │
│  │   Add Item      │          │  Remove Item    │           │
│  │   to Queue      │          │  from Queue     │           │
│  └─────────────────┘          └─────────────────┘           │
│           │                            │                    │
│           ▼                            ▼                    │
│  ┌─────────────────┐          ┌─────────────────┐           │
│  │ Signal NotEmpty │          │ Signal NotFull  │           │
│  └─────────────────┘          └─────────────────┘           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

이 구조의 장점은 다음과 같다.

* **효율적이다.** 스레드가 조건을 기다릴 때 CPU를 점유하지 않는다.
* **자동으로 깨운다.** 조건이 바뀌면 기다리던 스레드가 즉시 깨어난다.
* **데드락 방지**와 **조건 신호화**가 간단하게 처리된다.

### 2. ThreadSafeQueue — 스레드 안전한 큐 구조
먼저 Condition Variable을 이용한 기본 자료구조 `ThreadSafeQueue`를 살펴보자.

```cpp
template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> m_queue;
    CRITICAL_SECTION m_cs;
    CONDITION_VARIABLE m_notEmpty;
    CONDITION_VARIABLE m_notFull;
    size_t m_maxSize;
    std::atomic<bool> m_shutdown;
```

이 클래스는 `std::queue`를 기반으로 하며,
생산자-소비자 간 동기화를 위해 두 개의 Condition Variable을 사용한다.

* `m_notEmpty`: 큐가 비어 있을 때 소비자가 기다린다.
* `m_notFull`: 큐가 가득 찼을 때 생산자가 기다린다.

#### 큐 초기화

```cpp
InitializeCriticalSection(&m_cs);
InitializeConditionVariable(&m_notEmpty);
InitializeConditionVariable(&m_notFull);
```

이 초기화 과정으로 **멀티스레드 환경에서도 안전하게 동작하는 큐**가 완성된다.


### 3. 생산자(Producer) 동작 — `Push()`

```cpp
bool Push(const T& item, DWORD timeoutMs = INFINITE) {
    EnterCriticalSection(&m_cs);
    while (m_queue.size() >= m_maxSize && !m_shutdown.load()) {
        SleepConditionVariableCS(&m_notFull, &m_cs, timeoutMs);
    }
    ...
    m_queue.push(item);
    WakeAllConditionVariable(&m_notEmpty);
    LeaveCriticalSection(&m_cs);
}
```

* 생산자가 새 데이터를 추가하려고 할 때 큐가 꽉 차면 `SleepConditionVariableCS()`로 잠시 대기한다.
* 다른 스레드가 큐에서 데이터를 꺼내면 `m_notFull` 신호가 발생해 대기 중인 생산자가 깨어난다.
* 데이터가 성공적으로 추가되면 소비자들을 깨우기 위해 `WakeAllConditionVariable(&m_notEmpty)`를 호출한다.

즉, 생산자는 “큐에 공간이 생길 때까지 잠든다.”


### 4. 소비자(Consumer) 동작 — `Pop()`

```cpp
bool Pop(T& item, DWORD timeoutMs = INFINITE) {
    EnterCriticalSection(&m_cs);
    while (m_queue.empty() && !m_shutdown.load()) {
        SleepConditionVariableCS(&m_notEmpty, &m_cs, timeoutMs);
    }
    ...
    item = m_queue.front();
    m_queue.pop();
    WakeAllConditionVariable(&m_notFull);
    LeaveCriticalSection(&m_cs);
}
```

* 소비자가 데이터를 꺼내려 하지만 큐가 비어 있으면 `SleepConditionVariableCS()`로 대기한다.
* 생산자가 새 데이터를 넣으면 `WakeAllConditionVariable(&m_notEmpty)`로 신호를 보내 소비자를 깨운다.
* 아이템을 꺼내면 큐가 비워지므로 `m_notFull`을 통해 대기 중인 생산자에게 “공간이 생겼다”는 신호를 보낸다.

즉, 소비자는 “큐에 아이템이 들어올 때까지 잠든다.”


### 5. GameEventSystem — 게임 서버 이벤트 처리 시스템
이제 Condition Variable 기반 큐를 이용해 **이벤트 처리 시스템**을 구축한다.

```cpp
class GameEventSystem {
    ThreadSafeQueue<GameEvent> m_eventQueue;
    std::vector<std::thread> m_processorThreads;
    std::atomic<bool> m_running;
```

* `m_eventQueue`: 이벤트를 저장하는 공유 큐다.
* `m_processorThreads`: 이벤트를 처리하는 여러 소비자 스레드이다.
* `m_running`: 시스템이 실행 중인지 상태를 나타낸다.

#### 이벤트 구조체

```cpp
struct GameEvent {
    EventType type;
    int playerId;
    std::string data;
    std::chrono::steady_clock::time_point timestamp;
};
```

각 이벤트는 종류, 플레이어 ID, 데이터, 그리고 발생 시각을 포함한다.


### 6. 이벤트 처리 흐름

#### (1) 이벤트 생성 (Producer 역할)

```cpp
eventSystem.AddEvent(GameEventSystem::EventType::PLAYER_LOGIN, playerId, "Player123");
```

* 여러 개의 생산자 스레드가 `AddEvent()`를 통해 이벤트를 큐에 넣는다.
* 예: 로그인, 이동, 공격, 채팅 등의 다양한 이벤트를 무작위로 발생시킨다.

#### (2) 이벤트 소비 (Consumer 역할)

```cpp
void ProcessorThread(int threadId) {
    while (m_running.load()) {
        if (m_eventQueue.Pop(event, 1000)) {
            ProcessEvent(event);
        }
    }
}
```

* 이벤트 처리 스레드는 `Pop()`으로 큐에서 이벤트를 꺼내 처리한다.
* 큐가 비어 있으면 Condition Variable 덕분에 자동으로 대기 상태가 된다.
* 종료 이벤트(`SYSTEM_SHUTDOWN`)를 받으면 루프를 종료한다.

#### (3) 이벤트 처리 예시

```cpp
void HandlePlayerAttack(const GameEvent& event) {
    Sleep(5 + (rand() % 10)); // 5~15ms 처리 시간
}
```

각 이벤트 타입마다 별도의 핸들러를 통해 실제 게임 로직을 시뮬레이션한다.

### 7. 시스템 종료와 통계 출력

```cpp
void Stop() {
    AddEvent(EventType::SYSTEM_SHUTDOWN, 0, "shutdown");
    m_eventQueue.Shutdown();
    for (auto& t : m_processorThreads) t.join();
}
```

* 종료 시 `SYSTEM_SHUTDOWN` 이벤트를 넣어 모든 소비자 스레드를 깨운다.
* `Shutdown()`은 모든 Condition Variable을 깨워서 대기 중인 스레드가 즉시 종료되게 한다.

`PrintStatistics()` 함수는 전체 이벤트 수, 처리된 이벤트 수, 각 타입별 비율 등을 출력한다.

### 8. Condition Variable 테스트 시나리오
테스트 함수 `TestConditionVariable()`은
6개의 소비자 스레드와 여러 종류의 생산자 스레드를 만들어 10초간 시스템을 실행한다.

* **로그인/로그아웃 스레드**: 플레이어의 접속/종료 이벤트 발생
* **이동 스레드**: 짧은 주기로 위치 갱신 이벤트 발생
* **공격 스레드**: 간헐적으로 공격 이벤트 발생
* **채팅 스레드**: 플레이어 메시지 이벤트 발생
* **모니터 스레드**: 주기적으로 통계 출력

테스트가 끝나면 시스템은 자동으로 종료된다.

### 9. 핵심 요약

| 구분                     | 설명                                 |
| ---------------------- | ---------------------------------- |
| **Condition Variable** | 특정 조건이 충족될 때까지 스레드를 효율적으로 대기시키는 도구 |
| **Producer (Push)**    | 큐가 가득 차면 대기, 공간이 생기면 다시 작동         |
| **Consumer (Pop)**     | 큐가 비면 대기, 데이터가 들어오면 자동으로 깨어남       |
| **게임 서버 활용 예시**        | 이벤트 큐, 로그 처리, 비동기 명령 대기 등          |
| **장점**                 | CPU 낭비 없음, 스레드 간 효율적 협업, 자연스러운 동기화 |


이 예제는 **게임 서버의 핵심 패턴 중 하나인 Condition Variable 기반 이벤트 처리 모델**을 보여준다.
이 패턴을 사용하면 수많은 스레드가 서로의 작업을 방해하지 않고,
**필요할 때만 깨어나서 작업을 처리하는 효율적인 서버 구조**를 만들 수 있다.

즉, Condition Variable은 **비동기 이벤트 처리의 기본기이자, 고성능 서버 설계의 핵심 요소**이다.
   

</br>    

## 5.5 실습 예제: 종합 동기화 시스템
모든 동기화 객체를 활용한 종합적인 게임 서버 시스템을 구현해보겠다.

```cpp
int main() {
    try {
        std::cout << "=== 게임 서버 동기화 객체 심화 과정 ===" << std::endl;
        
        // 1. 성능 벤치마크
        AdvancedSyncBenchmark benchmark;
        benchmark.RunComprehensiveBenchmark();
        
        // 2. 게임 서버 시나리오별 테스트
        GameServerSyncGuide guide;
        guide.DemonstrateScenarios();
        
        // 3. 세마포어 테스트 (데이터베이스 연결 풀)
        TestDatabaseConnectionPool();
        
        // 4. Event 객체 테스트 (게임 세션 관리)
        TestGameSessionManager();
        
        // 5. SRWLock 성능 테스트
        TestSRWLockPerformance();
        
        // 6. Condition Variable 테스트
        TestConditionVariable();
        
        std::cout << "\n=== 모든 테스트 완료 ===" << std::endl;
        
    } catch (const std::exception& e) {
        std::cout << "오류 발생: " << e.what() << std::endl;
        return 1;
    }
    
    std::cout << "\n동기화 객체 심화 과정이 완료되었습니다!" << std::endl;
    return 0;
}
```

이 장에서는 게임 서버 개발에 필수적인 고급 동기화 기법들을 상세히 다뤘다. Critical Section, Mutex, SRWLock, Semaphore, Event, 그리고 Condition Variable 등 각 동기화 객체의 특성과 적절한 사용 시나리오를 실제 게임 서버 환경에서 활용하는 방법을 학습했다. 다음 장에서는 더욱 고성능이 요구되는 무잠금(Lock-free) 프로그래밍 기법을 알아보겠다.


