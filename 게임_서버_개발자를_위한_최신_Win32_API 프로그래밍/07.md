# ê²Œì„ ì„œë²„ ê°œë°œìë¥¼ ìœ„í•œ ìµœì‹  Win32 API í”„ë¡œê·¸ë˜ë°  

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  

# Chapter 7. ì„±ëŠ¥ ì¹´ìš´í„°ì™€ í”„ë¡œíŒŒì¼ë§

## 7.1 ë“¤ì–´ê°€ë©°
ê²Œì„ ì„œë²„ëŠ” ìˆ˜ë§ì€ í”Œë ˆì´ì–´ì˜ ìš”ì²­ì„ ë™ì‹œì— ì²˜ë¦¬í•´ì•¼ í•˜ë¯€ë¡œ, ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ê³¼ ìµœì í™”ê°€ ë§¤ìš° ì¤‘ìš”í•˜ë‹¤. ì„±ëŠ¥ ë¬¸ì œë¥¼ ì¡°ê¸°ì— ë°œê²¬í•˜ê³  í•´ê²°í•˜ê¸° ìœ„í•´ì„œëŠ” ì ì ˆí•œ ëª¨ë‹ˆí„°ë§ ë„êµ¬ì™€ í”„ë¡œíŒŒì¼ë§ ê¸°ë²•ì´ í•„ìš”í•˜ë‹¤.

```
ê²Œì„ ì„œë²„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ê³„ì¸µ:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Application Level        â”‚  â† ê²Œì„ ë¡œì§ ì„±ëŠ¥
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Framework Level          â”‚  â† ë„¤íŠ¸ì›Œí¬, DB ì„±ëŠ¥
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    OS Level                 â”‚  â† CPU, ë©”ëª¨ë¦¬, I/O
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Hardware Level           â”‚  â† ë¬¼ë¦¬ì  í•˜ë“œì›¨ì–´
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ì´ë²ˆ ì¥ì—ì„œëŠ” Windowsì—ì„œ ì œê³µí•˜ëŠ” Performance Counter API, ETW(Event Tracing for Windows), ê·¸ë¦¬ê³  Visual Studio í”„ë¡œíŒŒì¼ëŸ¬ë¥¼ í™œìš©í•œ ì„±ëŠ¥ ë¶„ì„ ë°©ë²•ì„ ì•Œì•„ë³´ê² ë‹¤.
  

</br>  
  
## 7.2 Performance Counter API í™œìš©

### 7.2.1 Performance Counter ê¸°ì´ˆ
Performance CounterëŠ” Windows ì‹œìŠ¤í…œì—ì„œ ë‹¤ì–‘í•œ ì„±ëŠ¥ ì§€í‘œë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” APIì´ë‹¤.

```cpp
#include <Windows.h>
#include <Pdh.h>
#include <iostream>
#include <string>
#include <vector>

#pragma comment(lib, "Pdh.lib")

class PerformanceMonitor {
private:
    PDH_HQUERY queryHandle = nullptr;
    
    struct CounterInfo {
        PDH_HCOUNTER handle;
        std::string name;
        std::string description;
        
        CounterInfo(const std::string& n, const std::string& d) 
            : handle(nullptr), name(n), description(d) {}
    };
    
    std::vector<CounterInfo> counters;
    
public:
    PerformanceMonitor() {
        PDH_STATUS status = PdhOpenQueryW(nullptr, 0, &queryHandle);
        if (status != ERROR_SUCCESS) {
            throw std::runtime_error("PDH ì¿¼ë¦¬ ìƒì„± ì‹¤íŒ¨: " + std::to_string(status));
        }
    }
    
    ~PerformanceMonitor() {
        if (queryHandle) {
            // ëª¨ë“  ì¹´ìš´í„° ì œê±°
            for (auto& counter : counters) {
                if (counter.handle) {
                    PdhRemoveCounter(counter.handle);
                }
            }
            PdhCloseQuery(queryHandle);
        }
    }
    
    bool addCounter(const std::string& counterPath, const std::string& description) {
        CounterInfo info(counterPath, description);
        
        // ì¹´ìš´í„° ê²½ë¡œë¥¼ ì™€ì´ë“œ ë¬¸ìë¡œ ë³€í™˜
        std::wstring wCounterPath(counterPath.begin(), counterPath.end());
        
        PDH_STATUS status = PdhAddCounterW(queryHandle, wCounterPath.c_str(), 
                                          0, &info.handle);
        
        if (status != ERROR_SUCCESS) {
            std::cout << "ì¹´ìš´í„° ì¶”ê°€ ì‹¤íŒ¨ [" << counterPath << "]: " 
                     << std::to_string(status) << std::endl;
            return false;
        }
        
        counters.push_back(info);
        return true;
    }
    
    void collectData() {
        PDH_STATUS status = PdhCollectQueryData(queryHandle);
        if (status != ERROR_SUCCESS) {
            std::cout << "ë°ì´í„° ìˆ˜ì§‘ ì‹¤íŒ¨: " << std::to_string(status) << std::endl;
        }
    }
    
    double getCounterValue(size_t index) {
        if (index >= counters.size()) {
            return -1.0;
        }
        
        PDH_FMT_COUNTERVALUE counterValue;
        PDH_STATUS status = PdhGetFormattedCounterValue(
            counters[index].handle, 
            PDH_FMT_DOUBLE, 
            nullptr, 
            &counterValue
        );
        
        if (status != ERROR_SUCCESS) {
            return -1.0;
        }
        
        return counterValue.doubleValue;
    }
    
    void printAllCounters() {
        std::cout << "\n=== ì„±ëŠ¥ ì¹´ìš´í„° í˜„í™© ===\n";
        for (size_t i = 0; i < counters.size(); ++i) {
            double value = getCounterValue(i);
            std::cout << counters[i].description << ": ";
            
            if (value >= 0) {
                std::cout << value;
            } else {
                std::cout << "N/A";
            }
            std::cout << std::endl;
        }
        std::cout << "========================\n\n";
    }
};
```

### 7.2.2 ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§

```cpp
class SystemResourceMonitor {
private:
    PerformanceMonitor perfMon;
    bool initialized = false;
    
public:
    SystemResourceMonitor() {
        try {
            // CPU ì‚¬ìš©ë¥  ëª¨ë‹ˆí„°ë§
            perfMon.addCounter("\\Processor(_Total)\\% Processor Time", 
                             "ì „ì²´ CPU ì‚¬ìš©ë¥  (%)");
            
            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
            perfMon.addCounter("\\Memory\\Available MBytes", 
                             "ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ (MB)");
            perfMon.addCounter("\\Memory\\Committed Bytes", 
                             "ì»¤ë°‹ëœ ë©”ëª¨ë¦¬ (Bytes)");
            
            // ë””ìŠ¤í¬ I/O ëª¨ë‹ˆí„°ë§
            perfMon.addCounter("\\PhysicalDisk(_Total)\\Disk Reads/sec", 
                             "ë””ìŠ¤í¬ ì½ê¸°/ì´ˆ");
            perfMon.addCounter("\\PhysicalDisk(_Total)\\Disk Writes/sec", 
                             "ë””ìŠ¤í¬ ì“°ê¸°/ì´ˆ");
            
            // ë„¤íŠ¸ì›Œí¬ I/O ëª¨ë‹ˆí„°ë§
            perfMon.addCounter("\\Network Interface(*)\\Bytes Total/sec", 
                             "ë„¤íŠ¸ì›Œí¬ ì´ ë°”ì´íŠ¸/ì´ˆ");
            
            // í”„ë¡œì„¸ìŠ¤ë³„ ëª¨ë‹ˆí„°ë§ (í˜„ì¬ í”„ë¡œì„¸ìŠ¤)
            std::string processName = getCurrentProcessName();
            
            perfMon.addCounter("\\Process(" + processName + ")\\% Processor Time", 
                             "í”„ë¡œì„¸ìŠ¤ CPU ì‚¬ìš©ë¥  (%)");
            perfMon.addCounter("\\Process(" + processName + ")\\Working Set", 
                             "í”„ë¡œì„¸ìŠ¤ ì›Œí‚¹ì…‹ (Bytes)");
            perfMon.addCounter("\\Process(" + processName + ")\\Private Bytes", 
                             "í”„ë¡œì„¸ìŠ¤ ì „ìš© ë©”ëª¨ë¦¬ (Bytes)");
            
            initialized = true;
            
            // ì²« ë²ˆì§¸ ë°ì´í„° ìˆ˜ì§‘ (ì´ˆê¸°í™”ìš©)
            perfMon.collectData();
            Sleep(1000);  // 1ì´ˆ ëŒ€ê¸° í›„ ë‹¤ì‹œ ìˆ˜ì§‘
            
        } catch (const std::exception& e) {
            std::cout << "ì„±ëŠ¥ ëª¨ë‹ˆí„° ì´ˆê¸°í™” ì‹¤íŒ¨: " << e.what() << std::endl;
        }
    }
    
    void update() {
        if (!initialized) return;
        
        perfMon.collectData();
    }
    
    void printSystemStatus() {
        if (!initialized) {
            std::cout << "ì„±ëŠ¥ ëª¨ë‹ˆí„°ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n";
            return;
        }
        
        perfMon.printAllCounters();
    }
    
private:
    std::string getCurrentProcessName() {
        char buffer[MAX_PATH];
        DWORD size = GetModuleFileNameA(nullptr, buffer, MAX_PATH);
        
        if (size > 0) {
            std::string fullPath(buffer);
            size_t lastSlash = fullPath.find_last_of("\\/");
            if (lastSlash != std::string::npos) {
                std::string fileName = fullPath.substr(lastSlash + 1);
                size_t lastDot = fileName.find_last_of(".");
                if (lastDot != std::string::npos) {
                    return fileName.substr(0, lastDot);
                }
                return fileName;
            }
        }
        
        return "Unknown";
    }
};
```

### 7.2.3 ê²Œì„ ì„œë²„ ì „ìš© ì„±ëŠ¥ ì¹´ìš´í„°

```cpp
class GameServerPerformanceCounter {
private:
    // ê²Œì„ ì„œë²„ íŠ¹í™” ë©”íŠ¸ë¦­
    std::atomic<uint64_t> totalConnections{0};
    std::atomic<uint64_t> activeConnections{0};
    std::atomic<uint64_t> messagesPerSecond{0};
    std::atomic<uint64_t> bytesPerSecond{0};
    std::atomic<uint64_t> totalErrors{0};
    
    // ì„±ëŠ¥ ì¸¡ì •ì„ ìœ„í•œ ì‹œê°„ ì •ë³´
    std::chrono::steady_clock::time_point lastUpdateTime;
    std::atomic<uint64_t> messageCount{0};
    std::atomic<uint64_t> byteCount{0};
    
    SystemResourceMonitor systemMonitor;
    
public:
    GameServerPerformanceCounter() {
        lastUpdateTime = std::chrono::steady_clock::now();
    }
    
    // ì—°ê²° ê´€ë ¨ ë©”íŠ¸ë¦­
    void onPlayerConnect() {
        totalConnections.fetch_add(1);
        activeConnections.fetch_add(1);
    }
    
    void onPlayerDisconnect() {
        activeConnections.fetch_sub(1);
    }
    
    // ë©”ì‹œì§€ ì²˜ë¦¬ ë©”íŠ¸ë¦­
    void onMessageProcessed(size_t bytes) {
        messageCount.fetch_add(1);
        byteCount.fetch_add(bytes);
    }
    
    // ì—ëŸ¬ ë©”íŠ¸ë¦­
    void onError() {
        totalErrors.fetch_add(1);
    }
    
    // ì´ˆë‹¹ í†µê³„ ì—…ë°ì´íŠ¸
    void updatePerSecondStats() {
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            now - lastUpdateTime);
        
        if (elapsed.count() >= 1000) {  // 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
            uint64_t currentMessages = messageCount.exchange(0);
            uint64_t currentBytes = byteCount.exchange(0);
            
            double seconds = elapsed.count() / 1000.0;
            messagesPerSecond.store(static_cast<uint64_t>(currentMessages / seconds));
            bytesPerSecond.store(static_cast<uint64_t>(currentBytes / seconds));
            
            lastUpdateTime = now;
        }
        
        // ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ì—…ë°ì´íŠ¸
        systemMonitor.update();
    }
    
    // í†µê³„ ì¶œë ¥
    void printGameServerStats() {
        std::cout << "\n=== ê²Œì„ ì„œë²„ ì„±ëŠ¥ í†µê³„ ===\n";
        std::cout << "ì´ ì—°ê²° ìˆ˜: " << totalConnections.load() << std::endl;
        std::cout << "í™œì„± ì—°ê²° ìˆ˜: " << activeConnections.load() << std::endl;
        std::cout << "ë©”ì‹œì§€/ì´ˆ: " << messagesPerSecond.load() << std::endl;
        std::cout << "ë°”ì´íŠ¸/ì´ˆ: " << formatBytes(bytesPerSecond.load()) << std::endl;
        std::cout << "ì´ ì—ëŸ¬ ìˆ˜: " << totalErrors.load() << std::endl;
        std::cout << "===========================\n";
        
        // ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ í˜„í™©
        systemMonitor.printSystemStatus();
    }
    
    // ì„±ëŠ¥ ë°ì´í„° êµ¬ì¡°ì²´
    struct PerformanceData {
        uint64_t totalConnections;
        uint64_t activeConnections;
        uint64_t messagesPerSecond;
        uint64_t bytesPerSecond;
        uint64_t totalErrors;
    };
    
    PerformanceData getPerformanceData() const {
        return {
            totalConnections.load(),
            activeConnections.load(),
            messagesPerSecond.load(),
            bytesPerSecond.load(),
            totalErrors.load()
        };
    }
    
private:
    std::string formatBytes(uint64_t bytes) {
        const char* units[] = {"B", "KB", "MB", "GB", "TB"};
        int unit = 0;
        double size = static_cast<double>(bytes);
        
        while (size >= 1024.0 && unit < 4) {
            size /= 1024.0;
            unit++;
        }
        
        char buffer[64];
        snprintf(buffer, sizeof(buffer), "%.2f %s", size, units[unit]);
        return std::string(buffer);
    }
};
```
   

</br>  
  
## 7.3 CPU ì‚¬ìš©ë¥  ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§

### 7.3.1 ì •ë°€í•œ CPU ì‚¬ìš©ë¥  ì¸¡ì •

```cpp
#include <Windows.h>
#include <iostream>
#include <thread>
#include <chrono>

class PreciseCpuMonitor {
private:
    ULARGE_INTEGER lastCPU, lastSysCPU, lastUserCPU;
    int numProcessors;
    HANDLE self;
    
public:
    PreciseCpuMonitor() {
        SYSTEM_INFO sysInfo;
        FILETIME ftime, fsys, fuser;
        
        GetSystemInfo(&sysInfo);
        numProcessors = sysInfo.dwNumberOfProcessors;
        
        GetSystemTimeAsFileTime(&ftime);
        memcpy(&lastCPU, &ftime, sizeof(FILETIME));
        
        self = GetCurrentProcess();
        GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
        memcpy(&lastSysCPU, &fsys, sizeof(FILETIME));
        memcpy(&lastUserCPU, &fuser, sizeof(FILETIME));
    }
    
    double getCurrentCpuUsage() {
        FILETIME ftime, fsys, fuser;
        ULARGE_INTEGER now, sys, user;
        double percent;
        
        GetSystemTimeAsFileTime(&ftime);
        memcpy(&now, &ftime, sizeof(FILETIME));
        
        GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
        memcpy(&sys, &fsys, sizeof(FILETIME));
        memcpy(&user, &fuser, sizeof(FILETIME));
        
        percent = static_cast<double>(sys.QuadPart - lastSysCPU.QuadPart) +
                 static_cast<double>(user.QuadPart - lastUserCPU.QuadPart);
        
        percent /= static_cast<double>(now.QuadPart - lastCPU.QuadPart);
        percent /= numProcessors;
        
        lastCPU = now;
        lastUserCPU = user;
        lastSysCPU = sys;
        
        return percent * 100.0;
    }
    
    void printCpuInfo() {
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo);
        
        std::cout << "\n=== CPU ì •ë³´ ===\n";
        std::cout << "í”„ë¡œì„¸ì„œ ìˆ˜: " << sysInfo.dwNumberOfProcessors << std::endl;
        std::cout << "í”„ë¡œì„¸ì„œ ì•„í‚¤í…ì²˜: ";
        
        switch (sysInfo.wProcessorArchitecture) {
            case PROCESSOR_ARCHITECTURE_AMD64:
                std::cout << "x64 (AMD64)" << std::endl;
                break;
            case PROCESSOR_ARCHITECTURE_ARM:
                std::cout << "ARM" << std::endl;
                break;
            case PROCESSOR_ARCHITECTURE_ARM64:
                std::cout << "ARM64" << std::endl;
                break;
            case PROCESSOR_ARCHITECTURE_INTEL:
                std::cout << "x86 (Intel)" << std::endl;
                break;
            default:
                std::cout << "ì•Œ ìˆ˜ ì—†ìŒ" << std::endl;
                break;
        }
        
        std::cout << "í˜ì´ì§€ í¬ê¸°: " << sysInfo.dwPageSize << " bytes" << std::endl;
        std::cout << "===============\n\n";
    }
};
```
  
ì´ë²ˆì—ëŠ” **í”„ë¡œì„¸ìŠ¤ì˜ CPU ì‚¬ìš©ë¥ ì„ ì •ë°€í•˜ê²Œ ì¸¡ì •í•˜ëŠ” ë°©ë²•**ì„ ì‚´í´ë³¸ë‹¤.
ì´ í´ë˜ìŠ¤ëŠ” Windows í™˜ê²½ì—ì„œ **í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ê°€ CPUë¥¼ ì–¼ë§ˆë‚˜ ì‚¬ìš©í•˜ëŠ”ì§€ (%)ë¡œ ê³„ì‚°**í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

ì¼ë°˜ì ìœ¼ë¡œ `task manager`(ì‘ì—… ê´€ë¦¬ì)ì—ì„œë„ CPU ì‚¬ìš©ë¥ ì„ ë³¼ ìˆ˜ ìˆì§€ë§Œ,
ì´ ì½”ë“œëŠ” **C++ í”„ë¡œê·¸ë¨ ë‚´ì—ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ CPU ì‚¬ìš©ëŸ‰ì„ ê³„ì‚°**í•  ë•Œ ìœ ìš©í•˜ë‹¤.
ì˜ˆë¥¼ ë“¤ì–´, **ì„œë²„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**, **ë¦¬ì†ŒìŠ¤ ì‚¬ìš© ì¶”ì **, **ë³‘ëª© êµ¬ê°„ ë¶„ì„** ë“±ì— í™œìš©í•  ìˆ˜ ìˆë‹¤.


#### ğŸ§© ì „ì²´ ê°œë… ìš”ì•½
ì´ í”„ë¡œê·¸ë¨ì€ Windows APIì˜ `GetProcessTimes()` í•¨ìˆ˜ë¥¼ ì´ìš©í•´ â€œí”„ë¡œì„¸ìŠ¤ê°€ ì‹œìŠ¤í…œ CPUë¥¼ ì–¼ë§ˆë‚˜ ì‚¬ìš©í–ˆëŠ”ì§€â€ë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ ì¸¡ì •í•œë‹¤.

CPU ì‚¬ìš©ë¥ ì€ ë‹¤ìŒ ê³µì‹ìœ¼ë¡œ ê³„ì‚°ëœë‹¤:

```
CPU ì‚¬ìš©ë¥ (%) =
 (í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ ì‚¬ìš©ì ëª¨ë“œ + ì»¤ë„ ëª¨ë“œ CPU ì‹œê°„ ì¦ê°€ëŸ‰)
 ------------------------------------------------------- Ã— 100
         (ì‹œìŠ¤í…œ ì „ì²´ ì‹œê°„ ì¦ê°€ëŸ‰ Ã— í”„ë¡œì„¸ì„œ ìˆ˜)
```

ì¦‰, ì¸¡ì • ì‹œì  ì‚¬ì´ì—ì„œ **í”„ë¡œì„¸ìŠ¤ê°€ ì–¼ë§ˆë‚˜ CPUë¥¼ ì‚¬ìš©í–ˆëŠ”ê°€**ë¥¼ ì‹œê°„ ë¹„ìœ¨ë¡œ ê³„ì‚°í•˜ëŠ” êµ¬ì¡°ì´ë‹¤.


#### ğŸ§± í´ë˜ìŠ¤ ë©¤ë²„ êµ¬ì„±

```cpp
class PreciseCpuMonitor {
private:
    ULARGE_INTEGER lastCPU, lastSysCPU, lastUserCPU;
    int numProcessors;
    HANDLE self;
```

* **`lastCPU`** : ë§ˆì§€ë§‰ìœ¼ë¡œ ì¸¡ì •í•œ ì‹œìŠ¤í…œ ì „ì²´ ì‹œê°„
* **`lastSysCPU`** : ë§ˆì§€ë§‰ìœ¼ë¡œ ì¸¡ì •í•œ ì»¤ë„ ëª¨ë“œ ì‹œê°„
* **`lastUserCPU`** : ë§ˆì§€ë§‰ìœ¼ë¡œ ì¸¡ì •í•œ ì‚¬ìš©ì ëª¨ë“œ ì‹œê°„
* **`numProcessors`** : CPU ì½”ì–´ ê°œìˆ˜
* **`self`** : í˜„ì¬ í”„ë¡œì„¸ìŠ¤ í•¸ë“¤ (`GetCurrentProcess()`ë¡œ ì–»ìŒ)

ì´ ë³€ìˆ˜ë“¤ì„ í†µí•´ ì´ì „ ìƒíƒœë¥¼ ê¸°ì–µí•˜ê³ , í˜„ì¬ ìƒíƒœì™€ ë¹„êµí•´ CPU ì ìœ ìœ¨ì„ ê³„ì‚°í•œë‹¤.


#### ğŸ§­ ìƒì„±ì: ì´ˆê¸° ìƒíƒœ ê¸°ë¡

```cpp
PreciseCpuMonitor() {
    SYSTEM_INFO sysInfo;
    FILETIME ftime, fsys, fuser;
    
    GetSystemInfo(&sysInfo);
    numProcessors = sysInfo.dwNumberOfProcessors;
    
    GetSystemTimeAsFileTime(&ftime);
    memcpy(&lastCPU, &ftime, sizeof(FILETIME));
    
    self = GetCurrentProcess();
    GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
    memcpy(&lastSysCPU, &fsys, sizeof(FILETIME));
    memcpy(&lastUserCPU, &fuser, sizeof(FILETIME));
}
```

ì´ ìƒì„±ìëŠ” ë‹¤ìŒ ê³¼ì •ì„ ìˆ˜í–‰í•œë‹¤.

1. **CPU ê°œìˆ˜(numProcessors)**ë¥¼ ì–»ëŠ”ë‹¤.
2. **í˜„ì¬ ì‹œìŠ¤í…œ ì‹œê°„**(`GetSystemTimeAsFileTime`)ì„ ì €ì¥í•œë‹¤.
3. **í”„ë¡œì„¸ìŠ¤ì˜ CPU ì‹œê°„**(`GetProcessTimes`)ì„ ì½ì–´ì„œ ì €ì¥í•œë‹¤.

ì´ ì •ë³´ë¥¼ ê¸°ì¤€ì ìœ¼ë¡œ ë‘ê³ , ì´í›„ ì¸¡ì •ì—ì„œ ë³€í™”ëŸ‰ì„ ê³„ì‚°í•œë‹¤.


#### âš™ï¸ getCurrentCpuUsage() í•¨ìˆ˜

```cpp
double getCurrentCpuUsage() {
    FILETIME ftime, fsys, fuser;
    ULARGE_INTEGER now, sys, user;
    double percent;
    
    GetSystemTimeAsFileTime(&ftime);
    memcpy(&now, &ftime, sizeof(FILETIME));
    
    GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
    memcpy(&sys, &fsys, sizeof(FILETIME));
    memcpy(&user, &fuser, sizeof(FILETIME));
    
    percent = static_cast<double>(sys.QuadPart - lastSysCPU.QuadPart) +
             static_cast<double>(user.QuadPart - lastUserCPU.QuadPart);
    
    percent /= static_cast<double>(now.QuadPart - lastCPU.QuadPart);
    percent /= numProcessors;
    
    lastCPU = now;
    lastUserCPU = user;
    lastSysCPU = sys;
    
    return percent * 100.0;
}
```

ì´ í•¨ìˆ˜ëŠ” ì‹¤ì œ CPU ì‚¬ìš©ë¥ ì„ ê³„ì‚°í•œë‹¤.
í•µì‹¬ ë¡œì§ì€ **ì´ì „ ì¸¡ì •ê°’ê³¼ í˜„ì¬ ì¸¡ì •ê°’ì˜ ì°¨ì´(ì¦ê°€ë¶„)**ì„ ì´ìš©í•˜ëŠ” ê²ƒì´ë‹¤.

**ì‘ë™ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.**

1. í˜„ì¬ ì‹œìŠ¤í…œ ì‹œê°„(`now`)ê³¼ í”„ë¡œì„¸ìŠ¤ CPU ì‹œê°„(`sys`, `user`)ì„ ì½ëŠ”ë‹¤.
2. ì´ì „ ì¸¡ì •ê°’(`lastSysCPU`, `lastUserCPU`)ê³¼ì˜ ì°¨ì´ë¥¼ ê³„ì‚°í•œë‹¤.
3. ì‹œê°„ ì¦ê°€ë¶„ìœ¼ë¡œ ë‚˜ëˆ„ì–´ **ë¹„ìœ¨(percent)**ì„ êµ¬í•œë‹¤.
4. CPU ì½”ì–´ ìˆ˜ë¡œ ë‚˜ëˆ„ì–´ **í‰ê·  ì‚¬ìš©ë¥ **ì„ ê³„ì‚°í•œë‹¤.
5. ë§ˆì§€ë§‰ìœ¼ë¡œ í˜„ì¬ ê°’ì„ ì €ì¥í•˜ì—¬ ë‹¤ìŒ ê³„ì‚° ì‹œ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤.


#### ğŸ§® ASCII ë‹¤ì´ì–´ê·¸ë¨ (ì‹œê°„ íë¦„ ì˜ˆì‹œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ì¸¡ì • ì£¼ê¸° ë‚´ CPU ì‚¬ìš©ëŸ‰ ê³„ì‚°   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“ ì‹œê°„ íë¦„ â†“

   [t1 ì‹œì ]  â”€â”€â–¶ lastSysCPU = 1000
                    lastUserCPU = 2000
                    lastCPU = 4000

   [t2 ì‹œì ]  â”€â”€â–¶ sys = 1300
                    user = 2500
                    now = 4600

   CPU ì‚¬ìš©ë¥  = ( (1300-1000) + (2500-2000) ) / (4600-4000) = 0.8
   ì½”ì–´ê°€ 4ê°œë©´ 0.8 / 4 = 0.2 â†’ 20%
```

ì¦‰, ì¼ì • ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ì´ í•¨ìˆ˜ë¥¼ ë°˜ë³µ í˜¸ì¶œí•˜ë©´ CPU ì ìœ ìœ¨ ë³€í™”ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.


#### ğŸ§¾ printCpuInfo() í•¨ìˆ˜

```cpp
void printCpuInfo() {
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    
    std::cout << "\n=== CPU ì •ë³´ ===\n";
    std::cout << "í”„ë¡œì„¸ì„œ ìˆ˜: " << sysInfo.dwNumberOfProcessors << std::endl;
    std::cout << "í”„ë¡œì„¸ì„œ ì•„í‚¤í…ì²˜: ";
    
    switch (sysInfo.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_AMD64:
            std::cout << "x64 (AMD64)" << std::endl;
            break;
        case PROCESSOR_ARCHITECTURE_ARM:
            std::cout << "ARM" << std::endl;
            break;
        case PROCESSOR_ARCHITECTURE_ARM64:
            std::cout << "ARM64" << std::endl;
            break;
        case PROCESSOR_ARCHITECTURE_INTEL:
            std::cout << "x86 (Intel)" << std::endl;
            break;
        default:
            std::cout << "ì•Œ ìˆ˜ ì—†ìŒ" << std::endl;
            break;
    }
    
    std::cout << "í˜ì´ì§€ í¬ê¸°: " << sysInfo.dwPageSize << " bytes" << std::endl;
    std::cout << "===============\n\n";
}
```

ì´ í•¨ìˆ˜ëŠ” **CPUì˜ ê¸°ë³¸ í•˜ë“œì›¨ì–´ ì •ë³´ë¥¼ ì¶œë ¥**í•œë‹¤.

* CPU ê°œìˆ˜
* ì•„í‚¤í…ì²˜(x86, x64, ARM ë“±)
* í˜ì´ì§€ í¬ê¸° (ë©”ëª¨ë¦¬ ê´€ë¦¬ ë‹¨ìœ„ í¬ê¸°)

ì´ ì •ë³´ëŠ” CPU ì‚¬ìš©ë¥ ê³¼ í•¨ê»˜ ì‹œìŠ¤í…œ ì„±ëŠ¥ ë¶„ì„ ì‹œ ìœ ìš©í•˜ê²Œ ì‚¬ìš©ëœë‹¤.

  
#### ğŸ§© ë¨¸ë©”ì´ë“œ ë‹¤ì´ì–´ê·¸ë¨ (ì „ì²´ íë¦„ ìš”ì•½)

```mermaid
flowchart TD
A[ìƒì„±ì ì‹¤í–‰] --> B[CPU ê°œìˆ˜ ë° ì´ˆê¸°ê°’ ì €ì¥]
B --> C[getCurrentCpuUsage í˜¸ì¶œ]
C --> D[í˜„ì¬ CPU ì‹œê°„ ì¸¡ì •]
D --> E[ì´ì „ ì¸¡ì •ê°’ê³¼ ë¹„êµ]
E --> F[ë¹„ìœ¨ ê³„ì‚° í›„ ê²°ê³¼ ë°˜í™˜]
F --> G[ê°’ ê°±ì‹  í›„ ë‹¤ìŒ ì¸¡ì • ëŒ€ë¹„]
```


#### âœ… ì •ë¦¬

| êµ¬ë¶„         | ì„¤ëª…                                                            |
| ---------- | ------------------------------------------------------------- |
| **ëª©ì **     | í”„ë¡œì„¸ìŠ¤ì˜ CPU ì‚¬ìš©ë¥ ì„ ì •ë°€í•˜ê²Œ ì¸¡ì •                                        |
| **ì‚¬ìš© API** | `GetSystemTimeAsFileTime`, `GetProcessTimes`, `GetSystemInfo` |
| **í•µì‹¬ ë¡œì§**  | ì´ì „ ì¸¡ì •ê°’ê³¼ í˜„ì¬ ì¸¡ì •ê°’ì˜ ì°¨ì´ë¡œ CPU ì ìœ ìœ¨ ê³„ì‚°                                |
| **íŠ¹ì§•**     | ë©€í‹°ì½”ì–´ í™˜ê²½ì—ì„œë„ ì •í™•í•œ í‰ê·  ì‚¬ìš©ë¥  ê³„ì‚° ê°€ëŠ¥                                   |
| **í™œìš© ì˜ˆì‹œ**  | ì„œë²„ ëª¨ë‹ˆí„°ë§, ì„±ëŠ¥ ë¡œê¹…, ë¶€í•˜ í…ŒìŠ¤íŠ¸                                        |


ì´ `PreciseCpuMonitor` í´ë˜ìŠ¤ëŠ” ë‹¨ìˆœí•˜ì§€ë§Œ ë§¤ìš° ì •ë°€í•œ CPU ì¸¡ì • ë„êµ¬ë‹¤.
`std::this_thread::sleep_for`ë¡œ ì¼ì • ê°„ê²©ë§ˆë‹¤ `getCurrentCpuUsage()`ë¥¼ í˜¸ì¶œí•˜ë©´
ì‹œê°„ì— ë”°ë¼ CPU ì‚¬ìš©ë¥ ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•  ìˆ˜ ìˆë‹¤.

ì´ëŠ” ì‹œìŠ¤í…œ ìµœì í™”ë‚˜ ì„±ëŠ¥ ë¶„ì„ì„ ê³µë¶€í•˜ëŠ” í•™ìƒë“¤ì—ê²Œ **ìš´ì˜ì²´ì œì˜ CPU ìŠ¤ì¼€ì¤„ë§ ì›ë¦¬ë¥¼ ì´í•´**í•˜ëŠ” ë°ì—ë„ í° ë„ì›€ì´ ëœë‹¤.



### 7.3.2 ìƒì„¸í•œ ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§

```cpp
class DetailedMemoryMonitor {
public:
    struct MemoryInfo {
        SIZE_T workingSetSize;      // ì›Œí‚¹ì…‹ í¬ê¸°
        SIZE_T privateBytes;        // ì „ìš© ë©”ëª¨ë¦¬
        SIZE_T virtualSize;         // ê°€ìƒ ë©”ëª¨ë¦¬ í¬ê¸°
        SIZE_T peakWorkingSetSize;  // ìµœëŒ€ ì›Œí‚¹ì…‹ í¬ê¸°
        SIZE_T peakPagefileUsage;   // ìµœëŒ€ í˜ì´ì§€íŒŒì¼ ì‚¬ìš©ëŸ‰
        
        // ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ì •ë³´
        DWORDLONG totalPhysicalMemory;
        DWORDLONG availablePhysicalMemory;
        DWORDLONG totalPageFile;
        DWORDLONG availablePageFile;
        DWORDLONG totalVirtual;
        DWORDLONG availableVirtual;
    };
    
    static MemoryInfo getCurrentMemoryInfo() {
        MemoryInfo info = {};
        
        // í”„ë¡œì„¸ìŠ¤ë³„ ë©”ëª¨ë¦¬ ì •ë³´
        PROCESS_MEMORY_COUNTERS_EX pmc;
        if (GetProcessMemoryInfo(GetCurrentProcess(), 
                               reinterpret_cast<PROCESS_MEMORY_COUNTERS*>(&pmc), 
                               sizeof(pmc))) {
            info.workingSetSize = pmc.WorkingSetSize;
            info.privateBytes = pmc.PrivateUsage;
            info.virtualSize = pmc.PagefileUsage;
            info.peakWorkingSetSize = pmc.PeakWorkingSetSize;
            info.peakPagefileUsage = pmc.PeakPagefileUsage;
        }
        
        // ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ì •ë³´
        MEMORYSTATUSEX memStatus;
        memStatus.dwLength = sizeof(memStatus);
        if (GlobalMemoryStatusEx(&memStatus)) {
            info.totalPhysicalMemory = memStatus.ullTotalPhys;
            info.availablePhysicalMemory = memStatus.ullAvailPhys;
            info.totalPageFile = memStatus.ullTotalPageFile;
            info.availablePageFile = memStatus.ullAvailPageFile;
            info.totalVirtual = memStatus.ullTotalVirtual;
            info.availableVirtual = memStatus.ullAvailVirtual;
        }
        
        return info;
    }
    
    static void printMemoryInfo(const MemoryInfo& info) {
        std::cout << "\n=== ë©”ëª¨ë¦¬ ì‚¬ìš© í˜„í™© ===\n";
        
        // í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ ì •ë³´
        std::cout << "[í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬]\n";
        std::cout << "ì›Œí‚¹ì…‹: " << formatBytes(info.workingSetSize) 
                 << " (ìµœëŒ€: " << formatBytes(info.peakWorkingSetSize) << ")\n";
        std::cout << "ì „ìš© ë©”ëª¨ë¦¬: " << formatBytes(info.privateBytes) << "\n";
        std::cout << "ê°€ìƒ ë©”ëª¨ë¦¬: " << formatBytes(info.virtualSize) 
                 << " (ìµœëŒ€: " << formatBytes(info.peakPagefileUsage) << ")\n\n";
        
        // ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ ì •ë³´
        std::cout << "[ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬]\n";
        std::cout << "ë¬¼ë¦¬ ë©”ëª¨ë¦¬: " << formatBytes(info.availablePhysicalMemory) 
                 << " / " << formatBytes(info.totalPhysicalMemory)
                 << " (" << getUsagePercentage(info.availablePhysicalMemory, 
                                             info.totalPhysicalMemory) << "% ì‚¬ìš© ê°€ëŠ¥)\n";
        
        std::cout << "í˜ì´ì§€ íŒŒì¼: " << formatBytes(info.availablePageFile) 
                 << " / " << formatBytes(info.totalPageFile)
                 << " (" << getUsagePercentage(info.availablePageFile, 
                                             info.totalPageFile) << "% ì‚¬ìš© ê°€ëŠ¥)\n";
        
        std::cout << "ê°€ìƒ ë©”ëª¨ë¦¬: " << formatBytes(info.availableVirtual) 
                 << " / " << formatBytes(info.totalVirtual)
                 << " (" << getUsagePercentage(info.availableVirtual, 
                                             info.totalVirtual) << "% ì‚¬ìš© ê°€ëŠ¥)\n";
        std::cout << "========================\n\n";
    }
    
    // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€
    static void detectMemoryLeaks() {
        static MemoryInfo initialInfo = getCurrentMemoryInfo();
        MemoryInfo currentInfo = getCurrentMemoryInfo();
        
        SIZE_T workingSetGrowth = currentInfo.workingSetSize - initialInfo.workingSetSize;
        SIZE_T privateGrowth = currentInfo.privateBytes - initialInfo.privateBytes;
        
        std::cout << "\n=== ë©”ëª¨ë¦¬ ì¦ê°€ëŸ‰ ë¶„ì„ ===\n";
        std::cout << "ì›Œí‚¹ì…‹ ì¦ê°€: " << formatBytes(workingSetGrowth) << "\n";
        std::cout << "ì „ìš© ë©”ëª¨ë¦¬ ì¦ê°€: " << formatBytes(privateGrowth) << "\n";
        
        // ê²½ê³  ì„ê³„ê°’ (100MB)
        const SIZE_T WARNING_THRESHOLD = 100 * 1024 * 1024;
        
        if (workingSetGrowth > WARNING_THRESHOLD) {
            std::cout << "âš ï¸  ì›Œí‚¹ì…‹ì´ í¬ê²Œ ì¦ê°€í–ˆìŠµë‹ˆë‹¤! ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ í™•ì¸í•˜ì„¸ìš”.\n";
        }
        
        if (privateGrowth > WARNING_THRESHOLD) {
            std::cout << "âš ï¸  ì „ìš© ë©”ëª¨ë¦¬ê°€ í¬ê²Œ ì¦ê°€í–ˆìŠµë‹ˆë‹¤! ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ í™•ì¸í•˜ì„¸ìš”.\n";
        }
        
        std::cout << "========================\n\n";
    }
    
private:
    static std::string formatBytes(SIZE_T bytes) {
        const char* units[] = {"B", "KB", "MB", "GB", "TB"};
        int unit = 0;
        double size = static_cast<double>(bytes);
        
        while (size >= 1024.0 && unit < 4) {
            size /= 1024.0;
            unit++;
        }
        
        char buffer[64];
        snprintf(buffer, sizeof(buffer), "%.2f %s", size, units[unit]);
        return std::string(buffer);
    }
    
    static double getUsagePercentage(DWORDLONG available, DWORDLONG total) {
        if (total == 0) return 0.0;
        return (1.0 - static_cast<double>(available) / static_cast<double>(total)) * 100.0;
    }
};
```
  
ì´ë²ˆì—ëŠ” **í”„ë¡œì„¸ìŠ¤ì™€ ì‹œìŠ¤í…œ ì „ì²´ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ìƒì„¸í•˜ê²Œ ì¸¡ì •í•˜ê³  ì¶œë ¥í•˜ëŠ” í´ë˜ìŠ¤**ë¥¼ ì‚´í´ë³¸ë‹¤.
ì´ í´ë˜ìŠ¤ëŠ” ë‹¨ìˆœíˆ â€œì–¼ë§ˆë‚˜ ë©”ëª¨ë¦¬ë¥¼ ì“°ê³  ìˆë‚˜â€ë¥¼ ë³´ì—¬ì£¼ëŠ” ìˆ˜ì¤€ì„ ë„˜ì–´,
**ì›Œí‚¹ì…‹(Working Set)**, **ì „ìš© ë©”ëª¨ë¦¬(Private Bytes)**, **ê°€ìƒ ë©”ëª¨ë¦¬(Virtual Memory)** ë“±
ì„¸ë¶€ì ì¸ ë©”ëª¨ë¦¬ ì§€í‘œë¥¼ í•¨ê»˜ ì œê³µí•˜ì—¬ **ì„±ëŠ¥ ë¶„ì„ê³¼ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€**ì— í™œìš©í•  ìˆ˜ ìˆë‹¤.

ì´ ì½”ë“œëŠ” íŠ¹íˆ **ê²Œì„ ì„œë²„, ë Œë”ë§ ì—”ì§„, ë°ì´í„°ë² ì´ìŠ¤ ì„œë²„** ë“±ê³¼ ê°™ì´
í”„ë¡œì„¸ìŠ¤ê°€ ì¥ì‹œê°„ ì‹¤í–‰ë˜ëŠ” í”„ë¡œê·¸ë¨ì—ì„œ **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜(memory leak)**ë¥¼ íƒì§€í•  ë•Œ ìœ ìš©í•˜ë‹¤.


#### ğŸ§© í´ë˜ìŠ¤ ì „ì²´ êµ¬ì¡° ê°œìš”

```cpp
class DetailedMemoryMonitor {
public:
    struct MemoryInfo { ... };
    static MemoryInfo getCurrentMemoryInfo();
    static void printMemoryInfo(const MemoryInfo& info);
    static void detectMemoryLeaks();

private:
    static std::string formatBytes(SIZE_T bytes);
    static double getUsagePercentage(DWORDLONG available, DWORDLONG total);
};
```

ì´ í´ë˜ìŠ¤ëŠ” **ì •ì  ë©”ì„œë“œ(static function)** ì¤‘ì‹¬ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤.
ì¦‰, ê°ì²´ë¥¼ ë§Œë“¤ì§€ ì•Šì•„ë„ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

ì˜ˆì‹œ:

```cpp
auto info = DetailedMemoryMonitor::getCurrentMemoryInfo();
DetailedMemoryMonitor::printMemoryInfo(info);
```

#### ğŸ§± MemoryInfo êµ¬ì¡°ì²´

```cpp
struct MemoryInfo {
    SIZE_T workingSetSize;      // ì›Œí‚¹ì…‹ í¬ê¸°
    SIZE_T privateBytes;        // ì „ìš© ë©”ëª¨ë¦¬
    SIZE_T virtualSize;         // ê°€ìƒ ë©”ëª¨ë¦¬ í¬ê¸°
    SIZE_T peakWorkingSetSize;  // ìµœëŒ€ ì›Œí‚¹ì…‹ í¬ê¸°
    SIZE_T peakPagefileUsage;   // ìµœëŒ€ í˜ì´ì§€íŒŒì¼ ì‚¬ìš©ëŸ‰
    
    // ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ì •ë³´
    DWORDLONG totalPhysicalMemory;
    DWORDLONG availablePhysicalMemory;
    DWORDLONG totalPageFile;
    DWORDLONG availablePageFile;
    DWORDLONG totalVirtual;
    DWORDLONG availableVirtual;
};
```

`MemoryInfo` êµ¬ì¡°ì²´ëŠ” **ë‘ ê°€ì§€ ë²”ì£¼ì˜ ë©”ëª¨ë¦¬ ì •ë³´**ë¥¼ í•¨ê»˜ ë‹´ëŠ”ë‹¤.

| êµ¬ë¶„              | ì„¤ëª…                            |
| --------------- | ----------------------------- |
| **í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ ì •ë³´** | í˜„ì¬ í”„ë¡œê·¸ë¨(í”„ë¡œì„¸ìŠ¤)ì´ ì‹¤ì œë¡œ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬   |
| **ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ ì •ë³´**  | ì»´í“¨í„° ì „ì²´ì˜ ë¬¼ë¦¬ì  ë©”ëª¨ë¦¬, ê°€ìƒ ë©”ëª¨ë¦¬ ì‚¬ìš© í˜„í™© |


#### ğŸ§® getCurrentMemoryInfo() í•¨ìˆ˜
ì´ í•¨ìˆ˜ëŠ” **í˜„ì¬ ì‹œì ì˜ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ ì¸¡ì •**í•œë‹¤.

```cpp
static MemoryInfo getCurrentMemoryInfo() {
    MemoryInfo info = {};
    
    PROCESS_MEMORY_COUNTERS_EX pmc;
    if (GetProcessMemoryInfo(GetCurrentProcess(), 
                           reinterpret_cast<PROCESS_MEMORY_COUNTERS*>(&pmc), 
                           sizeof(pmc))) {
        info.workingSetSize = pmc.WorkingSetSize;
        info.privateBytes = pmc.PrivateUsage;
        info.virtualSize = pmc.PagefileUsage;
        info.peakWorkingSetSize = pmc.PeakWorkingSetSize;
        info.peakPagefileUsage = pmc.PeakPagefileUsage;
    }
```

ì—¬ê¸°ì„œ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ëŠ” Windows APIì˜ `GetProcessMemoryInfo()`ì´ë‹¤.
ì´ í•¨ìˆ˜ëŠ” í˜„ì¬ í”„ë¡œì„¸ìŠ¤ê°€ ì‚¬ìš© ì¤‘ì¸ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ ìƒì„¸íˆ ì•Œë ¤ì¤€ë‹¤.

| í•­ëª©                      | ì„¤ëª…                            |
| ----------------------- | ----------------------------- |
| **Working Set**         | ì‹¤ì œ ë¬¼ë¦¬ RAMì— ì˜¬ë¼ì™€ ìˆëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ì–‘ |
| **Private Bytes**       | ì´ í”„ë¡œì„¸ìŠ¤ë§Œ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ ì–‘ (ê³µìœ  ë¶ˆê°€ ì˜ì—­) |
| **Virtual Size**        | í”„ë¡œì„¸ìŠ¤ê°€ ì˜ˆì•½í•œ ê°€ìƒ ì£¼ì†Œ ê³µê°„ í¬ê¸°         |
| **Peak Working Set**    | ì‹¤í–‰ ì¤‘ ê°€ì¥ ë§ì´ ì‚¬ìš©í–ˆë˜ RAM ì–‘         |
| **Peak Pagefile Usage** | ê°€ì¥ ë§ì´ ì‚¬ìš©ëœ ìŠ¤ì™‘(ê°€ìƒ) ë©”ëª¨ë¦¬ ì–‘        |

ì´í›„ ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ ì¡°íšŒí•œë‹¤.

```cpp
MEMORYSTATUSEX memStatus;
memStatus.dwLength = sizeof(memStatus);
if (GlobalMemoryStatusEx(&memStatus)) {
    info.totalPhysicalMemory = memStatus.ullTotalPhys;
    info.availablePhysicalMemory = memStatus.ullAvailPhys;
    info.totalPageFile = memStatus.ullTotalPageFile;
    info.availablePageFile = memStatus.ullAvailPageFile;
    info.totalVirtual = memStatus.ullTotalVirtual;
    info.availableVirtual = memStatus.ullAvailVirtual;
}
```

ì´ë•Œ ì‚¬ìš©í•˜ëŠ” `GlobalMemoryStatusEx()`ëŠ” ì‹œìŠ¤í…œ ì „ì²´ì˜ ë©”ëª¨ë¦¬ ìš©ëŸ‰ê³¼ ì‚¬ìš©ë¥ ì„ ì•Œë ¤ì£¼ëŠ” í•¨ìˆ˜ì´ë‹¤.

#### ğŸ“Š printMemoryInfo() í•¨ìˆ˜
ì´ í•¨ìˆ˜ëŠ” `MemoryInfo` ë°ì´í„°ë¥¼ ë³´ê¸° ì¢‹ê²Œ ì¶œë ¥í•œë‹¤.

```cpp
static void printMemoryInfo(const MemoryInfo& info) {
    std::cout << "\n=== ë©”ëª¨ë¦¬ ì‚¬ìš© í˜„í™© ===\n";
    
    // í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬
    std::cout << "[í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬]\n";
    std::cout << "ì›Œí‚¹ì…‹: " << formatBytes(info.workingSetSize) 
             << " (ìµœëŒ€: " << formatBytes(info.peakWorkingSetSize) << ")\n";
```

ì¶œë ¥ ì˜ˆì‹œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```
=== ë©”ëª¨ë¦¬ ì‚¬ìš© í˜„í™© ===
[í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬]
ì›Œí‚¹ì…‹: 120.45 MB (ìµœëŒ€: 200.00 MB)
ì „ìš© ë©”ëª¨ë¦¬: 80.12 MB
ê°€ìƒ ë©”ëª¨ë¦¬: 350.67 MB (ìµœëŒ€: 400.00 MB)

[ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬]
ë¬¼ë¦¬ ë©”ëª¨ë¦¬: 8.12 GB / 16.00 GB (49% ì‚¬ìš© ê°€ëŠ¥)
í˜ì´ì§€ íŒŒì¼: 13.50 GB / 20.00 GB (32% ì‚¬ìš© ê°€ëŠ¥)
ê°€ìƒ ë©”ëª¨ë¦¬: 1.50 TB / 2.00 TB (25% ì‚¬ìš© ê°€ëŠ¥)
========================
```

ASCII ê·¸ë¦¼ìœ¼ë¡œ ë‚˜íƒ€ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       DetailedMemoryMonitor â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬]             â”‚
â”‚   ì›Œí‚¹ì…‹ / ì „ìš© / ê°€ìƒ ë©”ëª¨ë¦¬  â”‚
â”‚                             â”‚
â”‚ [ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬]               â”‚
â”‚   ë¬¼ë¦¬ / í˜ì´ì§€ / ê°€ìƒ ë©”ëª¨ë¦¬  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ§© detectMemoryLeaks() í•¨ìˆ˜
ì´ í•¨ìˆ˜ëŠ” **í”„ë¡œì„¸ìŠ¤ì˜ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜(memory leak)**ë¥¼ ê°ì§€í•œë‹¤.

```cpp
static void detectMemoryLeaks() {
    static MemoryInfo initialInfo = getCurrentMemoryInfo();
    MemoryInfo currentInfo = getCurrentMemoryInfo();
    
    SIZE_T workingSetGrowth = currentInfo.workingSetSize - initialInfo.workingSetSize;
    SIZE_T privateGrowth = currentInfo.privateBytes - initialInfo.privateBytes;
```

ì‘ë™ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

1. **í”„ë¡œê·¸ë¨ ì‹œì‘ ì‹œì ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰(initialInfo)**ì„ ì €ì¥í•œë‹¤.
2. **í˜„ì¬ ì‹œì ì˜ ë©”ëª¨ë¦¬(currentInfo)**ì„ ì¸¡ì •í•œë‹¤.
3. ë‘ ê°’ì˜ ì°¨ì´ë¥¼ ë¹„êµí•˜ì—¬ ì¦ê°€ëŸ‰ì„ ê³„ì‚°í•œë‹¤.

```cpp
if (workingSetGrowth > 100MB) ê²½ê³  ì¶œë ¥
if (privateGrowth > 100MB) ê²½ê³  ì¶œë ¥
```

ì¦‰, ì¼ì • ê¸°ê°„ ë™ì•ˆ ë©”ëª¨ë¦¬ê°€ 100MB ì´ìƒ ì¦ê°€í•˜ë©´ â€œëˆ„ìˆ˜ ì˜ì‹¬â€ ê²½ê³ ë¥¼ ë„ìš´ë‹¤.

#### ğŸ§® formatBytes() í•¨ìˆ˜

```cpp
static std::string formatBytes(SIZE_T bytes) {
    const char* units[] = {"B", "KB", "MB", "GB", "TB"};
    int unit = 0;
    double size = static_cast<double>(bytes);
    
    while (size >= 1024.0 && unit < 4) {
        size /= 1024.0;
        unit++;
    }
    
    char buffer[64];
    snprintf(buffer, sizeof(buffer), "%.2f %s", size, units[unit]);
    return std::string(buffer);
}
```

ì´ í•¨ìˆ˜ëŠ” ë°”ì´íŠ¸ ë‹¨ìœ„ë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•ì‹(ì˜ˆ: MB, GB)ìœ¼ë¡œ ë³€í™˜í•œë‹¤.

#### ğŸ§© getUsagePercentage() í•¨ìˆ˜

```cpp
static double getUsagePercentage(DWORDLONG available, DWORDLONG total) {
    if (total == 0) return 0.0;
    return (1.0 - static_cast<double>(available) / static_cast<double>(total)) * 100.0;
}
```

ì´ í•¨ìˆ˜ëŠ” ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ ë¹„ìœ¨ì„ ê³„ì‚°í•˜ì—¬ â€œì‚¬ìš© ì¤‘ ë¹„ìœ¨(%)â€ë¡œ í‘œì‹œí•œë‹¤.

#### ğŸ§  ë¨¸ë©”ì´ë“œ ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ ë³´ëŠ” íë¦„

```mermaid
flowchart TD
A[í”„ë¡œê·¸ë¨ ì‹¤í–‰] --> B[ì´ˆê¸° ë©”ëª¨ë¦¬ ì¸¡ì • (initialInfo ì €ì¥)]
B --> C[í˜„ì¬ ë©”ëª¨ë¦¬ ì¸¡ì • (getCurrentMemoryInfo)]
C --> D[ì¦ê°€ëŸ‰ ê³„ì‚°]
D --> E{ì¦ê°€ëŸ‰ > 100MB?}
E -- ì˜ˆ --> F[ê²½ê³ : ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì˜ì‹¬]
E -- ì•„ë‹ˆì˜¤ --> G[ì •ìƒ ìƒíƒœ ìœ ì§€]
```

#### âœ… ì •ë¦¬

| êµ¬ë¶„         | ì„¤ëª…                                                          |
| ---------- | ----------------------------------------------------------- |
| **ëª©ì **     | í”„ë¡œì„¸ìŠ¤ ë° ì‹œìŠ¤í…œ ì „ì²´ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì‹¤ì‹œê°„ ë¶„ì„                               |
| **í•µì‹¬ ê¸°ëŠ¥**  | ë©”ëª¨ë¦¬ ì‚¬ìš© í˜„í™© ì¶œë ¥, ì¦ê°€ëŸ‰ ë¶„ì„, ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€                             |
| **ì‚¬ìš© API** | `GetProcessMemoryInfo`, `GlobalMemoryStatusEx`              |
| **ì¶œë ¥ ì •ë³´**  | Working Set, Private Bytes, Virtual Memory, System Memory ë“± |
| **ì¶”ê°€ ê¸°ëŠ¥**  | 100MB ì´ìƒ ì¦ê°€ ì‹œ ìë™ ê²½ê³  ë©”ì‹œì§€ ì¶œë ¥                                  |
  

ì´ `DetailedMemoryMonitor` í´ë˜ìŠ¤ëŠ” **ìš´ì˜ì²´ì œ ìˆ˜ì¤€ì˜ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ í”„ë¡œê·¸ë˜ë°ì ìœ¼ë¡œ ì¸¡ì •í•  ìˆ˜ ìˆëŠ” ë„êµ¬**ë‹¤.
í•™ìƒë“¤ì´ ì´ ì½”ë“œë¥¼ í†µí•´ ë°°ìš°ê²Œ ë˜ëŠ” í•µì‹¬ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

* í”„ë¡œê·¸ë¨ì˜ **ì‹¤ì œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì •í™•íˆ ì¸¡ì •í•˜ëŠ” ë°©ë²•**
* **ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ì™€ í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ì˜ ì°¨ì´ì ** ì´í•´
* **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€ ë¡œì§**ì˜ ê¸°ë³¸ ê°œë…

ì´ëŸ¬í•œ ëª¨ë‹ˆí„°ë§ ì½”ë“œëŠ” ë‹¨ìˆœí•œ ë””ë²„ê¹… ë„êµ¬ë¥¼ ë„˜ì–´ì„œ,
ì„±ëŠ¥ ìµœì í™”ì™€ ì•ˆì •ì ì¸ ì„œë²„ ìš´ì˜ì„ ìœ„í•œ **í•„ìˆ˜ ê¸°ìˆ ì  ê¸°ë°˜**ì´ ëœë‹¤.



### 7.3.3 ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

```cpp
class PerformanceDashboard {
private:
    PreciseCpuMonitor cpuMonitor;
    GameServerPerformanceCounter gameCounter;
    bool running = false;
    std::thread monitorThread;
    
public:
    void start() {
        running = true;
        monitorThread = std::thread(&PerformanceDashboard::monitorLoop, this);
    }
    
    void stop() {
        running = false;
        if (monitorThread.joinable()) {
            monitorThread.join();
        }
    }
    
    GameServerPerformanceCounter& getGameCounter() {
        return gameCounter;
    }
    
private:
    void monitorLoop() {
        const auto UPDATE_INTERVAL = std::chrono::seconds(5);
        auto lastUpdate = std::chrono::steady_clock::now();
        
        cpuMonitor.printCpuInfo();
        
        while (running) {
            auto now = std::chrono::steady_clock::now();
            if (now - lastUpdate >= UPDATE_INTERVAL) {
                clearScreen();
                printDashboard();
                lastUpdate = now;
            }
            
            gameCounter.updatePerSecondStats();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }
    
    void clearScreen() {
        // Windowsì—ì„œ ì½˜ì†” í™”ë©´ ì§€ìš°ê¸°
        COORD coordScreen = {0, 0};
        DWORD cCharsWritten;
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
        
        GetConsoleScreenBufferInfo(hConsole, &csbi);
        DWORD dwConSize = csbi.dwSize.X * csbi.dwSize.Y;
        
        FillConsoleOutputCharacter(hConsole, TEXT(' '), dwConSize, 
                                 coordScreen, &cCharsWritten);
        GetConsoleScreenBufferInfo(hConsole, &csbi);
        FillConsoleOutputAttribute(hConsole, csbi.wAttributes, dwConSize, 
                                 coordScreen, &cCharsWritten);
        SetConsoleCursorPosition(hConsole, coordScreen);
    }
    
    void printDashboard() {
        auto currentTime = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(currentTime);
        
        std::cout << "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
        std::cout << "â”‚              ê²Œì„ ì„œë²„ ì„±ëŠ¥ ëŒ€ì‹œë³´ë“œ                â”‚\n";
        std::cout << "â”‚  ì—…ë°ì´íŠ¸ ì‹œê°„: " << std::ctime(&time_t);
        std::cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
        
        // CPU ì‚¬ìš©ë¥ 
        double cpuUsage = cpuMonitor.getCurrentCpuUsage();
        std::cout << "CPU ì‚¬ìš©ë¥ : " << std::fixed << std::setprecision(1) 
                 << cpuUsage << "% ";
        printProgressBar(cpuUsage, 100.0);
        std::cout << "\n\n";
        
        // ë©”ëª¨ë¦¬ ì •ë³´
        auto memInfo = DetailedMemoryMonitor::getCurrentMemoryInfo();
        double memUsagePercent = DetailedMemoryMonitor::getUsagePercentage(
            memInfo.availablePhysicalMemory, memInfo.totalPhysicalMemory);
        
        std::cout << "ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : " << std::fixed << std::setprecision(1) 
                 << memUsagePercent << "% ";
        printProgressBar(memUsagePercent, 100.0);
        std::cout << "\n";
        
        std::cout << "í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬: " 
                 << DetailedMemoryMonitor::formatBytes(memInfo.workingSetSize) << "\n\n";
        
        // ê²Œì„ ì„œë²„ í†µê³„
        auto gameStats = gameCounter.getPerformanceData();
        std::cout << "â”Œâ”€ ê²Œì„ ì„œë²„ í†µê³„ â”€â”\n";
        std::cout << "â”‚ í™œì„± ì—°ê²°: " << std::setw(6) << gameStats.activeConnections << " â”‚\n";
        std::cout << "â”‚ ë©”ì‹œì§€/ì´ˆ: " << std::setw(6) << gameStats.messagesPerSecond << " â”‚\n";
        std::cout << "â”‚ ë°”ì´íŠ¸/ì´ˆ: " << std::setw(6) << gameStats.bytesPerSecond << " â”‚\n";
        std::cout << "â”‚ ì´ ì—ëŸ¬ìˆ˜: " << std::setw(6) << gameStats.totalErrors << " â”‚\n";
        std::cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
        
        // ì„±ëŠ¥ ê²½ê³ 
        printPerformanceWarnings(cpuUsage, memUsagePercent, gameStats);
    }
    
    void printProgressBar(double current, double max, int width = 30) {
        double percentage = (current / max) * 100.0;
        int filledWidth = static_cast<int>((current / max) * width);
        
        std::cout << "[";
        for (int i = 0; i < width; ++i) {
            if (i < filledWidth) {
                std::cout << "â–ˆ";
            } else {
                std::cout << "â–‘";
            }
        }
        std::cout << "]";
    }
    
    void printPerformanceWarnings(double cpuUsage, double memUsage, 
                                const GameServerPerformanceCounter::PerformanceData& gameStats) {
        std::vector<std::string> warnings;
        
        if (cpuUsage > 80.0) {
            warnings.push_back("âš ï¸  CPU ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤ (" + 
                             std::to_string(static_cast<int>(cpuUsage)) + "%)");
        }
        
        if (memUsage > 85.0) {
            warnings.push_back("âš ï¸  ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë†’ìŠµë‹ˆë‹¤ (" + 
                             std::to_string(static_cast<int>(memUsage)) + "%)");
        }
        
        if (gameStats.messagesPerSecond > 10000) {
            warnings.push_back("ğŸ“ˆ ë†’ì€ ë©”ì‹œì§€ ì²˜ë¦¬ëŸ‰ ê°ì§€ë¨ (" + 
                             std::to_string(gameStats.messagesPerSecond) + "/ì´ˆ)");
        }
        
        if (gameStats.totalErrors > 100) {
            warnings.push_back("âŒ ì—ëŸ¬ ë°œìƒëŸ‰ì´ ë§ìŠµë‹ˆë‹¤ (" + 
                             std::to_string(gameStats.totalErrors) + "ê°œ)");
        }
        
        if (!warnings.empty()) {
            std::cout << "â”Œâ”€ ê²½ê³  ì‚¬í•­ â”€â”\n";
            for (const auto& warning : warnings) {
                std::cout << "â”‚ " << warning << "\n";
            }
            std::cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
        }
    }
};
```
  
</br>    


## 7.4 ETW (Event Tracing for Windows) ê¸°ì´ˆ

### 7.4.1 ETW ê°œë…ê³¼ êµ¬ì¡°

```
ETW ì•„í‚¤í…ì²˜:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Provider  â”‚â”€â”€â”€â–¶â”‚   Session   â”‚â”€â”€â–¶â”‚  Consumer   â”‚
â”‚ (ì´ë²¤íŠ¸ ìƒì„±)â”‚     â”‚ (ì´ë²¤íŠ¸ ìˆ˜ì§‘) â”‚    â”‚ (ì´ë²¤íŠ¸ ë¶„ì„)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                   â”‚                   â”‚
       â–¼                   â–¼                   â–¼
  ê²Œì„ ì„œë²„ ì½”ë“œ      Windows ì»¤ë„       ë¶„ì„ ë„êµ¬
```

ETWëŠ” Windowsì—ì„œ ì œê³µí•˜ëŠ” ê³ ì„±ëŠ¥ ì´ë²¤íŠ¸ ì¶”ì  ì‹œìŠ¤í…œìœ¼ë¡œ, ìµœì†Œí•œì˜ ì˜¤ë²„í—¤ë“œë¡œ ìƒì„¸í•œ ì„±ëŠ¥ ë°ì´í„°ë¥¼ ìˆ˜ì§‘í•  ìˆ˜ ìˆë‹¤.

### 7.4.2 ETW Provider êµ¬í˜„

```cpp
#include <Windows.h>
#include <evntprov.h>
#include <iostream>
#include <string>

#pragma comment(lib, "Advapi32.lib")

// ì»¤ìŠ¤í…€ ETW Provider GUID (ìƒˆë¡œ ìƒì„±í•´ì•¼ í•¨)
// PowerShellì—ì„œ [System.Guid]::NewGuid() ë¡œ ìƒì„± ê°€ëŠ¥
DEFINE_GUID(GameServerProviderGuid, 
    0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0);

class ETWProvider {
private:
    REGHANDLE registrationHandle = 0;
    bool initialized = false;
    
public:
    ETWProvider() {
        ULONG result = EventRegister(&GameServerProviderGuid, nullptr, nullptr, 
                                   &registrationHandle);
        
        if (result == ERROR_SUCCESS) {
            initialized = true;
            std::cout << "ETW Provider ë“±ë¡ ì„±ê³µ\n";
        } else {
            std::cout << "ETW Provider ë“±ë¡ ì‹¤íŒ¨: " << result << "\n";
        }
    }
    
    ~ETWProvider() {
        if (initialized) {
            EventUnregister(registrationHandle);
        }
    }
    
    // ê°„ë‹¨í•œ ì´ë²¤íŠ¸ ê¸°ë¡
    void logEvent(UCHAR level, const std::string& message) {
        if (!initialized) return;
        
        EVENT_DESCRIPTOR eventDesc;
        EventDescCreate(&eventDesc, 1, 0, 0, level, 0, 0, 0);
        
        EVENT_DATA_DESCRIPTOR dataDesc;
        EventDataDescCreate(&dataDesc, message.c_str(), 
                          static_cast<ULONG>(message.length() + 1));
        
        EventWrite(registrationHandle, &eventDesc, 1, &dataDesc);
    }
    
    // ê²Œì„ ì„œë²„ íŠ¹í™” ì´ë²¤íŠ¸ë“¤
    void logPlayerConnect(int playerId, const std::string& playerName) {
        if (!initialized) return;
        
        EVENT_DESCRIPTOR eventDesc;
        EventDescCreate(&eventDesc, 100, 0, 0, TRACE_LEVEL_INFORMATION, 1, 0, 0);
        
        EVENT_DATA_DESCRIPTOR dataDescs[2];
        EventDataDescCreate(&dataDescs[0], &playerId, sizeof(playerId));
        EventDataDescCreate(&dataDescs[1], playerName.c_str(), 
                          static_cast<ULONG>(playerName.length() + 1));
        
        EventWrite(registrationHandle, &eventDesc, 2, dataDescs);
        
        std::cout << "ETW: í”Œë ˆì´ì–´ ì—°ê²° - ID: " << playerId 
                 << ", ì´ë¦„: " << playerName << "\n";
    }
    
    void logMessageProcessed(int messageType, DWORD processingTime) {
        if (!initialized) return;
        
        EVENT_DESCRIPTOR eventDesc;
        EventDescCreate(&eventDesc, 101, 0, 0, TRACE_LEVEL_VERBOSE, 2, 0, 0);
        
        EVENT_DATA_DESCRIPTOR dataDescs[2];
        EventDataDescCreate(&dataDescs[0], &messageType, sizeof(messageType));
        EventDataDescCreate(&dataDescs[1], &processingTime, sizeof(processingTime));
        
        EventWrite(registrationHandle, &eventDesc, 2, dataDescs);
    }
    
    void logError(const std::string& errorMessage, DWORD errorCode) {
        if (!initialized) return;
        
        EVENT_DESCRIPTOR eventDesc;
        EventDescCreate(&eventDesc, 102, 0, 0, TRACE_LEVEL_ERROR, 3, 0, 0);
        
        EVENT_DATA_DESCRIPTOR dataDescs[2];
        EventDataDescCreate(&dataDescs[0], errorMessage.c_str(), 
                          static_cast<ULONG>(errorMessage.length() + 1));
        EventDataDescCreate(&dataDescs[1], &errorCode, sizeof(errorCode));
        
        EventWrite(registrationHandle, &eventDesc, 2, dataDescs);
        
        std::cout << "ETW: ì—ëŸ¬ - " << errorMessage 
                 << " (ì½”ë“œ: " << errorCode << ")\n";
    }
    
    // ì„±ëŠ¥ ì¸¡ì • ë„ìš°ë¯¸ í´ë˜ìŠ¤
    class PerformanceTracker {
    private:
        ETWProvider& provider;
        int operationType;
        LARGE_INTEGER startTime;
        
    public:
        PerformanceTracker(ETWProvider& p, int type) 
            : provider(p), operationType(type) {
            QueryPerformanceCounter(&startTime);
        }
        
        ~PerformanceTracker() {
            LARGE_INTEGER endTime, frequency;
            QueryPerformanceCounter(&endTime);
            QueryPerformanceFrequency(&frequency);
            
            DWORD elapsed = static_cast<DWORD>(
                ((endTime.QuadPart - startTime.QuadPart) * 1000) / frequency.QuadPart
            );
            
            provider.logMessageProcessed(operationType, elapsed);
        }
    };
    
    PerformanceTracker trackPerformance(int operationType) {
        return PerformanceTracker(*this, operationType);
    }
};
```
     
ì´ ì½”ë“œëŠ” **Windows ETW(Event Tracing for Windows)**ë¥¼ í™œìš©í•´ ê²Œì„ ì„œë²„ì—ì„œ ë°œìƒí•˜ëŠ” ì£¼ìš” ì´ë²¤íŠ¸(ì˜ˆ: í”Œë ˆì´ì–´ ì—°ê²°, ë©”ì‹œì§€ ì²˜ë¦¬, ì˜¤ë¥˜ ë°œìƒ ë“±)ë¥¼ **íš¨ìœ¨ì ìœ¼ë¡œ ê¸°ë¡í•˜ê³  ì¶”ì **í•˜ê¸° ìœ„í•œ ì˜ˆì œì´ë‹¤.
ETWëŠ” ìœˆë„ìš°ì—ì„œ ì œê³µí•˜ëŠ” ê³ ì„±ëŠ¥ ì´ë²¤íŠ¸ ë¡œê¹… ì‹œìŠ¤í…œìœ¼ë¡œ, ë””ë²„ê¹…ì´ë‚˜ ì„±ëŠ¥ ë¶„ì„ ì‹œ ë§¤ìš° ìœ ìš©í•˜ë‹¤.
ì´ ì½”ë“œëŠ” íŠ¹íˆ **ê²Œì„ ì„œë²„ì˜ ì‹¤í–‰ ì¤‘ ë°œìƒí•˜ëŠ” ì´ë²¤íŠ¸ë¥¼ ETW ì„¸ì…˜ì— ê¸°ë¡í•˜ëŠ” â€œProviderâ€** ì—­í• ì„ ìˆ˜í–‰í•œë‹¤.


#### ì „ì²´ êµ¬ì¡° ê°œìš”

ETW ì‹œìŠ¤í…œì€ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ë¥¼ ê°€ì§„ë‹¤.

```mermaid
graph TD
    A["ê²Œì„ ì„œë²„ ì½”ë“œ"] --> B["ETW Provider (ì´ ì½”ë“œ)"]
    B --> C["ETW Controller (ì˜ˆ: logman, tracelog)"]
    C --> D["ETW Consumer (ì´ë²¤íŠ¸ ë·°ì–´, PerfView ë“±)"]
```

* **Provider**: ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ì£¼ì²´ (ì´ ì½”ë“œ)
* **Controller**: ì–´ë–¤ Providerì˜ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì§‘í• ì§€ ì œì–´í•¨
* **Consumer**: ìˆ˜ì§‘ëœ ì´ë²¤íŠ¸ë¥¼ ë¶„ì„í•˜ê±°ë‚˜ ì‹œê°í™”í•¨


#### 1. ETW Provider ë“±ë¡

```cpp
ULONG result = EventRegister(&GameServerProviderGuid, nullptr, nullptr, &registrationHandle);
```

* `EventRegister` í•¨ìˆ˜ëŠ” ETW Providerë¥¼ ìœˆë„ìš° ì»¤ë„ì— ë“±ë¡í•œë‹¤.
* `GameServerProviderGuid`ëŠ” Providerë¥¼ ê³ ìœ í•˜ê²Œ ì‹ë³„í•˜ëŠ” GUIDì´ë‹¤.
* PowerShellì—ì„œ `[System.Guid]::NewGuid()` ëª…ë ¹ìœ¼ë¡œ ìƒˆ GUIDë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤.
* ë“±ë¡ì— ì„±ê³µí•˜ë©´ `registrationHandle`ì´ ë°œê¸‰ë˜ì–´ ì´í›„ ì´ë²¤íŠ¸ ê¸°ë¡ì— ì‚¬ìš©ëœë‹¤.

ë“±ë¡ ì„±ê³µ ì—¬ë¶€ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì¶œë ¥ëœë‹¤.

```cpp
if (result == ERROR_SUCCESS) {
    std::cout << "ETW Provider ë“±ë¡ ì„±ê³µ\n";
} else {
    std::cout << "ETW Provider ë“±ë¡ ì‹¤íŒ¨: " << result << "\n";
}
```


#### 2. ê¸°ë³¸ ì´ë²¤íŠ¸ ê¸°ë¡ í•¨ìˆ˜

```cpp
void logEvent(UCHAR level, const std::string& message);
```

ì´ í•¨ìˆ˜ëŠ” ê°€ì¥ ë‹¨ìˆœí•œ í˜•íƒœì˜ ì´ë²¤íŠ¸ë¥¼ ê¸°ë¡í•œë‹¤.
ETW ì´ë²¤íŠ¸ëŠ” **EVENT_DESCRIPTOR**ì™€ **EVENT_DATA_DESCRIPTOR** êµ¬ì¡°ì²´ë¥¼ ì´ìš©í•´ ì •ì˜ëœë‹¤.

* `EventDescCreate` â†’ ì´ë²¤íŠ¸ì˜ ID, ìˆ˜ì¤€(Level) ë“±ì„ ì„¤ì •í•œë‹¤.
* `EventDataDescCreate` â†’ ì‹¤ì œ ì´ë²¤íŠ¸ ë°ì´í„°ë¥¼ ì§€ì •í•œë‹¤.
* `EventWrite` â†’ ì´ë²¤íŠ¸ë¥¼ ê¸°ë¡í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒê³¼ ê°™ì´ ì‹¤í–‰ë  ìˆ˜ ìˆë‹¤.

```cpp
logEvent(TRACE_LEVEL_INFORMATION, "ì„œë²„ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.");
```


#### 3. ê²Œì„ ì„œë²„ íŠ¹í™” ì´ë²¤íŠ¸ ê¸°ë¡

##### (1) í”Œë ˆì´ì–´ ì—°ê²° ì´ë²¤íŠ¸

```cpp
void logPlayerConnect(int playerId, const std::string& playerName);
```

í”Œë ˆì´ì–´ê°€ ì„œë²„ì— ì ‘ì†í•  ë•Œ í˜¸ì¶œëœë‹¤.

```cpp
EventDescCreate(&eventDesc, 100, 0, 0, TRACE_LEVEL_INFORMATION, 1, 0, 0);
```

* ì´ë²¤íŠ¸ ID `100`ì€ í”Œë ˆì´ì–´ ì—°ê²°ì„ ì˜ë¯¸í•œë‹¤.
* ì´ë²¤íŠ¸ ìˆ˜ì¤€(Level)ì€ `TRACE_LEVEL_INFORMATION`ì´ë‹¤.

ì´ë²¤íŠ¸ ë°ì´í„°ëŠ” ë‘ ê°œì´ë‹¤.

1. í”Œë ˆì´ì–´ ID (`int`)
2. í”Œë ˆì´ì–´ ì´ë¦„ (`string`)

```cpp
EventDataDescCreate(&dataDescs[0], &playerId, sizeof(playerId));
EventDataDescCreate(&dataDescs[1], playerName.c_str(), static_cast<ULONG>(playerName.length() + 1));
```

ê²°ê³¼ì ìœ¼ë¡œ ETW ë¡œê·¸ì— ë‹¤ìŒê³¼ ê°™ì€ í˜•íƒœì˜ ì´ë²¤íŠ¸ê°€ ê¸°ë¡ëœë‹¤.

```
ETW: í”Œë ˆì´ì–´ ì—°ê²° - ID: 42, ì´ë¦„: DragonKnight
```

##### (2) ë©”ì‹œì§€ ì²˜ë¦¬ ì´ë²¤íŠ¸

```cpp
void logMessageProcessed(int messageType, DWORD processingTime);
```

íŠ¹ì • ë©”ì‹œì§€ íƒ€ì…ì˜ ì²˜ë¦¬ ì‹œê°„ì„ ê¸°ë¡í•œë‹¤.

* ì´ë²¤íŠ¸ ID `101`
* ìˆ˜ì¤€(Level): `TRACE_LEVEL_VERBOSE`
* `processingTime`ì€ ë°€ë¦¬ì´ˆ ë‹¨ìœ„ë¡œ ê³„ì‚°ëœë‹¤.

ì´ ì •ë³´ëŠ” ì„±ëŠ¥ ë¶„ì„ ì‹œ ë§¤ìš° ì¤‘ìš”í•˜ë‹¤.
íŠ¹ì • ë©”ì‹œì§€ê°€ ê³¼ë„í•˜ê²Œ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ê²½ìš°, ë³‘ëª© êµ¬ê°„ì„ ì‹ë³„í•  ìˆ˜ ìˆë‹¤.

##### (3) ì˜¤ë¥˜ ì´ë²¤íŠ¸

```cpp
void logError(const std::string& errorMessage, DWORD errorCode);
```

ì„œë²„ì—ì„œ ì˜ˆì™¸ë‚˜ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì„ ë•Œ ê¸°ë¡í•œë‹¤.

* ì´ë²¤íŠ¸ ID `102`
* ìˆ˜ì¤€(Level): `TRACE_LEVEL_ERROR`

ì´ë²¤íŠ¸ ì˜ˆì‹œ ì¶œë ¥:

```
ETW: ì—ëŸ¬ - Database connection failed (ì½”ë“œ: 5001)
```


#### 4. ì„±ëŠ¥ ì¸¡ì • ë„ìš°ë¯¸ (PerformanceTracker)
ì„±ëŠ¥ ì¸¡ì •ì„ ìë™í™”í•˜ê¸° ìœ„í•œ **RAII (Resource Acquisition Is Initialization)** íŒ¨í„´ í´ë˜ìŠ¤ì´ë‹¤.

```cpp
class PerformanceTracker {
private:
    ETWProvider& provider;
    int operationType;
    LARGE_INTEGER startTime;
    
public:
    PerformanceTracker(ETWProvider& p, int type)
        : provider(p), operationType(type) {
        QueryPerformanceCounter(&startTime);
    }

    ~PerformanceTracker() {
        LARGE_INTEGER endTime, frequency;
        QueryPerformanceCounter(&endTime);
        QueryPerformanceFrequency(&frequency);
        DWORD elapsed = static_cast<DWORD>(
            ((endTime.QuadPart - startTime.QuadPart) * 1000) / frequency.QuadPart
        );
        provider.logMessageProcessed(operationType, elapsed);
    }
};
```
  
##### ì‘ë™ íë¦„ (RAII ê°œë…)

```mermaid
sequenceDiagram
    participant Code as ê²Œì„ ì„œë²„ ì½”ë“œ
    participant Tracker as PerformanceTracker
    participant ETW as ETWProvider

    Code->>Tracker: ìƒì„±ì í˜¸ì¶œ (ì‹œì‘ ì‹œê° ê¸°ë¡)
    Code-->>Code: ì‘ì—… ìˆ˜í–‰
    Tracker->>ETW: ì†Œë©¸ì í˜¸ì¶œ ì‹œ ì²˜ë¦¬ ì‹œê°„ ê¸°ë¡
```

`PerformanceTracker`ëŠ” ìƒì„± ì‹œì ì— ì‹œê°„ì„ ê¸°ë¡í•˜ê³ , ì†Œë©¸ ì‹œ ìë™ìœ¼ë¡œ ìˆ˜í–‰ ì‹œê°„ì„ ETWì— ê¸°ë¡í•œë‹¤.
ì´ ë•ë¶„ì— ë³„ë„ì˜ íƒ€ì´ë¨¸ ì½”ë“œ ì—†ì´ í•¨ìˆ˜ì˜ ì‹¤í–‰ ì‹œê°„ì„ ìë™ìœ¼ë¡œ ì¶”ì í•  ìˆ˜ ìˆë‹¤.

 
#### 5. ì „ì²´ ë™ì‘ ìš”ì•½
ETWProvider í´ë˜ìŠ¤ì˜ ì£¼ìš” íë¦„ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

```plaintext
[ETWProvider ìƒì„±]
    â†“
EventRegister() ë¡œ ë“±ë¡
    â†“
[ì´ë²¤íŠ¸ ë°œìƒ ì‹œ]
    â†“
EventDescCreate() â†’ EventDataDescCreate() â†’ EventWrite()
    â†“
[ETW ì„¸ì…˜ìœ¼ë¡œ ì „ë‹¬]
```


#### ë§ˆë¬´ë¦¬
ì´ ì½”ë“œëŠ” **ê²Œì„ ì„œë²„ì˜ ë™ì‘ ìƒíƒœì™€ ì„±ëŠ¥ì„ ETW ê¸°ë°˜ìœ¼ë¡œ ì‹¤ì‹œê°„ ê¸°ë¡**í•˜ê¸° ìœ„í•œ ê¸°ë³¸ êµ¬ì¡°ë¥¼ ë³´ì—¬ì¤€ë‹¤.
ì´ë¥¼ í†µí•´ ì„œë²„ì˜ ë³‘ëª©, ì˜¤ë¥˜, í”Œë ˆì´ì–´ í™œë™ ë“±ì„ ì„¸ë°€í•˜ê²Œ ë¶„ì„í•  ìˆ˜ ìˆë‹¤.
ETWëŠ” CPU ì˜¤ë²„í—¤ë“œê°€ ë§¤ìš° ë‚®ê¸° ë•Œë¬¸ì—, **ì‹¤ì‹œê°„ ì„œë¹„ìŠ¤ í™˜ê²½ì—ì„œë„ ì•ˆì •ì ìœ¼ë¡œ ë¡œê¹…ì´ ê°€ëŠ¥**í•˜ë‹¤ëŠ” ì¥ì ì´ ìˆë‹¤.

ì´ êµ¬ì¡°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©´, ê²Œì„ ì„œë²„ì˜ ì•ˆì •ì„±ê³¼ ì„±ëŠ¥ ê°€ì‹œì„±ì„ ëŒ€í­ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤.



### 7.4.3 ETWë¥¼ í™œìš©í•œ ì„±ëŠ¥ ë¶„ì„

```cpp
class GameServerWithETW {
private:
    ETWProvider etwProvider;
    
public:
    void simulateGameOperations() {
        std::cout << "\n=== ETWë¥¼ í™œìš©í•œ ê²Œì„ ì„œë²„ ì‹œë®¬ë ˆì´ì…˜ ===\n";
        
        // í”Œë ˆì´ì–´ ì—°ê²° ì‹œë®¬ë ˆì´ì…˜
        for (int i = 1; i <= 5; ++i) {
            std::string playerName = "Player" + std::to_string(i);
            etwProvider.logPlayerConnect(i, playerName);
            Sleep(100);
        }
        
        // ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> msgTypeDist(1, 10);
        std::uniform_int_distribution<> delayDist(10, 100);
        
        for (int i = 0; i < 20; ++i) {
            int messageType = msgTypeDist(gen);
            int delay = delayDist(gen);
            
            {
                auto tracker = etwProvider.trackPerformance(messageType);
                // ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
                Sleep(delay);
            }
            
            // ê°€ë” ì—ëŸ¬ ë°œìƒ ì‹œë®¬ë ˆì´ì…˜
            if (i % 7 == 0) {
                etwProvider.logError("ì‹œë®¬ë ˆì´ì…˜ ì—ëŸ¬", 12345);
            }
        }
        
        std::cout << "\nì‹œë®¬ë ˆì´ì…˜ ì™„ë£Œ. ETW ì´ë²¤íŠ¸ê°€ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.\n";
        std::cout << "Windows Event Viewer ë˜ëŠ” WPA(Windows Performance Analyzer)ì—ì„œ í™•ì¸í•˜ì„¸ìš”.\n";
    }
    
    // ETW ì„¸ì…˜ ìƒì„± ê°€ì´ë“œ ì¶œë ¥
    void printETWUsageGuide() {
        std::cout << "\n=== ETW ì‚¬ìš© ê°€ì´ë“œ ===\n";
        std::cout << "1. ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ëª…ë ¹ í”„ë¡¬í”„íŠ¸ ì‹¤í–‰\n";
        std::cout << "2. ETW ì„¸ì…˜ ì‹œì‘:\n";
        std::cout << "   wpr -start GeneralProfile\n";
        std::cout << "   ë˜ëŠ”\n";
        std::cout << "   logman create trace GameServerTrace -p {12345678-1234-5678-1234-56789ABCDEF0}\n";
        std::cout << "   logman start GameServerTrace\n\n";
        
        std::cout << "3. ê²Œì„ ì„œë²„ ì‹¤í–‰ ë° í…ŒìŠ¤íŠ¸\n\n";
        
        std::cout << "4. ETW ì„¸ì…˜ ì¤‘ì§€ ë° ë¡œê·¸ ì €ì¥:\n";
        std::cout << "   wpr -stop trace.etl\n";
        std::cout << "   ë˜ëŠ”\n";
        std::cout << "   logman stop GameServerTrace\n\n";
        
        std::cout << "5. ë¶„ì„:\n";
        std::cout << "   - WPA (Windows Performance Analyzer)ë¡œ trace.etl ì—´ê¸°\n";
        std::cout << "   - ë˜ëŠ” tracerpt ëª…ë ¹ìœ¼ë¡œ í…ìŠ¤íŠ¸ ë³€í™˜\n";
        std::cout << "========================\n\n";
    }
};
```

</br>      
  
  
## 7.5 Visual Studio í”„ë¡œíŒŒì¼ëŸ¬ ì—°ë™

### 7.5.1 í”„ë¡œíŒŒì¼ë§ì„ ìœ„í•œ ì½”ë“œ ì¤€ë¹„

```cpp
#include <Windows.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>
#include <thread>

// Visual Studio í”„ë¡œíŒŒì¼ëŸ¬ API (ì„ íƒì‚¬í•­)
#ifdef _WIN32
#include <VSPerf.h>
#pragma comment(lib, "VSPerf.lib")
#endif

class ProfilingDemo {
private:
    std::vector<int> data;
    std::mt19937 rng;
    
public:
    ProfilingDemo(size_t size = 1000000) : data(size), rng(std::random_device{}()) {
        generateTestData();
    }
    
    void generateTestData() {
        std::cout << "í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± ì¤‘...\n";
        
        std::uniform_int_distribution<int> dist(1, 100000);
        for (auto& value : data) {
            value = dist(rng);
        }
    }
    
    // CPU ì§‘ì•½ì  ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
    void cpuIntensiveOperation() {
        std::cout << "CPU ì§‘ì•½ì  ì‘ì—… ì‹¤í–‰ ì¤‘...\n";
        
        // ì •ë ¬ ì‘ì—…
        std::sort(data.begin(), data.end());
        
        // ë³µì¡í•œ ê³„ì‚°
        double result = 0.0;
        for (size_t i = 0; i < data.size(); ++i) {
            result += std::sin(data[i]) * std::cos(data[i]) * std::sqrt(data[i]);
        }
        
        std::cout << "ê³„ì‚° ê²°ê³¼: " << result << "\n";
    }
    
    // ë©”ëª¨ë¦¬ ì§‘ì•½ì  ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
    void memoryIntensiveOperation() {
        std::cout << "ë©”ëª¨ë¦¬ ì§‘ì•½ì  ì‘ì—… ì‹¤í–‰ ì¤‘...\n";
        
        std::vector<std::vector<int>> matrix;
        const size_t MATRIX_SIZE = 1000;
        
        // ëŒ€ëŸ‰ì˜ ë©”ëª¨ë¦¬ í• ë‹¹
        matrix.reserve(MATRIX_SIZE);
        for (size_t i = 0; i < MATRIX_SIZE; ++i) {
            matrix.emplace_back(MATRIX_SIZE, static_cast<int>(i));
        }
        
        // ë©”ëª¨ë¦¬ ì ‘ê·¼ íŒ¨í„´ í…ŒìŠ¤íŠ¸
        int sum = 0;
        for (size_t i = 0; i < MATRIX_SIZE; ++i) {
            for (size_t j = 0; j < MATRIX_SIZE; ++j) {
                sum += matrix[i][j];
            }
        }
        
        std::cout << "ë§¤íŠ¸ë¦­ìŠ¤ í•©ê³„: " << sum << "\n";
    }
    
    // I/O ì§‘ì•½ì  ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
    void ioIntensiveOperation() {
        std::cout << "I/O ì§‘ì•½ì  ì‘ì—… ì‹¤í–‰ ì¤‘...\n";
        
        const std::string filename = "test_data.txt";
        
        // íŒŒì¼ ì“°ê¸°
        HANDLE hFile = CreateFileA(filename.c_str(), GENERIC_WRITE, 0, nullptr,
                                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
        
        if (hFile != INVALID_HANDLE_VALUE) {
            for (size_t i = 0; i < data.size() / 100; ++i) {  // ì¼ë¶€ ë°ì´í„°ë§Œ ì €ì¥
                std::string line = std::to_string(data[i]) + "\n";
                DWORD bytesWritten;
                WriteFile(hFile, line.c_str(), static_cast<DWORD>(line.length()),
                         &bytesWritten, nullptr);
            }
            CloseHandle(hFile);
        }
        
        // íŒŒì¼ ì½ê¸°
        hFile = CreateFileA(filename.c_str(), GENERIC_READ, 0, nullptr,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
        
        if (hFile != INVALID_HANDLE_VALUE) {
            char buffer[1024];
            DWORD bytesRead;
            int totalBytes = 0;
            
            while (ReadFile(hFile, buffer, sizeof(buffer) - 1, &bytesRead, nullptr)
                   && bytesRead > 0) {
                totalBytes += bytesRead;
                buffer[bytesRead] = '\0';
            }
            
            CloseHandle(hFile);
            DeleteFileA(filename.c_str());  // ì •ë¦¬
            
            std::cout << "ì´ ì½ì€ ë°”ì´íŠ¸: " << totalBytes << "\n";
        }
    }
    
    // ë©€í‹°ìŠ¤ë ˆë“œ ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
    void multithreadedOperation() {
        std::cout << "ë©€í‹°ìŠ¤ë ˆë“œ ì‘ì—… ì‹¤í–‰ ì¤‘...\n";
        
        const int NUM_THREADS = std::thread::hardware_concurrency();
        std::vector<std::thread> threads;
        std::vector<long long> results(NUM_THREADS, 0);
        
        size_t chunkSize = data.size() / NUM_THREADS;
        
        for (int i = 0; i < NUM_THREADS; ++i) {
            threads.emplace_back([this, i, chunkSize, &results]() {
                size_t start = i * chunkSize;
                size_t end = (i == NUM_THREADS - 1) ? data.size() : (i + 1) * chunkSize;
                
                long long sum = 0;
                for (size_t j = start; j < end; ++j) {
                    sum += data[j] * data[j];  // ì œê³± í•©ê³„
                }
                
                results[i] = sum;
            });
        }
        
        for (auto& t : threads) {
            t.join();
        }
        
        long long totalSum = 0;
        for (long long result : results) {
            totalSum += result;
        }
        
        std::cout << "ë©€í‹°ìŠ¤ë ˆë“œ ê³„ì‚° ê²°ê³¼: " << totalSum << "\n";
    }
    
    // ì „ì²´ ë²¤ì¹˜ë§ˆí¬ ì‹¤í–‰
    void runAllBenchmarks() {
        std::cout << "\n=== Visual Studio í”„ë¡œíŒŒì¼ë§ ë°ëª¨ ===\n";
        std::cout << "ì´ í”„ë¡œê·¸ë¨ì„ Visual Studioì—ì„œ í”„ë¡œíŒŒì¼ë§í•˜ì„¸ìš”.\n";
        std::cout << "ë©”ë‰´: ë””ë²„ê·¸ > ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬ > CPU ì‚¬ìš©ëŸ‰\n\n";
        
        auto runWithTiming = [](const std::string& name, std::function<void()> func) {
            std::cout << "\n--- " << name << " ---\n";
            auto start = std::chrono::high_resolution_clock::now();
            
            func();
            
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
            std::cout << "ì‹¤í–‰ ì‹œê°„: " << duration.count() << "ms\n";
        };
        
        runWithTiming("CPU ì§‘ì•½ì  ì‘ì—…", [this]() { cpuIntensiveOperation(); });
        runWithTiming("ë©”ëª¨ë¦¬ ì§‘ì•½ì  ì‘ì—…", [this]() { memoryIntensiveOperation(); });
        runWithTiming("I/O ì§‘ì•½ì  ì‘ì—…", [this]() { ioIntensiveOperation(); });
        runWithTiming("ë©€í‹°ìŠ¤ë ˆë“œ ì‘ì—…", [this]() { multithreadedOperation(); });
        
        std::cout << "\n=== í”„ë¡œíŒŒì¼ë§ ì™„ë£Œ ===\n";
    }
};
```

### 7.5.2 í”„ë¡œíŒŒì¼ë§ ìµœì í™” íŒ

```cpp
class ProfilingOptimizationTips {
public:
    // í•«ìŠ¤íŒŸ ìµœì í™” ì˜ˆì‹œ
    static void demonstrateOptimization() {
        std::cout << "\n=== ì„±ëŠ¥ ìµœì í™” ì˜ˆì‹œ ===\n";
        
        const size_t VECTOR_SIZE = 1000000;
        std::vector<int> data(VECTOR_SIZE);
        
        // ë°ì´í„° ì´ˆê¸°í™”
        for (size_t i = 0; i < VECTOR_SIZE; ++i) {
            data[i] = static_cast<int>(i % 1000);
        }
        
        // ìµœì í™” ì „: ë¹„íš¨ìœ¨ì ì¸ ê²€ìƒ‰
        std::cout << "ìµœì í™” ì „ - ì„ í˜• ê²€ìƒ‰:\n";
        auto start = std::chrono::high_resolution_clock::now();
        
        int target = 500;
        int count = 0;
        for (size_t iteration = 0; iteration < 1000; ++iteration) {
            for (size_t i = 0; i < VECTOR_SIZE; ++i) {
                if (data[i] == target) {
                    count++;
                }
            }
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "ì°¾ì€ ê°œìˆ˜: " << count << ", ì‹œê°„: " << duration1.count() << "ms\n";
        
        // ìµœì í™” í›„: ì •ë ¬ í›„ ì´ì§„ ê²€ìƒ‰
        std::cout << "\nìµœì í™” í›„ - ì •ë ¬ + ì´ì§„ ê²€ìƒ‰:\n";
        std::sort(data.begin(), data.end());
        
        start = std::chrono::high_resolution_clock::now();
        
        count = 0;
        for (size_t iteration = 0; iteration < 1000; ++iteration) {
            auto range = std::equal_range(data.begin(), data.end(), target);
            count += static_cast<int>(range.second - range.first);
        }
        
        end = std::chrono::high_resolution_clock::now();
        auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "ì°¾ì€ ê°œìˆ˜: " << count << ", ì‹œê°„: " << duration2.count() << "ms\n";
        
        std::cout << "ì„±ëŠ¥ í–¥ìƒ: " << (static_cast<double>(duration1.count()) / duration2.count()) 
                 << "ë°° ë¹¨ë¼ì§\n";
    }
    
    // ìºì‹œ íš¨ìœ¨ì„± ìµœì í™”
    static void demonstrateCacheOptimization() {
        std::cout << "\n=== ìºì‹œ ìµœì í™” ì˜ˆì‹œ ===\n";
        
        const size_t MATRIX_SIZE = 1000;
        std::vector<std::vector<int>> matrix(MATRIX_SIZE, std::vector<int>(MATRIX_SIZE, 1));
        
        // ìºì‹œ ë¹„íš¨ìœ¨ì : ì—´ ìš°ì„  ì ‘ê·¼
        std::cout << "ìºì‹œ ë¹„íš¨ìœ¨ì  (ì—´ ìš°ì„  ì ‘ê·¼):\n";
        auto start = std::chrono::high_resolution_clock::now();
        
        long long sum1 = 0;
        for (size_t j = 0; j < MATRIX_SIZE; ++j) {
            for (size_t i = 0; i < MATRIX_SIZE; ++i) {
                sum1 += matrix[i][j];  // ë©”ëª¨ë¦¬ ì í”„ ë°œìƒ
            }
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration1 = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        // ìºì‹œ íš¨ìœ¨ì : í–‰ ìš°ì„  ì ‘ê·¼
        std::cout << "ìºì‹œ íš¨ìœ¨ì  (í–‰ ìš°ì„  ì ‘ê·¼):\n";
        start = std::chrono::high_resolution_clock::now();
        
        long long sum2 = 0;
        for (size_t i = 0; i < MATRIX_SIZE; ++i) {
            for (size_t j = 0; j < MATRIX_SIZE; ++j) {
                sum2 += matrix[i][j];  // ìˆœì°¨ì  ë©”ëª¨ë¦¬ ì ‘ê·¼
            }
        }
        
        end = std::chrono::high_resolution_clock::now();
        auto duration2 = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        std::cout << "ë¹„íš¨ìœ¨ì  ë°©ë²•: " << duration1.count() << "Î¼s (í•©ê³„: " << sum1 << ")\n";
        std::cout << "íš¨ìœ¨ì  ë°©ë²•: " << duration2.count() << "Î¼s (í•©ê³„: " << sum2 << ")\n";
        std::cout << "ì„±ëŠ¥ í–¥ìƒ: " << (static_cast<double>(duration1.count()) / duration2.count()) 
                 << "ë°° ë¹¨ë¼ì§\n";
    }
    
    // ë©”ëª¨ë¦¬ í• ë‹¹ ìµœì í™”
    static void demonstrateMemoryOptimization() {
        std::cout << "\n=== ë©”ëª¨ë¦¬ í• ë‹¹ ìµœì í™” ===\n";
        
        const int ITERATIONS = 100000;
        
        // ë¹„íš¨ìœ¨ì : ë°˜ë³µì ì¸ ë™ì  í• ë‹¹
        std::cout << "ë¹„íš¨ìœ¨ì  (ë°˜ë³µ í• ë‹¹):\n";
        auto start = std::chrono::high_resolution_clock::now();
        
        for (int i = 0; i < ITERATIONS; ++i) {
            std::vector<int> temp(100);
            std::fill(temp.begin(), temp.end(), i);
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        // íš¨ìœ¨ì : ì¬ì‚¬ìš©
        std::cout << "íš¨ìœ¨ì  (ì¬ì‚¬ìš©):\n";
        start = std::chrono::high_resolution_clock::now();
        
        std::vector<int> reusable;
        reusable.reserve(100);  // ë¯¸ë¦¬ ìš©ëŸ‰ í™•ë³´
        
        for (int i = 0; i < ITERATIONS; ++i) {
            reusable.clear();
            reusable.resize(100);
            std::fill(reusable.begin(), reusable.end(), i);
        }
        
        end = std::chrono::high_resolution_clock::now();
        auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << "ë°˜ë³µ í• ë‹¹: " << duration1.count() << "ms\n";
        std::cout << "ì¬ì‚¬ìš©: " << duration2.count() << "ms\n";
        std::cout << "ì„±ëŠ¥ í–¥ìƒ: " << (static_cast<double>(duration1.count()) / duration2.count()) 
                 << "ë°° ë¹¨ë¼ì§\n";
    }
};
```

### 7.5.3 Visual Studio í”„ë¡œíŒŒì¼ëŸ¬ í™œìš© ê°€ì´ë“œ

```cpp
void printVisualStudioProfilingGuide() {
    std::cout << R"(
=== Visual Studio 2022 í”„ë¡œíŒŒì¼ëŸ¬ í™œìš© ê°€ì´ë“œ ===

1. ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬ ì‹œì‘:
   - ë©”ë‰´: ë””ë²„ê·¸ > ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬ (Alt+F2)
   - ë˜ëŠ” í”„ë¡œì íŠ¸ ìš°í´ë¦­ > ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬

2. í”„ë¡œíŒŒì¼ë§ ë„êµ¬ ì„ íƒ:
   âœ“ CPU ì‚¬ìš©ëŸ‰: í•¨ìˆ˜ë³„ ì‹¤í–‰ ì‹œê°„ ë¶„ì„
   âœ“ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë° í• ë‹¹ íŒ¨í„´ ë¶„ì„
   âœ“ .NET ê°œì²´ í• ë‹¹ ì¶”ì : ê´€ë¦¬ ì½”ë“œ ë©”ëª¨ë¦¬ ë¶„ì„
   âœ“ GPU ì‚¬ìš©ëŸ‰: DirectX/OpenGL ì„±ëŠ¥ ë¶„ì„

3. ë¶„ì„ ê²°ê³¼ í•´ì„:
   
   [CPU ì‚¬ìš©ëŸ‰]
   - í•« íŒ¨ìŠ¤ (Hot Path): ê°€ì¥ ë§ì€ ì‹œê°„ì„ ì†Œë¹„í•˜ëŠ” ê²½ë¡œ
   - í˜¸ì¶œ íŠ¸ë¦¬ (Call Tree): í•¨ìˆ˜ í˜¸ì¶œ ê³„ì¸µ êµ¬ì¡°
   - ëª¨ë“ˆ (Modules): ë¼ì´ë¸ŒëŸ¬ë¦¬ë³„ ì„±ëŠ¥ ë¶„ì„
   
   [ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰]
   - í™ ìŠ¤ëƒ…ìƒ·: íŠ¹ì • ì‹œì ì˜ ë©”ëª¨ë¦¬ ìƒíƒœ
   - ì°¨ì´ì  ë¶„ì„: ìŠ¤ëƒ…ìƒ· ê°„ ë©”ëª¨ë¦¬ ë³€í™”ëŸ‰
   - í• ë‹¹ ë°±íŠ¸ë ˆì´ìŠ¤: ë©”ëª¨ë¦¬ í• ë‹¹ ìœ„ì¹˜ ì¶”ì 

4. ìµœì í™” ìš°ì„ ìˆœìœ„:
   1ìˆœìœ„: CPU ì‚¬ìš©ëŸ‰ì´ ë†’ì€ í•¨ìˆ˜
   2ìˆœìœ„: ìì£¼ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜
   3ìˆœìœ„: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ê¸‰ê²©íˆ ì¦ê°€í•˜ëŠ” ë¶€ë¶„

5. í”„ë¡œíŒŒì¼ë§ íŒ:
   - Release ëª¨ë“œì—ì„œ í”„ë¡œíŒŒì¼ë§ ìˆ˜í–‰
   - ëŒ€í‘œì ì¸ ì›Œí¬ë¡œë“œë¡œ í…ŒìŠ¤íŠ¸
   - ì—¬ëŸ¬ ë²ˆ ì‹¤í–‰í•˜ì—¬ í‰ê· ê°’ í™•ì¸
   - ì‘ì€ ë³€ê²½ í›„ ì¦‰ì‹œ ì¸¡ì •

6. ê²Œì„ ì„œë²„ íŠ¹í™” ë©”íŠ¸ë¦­:
   - ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œê°„
   - ë™ì‹œ ì ‘ì†ì ìˆ˜ë³„ ì„±ëŠ¥ ë³€í™”
   - ë©”ëª¨ë¦¬ ì¦ê°€ìœ¨
   - CPU ì½”ì–´ë³„ ì‚¬ìš©ë¥ 

========================
)";
}
```
  
</br>  
  

## 7.6 ì¢…í•© ì˜ˆì œ: ê²Œì„ ì„œë²„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

```cpp
#include <Windows.h>
#include <iostream>
#include <thread>
#include <atomic>
#include <memory>
#include <chrono>

class ComprehensiveGameServerMonitor {
private:
    std::unique_ptr<PerformanceDashboard> dashboard;
    std::unique_ptr<ETWProvider> etwProvider;
    std::unique_ptr<ProfilingDemo> profilingDemo;
    
    std::atomic<bool> running{false};
    std::thread monitorThread;
    
public:
    ComprehensiveGameServerMonitor() {
        dashboard = std::make_unique<PerformanceDashboard>();
        etwProvider = std::make_unique<ETWProvider>();
        profilingDemo = std::make_unique<ProfilingDemo>();
    }
    
    void start() {
        std::cout << "=== ì¢…í•© ê²Œì„ ì„œë²„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ===\n\n";
        
        running = true;
        
        // ëŒ€ì‹œë³´ë“œ ì‹œì‘
        dashboard->start();
        
        // ì‹œë®¬ë ˆì´ì…˜ ìŠ¤ë ˆë“œ ì‹œì‘
        monitorThread = std::thread(&ComprehensiveGameServerMonitor::simulationLoop, this);
        
        std::cout << "ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.\n";
        std::cout << "ì•„ë¬´ í‚¤ë‚˜ ëˆ„ë¥´ë©´ ì¢…ë£Œë©ë‹ˆë‹¤...\n\n";
    }
    
    void stop() {
        running = false;
        
        if (monitorThread.joinable()) {
            monitorThread.join();
        }
        
        dashboard->stop();
        
        std::cout << "\nëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\n";
    }
    
    void waitForInput() {
        std::cin.get();
        stop();
    }
    
private:
    void simulationLoop() {
        auto& gameCounter = dashboard->getGameCounter();
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> playerDist(1, 1000);
        std::uniform_int_distribution<> actionDist(1, 5);
        
        int iteration = 0;
        
        while (running) {
            iteration++;
            
            // í”Œë ˆì´ì–´ í™œë™ ì‹œë®¬ë ˆì´ì…˜
            if (iteration % 10 == 0) {  // 10ë²ˆì— í•œ ë²ˆ í”Œë ˆì´ì–´ ì—°ê²°
                int playerId = playerDist(gen);
                std::string playerName = "Player" + std::to_string(playerId);
                
                gameCounter.onPlayerConnect();
                etwProvider->logPlayerConnect(playerId, playerName);
            }
            
            // ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
            for (int i = 0; i < 5; ++i) {
                int messageType = actionDist(gen);
                size_t messageSize = 64 + (messageType * 32);
                
                {
                    auto tracker = etwProvider->trackPerformance(messageType);
                    // ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
                    std::this_thread::sleep_for(std::chrono::microseconds(100));
                }
                
                gameCounter.onMessageProcessed(messageSize);
            }
            
            // ê°€ë” ì—ëŸ¬ ë°œìƒ
            if (iteration % 100 == 0) {
                gameCounter.onError();
                etwProvider->logError("ì‹œë®¬ë ˆì´ì…˜ ì—ëŸ¬", 500 + iteration);
            }
            
            // ê°€ë” í”Œë ˆì´ì–´ ì—°ê²° í•´ì œ
            if (iteration % 15 == 0) {
                gameCounter.onPlayerDisconnect();
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    }
};

int main() {
    try {
        // Visual Studio í”„ë¡œíŒŒì¼ë§ ê°€ì´ë“œ ì¶œë ¥
        printVisualStudioProfilingGuide();
        
        // ìµœì í™” ë°ëª¨ ì‹¤í–‰
        std::cout << "\nì„±ëŠ¥ ìµœì í™” ë°ëª¨ë¥¼ ì‹¤í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ";
        char choice;
        std::cin >> choice;
        std::cin.ignore();  // ê°œí–‰ ë¬¸ì ì œê±°
        
        if (choice == 'y' || choice == 'Y') {
            ProfilingOptimizationTips::demonstrateOptimization();
            ProfilingOptimizationTips::demonstrateCacheOptimization();
            ProfilingOptimizationTips::demonstrateMemoryOptimization();
            
            std::cout << "\nê³„ì†í•˜ë ¤ë©´ Enterë¥¼ ëˆ„ë¥´ì„¸ìš”...";
            std::cin.get();
        }
        
        // ETW ì‚¬ìš© ê°€ì´ë“œ ì¶œë ¥
        GameServerWithETW etwDemo;
        etwDemo.printETWUsageGuide();
        
        // ì¢…í•© ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì‹œì‘
        ComprehensiveGameServerMonitor monitor;
        monitor.start();
        monitor.waitForInput();
        
        std::cout << "\n=== ìµœì¢… ì„±ëŠ¥ ë¶„ì„ ë¦¬í¬íŠ¸ ===\n";
        
        // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê²€ì‚¬
        DetailedMemoryMonitor::detectMemoryLeaks();
        
        // ìµœì¢… ë©”ëª¨ë¦¬ ìƒíƒœ
        auto finalMemInfo = DetailedMemoryMonitor::getCurrentMemoryInfo();
        DetailedMemoryMonitor::printMemoryInfo(finalMemInfo);
        
        std::cout << "í”„ë¡œíŒŒì¼ë§ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\n";
        std::cout << "Visual Studioì—ì„œ ìˆ˜ì§‘ëœ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì„¸ìš”.\n";
        
    } catch (const std::exception& e) {
        std::cerr << "ì˜¤ë¥˜ ë°œìƒ: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```
  
</br>  
  

## 7.7 ì„±ëŠ¥ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸

```cpp
void printPerformanceOptimizationChecklist() {
    std::cout << R"(
=== ê²Œì„ ì„œë²„ ì„±ëŠ¥ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸ ===

[ ] CPU ìµœì í™”
    [ ] í•«ìŠ¤íŒŸ í•¨ìˆ˜ ì‹ë³„ ë° ìµœì í™”
    [ ] ë¶ˆí•„ìš”í•œ ì—°ì‚° ì œê±°
    [ ] ë£¨í”„ ìµœì í™” (ì–¸ë¡¤ë§, ìºì‹œ ì¹œí™”ì  ì ‘ê·¼)
    [ ] ì•Œê³ ë¦¬ì¦˜ ë³µì¡ë„ ê°œì„  (O(nÂ²) â†’ O(n log n))
    [ ] SIMD ëª…ë ¹ì–´ í™œìš© ê²€í† 

[ ] ë©”ëª¨ë¦¬ ìµœì í™”
    [ ] ë©”ëª¨ë¦¬ í’€ ì‚¬ìš©
    [ ] ê°ì²´ ì¬ì‚¬ìš© íŒ¨í„´ ì ìš©
    [ ] ë¶ˆí•„ìš”í•œ ë™ì  í• ë‹¹ ì œê±°
    [ ] ìºì‹œ ë¼ì¸ ì •ë ¬ (64ë°”ì´íŠ¸)
    [ ] False Sharing ë°©ì§€

[ ] I/O ìµœì í™”
    [ ] ë¹„ë™ê¸° I/O ì‚¬ìš©
    [ ] ë°°ì¹˜ ì²˜ë¦¬ë¡œ I/O ìš”ì²­ ìµœì†Œí™”
    [ ] ì ì ˆí•œ ë²„í¼ í¬ê¸° ì„¤ì •
    [ ] SSD íŠ¹ì„±ì— ë§ëŠ” ì ‘ê·¼ íŒ¨í„´

[ ] ë„¤íŠ¸ì›Œí¬ ìµœì í™”
    [ ] ë©”ì‹œì§€ ì••ì¶• ë° ë°°ì¹˜ ì²˜ë¦¬
    [ ] ë¶ˆí•„ìš”í•œ ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ ì œê±°
    [ ] ì—°ê²° í’€ë§ ì‚¬ìš©
    [ ] TCP Nagle ì•Œê³ ë¦¬ì¦˜ ê³ ë ¤

[ ] ë™ì‹œì„± ìµœì í™”
    [ ] ë½ ê²½í•© ìµœì†Œí™”
    [ ] ë¬´ì ê¸ˆ ìë£Œêµ¬ì¡° í™œìš©
    [ ] ìŠ¤ë ˆë“œ í’€ ì ì ˆí•œ í¬ê¸° ì„¤ì •
    [ ] ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ìµœì†Œí™”

[ ] ëª¨ë‹ˆí„°ë§ ë° í”„ë¡œíŒŒì¼ë§
    [ ] ì§€ì†ì ì¸ ì„±ëŠ¥ ì¸¡ì •
    [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ëª¨ë‹ˆí„°ë§
    [ ] ë³‘ëª© ì§€ì  ì‹ë³„
    [ ] ETW ì´ë²¤íŠ¸ ë¡œê¹…

================================================
)";
}
```
  
</br>  
  
  
## 7.8 ë§ˆë¬´ë¦¬
ì´ë²ˆ ì¥ì—ì„œëŠ” ê²Œì„ ì„œë²„ì˜ ì„±ëŠ¥ì„ ëª¨ë‹ˆí„°ë§í•˜ê³  ë¶„ì„í•˜ëŠ” ë‹¤ì–‘í•œ ë°©ë²•ì„ ì•Œì•„ë³´ì•˜ë‹¤:

1. **Performance Counter API**: ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
2. **CPU ë° ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§**: ì •ë°€í•œ ì„±ëŠ¥ ì¸¡ì • ê¸°ë²•
3. **ETW (Event Tracing for Windows)**: ê³ ì„±ëŠ¥ ì´ë²¤íŠ¸ ë¡œê¹… ì‹œìŠ¤í…œ  
4. **Visual Studio í”„ë¡œíŒŒì¼ëŸ¬**: í†µí•© ê°œë°œ í™˜ê²½ì—ì„œì˜ ì„±ëŠ¥ ë¶„ì„

```
ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì˜ í•µì‹¬ ì›ì¹™:

ì¸¡ì • â†’ ë¶„ì„ â†’ ìµœì í™” â†’ ê²€ì¦
   â†‘                    â†“
   â†  â†  â†  â†  â†  â†  â†  â†
   
ì§€ì†ì ì¸ ì„±ëŠ¥ ê°œì„  ì‚¬ì´í´
```

ì„±ëŠ¥ ìµœì í™”ëŠ” ë‹¨ë°œì„±ì´ ì•„ë‹Œ ì§€ì†ì ì¸ ê³¼ì •ì´ë‹¤. ì •ê¸°ì ì¸ ëª¨ë‹ˆí„°ë§ê³¼ í”„ë¡œíŒŒì¼ë§ì„ í†µí•´ ì„±ëŠ¥ ì €í•˜ë¥¼ ì¡°ê¸°ì— ë°œê²¬í•˜ê³  ëŒ€ì‘í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤. ë‹¤ìŒ ì¥ì—ì„œëŠ” WMIë¥¼ í™œìš©í•œ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê² ë‹¤.  