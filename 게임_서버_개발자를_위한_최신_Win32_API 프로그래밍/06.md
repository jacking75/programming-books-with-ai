# ê²Œì„ ì„œë²„ ê°œë°œìë¥¼ ìœ„í•œ ìµœì‹  Win32 API í”„ë¡œê·¸ë˜ë°  

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  

# Chapter 6. ì¸í„°ë½ ì—°ì‚°ê³¼ ë¬´ì ê¸ˆ í”„ë¡œê·¸ë˜ë°

## 6.1 ë“¤ì–´ê°€ë©°
ê²Œì„ ì„œë²„ì—ì„œ ë†’ì€ ì„±ëŠ¥ì„ ì–»ê¸° ìœ„í•´ì„œëŠ” ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°ì´ í•„ìˆ˜ì ì…ì´ë‹¤. í•˜ì§€ë§Œ ì „í†µì ì¸ ë®¤í…ìŠ¤ë‚˜ í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ ê°™ì€ ì ê¸ˆ ë©”ì»¤ë‹ˆì¦˜ì€ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ê³¼ ëŒ€ê¸° ì‹œê°„ìœ¼ë¡œ ì¸í•´ ì„±ëŠ¥ ë³‘ëª©ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ì´ëŸ° ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë“±ì¥í•œ ê²ƒì´ ë°”ë¡œ **ì¸í„°ë½ ì—°ì‚°(Interlocked Operations)** ê³¼ **ë¬´ì ê¸ˆ í”„ë¡œê·¸ë˜ë°(Lock-Free Programming)** ì´ë‹¤.

```
ì „í†µì ì¸ ì ê¸ˆ ë°©ì‹:
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚Threadâ”‚â”€â”€â”€â–¶â”‚Lock â”‚â”€â”€â”€â–¶â”‚Work â”‚
â”‚  A   â”‚    â”‚Wait â”‚    â”‚Done â”‚
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
     
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚Threadâ”‚â”€â”€â”€â–¶â”‚Wait â”‚â”€â”€â”€â–¶â”‚Lock â”‚â”€â”€â”€â–¶â”‚Work â”‚
â”‚  B   â”‚    â”‚...  â”‚    â”‚Wait â”‚    â”‚Done â”‚
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜

ë¬´ì ê¸ˆ ë°©ì‹:
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚Threadâ”‚â”€â”€â”€â–¶â”‚Work â”‚
â”‚  A   â”‚    â”‚Done â”‚
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
     
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚Threadâ”‚â”€â”€â”€â–¶â”‚Work â”‚
â”‚  B   â”‚    â”‚Done â”‚
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
```
  

## 6.2 InterlockedXXX í•¨ìˆ˜êµ° ì™„ì „ ì •ë³µ

### 6.2.1 ê¸°ë³¸ ê°œë…
ì¸í„°ë½ ì—°ì‚°ì€ CPU ë ˆë²¨ì—ì„œ ì›ìì (atomic)ìœ¼ë¡œ ìˆ˜í–‰ë˜ëŠ” ì—°ì‚°ì´ë‹¤. ì´ëŠ” ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ê°„ì„­ ì—†ì´ í•´ë‹¹ ì—°ì‚°ì´ ì™„ì „íˆ ì™„ë£Œë¨ì„ ë³´ì¥í•œë‹¤.

```cpp
#include <Windows.h>
#include <iostream>
#include <thread>
#include <vector>

// ì˜ëª»ëœ ì˜ˆì‹œ - ê²½í•© ì¡°ê±´(Race Condition) ë°œìƒ
class BadCounter {
private:
    int count = 0;
    
public:
    void increment() {
        count++;  // ì›ìì ì´ì§€ ì•ŠìŒ!
    }
    
    int getCount() const { return count; }
};

// ì˜¬ë°”ë¥¸ ì˜ˆì‹œ - ì¸í„°ë½ ì—°ì‚° ì‚¬ìš©
class GoodCounter {
private:
    LONG count = 0;
    
public:
    void increment() {
        InterlockedIncrement(&count);  // ì›ìì  ì—°ì‚°!
    }
    
    LONG getCount() const { 
        return InterlockedCompareExchange(&count, 0, 0);  // ì›ìì  ì½ê¸°
    }
};
```

### 6.2.2 ì£¼ìš” InterlockedXXX í•¨ìˆ˜ë“¤

#### ê¸°ë³¸ ì‚°ìˆ  ì—°ì‚°

```cpp
#include <Windows.h>
#include <iostream>

void demonstrateBasicOperations() {
    LONG value = 100;
    
    std::cout << "=== ê¸°ë³¸ ì‚°ìˆ  ì—°ì‚° ===\n";
    std::cout << "ì´ˆê¸°ê°’: " << value << "\n";
    
    // ì¦ê°€/ê°ì†Œ
    LONG oldValue = InterlockedIncrement(&value);
    std::cout << "Increment í›„: " << value << " (ì´ì „ê°’: " << oldValue-1 << ")\n";
    
    oldValue = InterlockedDecrement(&value);
    std::cout << "Decrement í›„: " << value << " (ì´ì „ê°’: " << oldValue+1 << ")\n";
    
    // ë§ì…ˆ/ëº„ì…ˆ
    oldValue = InterlockedExchangeAdd(&value, 50);
    std::cout << "50 ì¶”ê°€ í›„: " << value << " (ì´ì „ê°’: " << oldValue << ")\n";
    
    oldValue = InterlockedExchangeAdd(&value, -25);
    std::cout << "25 ë¹¼ê¸° í›„: " << value << " (ì´ì „ê°’: " << oldValue << ")\n";
    
    // ë¹„íŠ¸ ì—°ì‚°
    oldValue = InterlockedAnd(&value, 0xFF);  // í•˜ìœ„ 8ë¹„íŠ¸ë§Œ ìœ ì§€
    std::cout << "AND 0xFF í›„: " << value << " (ì´ì „ê°’: " << oldValue << ")\n";
    
    oldValue = InterlockedOr(&value, 0x100);  // 9ë²ˆì§¸ ë¹„íŠ¸ ì„¤ì •
    std::cout << "OR 0x100 í›„: " << value << " (ì´ì „ê°’: " << oldValue << ")\n";
}
```

#### êµí™˜(Exchange) ì—°ì‚°

```cpp
void demonstrateExchangeOperations() {
    LONG value = 42;
    PVOID pointer = nullptr;
    
    std::cout << "\n=== êµí™˜ ì—°ì‚° ===\n";
    
    // ë‹¨ìˆœ êµí™˜
    LONG oldValue = InterlockedExchange(&value, 100);
    std::cout << "Exchange: ìƒˆê°’=" << value << ", ì´ì „ê°’=" << oldValue << "\n";
    
    // ì¡°ê±´ë¶€ êµí™˜ (Compare and Swap)
    LONG expected = 100;
    LONG newValue = 200;
    LONG actualOld = InterlockedCompareExchange(&value, newValue, expected);
    
    if (actualOld == expected) {
        std::cout << "CAS ì„±ê³µ: " << expected << " â†’ " << newValue << "\n";
    } else {
        std::cout << "CAS ì‹¤íŒ¨: ì˜ˆìƒ=" << expected << ", ì‹¤ì œ=" << actualOld << "\n";
    }
    
    // í¬ì¸í„° êµí™˜
    int data = 123;
    PVOID newPtr = &data;
    PVOID oldPtr = InterlockedExchangePointer(&pointer, newPtr);
    std::cout << "í¬ì¸í„° êµí™˜: ì´ì „=" << oldPtr << ", ìƒˆí¬ì¸í„°=" << pointer << "\n";
}
```

### 6.2.3 64ë¹„íŠ¸ ì—°ì‚°

```cpp
void demonstrate64BitOperations() {
    LONG64 bigValue = 0x123456789ABCDEF0LL;
    
    std::cout << "\n=== 64ë¹„íŠ¸ ì—°ì‚° ===\n";
    std::cout << "ì´ˆê¸°ê°’: 0x" << std::hex << bigValue << "\n";
    
    // 64ë¹„íŠ¸ ì¦ê°€
    LONG64 oldBig = InterlockedIncrement64(&bigValue);
    std::cout << "Increment64 í›„: 0x" << std::hex << bigValue << "\n";
    
    // 64ë¹„íŠ¸ êµí™˜
    LONG64 newBig = 0xFEDCBA9876543210LL;
    oldBig = InterlockedExchange64(&bigValue, newBig);
    std::cout << "Exchange64: ìƒˆê°’=0x" << std::hex << bigValue 
              << ", ì´ì „ê°’=0x" << oldBig << "\n";
    
    std::cout << std::dec;  // 10ì§„ìˆ˜ë¡œ ë³µì›
}
```

### 6.2.4 ìŠ¤í•€ë½ êµ¬í˜„í•˜ê¸°

```cpp
class SpinLock {
private:
    LONG lockFlag = 0;
    
public:
    void lock() {
        while (InterlockedCompareExchange(&lockFlag, 1, 0) != 0) {
            // CPU ì‚¬ì´í´ ì ˆì•½ì„ ìœ„í•œ íŒíŠ¸
            YieldProcessor();
        }
    }
    
    void unlock() {
        InterlockedExchange(&lockFlag, 0);
    }
    
    bool tryLock() {
        return InterlockedCompareExchange(&lockFlag, 1, 0) == 0;
    }
};

// RAII ìŠ¤íƒ€ì¼ ë½ ê°€ë“œ
class SpinLockGuard {
private:
    SpinLock& lock_;
    
public:
    explicit SpinLockGuard(SpinLock& lock) : lock_(lock) {
        lock_.lock();
    }
    
    ~SpinLockGuard() {
        lock_.unlock();
    }
    
    // ë³µì‚¬ ê¸ˆì§€
    SpinLockGuard(const SpinLockGuard&) = delete;
    SpinLockGuard& operator=(const SpinLockGuard&) = delete;
};

// ì‚¬ìš© ì˜ˆì‹œ
void demonstrateSpinLock() {
    SpinLock spinLock;
    int sharedData = 0;
    
    auto worker = [&](int id) {
        for (int i = 0; i < 1000; ++i) {
            SpinLockGuard guard(spinLock);
            sharedData++;
            std::cout << "Thread " << id << ": " << sharedData << "\n";
        }
    };
    
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);
    
    t1.join();
    t2.join();
    
    std::cout << "ìµœì¢… ê°’: " << sharedData << "\n";
}
```
    
ì´ë²ˆ ì˜ˆì œì—ì„œëŠ” **ìŠ¤í•€ë½(SpinLock)** ì„ ì§ì ‘ êµ¬í˜„í•´ë³´ë©°,
ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ **ì§§ì€ ì‹œê°„ ë™ì•ˆ ìì›ì„ ë³´í˜¸í•´ì•¼ í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ê²½ëŸ‰ ë™ê¸°í™” ê¸°ë²•**ì„ ì‚´í´ë³´ê² ë‹¤.

ìŠ¤í•€ë½ì€ **ë®¤í…ìŠ¤(Mutex)** ë‚˜ **Critical Section**ë³´ë‹¤ í›¨ì”¬ ê°€ë³ê³  ë¹ ë¥´ì§€ë§Œ,
**CPUë¥¼ ê³„ì† ì ìœ í•˜ë©´ì„œ ëŒ€ê¸°**í•œë‹¤ëŠ” íŠ¹ì§•ì´ ìˆë‹¤.
ë”°ë¼ì„œ â€œì ê¸ˆ ì‹œê°„ì´ ì§§ê³ , ì¶©ëŒì´ ìì£¼ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ” ìƒí™©â€ì—ì„œ ê°€ì¥ íš¨ìœ¨ì ì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, **ì§§ì€ ê³„ì‚° í›„ ì¦‰ì‹œ í•´ì œë˜ëŠ” ê³µìœ  ë³€ìˆ˜ ë³´í˜¸**ë‚˜
**ì§§ì€ ì„ê³„ êµ¬ì—­(critical section)** ì„ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ìì£¼ ì ‘ê·¼í•˜ëŠ” ê²½ìš°ì— ì‚¬ìš©í•˜ë©´ íš¨ê³¼ì ì´ë‹¤.

#### 1. SpinLock í´ë˜ìŠ¤ êµ¬ì¡°

```cpp
class SpinLock {
private:
    LONG lockFlag = 0;
```

* `lockFlag`ëŠ” ì ê¸ˆ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸ ë³€ìˆ˜ë‹¤.

  * `0`: ì ê¸ˆì´ í•´ì œëœ ìƒíƒœ (Unlocked)
  * `1`: ì ê¸ˆì´ ê±¸ë¦° ìƒíƒœ (Locked)
* Windowsì—ì„œ ì œê³µí•˜ëŠ” **ì›ìì (atomic)** ì—°ì‚° í•¨ìˆ˜ë¥¼ ì´ìš©í•´ í”Œë˜ê·¸ë¥¼ ì œì–´í•œë‹¤.

#### 2. lock() í•¨ìˆ˜ â€” ë½ íšë“ ê³¼ì •

```cpp
void lock() {
    while (InterlockedCompareExchange(&lockFlag, 1, 0) != 0) {
        // CPU ì‚¬ì´í´ ì ˆì•½ì„ ìœ„í•œ íŒíŠ¸
        YieldProcessor();
    }
}
```

ì´ ë¶€ë¶„ì´ ìŠ¤í•€ë½ì˜ í•µì‹¬ì´ë‹¤.

* `InterlockedCompareExchange()`ëŠ” **ì›ìì ìœ¼ë¡œ** ê°’ì„ ë¹„êµí•˜ê³  êµì²´í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

  * ì²« ë²ˆì§¸ ì¸ì(`lockFlag`)ê°€ ê¸°ëŒ€ê°’(`0`)ì´ë©´ `1`ë¡œ ë°”ê¾¸ê³ ,
  * ì„±ê³µí•˜ë©´ ì´ì „ ê°’ `0`ì„ ë°˜í™˜í•œë‹¤.
  * ì‹¤íŒ¨í•˜ë©´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ì ê¸ˆ ì¤‘ì´ë¯€ë¡œ `!= 0`ì´ ë˜ì–´ ë£¨í”„ë¥¼ ëˆë‹¤.

ì¦‰, **ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ê¸ˆì„ í•´ì œí•  ë•Œê¹Œì§€ ê³„ì† ë°˜ë³µ(Spin)** í•œë‹¤.
ì´ë¥¼ â€œ**busy waiting**â€ ë˜ëŠ” â€œ**spin-waiting**â€ì´ë¼ê³  ë¶€ë¥¸ë‹¤.

`YieldProcessor()`ëŠ” CPUê°€ ì‰¬ëŠ” ëŒ€ì‹  **ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ì‹¤í–‰ ê¸°íšŒë¥¼ ì ê¹ ì–‘ë³´í•˜ë„ë¡ íŒíŠ¸**ë¥¼ ì£¼ëŠ” í•¨ìˆ˜ë‹¤.
ì´ë¥¼ í†µí•´ CPU ì‚¬ì´í´ ë‚­ë¹„ë¥¼ ì¤„ì´ê³ , ê³¼ë„í•œ ì „ë ¥ ì†Œëª¨ë¥¼ ë°©ì§€í•œë‹¤.

#### 3. unlock() í•¨ìˆ˜ â€” ë½ í•´ì œ

```cpp
void unlock() {
    InterlockedExchange(&lockFlag, 0);
}
```

ë½ì„ í•´ì œí•  ë•ŒëŠ” ë‹¨ìˆœíˆ `lockFlag`ë¥¼ 0ìœ¼ë¡œ ëŒë ¤ë†“ëŠ”ë‹¤.
ì´ë•Œë„ `InterlockedExchange()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì›ìì ìœ¼ë¡œ ìˆ˜í–‰í•œë‹¤.
ì¦‰, ì¤‘ê°„ì— ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¼ì–´ë“¤ ìˆ˜ ì—†ë‹¤.

#### 4. tryLock() í•¨ìˆ˜ â€” ì¦‰ì‹œ ì‹œë„

```cpp
bool tryLock() {
    return InterlockedCompareExchange(&lockFlag, 1, 0) == 0;
}
```

ì´ í•¨ìˆ˜ëŠ” ì ê¸ˆì„ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  **ì¦‰ì‹œ ì‹œë„ë§Œ í•´ë³´ëŠ” ë¹„ì°¨ë‹¨(non-blocking)** ë²„ì „ì´ë‹¤.

* ì„±ê³µí•˜ë©´ `true`ë¥¼ ë°˜í™˜í•˜ê³ ,
* ì´ë¯¸ ì ê¸ˆ ì¤‘ì´ë©´ `false`ë¥¼ ë°˜í™˜í•œë‹¤.

ì´ë¥¼ í†µí•´ â€œì ê¸ˆ ì‹¤íŒ¨ ì‹œ ë‹¤ë¥¸ ì‘ì—…ì„ ë¨¼ì € ìˆ˜í–‰â€í•˜ëŠ” ìœ ì—°í•œ ë¡œì§ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

#### 5. SpinLockGuard â€” RAII íŒ¨í„´ìœ¼ë¡œ ì•ˆì „í•œ ì‚¬ìš©

```cpp
class SpinLockGuard {
private:
    SpinLock& lock_;
    
public:
    explicit SpinLockGuard(SpinLock& lock) : lock_(lock) {
        lock_.lock();
    }
    
    ~SpinLockGuard() {
        lock_.unlock();
    }
};
```

ì´ í´ë˜ìŠ¤ëŠ” C++ì˜ **RAII(Resource Acquisition Is Initialization)** íŒ¨í„´ì„ ì‚¬ìš©í•œë‹¤.
ì¦‰, ê°ì²´ê°€ ìƒì„±ë  ë•Œ ë½ì„ ìë™ìœ¼ë¡œ ê±¸ê³ ,
ê°ì²´ê°€ ì†Œë©¸ë  ë•Œ ë½ì„ ìë™ìœ¼ë¡œ í•´ì œí•œë‹¤.

ì´ë ‡ê²Œ í•˜ë©´ `unlock()` í˜¸ì¶œì„ ê¹œë¹¡í•´ì„œ **ë°ë“œë½(deadlock)** ì´ ë°œìƒí•˜ëŠ” ì‹¤ìˆ˜ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œëŠ” ë§¤ìš° ì•ˆì „í•˜ë‹¤.

```cpp
{
    SpinLockGuard guard(spinLock);
    sharedData++;   // ì„ê³„ êµ¬ì—­
}   // ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë©´ ìë™ìœ¼ë¡œ unlock()
```

#### 6. ì‚¬ìš© ì˜ˆì‹œ â€” ë‘ ìŠ¤ë ˆë“œê°€ ê³µìœ  ë³€ìˆ˜ ì ‘ê·¼

```cpp
void demonstrateSpinLock() {
    SpinLock spinLock;
    int sharedData = 0;
    
    auto worker = [&](int id) {
        for (int i = 0; i < 1000; ++i) {
            SpinLockGuard guard(spinLock);
            sharedData++;
            std::cout << "Thread " << id << ": " << sharedData << "\n";
        }
    };
```

ì—¬ê¸°ì„œëŠ” `sharedData`ë¼ëŠ” ê³µìœ  ìì›ì„ ë‘ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ìˆ˜ì •í•œë‹¤.
ë§Œì•½ ë½ì´ ì—†ë‹¤ë©´, ìŠ¤ë ˆë“œ ê°„ ê²½í•©ìœ¼ë¡œ ì¸í•´ **ë°ì´í„° ì†ìƒ(race condition)** ì´ ë°œìƒí•œë‹¤.

`SpinLockGuard`ë¥¼ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ë‹¤ìŒê³¼ ê°™ì€ íë¦„ì´ ë³´ì¥ëœë‹¤.

1. í•œ ìŠ¤ë ˆë“œê°€ `SpinLockGuard`ë¥¼ ìƒì„±í•˜ë©´ `lock()`ì„ í˜¸ì¶œí•œë‹¤.
2. ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” ì ê¸ˆì´ í’€ë¦´ ë•Œê¹Œì§€ `YieldProcessor()`ë¡œ ëŒ€ê¸°í•œë‹¤.
3. ë½ì„ ë³´ìœ í•œ ìŠ¤ë ˆë“œê°€ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë©´ `~SpinLockGuard()`ì—ì„œ ìë™ìœ¼ë¡œ `unlock()`ëœë‹¤.

#### 7. ì‹¤í–‰ ê²°ê³¼ ì˜ˆì‹œ

```
Thread 1: 1
Thread 2: 2
Thread 1: 3
Thread 2: 4
...
ìµœì¢… ê°’: 2000
```

ê²°ê³¼ì ìœ¼ë¡œ `sharedData`ëŠ” 2000ì´ ë˜ì–´,
ëª¨ë“  ì¦ê°€ ì—°ì‚°ì´ ì •í™•íˆ ìˆ˜í–‰ë˜ì—ˆìŒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

ë§Œì•½ ë½ì´ ì—†ì—ˆë‹¤ë©´, ë™ì‹œ ì ‘ê·¼ìœ¼ë¡œ ì¸í•´ ê²°ê³¼ê°€ 2000ë³´ë‹¤ ì‘ê²Œ ë‚˜ì™”ì„ ê²ƒì´ë‹¤.

#### 8. ìŠ¤í•€ë½ì˜ ì¥ë‹¨ì  ì •ë¦¬

| êµ¬ë¶„            | ì„¤ëª…                                                                            |
| ------------- | ----------------------------------------------------------------------------- |
| **ì¥ì **        | - ë§¤ìš° ë¹ ë¦„ (ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ì—†ìŒ)<br>- ì»¤ë„ ëª¨ë“œ ì§„ì…ì´ í•„ìš” ì—†ìŒ<br>- ì§§ì€ ì„ê³„ êµ¬ì—­ì—ì„œ ë›°ì–´ë‚œ ì„±ëŠ¥             |
| **ë‹¨ì **        | - ì ê¸ˆ ì¤‘ì—ë„ CPUë¥¼ ê³„ì† ì‚¬ìš©í•¨<br>- ê¸´ ëŒ€ê¸° ì‹œê°„ì´ ë°œìƒí•˜ë©´ ë¹„íš¨ìœ¨ì <br>- ì½”ì–´ ìˆ˜ê°€ ì ê±°ë‚˜ ê²½ìŸì´ ì‹¬í•œ ê²½ìš° ì˜¤íˆë ¤ ëŠë ¤ì§ |
| **ì í•©í•œ ì‚¬ìš© ì˜ˆì‹œ** | - ê³µìœ  ìì› ë³´í˜¸ êµ¬ê°„ì´ ì§§ì€ ê²½ìš°<br>- ë½ ì¶©ëŒ í™•ë¥ ì´ ë‚®ì€ ê²½ìš°<br>- ê²Œì„ ì„œë²„ì˜ ì‹¤ì‹œê°„ ì¹´ìš´í„°, ê°„ë‹¨í•œ ìºì‹œ ê°±ì‹  ë“±     |


#### 9. ê²°ë¡ 
ìŠ¤í•€ë½ì€ â€œ**ì§§ì€ ì‹œê°„ ë™ì•ˆë§Œ ê³µìœ  ë°ì´í„°ë¥¼ ë³´í˜¸í•´ì•¼ í•˜ëŠ” ìƒí™©**â€ì—ì„œ ê°•ë ¥í•œ ì„±ëŠ¥ì„ ë°œíœ˜í•œë‹¤.
í•˜ì§€ë§Œ ì¥ì‹œê°„ ì ìœ í•˜ê±°ë‚˜ ë§ì€ ìŠ¤ë ˆë“œê°€ ê²½ìŸí•˜ëŠ” ê²½ìš°ì—ëŠ” ì˜¤íˆë ¤ ì‹œìŠ¤í…œ íš¨ìœ¨ì„ ë–¨ì–´ëœ¨ë¦°ë‹¤.

ì¦‰, **ìŠ¤í•€ë½ì€ ê²½ëŸ‰ ë™ê¸°í™” ë„êµ¬ë¡œì„œ ë¹ ë¥¸ ì‘ë‹µì„±ê³¼ ì§§ì€ ë³´í˜¸ êµ¬ê°„ì´ í•„ìš”í•œ ì½”ë“œì— ì í•©í•œ ì„ íƒ**ì´ë‹¤.
ì´ ì˜ˆì œëŠ” ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ **ìµœì†Œí•œì˜ ì˜¤ë²„í—¤ë“œë¡œ ë™ê¸°í™”ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•**ì„ ì˜ ë³´ì—¬ì£¼ëŠ” ì˜ˆë‹¤.


</br>  
  
## 6.3 ë¬´ì ê¸ˆ íì™€ ìŠ¤íƒ êµ¬í˜„

### 6.3.1 ë¬´ì ê¸ˆ ìŠ¤íƒ (Lock-Free Stack)

```cpp
template<typename T>
class LockFreeStack {
private:
    struct Node {
        T data;
        Node* next;
        
        Node(const T& item) : data(item), next(nullptr) {}
    };
    
    Node* head = nullptr;
    
public:
    ~LockFreeStack() {
        while (Node* node = head) {
            head = node->next;
            delete node;
        }
    }
    
    void push(const T& item) {
        Node* newNode = new Node(item);
        
        do {
            newNode->next = head;
        } while (InterlockedCompareExchangePointer(
            reinterpret_cast<PVOID*>(&head),
            newNode,
            newNode->next) != newNode->next);
    }
    
    bool pop(T& result) {
        Node* oldHead;
        
        do {
            oldHead = head;
            if (oldHead == nullptr) {
                return false;  // ìŠ¤íƒì´ ë¹„ì–´ìˆìŒ
            }
        } while (InterlockedCompareExchangePointer(
            reinterpret_cast<PVOID*>(&head),
            oldHead->next,
            oldHead) != oldHead);
        
        result = oldHead->data;
        delete oldHead;
        return true;
    }
    
    bool empty() const {
        return head == nullptr;
    }
};
```
  
ì´ ì½”ë“œëŠ” **ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ë™ê¸°í™”ë¥¼ ìœ„í•œ ì ê¸ˆ(lock)** ì—†ì´ ë™ì‘í•˜ëŠ” **ë¬´ì ê¸ˆ ìŠ¤íƒ(Lock-Free Stack)** ì„ êµ¬í˜„í•œ ì˜ˆì œì´ë‹¤. ì¼ë°˜ì ì¸ ìŠ¤íƒì€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼í•  ë•Œ **ë°ì´í„° ê²½í•©(race condition)** ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ `mutex`ë‚˜ `critical section`ê³¼ ê°™ì€ **ë½(lock)**ì„ ì‚¬ìš©í•œë‹¤. ê·¸ëŸ¬ë‚˜ ë½ì€ ì„±ëŠ¥ ì €í•˜ë¥¼ ì¼ìœ¼í‚¤ê±°ë‚˜ ë°ë“œë½(deadlock) ìœ„í—˜ì„ ìœ ë°œí•  ìˆ˜ ìˆë‹¤.
ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ **CAS(Compare-And-Swap)** ì—°ì‚°ì„ ì´ìš©í•œ **ë¬´ì ê¸ˆ(lock-free)** ë°©ì‹ì´ ì‚¬ìš©ëœë‹¤.
ì´ êµ¬í˜„ì€ `InterlockedCompareExchangePointer` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì›ìì ìœ¼ë¡œ(head í¬ì¸í„° ë³€ê²½ì„) ìˆ˜í–‰í•¨ìœ¼ë¡œì¨ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼í•˜ë”ë¼ë„ ìŠ¤íƒì˜ ì¼ê´€ì„±ì„ ìœ ì§€í•˜ë„ë¡ í•œë‹¤.

#### í´ë˜ìŠ¤ êµ¬ì¡°

```cpp
template<typename T>
class LockFreeStack {
private:
    struct Node {
        T data;
        Node* next;
        
        Node(const T& item) : data(item), next(nullptr) {}
    };
    
    Node* head = nullptr;
```

* `LockFreeStack`ì€ í…œí”Œë¦¿ í´ë˜ìŠ¤ë¡œ, ì–´ë–¤ íƒ€ì…ì˜ ë°ì´í„°ë“  ìŠ¤íƒ í˜•íƒœë¡œ ì €ì¥í•  ìˆ˜ ìˆë‹¤.
* ë‚´ë¶€ êµ¬ì¡°ì²´ `Node`ëŠ” ìŠ¤íƒì˜ í•œ ìš”ì†Œë¥¼ í‘œí˜„í•˜ë©°, `data`ì™€ `ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°(next)`ë¥¼ ê°€ì§„ë‹¤.
* `head`ëŠ” ìŠ¤íƒì˜ ë§¨ ìœ„(top)ë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë‹¤.

ì¦‰, `head`ê°€ `nullptr`ì´ë©´ ìŠ¤íƒì´ ë¹„ì–´ ìˆëŠ” ìƒíƒœë‹¤.

#### ì†Œë©¸ì(Destructor)

```cpp
~LockFreeStack() {
    while (Node* node = head) {
        head = node->next;
        delete node;
    }
}
```

ì†Œë©¸ìëŠ” ìŠ¤íƒì´ íŒŒê´´ë  ë•Œ ëª¨ë“  ë…¸ë“œë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‚­ì œí•œë‹¤.
`while` ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ì—¬ `head`ê°€ ê°€ë¦¬í‚¤ëŠ” ë…¸ë“œë¥¼ í•˜ë‚˜ì”© ì‚­ì œí•˜ê³  `next`ë¡œ ì´ë™í•œë‹¤.
ì´ ë¶€ë¶„ì€ ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œ í˜¸ì¶œëœë‹¤ëŠ” ê°€ì • í•˜ì— ì‘ì„±ë˜ì—ˆìœ¼ë©°, ë™ì‹œ ì ‘ê·¼ì„ ê³ ë ¤í•˜ì§€ ì•ŠëŠ”ë‹¤.


#### push í•¨ìˆ˜

```cpp
void push(const T& item) {
    Node* newNode = new Node(item);
    
    do {
        newNode->next = head;
    } while (InterlockedCompareExchangePointer(
        reinterpret_cast<PVOID*>(&head),
        newNode,
        newNode->next) != newNode->next);
}
```

* ìƒˆ ë…¸ë“œë¥¼ ìƒì„±í•œ ë’¤, ë°˜ë³µë¬¸(`do-while`) ë‚´ì—ì„œ ì›ìì  ë¹„êµ-êµí™˜(CAS) ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.
* `InterlockedCompareExchangePointer`ëŠ” **headê°€ ì˜ˆìƒí•œ ê°’(newNode->next)**ì¼ ê²½ìš°ì—ë§Œ **headë¥¼ ìƒˆë¡œìš´ ë…¸ë“œ(newNode)**ë¡œ êµì²´í•œë‹¤.
* ë§Œì•½ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ê°™ì€ ì‹œì ì— `head`ë¥¼ ë³€ê²½í–ˆë‹¤ë©´ êµí™˜ì— ì‹¤íŒ¨í•˜ê³ , ë‹¤ì‹œ ì‹œë„í•œë‹¤.

ì¦‰, ì´ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

1. ìƒˆ ë…¸ë“œì˜ `next`ë¥¼ í˜„ì¬ì˜ `head`ë¡œ ì„¤ì •í•œë‹¤.
2. `head`ë¥¼ ìƒˆ ë…¸ë“œë¡œ êµì²´í•˜ë ¤ ì‹œë„í•œë‹¤.
3. ì‹¤íŒ¨ ì‹œ(`head`ê°€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì— ì˜í•´ ë³€ê²½ëœ ê²½ìš°) ë‹¤ì‹œ ì‹œë„í•œë‹¤.

ì´ ê³¼ì •ì„ í†µí•´ ë½ ì—†ì´ ì•ˆì „í•˜ê²Œ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ë°ì´í„°ë¥¼ pushí•  ìˆ˜ ìˆë‹¤.


#### pop í•¨ìˆ˜

```cpp
bool pop(T& result) {
    Node* oldHead;
    
    do {
        oldHead = head;
        if (oldHead == nullptr) {
            return false;  // ìŠ¤íƒì´ ë¹„ì–´ìˆìŒ
        }
    } while (InterlockedCompareExchangePointer(
        reinterpret_cast<PVOID*>(&head),
        oldHead->next,
        oldHead) != oldHead);
    
    result = oldHead->data;
    delete oldHead;
    return true;
}
```

* `pop` í•¨ìˆ˜ëŠ” ìŠ¤íƒì˜ ë§¨ ìœ„ ìš”ì†Œë¥¼ ì œê±°í•˜ê³  ê·¸ ê°’ì„ `result`ì— ë°˜í™˜í•œë‹¤.
* ë¨¼ì € `oldHead`ì— í˜„ì¬ `head`ë¥¼ ì €ì¥í•œë‹¤.
* ìŠ¤íƒì´ ë¹„ì–´ ìˆë‹¤ë©´(`nullptr`) ì¦‰ì‹œ `false`ë¥¼ ë°˜í™˜í•œë‹¤.
* `InterlockedCompareExchangePointer`ë¥¼ ì´ìš©í•´ `head`ë¥¼ `oldHead->next`ë¡œ êµì²´í•˜ë ¤ ì‹œë„í•œë‹¤.

  * ì´ë•Œ `head`ê°€ ì—¬ì „íˆ `oldHead`ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆì–´ì•¼ ì„±ê³µí•œë‹¤.
  * ë§Œì•½ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ pop ë˜ëŠ” pushë¥¼ ìˆ˜í–‰í–ˆë‹¤ë©´ ì‹¤íŒ¨í•˜ê³  ë‹¤ì‹œ ì‹œë„í•œë‹¤.
* ì„±ê³µ ì‹œ `oldHead`ì˜ ë°ì´í„°ë¥¼ ë³µì‚¬í•˜ê³ , ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•œë‹¤.

ì´ ê³¼ì •ì„ í†µí•´ `pop` ë˜í•œ **ë½ ì—†ì´ ì›ìì ìœ¼ë¡œ** ì²˜ë¦¬ëœë‹¤.


#### empty í•¨ìˆ˜

```cpp
bool empty() const {
    return head == nullptr;
}
```

ìŠ¤íƒì´ ë¹„ì–´ ìˆëŠ”ì§€ë¥¼ ë‹¨ìˆœíˆ í™•ì¸í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.
`head`ê°€ `nullptr`ì´ë©´ `true`, ì•„ë‹ˆë©´ `false`ë¥¼ ë°˜í™˜í•œë‹¤.


#### ì •ë¦¬
ì´ ì½”ë“œëŠ” **ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ë†’ì€ ì„±ëŠ¥**ì„ ìœ ì§€í•˜ë©´ì„œ **ë°ì´í„° ì¼ê´€ì„±ì„ ë³´ì¥í•˜ëŠ” ìŠ¤íƒ êµ¬ì¡°**ë¥¼ êµ¬í˜„í•œ ì˜ˆì œì´ë‹¤.
í•µì‹¬ì€ `InterlockedCompareExchangePointer`ë¥¼ ì‚¬ìš©í•œ **ì›ìì  í¬ì¸í„° êµí™˜ ì—°ì‚°(CAS)**ì´ë‹¤.
ì´ë¥¼ í†µí•´ ë½ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ ë„ ë™ì‹œì— ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ì•ˆì „í•˜ê²Œ push/pop ì—°ì‚°ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

ë‹¨, ì´ êµ¬í˜„ì€ ë©”ëª¨ë¦¬ ì¬í™œìš© ë¬¸ì œ(hazard pointer, ABA ë¬¸ì œ ë“±)ë¥¼ ê³ ë ¤í•˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ì‹¤ì œ ìƒìš© í™˜ê²½ì—ì„œëŠ” ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ê´€ë¦¬ ê¸°ë²•ì´ í•„ìš”í•˜ë‹¤.



### 6.3.2 ë¬´ì ê¸ˆ í (Lock-Free Queue)

```cpp
template<typename T>
class LockFreeQueue {
private:
    struct Node {
        std::atomic<T*> data;
        std::atomic<Node*> next;
        
        Node() : data(nullptr), next(nullptr) {}
    };
    
    std::atomic<Node*> head;
    std::atomic<Node*> tail;
    
public:
    LockFreeQueue() {
        Node* dummy = new Node;
        head.store(dummy);
        tail.store(dummy);
    }
    
    ~LockFreeQueue() {
        Node* current = head.load();
        while (current != nullptr) {
            Node* next = current->next.load();
            delete current->data.load();
            delete current;
            current = next;
        }
    }
    
    void enqueue(const T& item) {
        Node* newNode = new Node;
        T* data = new T(item);
        newNode->data.store(data);
        
        while (true) {
            Node* last = tail.load();
            Node* next = last->next.load();
            
            if (last == tail.load()) {  // tailì´ ë³€ê²½ë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
                if (next == nullptr) {
                    // tailì´ ì •ë§ ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ê³  ìˆìŒ
                    if (last->next.compare_exchange_weak(next, newNode)) {
                        break;
                    }
                } else {
                    // tailì´ ë’¤ì²˜ì ¸ ìˆìŒ, ë„ì›€ì„ ì¤Œ
                    tail.compare_exchange_weak(last, next);
                }
            }
        }
        
        // tailì„ ìƒˆ ë…¸ë“œë¡œ ì´ë™
        tail.compare_exchange_weak(tail.load(), newNode);
    }
    
    bool dequeue(T& result) {
        while (true) {
            Node* first = head.load();
            Node* last = tail.load();
            Node* next = first->next.load();
            
            if (first == head.load()) {  // headê°€ ë³€ê²½ë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
                if (first == last) {
                    if (next == nullptr) {
                        return false;  // íê°€ ë¹„ì–´ìˆìŒ
                    }
                    // tailì´ ë’¤ì²˜ì ¸ ìˆìŒ, ë„ì›€ì„ ì¤Œ
                    tail.compare_exchange_weak(last, next);
                } else {
                    if (next == nullptr) {
                        continue;  // ì¼ê´€ì„±ì´ ê¹¨ì¡ŒìŒ, ì¬ì‹œë„
                    }
                    
                    // ë°ì´í„° ì½ê¸°
                    T* data = next->data.load();
                    if (data == nullptr) {
                        continue;  // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ì²˜ë¦¬í•¨
                    }
                    
                    // head ì´ë™ ì‹œë„
                    if (head.compare_exchange_weak(first, next)) {
                        result = *data;
                        delete data;
                        delete first;
                        return true;
                    }
                }
            }
        }
    }
    
    bool empty() const {
        Node* first = head.load();
        Node* last = tail.load();
        return (first == last) && (first->next.load() == nullptr);
    }
};
```  
  
ì´ë²ˆì—ëŠ” **ë¬´ì ê¸ˆ í(Lock-Free Queue)**ì— ëŒ€í•´ ì‚´í´ë³¸ë‹¤.
ì´ ìë£Œêµ¬ì¡°ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— íì— ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°í•  ë•Œë„ **ë½(lock)**ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì•ˆì „í•˜ê²Œ ë™ì‘í•˜ë„ë¡ ì„¤ê³„ëœ íë‹¤.

ë½ì„ ì‚¬ìš©í•˜ëŠ” ì „í†µì ì¸ íëŠ” `mutex` ë“±ì„ ì´ìš©í•´ ì„ê³„êµ¬ì—­ì„ ë³´í˜¸í•˜ì§€ë§Œ, ê·¸ë¡œ ì¸í•´ **ì„±ëŠ¥ ì €í•˜**, **êµì°©ìƒíƒœ(deadlock)**, **ìš°ì„ ìˆœìœ„ ì—­ì „(priority inversion)** ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ **ì›ìì (atomic)** ì—°ì‚°ê³¼ **CAS(Compare-And-Swap)**ì„ ì´ìš©í•´ íì˜ ìƒíƒœë¥¼ ë™ê¸°í™”í•˜ëŠ” ë¬´ì ê¸ˆ ë°©ì‹ì´ ì‚¬ìš©ëœë‹¤.

ì´ êµ¬í˜„ì€ **Michael & Scott (1996)** ì˜ ê³ ì „ì ì¸ **Lock-Free Queue ì•Œê³ ë¦¬ì¦˜**ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, C++ì˜ `std::atomic`ì„ ì‚¬ìš©í•˜ì—¬ í¬ì¸í„°ì™€ ë°ì´í„°ë¥¼ ì›ìì ìœ¼ë¡œ ì¡°ì‘í•œë‹¤.


#### ì „ì²´ êµ¬ì¡° ìš”ì•½
íëŠ” **ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ì˜ êµ¬ì¡°**ë¡œ ë˜ì–´ ìˆìœ¼ë©°, í•­ìƒ ì¡´ì¬í•˜ëŠ” **ë”ë¯¸(dummy) ë…¸ë“œ**ë¥¼ ë‘ì–´ headì™€ tailì´ ê°€ë¦¬í‚¤ëŠ” ìœ„ì¹˜ë¥¼ ëª…í™•íˆ ìœ ì§€í•œë‹¤.

```plaintext
[Head] â†’ [Dummy] â†’ [Node1] â†’ [Node2] â†’ ... â†’ [Tail]
```

* **head**: dequeue(ì‚­ì œ) ì—°ì‚°ì˜ ì‹œì‘ì ì´ë‹¤.
* **tail**: enqueue(ì‚½ì…) ì—°ì‚°ì˜ ëì„ ê°€ë¦¬í‚¨ë‹¤.
* **dummy ë…¸ë“œ**: ë¹„ì–´ìˆëŠ” íì—ì„œë„ headì™€ tailì´ ë™ì¼í•œ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë„ë¡ ìœ ì§€í•˜ëŠ” ì—­í• ì„ í•œë‹¤.

ë‹¤ìŒì€ íì˜ ëŒ€ëµì ì¸ ê°œë… êµ¬ì¡°ë¥¼ í‘œí˜„í•œ ì•„ìŠ¤í‚¤ ë‹¤ì´ì–´ê·¸ë¨ì´ë‹¤.

```
ì´ˆê¸° ìƒíƒœ (ë¹„ì–´ìˆëŠ” í)
 â”Œâ”€â”€â”€â”€â”€â”€â”
 â”‚ head â”‚â”€â”€â”€â”€â”€â”€â”
 â””â”€â”€â”€â”€â”€â”€â”˜      â”‚
                â–¼
           [ dummy ]
                â–²
 â”Œâ”€â”€â”€â”€â”€â”€â”      â”‚
 â”‚ tail â”‚â”€â”€â”€â”€â”€â”€â”˜
 â””â”€â”€â”€â”€â”€â”€â”˜
```

#### ë…¸ë“œ ì •ì˜ ë° ë©¤ë²„ ë³€ìˆ˜

```cpp
struct Node {
    std::atomic<T*> data;
    std::atomic<Node*> next;

    Node() : data(nullptr), next(nullptr) {}
};

std::atomic<Node*> head;
std::atomic<Node*> tail;
```

* `Node`ëŠ” ê° í ìš”ì†Œë¥¼ ë‹´ëŠ” êµ¬ì¡°ì²´ì´ë‹¤.

  * `data`: ë…¸ë“œê°€ ì €ì¥í•˜ëŠ” ë°ì´í„°(í¬ì¸í„° í˜•íƒœ).
  * `next`: ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ì´ë‹¤.

* `head`ì™€ `tail`ì€ ëª¨ë‘ `std::atomic<Node*>`ë¡œ ì„ ì–¸ë˜ì–´ ì›ìì ìœ¼ë¡œ ì ‘ê·¼ëœë‹¤.

ì¦‰, ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— headë‚˜ tailì„ ìˆ˜ì •í•˜ë”ë¼ë„ ì•ˆì „í•˜ê²Œ ë™ì‘í•œë‹¤.

#### ìƒì„±ìì™€ ì†Œë©¸ì

```cpp
LockFreeQueue() {
    Node* dummy = new Node;
    head.store(dummy);
    tail.store(dummy);
}
```

* íëŠ” ì‹œì‘ ì‹œ ë”ë¯¸ ë…¸ë“œë¥¼ í•˜ë‚˜ ìƒì„±í•œë‹¤.
* `head`ì™€ `tail`ì´ ë™ì¼í•œ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë¯€ë¡œ, íê°€ ë¹„ì–´ ìˆìŒì„ ë‚˜íƒ€ë‚¸ë‹¤.

```cpp
~LockFreeQueue() {
    Node* current = head.load();
    while (current != nullptr) {
        Node* next = current->next.load();
        delete current->data.load();
        delete current;
        current = next;
    }
}
```

* íê°€ ì†Œë©¸ë  ë•Œ ëª¨ë“  ë…¸ë“œë¥¼ ìˆœì°¨ì ìœ¼ë¡œ í•´ì œí•œë‹¤.
* ë°ì´í„°ì™€ ë…¸ë“œë¥¼ í•˜ë‚˜ì”© ì‚­ì œí•˜ë©° ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•œë‹¤.

#### enqueue í•¨ìˆ˜ (ë°ì´í„° ì¶”ê°€)

```cpp
void enqueue(const T& item) {
    Node* newNode = new Node;
    T* data = new T(item);
    newNode->data.store(data);
    
    while (true) {
        Node* last = tail.load();
        Node* next = last->next.load();
        
        if (last == tail.load()) {  // tailì´ ë³€í•˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
            if (next == nullptr) {
                if (last->next.compare_exchange_weak(next, newNode)) {
                    break;
                }
            } else {
                tail.compare_exchange_weak(last, next);
            }
        }
    }
    
    tail.compare_exchange_weak(tail.load(), newNode);
}
```

**ì‘ë™ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.**

1. ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ë§Œë“ ë‹¤ (`newNode`).
2. í˜„ì¬ tailì´ ê°€ë¦¬í‚¤ëŠ” ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ì½ì–´ì˜¨ë‹¤ (`last`).
3. ë§Œì•½ `last->next`ê°€ `nullptr`ì´ë¼ë©´, `last`ê°€ ì‹¤ì œ ë§ˆì§€ë§‰ ë…¸ë“œì„ì„ ì˜ë¯¸í•œë‹¤.

   * ì´ë•Œ `compare_exchange_weak`ë¥¼ ì‚¬ìš©í•´ `last->next`ë¥¼ `newNode`ë¡œ ë°”ê¾¸ë ¤ ì‹œë„í•œë‹¤.
   * ì„±ê³µí•˜ë©´ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ì—°ê²°í•˜ê³  ë£¨í”„ë¥¼ íƒˆì¶œí•œë‹¤.
4. ë§Œì•½ `last->next`ê°€ ì¡´ì¬í•œë‹¤ë©´, tailì´ ë’¤ì²˜ì ¸ ìˆëŠ” ìƒíƒœì´ë¯€ë¡œ `tail`ì„ ì•ìœ¼ë¡œ ì´ë™ì‹œì¼œ ë„ì™€ì¤€ë‹¤.

ë§ˆì§€ë§‰ì— `tail`ì„ ìƒˆ ë…¸ë“œë¡œ ì´ë™ì‹œì¼œ ìµœì‹  ìƒíƒœë¡œ ìœ ì§€í•œë‹¤.

ì•„ë˜ëŠ” enqueue ê³¼ì •ì˜ íë¦„ì„ ë¨¸ë©”ì´ë“œ ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ í‘œí˜„í•œ ê²ƒì´ë‹¤.

```mermaid
flowchart TD
A["í˜„ì¬ tail(last) ì½ê¸°"] --> B{"last->next == nullptr?"}
B -- ì˜ˆ --> C["CASë¡œ nextë¥¼ newNodeë¡œ ì—°ê²° ì‹œë„"]
C -->|ì„±ê³µ| D["ë£¨í”„ íƒˆì¶œ"]
C -->|ì‹¤íŒ¨| A
B -- ì•„ë‹ˆì˜¤ --> E["tailì„ nextë¡œ ì´ë™"]
E --> A
```

#### dequeue í•¨ìˆ˜ (ë°ì´í„° ì œê±°)

```cpp
bool dequeue(T& result) {
    while (true) {
        Node* first = head.load();
        Node* last = tail.load();
        Node* next = first->next.load();
        
        if (first == head.load()) {
            if (first == last) {
                if (next == nullptr) {
                    return false;  // íê°€ ë¹„ì–´ìˆìŒ
                }
                tail.compare_exchange_weak(last, next);
            } else {
                if (next == nullptr) continue;
                
                T* data = next->data.load();
                if (data == nullptr) continue;
                
                if (head.compare_exchange_weak(first, next)) {
                    result = *data;
                    delete data;
                    delete first;
                    return true;
                }
            }
        }
    }
}
```

**ì‘ë™ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.**

1. `head`, `tail`, `first->next`ë¥¼ ì½ì–´ì˜¨ë‹¤.
2. `first == last`ì´ê³  `next == nullptr`ì´ë©´ íê°€ ë¹„ì–´ìˆëŠ” ìƒíƒœì´ë‹¤.
3. `tail`ì´ ë’¤ì²˜ì ¸ ìˆìœ¼ë©´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¥¼ ë•ê¸° ìœ„í•´ ì•ìœ¼ë¡œ ì´ë™ì‹œí‚¨ë‹¤.
4. `next` ë…¸ë“œì˜ ë°ì´í„°ë¥¼ ì½ëŠ”ë‹¤.
5. `head`ë¥¼ `next`ë¡œ ë³€ê²½í•˜ëŠ” CAS ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.

   * ì„±ê³µí•˜ë©´ ë°ì´í„°ë¥¼ ë°˜í™˜í•˜ê³  ì´ì „ `first` ë…¸ë“œë¥¼ ì‚­ì œí•œë‹¤.

ì•„ë˜ëŠ” dequeueì˜ ë™ì‘ ê³¼ì •ì„ ê°„ë‹¨íˆ í‘œí˜„í•œ ë¨¸ë©”ì´ë“œ ë‹¤ì´ì–´ê·¸ë¨ì´ë‹¤.

```mermaid
flowchart TD
A[head, tail, next ì½ê¸°] --> B{first == last?}
B -- ì˜ˆ --> C{next == nullptr?}
C -- ì˜ˆ --> D[íê°€ ë¹„ì–´ ìˆìŒ â†’ false ë°˜í™˜]
C -- ì•„ë‹ˆì˜¤ --> E[tailì„ nextë¡œ ì´ë™]
E --> A
B -- ì•„ë‹ˆì˜¤ --> F{next == nullptr?}
F -- ì˜ˆ --> A
F -- ì•„ë‹ˆì˜¤ --> G[headë¥¼ nextë¡œ CAS ì‹œë„]
G -->|ì„±ê³µ| H[data ë°˜í™˜ ë° first ì‚­ì œ]
G -->|ì‹¤íŒ¨| A
```

#### empty í•¨ìˆ˜

```cpp
bool empty() const {
    Node* first = head.load();
    Node* last = tail.load();
    return (first == last) && (first->next.load() == nullptr);
}
```

* headì™€ tailì´ ê°™ì€ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ê³ , ë‹¤ìŒ ë…¸ë“œê°€ ì—†ìœ¼ë©´ íê°€ ë¹„ì–´ ìˆë‹¤ê³  íŒë‹¨í•œë‹¤.

#### ì •ë¦¬
ì´ `LockFreeQueue`ëŠ” **ë™ì‹œì„±(concurrency)**ì´ ë†’ì€ í™˜ê²½ì—ì„œ ë›°ì–´ë‚œ ì„±ëŠ¥ì„ ë°œíœ˜í•˜ëŠ” í êµ¬ì¡°ë‹¤.
CAS ì—°ì‚°ì„ í†µí•´ ë½ì„ ì™„ì „íˆ ì œê±°í•˜ë©´ì„œë„ ë°ì´í„°ì˜ ì¼ê´€ì„±ì„ ë³´ì¥í•œë‹¤.

í•µì‹¬ í¬ì¸íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

1. **dummy ë…¸ë“œ**ë¥¼ ì‚¬ìš©í•˜ì—¬ headì™€ tailì˜ ì¼ê´€ì„±ì„ ìœ ì§€í•œë‹¤.
2. `enqueue`ì™€ `dequeue` ëª¨ë‘ **compare_exchange_weak**ë¥¼ ì‚¬ìš©í•´ ê²½ìŸ ìƒí™©ì„ ì²˜ë¦¬í•œë‹¤.
3. **tail ë³´ì •(tail catching up)** ë©”ì»¤ë‹ˆì¦˜ìœ¼ë¡œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ ì§„í–‰ì„ ë•ëŠ”ë‹¤.

ë‹¨, ì´ ì½”ë“œ ì—­ì‹œ **ABA ë¬¸ì œ**ë‚˜ **ë©”ëª¨ë¦¬ ì¬í™œìš©(hazard pointer)**ì— ëŒ€í•œ ì²˜ë¦¬ê°€ ë˜ì–´ ìˆì§€ ì•Šê¸° ë•Œë¬¸ì—
ì‹¤ì œ ìƒìš© í™˜ê²½ì—ì„œëŠ” ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ì•ˆì „ì¥ì¹˜ê°€ í•„ìš”í•˜ë‹¤.


  
### 6.3.3 ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

```cpp
#include <chrono>
#include <queue>
#include <mutex>

// ì „í†µì ì¸ ì ê¸ˆ ê¸°ë°˜ í
template<typename T>
class LockedQueue {
private:
    std::queue<T> queue_;
    std::mutex mutex_;
    
public:
    void enqueue(const T& item) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(item);
    }
    
    bool dequeue(T& result) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) {
            return false;
        }
        result = queue_.front();
        queue_.pop();
        return true;
    }
    
    bool empty() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }
};

void performanceTest() {
    const int OPERATIONS = 1000000;
    const int THREAD_COUNT = 4;
    
    // ë¬´ì ê¸ˆ í í…ŒìŠ¤íŠ¸
    {
        LockFreeQueue<int> lockFreeQueue;
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<std::thread> threads;
        
        // Producer ìŠ¤ë ˆë“œë“¤
        for (int t = 0; t < THREAD_COUNT / 2; ++t) {
            threads.emplace_back([&lockFreeQueue, OPERATIONS]() {
                for (int i = 0; i < OPERATIONS; ++i) {
                    lockFreeQueue.enqueue(i);
                }
            });
        }
        
        // Consumer ìŠ¤ë ˆë“œë“¤
        for (int t = 0; t < THREAD_COUNT / 2; ++t) {
            threads.emplace_back([&lockFreeQueue, OPERATIONS]() {
                int value;
                int consumed = 0;
                while (consumed < OPERATIONS) {
                    if (lockFreeQueue.dequeue(value)) {
                        consumed++;
                    } else {
                        std::this_thread::yield();
                    }
                }
            });
        }
        
        for (auto& t : threads) {
            t.join();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << "ë¬´ì ê¸ˆ í: " << duration.count() << "ms\n";
    }
    
    // ì ê¸ˆ ê¸°ë°˜ í í…ŒìŠ¤íŠ¸
    {
        LockedQueue<int> lockedQueue;
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<std::thread> threads;
        
        // Producer ìŠ¤ë ˆë“œë“¤
        for (int t = 0; t < THREAD_COUNT / 2; ++t) {
            threads.emplace_back([&lockedQueue, OPERATIONS]() {
                for (int i = 0; i < OPERATIONS; ++i) {
                    lockedQueue.enqueue(i);
                }
            });
        }
        
        // Consumer ìŠ¤ë ˆë“œë“¤
        for (int t = 0; t < THREAD_COUNT / 2; ++t) {
            threads.emplace_back([&lockedQueue, OPERATIONS]() {
                int value;
                int consumed = 0;
                while (consumed < OPERATIONS) {
                    if (lockedQueue.dequeue(value)) {
                        consumed++;
                    } else {
                        std::this_thread::yield();
                    }
                }
            });
        }
        
        for (auto& t : threads) {
            t.join();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << "ì ê¸ˆ ê¸°ë°˜ í: " << duration.count() << "ms\n";
    }
}
```
  

</br>    

## 6.4 ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´ì™€ ìºì‹œ ì¼ê´€ì„±

### 6.4.1 ë©”ëª¨ë¦¬ ìˆœì„œ ë¬¸ì œ

```cpp
// ìœ„í—˜í•œ ì½”ë“œ ì˜ˆì‹œ
class DangerousFlag {
private:
    bool ready = false;
    int data = 0;
    
public:
    // Writer ìŠ¤ë ˆë“œ
    void setData(int value) {
        data = value;      // 1. ë°ì´í„° ì„¤ì •
        ready = true;      // 2. í”Œë˜ê·¸ ì„¤ì •
    }
    
    // Reader ìŠ¤ë ˆë“œ
    int getData() {
        if (ready) {       // 3. í”Œë˜ê·¸ í™•ì¸
            return data;   // 4. ë°ì´í„° ì½ê¸°
        }
        return -1;
    }
};
```

CPUëŠ” ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ëª…ë ¹ì–´ ìˆœì„œë¥¼ ì¬ë°°ì—´í•  ìˆ˜ ìˆë‹¤. ì´ë¡œ ì¸í•´ `ready = true`ê°€ `data = value`ë³´ë‹¤ ë¨¼ì € ì‹¤í–‰ë  ìˆ˜ ìˆì–´, Readerê°€ ì˜ëª»ëœ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìˆë‹¤.

```
ë©”ëª¨ë¦¬ ì¬ë°°ì—´ì˜ ìœ„í—˜ì„±:

ì˜ˆìƒí•œ ìˆœì„œ:        ì‹¤ì œ ì‹¤í–‰ ìˆœì„œ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ data = valueâ”‚    â”‚ ready = trueâ”‚  â† ì¬ë°°ì—´ë¨!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ready = trueâ”‚    â”‚ data = valueâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Readerê°€ ready=trueë¥¼ í™•ì¸í–ˆì§€ë§Œ
dataëŠ” ì•„ì§ ì„¤ì •ë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŒ!
```

### 6.4.2 ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´ ì‚¬ìš©í•˜ê¸°

```cpp
class SafeFlag {
private:
    volatile bool ready = false;
    volatile int data = 0;
    
public:
    // Writer ìŠ¤ë ˆë“œ
    void setData(int value) {
        data = value;
        
        // ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´: ì´ì „ ëª¨ë“  ì“°ê¸°ê°€ ì™„ë£Œëœ í›„ ë‹¤ìŒ ì“°ê¸° ì‹¤í–‰
        MemoryBarrier();
        
        ready = true;
    }
    
    // Reader ìŠ¤ë ˆë“œ
    int getData() {
        if (ready) {
            // ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´: ready ì½ê¸° ì´í›„ì— data ì½ê¸° ì‹¤í–‰
            MemoryBarrier();
            return data;
        }
        return -1;
    }
};

// ë” ë‚˜ì€ ë°©ë²•: InterlockedXXX í•¨ìˆ˜ ì‚¬ìš©
class BetterFlag {
private:
    LONG ready = 0;
    LONG data = 0;
    
public:
    void setData(int value) {
        InterlockedExchange(&data, value);
        InterlockedExchange(&ready, 1);  // ìë™ìœ¼ë¡œ ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´ íš¨ê³¼
    }
    
    int getData() {
        if (InterlockedCompareExchange(&ready, 0, 0) == 1) {
            return InterlockedCompareExchange(&data, 0, 0);
        }
        return -1;
    }
};
```

### 6.4.3 ìºì‹œ ë¼ì¸ ìµœì í™”

```cpp
// ì˜ëª»ëœ ì˜ˆì‹œ: False Sharing ë°œìƒ
struct BadCounters {
    LONG counter1;  // ê°™ì€ ìºì‹œ ë¼ì¸ì— ìœ„ì¹˜
    LONG counter2;  // ê°™ì€ ìºì‹œ ë¼ì¸ì— ìœ„ì¹˜
};

// ì˜¬ë°”ë¥¸ ì˜ˆì‹œ: ìºì‹œ ë¼ì¸ ì •ë ¬
struct alignas(64) GoodCounters {  // 64ë°”ì´íŠ¸ ì •ë ¬ (ì¼ë°˜ì ì¸ ìºì‹œ ë¼ì¸ í¬ê¸°)
    LONG counter1;
    char padding1[60];  // íŒ¨ë”©ìœ¼ë¡œ ë‹¤ë¥¸ ìºì‹œ ë¼ì¸ì— ë°°ì¹˜
    
    LONG counter2;
    char padding2[60];
};

// C++17 ì´í›„ ë” ê°„ë‹¨í•œ ë°©ë²•
struct ModernCounters {
    alignas(std::hardware_destructive_interference_size) LONG counter1;
    alignas(std::hardware_destructive_interference_size) LONG counter2;
};

void demonstrateFalseSharing() {
    const int ITERATIONS = 10000000;
    
    // False Sharing í…ŒìŠ¤íŠ¸
    {
        BadCounters badCounters = {0, 0};
        auto start = std::chrono::high_resolution_clock::now();
        
        std::thread t1([&]() {
            for (int i = 0; i < ITERATIONS; ++i) {
                InterlockedIncrement(&badCounters.counter1);
            }
        });
        
        std::thread t2([&]() {
            for (int i = 0; i < ITERATIONS; ++i) {
                InterlockedIncrement(&badCounters.counter2);
            }
        });
        
        t1.join();
        t2.join();
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "False Sharing: " << duration.count() << "ms\n";
    }
    
    // ìºì‹œ ë¼ì¸ ìµœì í™” í…ŒìŠ¤íŠ¸
    {
        GoodCounters goodCounters = {0};
        auto start = std::chrono::high_resolution_clock::now();
        
        std::thread t1([&]() {
            for (int i = 0; i < ITERATIONS; ++i) {
                InterlockedIncrement(&goodCounters.counter1);
            }
        });
        
        std::thread t2([&]() {
            for (int i = 0; i < ITERATIONS; ++i) {
                InterlockedIncrement(&goodCounters.counter2);
            }
        });
        
        t1.join();
        t2.join();
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "ìºì‹œ ë¼ì¸ ìµœì í™”: " << duration.count() << "ms\n";
    }
}
```
  
ì´ ì½”ë“œëŠ” â€œFalse Sharing(ê±°ì§“ ê³µìœ )â€ë¡œ ì¸í•œ ì„±ëŠ¥ í•˜ë½ì„ ì¬í˜„í•˜ê³ , ìºì‹œ ë¼ì¸ ì •ë ¬ë¡œ ì´ë¥¼ ì œê±°í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì£¼ëŠ” ì˜ˆì œë‹¤. ì•„ë˜ì—ì„œ ì™œ ëŠë ¤ì§€ëŠ”ì§€, ì–´ë–¤ ì •ë ¬ì´ í•„ìš”í•œì§€, ì½”ë“œê°€ ì‹¤ì œë¡œ ë¬´ì—‡ì„ ë³´ì¥í•˜ëŠ”ì§€, ì‹¤ë¬´ì—ì„œì˜ ì£¼ì˜ì ì„ ìˆœì„œëŒ€ë¡œ ì„¤ëª…í•œë‹¤.

#### ë¬´ì—‡ì´ ëŠë ¤ì§€ëŠ”ê°€: False Sharing ê°œë…
ì„œë¡œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ â€œê°ì ë‹¤ë¥¸ ë³€ìˆ˜â€ë¥¼ ì—…ë°ì´íŠ¸í•˜ë”ë¼ë„, ê·¸ ë³€ìˆ˜ë“¤ì´ **ê°™ì€ ìºì‹œ ë¼ì¸**ì— ìˆìœ¼ë©´ ìºì‹œ ì¼ê´€ì„± í”„ë¡œí† ì½œ(MESI ë“±) ë•Œë¬¸ì— ê·¸ ë¼ì¸ì„ ì„œë¡œ ëºê³  ë¹¼ì•—ê¸°ëŠ” **ìºì‹œ ë¼ì¸ í•‘í**ì´ ë°œìƒí•œë‹¤. ê·¸ ê²°ê³¼ ë©”ëª¨ë¦¬ ëŒ€ì—­í­ê³¼ ì½”ì–´ ê°„ ì—°ê²°ì´ ë‚­ë¹„ë˜ì–´ ì„±ëŠ¥ì´ ê¸‰ê²©íˆ ë–¨ì–´ì§„ë‹¤.

ê°„ë‹¨ ASCII ë„ì‹ì´ë‹¤.

```
ì½”ì–´0                                  ì½”ì–´1
 â””â”€ counter1 ì¦ê°€ (line X ì†Œìœ )          â””â”€ counter2 ì¦ê°€ë¥¼ ì‹œë„
      â”‚                                        â”‚
      â”œâ”€ line X: Modified                      â”œâ”€ line Xë¥¼ Read/Modify ìœ„í•´ ìš”ì²­
      â””â”€ ì“°ê¸° ì™„ë£Œ ì‹œì ì—                       â””â”€ ì½”ì–´0ì˜ line Xê°€ Invalidate
         ì½”ì–´1ì˜ line Xë¥¼ Invalidate               (ì†Œìœ ê¶Œ ì´ë™)
```

ë‘ ë³€ìˆ˜ë¥¼ ê°™ì€ ë¼ì¸ì— ì˜¬ë ¤ë‘” ê²ƒì´ ì›ì¸ì´ë‹¤.


#### ì½”ë“œë¡œ ë³´ëŠ” ì¬í˜„ê³¼ í•´ê²°

ì˜ëª»ëœ ì˜ˆì‹œ: ê°™ì€ ë¼ì¸ì— ë°°ì¹˜ë˜ëŠ” ë‘ ì¹´ìš´í„°

```cpp
struct BadCounters {
    LONG counter1;  // ê°™ì€ ìºì‹œ ë¼ì¸
    LONG counter2;  // ê°™ì€ ìºì‹œ ë¼ì¸
};
```

ë‘ ìŠ¤ë ˆë“œê°€ ê°ê° `counter1`, `counter2`ë§Œ `InterlockedIncrement`ë¡œ ì˜¬ë ¤ë„, ë‘ í•„ë“œëŠ” ë³´í†µ 64ë°”ì´íŠ¸ ìºì‹œ ë¼ì¸ í•˜ë‚˜ì— í•¨ê»˜ ë†“ì´ë¯€ë¡œ ì§€ì†ì  invalidationì´ ë°œìƒí•œë‹¤. ì´ë•Œ `InterlockedIncrement`ëŠ” ì›ìì  ì¦ê°€ë¥¼ ë³´ì¥í•˜ì§€ë§Œ, **ìºì‹œ ë¼ì¸ ì†Œìœ ê¶Œ ê²½ìŸ**ê¹Œì§€ í•´ê²°í•´ì£¼ì§€ëŠ” ì•ŠëŠ”ë‹¤.
  

ì˜¬ë°”ë¥¸ ì˜ˆì‹œ: ìºì‹œ ë¼ì¸ ì •ë ¬ + íŒ¨ë”©ìœ¼ë¡œ ë¬¼ë¦¬ì  ë¶„ë¦¬

```cpp
struct alignas(64) GoodCounters {
    LONG counter1;
    char padding1[60];  // 4 + 60 = 64B (ì²« ë¼ì¸ ì±„ì›€)

    LONG counter2;
    char padding2[60];  // 64B (ë‘˜ì§¸ ë¼ì¸ ì±„ì›€)
};
```

í•µì‹¬ì€ ë‘ ê°€ì§€ë‹¤.

1. `struct alignas(64)`ë¡œ **êµ¬ì¡°ì²´ ì‹œì‘ ì£¼ì†Œë¥¼ 64ë°”ì´íŠ¸ ê²½ê³„**ì— ë§ì¶˜ë‹¤.
2. `counter1` ë’¤ë¥¼ 64ë°”ì´íŠ¸ê¹Œì§€ **íŒ¨ë”©ìœ¼ë¡œ ê½‰ ì±„ì›Œ** `counter2`ê°€ ì •í™•íˆ ë‹¤ìŒ ìºì‹œ ë¼ì¸ ì‹œì‘ì— ì˜¤ê²Œ í•œë‹¤.

ì´ë ‡ê²Œ í•˜ë©´ ë‘ ìŠ¤ë ˆë“œê°€ ì„œë¡œ ë‹¤ë¥¸ ë¼ì¸ì„ ì†Œìœ í•´ ê°±ì‹ í•˜ë¯€ë¡œ invalidation í•‘íì´ ì‚¬ë¼ì§„ë‹¤.
    
  
ë” í˜„ëŒ€ì ì¸ ë°©ë²•: êµ¬í˜„ ì œê³µ ìƒìˆ˜ ì‚¬ìš©

```cpp
struct ModernCounters {
    alignas(std::hardware_destructive_interference_size) LONG counter1;
    alignas(std::hardware_destructive_interference_size) LONG counter2;
};
```

* C++17ë¶€í„° `<new>`ì— `std::hardware_destructive_interference_size`ê°€ ì •ì˜ë˜ë©°, êµ¬í˜„ì´ ì•„ëŠ” **íŒŒê´´ì  ê°„ì„­ í¬ê¸°(ë³´í†µ ìºì‹œ ë¼ì¸ í¬ê¸°)** ë¡œ ì •ë ¬ì„ ë§ì¶˜ë‹¤.
* ë‹¨, êµ¬í˜„/í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ë”°ë¼ ê°’ì´ 0ì¼ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ, **ì‹¤ë¬´ì—ì„œëŠ” 64 ë°”ì´íŠ¸ë¥¼ í•©ë¦¬ì  ê¸°ë³¸ê°’ìœ¼ë¡œ ë‘ê³ , ê°’ì´ 0ì´ë©´ 64ë¡œ ëŒ€ì²´**í•˜ëŠ” ë°©ì‹ì„ ìì£¼ ì“´ë‹¤.


#### ì‹œë‚˜ë¦¬ì˜¤ íë¦„

```mermaid
sequenceDiagram
  participant C0 as Core 0
  participant C1 as Core 1
  participant L as Cache Line (counter1,counter2)

  C0->>L: counter1 ì¦ê°€ (ì·¨ë“/ìˆ˜ì •)
  Note right of C0: L ìƒíƒœ M(Modified), C1 ì‚¬ë³¸ I(Invalid)
  C1->>L: counter2 ì¦ê°€ ì‹œë„ (ì·¨ë“/ìˆ˜ì • ìš”ì²­)
  Note right of C1: ì†Œìœ ê¶Œì´ C1ë¡œ ì´ë™, C0 ì‚¬ë³¸ I(Invalid)
  C0->>L: ë‹¤ìŒ ì¦ê°€ ì‹œë„ ì‹œ ë‹¤ì‹œ ì·¨ë“
  Note over C0,C1: ê°™ì€ ë¼ì¸ì„ ë‘ ì½”ì–´ê°€ ë²ˆê°ˆì•„ ì†Œìœ <br/>â†’ í•‘í â†’ ì§€ì—° ì¦ê°€
```

GoodCounters/ModernCountersì—ì„œëŠ” `counter1`ê³¼ `counter2`ê°€ **ì„œë¡œ ë‹¤ë¥¸ ë¼ì¸**ì´ë¼ ìœ„ í•‘íì´ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.


#### `demonstrateFalseSharing()` ë™ì‘ ì„¤ëª…

```cpp
const int ITERATIONS = 10000000;
```

* ê° ìŠ¤ë ˆë“œê°€ 1ì²œë§Œ ë²ˆ ì¦ê°€ë¥¼ ìˆ˜í–‰í•œë‹¤.
  

êµ¬ê°„ 1: BadCounters í…ŒìŠ¤íŠ¸

* ë‘ ìŠ¤ë ˆë“œê°€ ê°™ì€ ë¼ì¸ìƒì˜ ì„œë¡œ ë‹¤ë¥¸ í•„ë“œë¥¼ ì¦ê°€í•œë‹¤.
* `InterlockedIncrement`ëŠ” Windowsì˜ ì›ìì  ì¦ê°€ APIë¡œ, ë‚´ë¶€ì ìœ¼ë¡œ ê°•í•œ ë©”ëª¨ë¦¬ ì¥ë²½ê³¼ ìºì‹œ ë¼ì¸ ì ê¸ˆì„ ìˆ˜ë°˜í•œë‹¤.
* ì—¬ê¸°ì— **ë¼ì¸ ê²½ìŸê¹Œì§€ ê²¹ì¹˜ë¯€ë¡œ** ì¸¡ì • ì‹œê°„ì´ í¬ê²Œ ë‚˜ì˜¨ë‹¤.
* ì¶œë ¥: `False Sharing: XXXms`
  

êµ¬ê°„ 2: GoodCounters í…ŒìŠ¤íŠ¸

* ê°™ì€ íŒ¨í„´ì´ì§€ë§Œ ê° í•„ë“œê°€ **ì„œë¡œ ë‹¤ë¥¸ ìºì‹œ ë¼ì¸**ì— ì¡´ì¬í•œë‹¤.
* ì¼ê´€ì„± í”„ë¡œí† ì½œì— ì˜í•œ í•‘íì´ ì—†ì–´ì ¸ ì‹œê°„ì´ ëˆˆì— ë„ê²Œ ì¤„ì–´ë“ ë‹¤.
* ì¶œë ¥: `ìºì‹œ ë¼ì¸ ìµœì í™”: YYYms`

> ì‹¤ì œ ìˆ˜ì¹˜ëŠ” CPU/ì½”ì–´ ìˆ˜, ì£¼íŒŒìˆ˜ ìŠ¤ì¼€ì¼ë§, ìŠ¤ì¼€ì¤„ëŸ¬, ì „ì› ì •ì±…ì— ë”°ë¼ ë‹¬ë¼ì§„ë‹¤. ì •í™•í•œ ë¹„êµë¥¼ ì›í•˜ë©´ ì½”ì–´ ê³ ì •(ìŠ¤ë ˆë“œ ì–´í”¼ë‹ˆí‹°), ê³ ì • ì„±ëŠ¥ ëª¨ë“œ, ì›Œë°ì—… ë“±ì„ ê¶Œì¥í•œë‹¤.


#### ì‹¤ë¬´ì—ì„œì˜ ì£¼ì˜Â·íŒ

1. **ì •ë ¬ë§Œìœ¼ë¡œëŠ” ë¶€ì¡±í•  ìˆ˜ ìˆë‹¤**
   êµ¬ì¡°ì²´ì— `alignas(64)`ë¥¼ ë¶™ì´ì§€ ì•Šê³  ë‚´ë¶€ì— íŒ¨ë”©ë§Œ ë‘ë©´, **êµ¬ì¡°ì²´ ì‹œì‘ ì£¼ì†Œê°€ 64ë°”ì´íŠ¸ ê²½ê³„ê°€ ì•„ë‹ ìˆ˜ë„** ìˆì–´ `counter2`ê°€ ë¼ì¸ ê²½ê³„ë¥¼ ì •í™•íˆ ë§ì¶”ì§€ ëª»í•  ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ **êµ¬ì¡°ì²´ ìì²´ë¥¼ 64B ì •ë ¬**í•´ì•¼ í•œë‹¤.

2. **ë°°ì—´/ì»¨í…Œì´ë„ˆì— ë‹´ì„ ë•Œ**
   `std::vector<GoodCounters>`ì²˜ëŸ¼ **íƒ€ì… ìì²´ê°€ 64B ì •ë ¬**ì´ë©´ ê° ì›ì†Œê°€ 64B ë°°ìˆ˜ ì£¼ì†Œì— ë†“ì¸ë‹¤. ë°˜ëŒ€ë¡œ `std::vector<LONG>`ì— `alignas(64)`ë¥¼ ë³€ìˆ˜ì—ë§Œ ë¶™ì´ë©´, ë°°ì—´ ìš”ì†Œ ì‚¬ì´ ê°„ê²©ì´ ì´˜ì´˜í•´ ë‹¤ì‹œ ê°™ì€ ë¼ì¸ì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆë‹¤. **íƒ€ì…ì— ì •ë ¬ì„ ë¶€ì—¬**í•˜ë¼.

   ```cpp
   struct alignas(64) PaddedCounter { std::atomic<long> v{0}; char pad[64 - sizeof(std::atomic<long>)]; };
   std::vector<PaddedCounter> counters(N); // ê° ì›ì†Œê°€ ì„œë¡œ ë‹¤ë¥¸ ë¼ì¸ì— ë†“ì„
   ```

3. **ì›ìì„± ì„ íƒ**
   ì˜ˆì œëŠ” `InterlockedIncrement`ë¥¼ ì“°ì§€ë§Œ, C++ í‘œì¤€ ì›ì íƒ€ì…ìœ¼ë¡œë„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

   ```cpp
   std::atomic<long> c1{0}, c2{0};
   c1.fetch_add(1, std::memory_order_relaxed);
   ```

   ë‹¨, ì‹¤í—˜ì˜ í¬ì¸íŠ¸ê°€ **ë¼ì¸ ê²½ìŸ**ì´ë¯€ë¡œ ë©”ëª¨ë¦¬ ì˜¤ë”ëŠ” `relaxed`ë¡œ ì¶©ë¶„í•˜ë‹¤. ë¶ˆí•„ìš”í•œ ì¥ë²½ì€ ì¸¡ì •ì— ì¡ìŒì„ ì¤€ë‹¤.

4. **ë¼ì¸ í¬ê¸° ê°€ì •**
   ëŒ€ë¶€ë¶„ì˜ x86-64 CPUëŠ” 64ë°”ì´íŠ¸ ìºì‹œ ë¼ì¸ì„ ì“´ë‹¤. ì¼ë¶€ ì•„í‚¤í…ì²˜/ë¯¸ë˜ CPUì—ì„œ ê°’ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ê°€ëŠ¥í•˜ë©´ `std::hardware_destructive_interference_size`ë¥¼ ì“°ê³ , ê°’ì´ 0ì´ë©´ 64ë¥¼ ì‚¬ìš©í•˜ëŠ” **í´ë°±**ì„ ë‘”ë‹¤.

5. **ì»´íŒŒì¼ëŸ¬ ìµœì í™”**
   ìµœì í™”ê°€ ë£¨í”„ë¥¼ ê³¼ë„í•˜ê²Œ ë°”ê¾¸ì§€ ì•Šë„ë¡ ì‹¤ì œ ì‹¤í–‰ ì‚¬ì´ë“œì´í™íŠ¸(ì›ì ì¦ê°€, `volatile` ë“±)ê°€ í•„ìš”í•˜ë‹¤. ì˜ˆì œëŠ” ì›ìì  APIë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ë¬¸ì œê°€ ì—†ë‹¤.

6. **ì¸¡ì • ë…¸ì´ì¦ˆ ì¤„ì´ê¸°**

   * ìŠ¤ë ˆë“œ ì–´í”¼ë‹ˆí‹°ë¥¼ ì„œë¡œ ë‹¤ë¥¸ ë¬¼ë¦¬ ì½”ì–´ë¡œ ê³ ì •í•œë‹¤.
   * ê³ ì • ì„±ëŠ¥ ëª¨ë“œ(ê³ ì„±ëŠ¥ ì „ì› ê³„íš)ë¡œ ì„¤ì •í•œë‹¤.
   * ì›Œë°ì—… ë£¨í”„ë¥¼ ë‘¬ì„œ í„°ë³´/ì˜¨ë„ ì˜í–¥ ì´ˆê¸°í™”ë¥¼ í•œë‹¤.

#### ìš”ì•½
* **ë¬¸ì œ**: ì„œë¡œ ë‹¤ë¥¸ ë³€ìˆ˜ê°€ ê°™ì€ ìºì‹œ ë¼ì¸ì— ìˆìœ¼ë©´, ë‘ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê°±ì‹ í•  ë•Œ **False Sharing**ìœ¼ë¡œ ìºì‹œ ë¼ì¸ í•‘íì´ ë°œìƒí•´ ëŠë ¤ì§„ë‹¤.
* **í•´ê²°**: ë‘ ë³€ìˆ˜ë¥¼ **ì„œë¡œ ë‹¤ë¥¸ ìºì‹œ ë¼ì¸**ì— ê°•ì œ ë°°ì¹˜í•œë‹¤. `alignas(64)`ë¡œ êµ¬ì¡°ì²´ ì‹œì‘ ì£¼ì†Œë¥¼ ì •ë ¬í•˜ê³ , **íŒ¨ë”©ìœ¼ë¡œ ê° í•„ë“œê°€ ì •í™•íˆ 64ë°”ì´íŠ¸ ê²½ê³„**ì— ì˜¤ê²Œ í•˜ê±°ë‚˜, `std::hardware_destructive_interference_size`ë¥¼ í™œìš©í•œë‹¤.
* **ì‹¤ë¬´ íŒ**: íƒ€ì… ìˆ˜ì¤€ ì •ë ¬, ì»¨í…Œì´ë„ˆ ì‚¬ìš© ì‹œ ì •ë ¬ ìœ ì§€, ë¶ˆí•„ìš”í•œ ë©”ëª¨ë¦¬ ì¥ë²½ ì œê±°, ë¼ì¸ í¬ê¸°ì˜ í´ë°± ì²˜ë¦¬ ë“±ì„ ì§€í‚¤ë©´ ëœë‹¤.

ì´ëŒ€ë¡œ ì ìš©í•˜ë©´ ë™ì¼í•œ ì¦ê°€ ì‘ì—…ì´ë¼ë„ **ì¸¡ì • ì‹œê°„ì´ ìœ ì˜ë¯¸í•˜ê²Œ ê°ì†Œ**í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.
  

</br>    

## 6.5 ABA ë¬¸ì œ í•´ê²° ë°©ë²•

### 6.5.1 ABA ë¬¸ì œë€?
ABA ë¬¸ì œëŠ” ë¬´ì ê¸ˆ í”„ë¡œê·¸ë˜ë°ì—ì„œ ë°œìƒí•˜ëŠ” ê³ ì „ì ì¸ ë¬¸ì œë‹¤:

```
ì´ˆê¸° ìƒíƒœ: A
Thread 1ì´ Aë¥¼ ì½ìŒ
Thread 2ê°€ Aë¥¼ Bë¡œ ë³€ê²½
Thread 2ê°€ ë‹¤ì‹œ Bë¥¼ Aë¡œ ë³€ê²½
Thread 1ì´ Compare-And-Swap ìˆ˜í–‰ â†’ ì„±ê³µ! (í•˜ì§€ë§Œ ì¤‘ê°„ì— ë³€ê²½ì´ ìˆì—ˆìŒ)
```

```cpp
// ABA ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì½”ë“œ
template<typename T>
class ProblematicStack {
private:
    struct Node {
        T data;
        Node* next;
    };
    
    Node* head = nullptr;
    
public:
    bool pop(T& result) {
        Node* oldHead = head;
        if (oldHead == nullptr) return false;
        
        // ì—¬ê¸°ì„œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ê°œì…í•  ìˆ˜ ìˆìŒ!
        // head â†’ A â†’ B â†’ C
        // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ A, Bë¥¼ ì œê±°í•˜ê³  ìƒˆë¡œìš´ Aë¥¼ ì‚½ì…
        // head â†’ A(new) â†’ D â†’ E
        
        Node* newHead = oldHead->next;
        
        // oldHeadê°€ ì—¬ì „íˆ Aë¥¼ ê°€ë¦¬í‚¤ë¯€ë¡œ CASê°€ ì„±ê³µí•˜ì§€ë§Œ
        // ì‹¤ì œë¡œëŠ” ì™„ì „íˆ ë‹¤ë¥¸ Aì„!
        if (InterlockedCompareExchangePointer(
            reinterpret_cast<PVOID*>(&head), newHead, oldHead) == oldHead) {
            result = oldHead->data;
            delete oldHead;  // ì´ë¯¸ ì‚­ì œëœ ë©”ëª¨ë¦¬ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŒ!
            return true;
        }
        return false;
    }
};
```

### 7.5.2 í•´ê²° ë°©ë²• 1: ë²„ì „ íƒœê·¸ ì‚¬ìš©

```cpp
template<typename T>
class VersionedStack {
private:
    struct Node {
        T data;
        Node* next;
        
        Node(const T& item) : data(item), next(nullptr) {}
    };
    
    struct TaggedPointer {
        Node* ptr;
        LONG tag;
        
        TaggedPointer() : ptr(nullptr), tag(0) {}
        TaggedPointer(Node* p, LONG t) : ptr(p), tag(t) {}
    };
    
    alignas(8) TaggedPointer head;  // 8ë°”ì´íŠ¸ ì •ë ¬ ë³´ì¥
    
public:
    void push(const T& item) {
        Node* newNode = new Node(item);
        TaggedPointer oldHead, newHead;
        
        do {
            oldHead = head;
            newNode->next = oldHead.ptr;
            newHead.ptr = newNode;
            newHead.tag = oldHead.tag + 1;  // ë²„ì „ ì¦ê°€
        } while (InterlockedCompareExchange64(
            reinterpret_cast<LONG64*>(&head),
            *reinterpret_cast<LONG64*>(&newHead),
            *reinterpret_cast<LONG64*>(&oldHead)) != 
            *reinterpret_cast<LONG64*>(&oldHead));
    }
    
    bool pop(T& result) {
        TaggedPointer oldHead, newHead;
        
        do {
            oldHead = head;
            if (oldHead.ptr == nullptr) {
                return false;
            }
            
            newHead.ptr = oldHead.ptr->next;
            newHead.tag = oldHead.tag + 1;  // ë²„ì „ ì¦ê°€
            
        } while (InterlockedCompareExchange64(
            reinterpret_cast<LONG64*>(&head),
            *reinterpret_cast<LONG64*>(&newHead),
            *reinterpret_cast<LONG64*>(&oldHead)) != 
            *reinterpret_cast<LONG64*>(&oldHead));
        
        result = oldHead.ptr->data;
        delete oldHead.ptr;
        return true;
    }
};
```
  
**ë¬´ì ê¸ˆ ìŠ¤íƒ(lock-free stack)**ì—ì„œ ë°œìƒí•˜ëŠ” **ABA ë¬¸ì œ(ABA Problem)**ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë°©ë²• ì¤‘ í•˜ë‚˜ì¸ **ë²„ì „ íƒœê·¸(Version Tag)**ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•œë‹¤.

#### ğŸ§© êµ¬ì¡° ê°œìš”
ì´ ìŠ¤íƒì€ ê° í¬ì¸í„°ì— **ë²„ì „ ë²ˆí˜¸(tag)**ë¥¼ ë¶™ì—¬ì„œ ê´€ë¦¬í•œë‹¤.
ì¦‰, headëŠ” ë‹¨ìˆœí•œ í¬ì¸í„°ê°€ ì•„ë‹ˆë¼ `(í¬ì¸í„° + ë²„ì „)` ìŒìœ¼ë¡œ ë™ì‘í•œë‹¤.
ì´ë¥¼ í†µí•´ ë™ì¼í•œ í¬ì¸í„° ê°’ì´ë¼ë„ ë²„ì „ì´ ë‹¤ë¥´ë©´ â€œë‹¤ë¥¸ ìƒíƒœâ€ë¡œ ì¸ì‹í•  ìˆ˜ ìˆê²Œ ëœë‹¤.

ì•„ë˜ëŠ” ì´ êµ¬ì¡°ë¥¼ ë‹¨ìˆœí™”í•œ ê°œë…ë„ì´ë‹¤.

```
head â”€â”€â”€â–¶ (ptr = NodeA, tag = 5)
             â†“
            NodeA â†’ NodeB â†’ ...
```

í¬ì¸í„°ê°€ ê°™ë”ë¼ë„ tag ê°’ì´ ë°”ë€Œë©´ ì´ì „ ìƒíƒœì™€ ë‹¤ë¥¸ ê²ƒìœ¼ë¡œ ê°„ì£¼í•œë‹¤.


#### ì½”ë“œ êµ¬ì¡° ë¶„ì„

##### 1ï¸âƒ£ Node êµ¬ì¡°ì²´

```cpp
struct Node {
    T data;
    Node* next;
    
    Node(const T& item) : data(item), next(nullptr) {}
};
```

* ìŠ¤íƒì˜ ê° ìš”ì†Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë…¸ë“œë‹¤.
* `data`ëŠ” ì‹¤ì œ ì €ì¥ ë°ì´í„°ì´ë©°, `next`ëŠ” ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¨ë‹¤.


##### 2ï¸âƒ£ TaggedPointer êµ¬ì¡°ì²´

```cpp
struct TaggedPointer {
    Node* ptr;
    LONG tag;
    
    TaggedPointer() : ptr(nullptr), tag(0) {}
    TaggedPointer(Node* p, LONG t) : ptr(p), tag(t) {}
};
```

* ì´ êµ¬ì¡°ì²´ëŠ” í¬ì¸í„°(`ptr`)ì™€ ë²„ì „ ë²ˆí˜¸(`tag`)ë¥¼ í•¨ê»˜ ê´€ë¦¬í•œë‹¤.
* ì¦‰, **í¬ì¸í„°ì˜ ìƒíƒœë¥¼ ë²„ì „ê¹Œì§€ í¬í•¨í•´ ì›ìì ìœ¼ë¡œ ë¹„êµ**í•  ìˆ˜ ìˆë‹¤.
* `tag`ëŠ” ë§¤ë²ˆ pushë‚˜ popì´ ë°œìƒí•  ë•Œë§ˆë‹¤ +1 ì¦ê°€í•œë‹¤.


##### 3ï¸âƒ£ ë©¤ë²„ ë³€ìˆ˜

```cpp
alignas(8) TaggedPointer head;
```

* `head`ëŠ” ìŠ¤íƒì˜ ë§¨ ìœ„ë¥¼ ê°€ë¦¬í‚¨ë‹¤.
* `alignas(8)`ì„ ì‚¬ìš©í•˜ì—¬ 8ë°”ì´íŠ¸ ì •ë ¬ì„ ë³´ì¥í•œë‹¤.
  ì´ëŠ” 64ë¹„íŠ¸ ì›ì ì—°ì‚°(`InterlockedCompareExchange64`)ì´ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•˜ë„ë¡ í•˜ê¸° ìœ„í•¨ì´ë‹¤.


#### ğŸ§± push í•¨ìˆ˜

```cpp
void push(const T& item) {
    Node* newNode = new Node(item);
    TaggedPointer oldHead, newHead;
    
    do {
        oldHead = head;
        newNode->next = oldHead.ptr;
        newHead.ptr = newNode;
        newHead.tag = oldHead.tag + 1;  // ë²„ì „ ì¦ê°€
    } while (InterlockedCompareExchange64(
        reinterpret_cast<LONG64*>(&head),
        *reinterpret_cast<LONG64*>(&newHead),
        *reinterpret_cast<LONG64*>(&oldHead)) != 
        *reinterpret_cast<LONG64*>(&oldHead));
}
```

**ë™ì‘ ê³¼ì •:**

1. ìƒˆ ë…¸ë“œë¥¼ ë§Œë“ ë‹¤.
2. í˜„ì¬ `head`ë¥¼ ì½ê³ , ìƒˆ ë…¸ë“œì˜ `next`ë¥¼ ê¸°ì¡´ headë¡œ ì—°ê²°í•œë‹¤.
3. `tag`ë¥¼ +1 ì¦ê°€ì‹œì¼œ ìƒˆë¡œìš´ ë²„ì „ì„ ë§Œë“ ë‹¤.
4. CASë¥¼ ì´ìš©í•´ `head`ë¥¼ `(newNode, newTag)`ë¡œ êµì²´í•˜ë ¤ ì‹œë„í•œë‹¤.

   * ì‹¤íŒ¨ ì‹œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ê°œì…í•œ ê²ƒì´ë¯€ë¡œ ë‹¤ì‹œ ì‹œë„í•œë‹¤.
   * ì„±ê³µ ì‹œ ìƒˆë¡œìš´ headê°€ ì„¤ì •ëœë‹¤.

ì•„ë˜ëŠ” push ë™ì‘ì˜ íë¦„ì„ ë‹¨ìˆœí™”í•œ ë‹¤ì´ì–´ê·¸ë¨ì´ë‹¤.

```mermaid
flowchart TD
A[í˜„ì¬ head ì½ê¸°] --> B[ìƒˆ ë…¸ë“œ ìƒì„± ë° next ì—°ê²°]
B --> C[tag = oldTag + 1]
C --> D[CASë¡œ head êµì²´ ì‹œë„]
D -->|ì„±ê³µ| E[push ì™„ë£Œ]
D -->|ì‹¤íŒ¨| A[ì¬ì‹œë„]
```

#### ğŸ§± pop í•¨ìˆ˜

```cpp
bool pop(T& result) {
    TaggedPointer oldHead, newHead;
    
    do {
        oldHead = head;
        if (oldHead.ptr == nullptr) {
            return false;
        }
        
        newHead.ptr = oldHead.ptr->next;
        newHead.tag = oldHead.tag + 1;  // ë²„ì „ ì¦ê°€
        
    } while (InterlockedCompareExchange64(
        reinterpret_cast<LONG64*>(&head),
        *reinterpret_cast<LONG64*>(&newHead),
        *reinterpret_cast<LONG64*>(&oldHead)) != 
        *reinterpret_cast<LONG64*>(&oldHead));
    
    result = oldHead.ptr->data;
    delete oldHead.ptr;
    return true;
}
```

**ë™ì‘ ê³¼ì •:**

1. í˜„ì¬ headë¥¼ ì½ëŠ”ë‹¤.
2. ë¹„ì–´ ìˆë‹¤ë©´ false ë°˜í™˜.
3. `next` ë…¸ë“œë¥¼ ìƒˆë¡œìš´ headë¡œ ì„¤ì •í•œë‹¤.
4. `tag`ë¥¼ +1 ì¦ê°€ì‹œì¼œ ë²„ì „ì„ ë³€ê²½í•œë‹¤.
5. CASë¥¼ í†µí•´ headë¥¼ `(newPtr, newTag)`ë¡œ êµì²´í•œë‹¤.
6. ì„±ê³µí•˜ë©´ ì´ì „ ë…¸ë“œë¥¼ ì‚­ì œí•˜ê³  ë°ì´í„°ë¥¼ ë°˜í™˜í•œë‹¤.

ì´ ê³¼ì •ì„ í†µí•´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ headë¥¼ ì ê¹ ë³€ê²½í–ˆë‹¤ ë‹¤ì‹œ ë˜ëŒë¦¬ë”ë¼ë„,
**ë²„ì „ì´ ë‹¬ë¼ì§€ë¯€ë¡œ ABA ë¬¸ì œë¥¼ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.**

#### âš™ï¸ ë™ì‘ ì˜ˆì‹œ (ASCII ê·¸ë¦¼)

```
ì´ˆê¸° ìƒíƒœ:
 head â†’ (ptr=A, tag=5)
 A â†’ B â†’ C

ìŠ¤ë ˆë“œ 1ì´ pop ìˆ˜í–‰ ì¤‘:
 oldHead = (A,5)
 newHead = (B,6)

CAS ì„±ê³µ â†’ head = (B,6)
```

ë§Œì•½ ê·¸ ì‚¬ì´ì— ìŠ¤ë ˆë“œ 2ê°€ Aë¥¼ popí–ˆë‹¤ê°€ ë‹¤ì‹œ pushí•´ì„œ Aì˜ ì£¼ì†Œê°€ ì¬ì‚¬ìš©ë˜ë”ë¼ë„,
ì´ì œ headì˜ tag ê°’ì€ 6ì´ë¯€ë¡œ `(A,5)`ì™€ëŠ” ë‹¤ë¥´ë‹¤ê³  ì¸ì‹ëœë‹¤.
ë”°ë¼ì„œ CAS ë¹„êµì—ì„œ ì‹¤íŒ¨í•˜ê²Œ ë˜ì–´ ABA ë¬¸ì œë¥¼ ì˜ˆë°©í•  ìˆ˜ ìˆë‹¤.

#### âœ… ì •ë¦¬
ì´ `VersionedStack`ì˜ í•µì‹¬ì€ **í¬ì¸í„°ì˜ ë²„ì „ì„ í•¨ê»˜ ê´€ë¦¬**í•˜ëŠ” ê²ƒì´ë‹¤.
ì´ë¡œì¨ ë™ì¼í•œ í¬ì¸í„°ê°€ ì¬ì‚¬ìš©ë˜ë”ë¼ë„ ë‹¤ë¥¸ ìƒíƒœë¡œ ì¸ì‹í•  ìˆ˜ ìˆê²Œ ë˜ì–´
ë¬´ì ê¸ˆ êµ¬ì¡°ì˜ ê°€ì¥ í° ì·¨ì•½ì  ì¤‘ í•˜ë‚˜ì¸ **ABA ë¬¸ì œ**ë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ì°¨ë‹¨í•  ìˆ˜ ìˆë‹¤.

**ìš”ì•½í•˜ìë©´:**

| ê°œë…                               | ì„¤ëª…                          |
| -------------------------------- | --------------------------- |
| **TaggedPointer**                | í¬ì¸í„°ì™€ ë²„ì „ ë²ˆí˜¸ë¥¼ ë¬¶ì€ êµ¬ì¡°ì²´          |
| **tag ì¦ê°€**                       | ë§¤ ì—°ì‚°ë§ˆë‹¤ ë²„ì „ì„ 1 ì¦ê°€ì‹œì¼œ ìƒíƒœ ë³€í™” ì¶”ì   |
| **InterlockedCompareExchange64** | í¬ì¸í„° + ë²„ì „ì„ ë™ì‹œì— ë¹„êµí•˜ëŠ” 64ë¹„íŠ¸ CAS |
| **íš¨ê³¼**                           | ABA ë¬¸ì œ ë°©ì§€, ë¬´ì ê¸ˆ ìŠ¤íƒì˜ ì•ˆì •ì„± í–¥ìƒ   |

ì´ ë°©ì‹ì€ ë¹„êµì  ë‹¨ìˆœí•˜ë©´ì„œë„ íš¨ìœ¨ì ì´ë©°, ì‹¤ë¬´ì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” ê³ ì „ì ì¸ ABA í•´ê²° ë°©ë²• ì¤‘ í•˜ë‚˜ë‹¤.
    
  
### 7.5.3 í•´ê²° ë°©ë²• 2: Hazard Pointer

```cpp
template<typename T>
class HazardPointerStack {
private:
    struct Node {
        T data;
        std::atomic<Node*> next;
        
        Node(const T& item) : data(item), next(nullptr) {}
    };
    
    std::atomic<Node*> head{nullptr};
    
    // Hazard Pointer ì‹œìŠ¤í…œ (ê°„ë‹¨í™”ëœ ë²„ì „)
    thread_local static Node* hazardPtr;
    static std::atomic<std::vector<Node*>*> toDelete;
    
    void retireNode(Node* node) {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ë³µì¡í•œ ì§€ì—° ì‚­ì œ ë©”ì»¤ë‹ˆì¦˜ í•„ìš”
        static thread_local std::vector<Node*> retired;
        retired.push_back(node);
        
        if (retired.size() > 10) {  // ì„ê³„ê°’ ë„ë‹¬ì‹œ ì •ë¦¬
            cleanupRetired(retired);
        }
    }
    
    void cleanupRetired(std::vector<Node*>& retired) {
        // ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ hazard pointerì™€ ë¹„êµí•˜ì—¬ ì•ˆì „í•œ ë…¸ë“œë§Œ ì‚­ì œ
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì „ì—­ hazard pointer ëª©ë¡ê³¼ ë¹„êµ í•„ìš”
        for (auto* node : retired) {
            if (node != hazardPtr) {  // ë‹¨ìˆœí™”ëœ ê²€ì‚¬
                delete node;
            }
        }
        retired.clear();
    }
    
public:
    void push(const T& item) {
        Node* newNode = new Node(item);
        Node* oldHead = head.load();
        
        do {
            newNode->next = oldHead;
        } while (!head.compare_exchange_weak(oldHead, newNode));
    }
    
    bool pop(T& result) {
        Node* oldHead;
        
        do {
            oldHead = head.load();
            if (oldHead == nullptr) {
                return false;
            }
            
            // Hazard Pointer ì„¤ì •
            hazardPtr = oldHead;
            
            // ë‹¤ì‹œ í™•ì¸ (hazard pointer ì„¤ì • í›„ headê°€ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŒ)
            if (head.load() != oldHead) {
                continue;
            }
            
        } while (!head.compare_exchange_weak(oldHead, oldHead->next.load()));
        
        result = oldHead->data;
        hazardPtr = nullptr;  // Hazard Pointer í•´ì œ
        
        retireNode(oldHead);  // ì§€ì—° ì‚­ì œ
        return true;
    }
};

// thread_local ë³€ìˆ˜ ì •ì˜
template<typename T>
thread_local typename HazardPointerStack<T>::Node* HazardPointerStack<T>::hazardPtr = nullptr;

template<typename T>
std::atomic<std::vector<typename HazardPointerStack<T>::Node*>*> HazardPointerStack<T>::toDelete{nullptr};
```
   
**ë¬´ì ê¸ˆ ìŠ¤íƒ(lock-free stack)**ì—ì„œ ë°œìƒí•˜ëŠ” **ABA ë¬¸ì œì™€ ë©”ëª¨ë¦¬ í•´ì œ ì•ˆì „ì„± ë¬¸ì œ**ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë˜ ë‹¤ë¥¸ ë°©ë²•ì¸
**Hazard Pointer(í•´ì €ë“œ í¬ì¸í„°)** ê¸°ë²•ì„ ì„¤ëª…í•œë‹¤.

ì´ ë°©ë²•ì€ ë‹¨ìˆœíˆ í¬ì¸í„°ì˜ ë²„ì „ì„ ê´€ë¦¬í•˜ë˜ ì´ì „ ë°©ì‹(ë²„ì „ íƒœê·¸ ë°©ì‹)ë³´ë‹¤ í•œ ë‹¨ê³„ ë°œì „ëœ **ë©”ëª¨ë¦¬ ì•ˆì „ ê´€ë¦¬ ê¸°ë²•**ì´ë‹¤.
íŠ¹íˆ, ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ë…¸ë“œë¥¼ ì‚­ì œí•˜ê±°ë‚˜ ì ‘ê·¼í•˜ëŠ” ìƒí™©ì—ì„œ **ì‚­ì œëœ ë©”ëª¨ë¦¬ì— ì ‘ê·¼í•˜ëŠ” ë¬¸ì œ(dangling pointer)**ë¥¼ ì˜ˆë°©í•˜ê¸° ìœ„í•´ ì‚¬ìš©ëœë‹¤.


#### âš™ï¸ ì½”ë“œ ê°œìš”
ì´ `HazardPointerStack`ì€ ê¸°ë³¸ì ì¸ ë¬´ì ê¸ˆ ìŠ¤íƒ êµ¬ì¡°ì—
â€œí•´ì €ë“œ í¬ì¸í„°ë¥¼ ì´ìš©í•œ ì•ˆì „í•œ ì‚­ì œ ë©”ì»¤ë‹ˆì¦˜â€ì„ ì¶”ê°€í•œ í˜•íƒœì´ë‹¤.

ìŠ¤íƒì˜ ê¸°ë³¸ ì—°ì‚°(push, pop)ì€ ì—¬ì „íˆ **CAS(Compare-And-Swap)**ë¥¼ ì‚¬ìš©í•´ ë½ ì—†ì´ ìˆ˜í–‰ë˜ë©°,
ë‹¨ì§€ pop ì‹œ ë…¸ë“œê°€ ì‚­ì œë˜ê¸° ì „ì— â€œë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼ ì¤‘ì¸ì§€â€ë¥¼ í™•ì¸í•˜ëŠ” ì ˆì°¨ê°€ ì¶”ê°€ëœë‹¤.


#### ğŸ§± Node êµ¬ì¡°ì²´

```cpp
struct Node {
    T data;
    std::atomic<Node*> next;
    
    Node(const T& item) : data(item), next(nullptr) {}
};
```

ê° ë…¸ë“œëŠ” ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°(`next`)ë¥¼ ê°€ì§„ë‹¤.
`std::atomic`ìœ¼ë¡œ ì„ ì–¸ë˜ì–´ ìˆì–´ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼í•˜ë”ë¼ë„ ì•ˆì „í•˜ë‹¤.


#### ğŸ§© ì£¼ìš” ë©¤ë²„ ë³€ìˆ˜

```cpp
std::atomic<Node*> head{nullptr};

// Hazard Pointer ì‹œìŠ¤í…œ (ê°„ë‹¨í™”ëœ ë²„ì „)
thread_local static Node* hazardPtr;
static std::atomic<std::vector<Node*>*> toDelete;
```

* **`head`** : ìŠ¤íƒì˜ ë§¨ ìœ„ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¨ë‹¤.
* **`hazardPtr` (thread_local)** : ê° ìŠ¤ë ˆë“œë§ˆë‹¤ ë³„ë„ë¡œ ì¡´ì¬í•˜ëŠ” í¬ì¸í„°ë‹¤.

  * í˜„ì¬ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼ ì¤‘ì¸ ë…¸ë“œë¥¼ í‘œì‹œí•œë‹¤.
  * ì¦‰, "ì´ ë…¸ë“œëŠ” ë‚´ê°€ ë³´ê³  ìˆìœ¼ë‹ˆ ì‚­ì œí•˜ì§€ ë§ˆë¼"ë¼ëŠ” ëœ»ì´ë‹¤.
* **`toDelete`** : ì‚­ì œê°€ ë³´ë¥˜ëœ ë…¸ë“œë“¤ì„ ì„ì‹œë¡œ ì €ì¥í•´ë‘ëŠ” ë¦¬ìŠ¤íŠ¸ë‹¤.

ì´ êµ¬ì¡° ë•ë¶„ì— ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê°™ì€ ìŠ¤íƒì— ì ‘ê·¼í•˜ë”ë¼ë„,
ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼ ì¤‘ì¸ ë…¸ë“œë¥¼ í•¨ë¶€ë¡œ ì§€ìš°ì§€ ì•ŠëŠ”ë‹¤.


#### ğŸ§± push í•¨ìˆ˜

```cpp
void push(const T& item) {
    Node* newNode = new Node(item);
    Node* oldHead = head.load();
    
    do {
        newNode->next = oldHead;
    } while (!head.compare_exchange_weak(oldHead, newNode));
}
```

pushëŠ” ê¸°ë³¸ì ì¸ ë¬´ì ê¸ˆ ë°©ì‹ìœ¼ë¡œ ë™ì‘í•œë‹¤.

1. ìƒˆ ë…¸ë“œë¥¼ ë§Œë“ ë‹¤.
2. í˜„ì¬ headë¥¼ ì½ê³ , ìƒˆ ë…¸ë“œì˜ `next`ë¥¼ ê¸°ì¡´ headë¡œ ì—°ê²°í•œë‹¤.
3. `CAS(compare_exchange_weak)` ì—°ì‚°ì„ í†µí•´ headë¥¼ ìƒˆ ë…¸ë“œë¡œ êµì²´í•œë‹¤.
4. ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— pushë¥¼ ì‹œë„í•˜ë©´ ì‹¤íŒ¨í•˜ê³  ë‹¤ì‹œ ì‹œë„í•œë‹¤.

ASCII ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ í‘œí˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```
push ì „:  [newNode]       head â†’ [A] â†’ [B]
push í›„:  head â†’ [newNode] â†’ [A] â†’ [B]
```


#### ğŸ§± pop í•¨ìˆ˜
ì´ì œ í•µì‹¬ì¸ pop ë¶€ë¶„ì„ ì‚´í´ë³´ì.

```cpp
bool pop(T& result) {
    Node* oldHead;
    
    do {
        oldHead = head.load();
        if (oldHead == nullptr) {
            return false;
        }
        
        // Hazard Pointer ì„¤ì •
        hazardPtr = oldHead;
        
        // ë‹¤ì‹œ í™•ì¸ (hazard pointer ì„¤ì • í›„ headê°€ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŒ)
        if (head.load() != oldHead) {
            continue;
        }
        
    } while (!head.compare_exchange_weak(oldHead, oldHead->next.load()));
    
    result = oldHead->data;
    hazardPtr = nullptr;  // Hazard Pointer í•´ì œ
    
    retireNode(oldHead);  // ì§€ì—° ì‚­ì œ
    return true;
}
```

**ë™ì‘ ê³¼ì •**

1. `head`ë¥¼ ì½ê³ , popí•  ë…¸ë“œë¥¼ `oldHead`ì— ì €ì¥í•œë‹¤.
2. `hazardPtr`ì— `oldHead`ë¥¼ ì €ì¥í•œë‹¤. â†’ í˜„ì¬ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼ ì¤‘ì¸ ë…¸ë“œë¥¼ í‘œì‹œí•œë‹¤.
3. ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ `head`ë¥¼ ë°”ê¿¨ì„ ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë¯€ë¡œ ë‹¤ì‹œ í™•ì¸í•œë‹¤.
4. ë¬¸ì œê°€ ì—†ìœ¼ë©´ `CAS`ë¡œ headë¥¼ ë‹¤ìŒ ë…¸ë“œë¡œ ë³€ê²½í•œë‹¤.
5. ë°ì´í„° ë³µì‚¬ í›„ hazard pointerë¥¼ í•´ì œí•˜ê³ (`nullptr`), ë…¸ë“œë¥¼ ì‚­ì œ ì˜ˆì•½(retire)í•œë‹¤.


#### ğŸ§¹ retireNodeì™€ cleanupRetired
popëœ ë…¸ë“œë¥¼ ì¦‰ì‹œ ì‚­ì œí•˜ì§€ ì•Šê³ , ì„ì‹œë¡œ ë³´ê´€í•œë‹¤.
ì´ê²ƒì´ **ì§€ì—° ì‚­ì œ(deferred reclamation)**ì´ë‹¤.

```cpp
void retireNode(Node* node) {
    static thread_local std::vector<Node*> retired;
    retired.push_back(node);
    
    if (retired.size() > 10) {  // ì¼ì • ê°œìˆ˜ ìŒ“ì´ë©´ ì •ë¦¬
        cleanupRetired(retired);
    }
}
```

ì¼ì • ê°œìˆ˜ ì´ìƒ ìŒ“ì´ë©´ `cleanupRetired`ë¥¼ í˜¸ì¶œí•´ ì‹¤ì œ ì‚­ì œë¥¼ ì‹œë„í•œë‹¤.

```cpp
void cleanupRetired(std::vector<Node*>& retired) {
    for (auto* node : retired) {
        if (node != hazardPtr) {  // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì ‘ê·¼ ì¤‘ì´ë©´ ì‚­ì œ ê¸ˆì§€
            delete node;
        }
    }
    retired.clear();
}
```

ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ hazard pointerì™€ ë¹„êµí•˜ì—¬
ì•„ë¬´ë„ ì ‘ê·¼í•˜ì§€ ì•ŠëŠ” ë…¸ë“œë§Œ ì•ˆì „í•˜ê²Œ ì‚­ì œí•œë‹¤.


#### ğŸ§© Hazard Pointerì˜ ê°œë… ë‹¤ì´ì–´ê·¸ë¨

```mermaid
flowchart LR
A[Thread 1] -->|hazardPtr=A| H((Head))
B[Thread 2] -->|hazardPtr=B| N1((Node1))
H --> N1 --> N2 --> N3
```

* Thread 1ì€ í˜„ì¬ `Head` ë…¸ë“œë¥¼ ì½ëŠ” ì¤‘ì´ë¯€ë¡œ hazardPtr = `Head`
* Thread 2ëŠ” `Node1`ì„ ì½ëŠ” ì¤‘ì´ë¯€ë¡œ hazardPtr = `Node1`
* ì–´ë–¤ ìŠ¤ë ˆë“œê°€ `Node1`ì„ ì‚­ì œí•˜ë ¤ í•´ë„
  â€œThread 2ê°€ ì ‘ê·¼ ì¤‘ì´ë¯€ë¡œ ì‚­ì œ ê¸ˆì§€â€ íŒì •ì´ ë‚´ë ¤ì§„ë‹¤.


#### âš™ï¸ ì •ë¦¬

| í•­ëª©          | ì„¤ëª…                                               |
| ----------- | ------------------------------------------------ |
| **ëª©ì **      | ë¬´ì ê¸ˆ ìŠ¤íƒì—ì„œ ì•ˆì „í•˜ê²Œ ë©”ëª¨ë¦¬ë¥¼ ê´€ë¦¬í•˜ê¸° ìœ„í•¨                       |
| **í•µì‹¬ ì•„ì´ë””ì–´** | ìŠ¤ë ˆë“œë³„ hazard pointerë¥¼ í†µí•´ ì‚­ì œí•´ë„ ë˜ëŠ” ë…¸ë“œì™€ ì ‘ê·¼ ì¤‘ì¸ ë…¸ë“œë¥¼ êµ¬ë¶„ |
| **ì¥ì **      | ë©”ëª¨ë¦¬ í•´ì œ íƒ€ì´ë° ë¬¸ì œ í•´ê²°, ABA ë¬¸ì œ ì™„í™”                      |
| **ë‹¨ì **      | êµ¬í˜„ ë³µì¡ë„ ì¦ê°€, ë©”ëª¨ë¦¬ ì§€ì—° ì‚­ì œë¡œ ì¸í•œ ì˜¤ë²„í—¤ë“œ ë°œìƒ ê°€ëŠ¥              |


#### âœ… ê²°ë¡ 
Hazard PointerëŠ” **ë¬´ì ê¸ˆ ìë£Œêµ¬ì¡°ì˜ ì•ˆì „í•œ ë©”ëª¨ë¦¬ í•´ì œ**ë¥¼ ë³´ì¥í•˜ëŠ” ê°•ë ¥í•œ ê¸°ë²•ì´ë‹¤.
ì´ ë°©ì‹ ë•ë¶„ì— â€œë½ ì—†ì´ ë™ì‹œ ì ‘ê·¼ì€ ê°€ëŠ¥í•˜ì§€ë§Œ ë©”ëª¨ë¦¬ëŠ” ì•ˆì „í•˜ê²Œ ê´€ë¦¬â€í•  ìˆ˜ ìˆë‹¤.

ì¦‰, ì´ ì½”ë“œëŠ” ë‹¨ìˆœíˆ ë¹ ë¥¸ ìŠ¤íƒì´ ì•„ë‹ˆë¼,
**ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ popí•˜ê³  pushí•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„ëœ ê³ ê¸‰ ë³‘ë ¬ í”„ë¡œê·¸ë˜ë° ì˜ˆì œ**ë¼ê³  í•  ìˆ˜ ìˆë‹¤.
  
  
</br>  

## 6.6 ì‹¤ì œ ê²Œì„ ì„œë²„ì—ì„œì˜ í™œìš©

### 6.6.1 ê²Œì„ ì´ë²¤íŠ¸ í

```cpp
class GameEventQueue {
public:
    enum class EventType {
        PLAYER_MOVE,
        PLAYER_ATTACK,
        ITEM_PICKUP,
        CHAT_MESSAGE
    };
    
    struct GameEvent {
        EventType type;
        int playerId;
        std::string data;
        std::chrono::steady_clock::time_point timestamp;
        
        GameEvent(EventType t, int id, const std::string& d)
            : type(t), playerId(id), data(d), 
              timestamp(std::chrono::steady_clock::now()) {}
    };
    
private:
    LockFreeQueue<GameEvent> eventQueue;
    std::atomic<bool> running{true};
    
public:
    void pushEvent(EventType type, int playerId, const std::string& data) {
        eventQueue.enqueue(GameEvent(type, playerId, data));
    }
    
    void processEvents() {
        GameEvent event(EventType::PLAYER_MOVE, 0, "");
        
        while (running.load()) {
            if (eventQueue.dequeue(event)) {
                handleEvent(event);
            } else {
                std::this_thread::sleep_for(std::chrono::microseconds(100));
            }
        }
    }
    
    void stop() {
        running.store(false);
    }
    
private:
    void handleEvent(const GameEvent& event) {
        switch (event.type) {
            case EventType::PLAYER_MOVE:
                std::cout << "Player " << event.playerId 
                         << " moved to " << event.data << "\n";
                break;
                
            case EventType::PLAYER_ATTACK:
                std::cout << "Player " << event.playerId 
                         << " attacked " << event.data << "\n";
                break;
                
            case EventType::ITEM_PICKUP:
                std::cout << "Player " << event.playerId 
                         << " picked up " << event.data << "\n";
                break;
                
            case EventType::CHAT_MESSAGE:
                std::cout << "Player " << event.playerId 
                         << " says: " << event.data << "\n";
                break;
        }
    }
};
```

### 6.6.2 ê³ ì„±ëŠ¥ ì¹´ìš´í„°

```cpp
class GameStatistics {
private:
    alignas(64) LONG64 totalPlayers = 0;
    alignas(64) LONG64 totalMessages = 0;
    alignas(64) LONG64 totalBytesTransferred = 0;
    alignas(64) LONG64 errorsCount = 0;
    
public:
    void playerConnected() {
        InterlockedIncrement64(&totalPlayers);
    }
    
    void playerDisconnected() {
        InterlockedDecrement64(&totalPlayers);
    }
    
    void messageProcessed() {
        InterlockedIncrement64(&totalMessages);
    }
    
    void bytesTransferred(LONG64 bytes) {
        InterlockedExchangeAdd64(&totalBytesTransferred, bytes);
    }
    
    void errorOccurred() {
        InterlockedIncrement64(&errorsCount);
    }
    
    struct Statistics {
        LONG64 players;
        LONG64 messages;
        LONG64 bytes;
        LONG64 errors;
    };
    
    Statistics getStatistics() const {
        return {
            InterlockedCompareExchange64(&totalPlayers, 0, 0),
            InterlockedCompareExchange64(&totalMessages, 0, 0),
            InterlockedCompareExchange64(&totalBytesTransferred, 0, 0),
            InterlockedCompareExchange64(&errorsCount, 0, 0)
        };
    }
    
    void printStatistics() const {
        auto stats = getStatistics();
        std::cout << "=== ê²Œì„ ì„œë²„ í†µê³„ ===\n";
        std::cout << "ì ‘ì†ì ìˆ˜: " << stats.players << "\n";
        std::cout << "ì²˜ë¦¬ëœ ë©”ì‹œì§€: " << stats.messages << "\n";
        std::cout << "ì „ì†¡ëœ ë°”ì´íŠ¸: " << stats.bytes << "\n";
        std::cout << "ì˜¤ë¥˜ ìˆ˜: " << stats.errors << "\n";
    }
};
```

### 6.6.3 ì¢…í•© ì˜ˆì œ í”„ë¡œê·¸ë¨

```cpp
#include <Windows.h>
#include <iostream>
#include <thread>
#include <vector>
#include <random>
#include <chrono>

int main() {
    std::cout << "=== ê²Œì„ ì„œë²„ ë¬´ì ê¸ˆ í”„ë¡œê·¸ë˜ë° ë°ëª¨ ===\n\n";
    
    // 1. ê¸°ë³¸ InterlockedXXX í•¨ìˆ˜ ë°ëª¨
    std::cout << "1. ê¸°ë³¸ Interlocked ì—°ì‚° ë°ëª¨\n";
    demonstrateBasicOperations();
    demonstrateExchangeOperations();
    demonstrate64BitOperations();
    
    // 2. ìŠ¤í•€ë½ ë°ëª¨
    std::cout << "\n2. ìŠ¤í•€ë½ ë°ëª¨\n";
    demonstrateSpinLock();
    
    // 3. ì„±ëŠ¥ ë¹„êµ
    std::cout << "\n3. ì„±ëŠ¥ ë¹„êµ (ë¬´ì ê¸ˆ vs ì ê¸ˆ)\n";
    performanceTest();
    
    // 4. False Sharing ë°ëª¨
    std::cout << "\n4. False Sharing ë°ëª¨\n";
    demonstrateFalseSharing();
    
    // 5. ê²Œì„ ì„œë²„ ì‹œë®¬ë ˆì´ì…˜
    std::cout << "\n5. ê²Œì„ ì„œë²„ ì‹œë®¬ë ˆì´ì…˜\n";
    
    GameEventQueue eventQueue;
    GameStatistics stats;
    
    // ì´ë²¤íŠ¸ ì²˜ë¦¬ ìŠ¤ë ˆë“œ
    std::thread processor([&]() {
        eventQueue.processEvents();
    });
    
    // ì‹œë®¬ë ˆì´ì…˜ëœ ê²Œì„ í´ë¼ì´ì–¸íŠ¸ë“¤
    std::vector<std::thread> clients;
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> eventDist(0, 3);
    std::uniform_int_distribution<> playerDist(1, 100);
    
    for (int i = 0; i < 4; ++i) {
        clients.emplace_back([&, i]() {
            stats.playerConnected();
            
            for (int j = 0; j < 1000; ++j) {
                int playerId = playerDist(gen);
                auto eventType = static_cast<GameEventQueue::EventType>(eventDist(gen));
                
                std::string data = "data_" + std::to_string(j);
                eventQueue.pushEvent(eventType, playerId, data);
                
                stats.messageProcessed();
                stats.bytesTransferred(data.length());
                
                std::this_thread::sleep_for(std::chrono::microseconds(100));
            }
            
            stats.playerDisconnected();
        });
    }
    
    // í†µê³„ ì¶œë ¥ ìŠ¤ë ˆë“œ
    std::thread statisticsThread([&]() {
        for (int i = 0; i < 10; ++i) {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            stats.printStatistics();
            std::cout << "------------------------\n";
        }
    });
    
    // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ëŒ€ê¸°
    for (auto& client : clients) {
        client.join();
    }
    
    // ì •ë¦¬
    std::this_thread::sleep_for(std::chrono::seconds(2));
    eventQueue.stop();
    processor.join();
    statisticsThread.join();
    
    std::cout << "\nìµœì¢… í†µê³„:\n";
    stats.printStatistics();
    
    return 0;
}
```
  
</br>  

## 6.7 ì„±ëŠ¥ ìµœì í™” íŒ

### 6.7.1 ì ì ˆí•œ ê¸°ë²• ì„ íƒ

```
ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ë³„ ìµœì  ê¸°ë²•:

ê°„ë‹¨í•œ ì¹´ìš´í„°:
â””â”€ InterlockedIncrement/Decrement

í”Œë˜ê·¸ë‚˜ ìƒíƒœ:
â””â”€ InterlockedCompareExchange

í/ìŠ¤íƒ (ë†’ì€ ê²½í•©):
â””â”€ Lock-Free ìë£Œêµ¬ì¡°

í/ìŠ¤íƒ (ë‚®ì€ ê²½í•©):
â””â”€ Mutex + STL ì»¨í…Œì´ë„ˆ

ë³µì¡í•œ ë™ê¸°í™”:
â””â”€ ì „í†µì ì¸ ë™ê¸°í™” ê°ì²´
```

### 6.7.2 ë²¤ì¹˜ë§ˆí‚¹ ë„êµ¬

```cpp
class PerformanceMeasurer {
private:
    std::chrono::high_resolution_clock::time_point startTime;
    std::string operation;
    
public:
    PerformanceMeasurer(const std::string& op) : operation(op) {
        startTime = std::chrono::high_resolution_clock::now();
    }
    
    ~PerformanceMeasurer() {
        auto endTime = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            endTime - startTime);
        
        std::cout << operation << ": " << duration.count() << " Î¼s\n";
    }
};

#define MEASURE_PERFORMANCE(name) PerformanceMeasurer _perf(name)

void benchmarkOperations() {
    const int ITERATIONS = 1000000;
    LONG value = 0;
    
    {
        MEASURE_PERFORMANCE("InterlockedIncrement");
        for (int i = 0; i < ITERATIONS; ++i) {
            InterlockedIncrement(&value);
        }
    }
    
    {
        MEASURE_PERFORMANCE("InterlockedExchangeAdd");
        for (int i = 0; i < ITERATIONS; ++i) {
            InterlockedExchangeAdd(&value, 1);
        }
    }
    
    {
        MEASURE_PERFORMANCE("InterlockedCompareExchange");
        for (int i = 0; i < ITERATIONS; ++i) {
            LONG expected = value;
            InterlockedCompareExchange(&value, expected + 1, expected);
        }
    }
}
```
  
</br>  

## 6.8 ë§ˆë¬´ë¦¬
ì´ë²ˆ ì¥ì—ì„œëŠ” ê²Œì„ ì„œë²„ì˜ ì„±ëŠ¥ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆëŠ” ì¸í„°ë½ ì—°ì‚°ê³¼ ë¬´ì ê¸ˆ í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•´ ì•Œì•„ë³´ì•˜ë‹¤. ì£¼ìš” ë‚´ìš©ì„ ì •ë¦¬í•˜ë©´:

1. **InterlockedXXX í•¨ìˆ˜êµ°**: CPU ë ˆë²¨ì—ì„œ ì›ìì ìœ¼ë¡œ ìˆ˜í–‰ë˜ëŠ” ì—°ì‚°ë“¤
2. **ë¬´ì ê¸ˆ ìë£Œêµ¬ì¡°**: ë›°ì–´ë‚œ ì„±ëŠ¥ì„ ì œê³µí•˜ì§€ë§Œ êµ¬í˜„ì´ ë³µì¡
3. **ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´**: ë©”ëª¨ë¦¬ ìˆœì„œ ë¬¸ì œ í•´ê²°ì„ ìœ„í•œ í•„ìˆ˜ ê°œë…
4. **ABA ë¬¸ì œ**: ë¬´ì ê¸ˆ í”„ë¡œê·¸ë˜ë°ì˜ ëŒ€í‘œì ì¸ í•¨ì •ê³¼ í•´ê²°ì±…

ë¬´ì ê¸ˆ í”„ë¡œê·¸ë˜ë°ì€ ê°•ë ¥í•˜ì§€ë§Œ ë³µì¡í•˜ë‹¤. í•­ìƒ ì •í™•ì„±ì„ ë¨¼ì € í™•ë³´í•œ í›„ ì„±ëŠ¥ ìµœì í™”ë¥¼ ì§„í–‰í•˜ì‹œê¸° ë°”ë€ë‹¤. ë‹¤ìŒ ì¥ì—ì„œëŠ” ì‹œìŠ¤í…œ ì„±ëŠ¥ì„ ëª¨ë‹ˆí„°ë§í•˜ê³  ë¶„ì„í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ì•Œì•„ë³´ê² ë‹¤.

```
ë¬´ì ê¸ˆ í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ì •í™•ì„±    â”‚ â† ê°€ì¥ ì¤‘ìš”!
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   ì„±ëŠ¥     â”‚ â† ê·¸ ë‹¤ìŒ
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ë³µì¡ì„±    â”‚ â† ê°ìˆ˜í•´ì•¼ í•  ë¹„ìš©
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```   
  