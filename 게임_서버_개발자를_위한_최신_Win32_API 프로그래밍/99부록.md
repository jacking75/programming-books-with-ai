# ê²Œì„ ì„œë²„ ê°œë°œìë¥¼ ìœ„í•œ ìµœì‹  Win32 API í”„ë¡œê·¸ë˜ë°  

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  

# ë¶€ë¡

## ë¶€ë¡ A. ìì£¼ ì‚¬ìš©í•˜ëŠ” Win32 API ë ˆí¼ëŸ°ìŠ¤
ê²Œì„ ì„œë²„ ê°œë°œì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” Win32 APIë“¤ì„ ì¹´í…Œê³ ë¦¬ë³„ë¡œ ì •ë¦¬í–ˆë‹¤. ê° í•¨ìˆ˜ì˜ ê¸°ë³¸ ì‚¬ìš©ë²•ê³¼ ì£¼ì˜ì‚¬í•­ì„ í¬í•¨í•˜ì—¬ ë¹ ë¥¸ ì°¸ì¡°ê°€ ê°€ëŠ¥í•˜ë„ë¡ êµ¬ì„±í–ˆë‹¤.

### A.1 ë©”ëª¨ë¦¬ ê´€ë¦¬ API

#### í™ ë©”ëª¨ë¦¬ ê´€ë¦¬
```cpp
// í™ ìƒì„± ë° í•´ì œ
HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
BOOL HeapDestroy(HANDLE hHeap);

// ë©”ëª¨ë¦¬ í• ë‹¹/í•´ì œ
LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);

// ì‚¬ìš© ì˜ˆì‹œ
HANDLE gameHeap = HeapCreate(HEAP_NO_SERIALIZE, 1024*1024, 0);
char* buffer = (char*)HeapAlloc(gameHeap, HEAP_ZERO_MEMORY, 4096);
```

#### ê°€ìƒ ë©”ëª¨ë¦¬ ê´€ë¦¬
```cpp
// ê°€ìƒ ë©”ëª¨ë¦¬ í• ë‹¹/í•´ì œ
LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);

// ë©”ëª¨ë¦¬ ë³´í˜¸ ì†ì„± ë³€ê²½
BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);

// ì‚¬ìš© ì˜ˆì‹œ - ëŒ€ìš©ëŸ‰ ë©”ëª¨ë¦¬ í’€
void* memoryPool = VirtualAlloc(NULL, 64*1024*1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
```

### A.2 íŒŒì¼ ì‹œìŠ¤í…œ API

#### íŒŒì¼ ì…ì¶œë ¥
```cpp
// íŒŒì¼ í•¸ë“¤ ê´€ë¦¬
HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, 
                   LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition,
                   DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
BOOL CloseHandle(HANDLE hObject);

// íŒŒì¼ ì½ê¸°/ì“°ê¸°
BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead,
              LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite,
               LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);

// ê²Œì„ ë¡œê·¸ íŒŒì¼ ì˜ˆì‹œ
HANDLE logFile = CreateFileW(L"game_server.log", GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
```

#### ë¹„ë™ê¸° íŒŒì¼ I/O
```cpp
// ì™„ë£Œ í¬íŠ¸ì™€ í•¨ê»˜ ì‚¬ìš©
HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort,
                             ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred,
                              PULONG_PTR lpCompletionKey, LPOVERLAPPED* lpOverlapped,
                              DWORD dwMilliseconds);
```

### A.3 í”„ë¡œì„¸ìŠ¤ ë° ìŠ¤ë ˆë“œ API

#### ìŠ¤ë ˆë“œ ê´€ë¦¬
```cpp
// ìŠ¤ë ˆë“œ ìƒì„± ë° ê´€ë¦¬
HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize,
                   LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter,
                   DWORD dwCreationFlags, LPDWORD lpThreadId);
DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE* lpHandles,
                            BOOL bWaitAll, DWORD dwMilliseconds);

// ê²Œì„ ì„œë²„ ì›Œì»¤ ìŠ¤ë ˆë“œ ì˜ˆì‹œ
HANDLE workerThread = CreateThread(NULL, 0, GameServerWorker, &threadData, 0, NULL);
```

#### í”„ë¡œì„¸ìŠ¤ ì •ë³´
```cpp
// í˜„ì¬ í”„ë¡œì„¸ìŠ¤/ìŠ¤ë ˆë“œ ì •ë³´
HANDLE GetCurrentProcess(void);
DWORD GetCurrentProcessId(void);
HANDLE GetCurrentThread(void);
DWORD GetCurrentThreadId(void);

// í”„ë¡œì„¸ìŠ¤ ìš°ì„ ìˆœìœ„ ì¡°ì •
BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass);
```

### A.4 ë™ê¸°í™” API

#### ë®¤í…ìŠ¤ì™€ ì„¸ë§ˆí¬ì–´
```cpp
// ë®¤í…ìŠ¤
HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
BOOL ReleaseMutex(HANDLE hMutex);

// ì„¸ë§ˆí¬ì–´
HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount,
                       LONG lMaximumCount, LPCWSTR lpName);
BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);

// ê²Œì„ ì„œë²„ ì—°ê²° ì œí•œ ì˜ˆì‹œ
HANDLE connectionSemaphore = CreateSemaphoreW(NULL, MAX_CONNECTIONS, MAX_CONNECTIONS, NULL);
```

#### ì´ë²¤íŠ¸ ê°ì²´
```cpp
// ì´ë²¤íŠ¸ ìƒì„± ë° ì œì–´
HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset,
                   BOOL bInitialState, LPCWSTR lpName);
BOOL SetEvent(HANDLE hEvent);
BOOL ResetEvent(HANDLE hEvent);
BOOL PulseEvent(HANDLE hEvent);
```

#### ì¸í„°ë½ ì—°ì‚°
```cpp
// ì›ìì  ì—°ì‚°
LONG InterlockedIncrement(LONG volatile* Addend);
LONG InterlockedDecrement(LONG volatile* Addend);
LONG InterlockedExchange(LONG volatile* Target, LONG Value);
LONG InterlockedCompareExchange(LONG volatile* Destination, LONG Exchange, LONG Comparand);

// 64ë¹„íŠ¸ ë²„ì „
LONG64 InterlockedIncrement64(LONG64 volatile* Addend);
LONG64 InterlockedCompareExchange64(LONG64 volatile* Destination, LONG64 Exchange, LONG64 Comparand);
```

### A.5 ë„¤íŠ¸ì›Œí¬ ê´€ë ¨ API

#### ì†Œì¼“ API (Winsock2)
```cpp
// ì´ˆê¸°í™” ë° ì •ë¦¬
int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
int WSACleanup(void);

// ì†Œì¼“ ìƒì„± ë° ê´€ë¦¬
SOCKET socket(int af, int type, int protocol);
int closesocket(SOCKET s);
int bind(SOCKET s, const sockaddr* addr, int namelen);
int listen(SOCKET s, int backlog);
SOCKET accept(SOCKET s, sockaddr* addr, int* addrlen);

// ë¹„ë™ê¸° ì†Œì¼“ ì´ë²¤íŠ¸
int WSAEventSelect(SOCKET s, WSAEVENT hEventObject, long lNetworkEvents);
DWORD WSAWaitForMultipleEvents(DWORD cEvents, const WSAEVENT* lphEvents,
                              BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable);
```

### A.6 ì‹œìŠ¤í…œ ì •ë³´ API

#### ì„±ëŠ¥ ë° ì‹œìŠ¤í…œ ì •ë³´
```cpp
// ì‹œìŠ¤í…œ ì •ë³´
void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
BOOL GetSystemTimes(LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);

// ë©”ëª¨ë¦¬ ìƒíƒœ
BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer);

// ì„±ëŠ¥ ì¹´ìš´í„°
BOOL QueryPerformanceCounter(LARGE_INTEGER* lpPerformanceCount);
BOOL QueryPerformanceFrequency(LARGE_INTEGER* lpFrequency);

// ì‚¬ìš© ì˜ˆì‹œ
SYSTEM_INFO sysInfo;
GetSystemInfo(&sysInfo);
printf("í”„ë¡œì„¸ì„œ ìˆ˜: %d\n", sysInfo.dwNumberOfProcessors);
```

---

## ë¶€ë¡ B. ì—ëŸ¬ ì½”ë“œ ë° ë””ë²„ê¹… ê°€ì´ë“œ

### B.1 ì¼ë°˜ì ì¸ Win32 ì—ëŸ¬ ì½”ë“œ
ê²Œì„ ì„œë²„ ê°œë°œì—ì„œ ìì£¼ ë§ˆì£¼ì¹˜ëŠ” ì—ëŸ¬ ì½”ë“œë“¤ê³¼ í•´ê²° ë°©ë²•ì„ ì •ë¦¬í–ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Win32 ì—ëŸ¬ ì½”ë“œ ê³„ì¸µ                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Application Layer                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚     ê²Œì„ ì„œë²„ ë¡œì§                               â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                          â”‚                              â”‚
â”‚                          â–¼                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚     Win32 API Layer                             â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚    â”‚
â”‚  â”‚  â”‚  File   â”‚ â”‚ Network â”‚ â”‚ Memory  â”‚           â”‚    â”‚
â”‚  â”‚  â”‚   API   â”‚ â”‚   API   â”‚ â”‚   API   â”‚           â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                          â”‚                              â”‚
â”‚                          â–¼                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚     Kernel Layer                                â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ë©”ëª¨ë¦¬ ê´€ë ¨ ì—ëŸ¬
| ì—ëŸ¬ ì½”ë“œ | ìƒìˆ˜ëª… | ì„¤ëª… ë° í•´ê²°ë°©ë²• |
|-----------|--------|------------------|
| 8 | ERROR_NOT_ENOUGH_MEMORY | ë©”ëª¨ë¦¬ ë¶€ì¡±. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì ê²€ í•„ìš” |
| 14 | ERROR_OUTOFMEMORY | ê°€ìƒ ë©”ëª¨ë¦¬ ë¶€ì¡±. VirtualAlloc ì‹¤íŒ¨ ì‹œ í™•ì¸ |
| 487 | ERROR_INVALID_ADDRESS | ì˜ëª»ëœ ë©”ëª¨ë¦¬ ì£¼ì†Œ. í¬ì¸í„° ìœ íš¨ì„± ê²€ì‚¬ í•„ìš” |

```cpp
// ì—ëŸ¬ ì²˜ë¦¬ ì˜ˆì‹œ
LPVOID ptr = HeapAlloc(GetProcessHeap(), 0, size);
if (ptr == NULL) {
    DWORD error = GetLastError();
    if (error == ERROR_NOT_ENOUGH_MEMORY) {
        // ë©”ëª¨ë¦¬ ì •ë¦¬ í›„ ì¬ì‹œë„
        CleanupMemoryPool();
        ptr = HeapAlloc(GetProcessHeap(), 0, size);
    }
}
```

#### íŒŒì¼ ì‹œìŠ¤í…œ ì—ëŸ¬
| ì—ëŸ¬ ì½”ë“œ | ìƒìˆ˜ëª… | ì„¤ëª… ë° í•´ê²°ë°©ë²• |
|-----------|--------|------------------|
| 2 | ERROR_FILE_NOT_FOUND | íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ. ê²½ë¡œ í™•ì¸ í•„ìš” |
| 3 | ERROR_PATH_NOT_FOUND | ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ. ë””ë ‰í„°ë¦¬ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ |
| 5 | ERROR_ACCESS_DENIED | ì ‘ê·¼ ê±°ë¶€. ê¶Œí•œ ë˜ëŠ” íŒŒì¼ ì ê¸ˆ ìƒíƒœ í™•ì¸ |
| 32 | ERROR_SHARING_VIOLATION | íŒŒì¼ì´ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì— ì˜í•´ ì‚¬ìš© ì¤‘ |

```cpp
// íŒŒì¼ ì—ëŸ¬ ì²˜ë¦¬
HANDLE hFile = CreateFileW(filename, GENERIC_READ, FILE_SHARE_READ, 
                          NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if (hFile == INVALID_HANDLE_VALUE) {
    DWORD error = GetLastError();
    switch (error) {
        case ERROR_FILE_NOT_FOUND:
            LogError(L"ì„¤ì • íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: %s", filename);
            break;
        case ERROR_ACCESS_DENIED:
            LogError(L"íŒŒì¼ ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤: %s", filename);
            break;
    }
}
```

#### ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ (Winsock)
| ì—ëŸ¬ ì½”ë“œ | ìƒìˆ˜ëª… | ì„¤ëª… ë° í•´ê²°ë°©ë²• |
|-----------|--------|------------------|
| 10054 | WSAECONNRESET | ì—°ê²°ì´ ì›ê²©ì§€ì— ì˜í•´ ì¬ì„¤ì •ë¨ |
| 10055 | WSAENOBUFS | ë²„í¼ ê³µê°„ ë¶€ì¡± |
| 10060 | WSAETIMEDOUT | ì—°ê²° ì‹œê°„ ì´ˆê³¼ |
| 10061 | WSAECONNREFUSED | ì—°ê²° ê±°ë¶€ë¨ |

### B.2 ë””ë²„ê¹… ë„êµ¬ ë° ê¸°ë²•

#### Visual Studio 2022 ë””ë²„ê±° í™œìš©

```cpp
// ì¡°ê±´ë¶€ ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì„¤ì •ì„ ìœ„í•œ ì½”ë“œ
void ProcessGamePacket(GamePacket* packet) {
    // íŠ¹ì • íŒ¨í‚· íƒ€ì…ì—ì„œë§Œ ì¤‘ë‹¨í•˜ë ¤ë©´:
    // ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì¡°ê±´: packet->type == PACKET_TYPE_LOGIN
    
    if (packet->type == PACKET_TYPE_LOGIN) {
        // ë””ë²„ê±°ì—ì„œ í™•ì¸í•  ë³€ìˆ˜ë“¤
        int playerCount = GetActivePlayerCount();
        DWORD memoryUsage = GetMemoryUsage();
        
        // OutputDebugStringìœ¼ë¡œ ì‹¤ì‹œê°„ ë¡œê·¸
        wchar_t debugMsg[256];
        swprintf_s(debugMsg, L"Login packet received. Players: %d, Memory: %d MB\n", 
                  playerCount, memoryUsage / (1024*1024));
        OutputDebugStringW(debugMsg);
    }
}
```

#### ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ íƒì§€

```cpp
// CRT ë””ë²„ê·¸ í™ ì‚¬ìš©
#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>

void EnableMemoryLeakDetection() {
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
    
    // íŠ¹ì • í• ë‹¹ ë²ˆí˜¸ì—ì„œ ì¤‘ë‹¨
    // _CrtSetBreakAlloc(1234);
}
#endif

// Application Verifier ì‚¬ìš© ê¶Œì¥
// verifier.exe /standard /all GameServer.exe
```

#### ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§

```cpp
class PerformanceProfiler {
    LARGE_INTEGER frequency, startTime, endTime;
    
public:
    void StartProfile() {
        QueryPerformanceFrequency(&frequency);
        QueryPerformanceCounter(&startTime);
    }
    
    double EndProfile() {
        QueryPerformanceCounter(&endTime);
        return static_cast<double>(endTime.QuadPart - startTime.QuadPart) / frequency.QuadPart;
    }
};

// ì‚¬ìš© ì˜ˆì‹œ
PerformanceProfiler profiler;
profiler.StartProfile();
ProcessGameLogic();
double elapsed = profiler.EndProfile();
if (elapsed > 0.016) { // 16ms ì´ˆê³¼ ì‹œ
    LogWarning(L"ê²Œì„ ë¡œì§ ì²˜ë¦¬ ì‹œê°„ ì´ˆê³¼: %.3fì´ˆ", elapsed);
}
```

### B.3 ì¼ë°˜ì ì¸ ë””ë²„ê¹… ì‹œë‚˜ë¦¬ì˜¤

#### ë°ë“œë½ íƒì§€
```cpp
// ë°ë“œë½ ë°©ì§€ë¥¼ ìœ„í•œ íƒ€ì„ì•„ì›ƒ ì‚¬ìš©
DWORD result = WaitForSingleObject(mutex, 5000); // 5ì´ˆ íƒ€ì„ì•„ì›ƒ
if (result == WAIT_TIMEOUT) {
    LogError(L"ë®¤í…ìŠ¤ ëŒ€ê¸° ì‹œê°„ ì´ˆê³¼ - ë°ë“œë½ ê°€ëŠ¥ì„±");
    // ì—ëŸ¬ ì²˜ë¦¬ ë˜ëŠ” ê°•ì œ í•´ì œ
}

// ë‹¤ì¤‘ ë®¤í…ìŠ¤ ìˆœì„œ ì§€ì •ìœ¼ë¡œ ë°ë“œë½ ë°©ì§€
void AcquireMultipleLocks() {
    // í•­ìƒ ê°™ì€ ìˆœì„œë¡œ ì ê¸ˆ íšë“
    WaitForSingleObject(globalMutex1, INFINITE);
    WaitForSingleObject(globalMutex2, INFINITE);
    
    // ì‘ì—… ìˆ˜í–‰
    
    // ì—­ìˆœìœ¼ë¡œ í•´ì œ
    ReleaseMutex(globalMutex2);
    ReleaseMutex(globalMutex1);
}
```

---

## ë¶€ë¡ C. ì„±ëŠ¥ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸

### C.1 ë©”ëª¨ë¦¬ ìµœì í™”

```
ğŸ“‹ ë©”ëª¨ë¦¬ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸
â”œâ”€â”€ âœ… ë©”ëª¨ë¦¬ í’€ ì‚¬ìš©
â”‚   â”œâ”€â”€ ê³ ì • í¬ê¸° ê°ì²´ìš© í’€ êµ¬í˜„
â”‚   â”œâ”€â”€ ê°€ë³€ í¬ê¸° ë²„í¼ìš© í’€ êµ¬í˜„
â”‚   â””â”€â”€ ë©”ëª¨ë¦¬ ì •ë ¬ ê³ ë ¤ (16ë°”ì´íŠ¸ ì •ë ¬)
â”œâ”€â”€ âœ… ê°€ìƒ ë©”ëª¨ë¦¬ í™œìš©
â”‚   â”œâ”€â”€ ëŒ€ìš©ëŸ‰ ë°ì´í„°ìš© VirtualAlloc ì‚¬ìš©
â”‚   â”œâ”€â”€ ì˜ˆì•½ í›„ í•„ìš”ì‹œ ì»¤ë°‹ ë°©ì‹
â”‚   â””â”€â”€ ë©”ëª¨ë¦¬ ë§¤í•‘ íŒŒì¼ í™œìš©
â”œâ”€â”€ âœ… ìºì‹œ ì¹œí™”ì  ì„¤ê³„
â”‚   â”œâ”€â”€ ë°ì´í„° êµ¬ì¡° ìµœì í™” (SoA vs AoS)
â”‚   â”œâ”€â”€ ë©”ëª¨ë¦¬ ì ‘ê·¼ íŒ¨í„´ ê°œì„ 
â”‚   â””â”€â”€ False sharing ë°©ì§€
â””â”€â”€ âœ… ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
    â”œâ”€â”€ RAII íŒ¨í„´ ì ìš©
    â”œâ”€â”€ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì‚¬ìš©
    â””â”€â”€ ì •ê¸°ì ì¸ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
```

#### ë©”ëª¨ë¦¬ í’€ êµ¬í˜„ ì˜ˆì‹œ
```cpp
template<typename T, size_t PoolSize>
class FixedMemoryPool {
    struct Block {
        alignas(T) char data[sizeof(T)];
        Block* next;
    };
    
    Block pool[PoolSize];
    Block* freeList;
    std::atomic<size_t> allocatedCount{0};
    
public:
    FixedMemoryPool() {
        // í”„ë¦¬ ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
        for (size_t i = 0; i < PoolSize - 1; ++i) {
            pool[i].next = &pool[i + 1];
        }
        pool[PoolSize - 1].next = nullptr;
        freeList = &pool[0];
    }
    
    T* Allocate() {
        if (auto* block = freeList) {
            freeList = block->next;
            allocatedCount.fetch_add(1);
            return reinterpret_cast<T*>(block);
        }
        return nullptr; // í’€ ê³ ê°ˆ
    }
    
    void Deallocate(T* ptr) {
        auto* block = reinterpret_cast<Block*>(ptr);
        block->next = freeList;
        freeList = block;
        allocatedCount.fetch_sub(1);
    }
    
    size_t GetAllocatedCount() const { return allocatedCount.load(); }
};
```

### C.2 I/O ìµœì í™”

#### ë¹„ë™ê¸° I/O ìµœì í™”
```cpp
class AsyncFileManager {
    HANDLE iocp;
    std::vector<std::thread> workers;
    
    struct IOContext {
        OVERLAPPED overlapped;
        HANDLE fileHandle;
        char* buffer;
        size_t bufferSize;
        std::function<void(DWORD, DWORD)> callback;
    };
    
public:
    AsyncFileManager(int workerThreads = 4) {
        iocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, workerThreads);
        
        for (int i = 0; i < workerThreads; ++i) {
            workers.emplace_back([this] { WorkerThread(); });
        }
    }
    
    void ReadFileAsync(HANDLE file, void* buffer, size_t size, 
                      LARGE_INTEGER offset, std::function<void(DWORD, DWORD)> callback) {
        auto* context = new IOContext{};
        context->overlapped = {};
        context->overlapped.Offset = offset.LowPart;
        context->overlapped.OffsetHigh = offset.HighPart;
        context->fileHandle = file;
        context->buffer = static_cast<char*>(buffer);
        context->bufferSize = size;
        context->callback = std::move(callback);
        
        // íŒŒì¼ì„ ì™„ë£Œ í¬íŠ¸ì— ì—°ê²°
        CreateIoCompletionPort(file, iocp, reinterpret_cast<ULONG_PTR>(context), 0);
        
        // ë¹„ë™ê¸° ì½ê¸° ì‹œì‘
        DWORD bytesRead;
        if (!ReadFile(file, buffer, static_cast<DWORD>(size), &bytesRead, &context->overlapped)) {
            if (GetLastError() != ERROR_IO_PENDING) {
                delete context;
                // ì—ëŸ¬ ì²˜ë¦¬
            }
        }
    }
    
private:
    void WorkerThread() {
        DWORD bytesTransferred;
        ULONG_PTR completionKey;
        LPOVERLAPPED overlapped;
        
        while (GetQueuedCompletionStatus(iocp, &bytesTransferred, &completionKey, 
                                        &overlapped, INFINITE)) {
            auto* context = reinterpret_cast<IOContext*>(completionKey);
            
            // ì½œë°± ì‹¤í–‰
            context->callback(bytesTransferred, GetLastError());
            
            delete context;
        }
    }
};
```

### C.3 ìŠ¤ë ˆë“œ ë° ë™ê¸°í™” ìµœì í™”

#### ë¬´ì ê¸ˆ í êµ¬í˜„
```cpp
template<typename T>
class LockFreeQueue {
    struct Node {
        std::atomic<T*> data;
        std::atomic<Node*> next;
        
        Node() : data(nullptr), next(nullptr) {}
    };
    
    std::atomic<Node*> head;
    std::atomic<Node*> tail;
    
public:
    LockFreeQueue() {
        Node* dummy = new Node;
        head.store(dummy);
        tail.store(dummy);
    }
    
    void Enqueue(T item) {
        Node* newNode = new Node;
        T* data = new T(std::move(item));
        newNode->data.store(data);
        
        while (true) {
            Node* last = tail.load();
            Node* next = last->next.load();
            
            if (last == tail.load()) {
                if (next == nullptr) {
                    if (last->next.compare_exchange_weak(next, newNode)) {
                        break;
                    }
                } else {
                    tail.compare_exchange_weak(last, next);
                }
            }
        }
        tail.compare_exchange_weak(tail.load(), newNode);
    }
    
    bool Dequeue(T& result) {
        while (true) {
            Node* first = head.load();
            Node* last = tail.load();
            Node* next = first->next.load();
            
            if (first == head.load()) {
                if (first == last) {
                    if (next == nullptr) {
                        return false; // íê°€ ë¹„ì–´ìˆìŒ
                    }
                    tail.compare_exchange_weak(last, next);
                } else {
                    if (next == nullptr) {
                        continue;
                    }
                    
                    T* data = next->data.load();
                    if (data == nullptr) {
                        continue;
                    }
                    
                    if (head.compare_exchange_weak(first, next)) {
                        result = *data;
                        delete data;
                        delete first;
                        return true;
                    }
                }
            }
        }
    }
};
```

### C.4 ë„¤íŠ¸ì›Œí¬ ìµœì í™”

#### ì†Œì¼“ ì˜µì…˜ ìµœì í™”
```cpp
void OptimizeSocket(SOCKET sock) {
    // Nagle ì•Œê³ ë¦¬ì¦˜ ë¹„í™œì„±í™” (ê²Œì„ì—ì„œëŠ” ì§€ì—° ì‹œê°„ì´ ì¤‘ìš”)
    BOOL nodelay = TRUE;
    setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, 
               reinterpret_cast<char*>(&nodelay), sizeof(nodelay));
    
    // ì†¡ì‹  ë²„í¼ í¬ê¸° ì¡°ì •
    int sendBufSize = 64 * 1024;
    setsockopt(sock, SOL_SOCKET, SO_SNDBUF, 
               reinterpret_cast<char*>(&sendBufSize), sizeof(sendBufSize));
    
    // ìˆ˜ì‹  ë²„í¼ í¬ê¸° ì¡°ì •  
    int recvBufSize = 64 * 1024;
    setsockopt(sock, SOL_SOCKET, SO_RCVBUF, 
               reinterpret_cast<char*>(&recvBufSize), sizeof(recvBufSize));
    
    // Keep-alive ì„¤ì •
    BOOL keepalive = TRUE;
    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, 
               reinterpret_cast<char*>(&keepalive), sizeof(keepalive));
    
    // Keep-alive íŒŒë¼ë¯¸í„° ì„¤ì • (Windows ì „ìš©)
    tcp_keepalive ka;
    ka.onoff = 1;
    ka.keepalivetime = 30000;  // 30ì´ˆ
    ka.keepaliveinterval = 5000; // 5ì´ˆ
    
    DWORD bytesReturned;
    WSAIoctl(sock, SIO_KEEPALIVE_VALS, &ka, sizeof(ka), 
             NULL, 0, &bytesReturned, NULL, NULL);
}
```

---

## ë¶€ë¡ D. Visual Studio 2022 íŒê³¼ íŠ¸ë¦­

### D.1 ê°œë°œ í™˜ê²½ ì„¤ì •

#### í”„ë¡œì íŠ¸ ì„¤ì • ìµœì í™”
```xml
<!-- Directory.Build.props íŒŒì¼ì— ê³µí†µ ì„¤ì • -->
<Project>
  <PropertyGroup>
    <!-- C++20 ì‚¬ìš© -->
    <LanguageStandard>stdcpp20</LanguageStandard>
    
    <!-- ë©€í‹°í”„ë¡œì„¸ì„œ ì»´íŒŒì¼ -->
    <MultiProcessorCompilation>true</MultiProcessorCompilation>
    
    <!-- ë¯¸ë¦¬ ì»´íŒŒì¼ëœ í—¤ë” -->
    <PrecompiledHeader>Use</PrecompiledHeader>
    <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    
    <!-- ë””ë²„ê·¸ ì •ë³´ ìµœì í™” -->
    <DebugInformationFormat Condition="'$(Configuration)'=='Debug'">ProgramDatabase</DebugInformationFormat>
    <DebugInformationFormat Condition="'$(Configuration)'=='Release'">None</DebugInformationFormat>
    
    <!-- ë§ì»¤ ìµœì í™” -->
    <LinkIncremental Condition="'$(Configuration)'=='Release'">false</LinkIncremental>
    <WholeProgramOptimization Condition="'$(Configuration)'=='Release'">true</WholeProgramOptimization>
  </PropertyGroup>
  
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
    <ClCompile>
      <!-- ë¦´ë¦¬ìŠ¤ ë¹Œë“œ ìµœì í™” -->
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
  </ItemDefinitionGroup>
</Project>
```

### D.2 ë””ë²„ê¹… ê¸°ëŠ¥ í™œìš©

#### ì»¤ìŠ¤í…€ ë””ë²„ê·¸ ì‹œê°í™”
```cpp
// GameServer.natvis íŒŒì¼ ìƒì„±
<?xml version="1.0" encoding="utf-8"?>
<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">
  <!-- ê²Œì„ í”Œë ˆì´ì–´ êµ¬ì¡°ì²´ ì‹œê°í™” -->
  <Type Name="GamePlayer">
    <DisplayString>{name} (ID: {playerId}, HP: {health}/{maxHealth})</DisplayString>
    <Expand>
      <Item Name="Player ID">playerId</Item>
      <Item Name="Name">name</Item>
      <Item Name="Health">health</Item>
      <Item Name="Max Health">maxHealth</Item>
      <Item Name="Position">position</Item>
      <Item Name="Level">level</Item>
    </Expand>
  </Type>
  
  <!-- ì»¤ìŠ¤í…€ ë²¡í„° ì‹œê°í™” -->
  <Type Name="Vector3">
    <DisplayString>({x}, {y}, {z})</DisplayString>
  </Type>
  
  <!-- ê²Œì„ íŒ¨í‚· ì‹œê°í™” -->
  <Type Name="GamePacket">
    <DisplayString Condition="type == 1">Login Packet: {data.loginData.username}</DisplayString>
    <DisplayString Condition="type == 2">Move Packet: ({data.moveData.x}, {data.moveData.y})</DisplayString>
    <DisplayString>Packet Type: {type}</DisplayString>
  </Type>
</AutoVisualizer>
```

#### ì¡°ê±´ë¶€ ì»´íŒŒì¼ ë§¤í¬ë¡œ
```cpp
// debug_macros.h
#ifdef _DEBUG
    #define DBG_PRINT(fmt, ...) \
        do { \
            wchar_t buffer[1024]; \
            swprintf_s(buffer, fmt L"\n", __VA_ARGS__); \
            OutputDebugStringW(buffer); \
        } while(0)
    
    #define DBG_ASSERT(condition, message) \
        do { \
            if (!(condition)) { \
                DBG_PRINT(L"ASSERT FAILED: %s at %s:%d", L##message, L##__FILE__, __LINE__); \
                __debugbreak(); \
            } \
        } while(0)
    
    #define DBG_TRACE_FUNCTION() \
        DBG_PRINT(L"TRACE: Entering %s", L##__FUNCTION__)
#else
    #define DBG_PRINT(fmt, ...)
    #define DBG_ASSERT(condition, message)
    #define DBG_TRACE_FUNCTION()
#endif

// ì‚¬ìš© ì˜ˆì‹œ
void ProcessPlayerLogin(const LoginData& data) {
    DBG_TRACE_FUNCTION();
    DBG_ASSERT(data.username != nullptr, "Username cannot be null");
    DBG_PRINT(L"Player login: %s", data.username);
    
    // ë¡œê·¸ì¸ ì²˜ë¦¬ ë¡œì§
}
```

### D.3 ì½”ë“œ ë¶„ì„ ë„êµ¬

#### ì •ì  ë¶„ì„ ê·œì¹™ ì„¤ì •
```xml
<!-- .editorconfig íŒŒì¼ -->
root = true

[*.{cpp,h}]
indent_style = space
indent_size = 4
end_of_line = crlf
charset = utf-8

# C++ ì½”ë”© ìŠ¤íƒ€ì¼
cpp_indent_braces = false
cpp_indent_multi_line_relative_to = innermost_parenthesis
cpp_indent_within_parentheses = indent
cpp_indent_preserve_within_parentheses = false
cpp_indent_case_contents = true
cpp_indent_case_labels = false
cpp_indent_case_contents_when_block = false
cpp_indent_lambda_braces_when_parameter = true
cpp_indent_goto_labels = one_left
cpp_indent_preprocessor = leftmost_column
cpp_indent_access_specifiers = false
cpp_indent_namespace_contents = true
cpp_indent_preserve_comments = false

# ê³µë°± ì„¤ì •
cpp_space_before_function_open_parenthesis = never
cpp_space_within_parameter_list_parentheses = false
cpp_space_between_empty_parameter_list_parentheses = false
cpp_space_after_keywords_in_control_flow_statements = true
cpp_space_within_control_flow_statement_parentheses = false
cpp_space_before_lambda_open_parenthesis = false
cpp_space_within_cast_parentheses = false
cpp_space_after_cast_close_parenthesis = false
cpp_space_within_expression_parentheses = false
cpp_space_before_block_open_brace = true
cpp_space_between_empty_braces = false
cpp_space_before_initializer_list_open_brace = false
cpp_space_within_initializer_list_braces = true
cpp_space_preserve_in_initializer_list = true
cpp_space_before_open_square_bracket = false
cpp_space_within_square_brackets = false
cpp_space_before_empty_square_brackets = false
cpp_space_between_empty_square_brackets = false
cpp_space_group_square_brackets = true
cpp_space_within_lambda_brackets = false
cpp_space_between_empty_lambda_brackets = false
cpp_space_before_comma = false
cpp_space_after_comma = true
cpp_space_remove_around_member_operators = true
cpp_space_before_inheritance_colon = true
cpp_space_before_constructor_colon = true
cpp_space_remove_before_semicolon = true
cpp_space_after_semicolon = false
cpp_space_remove_around_unary_operator = true
cpp_space_around_binary_operator = insert
cpp_space_around_assignment_operator = insert
cpp_space_pointer_reference_alignment = left
cpp_space_around_ternary_operator = insert

# ìƒˆ ì¤„ ì„¤ì •
cpp_new_line_before_open_brace_namespace = ignore
cpp_new_line_before_open_brace_type = ignore
cpp_new_line_before_open_brace_function = ignore
cpp_new_line_before_open_brace_block = ignore
cpp_new_line_before_open_brace_lambda = ignore
cpp_new_line_scope_braces_on_separate_lines = false
cpp_new_line_close_brace_same_line_empty_type = false
cpp_new_line_close_brace_same_line_empty_function = false
cpp_new_line_before_catch = true
cpp_new_line_before_else = true
cpp_new_line_before_while_in_do_while = false
```

### D.4 ìœ ìš©í•œ í™•ì¥ í”„ë¡œê·¸ë¨

#### ê¶Œì¥ í™•ì¥ í”„ë¡œê·¸ë¨ ëª©ë¡
```json
// .vscode/extensions.json (ì°¸ê³ ìš©)
{
    "recommendations": [
        "ms-vscode.cpptools",
        "ms-vscode.cpptools-extension-pack", 
        "ms-vscode.cmake-tools",
        "ms-vscode.hexeditor",
        "visualstudioexptteam.vscodeintellicode",
        "ms-vscode.vscode-json"
    ]
}
```

#### ì»¤ìŠ¤í…€ ì½”ë“œ ìŠ¤ë‹ˆí«
```json
// ê²Œì„ ì„œë²„ ì½”ë“œ ìŠ¤ë‹ˆí« (cpp.json)
{
    "Game Server Thread Function": {
        "prefix": "gsthread",
        "body": [
            "DWORD WINAPI ${1:ThreadName}(LPVOID lpParam) {",
            "    ${2:ThreadData}* data = static_cast<${2:ThreadData}*>(lpParam);",
            "    ",
            "    while (!data->shouldExit) {",
            "        try {",
            "            ${3:// ìŠ¤ë ˆë“œ ì‘ì—… ë¡œì§}",
            "            ",
            "            Sleep(${4:1}); // CPU ì‚¬ìš©ë¥  ì¡°ì ˆ",
            "        }",
            "        catch (const std::exception& e) {",
            "            LogError(L\"Thread error: %hs\", e.what());",
            "        }",
            "    }",
            "    ",
            "    return 0;",
            "}"
        ],
        "description": "ê²Œì„ ì„œë²„ ìŠ¤ë ˆë“œ í•¨ìˆ˜ í…œí”Œë¦¿"
    },
    
    "Error Handling Pattern": {
        "prefix": "gserror",
        "body": [
            "if (${1:condition}) {",
            "    DWORD error = GetLastError();",
            "    LogError(L\"${2:Operation} failed with error %d\", error);",
            "    ${3:// ì—ëŸ¬ ì²˜ë¦¬ ë¡œì§}",
            "    return ${4:false};",
            "}"
        ],
        "description": "Win32 ì—ëŸ¬ ì²˜ë¦¬ íŒ¨í„´"
    },
    
    "Performance Timer": {
        "prefix": "gstimer",
        "body": [
            "LARGE_INTEGER frequency, startTime, endTime;",
            "QueryPerformanceFrequency(&frequency);",
            "QueryPerformanceCounter(&startTime);",
            "",
            "${1:// ì¸¡ì •í•  ì½”ë“œ}",
            "",
            "QueryPerformanceCounter(&endTime);",
            "double elapsed = static_cast<double>(endTime.QuadPart - startTime.QuadPart) / frequency.QuadPart;",
            "LogInfo(L\"${2:Operation} took %.3f seconds\", elapsed);"
        ],
        "description": "ì„±ëŠ¥ ì¸¡ì • íƒ€ì´ë¨¸"
    }
}
```

ì´ ë¶€ë¡ë“¤ì€ ê²Œì„ ì„œë²„ ê°œë°œ ê³¼ì •ì—ì„œ ìì£¼ ì°¸ì¡°í•˜ê²Œ ë  ì‹¤ìš©ì ì¸ ì •ë³´ë“¤ì„ ë‹´ê³  ìˆë‹¤. ê°œë°œ ì¤‘ì— ë¬¸ì œê°€ ë°œìƒí–ˆì„ ë•Œë‚˜ ì„±ëŠ¥ ìµœì í™”ê°€ í•„ìš”í•  ë•Œ ë¹ ë¥´ê²Œ ì°¾ì•„ë³¼ ìˆ˜ ìˆë„ë¡ êµ¬ì„±í–ˆë‹¤. ê° ì„¹ì…˜ì˜ ì˜ˆì œ ì½”ë“œë“¤ì€ ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œ ë°”ë¡œ í™œìš©í•  ìˆ˜ ìˆë„ë¡ ì™„ì „í•œ í˜•íƒœë¡œ ì œê³µí–ˆë‹¤.


 