# ê²Œì„ ì„œë²„ ê°œë°œìë¥¼ ìœ„í•œ ìµœì‹  Win32 API í”„ë¡œê·¸ë˜ë°  

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  

# Chapter 10. ì„œë¹„ìŠ¤ í”„ë¡œê·¸ë˜ë°
ê²Œì„ ì„œë²„ëŠ” 24ì‹œê°„ ì—°ì†ìœ¼ë¡œ ë™ì‘í•´ì•¼ í•˜ëŠ” íŠ¹ì„±ìƒ Windows ì„œë¹„ìŠ¤ë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë‹¤. ì´ ì¥ì—ì„œëŠ” ê²Œì„ ì„œë²„ë¥¼ ì•ˆì •ì ì¸ Windows ì„œë¹„ìŠ¤ë¡œ ê°œë°œí•˜ê³  ë°°í¬í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¬ë‹¤.

## 10.1 Windows ì„œë¹„ìŠ¤ ê¸°ì´ˆ

### 10.1.1 ì„œë¹„ìŠ¤ì˜ íŠ¹ì§•ê³¼ ì¥ì 
Windows ì„œë¹„ìŠ¤ëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰ë˜ëŠ” íŠ¹ë³„í•œ í˜•íƒœì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ë‹¤. ê²Œì„ ì„œë²„ì— ì í•©í•œ ì´ìœ ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚            Windows System                â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚  Session 0 (Services)                    â”‚
   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚ â”‚ â”‚
   â”‚  â”‚  â”‚Game Srv â”‚  â”‚Database â”‚         â”‚ â”‚ â”‚
   â”‚  â”‚  â”‚Service  â”‚  â”‚Service  â”‚   ...   â”‚ â”‚ â”‚
   â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚ â”‚ â”‚
   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚  Session 1+ (Interactive Sessions)       â”‚
   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚  â”‚  User Applications                  â”‚ â”‚
   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ì„œë¹„ìŠ¤ì˜ ì£¼ìš” ì¥ì :
- ì‹œìŠ¤í…œ ë¶€íŒ… ì‹œ ìë™ ì‹œì‘
- ì‚¬ìš©ì ë¡œê·¸ì•„ì›ƒê³¼ ë¬´ê´€í•˜ê²Œ ë™ì‘
- ì‹œìŠ¤í…œ ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥
- SCM(Service Control Manager)ì„ í†µí•œ ê´€ë¦¬

### 10.1.2 ê¸°ë³¸ ì„œë¹„ìŠ¤ í…œí”Œë¦¿
ë‹¤ìŒì€ ê²Œì„ ì„œë²„ ì„œë¹„ìŠ¤ì˜ ê¸°ë³¸ êµ¬ì¡°ì´ë‹¤:

```cpp
#include <windows.h>
#include <winsvc.h>
#include <tchar.h>
#include <strsafe.h>
#include <iostream>
#include <thread>
#include <atomic>

#define SVCNAME TEXT("GameServerService")

class GameServerService {
private:
    SERVICE_STATUS          gSvcStatus;
    SERVICE_STATUS_HANDLE   gSvcStatusHandle;
    HANDLE                  ghSvcStopEvent = nullptr;
    std::atomic<bool>       m_running{false};
    std::thread             m_gameThread;

public:
    void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void WINAPI ServiceCtrlHandler(DWORD dwCtrl);
    void ReportSvcStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);
    void SvcInit(DWORD dwArgc, LPTSTR* lpszArgv);
    void SvcReportEvent(LPTSTR szFunction);
    
    // ê²Œì„ ì„œë²„ ë¡œì§
    void GameServerLoop();
    void StartGameServer();
    void StopGameServer();
};

// ì „ì—­ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
GameServerService g_service;

// ì„œë¹„ìŠ¤ ë©”ì¸ í•¨ìˆ˜ ë˜í¼
void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv) {
    g_service.ServiceMain(dwArgc, lpszArgv);
}

// ì„œë¹„ìŠ¤ ì œì–´ í•¸ë“¤ëŸ¬ ë˜í¼
void WINAPI ServiceCtrlHandler(DWORD dwCtrl) {
    g_service.ServiceCtrlHandler(dwCtrl);
}

void GameServerService::ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv) {
    // ì„œë¹„ìŠ¤ ì œì–´ í•¸ë“¤ëŸ¬ ë“±ë¡
    gSvcStatusHandle = RegisterServiceCtrlHandler(
        SVCNAME,
        ServiceCtrlHandler);

    if (!gSvcStatusHandle) {
        SvcReportEvent(TEXT("RegisterServiceCtrlHandler"));
        return;
    }

    // ì„œë¹„ìŠ¤ ìƒíƒœ ì´ˆê¸°í™”
    gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    gSvcStatus.dwServiceSpecificExitCode = 0;

    // ì„œë¹„ìŠ¤ ì‹œì‘ ìƒíƒœ ë³´ê³ 
    ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

    // ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ìˆ˜í–‰
    SvcInit(dwArgc, lpszArgv);
}

void GameServerService::SvcInit(DWORD dwArgc, LPTSTR* lpszArgv) {
    // ì •ì§€ ì´ë²¤íŠ¸ ìƒì„±
    ghSvcStopEvent = CreateEvent(
        nullptr,    // ê¸°ë³¸ ë³´ì•ˆ ì†ì„±
        TRUE,       // ìˆ˜ë™ ë¦¬ì…‹ ì´ë²¤íŠ¸
        FALSE,      // ì´ˆê¸° ìƒíƒœëŠ” non-signaled
        nullptr);   // ì´ë¦„ ì—†ìŒ

    if (ghSvcStopEvent == nullptr) {
        ReportSvcStatus(SERVICE_STOPPED, GetLastError(), 0);
        return;
    }

    // ì„œë¹„ìŠ¤ ì‹¤í–‰ ì¤‘ ìƒíƒœ ë³´ê³ 
    ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);

    // ê²Œì„ ì„œë²„ ì‹œì‘
    StartGameServer();

    // ì •ì§€ ì‹ í˜¸ ëŒ€ê¸°
    WaitForSingleObject(ghSvcStopEvent, INFINITE);

    // ê²Œì„ ì„œë²„ ì •ì§€
    StopGameServer();

    ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
}

void GameServerService::StartGameServer() {
    m_running = true;
    m_gameThread = std::thread(&GameServerService::GameServerLoop, this);
}

void GameServerService::StopGameServer() {
    m_running = false;
    if (m_gameThread.joinable()) {
        m_gameThread.join();
    }
}

void GameServerService::GameServerLoop() {
    // ì‹¤ì œ ê²Œì„ ì„œë²„ ë¡œì§
    while (m_running) {
        // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì²˜ë¦¬
        // ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸
        // ë„¤íŠ¸ì›Œí¬ I/O ì²˜ë¦¬
        // ...
        
        // CPU ì‚¬ìš©ë¥  ì¡°ì ˆ
        Sleep(1);
    }
}

void GameServerService::ServiceCtrlHandler(DWORD dwCtrl) {
    switch (dwCtrl) {
    case SERVICE_CONTROL_STOP:
        ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);
        SetEvent(ghSvcStopEvent);
        ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;

    default:
        break;
    }
}

void GameServerService::ReportSvcStatus(DWORD dwCurrentState,
    DWORD dwWin32ExitCode,
    DWORD dwWaitHint) {
    static DWORD dwCheckPoint = 1;

    gSvcStatus.dwCurrentState = dwCurrentState;
    gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
    gSvcStatus.dwWaitHint = dwWaitHint;

    if (dwCurrentState == SERVICE_START_PENDING)
        gSvcStatus.dwControlsAccepted = 0;
    else
        gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    if ((dwCurrentState == SERVICE_RUNNING) ||
        (dwCurrentState == SERVICE_STOPPED))
        gSvcStatus.dwCheckPoint = 0;
    else
        gSvcStatus.dwCheckPoint = dwCheckPoint++;

    SetServiceStatus(gSvcStatusHandle, &gSvcStatus);
}

void GameServerService::SvcReportEvent(LPTSTR szFunction) {
    HANDLE hEventSource;
    LPCTSTR lpszStrings[2];
    TCHAR Buffer[80];

    hEventSource = RegisterEventSource(nullptr, SVCNAME);

    if (hEventSource != nullptr) {
        StringCchPrintf(Buffer, 80, TEXT("%s failed with %d"), szFunction, GetLastError());

        lpszStrings[0] = SVCNAME;
        lpszStrings[1] = Buffer;

        ReportEvent(hEventSource,
            EVENTLOG_ERROR_TYPE,
            0,
            0,
            nullptr,
            2,
            0,
            lpszStrings,
            nullptr);

        DeregisterEventSource(hEventSource);
    }
}

int main() {
    SERVICE_TABLE_ENTRY DispatchTable[] = {
        { SVCNAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain },
        { nullptr, nullptr }
    };

    if (!StartServiceCtrlDispatcher(DispatchTable)) {
        SvcReportEvent(TEXT("StartServiceCtrlDispatcher"));
    }

    return 0;
}
```
    
ì´ ì˜ˆì œëŠ” **Windows ì„œë¹„ìŠ¤(Windows Service)** í˜•íƒœë¡œ ì‹¤í–‰ë˜ëŠ” **ê²Œì„ ì„œë²„ì˜ ê¸°ë³¸ í…œí”Œë¦¿**ì´ë‹¤.
ë³´í†µ ê²Œì„ ì„œë²„ëŠ” ë‹¨ìˆœí•œ ì½˜ì†” í”„ë¡œê·¸ë¨ì´ ì•„ë‹ˆë¼, **ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì§€ì†ì ìœ¼ë¡œ ì‹¤í–‰**ë˜ë©° **ìš´ì˜ì²´ì œì˜ ì„œë¹„ìŠ¤ ê´€ë¦¬ì(Service Control Manager)** ì— ì˜í•´ ì œì–´ë˜ì–´ì•¼ í•œë‹¤.

ì¦‰, ì„œë²„ë¥¼ ì‹œì‘í•˜ê±°ë‚˜ ì¤‘ì§€í•  ë•Œ ì‚¬ìš©ìê°€ ì§ì ‘ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼,
ìš´ì˜ì²´ì œ ìˆ˜ì¤€ì—ì„œ ê´€ë¦¬ë˜ëŠ” ì„œë¹„ìŠ¤ë¡œ ë“±ë¡í•˜ì—¬ **ìë™ ì‹œì‘**, **ì •ìƒ ì¢…ë£Œ**, **ìƒíƒœ ë³´ê³ ** ë“±ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡ ë§Œë“ ë‹¤.


#### ğŸ§  ì „ì²´ êµ¬ì¡° ê°œìš”
ì´ë²ˆ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ íë¦„ìœ¼ë¡œ êµ¬ì„±ëœë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main()                      â”‚
â”‚ â””â”€ StartServiceCtrlDispatcher() í˜¸ì¶œ  â”‚
â”‚     â†“                        â”‚
â”‚ ServiceMain()                â”‚
â”‚ â”œâ”€ RegisterServiceCtrlHandlerâ”‚
â”‚ â”œâ”€ ReportSvcStatus()         â”‚
â”‚ â””â”€ SvcInit()                 â”‚
â”‚     â”œâ”€ StartGameServer()     â”‚
â”‚     â””â”€ WaitForSingleObject() â”‚
â”‚          â†“                   â”‚
â”‚     StopGameServer()         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ê° í•¨ìˆ˜ì˜ ì—­í• ì„ í•œ ë‹¨ê³„ì”© ë‚˜ëˆ„ì–´ ì„¤ëª…í•˜ê² ë‹¤.

#### 1ï¸âƒ£ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ ê°œìš”

```cpp
class GameServerService {
private:
    SERVICE_STATUS          gSvcStatus;
    SERVICE_STATUS_HANDLE   gSvcStatusHandle;
    HANDLE                  ghSvcStopEvent = nullptr;
    std::atomic<bool>       m_running{false};
    std::thread             m_gameThread;

public:
    void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void WINAPI ServiceCtrlHandler(DWORD dwCtrl);
    void ReportSvcStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);
    void SvcInit(DWORD dwArgc, LPTSTR* lpszArgv);
    void SvcReportEvent(LPTSTR szFunction);
    
    void GameServerLoop();
    void StartGameServer();
    void StopGameServer();
};
```

**ì„¤ëª…**

* `SERVICE_STATUS`ì™€ `SERVICE_STATUS_HANDLE`ì€ Windows ì„œë¹„ìŠ¤ì˜ ìƒíƒœë¥¼ ìš´ì˜ì²´ì œì— ë³´ê³ í•˜ê¸° ìœ„í•´ ì‚¬ìš©ëœë‹¤.
* `ghSvcStopEvent`ëŠ” ì„œë¹„ìŠ¤ê°€ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ë¥¼ ê°ì‹œí•˜ê¸° ìœ„í•œ ì´ë²¤íŠ¸ í•¸ë“¤ì´ë‹¤.
* `m_gameThread`ëŠ” ì‹¤ì œ ê²Œì„ ì„œë²„ ë¡œì§ì„ ì‹¤í–‰í•˜ëŠ” ìŠ¤ë ˆë“œì´ë‹¤.

ì¦‰, ì´ í´ë˜ìŠ¤ëŠ” **ì„œë¹„ìŠ¤ ê´€ë¦¬ ë¡œì§ + ê²Œì„ ì„œë²„ ì‹¤í–‰ ë¡œì§**ì„ í•¨ê»˜ ê´€ë¦¬í•˜ëŠ” í•µì‹¬ ê°ì²´ì´ë‹¤.


#### 2ï¸âƒ£ ì„œë¹„ìŠ¤ ì‹œì‘ ì§„ì…ì 
Windows ì„œë¹„ìŠ¤ëŠ” ì¼ë°˜ í”„ë¡œê·¸ë¨ê³¼ ë‹¬ë¦¬ `main()` í•¨ìˆ˜ê°€ ì§ì ‘ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤.
ì„œë¹„ìŠ¤ ì œì–´ ê´€ë¦¬ì(SCM, Service Control Manager)ê°€ ë¨¼ì € ì‹¤í–‰ë˜ê³ ,
ë“±ë¡ëœ `ServiceMain()` í•¨ìˆ˜ë¡œ ì§„ì…í•˜ê²Œ ëœë‹¤.

```cpp
int main() {
    SERVICE_TABLE_ENTRY DispatchTable[] = {
        { SVCNAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain },
        { nullptr, nullptr }
    };

    if (!StartServiceCtrlDispatcher(DispatchTable)) {
        SvcReportEvent(TEXT("StartServiceCtrlDispatcher"));
    }

    return 0;
}
```

**ì„¤ëª…**

* `StartServiceCtrlDispatcher()`ëŠ” ì„œë¹„ìŠ¤ ì‹¤í–‰ì„ ìš´ì˜ì²´ì œì— ë“±ë¡í•œë‹¤.
* ë“±ë¡ í›„, SCMì€ `ServiceMain()`ì„ í˜¸ì¶œí•˜ì—¬ ì„œë¹„ìŠ¤ ì‹¤í–‰ì„ ì‹œì‘í•œë‹¤.
* ì´ ê³¼ì •ì€ ì½˜ì†” í”„ë¡œê·¸ë¨ì˜ `main()`ê³¼ ë‹¬ë¦¬ **ìš´ì˜ì²´ì œê°€ ì§ì ‘ í˜¸ì¶œ**í•œë‹¤ëŠ” ì ì´ í•µì‹¬ì´ë‹¤.


#### 3ï¸âƒ£ ì„œë¹„ìŠ¤ ë©”ì¸ ì§„ì… ë° ì´ˆê¸°í™”

```cpp
void GameServerService::ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv) {
    gSvcStatusHandle = RegisterServiceCtrlHandler(SVCNAME, ServiceCtrlHandler);

    if (!gSvcStatusHandle) {
        SvcReportEvent(TEXT("RegisterServiceCtrlHandler"));
        return;
    }

    gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    gSvcStatus.dwServiceSpecificExitCode = 0;

    ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000);
    SvcInit(dwArgc, lpszArgv);
}
```

**ì„¤ëª…**

* `RegisterServiceCtrlHandler()`ëŠ” **ì„œë¹„ìŠ¤ ì œì–´ ì´ë²¤íŠ¸**(ì˜ˆ: ì •ì§€ ëª…ë ¹, ì¬ì‹œì‘ ëª…ë ¹)ë¥¼ ì²˜ë¦¬í•  í•¸ë“¤ëŸ¬ë¥¼ ë“±ë¡í•œë‹¤.
* ì´í›„ `SvcInit()`ì„ í˜¸ì¶œí•˜ì—¬ ì‹¤ì œ ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ê³¼ì •ì„ ìˆ˜í–‰í•œë‹¤.


#### 4ï¸âƒ£ ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ë° ì‹¤í–‰ ë£¨í”„

```cpp
void GameServerService::SvcInit(DWORD dwArgc, LPTSTR* lpszArgv) {
    ghSvcStopEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
    if (ghSvcStopEvent == nullptr) {
        ReportSvcStatus(SERVICE_STOPPED, GetLastError(), 0);
        return;
    }

    ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);
    StartGameServer();

    WaitForSingleObject(ghSvcStopEvent, INFINITE);

    StopGameServer();
    ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
}
```

**ì„¤ëª…**

* `CreateEvent()`ë¡œ ì„œë¹„ìŠ¤ ì¢…ë£Œë¥¼ ê°ì§€í•  ì´ë²¤íŠ¸ë¥¼ ìƒì„±í•œë‹¤.
* `ReportSvcStatus(SERVICE_RUNNING)`ì„ í†µí•´ â€œì„œë¹„ìŠ¤ê°€ ì •ìƒ ì‹¤í–‰ ì¤‘ì„â€ì„ OSì— ë³´ê³ í•œë‹¤.
* `StartGameServer()`ë¥¼ í†µí•´ ê²Œì„ ì„œë²„ ì‹¤í–‰ ìŠ¤ë ˆë“œë¥¼ ì‹œì‘í•œë‹¤.
* ì´í›„ `WaitForSingleObject()`ë¡œ ì¢…ë£Œ ì‹ í˜¸(`ghSvcStopEvent`)ë¥¼ ëŒ€ê¸°í•œë‹¤.

ì¦‰, ì„œë¹„ìŠ¤ëŠ” **ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œê¹Œì§€ ê³„ì† ì‹¤í–‰ ìƒíƒœë¥¼ ìœ ì§€**í•œë‹¤.


#### 5ï¸âƒ£ ê²Œì„ ì„œë²„ ì‹¤í–‰ ë° ì¢…ë£Œ ë¡œì§

```cpp
void GameServerService::StartGameServer() {
    m_running = true;
    m_gameThread = std::thread(&GameServerService::GameServerLoop, this);
}

void GameServerService::StopGameServer() {
    m_running = false;
    if (m_gameThread.joinable()) {
        m_gameThread.join();
    }
}
```

**ì„¤ëª…**

* `StartGameServer()`ëŠ” ìƒˆë¡œìš´ ìŠ¤ë ˆë“œë¥¼ ë§Œë“¤ì–´ ê²Œì„ ì„œë²„ ë©”ì¸ ë£¨í”„ë¥¼ ì‹¤í–‰í•œë‹¤.
* `StopGameServer()`ëŠ” `m_running`ì„ `false`ë¡œ ë°”ê¾¸ì–´ ë£¨í”„ë¥¼ ì¢…ë£Œì‹œí‚¤ê³  ìŠ¤ë ˆë“œë¥¼ í•©ë¥˜(`join`)ì‹œí‚¨ë‹¤.


#### 6ï¸âƒ£ ê²Œì„ ì„œë²„ ë©”ì¸ ë£¨í”„

```cpp
void GameServerService::GameServerLoop() {
    while (m_running) {
        // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì²˜ë¦¬
        // ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸
        // ë„¤íŠ¸ì›Œí¬ I/O ì²˜ë¦¬
        Sleep(1);
    }
}
```

**ì„¤ëª…**

* ì„œë²„ì˜ í•µì‹¬ ë¡œì§ì´ ëŒì•„ê°€ëŠ” ë¶€ë¶„ì´ë‹¤.
* ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ì²˜ë¦¬, ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸, DB ì €ì¥ ë“±ì„ ìˆ˜í–‰í•œë‹¤.
* `Sleep(1)`ì„ ë„£ì–´ CPU ì ìœ ìœ¨ì„ ë‚®ì¶”ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.


#### 7ï¸âƒ£ ì„œë¹„ìŠ¤ ì œì–´ ì´ë²¤íŠ¸ ì²˜ë¦¬

```cpp
void GameServerService::ServiceCtrlHandler(DWORD dwCtrl) {
    switch (dwCtrl) {
    case SERVICE_CONTROL_STOP:
        ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);
        SetEvent(ghSvcStopEvent);
        ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0);
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    default:
        break;
    }
}
```

**ì„¤ëª…**

* ì„œë¹„ìŠ¤ ì œì–´ ê´€ë¦¬ì(SCM)ê°€ â€œì¤‘ì§€â€ ëª…ë ¹ì„ ë‚´ë¦¬ë©´ ì´ í•¨ìˆ˜ê°€ í˜¸ì¶œëœë‹¤.
* `SetEvent(ghSvcStopEvent)`ê°€ ì‹¤í–‰ë˜ì–´ ì„œë¹„ìŠ¤ ë£¨í”„(`WaitForSingleObject`)ë¥¼ ê¹¨ìš°ê³  ì¢…ë£Œ ê³¼ì •ì„ ì‹œì‘í•œë‹¤.


#### 8ï¸âƒ£ ì„œë¹„ìŠ¤ ìƒíƒœ ë³´ê³ 

```cpp
void GameServerService::ReportSvcStatus(DWORD dwCurrentState,
    DWORD dwWin32ExitCode,
    DWORD dwWaitHint) {
    static DWORD dwCheckPoint = 1;

    gSvcStatus.dwCurrentState = dwCurrentState;
    gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
    gSvcStatus.dwWaitHint = dwWaitHint;

    if (dwCurrentState == SERVICE_START_PENDING)
        gSvcStatus.dwControlsAccepted = 0;
    else
        gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    if ((dwCurrentState == SERVICE_RUNNING) ||
        (dwCurrentState == SERVICE_STOPPED))
        gSvcStatus.dwCheckPoint = 0;
    else
        gSvcStatus.dwCheckPoint = dwCheckPoint++;

    SetServiceStatus(gSvcStatusHandle, &gSvcStatus);
}
```

**ì„¤ëª…**

* ì„œë¹„ìŠ¤ì˜ í˜„ì¬ ìƒíƒœ(ì‹œì‘ ì¤‘, ì‹¤í–‰ ì¤‘, ì¢…ë£Œ ì¤‘ ë“±)ë¥¼ ìš´ì˜ì²´ì œì— ë³´ê³ í•œë‹¤.
* SCMì€ ì´ ì •ë³´ë¥¼ ì´ìš©í•´ ì„œë¹„ìŠ¤ ìƒíƒœë¥¼ ëª¨ë‹ˆí„°ë§í•œë‹¤.


#### 9ï¸âƒ£ ì´ë²¤íŠ¸ ë¡œê·¸ ê¸°ë¡

```cpp
void GameServerService::SvcReportEvent(LPTSTR szFunction) {
    HANDLE hEventSource;
    LPCTSTR lpszStrings[2];
    TCHAR Buffer[80];

    hEventSource = RegisterEventSource(nullptr, SVCNAME);

    if (hEventSource != nullptr) {
        StringCchPrintf(Buffer, 80, TEXT("%s failed with %d"), szFunction, GetLastError());
        lpszStrings[0] = SVCNAME;
        lpszStrings[1] = Buffer;

        ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0, 0, nullptr, 2, 0, lpszStrings, nullptr);
        DeregisterEventSource(hEventSource);
    }
}
```

**ì„¤ëª…**

* ì„œë¹„ìŠ¤ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë©´ Windows ì´ë²¤íŠ¸ ë¡œê·¸ì— ê¸°ë¡í•œë‹¤.
* ê´€ë¦¬ìëŠ” ì´ë²¤íŠ¸ ë·°ì–´(Event Viewer)ì—ì„œ ì˜¤ë¥˜ ë‚´ì—­ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.


#### ğŸ§© ì„œë¹„ìŠ¤ íë¦„ ìš”ì•½ (Mermaid Diagram)

```mermaid
sequenceDiagram
    participant OS as Service Control Manager
    participant GS as GameServerService
    participant Thread as GameServerThread

    OS->>GS: StartServiceCtrlDispatcher()
    OS->>GS: ServiceMain()
    GS->>OS: ReportSvcStatus(SERVICE_START_PENDING)
    GS->>GS: SvcInit()
    GS->>Thread: StartGameServer()
    Thread->>Thread: GameServerLoop() (while running)
    OS->>GS: SERVICE_CONTROL_STOP
    GS->>Thread: StopGameServer()
    GS->>OS: ReportSvcStatus(SERVICE_STOPPED)
```

#### ğŸ¯ ê²°ë¡ 
ì´ ì½”ë“œëŠ” **Windows ì„œë¹„ìŠ¤ í˜•íƒœë¡œ ë™ì‘í•˜ëŠ” ê²Œì„ ì„œë²„ì˜ ê¸°ë³¸ ê³¨ê²©**ì´ë‹¤.
ìš´ì˜ì²´ì œì˜ ì„œë¹„ìŠ¤ ê´€ë¦¬ ê¸°ëŠ¥ì„ ì´ìš©í•˜ë©´,

* ì„œë²„ì˜ ìë™ ì‹œì‘ ë° ì¢…ë£Œ,
* ì¥ì•  ë°œìƒ ì‹œ ì´ë²¤íŠ¸ ë¡œê·¸ ê¸°ë¡,
* ì„œë¹„ìŠ¤ ìƒíƒœ ëª¨ë‹ˆí„°ë§,
* ì•ˆì „í•œ ë©€í‹°ìŠ¤ë ˆë“œ ì‹¤í–‰

ì„ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

ì¦‰, ì´ ì˜ˆì œëŠ” ì½˜ì†” í”„ë¡œê·¸ë¨ì´ ì•„ë‹Œ **ìš´ì˜ì²´ì œì— ì™„ì „íˆ í†µí•©ëœ ì„œë¹„ìŠ¤í˜• ê²Œì„ ì„œë²„**ë¥¼ ë§Œë“œëŠ” ê¸°ì´ˆê°€ ë˜ëŠ” ì½”ë“œë¼ê³  í•  ìˆ˜ ìˆë‹¤.


</br>  

## 10.2 ì„œë¹„ìŠ¤ ì œì–´ ê´€ë¦¬ì (SCM) ì—°ë™

### 10.2.1 ì„œë¹„ìŠ¤ ì„¤ì¹˜ ë° ì œê±°
ì„œë¹„ìŠ¤ë¥¼ ì‹œìŠ¤í…œì— ë“±ë¡í•˜ê³  ì œê±°í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•´ë³´ê² ë‹¤:

```cpp
#include <windows.h>
#include <winsvc.h>
#include <tchar.h>
#include <iostream>

class ServiceInstaller {
private:
    static constexpr LPCTSTR SERVICE_NAME = TEXT("GameServerService");
    static constexpr LPCTSTR DISPLAY_NAME = TEXT("Game Server Service");
    static constexpr LPCTSTR DESCRIPTION = TEXT("High-performance game server service");

public:
    static bool InstallService(LPCTSTR servicePath);
    static bool UninstallService();
    static bool StartService();
    static bool StopService();
    static void PrintServiceStatus();
};

bool ServiceInstaller::InstallService(LPCTSTR servicePath) {
    SC_HANDLE schSCManager = nullptr;
    SC_HANDLE schService = nullptr;

    // SCM ì—´ê¸°
    schSCManager = OpenSCManager(
        nullptr,                   // ë¡œì»¬ ì»´í“¨í„°
        nullptr,                   // ServicesActive ë°ì´í„°ë² ì´ìŠ¤
        SC_MANAGER_ALL_ACCESS);    // ëª¨ë“  ì ‘ê·¼ ê¶Œí•œ

    if (schSCManager == nullptr) {
        std::wcout << L"OpenSCManager failed: " << GetLastError() << std::endl;
        return false;
    }

    // ì„œë¹„ìŠ¤ ìƒì„±
    schService = CreateService(
        schSCManager,              // SCM í•¸ë“¤
        SERVICE_NAME,              // ì„œë¹„ìŠ¤ ì´ë¦„
        DISPLAY_NAME,              // í‘œì‹œ ì´ë¦„
        SERVICE_ALL_ACCESS,        // ì›í•˜ëŠ” ì ‘ê·¼ ê¶Œí•œ
        SERVICE_WIN32_OWN_PROCESS, // ì„œë¹„ìŠ¤ íƒ€ì…
        SERVICE_AUTO_START,        // ì‹œì‘ íƒ€ì…
        SERVICE_ERROR_NORMAL,      // ì—ëŸ¬ ì œì–´ íƒ€ì…
        servicePath,               // ì„œë¹„ìŠ¤ ë°”ì´ë„ˆë¦¬ ê²½ë¡œ
        nullptr,                   // ë¡œë“œ ìˆœì„œ ê·¸ë£¹ ì—†ìŒ
        nullptr,                   // íƒœê·¸ ID ì—†ìŒ
        nullptr,                   // ì¢…ì†ì„± ì—†ìŒ
        nullptr,                   // LocalSystem ê³„ì •
        nullptr);                  // íŒ¨ìŠ¤ì›Œë“œ ì—†ìŒ

    if (schService == nullptr) {
        DWORD error = GetLastError();
        if (error == ERROR_SERVICE_EXISTS) {
            std::wcout << L"Service already exists!" << std::endl;
        } else {
            std::wcout << L"CreateService failed: " << error << std::endl;
        }
        CloseServiceHandle(schSCManager);
        return false;
    }

    // ì„œë¹„ìŠ¤ ì„¤ëª… ì„¤ì •
    SERVICE_DESCRIPTION sd;
    sd.lpDescription = const_cast<LPTSTR>(DESCRIPTION);
    ChangeServiceConfig2(schService, SERVICE_CONFIG_DESCRIPTION, &sd);

    // ì‹¤íŒ¨ ì‹œ ë™ì‘ ì„¤ì • (ìë™ ì¬ì‹œì‘)
    SC_ACTION actions[3];
    actions[0].Type = SC_ACTION_RESTART;
    actions[0].Delay = 5000; // 5ì´ˆ í›„ ì¬ì‹œì‘
    actions[1].Type = SC_ACTION_RESTART;
    actions[1].Delay = 10000; // 10ì´ˆ í›„ ì¬ì‹œì‘
    actions[2].Type = SC_ACTION_NONE;
    actions[2].Delay = 0;

    SERVICE_FAILURE_ACTIONS sfa;
    sfa.dwResetPeriod = 86400; // 24ì‹œê°„
    sfa.lpRebootMsg = nullptr;
    sfa.lpCommand = nullptr;
    sfa.cActions = 3;
    sfa.lpsaActions = actions;

    ChangeServiceConfig2(schService, SERVICE_CONFIG_FAILURE_ACTIONS, &sfa);

    std::wcout << L"Service installed successfully!" << std::endl;

    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
    return true;
}

bool ServiceInstaller::UninstallService() {
    SC_HANDLE schSCManager = nullptr;
    SC_HANDLE schService = nullptr;
    SERVICE_STATUS status;

    schSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
    if (schSCManager == nullptr) {
        std::wcout << L"OpenSCManager failed: " << GetLastError() << std::endl;
        return false;
    }

    schService = OpenService(schSCManager, SERVICE_NAME, DELETE | SERVICE_STOP | SERVICE_QUERY_STATUS);
    if (schService == nullptr) {
        std::wcout << L"OpenService failed: " << GetLastError() << std::endl;
        CloseServiceHandle(schSCManager);
        return false;
    }

    // ì„œë¹„ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ì´ë©´ ì •ì§€
    if (QueryServiceStatus(schService, &status)) {
        if (status.dwCurrentState != SERVICE_STOPPED) {
            std::wcout << L"Stopping service..." << std::endl;
            ControlService(schService, SERVICE_CONTROL_STOP, &status);
            
            // ì •ì§€ë  ë•Œê¹Œì§€ ëŒ€ê¸°
            while (QueryServiceStatus(schService, &status)) {
                if (status.dwCurrentState == SERVICE_STOPPED) {
                    break;
                }
                Sleep(1000);
            }
        }
    }

    // ì„œë¹„ìŠ¤ ì‚­ì œ
    if (DeleteService(schService)) {
        std::wcout << L"Service uninstalled successfully!" << std::endl;
    } else {
        std::wcout << L"DeleteService failed: " << GetLastError() << std::endl;
    }

    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
    return true;
}

void ServiceInstaller::PrintServiceStatus() {
    SC_HANDLE schSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (schSCManager == nullptr) return;

    SC_HANDLE schService = OpenService(schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS);
    if (schService == nullptr) {
        std::wcout << L"Service not found!" << std::endl;
        CloseServiceHandle(schSCManager);
        return;
    }

    SERVICE_STATUS_PROCESS status;
    DWORD bytesNeeded;
    if (QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO,
        (LPBYTE)&status, sizeof(status), &bytesNeeded)) {
        
        std::wcout << L"Service Status: ";
        switch (status.dwCurrentState) {
        case SERVICE_STOPPED:
            std::wcout << L"STOPPED"; break;
        case SERVICE_START_PENDING:
            std::wcout << L"START_PENDING"; break;
        case SERVICE_STOP_PENDING:
            std::wcout << L"STOP_PENDING"; break;
        case SERVICE_RUNNING:
            std::wcout << L"RUNNING"; break;
        case SERVICE_CONTINUE_PENDING:
            std::wcout << L"CONTINUE_PENDING"; break;
        case SERVICE_PAUSE_PENDING:
            std::wcout << L"PAUSE_PENDING"; break;
        case SERVICE_PAUSED:
            std::wcout << L"PAUSED"; break;
        default:
            std::wcout << L"UNKNOWN"; break;
        }
        std::wcout << L" (PID: " << status.dwProcessId << L")" << std::endl;
    }

    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
}
```
  
ì´ ì˜ˆì œì—ì„œëŠ” **ê²Œì„ ì„œë²„ ì„œë¹„ìŠ¤ë¥¼ Windows ì‹œìŠ¤í…œì— ì„¤ì¹˜(ë“±ë¡)**í•˜ê³ , í•„ìš” ì‹œ **ì œê±°(ì‚­ì œ)**í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•œë‹¤.
ì´ ì½”ë“œëŠ” ì‹¤ì œ ì„œë¹„ìŠ¤ ì‹¤í–‰ ë¡œì§(ê²Œì„ ì„œë²„ êµ¬ë™ ë¶€ë¶„)ì´ ì•„ë‹ˆë¼, ê·¸ ì„œë¹„ìŠ¤ë¥¼ **ì‹œìŠ¤í…œì˜ ì„œë¹„ìŠ¤ ê´€ë¦¬ ë„êµ¬(SCM, Service Control Manager)** ì— **ë“±ë¡í•˜ê³  ì œì–´í•˜ê¸° ìœ„í•œ ê´€ë¦¬ì ë„êµ¬**ì´ë‹¤.

ì¦‰, ìš°ë¦¬ê°€ ë§Œë“  `GameServerService`ë¥¼

> â€œWindowsê°€ ìë™ìœ¼ë¡œ ì‹¤í–‰í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆë„ë¡ ë“±ë¡í•˜ëŠ” ì—­í• â€
> ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ë‹¤.


#### ğŸ§© ì „ì²´ êµ¬ì¡° ê°œìš”
ì½”ë“œëŠ” `ServiceInstaller`ë¼ëŠ” í´ë˜ìŠ¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°, ì„œë¹„ìŠ¤ì˜ ìƒëª…ì£¼ê¸°ë¥¼ ê´€ë¦¬í•œë‹¤.

```mermaid
classDiagram
    class ServiceInstaller {
        +InstallService(servicePath)
        +UninstallService()
        +PrintServiceStatus()
        +StartService()
        +StopService()
    }
```

ì´ ì¤‘ ì£¼ìš” ê¸°ëŠ¥ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

| í•¨ìˆ˜                               | ì—­í•                       |
| -------------------------------- | ----------------------- |
| `InstallService()`               | Windowsì— ì„œë¹„ìŠ¤ë¥¼ ë“±ë¡í•œë‹¤      |
| `UninstallService()`             | ë“±ë¡ëœ ì„œë¹„ìŠ¤ë¥¼ ì œê±°í•œë‹¤           |
| `PrintServiceStatus()`           | ì„œë¹„ìŠ¤ì˜ í˜„ì¬ ì‹¤í–‰ ìƒíƒœë¥¼ ì¶œë ¥í•œë‹¤     |
| `StartService() / StopService()` | (ì¶”ê°€ ê¸°ëŠ¥) ì„œë¹„ìŠ¤ ì‹¤í–‰ ë° ì •ì§€ ì œì–´ìš© |


#### 1ï¸âƒ£ ì„œë¹„ìŠ¤ ì„¤ì¹˜ í•¨ìˆ˜ (`InstallService`)

```cpp
bool ServiceInstaller::InstallService(LPCTSTR servicePath) {
    SC_HANDLE schSCManager = nullptr;
    SC_HANDLE schService = nullptr;

    // SCM(ì„œë¹„ìŠ¤ ì œì–´ ê´€ë¦¬ì) ì—´ê¸°
    schSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
```

**ì„¤ëª…**

* `OpenSCManager()`ëŠ” **ì„œë¹„ìŠ¤ ì œì–´ ê´€ë¦¬ì(SCM)** ë¥¼ ì—°ë‹¤.
  SCMì€ Windowsì—ì„œ ëª¨ë“  ì„œë¹„ìŠ¤ë¥¼ ë“±ë¡Â·ê´€ë¦¬í•˜ëŠ” í•µì‹¬ ì‹œìŠ¤í…œ êµ¬ì„± ìš”ì†Œì´ë‹¤.
* `nullptr` ì¸ìëŠ” ë¡œì»¬ ì‹œìŠ¤í…œì—ì„œ ë™ì‘í•¨ì„ ì˜ë¯¸í•œë‹¤.
* `SC_MANAGER_ALL_ACCESS`ëŠ” ëª¨ë“  ì œì–´ ê¶Œí•œì„ ìš”ì²­í•œë‹¤.


#### 2ï¸âƒ£ ì„œë¹„ìŠ¤ ìƒì„±

```cpp
schService = CreateService(
    schSCManager,              
    SERVICE_NAME,              
    DISPLAY_NAME,              
    SERVICE_ALL_ACCESS,        
    SERVICE_WIN32_OWN_PROCESS, 
    SERVICE_AUTO_START,        
    SERVICE_ERROR_NORMAL,      
    servicePath,               
    nullptr, nullptr, nullptr, 
    nullptr, nullptr); 
```

**ì„¤ëª…**

* `CreateService()`ëŠ” ì‹¤ì œë¡œ **ì„œë¹„ìŠ¤ë¥¼ ì‹œìŠ¤í…œì— ë“±ë¡**í•œë‹¤.
* ì£¼ìš” ì¸ì ì˜ë¯¸ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

| ì¸ì                          | ì˜ë¯¸                                         |
| --------------------------- | ------------------------------------------ |
| `SERVICE_NAME`              | ë‚´ë¶€ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ì„œë¹„ìŠ¤ ì´ë¦„                          |
| `DISPLAY_NAME`              | ì œì–´íŒ ë“±ì—ì„œ í‘œì‹œë˜ëŠ” ì´ë¦„                            |
| `SERVICE_WIN32_OWN_PROCESS` | ì„œë¹„ìŠ¤ê°€ ë…ë¦½ í”„ë¡œì„¸ìŠ¤ë¡œ ì‹¤í–‰ë¨                          |
| `SERVICE_AUTO_START`        | ë¶€íŒ… ì‹œ ìë™ ì‹œì‘                                 |
| `servicePath`               | ì‹¤ì œ ì‹¤í–‰ íŒŒì¼ ê²½ë¡œ(ì˜ˆ: `C:\GameServer\server.exe`) |

**ì˜¤ë¥˜ ì²˜ë¦¬**

```cpp
if (schService == nullptr) {
    DWORD error = GetLastError();
    if (error == ERROR_SERVICE_EXISTS) {
        std::wcout << L"Service already exists!" << std::endl;
    } else {
        std::wcout << L"CreateService failed: " << error << std::endl;
    }
    CloseServiceHandle(schSCManager);
    return false;
}
```

ì„œë¹„ìŠ¤ê°€ ì´ë¯¸ ë“±ë¡ëœ ê²½ìš° ë˜ëŠ” ê¶Œí•œì´ ë¶€ì¡±í•  ê²½ìš° ì˜ˆì™¸ë¥¼ ì²˜ë¦¬í•œë‹¤.


#### 3ï¸âƒ£ ì„œë¹„ìŠ¤ ì„¤ëª… ë° ì‹¤íŒ¨ ì‹œ ë™ì‘ ì„¤ì •

```cpp
SERVICE_DESCRIPTION sd;
sd.lpDescription = const_cast<LPTSTR>(DESCRIPTION);
ChangeServiceConfig2(schService, SERVICE_CONFIG_DESCRIPTION, &sd);
```

**ì„¤ëª…**

* ì„œë¹„ìŠ¤ì˜ ì„¤ëª…ì„ ì¶”ê°€í•˜ì—¬ ê´€ë¦¬ìê°€ ë³´ê¸° ì‰½ê²Œ ë§Œë“ ë‹¤.
  (ì˜ˆ: â€œHigh-performance game server serviceâ€)

---

ë‹¤ìŒìœ¼ë¡œ, **ì„œë¹„ìŠ¤ ì‹¤íŒ¨ ì‹œ ì¬ì‹œì‘ ì •ì±…**ì„ ì„¤ì •í•œë‹¤.

```cpp
SC_ACTION actions[3];
actions[0].Type = SC_ACTION_RESTART;
actions[0].Delay = 5000; // 5ì´ˆ í›„ ì¬ì‹œì‘
actions[1].Type = SC_ACTION_RESTART;
actions[1].Delay = 10000; // 10ì´ˆ í›„ ì¬ì‹œì‘
actions[2].Type = SC_ACTION_NONE;

SERVICE_FAILURE_ACTIONS sfa;
sfa.dwResetPeriod = 86400; // 24ì‹œê°„ë§ˆë‹¤ ë¦¬ì…‹
sfa.cActions = 3;
sfa.lpsaActions = actions;

ChangeServiceConfig2(schService, SERVICE_CONFIG_FAILURE_ACTIONS, &sfa);
```

**ì„¤ëª…**

* ë§Œì•½ ì„œë²„ê°€ í¬ë˜ì‹œë‚˜ ì˜¤ë¥˜ë¡œ ì¢…ë£Œë˜ë©´, Windowsê°€ ìë™ìœ¼ë¡œ ì¬ì‹œì‘í•˜ë„ë¡ ì„¤ì •í•œë‹¤.
* ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œëŠ” ì„œë²„ ì•ˆì •ì„±ì„ ìœ„í•´ ë§¤ìš° ì¤‘ìš”í•œ ë¶€ë¶„ì´ë‹¤.

âœ… **ê²°ê³¼ ë©”ì‹œì§€ ì¶œë ¥**

```cpp
std::wcout << L"Service installed successfully!" << std::endl;
```


#### 4ï¸âƒ£ ì„œë¹„ìŠ¤ ì œê±° í•¨ìˆ˜ (`UninstallService`)

```cpp
bool ServiceInstaller::UninstallService() {
    SC_HANDLE schSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
    SC_HANDLE schService = OpenService(schSCManager, SERVICE_NAME, DELETE | SERVICE_STOP | SERVICE_QUERY_STATUS);
```

**ì„¤ëª…**

* `OpenService()`ë¥¼ í†µí•´ ì´ë¯¸ ë“±ë¡ëœ ì„œë¹„ìŠ¤ë¥¼ ë¶ˆëŸ¬ì˜¨ë‹¤.
* ì ‘ê·¼ ê¶Œí•œìœ¼ë¡œ `DELETE`, `SERVICE_STOP`, `SERVICE_QUERY_STATUS`ë¥¼ ìš”ì²­í•œë‹¤.


#### 5ï¸âƒ£ ì„œë¹„ìŠ¤ ì •ì§€ í›„ ì‚­ì œ

```cpp
if (QueryServiceStatus(schService, &status)) {
    if (status.dwCurrentState != SERVICE_STOPPED) {
        ControlService(schService, SERVICE_CONTROL_STOP, &status);
        while (QueryServiceStatus(schService, &status)) {
            if (status.dwCurrentState == SERVICE_STOPPED) break;
            Sleep(1000);
        }
    }
}
```

**ì„¤ëª…**

* ì„œë¹„ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ì´ë©´ `ControlService()`ë¡œ ì •ì§€ ëª…ë ¹ì„ ë³´ë‚¸ë‹¤.
* `QueryServiceStatus()`ë¥¼ ë°˜ë³µ í˜¸ì¶œí•˜ì—¬ **ì™„ì „íˆ ì •ì§€ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤.**

---

```cpp
if (DeleteService(schService)) {
    std::wcout << L"Service uninstalled successfully!" << std::endl;
} else {
    std::wcout << L"DeleteService failed: " << GetLastError() << std::endl;
}
```

**ì„¤ëª…**

* `DeleteService()`ë¥¼ í˜¸ì¶œí•˜ë©´ SCMì—ì„œ í•´ë‹¹ ì„œë¹„ìŠ¤ê°€ ì™„ì „íˆ ì œê±°ëœë‹¤.
* ì´í›„ `CloseServiceHandle()`ë¡œ ìì› ì •ë¦¬ë¥¼ í•œë‹¤.


#### 6ï¸âƒ£ ì„œë¹„ìŠ¤ ìƒíƒœ ì¶œë ¥ (`PrintServiceStatus`)

```cpp
SC_HANDLE schService = OpenService(schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS);
SERVICE_STATUS_PROCESS status;
DWORD bytesNeeded;

if (QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO,
    (LPBYTE)&status, sizeof(status), &bytesNeeded)) {
```

**ì„¤ëª…**

* `QueryServiceStatusEx()`ë¥¼ í†µí•´ ì„œë¹„ìŠ¤ì˜ í˜„ì¬ ìƒíƒœë¥¼ ê°€ì ¸ì˜¨ë‹¤.
* ê·¸ ê²°ê³¼ë¥¼ ì´ìš©í•´ ìƒíƒœë¥¼ êµ¬ë¶„í•˜ì—¬ ì¶œë ¥í•œë‹¤.

```cpp
switch (status.dwCurrentState) {
case SERVICE_STOPPED: std::wcout << L"STOPPED"; break;
case SERVICE_RUNNING: std::wcout << L"RUNNING"; break;
case SERVICE_PAUSED: std::wcout << L"PAUSED"; break;
default: std::wcout << L"UNKNOWN"; break;
}
std::wcout << L" (PID: " << status.dwProcessId << L")" << std::endl;
```

**ì¶œë ¥ ì˜ˆì‹œ**

```
Service Status: RUNNING (PID: 6524)
```


#### ğŸ§  ì„¤ì¹˜ ë° ì œê±° ë™ì‘ íë¦„ ìš”ì•½
ì•„ë˜ ë‹¤ì´ì–´ê·¸ë¨ì€ ì„œë¹„ìŠ¤ ì„¤ì¹˜ì™€ ì œê±° ê³¼ì •ì„ ë‹¨ê³„ë³„ë¡œ í‘œí˜„í•œ ê²ƒì´ë‹¤.

```mermaid
flowchart TD
    A["ê´€ë¦¬ì ì‹¤í–‰: ServiceInstaller"] --> B["OpenSCManager()ë¡œ SCM ì—´ê¸°"]
    B --> C["CreateService()ë¡œ ë“±ë¡"]
    C --> D["ì„¤ëª… ë° ì‹¤íŒ¨ ì •ì±… ì„¤ì •"]
    D --> E["ì„œë¹„ìŠ¤ ë“±ë¡ ì™„ë£Œ ë©”ì‹œì§€ ì¶œë ¥"]
    E --> F["UninstallService() í˜¸ì¶œ ì‹œ"]
    F --> G["OpenService()ë¡œ ì„œë¹„ìŠ¤ ì—´ê¸°"]
    G --> H["ì„œë¹„ìŠ¤ ì •ì§€ ëª…ë ¹ ì „ì†¡"]
    H --> I["DeleteService() í˜¸ì¶œ"]
    I --> J["ì„œë¹„ìŠ¤ ì œê±° ì™„ë£Œ"]
```


#### ğŸ§© ì½˜ì†” ëª…ë ¹ íë¦„ ì˜ˆì‹œ

```
> GameServerInstaller.exe install "C:\GameServer\server.exe"
Service installed successfully!

> GameServerInstaller.exe status
Service Status: RUNNING (PID: 6524)

> GameServerInstaller.exe uninstall
Stopping service...
Service uninstalled successfully!
```


#### ğŸ¯ ê²°ë¡ 
ì´ ì½”ë“œëŠ” **Windows ì„œë¹„ìŠ¤ì˜ ë“±ë¡ê³¼ ì œê±°ë¥¼ ë‹´ë‹¹í•˜ëŠ” ê´€ë¦¬ì ë„êµ¬**ì˜ ì˜ˆì œì´ë‹¤.
ê²Œì„ ì„œë²„ë‚˜ ë°±ì—”ë“œ ì„œë¹„ìŠ¤ì²˜ëŸ¼ **í•­ìƒ ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ” ì„œë²„ í”„ë¡œê·¸ë¨**ì€ ì´ë ‡ê²Œ ìš´ì˜ì²´ì œ ì„œë¹„ìŠ¤ë¡œ ë“±ë¡í•˜ì—¬

* ë¶€íŒ… ì‹œ ìë™ ì‹¤í–‰
* ì˜¤ë¥˜ ë°œìƒ ì‹œ ìë™ ì¬ì‹œì‘
* ê´€ë¦¬ ë„êµ¬ì—ì„œ ìƒíƒœ ëª¨ë‹ˆí„°ë§

ì´ ê°€ëŠ¥í•˜ë„ë¡ ë§Œë“œëŠ” ê²ƒì´ ì¢‹ë‹¤.

ì¦‰, `ServiceInstaller`ëŠ” ê²Œì„ ì„œë²„ë¥¼ ìš´ì˜ í™˜ê²½ì— ì•ˆì „í•˜ê²Œ ë°°í¬í•˜ê¸° ìœ„í•œ **í•„ìˆ˜ ê´€ë¦¬ ë„êµ¬ì˜ í•µì‹¬ ì½”ë“œ**ë¼ê³  í•  ìˆ˜ ìˆë‹¤.


### 10.2.2 ì„œë¹„ìŠ¤ ê´€ë¦¬ ìœ í‹¸ë¦¬í‹°
ëª…ë ¹ì¤„ì—ì„œ ì„œë¹„ìŠ¤ë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ìœ í‹¸ë¦¬í‹°ë¥¼ ë§Œë“¤ì–´ë³´ê² ë‹¤:

```cpp
// ServiceManager.cpp - ì„œë¹„ìŠ¤ ê´€ë¦¬ ìœ í‹¸ë¦¬í‹°
#include <iostream>
#include <string>
#include <filesystem>

void PrintUsage() {
    std::wcout << L"Game Server Service Manager\n";
    std::wcout << L"Usage:\n";
    std::wcout << L"  ServiceManager.exe install [path]  - Install service\n";
    std::wcout << L"  ServiceManager.exe uninstall       - Uninstall service\n";
    std::wcout << L"  ServiceManager.exe start           - Start service\n";
    std::wcout << L"  ServiceManager.exe stop            - Stop service\n";
    std::wcout << L"  ServiceManager.exe status          - Show service status\n";
}

int wmain(int argc, wchar_t* argv[]) {
    if (argc < 2) {
        PrintUsage();
        return 1;
    }

    std::wstring command = argv[1];

    if (command == L"install") {
        std::wstring servicePath;
        if (argc >= 3) {
            servicePath = argv[2];
        } else {
            // í˜„ì¬ ë””ë ‰í† ë¦¬ì˜ GameServer.exe ì‚¬ìš©
            servicePath = std::filesystem::current_path() / L"GameServer.exe";
        }

        if (!std::filesystem::exists(servicePath)) {
            std::wcout << L"Service executable not found: " << servicePath << std::endl;
            return 1;
        }

        return ServiceInstaller::InstallService(servicePath.c_str()) ? 0 : 1;
    }
    else if (command == L"uninstall") {
        return ServiceInstaller::UninstallService() ? 0 : 1;
    }
    else if (command == L"start") {
        return ServiceInstaller::StartService() ? 0 : 1;
    }
    else if (command == L"stop") {
        return ServiceInstaller::StopService() ? 0 : 1;
    }
    else if (command == L"status") {
        ServiceInstaller::PrintServiceStatus();
        return 0;
    }
    else {
        std::wcout << L"Unknown command: " << command << std::endl;
        PrintUsage();
        return 1;
    }
}
```
  
</br>  

## 10.3 ì„œë¹„ìŠ¤ ë””ë²„ê¹… ê¸°ë²•

### 10.3.1 ë””ë²„ê·¸ ëª¨ë“œ ì§€ì›
ì„œë¹„ìŠ¤ ê°œë°œ ì‹œ ë””ë²„ê¹…ì„ ìœ„í•´ ì½˜ì†” ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œë„ ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ êµ¬í˜„í•œë‹¤:  

```cpp
#include <windows.h>
#include <iostream>
#include <io.h>
#include <fcntl.h>

class GameServerApp {
private:
    bool m_isService = false;
    std::atomic<bool> m_running{false};
    
public:
    void SetServiceMode(bool isService) { m_isService = isService; }
    bool IsServiceMode() const { return m_isService; }
    
    void Run();
    void Stop();
    
    // ë””ë²„ê·¸ ì½˜ì†” ì„¤ì •
    void SetupDebugConsole();
    void Log(const std::wstring& message);
};

void GameServerApp::SetupDebugConsole() {
    if (m_isService) return;
    
    // ì½˜ì†” í• ë‹¹
    if (AllocConsole()) {
        // stdoutì„ ì½˜ì†”ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
        freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
        freopen_s((FILE**)stderr, "CONOUT$", "w", stderr);
        freopen_s((FILE**)stdin, "CONIN$", "r", stdin);
        
        // UTF-8 ì¶œë ¥ ì„¤ì •
        SetConsoleOutputCP(CP_UTF8);
        
        std::wcout << L"Debug Console Initialized" << std::endl;
    }
}

void GameServerApp::Log(const std::wstring& message) {
    SYSTEMTIME st;
    GetLocalTime(&st);
    
    wchar_t timestamp[64];
    swprintf_s(timestamp, L"[%04d-%02d-%02d %02d:%02d:%02d.%03d]",
        st.wYear, st.wMonth, st.wDay,
        st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    
    if (m_isService) {
        // ì„œë¹„ìŠ¤ ëª¨ë“œì—ì„œëŠ” ì´ë²¤íŠ¸ ë¡œê·¸ì— ê¸°ë¡
        HANDLE hEventSource = RegisterEventSource(nullptr, L"GameServerService");
        if (hEventSource) {
            std::wstring logMessage = std::wstring(timestamp) + L" " + message;
            LPCWSTR strings[] = { logMessage.c_str() };
            ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0,
                nullptr, 1, 0, strings, nullptr);
            DeregisterEventSource(hEventSource);
        }
    } else {
        // ë””ë²„ê·¸ ëª¨ë“œì—ì„œëŠ” ì½˜ì†”ì— ì¶œë ¥
        std::wcout << timestamp << L" " << message << std::endl;
    }
}

void GameServerApp::Run() {
    m_running = true;
    Log(L"Game Server Starting...");
    
    // ê²Œì„ ì„œë²„ ì´ˆê¸°í™”
    Log(L"Initializing network subsystem...");
    // InitializeNetwork();
    
    Log(L"Loading game configuration...");
    // LoadConfiguration();
    
    Log(L"Starting game loop...");
    
    // ë©”ì¸ ê²Œì„ ë£¨í”„
    while (m_running) {
        // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì²˜ë¦¬
        // ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸
        // ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
        
        Sleep(1); // CPU ì‚¬ìš©ë¥  ì¡°ì ˆ
    }
    
    Log(L"Game Server Stopped");
}

void GameServerApp::Stop() {
    Log(L"Shutdown signal received");
    m_running = false;
}

// ì „ì—­ ì• í”Œë¦¬ì¼€ì´ì…˜ ì¸ìŠ¤í„´ìŠ¤
GameServerApp g_app;

// ì½˜ì†” ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (Ctrl+C ì²˜ë¦¬)
BOOL WINAPI ConsoleCtrlHandler(DWORD dwCtrlType) {
    switch (dwCtrlType) {
    case CTRL_C_EVENT:
    case CTRL_CLOSE_EVENT:
    case CTRL_BREAK_EVENT:
        g_app.Stop();
        return TRUE;
    default:
        return FALSE;
    }
}

// ì„œë¹„ìŠ¤ ëª¨ë“œ ì§„ì…ì 
void RunAsService() {
    g_app.SetServiceMode(true);
    
    // ì„œë¹„ìŠ¤ í…Œì´ë¸” ë“±ë¡
    SERVICE_TABLE_ENTRY DispatchTable[] = {
        { const_cast<LPWSTR>(L"GameServerService"), ServiceMain },
        { nullptr, nullptr }
    };
    
    StartServiceCtrlDispatcher(DispatchTable);
}

// ì½˜ì†” ëª¨ë“œ ì§„ì…ì 
void RunAsConsole() {
    g_app.SetServiceMode(false);
    g_app.SetupDebugConsole();
    
    std::wcout << L"=== Game Server Debug Mode ===" << std::endl;
    std::wcout << L"Press Ctrl+C to stop the server" << std::endl;
    
    // Ctrl+C í•¸ë“¤ëŸ¬ ë“±ë¡
    SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
    
    g_app.Run();
}

int main(int argc, char* argv[]) {
    // ëª…ë ¹ì¤„ ì¸ìˆ˜ í™•ì¸
    bool debugMode = false;
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--debug") == 0 || strcmp(argv[i], "-d") == 0) {
            debugMode = true;
            break;
        }
    }
    
    if (debugMode) {
        RunAsConsole();
    } else {
        RunAsService();
    }
    
    return 0;
}
```
   
ì´ ì½”ë“œëŠ” **ê²Œì„ ì„œë²„ë¥¼ ìœˆë„ìš° ì„œë¹„ìŠ¤ë¡œ ì‹¤í–‰í•˜ê±°ë‚˜, ë””ë²„ê¹…ì„ ìœ„í•´ ì½˜ì†” ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ êµ¬í˜„í•œ ì˜ˆì œ**ì´ë‹¤.
ì„œë¹„ìŠ¤ ëª¨ë“œëŠ” ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œ ì‚¬ìš©ë˜ê³ , ì½˜ì†” ëª¨ë“œëŠ” ê°œë°œìë‚˜ í…ŒìŠ¤í„°ê°€ ì„œë²„ì˜ ë™ì‘ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•˜ê³  ë””ë²„ê¹…í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.

ì¦‰,

* **ìš´ì˜ ì‹œ**ì—ëŠ” ìœˆë„ìš° ì„œë¹„ìŠ¤ë¡œ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰ëœë‹¤.
* **ê°œë°œ/í…ŒìŠ¤íŠ¸ ì‹œ**ì—ëŠ” ì½˜ì†” ì°½ì—ì„œ ë¡œê·¸ë¥¼ í™•ì¸í•˜ë©° ì‹¤í–‰ëœë‹¤.

ì•„ë˜ëŠ” ì½”ë“œì˜ ì£¼ìš” êµ¬ì„±ê³¼ íë¦„ì„ ë‹¨ê³„ë³„ë¡œ ë‚˜ëˆ„ì–´ ì„¤ëª…í•œ ê²ƒì´ë‹¤.


#### 1ï¸âƒ£ í´ë˜ìŠ¤ êµ¬ì¡°ì™€ í•µì‹¬ ë©¤ë²„

```cpp
class GameServerApp {
private:
    bool m_isService = false;
    std::atomic<bool> m_running{false};
    
public:
    void SetServiceMode(bool isService);
    bool IsServiceMode() const;
    
    void Run();
    void Stop();
    void SetupDebugConsole();
    void Log(const std::wstring& message);
};
```

`GameServerApp` í´ë˜ìŠ¤ëŠ” ì„œë²„ ì‹¤í–‰ì˜ ì¤‘ì‹¬ ì—­í• ì„ í•œë‹¤.

* **`m_isService`**: í˜„ì¬ ì„œë²„ê°€ ì„œë¹„ìŠ¤ ëª¨ë“œì¸ì§€ ì—¬ë¶€ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.
* **`m_running`**: ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ ì—¬ë¶€ë¥¼ ê´€ë¦¬í•˜ëŠ” í”Œë˜ê·¸ì´ë‹¤.

ì•„ë˜ì™€ ê°™ì€ ê´€ê³„ë¥¼ ê°€ì§„ë‹¤.

```mermaid
classDiagram
    class GameServerApp {
        - bool m_isService
        - atomic<bool> m_running
        + void SetServiceMode(bool)
        + bool IsServiceMode()
        + void SetupDebugConsole()
        + void Log(wstring)
        + void Run()
        + void Stop()
    }
```


#### 2ï¸âƒ£ ë””ë²„ê·¸ ì½˜ì†” ì„¤ì • (`SetupDebugConsole`)

```cpp
void GameServerApp::SetupDebugConsole() {
    if (m_isService) return;
    
    if (AllocConsole()) {
        freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
        freopen_s((FILE**)stderr, "CONOUT$", "w", stderr);
        freopen_s((FILE**)stdin, "CONIN$", "r", stdin);
        SetConsoleOutputCP(CP_UTF8);
        
        std::wcout << L"Debug Console Initialized" << std::endl;
    }
}
```

ì´ í•¨ìˆ˜ëŠ” **ë””ë²„ê·¸ ëª¨ë“œì¼ ë•Œ ì½˜ì†” ì°½ì„ ì´ˆê¸°í™”**í•œë‹¤.

1. `AllocConsole()`ë¡œ ìƒˆë¡œìš´ ì½˜ì†”ì„ í• ë‹¹í•œë‹¤.
2. `freopen_s`ë¡œ `stdout`, `stderr`, `stdin`ì„ ì½˜ì†”ì— ì—°ê²°í•œë‹¤.
3. `SetConsoleOutputCP(CP_UTF8)`ë¡œ UTF-8 ë¬¸ì ì¶œë ¥ì„ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.

ASCII ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ í‘œí˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```
+----------------------+
| GameServerApp        |
|  (ë””ë²„ê·¸ ëª¨ë“œ ì‹¤í–‰)  |
+----------+-----------+
           |
           v
  [AllocConsole í˜¸ì¶œ]
           |
           v
  [í‘œì¤€ ì…ì¶œë ¥ ì—°ê²°]
           |
           v
  [UTF-8 ì„¤ì • ë° ì´ˆê¸°í™” ë©”ì‹œì§€ ì¶œë ¥]
```


#### 3ï¸âƒ£ ë¡œê·¸ ê¸°ë¡ í•¨ìˆ˜ (`Log`)

```cpp
void GameServerApp::Log(const std::wstring& message) {
    SYSTEMTIME st;
    GetLocalTime(&st);
    
    wchar_t timestamp[64];
    swprintf_s(timestamp, L"[%04d-%02d-%02d %02d:%02d:%02d.%03d]", ...);
    
    if (m_isService) {
        HANDLE hEventSource = RegisterEventSource(nullptr, L"GameServerService");
        ...
        ReportEvent(...);
        DeregisterEventSource(hEventSource);
    } else {
        std::wcout << timestamp << L" " << message << std::endl;
    }
}
```

ì´ í•¨ìˆ˜ëŠ” **ë¡œê·¸ë¥¼ ì¶œë ¥í•˜ê±°ë‚˜, ì„œë¹„ìŠ¤ ëª¨ë“œì—ì„œëŠ” ìœˆë„ìš° ì´ë²¤íŠ¸ ë¡œê·¸ì— ê¸°ë¡**í•œë‹¤.

* **ì„œë¹„ìŠ¤ ëª¨ë“œ**: `ReportEvent`ë¥¼ í†µí•´ ìœˆë„ìš° ì´ë²¤íŠ¸ ë·°ì–´ì— ë¡œê·¸ë¥¼ ë‚¨ê¸´ë‹¤.
* **ë””ë²„ê·¸ ëª¨ë“œ**: ì½˜ì†” ì°½ì— íƒ€ì„ìŠ¤íƒ¬í”„ì™€ í•¨ê»˜ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•œë‹¤.

ì´ë ‡ê²Œ í•˜ë©´ ê°™ì€ ì½”ë“œ ê¸°ë°˜ìœ¼ë¡œ ìš´ì˜ê³¼ ë””ë²„ê¹… ëª¨ë‘ ì¼ê´€ëœ ë¡œê·¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.


#### 4ï¸âƒ£ ë©”ì¸ ì‹¤í–‰ ë£¨í”„ (`Run` & `Stop`)

```cpp
void GameServerApp::Run() {
    m_running = true;
    Log(L"Game Server Starting...");
    
    Log(L"Initializing network subsystem...");
    Log(L"Loading game configuration...");
    Log(L"Starting game loop...");
    
    while (m_running) {
        Sleep(1);
    }
    
    Log(L"Game Server Stopped");
}

void GameServerApp::Stop() {
    Log(L"Shutdown signal received");
    m_running = false;
}
```

* **`Run()`**ì€ ì„œë²„ì˜ ë©”ì¸ ë£¨í”„ë¥¼ ì‹¤í–‰í•œë‹¤.

  * ë„¤íŠ¸ì›Œí¬ ì´ˆê¸°í™”, ì„¤ì • ë¡œë”©, ê²Œì„ ë£¨í”„ ì‹œì‘ ë“±ì˜ ë‹¨ê³„ê°€ í¬í•¨ëœë‹¤.
  * ë£¨í”„ ë‚´ë¶€ì—ì„œëŠ” í´ë¼ì´ì–¸íŠ¸ ì—°ê²°, ê²Œì„ ë¡œì§, ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ë“±ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.
* **`Stop()`**ì€ ì™¸ë¶€ ì‹ í˜¸(ì˜ˆ: Ctrl+C)ë¥¼ ë°›ì•„ ë£¨í”„ë¥¼ ì¢…ë£Œí•œë‹¤.

ë£¨í”„ì˜ íë¦„ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

```mermaid
flowchart TD
    A["ì„œë²„ ì‹œì‘ Run()"] --> B["ë„¤íŠ¸ì›Œí¬ ì´ˆê¸°í™”"]
    B --> C["ì„¤ì • ë¡œë”©"]
    C --> D["ë©”ì¸ ë£¨í”„ ì‹¤í–‰"]
    D -->|Ctrl+C ì‹ í˜¸| E["Stop() í˜¸ì¶œ"]
    E --> F["ì„œë²„ ì¢…ë£Œ ë¡œê·¸"]
```


#### 5ï¸âƒ£ ì½˜ì†”/ì„œë¹„ìŠ¤ ëª¨ë“œ ì‹¤í–‰ ë¶„ê¸°

```cpp
void RunAsService() {
    g_app.SetServiceMode(true);
    SERVICE_TABLE_ENTRY DispatchTable[] = {
        { const_cast<LPWSTR>(L"GameServerService"), ServiceMain },
        { nullptr, nullptr }
    };
    StartServiceCtrlDispatcher(DispatchTable);
}

void RunAsConsole() {
    g_app.SetServiceMode(false);
    g_app.SetupDebugConsole();
    
    std::wcout << L"=== Game Server Debug Mode ===" << std::endl;
    std::wcout << L"Press Ctrl+C to stop the server" << std::endl;
    
    SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
    g_app.Run();
}
```

* **ì„œë¹„ìŠ¤ ëª¨ë“œ**ëŠ” `StartServiceCtrlDispatcher`ë¥¼ í†µí•´ ìœˆë„ìš° ì„œë¹„ìŠ¤ ê´€ë¦¬ìê°€ í˜¸ì¶œí•œë‹¤.
* **ì½˜ì†” ëª¨ë“œ**ëŠ” ë””ë²„ê¹…ìš© ì½˜ì†”ì„ ì—´ê³ , Ctrl+Cë¥¼ ê°ì§€í•˜ì—¬ ì„œë²„ë¥¼ ì¢…ë£Œí•œë‹¤.


#### 6ï¸âƒ£ ì§„ì…ì  (`main`)

```cpp
int main(int argc, char* argv[]) {
    bool debugMode = false;
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--debug") == 0 || strcmp(argv[i], "-d") == 0) {
            debugMode = true;
            break;
        }
    }
    
    if (debugMode)
        RunAsConsole();
    else
        RunAsService();
    
    return 0;
}
```

* ëª…ë ¹ì¤„ ì¸ìˆ˜ì— `--debug` ë˜ëŠ” `-d`ê°€ ìˆìœ¼ë©´ ì½˜ì†” ëª¨ë“œë¡œ ì‹¤í–‰í•œë‹¤.
* ì•„ë¬´ ì˜µì…˜ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ì ìœ¼ë¡œ ì„œë¹„ìŠ¤ ëª¨ë“œë¡œ ì‹¤í–‰í•œë‹¤.

ì¦‰, ê°œë°œìëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì„œë²„ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.

```bash
GameServer.exe --debug   # ë””ë²„ê·¸ ì½˜ì†” ëª¨ë“œ
GameServer.exe           # ì„œë¹„ìŠ¤ ëª¨ë“œ
```


#### âœ… ì •ë¦¬

| êµ¬ë¶„         | ì„¤ëª…                                        |
| ---------- | ----------------------------------------- |
| **ì„œë¹„ìŠ¤ ëª¨ë“œ** | ìœˆë„ìš° ì„œë¹„ìŠ¤ë¡œ ì‹¤í–‰ë˜ì–´ ì´ë²¤íŠ¸ ë¡œê·¸ì— ê¸°ë¡í•¨                 |
| **ë””ë²„ê·¸ ëª¨ë“œ** | ì½˜ì†” ì°½ì—ì„œ ì§ì ‘ ë¡œê·¸ë¥¼ í™•ì¸í•˜ë©° ì‹¤í–‰í•¨                    |
| **ê³µí†µì **    | ë™ì¼í•œ `GameServerApp` í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì½”ë“œ ì¼ê´€ì„±ì„ ìœ ì§€í•¨ |
| **ì‚¬ìš© ëª©ì **  | ìš´ì˜í™˜ê²½ì—ì„œëŠ” ì•ˆì •ì  ì„œë¹„ìŠ¤, ê°œë°œí™˜ê²½ì—ì„œëŠ” ì‹¤ì‹œê°„ ë””ë²„ê¹… ì§€ì›       |

ì´ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë©´ **í•˜ë‚˜ì˜ ì½”ë“œë¡œ ìš´ì˜ í™˜ê²½ê³¼ ê°œë°œ í™˜ê²½ ëª¨ë‘ë¥¼ ëŒ€ì‘í•  ìˆ˜ ìˆë‹¤**.
ì¦‰, â€œ**ì‹¤ì œ ì„œë¹„ìŠ¤ì™€ ë™ì¼í•œ ì½”ë“œë¡œ ë””ë²„ê·¸í•  ìˆ˜ ìˆëŠ” êµ¬ì¡°**â€ë¥¼ ë§Œë“œëŠ” ê²ƒì´ ì´ ì½”ë“œì˜ í•µì‹¬ì´ë‹¤.

  

### 10.3.2 ì›ê²© ë””ë²„ê¹… ì„¤ì •
Visual Studioì—ì„œ ì„œë¹„ìŠ¤ë¥¼ ë””ë²„ê¹…í•˜ê¸° ìœ„í•œ ì„¤ì • ë°©ë²•ì´ë‹¤:

```cpp
// DebugHelper.cpp - ì„œë¹„ìŠ¤ ë””ë²„ê¹… ë„ìš°ë¯¸
#include <windows.h>
#include <iostream>

class ServiceDebugHelper {
public:
    // ë””ë²„ê±° ì—°ê²° ëŒ€ê¸°
    static void WaitForDebugger() {
        std::wcout << L"Waiting for debugger to attach..." << std::endl;
        std::wcout << L"Process ID: " << GetCurrentProcessId() << std::endl;
        
        while (!IsDebuggerPresent()) {
            Sleep(1000);
            std::wcout << L"." << std::flush;
        }
        
        std::wcout << L"\nDebugger attached!" << std::endl;
        
        // ë””ë²„ê±°ì—ê²Œ ë¸Œë ˆì´í¬í¬ì¸íŠ¸ ì•Œë¦¼
        DebugBreak();
    }
    
    // ë””ë²„ê·¸ ì •ë³´ ë¤í”„
    static void DumpProcessInfo() {
        DWORD pid = GetCurrentProcessId();
        HANDLE hProcess = GetCurrentProcess();
        
        PROCESS_MEMORY_COUNTERS pmc;
        if (GetProcessMemoryInfo(hProcess, &pmc, sizeof(pmc))) {
            std::wcout << L"\n=== Process Information ===" << std::endl;
            std::wcout << L"PID: " << pid << std::endl;
            std::wcout << L"Working Set: " << pmc.WorkingSetSize / 1024 / 1024 << L" MB" << std::endl;
            std::wcout << L"Peak Working Set: " << pmc.PeakWorkingSetSize / 1024 / 1024 << L" MB" << std::endl;
            std::wcout << L"Private Bytes: " << pmc.PagefileUsage / 1024 / 1024 << L" MB" << std::endl;
        }
        
        FILETIME createTime, exitTime, kernelTime, userTime;
        if (GetProcessTimes(hProcess, &createTime, &exitTime, &kernelTime, &userTime)) {
            SYSTEMTIME st;
            FileTimeToSystemTime(&createTime, &st);
            std::wcout << L"Start Time: " << st.wYear << L"-" << st.wMonth << L"-" << st.wDay
                      << L" " << st.wHour << L":" << st.wMinute << L":" << st.wSecond << std::endl;
        }
    }
};

// ì„œë¹„ìŠ¤ ë©”ì¸ í•¨ìˆ˜ ìˆ˜ì • ë²„ì „
void GameServerService::SvcInit(DWORD dwArgc, LPTSTR* lpszArgv) {
    // ë””ë²„ê·¸ ëª¨ë“œ ì²´í¬
    bool debugMode = false;
    for (DWORD i = 0; i < dwArgc; i++) {
        if (_tcscmp(lpszArgv[i], TEXT("--debug")) == 0) {
            debugMode = true;
            break;
        }
    }
    
    if (debugMode) {
        // ë””ë²„ê·¸ ì½˜ì†” í• ë‹¹
        AllocConsole();
        freopen_s((FILE**)stdout, "CONOUT$", "w", stdout);
        freopen_s((FILE**)stderr, "CONOUT$", "w", stderr);
        
        ServiceDebugHelper::WaitForDebugger();
        ServiceDebugHelper::DumpProcessInfo();
    }
    
    // ë‚˜ë¨¸ì§€ ì´ˆê¸°í™” ë¡œì§...
    ghSvcStopEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);
    if (ghSvcStopEvent == nullptr) {
        ReportSvcStatus(SERVICE_STOPPED, GetLastError(), 0);
        return;
    }
    
    ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);
    
    StartGameServer();
    WaitForSingleObject(ghSvcStopEvent, INFINITE);
    StopGameServer();
    
    ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
}
```
  
</br>  
  
  
## 10.4 ê²Œì„ ì„œë²„ë¥¼ ì„œë¹„ìŠ¤ë¡œ ë°°í¬í•˜ê¸°

### 10.4.1 ìë™ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸
PowerShellì„ ì´ìš©í•œ ìë™ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ì´ë‹¤:

```powershell
# DeployGameServer.ps1
param(
    [string]$ServiceName = "GameServerService",
    [string]$BinaryPath = ".\GameServer.exe",
    [string]$ConfigPath = ".\config.json",
    [switch]$Debug
)

Write-Host "=== Game Server Deployment Script ===" -ForegroundColor Green

# ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    Write-Error "This script requires Administrator privileges"
    exit 1
}

# íŒŒì¼ ì¡´ì¬ í™•ì¸
if (-not (Test-Path $BinaryPath)) {
    Write-Error "Service binary not found: $BinaryPath"
    exit 1
}

if (-not (Test-Path $ConfigPath)) {
    Write-Warning "Configuration file not found: $ConfigPath"
}

try {
    # ê¸°ì¡´ ì„œë¹„ìŠ¤ ì •ì§€ ë° ì œê±°
    $existingService = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
    if ($existingService) {
        Write-Host "Stopping existing service..." -ForegroundColor Yellow
        Stop-Service -Name $ServiceName -Force -ErrorAction SilentlyContinue
        
        Write-Host "Removing existing service..." -ForegroundColor Yellow
        & sc.exe delete $ServiceName
        Start-Sleep -Seconds 2
    }
    
    # ìƒˆ ì„œë¹„ìŠ¤ ì„¤ì¹˜
    Write-Host "Installing new service..." -ForegroundColor Cyan
    $fullPath = Resolve-Path $BinaryPath
    
    $createResult = & sc.exe create $ServiceName binPath= $fullPath start= auto
    if ($LASTEXITCODE -ne 0) {
        throw "Failed to create service"
    }
    
    # ì„œë¹„ìŠ¤ ì„¤ëª… ì„¤ì •
    & sc.exe description $ServiceName "High-performance game server service"
    
    # ì‹¤íŒ¨ ì‹œ ì¬ì‹œì‘ ì„¤ì •
    & sc.exe failure $ServiceName reset= 86400 actions= restart/5000/restart/10000/none/0
    
    # ì„œë¹„ìŠ¤ ì‹œì‘
    Write-Host "Starting service..." -ForegroundColor Cyan
    if ($Debug) {
        # ë””ë²„ê·¸ ëª¨ë“œë¡œ ì‹œì‘
        & sc.exe start $ServiceName --debug
    } else {
        Start-Service -Name $ServiceName
    }
    
    # ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
    Start-Sleep -Seconds 3
    $service = Get-Service -Name $ServiceName
    if ($service.Status -eq "Running") {
        Write-Host "Service deployed and started successfully!" -ForegroundColor Green
        Write-Host "Service Status: $($service.Status)" -ForegroundColor Green
    } else {
        Write-Warning "Service installed but not running. Status: $($service.Status)"
    }
    
} catch {
    Write-Error "Deployment failed: $_"
    exit 1
}

Write-Host "Deployment completed!" -ForegroundColor Green
```

### 10.4.2 êµ¬ì„± íŒŒì¼ ê´€ë¦¬
ì„œë¹„ìŠ¤ ì„¤ì •ì„ ìœ„í•œ JSON êµ¬ì„± íŒŒì¼ êµ¬ì¡°ì´ë‹¤:  

```json
{
    "server": {
        "name": "GameServer_01",
        "port": 8080,
        "maxConnections": 10000,
        "tickRate": 60,
        "logLevel": "INFO"
    },
    "database": {
        "connectionString": "Server=localhost;Database=GameDB;Trusted_Connection=true;",
        "connectionPoolSize": 50,
        "commandTimeout": 30
    },
    "performance": {
        "workerThreads": 0,
        "ioThreads": 0,
        "memoryLimit": "2GB",
        "gcMode": "server"
    },
    "logging": {
        "enableFileLogging": true,
        "logDirectory": "C:\\GameServer\\Logs",
        "maxLogFileSize": "100MB",
        "retentionDays": 30
    },
    "monitoring": {
        "enablePerfCounters": true,
        "reportingInterval": 60,
        "alertThresholds": {
            "cpuUsage": 80,
            "memoryUsage": 85,
            "connectionCount": 9000
        }
    }
}
```

êµ¬ì„± íŒŒì¼ì„ ì½ëŠ” C++ ì½”ë“œ:

```cpp
#include <windows.h>
#include <iostream>
#include <fstream>
#include <string>
#include "json/json.h" // jsoncpp ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©

class GameServerConfig {
private:
    Json::Value m_config;
    std::wstring m_configPath;
    
public:
    bool LoadFromFile(const std::wstring& path) {
        m_configPath = path;
        
        std::ifstream file(path);
        if (!file.is_open()) {
            return false;
        }
        
        Json::Reader reader;
        if (!reader.parse(file, m_config)) {
            return false;
        }
        
        return true;
    }
    
    // ì„œë²„ ì„¤ì •
    std::string GetServerName() const {
        return m_config["server"]["name"].asString();
    }
    
    int GetServerPort() const {
        return m_config["server"]["port"].asInt();
    }
    
    int GetMaxConnections() const {
        return m_config["server"]["maxConnections"].asInt();
    }
    
    int GetTickRate() const {
        return m_config["server"]["tickRate"].asInt();
    }
    
    // ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
    std::string GetConnectionString() const {
        return m_config["database"]["connectionString"].asString();
    }
    
    int GetConnectionPoolSize() const {
        return m_config["database"]["connectionPoolSize"].asInt();
    }
    
    // ë¡œê¹… ì„¤ì •
    std::string GetLogDirectory() const {
        return m_config["logging"]["logDirectory"].asString();
    }
    
    bool IsFileLoggingEnabled() const {
        return m_config["logging"]["enableFileLogging"].asBool();
    }
    
    // ì„±ëŠ¥ ì„¤ì •
    int GetWorkerThreads() const {
        int threads = m_config["performance"]["workerThreads"].asInt();
        if (threads == 0) {
            SYSTEM_INFO si;
            GetSystemInfo(&si);
            return si.dwNumberOfProcessors;
        }
        return threads;
    }
    
    // ì„¤ì • ë³€ê²½ ê°ì‹œ
    void WatchForChanges(std::function<void()> callback) {
        std::thread watchThread([this, callback]() {
            HANDLE hDir = CreateFile(
                m_configPath.substr(0, m_configPath.find_last_of(L'\\')).c_str(),
                FILE_LIST_DIRECTORY,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                nullptr,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                nullptr);
                
            if (hDir == INVALID_HANDLE_VALUE) return;
            
            char buffer[1024];
            DWORD bytesReturned;
            
            while (true) {
                if (ReadDirectoryChangesW(hDir, buffer, sizeof(buffer), FALSE,
                    FILE_NOTIFY_CHANGE_LAST_WRITE, &bytesReturned, nullptr, nullptr)) {
                    
                    FILE_NOTIFY_INFORMATION* pNotify = (FILE_NOTIFY_INFORMATION*)buffer;
                    std::wstring fileName(pNotify->FileName, pNotify->FileNameLength / sizeof(WCHAR));
                    
                    if (fileName == m_configPath.substr(m_configPath.find_last_of(L'\\') + 1)) {
                        Sleep(100); // íŒŒì¼ ì“°ê¸° ì™„ë£Œ ëŒ€ê¸°
                        if (LoadFromFile(m_configPath)) {
                            callback();
                        }
                    }
                }
            }
            
            CloseHandle(hDir);
        });
        
        watchThread.detach();
    }
};
```

### 10.4.3 ì„œë¹„ìŠ¤ ìƒíƒœ ëª¨ë‹ˆí„°ë§

```cpp
class ServiceMonitor {
private:
    HANDLE m_hService = nullptr;
    std::atomic<bool> m_monitoring{false};
    std::thread m_monitorThread;
    
public:
    struct ServiceStats {
        DWORD processId = 0;
        SIZE_T workingSetSize = 0;
        SIZE_T privateBytes = 0;
        DWORD handleCount = 0;
        DWORD threadCount = 0;
        FILETIME kernelTime = {};
        FILETIME userTime = {};
        double cpuUsage = 0.0;
    };
    
    bool StartMonitoring(const std::wstring& serviceName) {
        SC_HANDLE hSCM = OpenSCManager(nullptr, nullptr, SC_MANAGER_CONNECT);
        if (!hSCM) return false;
        
        m_hService = OpenService(hSCM, serviceName.c_str(), SERVICE_QUERY_STATUS);
        CloseServiceHandle(hSCM);
        
        if (!m_hService) return false;
        
        m_monitoring = true;
        m_monitorThread = std::thread(&ServiceMonitor::MonitorLoop, this);
        
        return true;
    }
    
    void StopMonitoring() {
        m_monitoring = false;
        if (m_monitorThread.joinable()) {
            m_monitorThread.join();
        }
        
        if (m_hService) {
            CloseServiceHandle(m_hService);
            m_hService = nullptr;
        }
    }
    
    ServiceStats GetCurrentStats() {
        ServiceStats stats;
        
        SERVICE_STATUS_PROCESS ssp;
        DWORD bytesNeeded;
        
        if (!QueryServiceStatusEx(m_hService, SC_STATUS_PROCESS_INFO,
            (LPBYTE)&ssp, sizeof(ssp), &bytesNeeded)) {
            return stats;
        }
        
        stats.processId = ssp.dwProcessId;
        
        if (stats.processId == 0) return stats;
        
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
            FALSE, stats.processId);
        if (!hProcess) return stats;
        
        // ë©”ëª¨ë¦¬ ì •ë³´
        PROCESS_MEMORY_COUNTERS pmc;
        if (GetProcessMemoryInfo(hProcess, &pmc, sizeof(pmc))) {
            stats.workingSetSize = pmc.WorkingSetSize;
            stats.privateBytes = pmc.PagefileUsage;
        }
        
        // í•¸ë“¤ ë° ìŠ¤ë ˆë“œ ìˆ˜
        DWORD handleCount;
        GetProcessHandleCount(hProcess, &handleCount);
        stats.handleCount = handleCount;
        
        // CPU ì‚¬ìš©ë¥  ê³„ì‚° (ê°„ì†Œí™”ëœ ë²„ì „)
        static FILETIME lastKernelTime = {};
        static FILETIME lastUserTime = {};
        static FILETIME lastTime = {};
        
        FILETIME creationTime, exitTime;
        if (GetProcessTimes(hProcess, &creationTime, &exitTime,
            &stats.kernelTime, &stats.userTime)) {
            
            FILETIME currentTime;
            GetSystemTimeAsFileTime(&currentTime);
            
            if (lastTime.dwLowDateTime != 0 || lastTime.dwHighDateTime != 0) {
                // CPU ì‚¬ìš©ë¥  ê³„ì‚° ë¡œì§
                // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ì •í™•í•œ ê³„ì‚°ì´ í•„ìš”
            }
            
            lastKernelTime = stats.kernelTime;
            lastUserTime = stats.userTime;
            lastTime = currentTime;
        }
        
        CloseHandle(hProcess);
        return stats;
    }
    
private:
    void MonitorLoop() {
        while (m_monitoring) {
            ServiceStats stats = GetCurrentStats();
            
            // ì„ê³„ê°’ ì²´í¬
            if (stats.workingSetSize > 2LL * 1024 * 1024 * 1024) { // 2GB
                LogAlert(L"High memory usage detected");
            }
            
            if (stats.cpuUsage > 80.0) {
                LogAlert(L"High CPU usage detected");
            }
            
            Sleep(5000); // 5ì´ˆë§ˆë‹¤ ëª¨ë‹ˆí„°ë§
        }
    }
    
    void LogAlert(const std::wstring& message) {
        HANDLE hEventSource = RegisterEventSource(nullptr, L"GameServerService");
        if (hEventSource) {
            LPCWSTR strings[] = { message.c_str() };
            ReportEvent(hEventSource, EVENTLOG_WARNING_TYPE, 0, 0,
                nullptr, 1, 0, strings, nullptr);
            DeregisterEventSource(hEventSource);
        }
    }
};
```

ì´ì œ Chapter 11ì˜ ë‚´ìš©ì´ ì™„ì„±ë˜ì—ˆë‹¤. ì´ ì¥ì—ì„œëŠ” ê²Œì„ ì„œë²„ë¥¼ ì•ˆì •ì ì¸ Windows ì„œë¹„ìŠ¤ë¡œ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë¤˜ë‹¤. ì„œë¹„ìŠ¤ì˜ ê¸°ë³¸ êµ¬ì¡°ë¶€í„° ë””ë²„ê¹…, ë°°í¬, ëª¨ë‹ˆí„°ë§ê¹Œì§€ ì‹¤ë¬´ì—ì„œ í•„ìš”í•œ ëª¨ë“  ìš”ì†Œë¥¼ í¬í•¨í–ˆë‹¤.  