# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
  
# 8장. 모듈과 패키지

## 들어가기 전에
C++에서는 헤더 파일(.h)과 소스 파일(.cpp)을 나누고, 네임스페이스를 사용해서 코드를 조직화한다. 또한 외부 라이브러리를 사용할 때는 복잡한 빌드 시스템을 구성해야 한다. Rust는 이 모든 것을 더 간단하고 일관성 있게 해결한다.

Rust의 모듈 시스템은 다음과 같은 장점이 있다:
- **통일된 시스템**: 모든 코드 조직화가 모듈 시스템으로 해결됨
- **명시적 가시성**: `pub` 키워드로 명확한 접근 제어
- **의존성 관리**: Cargo를 통한 자동화된 패키지 관리
- **컴파일 최적화**: 모듈 경계를 통한 효율적인 컴파일
  

## 8.1 모듈 시스템 이해

### 기본 모듈 개념

```rust
// main.rs
mod greetings {
    pub fn hello() {
        println!("안녕하세요!");
    }
    
    pub fn goodbye() {
        println!("안녕히 가세요!");
    }
    
    // 비공개 함수 (같은 모듈 내에서만 접근 가능)
    fn secret() {
        println!("비밀 메시지");
    }
    
    // 중첩 모듈
    pub mod formal {
        pub fn hello() {
            println!("안녕하십니까!");
        }
        
        pub fn goodbye() {
            println!("안녕히 계십시오!");
        }
    }
}

fn main() {
    // 모듈 함수 호출
    greetings::hello();
    greetings::goodbye();
    
    // 중첩 모듈 함수 호출
    greetings::formal::hello();
    greetings::formal::goodbye();
    
    // 이런 호출은 컴파일 에러
    // greetings::secret(); // private 함수
}
```

### C++와의 모듈 시스템 비교

```cpp
// C++ 헤더 파일 (greetings.h)
#ifndef GREETINGS_H
#define GREETINGS_H

namespace greetings {
    void hello();
    void goodbye();
    
    namespace formal {
        void hello();
        void goodbye();
    }
}

#endif

// C++ 소스 파일 (greetings.cpp)
#include "greetings.h"
#include <iostream>

namespace greetings {
    void hello() {
        std::cout << "안녕하세요!" << std::endl;
    }
    
    void goodbye() {
        std::cout << "안녕히 가세요!" << std::endl;
    }
    
    namespace formal {
        void hello() {
            std::cout << "안녕하십니까!" << std::endl;
        }
        
        void goodbye() {
            std::cout << "안녕히 계십시오!" << std::endl;
        }
    }
}

// main.cpp
#include "greetings.h"

int main() {
    greetings::hello();
    greetings::formal::hello();
    return 0;
}
```

```rust
// Rust는 모든 것이 한 파일에 또는 모듈로 조직화됨
mod greetings {
    pub fn hello() {
        println!("안녕하세요!");
    }
    
    pub mod formal {
        pub fn hello() {
            println!("안녕하십니까!");
        }
    }
}

fn main() {
    greetings::hello();
    greetings::formal::hello();
}
```

### 파일로 분리된 모듈

```rust
// src/main.rs
mod greetings; // greetings.rs 파일을 모듈로 가져옴
mod math;      // math.rs 파일을 모듈로 가져옴

fn main() {
    greetings::hello();
    greetings::formal::hello();
    
    println!("2 + 3 = {}", math::add(2, 3));
    println!("10 - 4 = {}", math::subtract(10, 4));
    
    println!("원의 넓이 (반지름 5): {:.2}", math::geometry::circle_area(5.0));
}
```

```rust
// src/greetings.rs
pub fn hello() {
    println!("안녕하세요!");
}

pub fn goodbye() {
    println!("안녕히 가세요!");
}

fn secret() {
    println!("비밀 메시지"); // private 함수
}

// 중첩 모듈
pub mod formal {
    pub fn hello() {
        println!("안녕하십니까!");
    }
    
    pub fn goodbye() {
        println!("안녕히 계십시오!");
    }
}

// 같은 모듈 내에서 private 함수 사용
pub fn reveal_secret() {
    secret(); // 같은 모듈이므로 접근 가능
}
```

```rust
// src/math.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

pub fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

pub fn divide(a: i32, b: i32) -> Option<i32> {
    if b != 0 {
        Some(a / b)
    } else {
        None
    }
}

// 중첩 모듈
pub mod geometry {
    pub fn circle_area(radius: f64) -> f64 {
        std::f64::consts::PI * radius * radius
    }
    
    pub fn rectangle_area(width: f64, height: f64) -> f64 {
        width * height
    }
    
    pub fn triangle_area(base: f64, height: f64) -> f64 {
        0.5 * base * height
    }
}
```

### 디렉토리 구조를 사용한 모듈 조직화

```
src/
├── main.rs
├── lib.rs (라이브러리의 경우)
├── greetings/
│   ├── mod.rs
│   ├── casual.rs
│   └── formal.rs
└── math/
    ├── mod.rs
    ├── basic.rs
    └── advanced.rs
```

```rust
// src/greetings/mod.rs
pub mod casual;
pub mod formal;

// 모듈에서 함수를 재수출
pub use casual::hello as casual_hello;
pub use formal::hello as formal_hello;

// 공통 기능
pub fn get_greeting_count() -> usize {
    2 // casual과 formal
}
```

```rust
// src/greetings/casual.rs
pub fn hello() {
    println!("안녕!");
}

pub fn goodbye() {
    println!("잘 가!");
}

pub fn how_are_you() {
    println!("어때? 잘 지내?");
}
```

```rust
// src/greetings/formal.rs
pub fn hello() {
    println!("안녕하십니까!");
}

pub fn goodbye() {
    println!("안녕히 계십시오!");
}

pub fn how_are_you() {
    println!("어떻게 지내십니까?");
}
```

```rust
// src/math/mod.rs
pub mod basic;
pub mod advanced;

// 기본 연산들을 최상위 레벨로 재수출
pub use basic::{add, subtract, multiply, divide};

// 상수 정의
pub const PI: f64 = std::f64::consts::PI;
pub const E: f64 = std::f64::consts::E;
```

```rust
// src/math/basic.rs
pub fn add(a: f64, b: f64) -> f64 {
    a + b
}

pub fn subtract(a: f64, b: f64) -> f64 {
    a - b
}

pub fn multiply(a: f64, b: f64) -> f64 {
    a * b
}

pub fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b != 0.0 {
        Ok(a / b)
    } else {
        Err("0으로 나눌 수 없습니다".to_string())
    }
}

pub fn power(base: f64, exponent: i32) -> f64 {
    base.powi(exponent)
}
```

```rust
// src/math/advanced.rs
use super::PI; // 부모 모듈의 상수 사용

pub fn sin(x: f64) -> f64 {
    x.sin()
}

pub fn cos(x: f64) -> f64 {
    x.cos()
}

pub fn tan(x: f64) -> f64 {
    x.tan()
}

pub fn circle_area(radius: f64) -> f64 {
    PI * radius * radius
}

pub fn circle_circumference(radius: f64) -> f64 {
    2.0 * PI * radius
}

pub fn factorial(n: u32) -> u64 {
    match n {
        0 | 1 => 1,
        _ => (2..=n as u64).product(),
    }
}
```  
   
#### 프로젝트 디렉토리 구조 분석
**기본 디렉토리 구조**
```
src/
├── main.rs          # 실행 가능한 바이너리의 진입점
├── lib.rs           # 라이브러리 크레이트의 루트 (선택적)
├── greetings/       # greetings 모듈 디렉토리
│   ├── mod.rs       # greetings 모듈의 루트 파일
│   ├── casual.rs    # 서브모듈: 캐주얼 인사
│   └── formal.rs    # 서브모듈: 정중한 인사
└── math/            # math 모듈 디렉토리
    ├── mod.rs       # math 모듈의 루트 파일
    ├── basic.rs     # 서브모듈: 기본 수학 연산
    └── advanced.rs  # 서브모듈: 고급 수학 함수
```

**파일 역할**
- `main.rs`: 바이너리 크레이트의 진입점, `fn main()` 함수가 있다
- `lib.rs`: 라이브러리 크레이트의 루트, 외부에서 사용할 API를 정의한다
- `mod.rs`: 디렉토리 형태 모듈의 루트 파일, 해당 디렉토리의 모듈을 구성한다
  
#### greetings 모듈 구조

**mod.rs의 역할**
```rust
// src/greetings/mod.rs
pub mod casual;    // casual.rs 파일을 서브모듈로 선언
pub mod formal;    // formal.rs 파일을 서브모듈로 선언

// 재수출(re-export)을 통한 API 간소화
pub use casual::hello as casual_hello;
pub use formal::hello as formal_hello;

pub fn get_greeting_count() -> usize {
    2 // casual과 formal
}
```

**재수출의 장점**
- 외부에서 `greetings::casual_hello()` 형태로 직접 접근 가능하다
- `greetings::casual::hello()`보다 간단한 경로를 제공한다
- 모듈 내부 구조를 숨기면서 깔끔한 API를 노출할 수 있다

**서브모듈 구현**
```rust
// src/greetings/casual.rs
pub fn hello() {
    println!("안녕!");
}
// 같은 주제(캐주얼 인사)의 함수들을 한 곳에 모았다
```

#### math 모듈 구조
**상수와 재수출**
```rust
// src/math/mod.rs
pub mod basic;
pub mod advanced;

// 자주 사용되는 기본 연산을 최상위로 재수출
pub use basic::{add, subtract, multiply, divide};

// 수학 상수들을 모듈 레벨에서 제공
pub const PI: f64 = std::f64::consts::PI;
pub const E: f64 = std::f64::consts::E;
```

**모듈 간 의존성**
```rust
// src/math/advanced.rs
use super::PI; // 부모 모듈(math)의 상수를 가져온다

pub fn circle_area(radius: f64) -> f64 {
    PI * radius * radius  // 부모 모듈의 PI 상수 사용
}
```

#### main.rs에서의 사용법

```rust
// src/main.rs
mod greetings;  // greetings 디렉토리 모듈 선언
mod math;       // math 디렉토리 모듈 선언

fn main() {
    // 재수출된 함수 사용 (간단한 경로)
    greetings::casual_hello();
    greetings::formal_hello();
    
    // 직접 경로 사용
    greetings::casual::goodbye();
    greetings::formal::goodbye();
    
    // math 모듈 사용
    let result = math::add(5.0, 3.0);        // 재수출된 함수
    let area = math::advanced::circle_area(10.0);  // 직접 접근
    
    println!("덧셈 결과: {}", result);
    println!("원의 넓이: {}", area);
}
```

#### lib.rs를 통한 라이브러리 제공

```rust
// src/lib.rs
pub mod greetings;
pub mod math;

// 라이브러리의 주요 API만 재수출
pub use greetings::{casual_hello, formal_hello};
pub use math::{add, subtract, multiply, divide};

// 라이브러리 전체를 대표하는 함수
pub fn library_info() {
    println!("인사말과 수학 함수를 제공하는 라이브러리");
}
```

#### 조건부 컴파일
```rust
// src/math/advanced.rs
#[cfg(feature = "advanced-math")]
pub fn complex_calculation() -> f64 {
    // 고급 수학 기능 (feature flag로 제어)
    42.0
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_circle_area() {
        let area = circle_area(1.0);
        assert!((area - PI).abs() < f64::EPSILON);
    }
}
```

#### use 구문의 다양한 형태
```rust
// 여러 항목 한 번에 가져오기
use math::{add, subtract, PI};

// 모든 public 항목 가져오기 (권장하지 않음)
use math::*;

// 별칭 사용
use greetings::casual::hello as casual_hi;

// 중첩된 use
use greetings::{
    casual::{hello, goodbye},
    formal::how_are_you as formal_inquiry,
};
```

### 모듈 가시성 제어

#### pub의 세밀한 제어
```rust
// src/math/mod.rs
pub mod basic;           // 외부에서 접근 가능
pub(crate) mod internal; // 크레이트 내부에서만 접근 가능
mod private;             // 현재 모듈에서만 접근 가능

pub use basic::add;      // public으로 재수출
pub(crate) use internal::helper; // 크레이트 내부로만 재수출
```

#### 구조체와 열거형의 가시성
```rust
// src/math/basic.rs
pub struct Calculator {
    pub precision: u32,        // public 필드
    pub(crate) history: Vec<f64>, // 크레이트 내부에서만 접근
    private_state: bool,       // private 필드
}

impl Calculator {
    pub fn new(precision: u32) -> Self {
        Self {
            precision,
            history: Vec::new(),
            private_state: false,
        }
    }
    
    pub fn calculate(&mut self, a: f64, b: f64) -> f64 {
        let result = add(a, b);
        self.history.push(result);
        result
    }
}
```

### 실제 사용 시나리오

#### 외부 크레이트에서 사용
```rust
// Cargo.toml에 의존성 추가 후
use my_library::{casual_hello, add, math};

fn main() {
    casual_hello();
    let sum = add(10.0, 20.0);
    let area = math::advanced::circle_area(5.0);
}
```

#### 테스트 모듈
```rust
// src/math/basic.rs
#[cfg(test)]
mod tests {
    use super::*; // 부모 모듈의 모든 항목 가져오기
    
    #[test]
    fn test_add() {
        assert_eq!(add(2.0, 3.0), 5.0);
    }
    
    #[test]
    fn test_divide_by_zero() {
        assert!(divide(5.0, 0.0).is_err());
    }
}
```

### 핵심 정리

- **모듈 구조**: 디렉토리와 `mod.rs` 파일로 계층적 모듈 시스템을 구성한다
- **재수출**: `pub use`를 통해 깔끔한 API를 제공하고 내부 구조를 숨긴다
- **가시성 제어**: `pub`, `pub(crate)` 등으로 세밀한 접근 권한 제어가 가능하다
- **모듈 간 의존성**: `super`, `crate`, `self` 키워드로 상대적/절대적 경로를 사용한다
- **네이밍 규칙**: snake_case를 사용하고, 의미 있는 모듈명을 선택한다
  
</br>  
  

## 8.2 `pub mod`와 `use`
Rust의 `pub mod`와 `use`는 완전히 다른 목적을 가진 키워드다.

### pub mod - 모듈 선언
**목적:** 모듈을 정의하고 외부에 공개한다

```rust
// src/lib.rs
pub mod network;    // network 모듈을 선언하고 외부에 공개
mod database;       // database 모듈을 선언하지만 내부에서만 사용

// src/network/mod.rs 또는 src/network.rs 파일이 존재해야 함
```

**특징:**
- 파일 시스템의 모듈 구조를 정의한다
- `pub`가 있으면 외부 크레이트에서도 접근 가능하다
- `pub` 없이 `mod`만 쓰면 현재 크레이트 내부에서만 접근 가능하다

### use - 경로 가져오기
**목적:** 다른 곳에 정의된 아이템을 현재 스코프로 가져온다

```rust
use std::collections::HashMap;
use crate::network::connect;
use super::parent_function;

fn main() {
    let map = HashMap::new();        // std::collections::HashMap 대신
    connect();                       // crate::network::connect 대신
    parent_function();               // super::parent_function 대신
}
```

### 실제 사용 예시

#### 모듈 구조 설정
```rust
// src/lib.rs
pub mod auth {
    pub fn login() { println!("로그인 성공"); }
    fn internal_check() { }  // 외부 접근 불가
}

pub mod user;  // src/user.rs 파일을 모듈로 선언
```

```rust
// src/user.rs
pub struct User {
    pub name: String,
}

impl User {
    pub fn new(name: String) -> Self {
        User { name }
    }
}
```

#### 모듈 사용하기
```rust
// src/main.rs
use myapp::auth;           // auth 모듈 전체 가져오기
use myapp::user::User;     // User 구조체만 가져오기

fn main() {
    auth::login();                    // use로 가져온 후 사용
    let user = User::new("김개발".to_string());
    
    // use 없이 전체 경로로도 가능
    myapp::auth::login();
}
```    
  
`use myapp::`은 크레이트에서 패키지 이름이 `myapp` 으로 되어 있기 때문이다.    
```toml
# Cargo.toml
[package]
name = "myapp"     # 이것이 크레이트 이름
version = "0.1.0"
```  
  
### 언제 사용하는가

#### pub mod 사용 시점
1. **새로운 모듈 파일을 만들 때**
   ```rust
   pub mod server;    // server.rs 파일을 모듈로 만들기
   ```

2. **모듈을 외부에 공개하고 싶을 때**
   ```rust
   pub mod api;       // 외부 크레이트에서 접근 가능
   mod internal;      // 현재 크레이트 내부에서만 접근
   ```

3. **인라인 모듈 정의할 때**
   ```rust
   pub mod config {
       pub const VERSION: &str = "1.0.0";
   }
   ```

#### use 사용 시점
1. **긴 경로를 짧게 만들고 싶을 때**
   ```rust
   use std::collections::HashMap;
   // std::collections::HashMap::new() → HashMap::new()
   ```

2. **외부 크레이트의 기능을 사용할 때**
   ```rust
   use serde::{Serialize, Deserialize};
   use tokio::net::TcpListener;
   ```

3. **같은 크레이트 내 다른 모듈의 아이템 사용할 때**
   ```rust
   use crate::database::connect;
   use super::parent_module::some_function;
   ```

### 핵심 차이점

| 구분 | pub mod | use |
|------|---------|-----|
| 역할 | 모듈 정의 및 공개 | 아이템 가져오기 |
| 위치 | 파일 최상단 | 함수나 블록 내부도 가능 |
| 효과 | 모듈 트리 구조 생성 | 현재 스코프에 별칭 생성 |

간단히 말해서 `pub mod`는 "모듈을 만들고 공개한다"이고, `use`는 "만들어진 것을 가져와서 편하게 쓴다"는 개념이다.  
  
</br>  
  
    
## 8.3 pub 키워드와 접근 제어

### 기본 접근 제어

```rust
mod restaurant {
    pub struct Breakfast {
        pub toast: String,      // 공개 필드
        seasonal_fruit: String, // 비공개 필드
    }
    
    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
    
    pub enum Appetizer {
        Soup,
        Salad,
    }
    
    // 비공개 함수
    fn cook() {
        println!("요리 중...");
    }
    
    // 공개 함수
    pub fn eat_at_restaurant() {
        cook(); // 같은 모듈이므로 호출 가능
        
        let mut meal = Breakfast::summer("호밀빵");
        meal.toast = String::from("밀빵"); // 공개 필드이므로 변경 가능
        // meal.seasonal_fruit = String::from("blueberries"); // 컴파일 에러!
        
        let order1 = Appetizer::Soup;
        let order2 = Appetizer::Salad;
    }
}

fn main() {
    restaurant::eat_at_restaurant();
    
    let mut meal = restaurant::Breakfast::summer("호밀빵");
    meal.toast = String::from("밀빵");
    
    // restaurant::cook(); // 컴파일 에러! private 함수
}
```

### 세분화된 접근 제어

```rust
mod outer {
    pub fn public_function() {
        println!("outer::public_function 호출됨");
        private_function();
    }
    
    fn private_function() {
        println!("outer::private_function 호출됨");
    }
    
    pub mod inner {
        pub fn inner_public() {
            println!("outer::inner::inner_public 호출됨");
            inner_private();
        }
        
        fn inner_private() {
            println!("outer::inner::inner_private 호출됨");
        }
        
        // 부모 모듈의 private 함수에 접근
        pub fn call_parent_private() {
            // super::private_function(); // 컴파일 에러!
            super::public_function(); // OK
        }
    }
    
    // pub(crate): 같은 크레이트 내에서만 접근 가능
    pub(crate) fn crate_visible() {
        println!("크레이트 내에서만 보임");
    }
    
    // pub(super): 부모 모듈에서만 접근 가능
    pub(super) fn parent_visible() {
        println!("부모 모듈에서만 보임");
    }
    
    // pub(in path): 특정 경로에서만 접근 가능
    pub(in crate::outer) fn module_visible() {
        println!("outer 모듈 내에서만 보임");
    }
}

fn main() {
    outer::public_function();
    outer::inner::inner_public();
    outer::inner::call_parent_private();
    
    outer::crate_visible(); // 같은 크레이트이므로 OK
    // outer::parent_visible(); // 컴파일 에러! 부모 모듈이 아님
}
```

### 구조체와 열거형의 접근 제어

```rust
mod shapes {
    // 구조체의 필드별 접근 제어
    pub struct Rectangle {
        pub width: f64,   // 공개 필드
        pub height: f64,  // 공개 필드
        area: f64,        // 비공개 필드 (캐시용)
    }
    
    impl Rectangle {
        pub fn new(width: f64, height: f64) -> Rectangle {
            Rectangle {
                width,
                height,
                area: width * height,
            }
        }
        
        pub fn area(&self) -> f64 {
            self.area
        }
        
        pub fn resize(&mut self, width: f64, height: f64) {
            self.width = width;
            self.height = height;
            self.area = width * height; // 캐시 업데이트
        }
        
        // 비공개 메서드
        fn recalculate_area(&mut self) {
            self.area = self.width * self.height;
        }
    }
    
    // 열거형의 경우 pub이면 모든 변형이 공개됨
    pub enum Color {
        Red,
        Green,
        Blue,
        Custom(u8, u8, u8),
    }
    
    // 비공개 열거형
    enum InternalState {
        Ready,
        Processing,
        Done,
    }
    
    pub struct Processor {
        state: InternalState, // 비공개 필드
    }
    
    impl Processor {
        pub fn new() -> Processor {
            Processor {
                state: InternalState::Ready,
            }
        }
        
        pub fn is_ready(&self) -> bool {
            matches!(self.state, InternalState::Ready)
        }
        
        pub fn process(&mut self) {
            self.state = InternalState::Processing;
            // 처리 로직...
            self.state = InternalState::Done;
        }
    }
}

fn main() {
    let mut rect = shapes::Rectangle::new(10.0, 5.0);
    println!("넓이: {}", rect.area());
    
    rect.width = 15.0; // 공개 필드 변경
    // rect.area = 100.0; // 컴파일 에러! 비공개 필드
    
    rect.resize(20.0, 8.0);
    println!("새 넓이: {}", rect.area());
    
    let color = shapes::Color::Custom(255, 128, 0);
    
    let mut processor = shapes::Processor::new();
    if processor.is_ready() {
        processor.process();
    }
}
```
  
</br>    
  

## 8.4 use 키워드로 스코프 가져오기

### 기본 use 사용법

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {
            println!("대기 명단에 추가됨");
        }
        
        pub fn seat_at_table() {
            println!("테이블에 안내됨");
        }
    }
    
    pub mod serving {
        pub fn take_order() {
            println!("주문 받음");
        }
        
        pub fn serve_order() {
            println!("주문 서빙");
        }
        
        pub fn take_payment() {
            println!("결제 처리");
        }
    }
}

// use를 사용하지 않은 경우
fn eat_at_restaurant_verbose() {
    front_of_house::hosting::add_to_waitlist();
    front_of_house::hosting::seat_at_table();
    front_of_house::serving::take_order();
    front_of_house::serving::serve_order();
    front_of_house::serving::take_payment();
}

// use로 간소화
use front_of_house::hosting;
use front_of_house::serving;

fn eat_at_restaurant_concise() {
    hosting::add_to_waitlist();
    hosting::seat_at_table();
    serving::take_order();
    serving::serve_order();
    serving::take_payment();
}

// 특정 함수만 가져오기
use front_of_house::hosting::add_to_waitlist;

fn eat_at_restaurant_specific() {
    add_to_waitlist(); // 직접 호출 가능
    hosting::seat_at_table(); // 모듈을 통해 호출
}

fn main() {
    eat_at_restaurant_verbose();
    eat_at_restaurant_concise();
    eat_at_restaurant_specific();
}
```

### as 키워드와 중복 이름 해결

```rust
use std::fmt::Result;
use std::io::Result as IoResult; // 이름 충돌 방지

fn function1() -> Result<(), std::fmt::Error> {
    // fmt::Result 사용
    Ok(())
}

fn function2() -> IoResult<()> {
    // io::Result 사용 (as로 별칭 지정)
    Ok(())
}

// 여러 항목을 한 번에 가져오기
use std::collections::{HashMap, HashSet, BTreeMap};

// 모든 공개 항목 가져오기 (신중히 사용)
use std::collections::*;

fn main() {
    let mut map = HashMap::new();
    map.insert("key", "value");
    
    let mut set = HashSet::new();
    set.insert(42);
    
    let mut btree = BTreeMap::new();
    btree.insert("a", 1);
}
```

### 중첩된 경로와 self

```rust
mod utils {
    pub fn helper() {
        println!("헬퍼 함수");
    }
    
    pub mod string_utils {
        pub fn capitalize(s: &str) -> String {
            let mut chars = s.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        }
        
        pub fn reverse(s: &str) -> String {
            s.chars().rev().collect()
        }
    }
    
    pub mod math_utils {
        pub fn square(x: i32) -> i32 {
            x * x
        }
        
        pub fn cube(x: i32) -> i32 {
            x * x * x
        }
    }
}

// 중첩된 use 문
use utils::{
    helper,
    string_utils::{capitalize, reverse},
    math_utils::square,
};

// self를 사용한 모듈과 함수 동시 가져오기
use utils::string_utils::{self, capitalize as cap};

fn main() {
    helper();
    
    let text = "hello world";
    println!("원본: {}", text);
    println!("대문자화: {}", capitalize(text));
    println!("뒤집기: {}", reverse(text));
    
    println!("5의 제곱: {}", square(5));
    
    // self를 사용한 경우
    println!("capitalize 함수: {}", cap(text));
    println!("모듈을 통한 호출: {}", string_utils::reverse(text));
}
```

### re-export (재수출)

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {
            println!("대기 명단에 추가");
        }
    }
}

// 재수출을 통한 API 간소화
pub use front_of_house::hosting;

// 또는 특정 함수 재수출
pub use front_of_house::hosting::add_to_waitlist;

// 라이브러리 크레이트에서 자주 사용하는 패턴
pub mod prelude {
    pub use crate::front_of_house::hosting::add_to_waitlist;
    pub use std::collections::HashMap;
    pub use std::collections::HashSet;
}

fn main() {
    // 재수출된 함수 사용
    hosting::add_to_waitlist();
    add_to_waitlist();
    
    // prelude 사용 예시
    use crate::prelude::*;
    let mut map = HashMap::new();
    map.insert("key", "value");
}
```
  
</br>   
  

## 8.5 외부 크레이트 사용하기

### Cargo.toml 설정

```toml
[package]
name = "my_project"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = "1.0"              # JSON 직렬화/역직렬화
serde_json = "1.0"         # JSON 지원
reqwest = { version = "0.11", features = ["json"] }  # HTTP 클라이언트
tokio = { version = "1.0", features = ["full"] }     # 비동기 런타임
clap = "4.0"               # 명령행 파싱
rand = "0.8"               # 랜덤 수 생성

[dev-dependencies]          # 개발/테스트 시에만 사용
pretty_assertions = "1.0"
```

### 외부 크레이트 사용 예제

```rust
// Cargo.toml에 다음 의존성이 있다고 가정:
// [dependencies]
// serde = { version = "1.0", features = ["derive"] }
// serde_json = "1.0"
// rand = "0.8"

use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use rand::Rng;

// JSON 직렬화/역직렬화를 위한 구조체
#[derive(Serialize, Deserialize, Debug, Clone)]
struct User {
    id: u32,
    name: String,
    email: String,
    age: u8,
    preferences: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct UserDatabase {
    users: Vec<User>,
    metadata: HashMap<String, String>,
}

impl UserDatabase {
    fn new() -> Self {
        let mut metadata = HashMap::new();
        metadata.insert("version".to_string(), "1.0".to_string());
        metadata.insert("created".to_string(), "2024".to_string());
        
        UserDatabase {
            users: Vec::new(),
            metadata,
        }
    }
    
    fn add_user(&mut self, user: User) {
        self.users.push(user);
    }
    
    fn find_user_by_id(&self, id: u32) -> Option<&User> {
        self.users.iter().find(|user| user.id == id)
    }
    
    fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }
    
    fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
    
    fn generate_random_user(&mut self) -> User {
        let mut rng = rand::thread_rng();
        
        let names = ["Alice", "Bob", "Charlie", "Diana", "Eve"];
        let domains = ["example.com", "test.org", "demo.net"];
        
        let name = names[rng.gen_range(0..names.len())];
        let domain = domains[rng.gen_range(0..domains.len())];
        
        let mut preferences = HashMap::new();
        preferences.insert("theme".to_string(), "dark".to_string());
        preferences.insert("language".to_string(), "en".to_string());
        
        let user = User {
            id: rng.gen_range(1000..9999),
            name: name.to_string(),
            email: format!("{}@{}", name.to_lowercase(), domain),
            age: rng.gen_range(18..80),
            preferences,
        };
        
        self.add_user(user.clone());
        user
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== 외부 크레이트 사용 예제 ===");
    
    let mut db = UserDatabase::new();
    
    // 수동으로 사용자 추가
    let mut user1_prefs = HashMap::new();
    user1_prefs.insert("theme".to_string(), "light".to_string());
    user1_prefs.insert("language".to_string(), "ko".to_string());
    
    let user1 = User {
        id: 1001,
        name: "김철수".to_string(),
        email: "chulsoo@example.com".to_string(),
        age: 28,
        preferences: user1_prefs,
    };
    
    db.add_user(user1);
    
    // 랜덤 사용자 생성
    println!("랜덤 사용자 생성:");
    for _ in 0..3 {
        let user = db.generate_random_user();
        println!("생성된 사용자: {} (ID: {})", user.name, user.id);
    }
    
    // JSON으로 직렬화
    let json_data = db.to_json()?;
    println!("\n=== JSON 데이터 ===");
    println!("{}", json_data);
    
    // JSON에서 역직렬화
    let restored_db = UserDatabase::from_json(&json_data)?;
    println!("\n=== 복원된 데이터베이스 ===");
    println!("사용자 수: {}", restored_db.users.len());
    
    // 사용자 검색
    if let Some(user) = restored_db.find_user_by_id(1001) {
        println!("찾은 사용자: {:?}", user);
    }
    
    Ok(())
}

// 다른 모듈에서 외부 크레이트 재수출 예제
pub mod random_utils {
    pub use rand::{thread_rng, Rng}; // rand 크레이트 재수출
    
    pub fn random_between(min: i32, max: i32) -> i32 {
        let mut rng = thread_rng();
        rng.gen_range(min..=max)
    }
    
    pub fn random_choice<T: Clone>(items: &[T]) -> Option<T> {
        if items.is_empty() {
            None
        } else {
            let mut rng = thread_rng();
            let index = rng.gen_range(0..items.len());
            Some(items[index].clone())
        }
    }
}

pub mod json_utils {
    pub use serde_json::{to_string, from_str, Value}; // serde_json 재수출
    
    pub fn pretty_print_json<T: serde::Serialize>(data: &T) -> Result<(), serde_json::Error> {
        let json = serde_json::to_string_pretty(data)?;
        println!("{}", json);
        Ok(())
    }
}
```

### 조건부 컴파일과 기능 플래그

```rust
// Cargo.toml에서 기능 정의
// [features]
// default = ["json"]
// json = ["serde_json"]
// networking = ["reqwest", "tokio"]
// 
// [dependencies]
// serde_json = { version = "1.0", optional = true }
// reqwest = { version = "0.11", optional = true }
// tokio = { version = "1.0", optional = true }

#[cfg(feature = "json")]
use serde_json;

#[cfg(feature = "networking")]
use reqwest;

pub struct DataManager {
    data: std::collections::HashMap<String, String>,
}

impl DataManager {
    pub fn new() -> Self {
        DataManager {
            data: std::collections::HashMap::new(),
        }
    }
    
    pub fn add(&mut self, key: String, value: String) {
        self.data.insert(key, value);
    }
    
    // JSON 기능이 활성화된 경우에만 컴파일됨
    #[cfg(feature = "json")]
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.data)
    }
    
    #[cfg(feature = "json")]
    pub fn from_json(&mut self, json: &str) -> Result<(), serde_json::Error> {
        self.data = serde_json::from_str(json)?;
        Ok(())
    }
    
    // 네트워킹 기능이 활성화된 경우에만 컴파일됨
    #[cfg(feature = "networking")]
    pub async fn fetch_from_url(&mut self, url: &str) -> Result<(), Box<dyn std::error::Error>> {
        let response = reqwest::get(url).await?;
        let text = response.text().await?;
        self.add("fetched_data".to_string(), text);
        Ok(())
    }
}

// 플랫폼별 조건부 컴파일
#[cfg(target_os = "windows")]
fn platform_specific_function() {
    println!("Windows에서 실행 중");
}

#[cfg(target_os = "linux")]
fn platform_specific_function() {
    println!("Linux에서 실행 중");
}

#[cfg(target_os = "macos")]
fn platform_specific_function() {
    println!("macOS에서 실행 중");
}

fn main() {
    let mut manager = DataManager::new();
    manager.add("key1".to_string(), "value1".to_string());
    
    #[cfg(feature = "json")]
    {
        match manager.to_json() {
            Ok(json) => println!("JSON: {}", json),
            Err(e) => eprintln!("JSON 에러: {}", e),
        }
    }
    
    #[cfg(not(feature = "json"))]
    {
        println!("JSON 기능이 비활성화되어 있습니다.");
    }
    
    platform_specific_function();
}
```
  
</br>   
  

## 실습: 다중 모듈 프로젝트 구성
이제 배운 내용을 종합해서 실제 프로젝트 구조를 가진 애플리케이션을 만들어보자:

**프로젝트 구조:**
```
game_server/
├── Cargo.toml
├── README.md
└── src/
    ├── main.rs
    ├── lib.rs
    ├── config/
    │   ├── mod.rs
    │   ├── server.rs
    │   └── database.rs
    ├── network/
    │   ├── mod.rs
    │   ├── client.rs
    │   ├── protocol.rs
    │   └── handler.rs
    ├── game/
    │   ├── mod.rs
    │   ├── player.rs
    │   ├── room.rs
    │   └── events.rs
    ├── database/
    │   ├── mod.rs
    │   ├── connection.rs
    │   └── queries.rs
    └── utils/
        ├── mod.rs
        ├── logger.rs
        └── time.rs
```

### Cargo.toml 설정

```toml
[package]
name = "game_server"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <your.email@example.com>"]
description = "A simple game server implementation"
license = "MIT"
keywords = ["game", "server", "networking"]
categories = ["games", "network-programming"]

[lib]
name = "game_server_lib"
path = "src/lib.rs"

[[bin]]
name = "server"
path = "src/main.rs"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
log = "0.4"
env_logger = "0.10"
anyhow = "1.0"
thiserror = "1.0"

[dev-dependencies]
tokio-test = "0.4"

[features]
default = ["sqlite", "logging"]
sqlite = []
mysql = []
postgresql = []
logging = ["log", "env_logger"]
```

### src/lib.rs - 라이브러리 루트

```rust
//! # Game Server Library
//! 
//! 이 라이브러리는 간단한 게임 서버의 핵심 기능을 제공합니다.

pub mod config;
pub mod network;
pub mod game;
pub mod database;
pub mod utils;

// 공통 타입과 에러 정의
pub mod error;
pub mod types;

// 주요 기능들을 재수출하여 사용하기 쉽게 함
pub use config::{ServerConfig, DatabaseConfig};
pub use game::{Player, Room, GameEvent};
pub use network::{Client, NetworkHandler};
pub use error::{GameError, Result};

// Prelude 모듈 - 자주 사용되는 항목들
pub mod prelude {
    pub use crate::{
        GameError,
        Result,
        Player,
        Room,
        Client,
        ServerConfig,
    };
    pub use std::collections::HashMap;
    pub use uuid::Uuid;
    pub use chrono::{DateTime, Utc};
}

/// 서버 버전 정보
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

/// 기본 설정으로 서버를 초기화하는 편의 함수
pub fn init_default_server() -> Result<ServerConfig> {
    config::ServerConfig::load_from_file("config.json")
        .or_else(|_| Ok(config::ServerConfig::default()))
}
```

### src/error.rs - 에러 타입 정의

```rust
use thiserror::Error;

pub type Result<T> = std::result::Result<T, GameError>;

#[derive(Error, Debug)]
pub enum GameError {
    #[error("네트워크 에러: {0}")]
    Network(String),
    
    #[error("데이터베이스 에러: {0}")]
    Database(String),
    
    #[error("플레이어 에러: {0}")]
    Player(String),
    
    #[error("방 에러: {0}")]
    Room(String),
    
    #[error("설정 에러: {0}")]
    Config(String),
    
    #[error("인증 에러: {0}")]
    Authentication(String),
    
    #[error("직렬화/역직렬화 에러: {0}")]
    Serialization(#[from] serde_json::Error),
    
    #[error("I/O 에러: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("일반 에러: {0}")]
    General(String),
}

impl GameError {
    pub fn network<T: Into<String>>(msg: T) -> Self {
        GameError::Network(msg.into())
    }
    
    pub fn player<T: Into<String>>(msg: T) -> Self {
        GameError::Player(msg.into())
    }
    
    pub fn room<T: Into<String>>(msg: T) -> Self {
        GameError::Room(msg.into())
    }
}
```

### src/types.rs - 공통 타입 정의

```rust
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

pub type PlayerId = Uuid;
pub type RoomId = Uuid;
pub type ClientId = Uuid;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PlayerStatus {
    Online,
    Away,
    Offline,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum RoomStatus {
    Waiting,
    InGame,
    Finished,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Timestamp {
    pub created_at: DateTime<Utc>,
    pub updated_at: Option<DateTime<Utc>>,
}

impl Default for Timestamp {
    fn default() -> Self {
        Self {
            created_at: Utc::now(),
            updated_at: None,
        }
    }
}

impl Timestamp {
    pub fn new() -> Self {
        Self::default()
    }
    
    pub fn update(&mut self) {
        self.updated_at = Some(Utc::now());
    }
}
```

### src/config/mod.rs

```rust
pub mod server;
pub mod database;

pub use server::ServerConfig;
pub use database::DatabaseConfig;

use crate::error::{GameError, Result};
use std::fs;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub server: ServerConfig,
    pub database: DatabaseConfig,
}

impl Config {
    pub fn load_from_file(path: &str) -> Result<Self> {
        let content = fs::read_to_string(path)
            .map_err(|e| GameError::Config(format!("설정 파일을 읽을 수 없습니다: {}", e)))?;
        
        let config: Config = serde_json::from_str(&content)
            .map_err(|e| GameError::Config(format!("설정 파일을 파싱할 수 없습니다: {}", e)))?;
        
        config.validate()?;
        Ok(config)
    }
    
    pub fn save_to_file(&self, path: &str) -> Result<()> {
        let content = serde_json::to_string_pretty(self)?;
        fs::write(path, content)
            .map_err(|e| GameError::Config(format!("설정 파일을 저장할 수 없습니다: {}", e)))?;
        Ok(())
    }
    
    pub fn validate(&self) -> Result<()> {
        self.server.validate()?;
        self.database.validate()?;
        Ok(())
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            server: ServerConfig::default(),
            database: DatabaseConfig::default(),
        }
    }
}
```

### src/config/server.rs

```rust
use serde::{Serialize, Deserialize};
use crate::error::{GameError, Result};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
    pub max_clients: usize,
    pub max_rooms: usize,
    pub tick_rate: u64,
    pub auth_required: bool,
    pub log_level: String,
}

impl ServerConfig {
    pub fn load_from_file(path: &str) -> Result<Self> {
        let content = std::fs::read_to_string(path)
            .map_err(|e| GameError::Config(format!("서버 설정 파일을 읽을 수 없습니다: {}", e)))?;
        
        let config: ServerConfig = serde_json::from_str(&content)?;
        config.validate()?;
        Ok(config)
    }
    
    pub fn validate(&self) -> Result<()> {
        if self.port < 1024 {
            return Err(GameError::Config("포트는 1024 이상이어야 합니다".to_string()));
        }
        
        if self.max_clients == 0 {
            return Err(GameError::Config("최대 클라이언트 수는 1 이상이어야 합니다".to_string()));
        }
        
        if self.max_rooms == 0 {
            return Err(GameError::Config("최대 방 개수는 1 이상이어야 합니다".to_string()));
        }
        
        if !["trace", "debug", "info", "warn", "error"].contains(&self.log_level.as_str()) {
            return Err(GameError::Config("올바르지 않은 로그 레벨입니다".to_string()));
        }
        
        Ok(())
    }
    
    pub fn bind_address(&self) -> String {
        format!("{}:{}", self.host, self.port)
    }
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            host: "127.0.0.1".to_string(),
            port: 8080,
            max_clients: 1000,
            max_rooms: 100,
            tick_rate: 60,
            auth_required: false,
            log_level: "info".to_string(),
        }
    }
}
```

### src/config/database.rs

```rust
use serde::{Serialize, Deserialize};
use crate::error::{GameError, Result};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseConfig {
    pub db_type: DatabaseType,
    pub host: Option<String>,
    pub port: Option<u16>,
    pub username: Option<String>,
    pub password: Option<String>,
    pub database_name: String,
    pub file_path: Option<String>, // SQLite용
    pub max_connections: u32,
    pub timeout_seconds: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DatabaseType {
    #[serde(rename = "sqlite")]
    SQLite,
    #[serde(rename = "mysql")]
    MySQL,
    #[serde(rename = "postgresql")]
    PostgreSQL,
}

impl DatabaseConfig {
    pub fn validate(&self) -> Result<()> {
        match self.db_type {
            DatabaseType::SQLite => {
                if self.file_path.is_none() {
                    return Err(GameError::Config("SQLite는 파일 경로가 필요합니다".to_string()));
                }
            }
            DatabaseType::MySQL | DatabaseType::PostgreSQL => {
                if self.host.is_none() || self.port.is_none() {
                    return Err(GameError::Config("MySQL/PostgreSQL은 호스트와 포트가 필요합니다".to_string()));
                }
                if self.username.is_none() {
                    return Err(GameError::Config("사용자명이 필요합니다".to_string()));
                }
            }
        }
        
        if self.max_connections == 0 {
            return Err(GameError::Config("최대 연결 수는 1 이상이어야 합니다".to_string()));
        }
        
        Ok(())
    }
    
    pub fn connection_string(&self) -> Result<String> {
        match self.db_type {
            DatabaseType::SQLite => {
                Ok(format!("sqlite:{}", self.file_path.as_ref().unwrap()))
            }
            DatabaseType::MySQL => {
                Ok(format!(
                    "mysql://{}:{}@{}:{}/{}",
                    self.username.as_ref().unwrap(),
                    self.password.as_ref().unwrap_or(&"".to_string()),
                    self.host.as_ref().unwrap(),
                    self.port.unwrap(),
                    self.database_name
                ))
            }
            DatabaseType::PostgreSQL => {
                Ok(format!(
                    "postgresql://{}:{}@{}:{}/{}",
                    self.username.as_ref().unwrap(),
                    self.password.as_ref().unwrap_or(&"".to_string()),
                    self.host.as_ref().unwrap(),
                    self.port.unwrap(),
                    self.database_name
                ))
            }
        }
    }
}

impl Default for DatabaseConfig {
    fn default() -> Self {
        Self {
            db_type: DatabaseType::SQLite,
            host: None,
            port: None,
            username: None,
            password: None,
            database_name: "game_server.db".to_string(),
            file_path: Some("./game_server.db".to_string()),
            max_connections: 10,
            timeout_seconds: 30,
        }
    }
}
```

### src/game/mod.rs

```rust
pub mod player;
pub mod room;
pub mod events;

pub use player::Player;
pub use room::Room;
pub use events::GameEvent;

use crate::{error::Result, types::*};
use std::collections::HashMap;

pub struct GameManager {
    players: HashMap<PlayerId, Player>,
    rooms: HashMap<RoomId, Room>,
    max_rooms: usize,
}

impl GameManager {
    pub fn new(max_rooms: usize) -> Self {
        Self {
            players: HashMap::new(),
            rooms: HashMap::new(),
            max_rooms,
        }
    }
    
    pub fn add_player(&mut self, player: Player) -> Result<()> {
        let player_id = player.id();
        if self.players.contains_key(&player_id) {
            return Err(crate::error::GameError::player("플레이어가 이미 존재합니다"));
        }
        
        self.players.insert(player_id, player);
        log::info!("플레이어 추가됨: {}", player_id);
        Ok(())
    }
    
    pub fn create_room(&mut self, creator_id: PlayerId) -> Result<RoomId> {
        if self.rooms.len() >= self.max_rooms {
            return Err(crate::error::GameError::room("최대 방 개수에 도달했습니다"));
        }
        
        let room = Room::new(creator_id)?;
        let room_id = room.id();
        
        self.rooms.insert(room_id, room);
        log::info!("방 생성됨: {}", room_id);
        Ok(room_id)
    }
    
    pub fn get_player(&self, player_id: &PlayerId) -> Option<&Player> {
        self.players.get(player_id)
    }
    
    pub fn get_room(&self, room_id: &RoomId) -> Option<&Room> {
        self.rooms.get(room_id)
    }
    
    pub fn get_room_mut(&mut self, room_id: &RoomId) -> Option<&mut Room> {
        self.rooms.get_mut(room_id)
    }
    
    pub fn player_count(&self) -> usize {
        self.players.len()
    }
    
    pub fn room_count(&self) -> usize {
        self.rooms.len()
    }
}
```

### src/game/player.rs

```rust
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use crate::{types::*, error::Result};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Player {
    id: PlayerId,
    name: String,
    status: PlayerStatus,
    room_id: Option<RoomId>,
    score: u32,
    timestamp: Timestamp,
}

impl Player {
    pub fn new(name: String) -> Self {
        Self {
            id: Uuid::new_v4(),
            name,
            status: PlayerStatus::Online,
            room_id: None,
            score: 0,
            timestamp: Timestamp::new(),
        }
    }
    
    pub fn id(&self) -> PlayerId {
        self.id
    }
    
    pub fn name(&self) -> &str {
        &self.name
    }
    
    pub fn status(&self) -> PlayerStatus {
        self.status
    }
    
    pub fn set_status(&mut self, status: PlayerStatus) {
        self.status = status;
        self.timestamp.update();
    }
    
    pub fn room_id(&self) -> Option<RoomId> {
        self.room_id
    }
    
    pub fn join_room(&mut self, room_id: RoomId) -> Result<()> {
        if self.room_id.is_some() {
            return Err(crate::error::GameError::player("이미 방에 참가 중입니다"));
        }
        
        self.room_id = Some(room_id);
        self.timestamp.update();
        Ok(())
    }
    
    pub fn leave_room(&mut self) -> Result<()> {
        if self.room_id.is_none() {
            return Err(crate::error::GameError::player("참가 중인 방이 없습니다"));
        }
        
        self.room_id = None;
        self.timestamp.update();
        Ok(())
    }
    
    pub fn score(&self) -> u32 {
        self.score
    }
    
    pub fn add_score(&mut self, points: u32) {
        self.score += points;
        self.timestamp.update();
    }
    
    pub fn reset_score(&mut self) {
        self.score = 0;
        self.timestamp.update();
    }
    
    pub fn is_online(&self) -> bool {
        self.status == PlayerStatus::Online
    }
    
    pub fn is_in_room(&self) -> bool {
        self.room_id.is_some()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_player_creation() {
        let player = Player::new("TestPlayer".to_string());
        assert_eq!(player.name(), "TestPlayer");
        assert_eq!(player.status(), PlayerStatus::Online);
        assert_eq!(player.score(), 0);
        assert!(!player.is_in_room());
    }
    
    #[test]
    fn test_player_join_room() {
        let mut player = Player::new("TestPlayer".to_string());
        let room_id = Uuid::new_v4();
        
        assert!(player.join_room(room_id).is_ok());
        assert_eq!(player.room_id(), Some(room_id));
        assert!(player.is_in_room());
        
        // 이미 방에 있을 때 다른 방 참가 시도
        let another_room = Uuid::new_v4();
        assert!(player.join_room(another_room).is_err());
    }
}
```

### src/main.rs - 애플리케이션 엔트리 포인트

```rust
use game_server_lib::prelude::*;
use game_server_lib::{config::Config, game::GameManager, utils::logger};
use std::sync::Arc;
use tokio::sync::Mutex;
use log::{info, error};

#[tokio::main]
async fn main() -> Result<()> {
    // 로거 초기화
    logger::init_logger()?;
    
    info!("게임 서버 시작 중... (버전: {})", game_server_lib::VERSION);
    
    // 설정 로드
    let config = match Config::load_from_file("config.json") {
        Ok(config) => {
            info!("설정 파일에서 설정을 로드했습니다");
            config
        }
        Err(_) => {
            info!("설정 파일을 찾을 수 없어 기본 설정을 사용합니다");
            let default_config = Config::default();
            
            // 기본 설정 파일 생성
            if let Err(e) = default_config.save_to_file("config.json") {
                error!("기본 설정 파일 생성 실패: {}", e);
            } else {
                info!("기본 설정 파일을 생성했습니다: config.json");
            }
            
            default_config
        }
    };
    
    info!("서버 설정:");
    info!("  - 주소: {}", config.server.bind_address());
    info!("  - 최대 클라이언트: {}", config.server.max_clients);
    info!("  - 최대 방: {}", config.server.max_rooms);
    info!("  - 틱 레이트: {}", config.server.tick_rate);
    
    // 게임 매니저 초기화
    let game_manager = Arc::new(Mutex::new(GameManager::new(config.server.max_rooms)));
    
    // 테스트용 플레이어와 방 생성
    {
        let mut gm = game_manager.lock().await;
        
        // 테스트 플레이어 생성
        for i in 1..=3 {
            let player = Player::new(format!("Player{}", i));
            let player_id = player.id();
            gm.add_player(player)?;
            info!("테스트 플레이어 생성됨: Player{} ({})", i, player_id);
        }
        
        info!("현재 플레이어 수: {}", gm.player_count());
        info!("현재 방 수: {}", gm.room_count());
    }
    
    // 서버 시뮬레이션 (실제로는 여기서 네트워크 서버를 시작)
    info!("게임 서버가 {}에서 시작되었습니다", config.server.bind_address());
    info!("서버를 중지하려면 Ctrl+C를 누르세요");
    
    // 서버 메인 루프 시뮬레이션
    let mut tick_interval = tokio::time::interval(
        tokio::time::Duration::from_millis(1000 / config.server.tick_rate)
    );
    
    let mut tick_count = 0u64;
    
    loop {
        tokio::select! {
            _ = tick_interval.tick() => {
                tick_count += 1;
                
                if tick_count % config.server.tick_rate == 0 {
                    let gm = game_manager.lock().await;
                    info!("서버 상태 - 플레이어: {}, 방: {}, 틱: {}", 
                          gm.player_count(), gm.room_count(), tick_count);
                }
                
                // 시뮬레이션 종료 조건
                if tick_count >= 300 { // 5초 후 종료
                    info!("시뮬레이션 종료");
                    break;
                }
            }
            _ = tokio::signal::ctrl_c() => {
                info!("종료 신호 받음");
                break;
            }
        }
    }
    
    info!("게임 서버가 종료되었습니다");
    Ok(())
}
```

### src/utils/logger.rs

```rust
use crate::error::Result;
use log::LevelFilter;
use env_logger::{Builder, Target};
use std::io::Write;
use chrono::Utc;

pub fn init_logger() -> Result<()> {
    let mut builder = Builder::from_default_env();
    
    builder
        .target(Target::Stdout)
        .filter_level(LevelFilter::Info)
        .format(|buf, record| {
            writeln!(
                buf,
                "[{}] [{}] [{}:{}] - {}",
                Utc::now().format("%Y-%m-%d %H:%M:%S%.3f UTC"),
                record.level(),
                record.file().unwrap_or("unknown"),
                record.line().unwrap_or(0),
                record.args()
            )
        })
        .init();
    
    Ok(())
}

pub fn init_logger_with_level(level: &str) -> Result<()> {
    let level_filter = match level.to_lowercase().as_str() {
        "trace" => LevelFilter::Trace,
        "debug" => LevelFilter::Debug,
        "info" => LevelFilter::Info,
        "warn" => LevelFilter::Warn,
        "error" => LevelFilter::Error,
        _ => LevelFilter::Info,
    };
    
    let mut builder = Builder::from_default_env();
    
    builder
        .target(Target::Stdout)
        .filter_level(level_filter)
        .format(|buf, record| {
            writeln!(
                buf,
                "[{}] [{}] [{}] - {}",
                Utc::now().format("%Y-%m-%d %H:%M:%S%.3f UTC"),
                record.level(),
                record.module_path().unwrap_or("unknown"),
                record.args()
            )
        })
        .init();
    
    Ok(())
}
```

### 프로젝트 실행 방법

```bash
# 새 프로젝트 생성
cargo new game_server --lib
cd game_server

# 위의 파일들을 해당 위치에 생성하고 내용 작성

# 프로젝트 빌드
cargo build

# 테스트 실행
cargo test

# 서버 실행
cargo run --bin server

# 라이브러리 문서 생성
cargo doc --open

# 릴리스 빌드
cargo build --release
```

### 남은 모듈 파일들

```rust
// src/utils/mod.rs
pub mod logger;
pub mod time;

pub use logger::{init_logger, init_logger_with_level};
pub use time::{timestamp, format_duration};

use std::collections::HashMap;

pub fn calculate_hash<T: std::hash::Hash>(obj: &T) -> u64 {
    use std::hash::{DefaultHasher, Hasher};
    let mut hasher = DefaultHasher::new();
    obj.hash(&mut hasher);
    hasher.finish()
}

pub fn sanitize_string(input: &str) -> String {
    input
        .chars()
        .filter(|c| c.is_alphanumeric() || c.is_whitespace() || ".-_".contains(*c))
        .collect()
}
```

```rust
// src/utils/time.rs
use chrono::{DateTime, Utc, Duration};

pub fn timestamp() -> DateTime<Utc> {
    Utc::now()
}

pub fn format_duration(duration: Duration) -> String {
    if duration.num_hours() > 0 {
        format!("{}시간 {}분", duration.num_hours(), duration.num_minutes() % 60)
    } else if duration.num_minutes() > 0 {
        format!("{}분 {}초", duration.num_minutes(), duration.num_seconds() % 60)
    } else {
        format!("{}초", duration.num_seconds())
    }
}

pub fn is_expired(created_at: DateTime<Utc>, ttl_seconds: i64) -> bool {
    let now = Utc::now();
    let elapsed = now.signed_duration_since(created_at);
    elapsed.num_seconds() > ttl_seconds
}
```

```rust
// src/game/room.rs
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use crate::{types::*, error::Result};
use std::collections::HashSet;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Room {
    id: RoomId,
    name: String,
    owner_id: PlayerId,
    players: HashSet<PlayerId>,
    status: RoomStatus,
    max_players: u8,
    timestamp: Timestamp,
}

impl Room {
    pub fn new(owner_id: PlayerId) -> Result<Self> {
        Ok(Self {
            id: Uuid::new_v4(),
            name: format!("Room_{}", Uuid::new_v4().to_string()[..8].to_uppercase()),
            owner_id,
            players: {
                let mut set = HashSet::new();
                set.insert(owner_id);
                set
            },
            status: RoomStatus::Waiting,
            max_players: 4,
            timestamp: Timestamp::new(),
        })
    }
    
    pub fn with_name(owner_id: PlayerId, name: String) -> Result<Self> {
        let mut room = Self::new(owner_id)?;
        room.name = name;
        Ok(room)
    }
    
    pub fn id(&self) -> RoomId {
        self.id
    }
    
    pub fn name(&self) -> &str {
        &self.name
    }
    
    pub fn owner_id(&self) -> PlayerId {
        self.owner_id
    }
    
    pub fn add_player(&mut self, player_id: PlayerId) -> Result<()> {
        if self.players.len() >= self.max_players as usize {
            return Err(crate::error::GameError::room("방이 가득 참"));
        }
        
        if self.players.contains(&player_id) {
            return Err(crate::error::GameError::room("이미 방에 있는 플레이어"));
        }
        
        self.players.insert(player_id);
        self.timestamp.update();
        Ok(())
    }
    
    pub fn remove_player(&mut self, player_id: PlayerId) -> Result<()> {
        if !self.players.remove(&player_id) {
            return Err(crate::error::GameError::room("방에 없는 플레이어"));
        }
        
        // 방장이 나갔을 경우 새 방장 지정
        if player_id == self.owner_id && !self.players.is_empty() {
            self.owner_id = *self.players.iter().next().unwrap();
        }
        
        self.timestamp.update();
        Ok(())
    }
    
    pub fn player_count(&self) -> usize {
        self.players.len()
    }
    
    pub fn is_full(&self) -> bool {
        self.players.len() >= self.max_players as usize
    }
    
    pub fn is_empty(&self) -> bool {
        self.players.is_empty()
    }
}
```

```rust
// src/game/events.rs
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use crate::types::*;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GameEvent {
    PlayerJoined {
        player_id: PlayerId,
        room_id: RoomId,
        timestamp: DateTime<Utc>,
    },
    PlayerLeft {
        player_id: PlayerId,
        room_id: RoomId,
        timestamp: DateTime<Utc>,
    },
    RoomCreated {
        room_id: RoomId,
        owner_id: PlayerId,
        timestamp: DateTime<Utc>,
    },
    RoomDestroyed {
        room_id: RoomId,
        timestamp: DateTime<Utc>,
    },
    GameStarted {
        room_id: RoomId,
        players: Vec<PlayerId>,
        timestamp: DateTime<Utc>,
    },
    GameEnded {
        room_id: RoomId,
        winner: Option<PlayerId>,
        timestamp: DateTime<Utc>,
    },
    ScoreUpdated {
        player_id: PlayerId,
        new_score: u32,
        timestamp: DateTime<Utc>,
    },
}

impl GameEvent {
    pub fn timestamp(&self) -> DateTime<Utc> {
        match self {
            Self::PlayerJoined { timestamp, .. } => *timestamp,
            Self::PlayerLeft { timestamp, .. } => *timestamp,
            Self::RoomCreated { timestamp, .. } => *timestamp,
            Self::RoomDestroyed { timestamp, .. } => *timestamp,
            Self::GameStarted { timestamp, .. } => *timestamp,
            Self::GameEnded { timestamp, .. } => *timestamp,
            Self::ScoreUpdated { timestamp, .. } => *timestamp,
        }
    }
    
    pub fn event_type(&self) -> &'static str {
        match self {
            Self::PlayerJoined { .. } => "PlayerJoined",
            Self::PlayerLeft { .. } => "PlayerLeft",
            Self::RoomCreated { .. } => "RoomCreated",
            Self::RoomDestroyed { .. } => "RoomDestroyed",
            Self::GameStarted { .. } => "GameStarted",
            Self::GameEnded { .. } => "GameEnded",
            Self::ScoreUpdated { .. } => "ScoreUpdated",
        }
    }
}

pub struct EventManager {
    events: Vec<GameEvent>,
    max_events: usize,
}

impl EventManager {
    pub fn new(max_events: usize) -> Self {
        Self {
            events: Vec::with_capacity(max_events),
            max_events,
        }
    }
    
    pub fn add_event(&mut self, event: GameEvent) {
        self.events.push(event);
        
        // 최대 이벤트 수 초과 시 오래된 이벤트 제거
        if self.events.len() > self.max_events {
            self.events.remove(0);
        }
    }
    
    pub fn get_recent_events(&self, count: usize) -> &[GameEvent] {
        let start = if self.events.len() > count {
            self.events.len() - count
        } else {
            0
        };
        &self.events[start..]
    }
    
    pub fn clear_old_events(&mut self, cutoff_time: DateTime<Utc>) {
        self.events.retain(|event| event.timestamp() > cutoff_time);
    }
}
```

```rust
// src/network/mod.rs
pub mod client;
pub mod protocol;
pub mod handler;

pub use client::Client;
pub use protocol::{Message, MessageType};
pub use handler::NetworkHandler;

use crate::error::{GameError, Result};
use std::collections::HashMap;
use uuid::Uuid;

pub type ConnectionId = Uuid;

pub struct NetworkManager {
    clients: HashMap<ConnectionId, Client>,
    max_clients: usize,
}

impl NetworkManager {
    pub fn new(max_clients: usize) -> Self {
        Self {
            clients: HashMap::with_capacity(max_clients),
            max_clients,
        }
    }
    
    pub fn add_client(&mut self, client: Client) -> Result<ConnectionId> {
        if self.clients.len() >= self.max_clients {
            return Err(GameError::network("최대 클라이언트 수에 도달"));
        }
        
        let connection_id = client.connection_id();
        self.clients.insert(connection_id, client);
        Ok(connection_id)
    }
    
    pub fn remove_client(&mut self, connection_id: &ConnectionId) -> Option<Client> {
        self.clients.remove(connection_id)
    }
    
    pub fn get_client(&self, connection_id: &ConnectionId) -> Option<&Client> {
        self.clients.get(connection_id)
    }
    
    pub fn client_count(&self) -> usize {
        self.clients.len()
    }
    
    pub fn broadcast_message(&self, message: &Message) -> Result<()> {
        for client in self.clients.values() {
            // 실제 구현에서는 여기서 네트워크를 통해 메시지 전송
            log::debug!("Broadcasting to client {}: {:?}", client.connection_id(), message);
        }
        Ok(())
    }
}
```

```rust
// src/network/client.rs
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};
use crate::{types::*, error::Result};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Client {
    connection_id: ConnectionId,
    player_id: Option<PlayerId>,
    ip_address: String,
    connected_at: DateTime<Utc>,
    last_activity: DateTime<Utc>,
    is_authenticated: bool,
}

impl Client {
    pub fn new(ip_address: String) -> Self {
        let now = Utc::now();
        Self {
            connection_id: Uuid::new_v4(),
            player_id: None,
            ip_address,
            connected_at: now,
            last_activity: now,
            is_authenticated: false,
        }
    }
    
    pub fn connection_id(&self) -> ConnectionId {
        self.connection_id
    }
    
    pub fn player_id(&self) -> Option<PlayerId> {
        self.player_id
    }
    
    pub fn authenticate(&mut self, player_id: PlayerId) -> Result<()> {
        if self.is_authenticated {
            return Err(crate::error::GameError::authentication("이미 인증된 클라이언트"));
        }
        
        self.player_id = Some(player_id);
        self.is_authenticated = true;
        self.update_activity();
        Ok(())
    }
    
    pub fn is_authenticated(&self) -> bool {
        self.is_authenticated
    }
    
    pub fn update_activity(&mut self) {
        self.last_activity = Utc::now();
    }
    
    pub fn is_idle(&self, timeout_seconds: i64) -> bool {
        let now = Utc::now();
        let elapsed = now.signed_duration_since(self.last_activity);
        elapsed.num_seconds() > timeout_seconds
    }
    
    pub fn ip_address(&self) -> &str {
        &self.ip_address
    }
    
    pub fn connected_duration(&self) -> chrono::Duration {
        Utc::now().signed_duration_since(self.connected_at)
    }
}
```

```rust
// src/network/protocol.rs
use serde::{Serialize, Deserialize};
use crate::types::*;
use crate::game::GameEvent;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub message_type: MessageType,
    pub payload: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageType {
    // 인증 관련
    AuthRequest,
    AuthResponse,
    
    // 플레이어 관련
    PlayerJoin,
    PlayerLeave,
    PlayerUpdate,
    
    // 방 관련
    RoomCreate,
    RoomJoin,
    RoomLeave,
    RoomUpdate,
    RoomList,
    
    // 게임 관련
    GameStart,
    GameEnd,
    GameUpdate,
    ScoreUpdate,
    
    // 시스템 관련
    Ping,
    Pong,
    Error,
    Notification,
}

impl Message {
    pub fn new(message_type: MessageType, payload: serde_json::Value) -> Self {
        Self {
            message_type,
            payload,
            timestamp: chrono::Utc::now(),
        }
    }
    
    pub fn ping() -> Self {
        Self::new(MessageType::Ping, serde_json::Value::Null)
    }
    
    pub fn pong() -> Self {
        Self::new(MessageType::Pong, serde_json::Value::Null)
    }
    
    pub fn error(message: String) -> Self {
        Self::new(
            MessageType::Error,
            serde_json::json!({ "error": message })
        )
    }
    
    pub fn notification(message: String) -> Self {
        Self::new(
            MessageType::Notification,
            serde_json::json!({ "message": message })
        )
    }
    
    pub fn from_game_event(event: &GameEvent) -> Self {
        let payload = serde_json::to_value(event).unwrap_or(serde_json::Value::Null);
        
        let message_type = match event {
            GameEvent::PlayerJoined { .. } => MessageType::PlayerJoin,
            GameEvent::PlayerLeft { .. } => MessageType::PlayerLeave,
            GameEvent::RoomCreated { .. } => MessageType::RoomCreate,
            GameEvent::GameStarted { .. } => MessageType::GameStart,
            GameEvent::GameEnded { .. } => MessageType::GameEnd,
            GameEvent::ScoreUpdated { .. } => MessageType::ScoreUpdate,
            _ => MessageType::Notification,
        };
        
        Self::new(message_type, payload)
    }
}
```

### 실행 예시

```
[2024-01-15 10:30:15.123 UTC] [INFO] [src/main.rs:12] - 게임 서버 시작 중... (버전: 0.1.0)
[2024-01-15 10:30:15.124 UTC] [INFO] [src/main.rs:20] - 설정 파일을 찾을 수 없어 기본 설정을 사용합니다
[2024-01-15 10:30:15.125 UTC] [INFO] [src/main.rs:29] - 기본 설정 파일을 생성했습니다: config.json
[2024-01-15 10:30:15.126 UTC] [INFO] [src/main.rs:35] - 서버 설정:
[2024-01-15 10:30:15.126 UTC] [INFO] [src/main.rs:36] -   - 주소: 127.0.0.1:8080
[2024-01-15 10:30:15.126 UTC] [INFO] [src/main.rs:37] -   - 최대 클라이언트: 1000
[2024-01-15 10:30:15.126 UTC] [INFO] [src/main.rs:38] -   - 최대 방: 100
[2024-01-15 10:30:15.126 UTC] [INFO] [src/main.rs:39] -   - 틱 레이트: 60
[2024-01-15 10:30:15.127 UTC] [INFO] [src/game/mod.rs:32] - 플레이어 추가됨: a1b2c3d4-e5f6-7890-abcd-123456789012
[2024-01-15 10:30:15.128 UTC] [INFO] [src/main.rs:49] - 테스트 플레이어 생성됨: Player1 (a1b2c3d4-e5f6-7890-abcd-123456789012)
[2024-01-15 10:30:15.129 UTC] [INFO] [src/game/mod.rs:32] - 플레이어 추가됨: b2c3d4e5-f6g7-8901-bcde-234567890123
[2024-01-15 10:30:15.130 UTC] [INFO] [src/main.rs:49] - 테스트 플레이어 생성됨: Player2 (b2c3d4e5-f6g7-8901-bcde-234567890123)
[2024-01-15 10:30:15.131 UTC] [INFO] [src/game/mod.rs:32] - 플레이어 추가됨: c3d4e5f6-g7h8-9012-cdef-345678901234
[2024-01-15 10:30:15.132 UTC] [INFO] [src/main.rs:49] - 테스트 플레이어 생성됨: Player3 (c3d4e5f6-g7h8-9012-cdef-345678901234)
[2024-01-15 10:30:15.133 UTC] [INFO] [src/main.rs:52] - 현재 플레이어 수: 3
[2024-01-15 10:30:15.133 UTC] [INFO] [src/main.rs:53] - 현재 방 수: 0
[2024-01-15 10:30:15.134 UTC] [INFO] [src/main.rs:57] - 게임 서버가 127.0.0.1:8080에서 시작되었습니다
[2024-01-15 10:30:15.134 UTC] [INFO] [src/main.rs:58] - 서버를 중지하려면 Ctrl+C를 누르세요
[2024-01-15 10:30:16.135 UTC] [INFO] [src/main.rs:70] - 서버 상태 - 플레이어: 3, 방: 0, 틱: 60
[2024-01-15 10:30:17.136 UTC] [INFO] [src/main.rs:70] - 서버 상태 - 플레이어: 3, 방: 0, 틱: 120
[2024-01-15 10:30:18.137 UTC] [INFO] [src/main.rs:70] - 서버 상태 - 플레이어: 3, 방: 0, 틱: 180
[2024-01-15 10:30:19.138 UTC] [INFO] [src/main.rs:70] - 서버 상태 - 플레이어: 3, 방: 0, 틱: 240
[2024-01-15 10:30:20.139 UTC] [INFO] [src/main.rs:70] - 서버 상태 - 플레이어: 3, 방: 0, 틱: 300
[2024-01-15 10:30:20.140 UTC] [INFO] [src/main.rs:74] - 시뮬레이션 종료
[2024-01-15 10:30:20.140 UTC] [INFO] [src/main.rs:82] - 게임 서버가 종료되었습니다
```

### 생성된 config.json 파일 예시

```json
{
  "server": {
    "host": "127.0.0.1",
    "port": 8080,
    "max_clients": 1000,
    "max_rooms": 100,
    "tick_rate": 60,
    "auth_required": false,
    "log_level": "info"
  },
  "database": {
    "db_type": "sqlite",
    "host": null,
    "port": null,
    "username": null,
    "password": null,
    "database_name": "game_server.db",
    "file_path": "./game_server.db",
    "max_connections": 10,
    "timeout_seconds": 30
  }
}
```

### 프로젝트에서 사용된 모듈 시스템 개념들

1. **계층적 모듈 구조**: config, network, game, database, utils로 기능별 분리
2. **pub 키워드**: 공개할 타입, 함수, 모듈을 명시적으로 지정
3. **use와 재수출**: `pub use`로 편리한 API 제공
4. **외부 크레이트**: Cargo.toml을 통한 의존성 관리
5. **조건부 컴파일**: feature 플래그를 통한 선택적 기능
6. **prelude 패턴**: 자주 사용하는 타입들을 한 번에 가져올 수 있게 함
7. **lib.rs vs main.rs**: 라이브러리와 실행 파일의 분리

---

**이번 장 요약:**

1. **모듈 시스템**: 코드를 논리적 단위로 조직화하고 네임스페이스 제공
2. **접근 제어**: `pub` 키워드로 API 경계를 명확히 정의
3. **use 문**: 긴 경로를 단축하고 코드 가독성 향상
4. **외부 크레이트**: Cargo를 통한 통합된 패키지 관리
5. **프로젝트 구조**: 실제 프로덕션 수준의 모듈 조직화 방법

Rust의 모듈 시스템은 C++의 헤더 파일과 네임스페이스보다 더 체계적이고 안전하다. 컴파일 타임에 모든 의존성이 해결되고, 명시적인 가시성 제어로 API 설계가 명확해진다. 특히 대규모 프로젝트에서는 이런 모듈 시스템의 장점이 크게 드러난다.    