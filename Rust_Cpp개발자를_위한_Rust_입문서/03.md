# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
  
# 3장. 소유권과 메모리 관리

## 들어가기 전에
C++ 개발자라면 메모리 관리의 어려움을 잘 알고 있을 것이다. `new`와 `delete`를 잊어버려서 메모리 누수가 발생하거나, 이미 해제된 메모리에 접근해서 세그멘테이션 폴트가 발생하는 경험을 해봤을 것이다. Rust는 이런 문제들을 컴파일 타임에 해결한다. 어떻게? 바로 **소유권(Ownership)** 시스템을 통해서이다.  
    
  
## 3.1 소유권(Ownership) 개념

### 소유권의 기본 규칙
Rust의 소유권 시스템에는 세 가지 기본 규칙이 있다:

1. **각 값은 소유자(owner)가 있다**
2. **한 번에 하나의 소유자만 있을 수 있다**
3. **소유자가 스코프를 벗어나면 값이 삭제(drop)된다**

### C++와의 비교

```cpp
// C++: 수동 메모리 관리
void cpp_example() {
    int* ptr = new int(42);
    // 메모리 사용
    delete ptr;  // 수동으로 해제해야 함
    // ptr = nullptr; // 댕글링 포인터 방지를 위해 수동으로 설정
}

// C++11 이후: 스마트 포인터
void cpp_smart_example() {
    auto ptr = std::make_unique<int>(42);
    // 스코프를 벗어나면 자동으로 해제
}
```

```rust
// Rust: 소유권 시스템
fn rust_example() {
    let x = Box::new(42);  // 힙에 메모리 할당
    // 스코프를 벗어나면 자동으로 해제
} // x가 여기서 drop됨
```

### 스코프와 메모리 해제

```rust
fn main() {
    {                        // s는 아직 유효하지 않음
        let s = String::from("hello"); // s가 유효해짐
        
        // s를 사용할 수 있음
        println!("{}", s);
    }                        // 스코프가 끝나고 s가 drop됨
    
    // println!("{}", s);    // 컴파일 에러! s는 더 이상 유효하지 않음
}
```

### 소유권 이전 (Move)

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1의 소유권이 s2로 이전 (move)
    
    // println!("{}", s1);  // 컴파일 에러! s1은 더 이상 유효하지 않음
    println!("{}", s2);   // OK
}
```

이것이 C++와 다른 점이다. C++에서는 기본적으로 복사가 일어나지만, Rust에서는 이전(move)이 일어난다.

```cpp
// C++: 기본적으로 복사
std::string s1 = "hello";
std::string s2 = s1;  // s1을 s2로 복사
std::cout << s1 << std::endl;  // OK, s1 여전히 유효
std::cout << s2 << std::endl;  // OK, s2도 유효
```

### 함수와 소유권

```rust
fn main() {
    let s = String::from("hello");
    
    takes_ownership(s);  // s의 소유권이 함수로 이전
    // println!("{}", s); // 컴파일 에러! s는 더 이상 유효하지 않음
    
    let x = 5;
    makes_copy(x);       // x가 복사됨 (i32는 Copy 트레이트 구현)
    println!("{}", x);   // OK, x는 여전히 유효
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_string이 스코프를 벗어나고 drop됨

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
} // some_integer가 스코프를 벗어나지만 Copy이므로 문제없음
```

### 소유권을 반환하는 함수

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership이 반환한 값이 s1으로 이전
    let s2 = String::from("hello");     // s2가 스코프에 들어옴
    let s3 = takes_and_gives_back(s2);  // s2가 함수로 이전되고, 반환값이 s3으로 이전
    
    println!("s1: {}, s3: {}", s1, s3);
    // println!("{}", s2); // 컴파일 에러! s2는 이미 이전됨
}

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    some_string  // some_string이 호출한 함수로 이전됨
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string  // a_string이 호출한 함수로 반환됨
}
```
   
</br>  
  
  
## 3.2 Move와 Copy 트레이트

### Copy 트레이트
일부 타입들은 `Copy` 트레이트를 구현해서 대입할 때 복사가 일어난다.

```rust
fn main() {
    // 기본 타입들은 Copy 트레이트를 구현
    let x = 5;
    let y = x;  // x가 y로 복사됨
    println!("x: {}, y: {}", x, y);  // 둘 다 유효
    
    // 튜플도 모든 요소가 Copy면 Copy
    let tup = (5, 10, 'a');
    let tup2 = tup;  // 복사됨
    println!("tup: {:?}, tup2: {:?}", tup, tup2);  // 둘 다 유효
}
```

### Copy 트레이트를 구현하는 타입들
- 모든 정수 타입 (`i32`, `u64` 등)
- 불린 타입 (`bool`)
- 모든 부동소수점 타입 (`f32`, `f64`)
- 문자 타입 (`char`)
- 튜플 (모든 요소가 Copy인 경우에만)

### Copy vs Move 예제

```rust
fn main() {
    // Copy 트레이트를 구현하는 타입
    let a = 5;
    let b = a;  // 복사
    println!("a: {}, b: {}", a, b);  // 둘 다 유효
    
    // Copy 트레이트를 구현하지 않는 타입
    let s1 = String::from("hello");
    let s2 = s1;  // 이전 (move)
    // println!("s1: {}, s2: {}", s1, s2);  // 컴파일 에러!
    println!("s2: {}", s2);  // s2만 유효
    
    // 명시적으로 복사하고 싶다면 clone 사용
    let s3 = String::from("world");
    let s4 = s3.clone();  // 깊은 복사
    println!("s3: {}, s4: {}", s3, s4);  // 둘 다 유효
}
```

### 사용자 정의 타입과 Copy

```rust
// Copy 트레이트를 구현하는 구조체
#[derive(Debug, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

// Copy를 구현할 수 없는 구조체 (String 때문에)
#[derive(Debug, Clone)]
struct Person {
    name: String,
    age: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1;  // 복사됨
    println!("p1: {:?}, p2: {:?}", p1, p2);  // 둘 다 유효
    
    let person1 = Person {
        name: String::from("Alice"),
        age: 30,
    };
    let person2 = person1;  // 이전됨
    // println!("person1: {:?}", person1);  // 컴파일 에러!
    println!("person2: {:?}", person2);   // person2만 유효
    
    // 명시적 복사
    let person3 = Person {
        name: String::from("Bob"),
        age: 25,
    };
    let person4 = person3.clone();  // 깊은 복사
    println!("person3: {:?}, person4: {:?}", person3, person4);  // 둘 다 유효
}
```
  
</br>  
  
  
## 3.3 참조와 빌림(Borrowing)
소유권을 이전하지 않고 값을 사용하고 싶을 때는 **참조(reference)** 를 사용한다. 이를 **빌림(borrowing)** 이라고 한다.  

### 불변 참조

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);  // s1의 참조를 전달
    
    println!("'{}' 문자열의 길이는 {}입니다.", s1, len);  // s1 여전히 유효
}

fn calculate_length(s: &String) -> usize {  // s는 String의 참조
    s.len()
}  // s는 참조이므로 실제 값이 drop되지 않음
```

### 참조의 특징

```rust
fn main() {
    let s = String::from("hello");
    
    // 참조 생성
    let r1 = &s;
    let r2 = &s;
    let r3 = &s;
    
    // 여러 개의 불변 참조는 괜찮음
    println!("r1: {}, r2: {}, r3: {}", r1, r2, r3);
    println!("원본 s: {}", s);  // 원본도 여전히 유효
}
```

### C++와의 참조 비교

```cpp
// C++
void cpp_example() {
    std::string s = "hello";
    std::string& r1 = s;      // 참조
    std::string* p1 = &s;     // 포인터
    
    // 참조는 재할당 불가
    // r1 = another_string;   // r1이 가리키는 객체를 변경
    
    // 포인터는 재할당 가능
    p1 = &another_string;     // p1이 가리키는 주소를 변경
}
```

```rust
// Rust
fn rust_example() {
    let s = String::from("hello");
    let r1 = &s;              // 불변 참조
    
    // 참조는 재할당 가능 (참조 자체를 다른 것으로 바꿈)
    let s2 = String::from("world");
    let r1 = &s2;             // r1이 s2를 참조하도록 변경
    
    println!("{}", r1);       // "world" 출력
}
```

### 댕글링 참조 방지

```rust
fn main() {
    // let reference_to_nothing = dangle();  // 컴파일 에러!
    let valid_string = no_dangle();
    println!("{}", valid_string);
}

// 이런 함수는 컴파일 에러
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s  // s가 스코프를 벗어나면서 drop되는데 참조를 반환하려 함
// }

fn no_dangle() -> String {
    let s = String::from("hello");
    s  // 소유권을 이전하여 반환
}
```
  
</br> 
    

## 3.4 가변 참조와 불변 참조

### 가변 참조

```rust
fn main() {
    let mut s = String::from("hello");  // 원본이 가변이어야 함
    
    change(&mut s);  // 가변 참조 전달
    
    println!("{}", s);  // "hello, world" 출력
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

### 가변 참조의 제한 사항

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &mut s;  // OK
    // let r2 = &mut s;  // 컴파일 에러! 가변 참조는 하나만 허용
    
    println!("{}", r1);
}
```

### 불변 참조와 가변 참조 혼용 제한

```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &s;      // OK
    let r2 = &s;      // OK, 여러 불변 참조는 괜찮음
    // let r3 = &mut s;  // 컴파일 에러! 불변 참조가 있는 동안 가변 참조 불가
    
    println!("{} and {}", r1, r2);
    // r1과 r2는 여기서 더 이상 사용되지 않음
    
    let r3 = &mut s;  // OK, 이제 가변 참조 가능
    println!("{}", r3);
}
```

### 참조의 생명주기 (스코프)

```rust
fn main() {
    let mut s = String::from("hello");
    
    {
        let r1 = &s;      // 불변 참조 시작
        println!("{}", r1);
    }                     // r1이 스코프를 벗어남
    
    let r2 = &mut s;      // 이제 가변 참조 가능
    println!("{}", r2);
}
```

### 실제 사용 예제

```rust
fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];
    
    // 불변 참조로 읽기
    print_vec(&numbers);
    
    // 가변 참조로 수정
    double_vec(&mut numbers);
    
    // 다시 불변 참조로 읽기
    print_vec(&numbers);
}

fn print_vec(v: &Vec<i32>) {
    for num in v {
        print!("{} ", num);
    }
    println!();
}

fn double_vec(v: &mut Vec<i32>) {
    for num in v {
        *num *= 2;  // 역참조하여 값 수정
    }
}
```

### 빌림 검사기 (Borrow Checker)의 장점

```rust
// 이런 C++ 스타일 버그를 Rust가 방지해줌
fn main() {
    let mut data = vec![1, 2, 3];
    
    // C++에서는 가능하지만 위험한 패턴
    // let ptr = &data[0];  // 첫 번째 요소 참조
    // data.push(4);        // 벡터 재할당으로 ptr이 무효화될 수 있음
    // println!("{}", ptr); // 댕글링 포인터 접근!
    
    // Rust에서는 컴파일 에러로 방지
    let first = &data[0];
    // data.push(4);        // 컴파일 에러!
    println!("첫 번째: {}", first);
    
    // 참조 사용이 끝난 후 수정
    data.push(4);  // 이제 OK
    println!("전체: {:?}", data);
}
```
  
</br>  
  
  
## 실습: 문자열 조작 프로그램
이제 배운 소유권과 참조 개념을 활용해서 문자열을 조작하는 프로그램을 만들어보자:

```rust
use std::io;

fn main() {
    println!("=== 문자열 조작 프로그램 ===");
    
    let mut text = String::new();
    
    loop {
        println!("\n현재 문자열: \"{}\"", text);
        println!("1. 텍스트 입력/변경");
        println!("2. 텍스트 추가");
        println!("3. 단어 개수 세기");
        println!("4. 대문자로 변환");
        println!("5. 소문자로 변환");
        println!("6. 특정 문자열 찾기");
        println!("7. 문자열 뒤집기");
        println!("8. 종료");
        
        let choice = get_input("선택하세요: ");
        
        match choice.trim() {
            "1" => set_text(&mut text),
            "2" => append_text(&mut text),
            "3" => count_words(&text),
            "4" => to_uppercase(&mut text),
            "5" => to_lowercase(&mut text),
            "6" => find_substring(&text),
            "7" => reverse_string(&mut text),
            "8" => {
                println!("프로그램을 종료합니다.");
                break;
            }
            _ => println!("잘못된 선택입니다."),
        }
    }
}

fn get_input(prompt: &str) -> String {
    print!("{}", prompt);
    io::stdout().flush().unwrap();
    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("입력 실패");
    input
}

fn set_text(text: &mut String) {
    let input = get_input("새로운 텍스트를 입력하세요: ");
    *text = input.trim().to_string();  // 소유권 이전
    println!("텍스트가 설정되었습니다.");
}

fn append_text(text: &mut String) {
    let input = get_input("추가할 텍스트를 입력하세요: ");
    text.push_str(input.trim());  // 가변 참조를 통한 수정
    println!("텍스트가 추가되었습니다.");
}

fn count_words(text: &String) {  // 불변 참조로 읽기만 함
    let word_count = text.split_whitespace().count();
    println!("단어 개수: {}", word_count);
}

fn to_uppercase(text: &mut String) {
    *text = text.to_uppercase();  // 새로운 String 생성하여 교체
    println!("대문자로 변환되었습니다.");
}

fn to_lowercase(text: &mut String) {
    *text = text.to_lowercase();  // 새로운 String 생성하여 교체
    println!("소문자로 변환되었습니다.");
}

fn find_substring(text: &String) {  // 불변 참조
    let search = get_input("찾을 문자열을 입력하세요: ");
    let search = search.trim();
    
    if text.contains(search) {
        // 위치 찾기
        if let Some(pos) = text.find(search) {
            println!("\"{}\"를 위치 {}에서 찾았습니다.", search, pos);
        }
    } else {
        println!("\"{}\"를 찾을 수 없습니다.", search);
    }
}

fn reverse_string(text: &mut String) {
    *text = text.chars().rev().collect();  // 문자 단위로 뒤집기
    println!("문자열이 뒤집어졌습니다.");
}

// 추가: 문자열 분석 함수들
fn analyze_text(text: &str) -> TextAnalysis {  // &str 사용 (문자열 슬라이스)
    TextAnalysis {
        char_count: text.chars().count(),
        byte_count: text.len(),
        word_count: text.split_whitespace().count(),
        line_count: text.lines().count(),
    }
}

struct TextAnalysis {
    char_count: usize,
    byte_count: usize,
    word_count: usize,
    line_count: usize,
}

impl TextAnalysis {
    fn print_analysis(&self) {  // &self는 불변 참조
        println!("=== 텍스트 분석 ===");
        println!("문자 수: {}", self.char_count);
        println!("바이트 수: {}", self.byte_count);
        println!("단어 수: {}", self.word_count);
        println!("줄 수: {}", self.line_count);
    }
}
```

### 실행 방법

```bash
cargo new string_manipulation
cd string_manipulation
# 위 코드를 src/main.rs에 복사하고, 필요한 use 문 추가
```

`use std::io::Write;`를 파일 상단에 추가해야 `flush()` 메서드를 사용할 수 있어:

```rust
use std::io;
use std::io::Write;  // 이 줄 추가

// ... 나머지 코드
```

### 프로그램에서 사용된 소유권 개념들

1. **가변 참조 (`&mut String`)**: 텍스트를 수정하는 함수들
2. **불변 참조 (`&String`, `&str`)**: 텍스트를 읽기만 하는 함수들
3. **소유권 이전**: `*text = input.trim().to_string()`
4. **빌림**: 함수들이 `main`의 `text` 변수를 빌려서 사용
5. **문자열 슬라이스 (`&str`)**: `analyze_text` 함수에서 더 유연한 매개변수

### 실행 예시

```
=== 문자열 조작 프로그램 ===

현재 문자열: ""
1. 텍스트 입력/변경
2. 텍스트 추가
3. 단어 개수 세기
4. 대문자로 변환
5. 소문자로 변환
6. 특정 문자열 찾기
7. 문자열 뒤집기
8. 종료
선택하세요: 1
새로운 텍스트를 입력하세요: Hello Rust World
텍스트가 설정되었습니다.

현재 문자열: "Hello Rust World"
선택하세요: 3
단어 개수: 3
```

---

**이번 장 요약:**

1. **소유권**: 각 값은 하나의 소유자만 가지며, 소유자가 스코프를 벗어나면 자동으로 메모리 해제된다
2. **Move vs Copy**: 대부분의 타입은 move되지만, Copy 트레이트를 구현한 타입은 복사된다
3. **참조와 빌림**: `&`로 소유권을 이전하지 않고 값을 사용할 수 있다
4. **가변/불변 참조**: 불변 참조는 여러 개 가능하지만, 가변 참조는 하나만 가능하고 불변 참조와 동시에 존재할 수 없다
5. **빌림 검사기**: 컴파일 타임에 메모리 안전성을 보장한다  
  
소유권은 Rust의 가장 중요한 개념이다. 처음에는 어렵게 느껴질 수 있지만, 이를 통해 메모리 안전성과 성능을 동시에 얻을 수 있다. 다음 장에서는 구조체와 열거형을 통해 더 복잡한 데이터 구조를 다뤄볼 것이다.    