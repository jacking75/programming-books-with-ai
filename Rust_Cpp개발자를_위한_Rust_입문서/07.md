# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
  
# 7장. 제네릭과 트레이트

## 들어가기 전에
C++의 템플릿과 가상 함수를 사용해봤다면, 코드의 재사용성과 다형성의 중요성을 알고 있을 것이다. Rust의 제네릭과 트레이트는 이와 비슷한 역할을 하지만, 더 안전하고 성능상 이점이 있다. 
  
C++에서는 템플릿 인스턴스화 시점에 에러가 발생할 수 있고, 가상 함수는 런타임 오버헤드가 있다. 하지만 Rust는 컴파일 타임에 모든 타입을 검증하고, 제로 비용 추상화를 제공해. 즉, 추상화를 사용해도 성능 손실이 없다는 뜻이다.
  

## 7.1 제네릭 함수와 구조체

### 제네릭 함수 기본

```rust
// 제네릭을 사용하지 않은 중복 코드
fn find_largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn find_largest_char(list: &[char]) -> char {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// 제네릭을 사용한 통합 함수
fn find_largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    let result = find_largest(&numbers);
    println!("가장 큰 숫자: {}", result);
    
    let chars = vec!['y', 'm', 'a', 'q'];
    let result = find_largest(&chars);
    println!("가장 큰 문자: {}", result);
}
```   
  
#### find_largest 함수 시그니처 분석
**제네릭 타입 매개변수**
```rust
fn find_largest<T: PartialOrd + Copy>(list: &[T]) -> T
```

- `<T: PartialOrd + Copy>`: 제네릭 타입 `T`에 대한 트레이트 바운드다
- `T`는 컴파일 타임에 구체적인 타입으로 결정된다
- 이 함수는 `i32`, `f64`, `char` 등 다양한 타입에서 사용할 수 있다

#### 트레이트 바운드 상세 분석
**PartialOrd 트레이트**
```rust
T: PartialOrd
```
- 부분 순서 관계를 정의하는 트레이트다
- `>`, `<`, `>=`, `<=` 연산자를 사용할 수 있게 해준다
- `item > largest` 비교를 위해 필요하다
- `Ord`와 달리 모든 값이 비교 가능하지 않을 수도 있다 (예: NaN과 다른 수)

**Copy 트레이트**
```rust
T: Copy
```
- 값을 복사할 수 있는 타입임을 나타낸다
- `let mut largest = list[0]`에서 값을 복사하기 위해 필요하다
- `i32`, `f64`, `char` 같은 기본 타입들이 구현하고 있다
- `String`이나 `Vec` 같은 힙 할당 타입은 `Copy`를 구현하지 않는다

#### 함수 매개변수와 반환값

**매개변수: `list: &[T]`**
- 슬라이스에 대한 불변 참조를 받는다
- 소유권을 가져오지 않고 빌려온다
- 배열, 벡터, 슬라이스 모두 전달 가능하다

**반환값: `-> T`**
- `T` 타입의 값을 직접 반환한다 (참조가 아님)
- `Copy` 트레이트 덕분에 값을 복사해서 반환할 수 있다

#### 함수 구현부 분석

**초기화**
```rust
let mut largest = list[0];
```
- 첫 번째 요소를 가장 큰 값의 초기값으로 설정한다
- `Copy` 트레이트 덕분에 값이 복사된다
- 빈 슬라이스가 전달되면 패닉이 발생한다

**반복과 비교**
```rust
for &item in list {
    if item > largest {
        largest = item;
    }
}
```
- `&item`: 패턴 매칭으로 참조를 역참조한다
- `item > largest`: `PartialOrd` 트레이트의 비교 연산을 사용한다
- 더 큰 값을 찾으면 `largest`를 업데이트한다

#### 사용 예제

```rust
fn main() {
    // 정수 배열에서 사용
    let numbers = vec![34, 50, 25, 100, 65];
    let result = find_largest(&numbers);
    println!("가장 큰 수: {}", result); // 100

    // 문자 배열에서 사용
    let chars = vec!['y', 'm', 'a', 'q'];
    let result = find_largest(&chars);
    println!("가장 큰 문자: {}", result); // 'y'

    // 부동소수점에서 사용
    let floats = vec![1.1, 2.2, 0.5, 3.3];
    let result = find_largest(&floats);
    println!("가장 큰 실수: {}", result); // 3.3
}
```
  
#### 컴파일 타임 단형화(Monomorphization)

```rust
// 컴파일러가 생성하는 실제 코드 (개념적)
fn find_largest_i32(list: &[i32]) -> i32 { /* ... */ }
fn find_largest_f64(list: &[f64]) -> f64 { /* ... */ }
fn find_largest_char(list: &[char]) -> char { /* ... */ }
```

컴파일러는 사용되는 각 타입에 대해 별도의 함수를 생성하므로 런타임 성능 손실이 없다.

#### 핵심 정리
- 제네릭과 트레이트 바운드를 사용해서 타입 안전하면서도 재사용 가능한 함수를 작성했다
- `PartialOrd`로 비교 가능하고, `Copy`로 복사 가능한 타입에서만 동작한다
- 컴파일 타임에 타입이 결정되므로 런타임 성능이 우수하다
- 빈 슬라이스 처리나 더 범용적인 타입 지원을 위해 개선할 수 있다

C#의 제네릭 메서드나 Go의 제네릭과 비슷하지만, 트레이트 시스템을 통해 더 정교한 타입 제약을 표현할 수 있다.
  
  
### C++와의 제네릭 비교

```cpp
// C++ 템플릿
#include <iostream>
#include <vector>

template<typename T>
T find_largest(const std::vector<T>& list) {
    T largest = list[0];
    for (const auto& item : list) {
        if (item > largest) {
            largest = item;
        }
    }
    return largest;
}

int main() {
    std::vector<int> numbers = {34, 50, 25, 100, 65};
    auto result = find_largest(numbers);
    std::cout << "가장 큰 숫자: " << result << std::endl;
}
```

```rust
// Rust 제네릭 (더 안전함)
fn find_largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    let result = find_largest(&numbers);
    println!("가장 큰 숫자: {}", result);
}
```

### 제네릭 구조체

```rust
// 기본 제네릭 구조체
#[derive(Debug)]
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn new(x: T, y: T) -> Self {
        Point { x, y }
    }
    
    fn x(&self) -> &T {
        &self.x
    }
    
    fn y(&self) -> &T {
        &self.y
    }
}

// 특정 타입에 대해서만 메서드 구현
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// 여러 제네릭 타입을 가지는 구조체
#[derive(Debug)]
struct Pair<T, U> {
    first: T,
    second: U,
}

impl<T, U> Pair<T, U> {
    fn new(first: T, second: U) -> Self {
        Pair { first, second }
    }
    
    fn first(&self) -> &T {
        &self.first
    }
    
    fn second(&self) -> &U {
        &self.second
    }
    
    // 다른 타입의 Pair로 변환
    fn mixup<V, W>(self, other: Pair<V, W>) -> Pair<T, W> {
        Pair {
            first: self.first,
            second: other.second,
        }
    }
}

fn main() {
    // 정수 포인트
    let integer_point = Point::new(5, 10);
    println!("정수 포인트: {:?}", integer_point);
    println!("x 좌표: {}", integer_point.x());
    
    // 부동소수점 포인트
    let float_point = Point::new(1.0, 4.0);
    println!("부동소수점 포인트: {:?}", float_point);
    println!("원점으로부터 거리: {}", float_point.distance_from_origin());
    
    // 서로 다른 타입의 쌍
    let pair1 = Pair::new("hello", 42);
    let pair2 = Pair::new(3.14, true);
    let mixed = pair1.mixup(pair2);
    
    println!("혼합된 쌍: first = {}, second = {}", mixed.first(), mixed.second());
}
```

### 제네릭 열거형

```rust
// Option과 Result는 이미 제네릭 열거형의 좋은 예시
// 커스텀 제네릭 열거형 만들기

#[derive(Debug)]
enum Container<T> {
    Empty,
    Single(T),
    Multiple(Vec<T>),
}

impl<T> Container<T> {
    fn new() -> Self {
        Container::Empty
    }
    
    fn add(self, item: T) -> Self {
        match self {
            Container::Empty => Container::Single(item),
            Container::Single(existing) => Container::Multiple(vec![existing, item]),
            Container::Multiple(mut items) => {
                items.push(item);
                Container::Multiple(items)
            }
        }
    }
    
    fn count(&self) -> usize {
        match self {
            Container::Empty => 0,
            Container::Single(_) => 1,
            Container::Multiple(items) => items.len(),
        }
    }
}

impl<T: Clone> Container<T> {
    fn get_all(&self) -> Vec<T> {
        match self {
            Container::Empty => vec![],
            Container::Single(item) => vec![item.clone()],
            Container::Multiple(items) => items.clone(),
        }
    }
}

fn main() {
    let mut container = Container::<i32>::new();
    println!("빈 컨테이너: {:?}, 개수: {}", container, container.count());
    
    container = container.add(10);
    println!("요소 1개: {:?}, 개수: {}", container, container.count());
    
    container = container.add(20);
    println!("요소 2개: {:?}, 개수: {}", container, container.count());
    
    container = container.add(30);
    println!("요소 3개: {:?}, 개수: {}", container, container.count());
    
    let all_items = container.get_all();
    println!("모든 요소: {:?}", all_items);
}
```
  
</br>  
  
  
## 7.2 트레이트 정의와 구현

### 기본 트레이트 정의

```rust
// 트레이트 정의
trait Drawable {
    fn draw(&self);
    
    // 기본 구현을 가진 메서드
    fn describe(&self) {
        println!("이것은 그릴 수 있는 객체입니다.");
    }
}

// 구조체 정의
struct Circle {
    radius: f64,
}

struct Rectangle {
    width: f64,
    height: f64,
}

struct Triangle {
    base: f64,
    height: f64,
}

// 트레이트 구현
impl Drawable for Circle {
    fn draw(&self) {
        println!("반지름이 {}인 원을 그립니다.", self.radius);
    }
    
    // describe는 기본 구현을 사용할 수도 있고, 재정의할 수도 있음
    fn describe(&self) {
        println!("이것은 원입니다. 반지름: {}", self.radius);
    }
}

impl Drawable for Rectangle {
    fn draw(&self) {
        println!("{}x{} 크기의 사각형을 그립니다.", self.width, self.height);
    }
}

impl Drawable for Triangle {
    fn draw(&self) {
        println!("밑변 {}, 높이 {}인 삼각형을 그립니다.", self.base, self.height);
    }
}

// 트레이트를 매개변수로 받는 함수
fn draw_shape(shape: &dyn Drawable) {
    shape.describe();
    shape.draw();
}

// 제네릭과 트레이트 바운드를 함께 사용
fn draw_shape_generic<T: Drawable>(shape: &T) {
    shape.describe();
    shape.draw();
}

fn main() {
    let circle = Circle { radius: 5.0 };
    let rectangle = Rectangle { width: 10.0, height: 5.0 };
    let triangle = Triangle { base: 8.0, height: 6.0 };
    
    println!("=== 다이나믹 디스패치 ===");
    draw_shape(&circle);
    draw_shape(&rectangle);
    draw_shape(&triangle);
    
    println!("\n=== 스태틱 디스패치 (제네릭) ===");
    draw_shape_generic(&circle);
    draw_shape_generic(&rectangle);
    draw_shape_generic(&triangle);
}
```

### C++와의 트레이트 비교

```cpp
// C++ 가상 함수 (인터페이스)
class Drawable {
public:
    virtual void draw() const = 0;  // 순수 가상 함수
    virtual void describe() const { // 기본 구현
        std::cout << "이것은 그릴 수 있는 객체입니다." << std::endl;
    }
    virtual ~Drawable() = default;
};

class Circle : public Drawable {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    void draw() const override {
        std::cout << "반지름이 " << radius << "인 원을 그립니다." << std::endl;
    }
};

// 다형성 사용
void draw_shape(const Drawable& shape) {
    shape.describe();
    shape.draw();
}
```

```rust
// Rust 트레이트 (더 유연하고 안전함)
trait Drawable {
    fn draw(&self);
    fn describe(&self) {
        println!("이것은 그릴 수 있는 객체입니다.");
    }
}

struct Circle {
    radius: f64,
}

impl Drawable for Circle {
    fn draw(&self) {
        println!("반지름이 {}인 원을 그립니다.", self.radius);
    }
}

// 스태틱 디스패치 (성능 우수)
fn draw_shape_generic<T: Drawable>(shape: &T) {
    shape.describe();
    shape.draw();
}

// 다이나믹 디스패치 (유연성 우수)
fn draw_shape_dynamic(shape: &dyn Drawable) {
    shape.describe();
    shape.draw();
}
```

### 복합 트레이트와 연관 함수

```rust
// 여러 기능을 가진 트레이트
trait Calculable {
    fn area(&self) -> f64;
    fn perimeter(&self) -> f64;
    
    // 연관 함수 (static 함수와 유사)
    fn shape_type() -> &'static str;
    
    // 기본 구현이 있는 메서드
    fn info(&self) {
        println!("{}: 넓이 = {:.2}, 둘레 = {:.2}", 
                 Self::shape_type(), self.area(), self.perimeter());
    }
}

impl Calculable for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * std::f64::consts::PI * self.radius
    }
    
    fn shape_type() -> &'static str {
        "원"
    }
}

impl Calculable for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
    
    fn perimeter(&self) -> f64 {
        2.0 * (self.width + self.height)
    }
    
    fn shape_type() -> &'static str {
        "사각형"
    }
}

// 여러 트레이트를 동시에 요구
fn analyze_shape<T: Drawable + Calculable>(shape: &T) {
    println!("=== 도형 분석 ===");
    shape.draw();
    shape.info();
}

fn main() {
    let circle = Circle { radius: 3.0 };
    let rectangle = Rectangle { width: 4.0, height: 6.0 };
    
    analyze_shape(&circle);
    println!();
    analyze_shape(&rectangle);
    
    // 연관 함수 호출
    println!("\n연관 함수 호출:");
    println!("원 타입: {}", <Circle as Calculable>::shape_type());
    println!("사각형 타입: {}", <Rectangle as Calculable>::shape_type());
}
```

### 트레이트 객체와 박싱

```rust
// 트레이트 객체를 저장하는 벡터
fn main() {
    let shapes: Vec<Box<dyn Drawable>> = vec![
        Box::new(Circle { radius: 2.0 }),
        Box::new(Rectangle { width: 3.0, height: 4.0 }),
        Box::new(Triangle { base: 5.0, height: 6.0 }),
    ];
    
    println!("모든 도형 그리기:");
    for (i, shape) in shapes.iter().enumerate() {
        println!("도형 {}:", i + 1);
        shape.draw();
    }
    
    // Rc를 사용한 공유
    use std::rc::Rc;
    
    let shared_circle = Rc::new(Circle { radius: 10.0 });
    let shapes_shared: Vec<Rc<dyn Drawable>> = vec![
        shared_circle.clone(),
        Rc::new(Rectangle { width: 8.0, height: 12.0 }),
    ];
    
    println!("\n공유된 도형들:");
    for shape in &shapes_shared {
        shape.draw();
    }
    
    // shared_circle은 여전히 사용 가능
    println!("공유된 원의 반지름: {}", shared_circle.radius);
}
```
  
</br>  
  

## 7.3 트레이트 바운드

### 기본 트레이트 바운드

```rust
use std::fmt::{Debug, Display};

// 트레이트 바운드를 사용한 제네릭 함수
fn print_debug<T: Debug>(item: &T) {
    println!("디버그: {:?}", item);
}

fn print_display<T: Display>(item: &T) {
    println!("디스플레이: {}", item);
}

// 여러 트레이트 바운드
fn print_both<T: Debug + Display>(item: &T) {
    println!("디버그: {:?}", item);
    println!("디스플레이: {}", item);
}

// where 절을 사용한 더 읽기 쉬운 문법
fn complex_function<T, U>(t: &T, u: &U) -> String 
where
    T: Display + Debug,
    U: Clone + Debug,
{
    format!("T: {} (debug: {:?}), U: {:?}", t, t, u)
}

fn main() {
    let number = 42;
    let text = "Hello, Rust!";
    
    print_debug(&number);
    print_display(&number);
    print_both(&number);
    
    print_debug(&text);
    print_display(&text);
    print_both(&text);
    
    let result = complex_function(&number, &text.to_string());
    println!("복합 함수 결과: {}", result);
}
```

### 조건부 트레이트 구현

```rust
use std::fmt::Display;

// 제네릭 구조체
struct Wrapper<T> {
    value: T,
}

impl<T> Wrapper<T> {
    fn new(value: T) -> Self {
        Wrapper { value }
    }
}

// T가 Display를 구현할 때만 이 메서드 제공
impl<T: Display> Wrapper<T> {
    fn print(&self) {
        println!("Wrapped value: {}", self.value);
    }
}

// T가 Debug를 구현할 때만 이 메서드 제공
impl<T: std::fmt::Debug> Wrapper<T> {
    fn debug_print(&self) {
        println!("Debug wrapped value: {:?}", self.value);
    }
}

// T가 Clone을 구현할 때만 이 메서드 제공
impl<T: Clone> Wrapper<T> {
    fn duplicate(&self) -> Wrapper<T> {
        Wrapper::new(self.value.clone())
    }
}

// 특정 타입에 대해서만 트레이트 구현 (블랭킷 구현)
trait Printable {
    fn print_fancy(&self);
}

impl<T: Display> Printable for T {
    fn print_fancy(&self) {
        println!("*** {} ***", self);
    }
}

fn main() {
    let number_wrapper = Wrapper::new(42);
    let string_wrapper = Wrapper::new("Hello".to_string());
    
    // Display를 구현하는 타입들은 print 메서드 사용 가능
    number_wrapper.print();
    string_wrapper.print();
    
    // Debug를 구현하는 타입들은 debug_print 메서드 사용 가능
    number_wrapper.debug_print();
    string_wrapper.debug_print();
    
    // Clone을 구현하는 타입들은 duplicate 메서드 사용 가능
    let duplicated = string_wrapper.duplicate();
    duplicated.print();
    
    // 블랭킷 구현된 트레이트 사용
    42.print_fancy();
    "Rust".print_fancy();
}
```

### 제네릭 라이프타임과 트레이트 바운드

```rust
use std::fmt::Display;

// 라이프타임과 트레이트 바운드를 함께 사용
fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str 
where
    T: Display,
{
    println!("공지: {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// 트레이트 바운드가 있는 구조체와 라이프타임
struct ImportantExcerpt<'a, T> 
where
    T: Display,
{
    part: &'a str,
    metadata: T,
}

impl<'a, T> ImportantExcerpt<'a, T> 
where
    T: Display,
{
    fn new(part: &'a str, metadata: T) -> Self {
        ImportantExcerpt { part, metadata }
    }
    
    fn announce_and_return_part(&self) -> &str {
        println!("주목! 메타데이터: {}", self.metadata);
        self.part
    }
}

fn main() {
    let string1 = String::from("긴 문자열입니다");
    let string2 = "짧은 문자열";
    
    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        "이것은 중요한 공지입니다",
    );
    
    println!("더 긴 문자열: {}", result);
    
    let excerpt = ImportantExcerpt::new("중요한 텍스트", 42);
    let part = excerpt.announce_and_return_part();
    println!("추출된 부분: {}", part);
}
```
  
</br>  
  

## 7.4 연관 타입

### 기본 연관 타입

```rust
// Iterator 트레이트 (표준 라이브러리에 있는 것과 유사)
trait Iterator {
    type Item;  // 연관 타입
    
    fn next(&mut self) -> Option<Self::Item>;
    
    // 기본 구현들
    fn collect<B: FromIterator<Self::Item>>(self) -> B 
    where
        Self: Sized,
    {
        FromIterator::from_iter(self)
    }
    
    fn map<B, F>(self, f: F) -> Map<Self, F> 
    where
        Self: Sized,
        F: FnMut(Self::Item) -> B,
    {
        Map { iter: self, f }
    }
}

// Map 구조체 (간단한 구현)
struct Map<I, F> {
    iter: I,
    f: F,
}

impl<B, I: Iterator, F> Iterator for Map<I, F> 
where
    F: FnMut(I::Item) -> B,
{
    type Item = B;
    
    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next().map(&mut self.f)
    }
}

// FromIterator 트레이트 (간단한 버전)
trait FromIterator<A> {
    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self;
}

impl<T> FromIterator<T> for Vec<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        let mut vec = Vec::new();
        for item in iter {
            vec.push(item);
        }
        vec
    }
}

// 커스텀 이터레이터 구현
struct Counter {
    current: usize,
    max: usize,
}

impl Counter {
    fn new(max: usize) -> Counter {
        Counter { current: 0, max }
    }
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.max {
            let current = self.current;
            self.current += 1;
            Some(current)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(5);
    
    println!("카운터 값들:");
    for value in counter {
        println!("{}", value);
    }
    
    // 체이닝 사용
    let doubled: Vec<usize> = Counter::new(5)
        .map(|x| x * 2)
        .collect();
    
    println!("두 배로 만든 값들: {:?}", doubled);
}
```

### 연관 타입 vs 제네릭

```rust
// 제네릭을 사용한 경우 (여러 Add 구현이 가능)
trait Add<RHS> {
    type Output;
    fn add(self, rhs: RHS) -> Self::Output;
}

// 연관 타입을 사용한 경우 (하나의 Add 구현만 가능)
trait AddAssoc {
    type Rhs;
    type Output;
    fn add(self, rhs: Self::Rhs) -> Self::Output;
}

// 실제 std::ops::Add는 제네릭과 연관 타입을 함께 사용
struct Point {
    x: i32,
    y: i32,
}

impl Add<Point> for Point {
    type Output = Point;
    
    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl Add<i32> for Point {
    type Output = Point;
    
    fn add(self, scalar: i32) -> Point {
        Point {
            x: self.x + scalar,
            y: self.y + scalar,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = p1.add(p2);
    
    println!("Point + Point = ({}, {})", p3.x, p3.y);
    
    let p4 = Point { x: 10, y: 20 };
    let p5 = p4.add(5);
    
    println!("Point + scalar = ({}, {})", p5.x, p5.y);
}
```

### 고급 연관 타입 예제

```rust
// 데이터베이스 연결을 추상화하는 트레이트
trait Database {
    type Connection;
    type Error;
    
    fn connect(&self) -> Result<Self::Connection, Self::Error>;
}

trait Query<DB: Database> {
    type Result;
    
    fn execute(&self, conn: &DB::Connection) -> Result<Self::Result, DB::Error>;
}

// MySQL 구현
struct MySQL {
    host: String,
}

struct MySQLConnection {
    _host: String,
}

#[derive(Debug)]
struct MySQLError {
    message: String,
}

impl std::fmt::Display for MySQLError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "MySQL Error: {}", self.message)
    }
}

impl std::error::Error for MySQLError {}

impl Database for MySQL {
    type Connection = MySQLConnection;
    type Error = MySQLError;
    
    fn connect(&self) -> Result<Self::Connection, Self::Error> {
        // 실제로는 MySQL 연결 로직
        println!("MySQL에 연결 중: {}", self.host);
        Ok(MySQLConnection {
            _host: self.host.clone(),
        })
    }
}

// 사용자 쿼리
struct UserQuery {
    user_id: i32,
}

impl<DB: Database> Query<DB> for UserQuery {
    type Result = String;
    
    fn execute(&self, _conn: &DB::Connection) -> Result<Self::Result, DB::Error> {
        // 실제로는 SQL 실행 로직
        Ok(format!("User data for ID: {}", self.user_id))
    }
}

// PostgreSQL 구현
struct PostgreSQL {
    host: String,
}

struct PostgreSQLConnection {
    _host: String,
}

#[derive(Debug)]
struct PostgreSQLError {
    code: i32,
    message: String,
}

impl std::fmt::Display for PostgreSQLError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "PostgreSQL Error {}: {}", self.code, self.message)
    }
}

impl std::error::Error for PostgreSQLError {}

impl Database for PostgreSQL {
    type Connection = PostgreSQLConnection;
    type Error = PostgreSQLError;
    
    fn connect(&self) -> Result<Self::Connection, Self::Error> {
        println!("PostgreSQL에 연결 중: {}", self.host);
        Ok(PostgreSQLConnection {
            _host: self.host.clone(),
        })
    }
}

// 제네릭 데이터베이스 작업 함수
fn fetch_user_data<DB: Database>(
    db: &DB,
    user_id: i32,
) -> Result<String, DB::Error> {
    let conn = db.connect()?;
    let query = UserQuery { user_id };
    query.execute(&conn)
}

fn main() {
    let mysql_db = MySQL {
        host: "localhost:3306".to_string(),
    };
    
    let postgresql_db = PostgreSQL {
        host: "localhost:5432".to_string(),
    };
    
    match fetch_user_data(&mysql_db, 123) {
        Ok(data) => println!("MySQL 결과: {}", data),
        Err(e) => eprintln!("MySQL 에러: {}", e),
    }
    
    match fetch_user_data(&postgresql_db, 456) {
        Ok(data) => println!("PostgreSQL 결과: {}", data),
        Err(e) => eprintln!("PostgreSQL 에러: {}", e),
    }
}
```
  
</br>  
  

## 실습: 제네릭을 활용한 컬렉션 라이브러리
이제 배운 내용을 종합해서 제네릭 컬렉션 라이브러리를 만들어보자:

```rust
use std::fmt::{Debug, Display};
use std::cmp::PartialEq;

// 컬렉션 트레이트 정의
trait Collection<T> {
    fn new() -> Self;
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool {
        self.len() == 0
    }
    fn add(&mut self, item: T);
    fn remove(&mut self, item: &T) -> bool where T: PartialEq;
    fn contains(&self, item: &T) -> bool where T: PartialEq;
    fn clear(&mut self);
}

// Iterable 트레이트
trait Iterable<T> {
    type Iterator: Iterator<Item = T>;
    fn iter(&self) -> Self::Iterator;
}

// 스택 구현
#[derive(Debug, Clone)]
struct Stack<T> {
    items: Vec<T>,
}

impl<T> Collection<T> for Stack<T> 
where 
    T: PartialEq + Clone,
{
    fn new() -> Self {
        Stack { items: Vec::new() }
    }
    
    fn len(&self) -> usize {
        self.items.len()
    }
    
    fn add(&mut self, item: T) {
        self.push(item);
    }
    
    fn remove(&mut self, item: &T) -> bool {
        if let Some(pos) = self.items.iter().position(|x| x == item) {
            self.items.remove(pos);
            true
        } else {
            false
        }
    }
    
    fn contains(&self, item: &T) -> bool {
        self.items.contains(item)
    }
    
    fn clear(&mut self) {
        self.items.clear();
    }
}

impl<T: Clone> Stack<T> {
    fn push(&mut self, item: T) {
        self.items.push(item);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }
    
    fn peek(&self) -> Option<&T> {
        self.items.last()
    }
}

// 스택 이터레이터
struct StackIterator<T> {
    stack: Stack<T>,
}

impl<T: Clone> Iterator for StackIterator<T> {
    type Item = T;
    
    fn next(&mut self) -> Option<Self::Item> {
        self.stack.pop()
    }
}

impl<T: Clone> Iterable<T> for Stack<T> {
    type Iterator = StackIterator<T>;
    
    fn iter(&self) -> Self::Iterator {
        StackIterator {
            stack: self.clone(),
        }
    }
}

// 큐 구현
use std::collections::VecDeque;

#[derive(Debug, Clone)]
struct Queue<T> {
    items: VecDeque<T>,
}

impl<T> Collection<T> for Queue<T> 
where 
    T: PartialEq + Clone,
{
    fn new() -> Self {
        Queue { items: VecDeque::new() }
    }
    
    fn len(&self) -> usize {
        self.items.len()
    }
    
    fn add(&mut self, item: T) {
        self.enqueue(item);
    }
    
    fn remove(&mut self, item: &T) -> bool {
        if let Some(pos) = self.items.iter().position(|x| x == item) {
            self.items.remove(pos);
            true
        } else {
            false
        }
    }
    
    fn contains(&self, item: &T) -> bool {
        self.items.contains(item)
    }
    
    fn clear(&mut self) {
        self.items.clear();
    }
}

impl<T: Clone> Queue<T> {
    fn enqueue(&mut self, item: T) {
        self.items.push_back(item);
    }
    
    fn dequeue(&mut self) -> Option<T> {
        self.items.pop_front()
    }
    
    fn front(&self) -> Option<&T> {
        self.items.front()
    }
}

// 큐 이터레이터
struct QueueIterator<T> {
    queue: Queue<T>,
}

impl<T: Clone> Iterator for QueueIterator<T> {
    type Item = T;
    
    fn next(&mut self) -> Option<Self::Item> {
        self.queue.dequeue()
    }
}

impl<T: Clone> Iterable<T> for Queue<T> {
    type Iterator = QueueIterator<T>;
    
    fn iter(&self) -> Self::Iterator {
        QueueIterator {
            queue: self.clone(),
        }
    }
}

// 우선순위 큐 구현
use std::collections::BinaryHeap;
use std::cmp::Reverse;

#[derive(Debug, Clone)]
struct PriorityQueue<T> {
    heap: BinaryHeap<T>,
}

impl<T: Ord + Clone> Collection<T> for PriorityQueue<T> {
    fn new() -> Self {
        PriorityQueue { heap: BinaryHeap::new() }
    }
    
    fn len(&self) -> usize {
        self.heap.len()
    }
    
    fn add(&mut self, item: T) {
        self.heap.push(item);
    }
    
    fn remove(&mut self, item: &T) -> bool {
        // BinaryHeap에서 특정 아이템 제거는 비효율적
        let items: Vec<T> = self.heap.drain().collect();
        let mut found = false;
        
        for heap_item in items {
            if !found && &heap_item == item {
                found = true;
            } else {
                self.heap.push(heap_item);
            }
        }
        
        found
    }
    
    fn contains(&self, item: &T) -> bool {
        self.heap.iter().any(|x| x == item)
    }
    
    fn clear(&mut self) {
        self.heap.clear();
    }
}

impl<T: Ord + Clone> PriorityQueue<T> {
    fn push(&mut self, item: T) {
        self.heap.push(item);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.heap.pop()
    }
    
    fn peek(&self) -> Option<&T> {
        self.heap.peek()
    }
}

// 최소 우선순위 큐
#[derive(Debug, Clone)]
struct MinPriorityQueue<T> {
    heap: BinaryHeap<Reverse<T>>,
}

impl<T: Ord + Clone> MinPriorityQueue<T> {
    fn new() -> Self {
        MinPriorityQueue { heap: BinaryHeap::new() }
    }
    
    fn push(&mut self, item: T) {
        self.heap.push(Reverse(item));
    }
    
    fn pop(&mut self) -> Option<T> {
        self.heap.pop().map(|Reverse(item)| item)
    }
    
    fn peek(&self) -> Option<&T> {
        self.heap.peek().map(|Reverse(item)| item)
    }
    
    fn len(&self) -> usize {
        self.heap.len()
    }
}

// 통계 트레이트
trait Statistics<T> {
    fn sum(&self) -> T;
    fn average(&self) -> Option<f64>;
    fn min(&self) -> Option<&T>;
    fn max(&self) -> Option<&T>;
}

// 숫자 컬렉션에 대한 통계 구현
impl<C, T> Statistics<T> for C 
where 
    C: Collection<T> + Iterable<T>,
    T: Copy + PartialOrd + std::ops::Add<Output = T> + Into<f64> + Default,
{
    fn sum(&self) -> T {
        let mut total = T::default();
        for item in self.iter() {
            total = total + item;
        }
        total
    }
    
    fn average(&self) -> Option<f64> {
        if self.is_empty() {
            None
        } else {
            let sum: f64 = self.sum().into();
            Some(sum / self.len() as f64)
        }
    }
    
    fn min(&self) -> Option<&T> {
        // 이 구현은 완전하지 않음 (수명 문제로 인해)
        // 실제로는 더 복잡한 구현이 필요
        None
    }
    
    fn max(&self) -> Option<&T> {
        // 마찬가지로 수명 문제
        None
    }
}

// 컬렉션 유틸리티 함수들
fn print_collection_info<C, T>(collection: &C, name: &str) 
where 
    C: Collection<T>,
    T: Debug,
{
    println!("{}: 길이 = {}, 비어있음 = {}", 
             name, collection.len(), collection.is_empty());
}

fn transform_collection<C, T, U, F>(collection: &C, mut transform: F) -> Vec<U>
where
    C: Iterable<T>,
    F: FnMut(T) -> U,
{
    collection.iter().map(|item| transform(item)).collect()
}

fn filter_collection<C, T, F>(collection: &C, mut predicate: F) -> Vec<T>
where
    C: Iterable<T>,
    F: FnMut(&T) -> bool,
{
    collection.iter().filter(|item| predicate(item)).collect()
}

// 메인 함수
fn main() {
    println!("=== 제네릭 컬렉션 라이브러리 테스트 ===\n");
    
    // 스택 테스트
    println!("--- 스택 테스트 ---");
    let mut stack = Stack::<i32>::new();
    stack.add(10);
    stack.add(20);
    stack.add(30);
    
    print_collection_info(&stack, "스택");
    println!("스택 내용: {:?}", stack);
    println!("peek: {:?}", stack.peek());
    println!("pop: {:?}", stack.pop());
    println!("pop 후: {:?}", stack);
    
    println!("스택 순회:");
    for item in stack.iter() {
        println!("  {}", item);
    }
    
    // 큐 테스트
    println!("\n--- 큐 테스트 ---");
    let mut queue = Queue::<String>::new();
    queue.add("first".to_string());
    queue.add("second".to_string());
    queue.add("third".to_string());
    
    print_collection_info(&queue, "큐");
    println!("큐 내용: {:?}", queue);
    println!("front: {:?}", queue.front());
    println!("dequeue: {:?}", queue.dequeue());
    println!("dequeue 후: {:?}", queue);
    
    println!("큐 순회:");
    for item in queue.iter() {
        println!("  {}", item);
    }
    
    // 우선순위 큐 테스트
    println!("\n--- 우선순위 큐 테스트 ---");
    let mut pq = PriorityQueue::<i32>::new();
    pq.add(30);
    pq.add(10);
    pq.add(20);
    pq.add(40);
    
    print_collection_info(&pq, "우선순위 큐");
    println!("peek (최대값): {:?}", pq.peek());
    
    println!("우선순위 순으로 제거:");
    while !pq.is_empty() {
        println!("  pop: {:?}", pq.pop());
    }
    
    // 최소 우선순위 큐 테스트
    println!("\n--- 최소 우선순위 큐 테스트 ---");
    let mut min_pq = MinPriorityQueue::new();
    min_pq.push(30);
    min_pq.push(10);
    min_pq.push(20);
    min_pq.push(40);
    
    println!("최소 우선순위 큐 길이: {}", min_pq.len());
    println!("peek (최소값): {:?}", min_pq.peek());
    
    println!("최소값부터 제거:");
    while min_pq.len() > 0 {
        println!("  pop: {:?}", min_pq.pop());
    }
    
    // 함수형 프로그래밍 스타일 테스트
    println!("\n--- 함수형 변환 테스트 ---");
    let numbers_stack = {
        let mut s = Stack::new();
        for i in 1..=5 {
            s.add(i);
        }
        s
    };
    
    let doubled = transform_collection(&numbers_stack, |x| x * 2);
    println!("원본 스택: {:?}", numbers_stack);
    println!("두 배로 변환: {:?}", doubled);
    
    let evens = filter_collection(&numbers_stack, |&x| x % 2 == 0);
    println!("짝수만 필터링: {:?}", evens);
    
    // 제네릭 알고리즘 테스트
    println!("\n--- 제네릭 알고리즘 테스트 ---");
    test_generic_algorithms();
}

// 추가 알고리즘들
fn test_generic_algorithms() {
    // 다양한 타입에서 동작하는 제네릭 함수들
    
    println!("정수 스택 테스트:");
    let mut int_stack = Stack::new();
    for i in 1..=5 {
        int_stack.add(i);
    }
    
    // 통계 계산 (기본 구현의 한계로 인해 간단한 버전)
    let sum: i32 = int_stack.iter().sum();
    let count = int_stack.len() as f64;
    let avg = sum as f64 / count;
    
    println!("합계: {}, 평균: {:.2}", sum, avg);
    
    println!("\n문자열 큐 테스트:");
    let mut string_queue = Queue::new();
    let words = ["apple", "banana", "cherry", "date"];
    for word in &words {
        string_queue.add(word.to_string());
    }
    
    println!("큐 내용:");
    for item in string_queue.iter() {
        println!("  {}", item);
    }
    
    // 타입 안전성 테스트
    println!("\n타입 안전성 테스트:");
    // let mut mixed_stack = Stack::new();
    // mixed_stack.add(42);
    // mixed_stack.add("hello"); // 컴파일 에러! 타입이 다름
}

// 추가: 컬렉션 비교 함수
fn compare_collections<C1, C2, T>(c1: &C1, c2: &C2) -> bool 
where 
    C1: Collection<T> + Iterable<T>,
    C2: Collection<T> + Iterable<T>,
    T: PartialEq,
{
    if c1.len() != c2.len() {
        return false;
    }
    
    let items1: Vec<T> = c1.iter().collect();
    let items2: Vec<T> = c2.iter().collect();
    
    items1 == items2
}

// 추가: 컬렉션 합치기
fn merge_collections<C1, C2, T>(c1: &C1, c2: &C2) -> Vec<T>
where
    C1: Iterable<T>,
    C2: Iterable<T>,
{
    let mut result = Vec::new();
    
    for item in c1.iter() {
        result.push(item);
    }
    
    for item in c2.iter() {
        result.push(item);
    }
    
    result
}
```

### 프로그램 실행 방법

```bash
cargo new generic_collections
cd generic_collections
# 위 코드를 src/main.rs에 복사
cargo run
```

### 실행 예시

```
=== 제네릭 컬렉션 라이브러리 테스트 ===

--- 스택 테스트 ---
스택: 길이 = 3, 비어있음 = false
스택 내용: Stack { items: [10, 20, 30] }
peek: Some(30)
pop: Some(30)
pop 후: Stack { items: [10, 20] }
스택 순회:
  20
  10

--- 큐 테스트 ---
큐: 길이 = 3, 비어있음 = false
큐 내용: Queue { items: ["first", "second", "third"] }
front: Some("first")
dequeue: Some("first")
dequeue 후: Queue { items: ["second", "third"] }
큐 순회:
  second
  third

--- 우선순위 큐 테스트 ---
우선순위 큐: 길이 = 4, 비어있음 = false
peek (최대값): Some(40)
우선순위 순으로 제거:
  pop: Some(40)
  pop: Some(30)
  pop: Some(20)
  pop: Some(10)
```

### 프로그램에서 사용된 제네릭과 트레이트 개념들

1. **제네릭 구조체**: `Stack<T>`, `Queue<T>`, `PriorityQueue<T>`
2. **트레이트 정의**: `Collection<T>`, `Iterable<T>`, `Statistics<T>`  
3. **트레이트 바운드**: `where T: PartialEq + Clone`
4. **연관 타입**: `type Iterator: Iterator<Item = T>`
5. **조건부 구현**: 특정 트레이트를 구현하는 타입에만 메서드 제공
6. **제네릭 함수**: 타입에 관계없이 동작하는 유틸리티 함수들

---

**이번 장 요약:**

1. **제네릭**: 타입 매개변수로 코드 재사용성 극대화, 컴파일 타임 타입 검증
2. **트레이트**: 공통 동작을 정의하는 인터페이스, 다형성과 코드 조직화
3. **트레이트 바운드**: 제네릭 타입이 가져야 할 능력을 명시적으로 제한
4. **연관 타입**: 트레이트의 일부로 타입을 정의하여 더 명확한 API 제공
5. **제로 비용 추상화**: 추상화를 사용해도 런타임 성능 손실 없음

Rust의 제네릭과 트레이트 시스템은 C++의 템플릿보다 더 안전하고, Java/C#의 인터페이스보다 더 유연하다. 컴파일 타임에 모든 타입을 확정하므로 성능도 우수하고, 트레이트 시스템으로 강력한 추상화가 가능하다.   