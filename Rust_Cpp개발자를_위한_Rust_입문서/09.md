# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
    
# 9장. 동시성 프로그래밍 기초

## 들어가기 전에
C++에서 멀티스레딩을 다뤄본 적이 있다면, 데이터 레이스(data race), 데드락(deadlock), 메모리 접근 순서 등의 복잡한 문제들을 만난 적이 있을 것이다. 이런 문제들은 런타임에 발생하고 디버깅이 어려워서 개발자들을 괴롭히는 문제이다.  
  
Rust는 이런 문제들을 컴파일 타임에 해결한다. 소유권 시스템과 타입 시스템을 통해 데이터 레이스를 원천적으로 차단하고, 안전한 동시성을 보장한다. Rust의 동시성 모델은 두 가지 주요 패러다임을 지원한다:  
  
1. **메시지 패싱**: "메모리를 공유하지 말고 통신으로 공유하라"
2. **공유 상태**: 안전한 메모리 공유를 위한 동기화 프리미티브
  

## 9.1 스레드 생성과 관리

### 기본 스레드 생성

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // 메인 스레드
    println!("메인 스레드에서 시작");
    
    // 새 스레드 생성
    let handle = thread::spawn(|| {
        for i in 1..=5 {
            println!("새 스레드에서: {}", i);
            thread::sleep(Duration::from_millis(500));
        }
    });
    
    // 메인 스레드에서 작업
    for i in 1..=3 {
        println!("메인 스레드에서: {}", i);
        thread::sleep(Duration::from_millis(300));
    }
    
    // 새 스레드가 끝날 때까지 기다림
    handle.join().unwrap();
    println!("모든 스레드 완료");
}
```

### C++와의 스레드 비교

```cpp
// C++
#include <iostream>
#include <thread>
#include <chrono>

int main() {
    std::cout << "메인 스레드에서 시작" << std::endl;
    
    // 새 스레드 생성
    std::thread t([]() {
        for (int i = 1; i <= 5; ++i) {
            std::cout << "새 스레드에서: " << i << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        }
    });
    
    // 메인 스레드에서 작업
    for (int i = 1; i <= 3; ++i) {
        std::cout << "메인 스레드에서: " << i << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(300));
    }
    
    // 스레드 조인
    t.join();
    std::cout << "모든 스레드 완료" << std::endl;
    
    return 0;
}
```

```rust
// Rust (더 안전함)
use std::thread;
use std::time::Duration;

fn main() {
    println!("메인 스레드에서 시작");
    
    let handle = thread::spawn(|| {
        for i in 1..=5 {
            println!("새 스레드에서: {}", i);
            thread::sleep(Duration::from_millis(500));
        }
    });
    
    for i in 1..=3 {
        println!("메인 스레드에서: {}", i);
        thread::sleep(Duration::from_millis(300));
    }
    
    handle.join().unwrap(); // Result 타입으로 에러 처리
    println!("모든 스레드 완료");
}
```

### 스레드에서 데이터 사용하기

```rust
use std::thread;

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    
    // 데이터를 스레드로 이동
    let handle = thread::spawn(move || {
        println!("스레드에서 받은 데이터: {:?}", data);
        let sum: i32 = data.iter().sum();
        sum
    });
    
    // data는 더 이상 사용할 수 없음 (move됨)
    // println!("{:?}", data); // 컴파일 에러!
    
    let result = handle.join().unwrap();
    println!("계산 결과: {}", result);
}
```

### 여러 스레드 생성과 관리

```rust
use std::thread;

fn main() {
    let mut handles = vec![];
    
    // 5개의 스레드 생성
    for i in 0..5 {
        let handle = thread::spawn(move || {
            println!("스레드 {} 시작", i);
            
            // 각 스레드별로 다른 작업 시간
            let sleep_time = (i + 1) * 100;
            thread::sleep(std::time::Duration::from_millis(sleep_time));
            
            println!("스레드 {} 완료", i);
            i * 2 // 결과값 반환
        });
        
        handles.push(handle);
    }
    
    // 모든 스레드의 완료를 기다리고 결과 수집
    let results: Vec<i32> = handles
        .into_iter()
        .map(|handle| handle.join().unwrap())
        .collect();
    
    println!("모든 결과: {:?}", results);
    println!("결과 합계: {}", results.iter().sum::<i32>());
}
```

### 스레드 빌더와 설정

```rust
use std::thread;

fn main() {
    // 스레드 이름과 스택 크기 설정
    let builder = thread::Builder::new()
        .name("worker".to_string())
        .stack_size(32 * 1024); // 32KB 스택
    
    let handle = builder.spawn(|| {
        println!("작업자 스레드 실행 중");
        
        // 현재 스레드 정보
        let current_thread = thread::current();
        println!("스레드 이름: {:?}", current_thread.name());
        println!("스레드 ID: {:?}", current_thread.id());
        
        // 긴 작업 시뮬레이션
        for i in 1..=10 {
            println!("작업 진행: {}%", i * 10);
            thread::sleep(std::time::Duration::from_millis(200));
        }
        
        "작업 완료"
    }).unwrap();
    
    match handle.join() {
        Ok(result) => println!("스레드 결과: {}", result),
        Err(e) => println!("스레드 에러: {:?}", e),
    }
}
```

### 스레드 풀 패턴

```rust
use std::sync::{Arc, Mutex};
use std::sync::mpsc;
use std::thread;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        assert!(size > 0);
        
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        
        let mut workers = Vec::with_capacity(size);
        
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }
        
        ThreadPool { workers, sender }
    }
    
    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || {
            println!("작업자 {} 시작됨", id);
            
            loop {
                let job = receiver.lock().unwrap().recv();
                
                match job {
                    Ok(job) => {
                        println!("작업자 {}가 작업을 받았습니다", id);
                        job();
                    }
                    Err(_) => {
                        println!("작업자 {} 종료됨", id);
                        break;
                    }
                }
            }
        });
        
        Worker { id, thread }
    }
}

fn main() {
    let pool = ThreadPool::new(3);
    
    // 여러 작업을 스레드 풀에 제출
    for i in 1..=10 {
        pool.execute(move || {
            println!("작업 {} 시작", i);
            thread::sleep(std::time::Duration::from_millis(500));
            println!("작업 {} 완료", i);
        });
    }
    
    // 잠시 대기하여 작업 완료 관찰
    thread::sleep(std::time::Duration::from_secs(3));
    println!("메인 함수 종료");
}
```  
  
#### 핵심 구조체들

##### 1. Job 타입 정의
```rust
type Job = Box<dyn FnOnce() + Send + 'static>;
```
- `Box<dyn FnOnce()>`: 힙에 할당된 클로저를 담는 박스다
- `Send`: 스레드 간 전송 가능한 타입임을 보장한다
- `'static`: 정적 생명주기를 가져야 한다 (스레드가 언제 끝날지 모르므로)

##### 2. ThreadPool 구조체
```rust
struct ThreadPool {
    workers: Vec<Worker>,           // 작업자 스레드들
    sender: mpsc::Sender<Job>,      // 작업을 보내는 채널
}
```

##### 3. Worker 구조체
```rust
struct Worker {
    id: usize,                      // 작업자 ID
    thread: thread::JoinHandle<()>, // 스레드 핸들
}
```

#### 동작 원리

##### ThreadPool::new() 분석
```rust
fn new(size: usize) -> ThreadPool {
    assert!(size > 0);  // 스레드 개수 검증
    
    let (sender, receiver) = mpsc::channel();       // 채널 생성
    let receiver = Arc::new(Mutex::new(receiver));  // 공유 가능하게 래핑
    
    let mut workers = Vec::with_capacity(size);
    
    for id in 0..size {
        workers.push(Worker::new(id, Arc::clone(&receiver)));  // 각 작업자 생성
    }
    
    ThreadPool { workers, sender }
}
```

**핵심 아이디어:**
- 하나의 `sender`로 작업을 보낸다
- 여러 `Worker`가 하나의 `receiver`를 공유한다
- `Arc<Mutex<>>`로 안전한 공유를 보장한다

##### Worker::new() 분석
```rust
fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
    let thread = thread::spawn(move || {
        loop {
            let job = receiver.lock().unwrap().recv();  // 작업 대기
            
            match job {
                Ok(job) => {
                    println!("작업자 {}가 작업을 받았습니다", id);
                    job();  // 작업 실행
                }
                Err(_) => {
                    println!("작업자 {} 종료됨", id);
                    break;  // 채널이 닫히면 종료
                }
            }
        }
    });
    
    Worker { id, thread }
}
```

**동작 과정:**
1. 각 Worker는 무한 루프로 작업을 기다린다
2. `receiver.lock()`으로 뮤텍스를 잠그고 작업을 받는다
3. 작업을 받으면 실행하고 다시 대기 상태로 돌아간다

#### 동시성 메커니즘

##### `Arc<Mutex<Receiver>>` 패턴
```rust
let receiver = Arc<Mutex<mpsc::Receiver<Job>>>;
```

- **Arc (Atomic Reference Counter)**: 여러 스레드가 동일한 데이터를 공유할 수 있게 한다
- **Mutex (Mutual Exclusion)**: 한 번에 하나의 스레드만 접근 가능하게 한다
- **Receiver**: 채널에서 메시지를 받는 역할을 한다

##### 작업 흐름
```
Main Thread                    Worker Threads
    |                              |
    | -- execute(job1) -->         |
    | -- execute(job2) -->    Worker 1: 받아서 실행
    | -- execute(job3) -->    Worker 2: 받아서 실행  
    |                         Worker 3: 받아서 실행
```

#### 게임 서버에서 활용 예시

```rust
// 게임 서버에서 사용 예시
let pool = ThreadPool::new(4);

// 플레이어 요청 처리
pool.execute(move || {
    process_player_login(player_id);
});

// 게임 로직 처리
pool.execute(move || {
    update_game_state(room_id);
});

// 데이터베이스 작업
pool.execute(move || {
    save_player_data_to_db(player_data);
});
```

#### 주요 장점

1. **성능**: 스레드 생성/소멸 비용을 줄인다
2. **자원 관리**: 동시 실행 스레드 수를 제한한다
3. **안전성**: Rust의 소유권 시스템으로 데이터 레이스를 방지한다

이 패턴은 웹 서버나 게임 서버에서 클라이언트 요청을 효율적으로 처리할 때 매우 유용하다. 특히 C#의 ThreadPool이나 Golang의 goroutine과 비슷한 역할을 한다.
  
</br>    
  

## 9.2 메시지 패싱 (채널)

### 기본 채널 사용법

```rust
use std::sync::mpsc; // multiple producer, single consumer
use std::thread;
use std::time::Duration;

fn main() {
    // 채널 생성 (송신자, 수신자)
    let (tx, rx) = mpsc::channel();
    
    // 송신자를 스레드로 이동
    thread::spawn(move || {
        let messages = vec!["안녕", "Rust", "채널", "테스트"];
        
        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(500));
        }
    });
    
    // 메인 스레드에서 메시지 수신
    for received in rx {
        println!("받은 메시지: {}", received);
    }
    
    println!("모든 메시지 수신 완료");
}
```

### 여러 송신자 패턴

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    
    // 여러 송신자 생성
    for i in 1..=3 {
        let tx_clone = tx.clone(); // 송신자 복제
        
        thread::spawn(move || {
            for j in 1..=5 {
                let msg = format!("송신자 {}에서 메시지 {}", i, j);
                tx_clone.send(msg).unwrap();
                thread::sleep(std::time::Duration::from_millis(100));
            }
        });
    }
    
    // 원본 송신자 해제 (중요!)
    drop(tx);
    
    // 모든 메시지 수신
    while let Ok(msg) = rx.recv() {
        println!("받은 메시지: {}", msg);
    }
    
    println!("모든 송신자 완료");
}
```

### 동기식 채널 (Synchronous Channel)

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    // 버퍼 크기가 0인 동기식 채널
    let (tx, rx) = mpsc::sync_channel::<String>(0);
    
    let tx_clone = tx.clone();
    
    // 송신자 스레드
    thread::spawn(move || {
        for i in 1..=3 {
            let msg = format!("메시지 {}", i);
            println!("보내는 중: {}", msg);
            tx_clone.send(msg).unwrap();
            println!("전송 완료: 메시지 {}", i);
        }
    });
    
    // 수신 지연으로 동기화 확인
    thread::sleep(std::time::Duration::from_secs(1));
    
    for received in rx {
        println!("받음: {}", received);
        thread::sleep(std::time::Duration::from_millis(500)); // 수신 지연
    }
}
```

### 양방향 통신

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

#[derive(Debug)]
enum WorkerMessage {
    Work(String),
    Terminate,
}

#[derive(Debug)]
enum MainMessage {
    Result(String),
    Status(String),
}

fn main() {
    // 메인 -> 작업자 채널
    let (main_tx, worker_rx) = mpsc::channel::<WorkerMessage>();
    // 작업자 -> 메인 채널
    let (worker_tx, main_rx) = mpsc::channel::<MainMessage>();
    
    // 작업자 스레드
    thread::spawn(move || {
        println!("작업자 스레드 시작");
        
        for message in worker_rx {
            match message {
                WorkerMessage::Work(data) => {
                    worker_tx.send(MainMessage::Status("작업 시작".to_string())).unwrap();
                    
                    // 작업 시뮬레이션
                    thread::sleep(Duration::from_millis(500));
                    let result = format!("처리됨: {}", data.to_uppercase());
                    
                    worker_tx.send(MainMessage::Result(result)).unwrap();
                }
                WorkerMessage::Terminate => {
                    println!("작업자 스레드 종료");
                    break;
                }
            }
        }
    });
    
    // 작업 전송
    let tasks = vec!["hello", "world", "rust", "channel"];
    
    for task in tasks {
        main_tx.send(WorkerMessage::Work(task.to_string())).unwrap();
        
        // 응답 받기
        if let Ok(response) = main_rx.recv() {
            println!("응답: {:?}", response);
        }
        if let Ok(response) = main_rx.recv() {
            println!("응답: {:?}", response);
        }
    }
    
    // 종료 신호
    main_tx.send(WorkerMessage::Terminate).unwrap();
    
    // 남은 메시지들 처리
    while let Ok(msg) = main_rx.try_recv() {
        println!("남은 메시지: {:?}", msg);
    }
}
```

### 채널을 이용한 작업 큐

```rust
use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
struct Task {
    id: u32,
    name: String,
    duration_ms: u64,
}

impl Task {
    fn execute(&self) {
        println!("작업 {} '{}' 시작", self.id, self.name);
        thread::sleep(Duration::from_millis(self.duration_ms));
        println!("작업 {} '{}' 완료", self.id, self.name);
    }
}

fn create_worker(worker_id: usize, receiver: mpsc::Receiver<Task>) {
    thread::spawn(move || {
        println!("작업자 {} 시작됨", worker_id);
        
        while let Ok(task) = receiver.recv() {
            let start = Instant::now();
            task.execute();
            let elapsed = start.elapsed();
            println!("작업자 {}: 작업 {}를 {:.2}초에 완료", 
                     worker_id, task.id, elapsed.as_secs_f64());
        }
        
        println!("작업자 {} 종료됨", worker_id);
    });
}

fn main() {
    let (tx, rx) = mpsc::channel::<Task>();
    
    // 3개의 작업자 스레드 생성
    let num_workers = 3;
    for worker_id in 0..num_workers {
        let rx_clone = rx.clone();
        create_worker(worker_id, rx_clone);
    }
    
    // 원본 수신자 해제
    drop(rx);
    
    // 작업들 생성 및 전송
    let tasks = vec![
        Task { id: 1, name: "파일 처리".to_string(), duration_ms: 1000 },
        Task { id: 2, name: "데이터 분석".to_string(), duration_ms: 1500 },
        Task { id: 3, name: "리포트 생성".to_string(), duration_ms: 800 },
        Task { id: 4, name: "이메일 발송".to_string(), duration_ms: 600 },
        Task { id: 5, name: "백업 생성".to_string(), duration_ms: 2000 },
        Task { id: 6, name: "로그 분석".to_string(), duration_ms: 1200 },
    ];
    
    let start_time = Instant::now();
    
    for task in tasks {
        tx.send(task).unwrap();
    }
    
    // 송신자 해제하여 작업자들에게 종료 신호 전달
    drop(tx);
    
    // 모든 작업자가 종료될 때까지 대기
    thread::sleep(Duration::from_secs(5));
    
    let total_time = start_time.elapsed();
    println!("전체 작업 시간: {:.2}초", total_time.as_secs_f64());
}
```
  
</br>  
  
  
## 9.3 공유 상태와 Mutex

### 기본 Mutex 사용법

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    // Mutex로 보호된 공유 데이터
    let counter = Mutex::new(0);
    
    let mut handles = vec![];
    
    for i in 0..5 {
        let handle = thread::spawn(|| {
            // Mutex 락 획득
            let mut num = counter.lock().unwrap();
            *num += 1;
            println!("스레드 {}: 카운터 = {}", i, *num);
            // 스코프를 벗어나면 자동으로 락 해제
        });
        
        handles.push(handle);
    }
    
    // 모든 스레드 완료 대기
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("최종 결과: {}", *counter.lock().unwrap());
}
```

**주의**: 위 코드는 실제로는 컴파일되지 않는다. 왜냐하면 `counter`를 여러 스레드에서 공유할 수 없기 때문이다. 다음에서 올바른 방법을 보여주겠다.  
   
### Arc와 Mutex 조합

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // Arc로 Mutex를 여러 스레드에서 공유
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for i in 0..10 {
        let counter = Arc::clone(&counter); // 참조 카운트 증가
        
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
            println!("스레드 {} 완료", i);
        });
        
        handles.push(handle);
    }
    
    // 모든 스레드 완료 대기
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("최종 결과: {}", *counter.lock().unwrap());
    // 예상 결과: 1000 (10개 스레드 * 100회 증가)
}
```

### C++와의 Mutex 비교

```cpp
// C++
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>

std::mutex mtx;
int counter = 0;

void increment() {
    for (int i = 0; i < 100; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        ++counter;
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "최종 결과: " << counter << std::endl;
    return 0;
}
```

```rust
// Rust (더 안전함)
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
        });
        
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("최종 결과: {}", *counter.lock().unwrap());
}
```

### 데드락 방지 패턴

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let resource1 = Arc::new(Mutex::new(1));
    let resource2 = Arc::new(Mutex::new(2));
    
    let r1_clone = Arc::clone(&resource1);
    let r2_clone = Arc::clone(&resource2);
    
    // 스레드 1: resource1 -> resource2 순서로 락 획득
    let handle1 = thread::spawn(move || {
        println!("스레드 1: resource1 락 시도");
        let _guard1 = r1_clone.lock().unwrap();
        println!("스레드 1: resource1 락 획득");
        
        thread::sleep(Duration::from_millis(100)); // 데드락 유발을 위한 지연
        
        println!("스레드 1: resource2 락 시도");
        let _guard2 = r2_clone.lock().unwrap();
        println!("스레드 1: resource2 락 획득");
        
        // 작업 수행
        println!("스레드 1: 작업 완료");
    });
    
    let r1_clone = Arc::clone(&resource1);
    let r2_clone = Arc::clone(&resource2);
    
    // 스레드 2: resource2 -> resource1 순서로 락 획득 (데드락 위험!)
    let handle2 = thread::spawn(move || {
        println!("스레드 2: resource2 락 시도");
        let _guard2 = r2_clone.lock().unwrap();
        println!("스레드 2: resource2 락 획득");
        
        thread::sleep(Duration::from_millis(100)); // 데드락 유발을 위한 지연
        
        println!("스레드 2: resource1 락 시도");
        let _guard1 = r1_clone.lock().unwrap();
        println!("스레드 2: resource1 락 획득");
        
        // 작업 수행
        println!("스레드 2: 작업 완료");
    });
    
    // 데드락을 방지하려면 모든 스레드에서 같은 순서로 락을 획득해야 함
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    println!("모든 스레드 완료");
}
```

### 안전한 리소스 공유 패턴

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::HashMap;

// 스레드 안전한 카운터 구조체
struct SafeCounter {
    counts: Arc<Mutex<HashMap<String, i32>>>,
}

impl SafeCounter {
    fn new() -> Self {
        SafeCounter {
            counts: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn increment(&self, key: &str) {
        let mut counts = self.counts.lock().unwrap();
        let counter = counts.entry(key.to_string()).or_insert(0);
        *counter += 1;
    }
    
    fn get(&self, key: &str) -> Option<i32> {
        let counts = self.counts.lock().unwrap();
        counts.get(key).copied()
    }
    
    fn snapshot(&self) -> HashMap<String, i32> {
        let counts = self.counts.lock().unwrap();
        counts.clone()
    }
}

// Clone을 구현하여 쉽게 공유 가능
impl Clone for SafeCounter {
    fn clone(&self) -> Self {
        SafeCounter {
            counts: Arc::clone(&self.counts),
        }
    }
}

fn main() {
    let counter = SafeCounter::new();
    let mut handles = vec![];
    
    // 각 스레드가 다른 키에 대해 카운팅
    for i in 0..5 {
        let counter_clone = counter.clone();
        let key = format!("thread_{}", i);
        
        let handle = thread::spawn(move || {
            for _ in 0..10 {
                counter_clone.increment(&key);
                thread::sleep(std::time::Duration::from_millis(10));
            }
            println!("{} 완료", key);
        });
        
        handles.push(handle);
    }
    
    // 동시에 "global" 키도 증가
    let counter_clone = counter.clone();
    let global_handle = thread::spawn(move || {
        for _ in 0..50 {
            counter_clone.increment("global");
            thread::sleep(std::time::Duration::from_millis(5));
        }
        println!("global 완료");
    });
    
    handles.push(global_handle);
    
    // 모든 스레드 완료 대기
    for handle in handles {
        handle.join().unwrap();
    }
    
    // 결과 출력
    println!("최종 결과:");
    let snapshot = counter.snapshot();
    for (key, count) in snapshot {
        println!("{}: {}", key, count);
    }
}
```
  
</br>    
  

## 9.4 Arc를 이용한 참조 카운팅

### Arc 기본 개념

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    // Arc: Atomically Reference Counted
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data); // 참조 카운트 증가
        
        let handle = thread::spawn(move || {
            println!("스레드 {}: {:?}", i, data_clone);
            println!("스레드 {}: 합계 = {}", i, data_clone.iter().sum::<i32>());
        });
        
        handles.push(handle);
    }
    
    // 메인 스레드에서도 데이터 사용 가능
    println!("메인 스레드: 데이터 길이 = {}", data.len());
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("참조 카운트: {}", Arc::strong_count(&data)); // 1 (메인 스레드만 남음)
}
```

### C++와의 shared_ptr 비교

```cpp
// C++
#include <iostream>
#include <thread>
#include <memory>
#include <vector>

int main() {
    auto data = std::make_shared<std::vector<int>>(std::vector<int>{1, 2, 3, 4, 5});
    
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back([data, i]() {
            std::cout << "스레드 " << i << ": 크기 = " << data->size() << std::endl;
        });
    }
    
    std::cout << "참조 카운트: " << data.use_count() << std::endl;
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "참조 카운트: " << data.use_count() << std::endl;
    return 0;
}
```

```rust
// Rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];
    
    for i in 0..3 {
        let data = Arc::clone(&data);
        
        let handle = thread::spawn(move || {
            println!("스레드 {}: 크기 = {}", i, data.len());
        });
        
        handles.push(handle);
    }
    
    println!("참조 카운트: {}", Arc::strong_count(&data));
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("참조 카운트: {}", Arc::strong_count(&data));
}
```

### Weak 참조와 순환 참조 방지

```rust
use std::sync::{Arc, Weak, Mutex};
use std::thread;

struct Node {
    value: i32,
    parent: Option<Weak<Mutex<Node>>>, // Weak 참조로 순환 참조 방지
    children: Vec<Arc<Mutex<Node>>>,
}

impl Node {
    fn new(value: i32) -> Arc<Mutex<Node>> {
        Arc::new(Mutex::new(Node {
            value,
            parent: None,
            children: Vec::new(),
        }))
    }
    
    fn add_child(parent: &Arc<Mutex<Node>>, child_value: i32) -> Arc<Mutex<Node>> {
        let child = Node::new(child_value);
        
        // 자식에게 부모의 weak 참조 설정
        {
            let mut child_lock = child.lock().unwrap();
            child_lock.parent = Some(Arc::downgrade(parent));
        }
        
        // 부모에게 자식 추가
        {
            let mut parent_lock = parent.lock().unwrap();
            parent_lock.children.push(Arc::clone(&child));
        }
        
        child
    }
}

fn main() {
    let root = Node::new(1);
    
    println!("루트 노드 참조 카운트: {}", Arc::strong_count(&root));
    
    // 자식 노드들 생성
    let child1 = Node::add_child(&root, 2);
    let child2 = Node::add_child(&root, 3);
    
    println!("자식 추가 후 루트 참조 카운트: {}", Arc::strong_count(&root));
    println!("child1 참조 카운트: {}", Arc::strong_count(&child1));
    
    // 다른 스레드에서 트리 탐색
    let root_clone = Arc::clone(&root);
    let handle = thread::spawn(move || {
        let root_lock = root_clone.lock().unwrap();
        println!("스레드에서 루트 값: {}", root_lock.value);
        println!("자식 개수: {}", root_lock.children.len());
        
        for (i, child) in root_lock.children.iter().enumerate() {
            let child_lock = child.lock().unwrap();
            println!("자식 {}: 값 = {}", i, child_lock.value);
            
            // 부모로 역참조 (Weak 참조 사용)
            if let Some(parent_weak) = &child_lock.parent {
                if let Some(parent_strong) = parent_weak.upgrade() {
                    let parent_lock = parent_strong.lock().unwrap();
                    println!("자식 {}의 부모 값: {}", i, parent_lock.value);
                } else {
                    println!("부모가 이미 해제됨");
                }
            }
        }
    });
    
    handle.join().unwrap();
    
    println!("프로그램 종료 전 참조 카운트들:");
    println!("루트: {}", Arc::strong_count(&root));
    println!("child1: {}", Arc::strong_count(&child1));
    println!("child2: {}", Arc::strong_count(&child2));
}
```

### 고급 Arc 패턴

```rust
use std::sync::{Arc, Mutex, RwLock};
use std::thread;
use std::time::Duration;

// 읽기가 많고 쓰기가 적은 경우 RwLock 사용
struct SharedConfig {
    settings: Arc<RwLock<std::collections::HashMap<String, String>>>,
}

impl SharedConfig {
    fn new() -> Self {
        SharedConfig {
            settings: Arc::new(RwLock::new(std::collections::HashMap::new())),
        }
    }
    
    fn set(&self, key: String, value: String) {
        let mut settings = self.settings.write().unwrap();
        settings.insert(key, value);
    }
    
    fn get(&self, key: &str) -> Option<String> {
        let settings = self.settings.read().unwrap();
        settings.get(key).cloned()
    }
    
    fn snapshot(&self) -> std::collections::HashMap<String, String> {
        let settings = self.settings.read().unwrap();
        settings.clone()
    }
}

impl Clone for SharedConfig {
    fn clone(&self) -> Self {
        SharedConfig {
            settings: Arc::clone(&self.settings),
        }
    }
}

fn main() {
    let config = SharedConfig::new();
    
    // 초기 설정
    config.set("host".to_string(), "localhost".to_string());
    config.set("port".to_string(), "8080".to_string());
    config.set("debug".to_string(), "true".to_string());
    
    let mut handles = vec![];
    
    // 여러 읽기 스레드 (동시 읽기 가능)
    for i in 0..5 {
        let config_clone = config.clone();
        
        let handle = thread::spawn(move || {
            for _ in 0..10 {
                if let Some(host) = config_clone.get("host") {
                    println!("읽기 스레드 {}: host = {}", i, host);
                }
                thread::sleep(Duration::from_millis(50));
            }
        });
        
        handles.push(handle);
    }
    
    // 가끔 설정을 변경하는 스레드
    let config_clone = config.clone();
    let update_handle = thread::spawn(move || {
        for i in 0..3 {
            thread::sleep(Duration::from_millis(200));
            config_clone.set("timestamp".to_string(), format!("update_{}", i));
            println!("설정 업데이트: update_{}", i);
        }
    });
    
    handles.push(update_handle);
    
    // 모든 스레드 완료 대기
    for handle in handles {
        handle.join().unwrap();
    }
    
    // 최종 설정 출력
    println!("최종 설정:");
    let final_settings = config.snapshot();
    for (key, value) in final_settings {
        println!("  {}: {}", key, value);
    }
}
```
  
</br>    
  


## 실습: 멀티스레드 웹 크롤러
이제 배운 내용을 종합해서 멀티스레드 웹 크롤러를 만들어보자:

```rust
use std::sync::{Arc, Mutex, mpsc};
use std::thread;
use std::time::{Duration, Instant};
use std::collections::{HashSet, VecDeque};
use std::io::Read;

// 의존성을 위해 Cargo.toml에 추가 필요:
// [dependencies]
// reqwest = { version = "0.11", features = ["blocking"] }
// scraper = "0.15"
// url = "2.3"

// 실제 HTTP 요청 없이 시뮬레이션하는 버전

#[derive(Debug, Clone)]
struct CrawlResult {
    url: String,
    status: CrawlStatus,
    links_found: Vec<String>,
    content_length: usize,
    crawl_time: Duration,
}

#[derive(Debug, Clone)]
enum CrawlStatus {
    Success,
    NotFound,
    Timeout,
    NetworkError,
}

#[derive(Debug, Clone)]
struct CrawlTask {
    url: String,
    depth: u32,
}

struct WebCrawler {
    max_workers: usize,
    max_depth: u32,
    crawled_urls: Arc<Mutex<HashSet<String>>>,
    pending_tasks: Arc<Mutex<VecDeque<CrawlTask>>>,
    results: Arc<Mutex<Vec<CrawlResult>>>,
}

impl WebCrawler {
    fn new(max_workers: usize, max_depth: u32) -> Self {
        WebCrawler {
            max_workers,
            max_depth,
            crawled_urls: Arc::new(Mutex::new(HashSet::new())),
            pending_tasks: Arc::new(Mutex::new(VecDeque::new())),
            results: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    fn add_seed_url(&self, url: String) {
        let mut tasks = self.pending_tasks.lock().unwrap();
        tasks.push_back(CrawlTask { url, depth: 0 });
    }
    
    fn simulate_http_request(&self, url: &str) -> CrawlResult {
        let start = Instant::now();
        
        // HTTP 요청 시뮬레이션
        thread::sleep(Duration::from_millis(
            rand::random::<u64>() % 1000 + 200
        )); // 200-1200ms 랜덤 지연
        
        let status = match rand::random::<u32>() % 10 {
            0 => CrawlStatus::NotFound,      // 10% 확률로 404
            1 => CrawlStatus::NetworkError,  // 10% 확률로 네트워크 에러
            9 => CrawlStatus::Timeout,       // 10% 확률로 타임아웃
            _ => CrawlStatus::Success,       // 70% 확률로 성공
        };
        
        let links_found = if matches!(status, CrawlStatus::Success) {
            // 성공한 경우 랜덤한 링크들 생성
            let num_links = rand::random::<usize>() % 5 + 1;
            (0..num_links)
                .map(|i| format!("{}/page{}", url, i + 1))
                .collect()
        } else {
            vec![]
        };
        
        let content_length = rand::random::<usize>() % 10000 + 1000;
        
        CrawlResult {
            url: url.to_string(),
            status,
            links_found,
            content_length,
            crawl_time: start.elapsed(),
        }
    }
    
    fn worker_thread(&self, worker_id: usize) {
        println!("크롤러 작업자 {} 시작", worker_id);
        
        loop {
            // 작업 큐에서 작업 가져오기
            let task = {
                let mut tasks = self.pending_tasks.lock().unwrap();
                tasks.pop_front()
            };
            
            let task = match task {
                Some(task) => task,
                None => {
                    // 작업이 없으면 잠시 대기
                    thread::sleep(Duration::from_millis(100));
                    continue;
                }
            };
            
            // URL이 이미 크롤링되었는지 확인
            {
                let mut crawled = self.crawled_urls.lock().unwrap();
                if crawled.contains(&task.url) {
                    continue; // 이미 크롤링된 URL
                }
                crawled.insert(task.url.clone());
            }
            
            println!("작업자 {}: 크롤링 중 {} (깊이: {})", 
                     worker_id, task.url, task.depth);
            
            // HTTP 요청 수행
            let result = self.simulate_http_request(&task.url);
            
            println!("작업자 {}: {} - {:?} ({}ms)", 
                     worker_id, task.url, result.status, 
                     result.crawl_time.as_millis());
            
            // 성공한 경우 새로운 링크들을 작업 큐에 추가
            if matches!(result.status, CrawlStatus::Success) && task.depth < self.max_depth {
                let mut tasks = self.pending_tasks.lock().unwrap();
                for link in &result.links_found {
                    tasks.push_back(CrawlTask {
                        url: link.clone(),
                        depth: task.depth + 1,
                    });
                }
            }
            
            // 결과 저장
            {
                let mut results = self.results.lock().unwrap();
                results.push(result);
            }
        }
    }
    
    fn crawl(&self, duration_seconds: u64) {
        let start_time = Instant::now();
        println!("웹 크롤링 시작 ({}초간 실행)", duration_seconds);
        
        // 작업자 스레드들 시작
        let mut handles = vec![];
        for worker_id in 0..self.max_workers {
            let crawler = self.clone();
            
            let handle = thread::spawn(move || {
                crawler.worker_thread(worker_id);
            });
            
            handles.push(handle);
        }
        
        // 지정된 시간동안 실행
        thread::sleep(Duration::from_secs(duration_seconds));
        
        println!("크롤링 종료 신호 전송 중...");
        
        // 실제 구현에서는 여기서 작업자들에게 종료 신호를 보내야 함
        // 간단한 시뮬레이션을 위해 프로그램 종료
        
        let total_time = start_time.elapsed();
        self.print_statistics(total_time);
    }
    
    fn print_statistics(&self, total_time: Duration) {
        let results = self.results.lock().unwrap();
        let crawled_count = self.crawled_urls.lock().unwrap().len();
        let pending_count = self.pending_tasks.lock().unwrap().len();
        
        println!("\n=== 크롤링 통계 ===");
        println!("총 실행 시간: {:.2}초", total_time.as_secs_f64());
        println!("크롤링된 URL 수: {}", crawled_count);
        println!("대기 중인 URL 수: {}", pending_count);
        println!("총 결과 수: {}", results.len());
        
        let mut success_count = 0;
        let mut error_counts = std::collections::HashMap::new();
        let mut total_content_size = 0;
        let mut total_response_time = Duration::new(0, 0);
        
        for result in results.iter() {
            match result.status {
                CrawlStatus::Success => {
                    success_count += 1;
                    total_content_size += result.content_length;
                }
                ref status => {
                    let status_str = format!("{:?}", status);
                    *error_counts.entry(status_str).or_insert(0) += 1;
                }
            }
            total_response_time += result.crawl_time;
        }
        
        println!("성공: {} ({:.1}%)", success_count, 
                 success_count as f64 / results.len() as f64 * 100.0);
        
        for (status, count) in error_counts {
            println!("{}: {} ({:.1}%)", status, count,
                     count as f64 / results.len() as f64 * 100.0);
        }
        
        if success_count > 0 {
            println!("평균 콘텐츠 크기: {:.1} KB", 
                     total_content_size as f64 / success_count as f64 / 1024.0);
        }
        
        if !results.is_empty() {
            println!("평균 응답 시간: {:.1}ms", 
                     total_response_time.as_millis() as f64 / results.len() as f64);
        }
        
        println!("처리량: {:.2} URL/초", 
                 results.len() as f64 / total_time.as_secs_f64());
    }
}

// WebCrawler에 Clone 구현 (Arc들을 복제)
impl Clone for WebCrawler {
    fn clone(&self) -> Self {
        WebCrawler {
            max_workers: self.max_workers,
            max_depth: self.max_depth,
            crawled_urls: Arc::clone(&self.crawled_urls),
            pending_tasks: Arc::clone(&self.pending_tasks),
            results: Arc::clone(&self.results),
        }
    }
}

// 간단한 난수 생성기 (실제로는 rand 크레이트 사용 권장)
mod rand {
    use std::sync::atomic::{AtomicU64, Ordering};
    
    static SEED: AtomicU64 = AtomicU64::new(12345);
    
    pub fn random<T>() -> T 
    where 
        T: From<u64>,
    {
        let current = SEED.load(Ordering::Relaxed);
        let next = current.wrapping_mul(1103515245).wrapping_add(12345);
        SEED.store(next, Ordering::Relaxed);
        T::from(next)
    }
}

fn main() {
    println!("=== 멀티스레드 웹 크롤러 ===");
    
    // 크롤러 생성 (4개 작업자, 최대 깊이 2)
    let crawler = WebCrawler::new(4, 2);
    
    // 시드 URL들 추가
    let seed_urls = vec![
        "https://example.com".to_string(),
        "https://test.org".to_string(),
        "https://demo.net".to_string(),
    ];
    
    for url in seed_urls {
        crawler.add_seed_url(url);
    }
    
    // 10초간 크롤링 실행
    crawler.crawl(10);
}

// 추가: 실제 HTTP 요청을 사용하는 버전 (reqwest 크레이트 필요)
#[cfg(feature = "real_http")]
mod real_crawler {
    use super::*;
    
    impl WebCrawler {
        fn real_http_request(&self, url: &str) -> CrawlResult {
            let start = Instant::now();
            
            // 실제 HTTP 클라이언트 사용
            let client = reqwest::blocking::Client::builder()
                .timeout(Duration::from_secs(5))
                .build()
                .unwrap();
            
            let result = match client.get(url).send() {
                Ok(response) => {
                    let status_code = response.status();
                    let content_length = response.content_length().unwrap_or(0) as usize;
                    
                    let status = if status_code.is_success() {
                        CrawlStatus::Success
                    } else if status_code.as_u16() == 404 {
                        CrawlStatus::NotFound
                    } else {
                        CrawlStatus::NetworkError
                    };
                    
                    // 실제로는 HTML을 파싱하여 링크 추출
                    let links_found = vec![]; // 간단화를 위해 빈 벡터
                    
                    CrawlResult {
                        url: url.to_string(),
                        status,
                        links_found,
                        content_length,
                        crawl_time: start.elapsed(),
                    }
                }
                Err(_) => {
                    CrawlResult {
                        url: url.to_string(),
                        status: CrawlStatus::NetworkError,
                        links_found: vec![],
                        content_length: 0,
                        crawl_time: start.elapsed(),
                    }
                }
            };
            
            result
        }
    }
}

// 프로그램 실행 방법:
// cargo new web_crawler
// cd web_crawler
// # 위 코드를 src/main.rs에 복사
// cargo run
```

### 실행 예시

```
=== 멀티스레드 웹 크롤러 ===
웹 크롤링 시작 (10초간 실행)
크롤러 작업자 0 시작
크롤러 작업자 1 시작
크롤러 작업자 2 시작
크롤러 작업자 3 시작
작업자 0: 크롤링 중 https://example.com (깊이: 0)
작업자 1: 크롤링 중 https://test.org (깊이: 0)
작업자 2: 크롤링 중 https://demo.net (깊이: 0)
작업자 0: https://example.com - Success (756ms)
작업자 1: https://test.org - Success (892ms)
작업자 2: https://demo.net - NetworkError (445ms)
작업자 3: 크롤링 중 https://example.com/page1 (깊이: 1)
작업자 0: 크롤링 중 https://example.com/page2 (깊이: 1)
...

크롤링 종료 신호 전송 중...

=== 크롤링 통계 ===
총 실행 시간: 10.12초
크롤링된 URL 수: 23
대기 중인 URL 수: 7
총 결과 수: 23
성공: 16 (69.6%)
NetworkError: 3 (13.0%)
NotFound: 2 (8.7%)
Timeout: 2 (8.7%)
평균 콘텐츠 크기: 5.7 KB
평균 응답 시간: 623.4ms
처리량: 2.27 URL/초
```

### 프로그램에서 사용된 동시성 개념들
1. **스레드 생성**: 여러 크롤러 작업자를 병렬로 실행
2. **Arc + Mutex**: 공유 상태 (크롤링된 URL, 작업 큐, 결과) 안전하게 관리
3. **메시지 패싱 패턴**: 작업 큐를 통한 작업 배분
4. **동기화**: Mutex를 통한 데이터 레이스 방지
5. **참조 카운팅**: Arc를 통해 크롤러 인스턴스를 여러 스레드에서 공유

---

**이번 장 요약:**

1. **스레드 관리**: `std::thread`로 안전한 스레드 생성과 관리
2. **메시지 패싱**: 채널을 통한 스레드 간 통신으로 데이터 레이스 방지
3. **공유 상태**: Mutex를 통한 안전한 메모리 공유
4. **참조 카운팅**: Arc로 여러 스레드에서 데이터 공유
5. **타입 안전성**: 컴파일 타임에 동시성 문제 방지

Rust의 동시성 모델은 "두려움 없는 동시성(Fearless Concurrency)"을 제공해. C++에서 런타임에 발생하는 데이터 레이스, 댕글링 포인터 등의 문제를 컴파일 타임에 방지하면서도, 성능 손실 없는 제로 비용 추상화를 제공해. 특히 게임 서버처럼 고성능과 안전성이 모두 중요한 분야에서는 이런 특성이 큰 장점이 될 것이야.  