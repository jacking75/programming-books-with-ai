# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
  
# 5장. 벡터와 문자열
C++ 개발자라면 `std::vector`, `std::string`, `std::map` 같은 STL 컨테이너에 익숙할 것이다. Rust도 비슷한 컬렉션 타입들을 제공하지만, 소유권 시스템과 결합되어 더 안전하게 동작한다. 이 장에서는 Rust의 주요 컬렉션 타입들과 반복자 사용법을 배워보자.
    
  
## 5.1 Vec<T> 사용법

### 기본 벡터 생성과 사용

```rust
fn main() {
    // 빈 벡터 생성
    let mut v1: Vec<i32> = Vec::new();
    
    // vec! 매크로로 초기값과 함께 생성
    let mut v2 = vec![1, 2, 3, 4, 5];
    
    // 요소 추가
    v1.push(10);
    v1.push(20);
    v1.push(30);
    
    println!("v1: {:?}", v1);  // [10, 20, 30]
    println!("v2: {:?}", v2);  // [1, 2, 3, 4, 5]
    
    // 벡터 길이
    println!("v1 길이: {}", v1.len());
    println!("v2가 비어있는가? {}", v2.is_empty());
}
```

### C++와의 비교

```cpp
// C++
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v1;              // 빈 벡터
    std::vector<int> v2{1, 2, 3, 4, 5}; // 초기화 리스트
    
    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(30);
    
    std::cout << "크기: " << v1.size() << std::endl;
    std::cout << "비어있음: " << v1.empty() << std::endl;
}
```

```rust
// Rust
fn main() {
    let mut v1: Vec<i32> = Vec::new();
    let mut v2 = vec![1, 2, 3, 4, 5];
    
    v1.push(10);
    v1.push(20);
    v1.push(30);
    
    println!("크기: {}", v1.len());
    println!("비어있음: {}", v1.is_empty());
}
```

### 벡터 요소 접근

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    
    // 인덱스로 접근 (패닉 가능)
    let third = v[2];
    println!("세 번째 요소: {}", third);
    
    // get 메서드 사용 (안전한 접근)
    match v.get(2) {
        Some(third) => println!("세 번째 요소: {}", third),
        None => println!("세 번째 요소가 없습니다."),
    }
    
    // 범위를 벗어난 접근
    // let does_not_exist = v[100];  // 패닉 발생!
    
    match v.get(100) {
        Some(value) => println!("값: {}", value),
        None => println!("인덱스 100에는 요소가 없습니다."),
    }
    
    // 첫 번째와 마지막 요소
    if let Some(first) = v.first() {
        println!("첫 번째: {}", first);
    }
    
    if let Some(last) = v.last() {
        println!("마지막: {}", last);
    }
}
```

### 벡터 수정

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    
    // 요소 추가
    v.push(6);
    println!("요소 추가 후: {:?}", v);
    
    // 마지막 요소 제거
    if let Some(last) = v.pop() {
        println!("제거된 요소: {}", last);
    }
    println!("요소 제거 후: {:?}", v);
    
    // 특정 위치에 요소 삽입
    v.insert(2, 100);  // 인덱스 2에 100 삽입
    println!("요소 삽입 후: {:?}", v);
    
    // 특정 위치의 요소 제거
    let removed = v.remove(2);
    println!("제거된 요소: {}", removed);
    println!("요소 제거 후: {:?}", v);
    
    // 벡터 비우기
    v.clear();
    println!("비운 후 길이: {}", v.len());
}
```

### 벡터와 소유권

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    
    // 불변 참조
    let first = &v[0];
    println!("첫 번째: {}", first);
    
    // 가변 참조와 불변 참조를 동시에 가질 수 없음
    // v.push(6);  // 컴파일 에러! first가 아직 유효함
    
    // first 사용이 끝난 후에는 가능
    v.push(6);
    println!("요소 추가 후: {:?}", v);
    
    // 소유권 이전
    let v2 = v;  // v의 소유권이 v2로 이전
    // println!("{:?}", v);  // 컴파일 에러!
    println!("v2: {:?}", v2);
}
```

### 벡터 반복

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    
    // 불변 참조로 반복
    println!("불변 반복:");
    for item in &v {
        println!("{}", item);
    }
    
    // 가변 참조로 반복 (수정 가능)
    let mut v_mut = vec![1, 2, 3, 4, 5];
    println!("가변 반복 (각 요소에 10 더하기):");
    for item in &mut v_mut {
        *item += 10;
        println!("{}", item);
    }
    
    // 소유권을 가져오며 반복
    println!("소유권 이전 반복:");
    for item in v {  // v의 소유권이 이전됨
        println!("{}", item);
    }
    // println!("{:?}", v);  // 컴파일 에러! v는 더 이상 사용할 수 없음
}
```

### 다양한 타입의 벡터

```rust
#[derive(Debug)]
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

fn main() {
    // 같은 타입만 저장 가능
    let numbers = vec![1, 2, 3, 4, 5];
    let strings = vec!["hello", "world", "rust"];
    
    // 다양한 타입을 저장하려면 enum 사용
    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Float(10.12),
        SpreadsheetCell::Text(String::from("blue")),
    ];
    
    println!("숫자들: {:?}", numbers);
    println!("문자열들: {:?}", strings);
    println!("스프레드시트 행: {:?}", row);
    
    // enum 벡터 처리
    for cell in &row {
        match cell {
            SpreadsheetCell::Int(i) => println!("정수: {}", i),
            SpreadsheetCell::Float(f) => println!("부동소수점: {}", f),
            SpreadsheetCell::Text(s) => println!("텍스트: {}", s),
        }
    }
}
```
  
</br>    
  

## 5.2 String vs &str

### 문자열 타입 이해하기

```rust
fn main() {
    // 문자열 리터럴 (&str) - 불변이고 컴파일 타임에 알려진 크기
    let s1 = "hello";  // &str 타입
    
    // String 타입 - 가변이고 힙에 할당됨
    let mut s2 = String::new();
    let s3 = String::from("hello");
    let s4 = "hello".to_string();
    
    // 문자열에 내용 추가
    s2.push_str("world");
    s2.push('!');
    
    println!("s1: {}", s1);  // hello
    println!("s2: {}", s2);  // world!
    println!("s3: {}", s3);  // hello
    println!("s4: {}", s4);  // hello
}
```

### C++와의 문자열 비교

```cpp
// C++
#include <string>
#include <iostream>

int main() {
    const char* s1 = "hello";           // C 스타일 문자열
    std::string s2 = "hello";           // C++ std::string
    std::string s3("hello");            // 생성자 사용
    
    s2 += " world";                     // 문자열 추가
    
    std::cout << s1 << std::endl;
    std::cout << s2 << std::endl;
}
```

```rust
// Rust
fn main() {
    let s1: &str = "hello";             // 문자열 슬라이스
    let mut s2 = String::from("hello");  // 소유된 문자열
    let s3 = "hello".to_string();       // 변환
    
    s2.push_str(" world");              // 문자열 추가
    
    println!("{}", s1);
    println!("{}", s2);
}
```

### 문자열 조작

```rust
fn main() {
    let mut s = String::from("Hello");
    
    // 문자열 추가
    s.push_str(", World");
    s.push('!');
    println!("추가 후: {}", s);
    
    // 문자열 연결
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2;  // s1의 소유권이 이전됨
    // println!("{}", s1);  // 컴파일 에러!
    println!("연결 결과: {}", s3);
    
    // format! 매크로 사용 (소유권 이전 없음)
    let s4 = String::from("Hello");
    let s5 = String::from("World");
    let s6 = format!("{}, {}!", s4, s5);
    println!("format 결과: {}", s6);
    println!("s4는 여전히 유효: {}", s4);
    println!("s5도 여전히 유효: {}", s5);
}
```

### 문자열 슬라이싱

```rust
fn main() {
    let s = String::from("안녕하세요 Rust 세계!");
    
    // 바이트 인덱스로 슬라이싱 (주의: 한글은 3바이트)
    let hello = &s[0..15];  // "안녕하세요"
    let rust = &s[16..20];  // "Rust"
    
    println!("hello: {}", hello);
    println!("rust: {}", rust);
    
    // 안전한 슬라이싱
    if let Some(first_word) = get_first_word(&s) {
        println!("첫 번째 단어: {}", first_word);
    }
}

fn get_first_word(s: &str) -> Option<&str> {
    for (i, &item) in s.as_bytes().iter().enumerate() {
        if item == b' ' {
            return Some(&s[0..i]);
        }
    }
    None
}
```

### 문자열 순회

```rust
fn main() {
    let s = "नमस्ते Rust";
    
    // 문자 단위로 순회
    println!("문자 단위:");
    for c in s.chars() {
        println!("{}", c);
    }
    
    // 바이트 단위로 순회
    println!("\n바이트 단위:");
    for b in s.bytes() {
        println!("{}", b);
    }
    
    // 문자 개수와 바이트 개수
    println!("\n문자 개수: {}", s.chars().count());
    println!("바이트 개수: {}", s.len());
}
```

### 문자열 변환과 파싱

```rust
fn main() {
    // &str을 String으로
    let s1: &str = "hello";
    let s2: String = s1.to_string();
    let s3: String = String::from(s1);
    
    // String을 &str로
    let s4: String = String::from("world");
    let s5: &str = &s4;
    let s6: &str = s4.as_str();
    
    // 숫자를 문자열로
    let num = 42;
    let num_str = num.to_string();
    println!("숫자를 문자열로: {}", num_str);
    
    // 문자열을 숫자로 파싱
    let parsed: i32 = "42".parse().expect("숫자가 아닙니다!");
    println!("파싱된 숫자: {}", parsed);
    
    // 안전한 파싱
    match "abc".parse::<i32>() {
        Ok(num) => println!("파싱 성공: {}", num),
        Err(e) => println!("파싱 실패: {}", e),
    }
}
```
   
</br>  
  
     
## 5.3 해시맵(HashMap) 기초

### HashMap 생성과 사용

```rust
use std::collections::HashMap;

fn main() {
    // 빈 HashMap 생성
    let mut scores = HashMap::new();
    
    // 값 삽입
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
    
    println!("점수판: {:?}", scores);
    
    // 초기값과 함께 생성하는 방법들
    let teams = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 50];
    
    // collect를 사용한 생성
    let scores2: HashMap<_, _> = teams
        .into_iter()
        .zip(initial_scores.into_iter())
        .collect();
    
    println!("scores2: {:?}", scores2);
}
```

### HashMap 값 접근

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
    
    // get 메서드로 안전한 접근
    let team_name = String::from("Blue");
    match scores.get(&team_name) {
        Some(score) => println!("{} 팀의 점수: {}", team_name, score),
        None => println!("{} 팀을 찾을 수 없습니다.", team_name),
    }
    
    // 존재하지 않는 키
    match scores.get("Green") {
        Some(score) => println!("Green 팀의 점수: {}", score),
        None => println!("Green 팀을 찾을 수 없습니다."),
    }
    
    // 기본값과 함께 접근
    let green_score = scores.get("Green").unwrap_or(&0);
    println!("Green 팀의 점수 (기본값 사용): {}", green_score);
}
```

### HashMap 반복과 수정

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
    scores.insert(String::from("Red"), 25);
    
    // 키-값 쌍으로 반복
    println!("모든 점수:");
    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }
    
    // 값 덮어쓰기
    scores.insert(String::from("Blue"), 25);
    println!("\nBlue 팀 점수 업데이트 후:");
    println!("Blue: {:?}", scores.get("Blue"));
    
    // 키가 없을 때만 삽입
    scores.entry(String::from("Green")).or_insert(30);
    scores.entry(String::from("Blue")).or_insert(100); // Blue는 이미 있으므로 변경 안됨
    
    println!("\nentry 사용 후:");
    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }
    
    // 기존 값을 기반으로 업데이트
    let text = "hello world wonderful world";
    let mut word_count = HashMap::new();
    
    for word in text.split_whitespace() {
        let count = word_count.entry(word).or_insert(0);
        *count += 1;
    }
    
    println!("\n단어 개수:");
    for (word, count) in &word_count {
        println!("{}: {}", word, count);
    }
}
```

### HashMap과 소유권

```rust
use std::collections::HashMap;

fn main() {
    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");
    
    let mut map = HashMap::new();
    
    // 소유권이 HashMap으로 이전됨
    map.insert(field_name, field_value);
    
    // 이제 field_name과 field_value는 사용할 수 없음
    // println!("{}", field_name);  // 컴파일 에러!
    
    // 참조를 사용하면 소유권 이전 없음
    let key = String::from("name");
    let value = String::from("Alice");
    
    let mut map2 = HashMap::new();
    map2.insert(&key, &value);  // 참조 저장
    
    println!("key는 여전히 사용 가능: {}", key);
    println!("value도 여전히 사용 가능: {}", value);
}
```

### C++와의 HashMap 비교

```cpp
// C++
#include <unordered_map>
#include <iostream>
#include <string>

int main() {
    std::unordered_map<std::string, int> scores;
    scores["Blue"] = 10;
    scores["Yellow"] = 50;
    
    // 접근
    std::cout << "Blue: " << scores["Blue"] << std::endl;
    
    // 안전한 접근 (find 사용)
    auto it = scores.find("Green");
    if (it != scores.end()) {
        std::cout << "Green: " << it->second << std::endl;
    } else {
        std::cout << "Green 팀을 찾을 수 없습니다." << std::endl;
    }
}
```

```rust
// Rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    scores.insert("Blue", 10);
    scores.insert("Yellow", 50);
    
    // 안전한 접근만 제공
    match scores.get("Blue") {
        Some(score) => println!("Blue: {}", score),
        None => println!("Blue 팀을 찾을 수 없습니다."),
    }
    
    match scores.get("Green") {
        Some(score) => println!("Green: {}", score),
        None => println!("Green 팀을 찾을 수 없습니다."),
    }
}
```
  
</br>  
  
  
## 5.4 반복자(Iterator) 기본 사용법

### 반복자 생성

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    
    // iter() - 불변 참조 반복자
    println!("iter():");
    for item in v.iter() {
        println!("{}", item);  // item은 &i32 타입
    }
    
    // into_iter() - 소유권을 가져오는 반복자
    let v2 = vec![1, 2, 3];
    println!("into_iter():");
    for item in v2.into_iter() {
        println!("{}", item);  // item은 i32 타입
    }
    // v2는 더 이상 사용할 수 없음
    
    // iter_mut() - 가변 참조 반복자
    let mut v3 = vec![1, 2, 3];
    println!("iter_mut() (각 요소에 10 더하기):");
    for item in v3.iter_mut() {
        *item += 10;
        println!("{}", item);  // item은 &mut i32 타입
    }
    println!("v3 수정 후: {:?}", v3);
}
```

### 반복자 어댑터

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5, 6];
    
    // map - 각 요소를 변환
    let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect();
    println!("doubled: {:?}", doubled);
    
    // filter - 조건에 맞는 요소만 필터링
    let even: Vec<&i32> = v.iter().filter(|&x| x % 2 == 0).collect();
    println!("even numbers: {:?}", even);
    
    // map과 filter 체이닝
    let even_doubled: Vec<i32> = v
        .iter()
        .filter(|&x| x % 2 == 0)
        .map(|x| x * 2)
        .collect();
    println!("even numbers doubled: {:?}", even_doubled);
    
    // enumerate - 인덱스와 함께
    println!("enumerate:");
    for (index, value) in v.iter().enumerate() {
        println!("인덱스 {}: 값 {}", index, value);
    }
}
```

### 반복자 소비 어댑터

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    
    // collect - 다른 컬렉션으로 변환
    let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect();
    println!("doubled: {:?}", doubled);
    
    // reduce (fold) - 단일 값으로 축약
    let sum = v.iter().fold(0, |acc, x| acc + x);
    println!("합계: {}", sum);
    
    // find - 조건에 맞는 첫 번째 요소 찾기
    let found = v.iter().find(|&&x| x > 3);
    match found {
        Some(value) => println!("3보다 큰 첫 번째 값: {}", value),
        None => println!("3보다 큰 값을 찾을 수 없습니다."),
    }
    
    // any - 조건에 맞는 요소가 하나라도 있는지
    let has_even = v.iter().any(|&x| x % 2 == 0);
    println!("짝수가 있는가? {}", has_even);
    
    // all - 모든 요소가 조건에 맞는지
    let all_positive = v.iter().all(|&x| x > 0);
    println!("모든 값이 양수인가? {}", all_positive);
    
    // count - 조건에 맞는 요소 개수
    let even_count = v.iter().filter(|&x| x % 2 == 0).count();
    println!("짝수 개수: {}", even_count);
}
```

### 문자열과 반복자

```rust
fn main() {
    let text = "hello world rust programming";
    
    // 단어별로 분리하여 처리
    let word_lengths: Vec<usize> = text
        .split_whitespace()
        .map(|word| word.len())
        .collect();
    println!("단어 길이들: {:?}", word_lengths);
    
    // 긴 단어만 필터링
    let long_words: Vec<&str> = text
        .split_whitespace()
        .filter(|word| word.len() > 4)
        .collect();
    println!("5글자 이상 단어들: {:?}", long_words);
    
    // 문자 단위 처리
    let vowel_count = text
        .chars()
        .filter(|c| "aeiou".contains(*c))
        .count();
    println!("모음 개수: {}", vowel_count);
}
```

### 커스텀 반복자

```rust
struct Counter {
    current: usize,
    max: usize,
}

impl Counter {
    fn new(max: usize) -> Counter {
        Counter { current: 0, max }
    }
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.max {
            let current = self.current;
            self.current += 1;
            Some(current)
        } else {
            None
        }
    }
}

fn main() {
    let counter = Counter::new(5);
    
    println!("커스텀 반복자:");
    for num in counter {
        println!("{}", num);
    }
    
    // 반복자 어댑터와 함께 사용
    let sum: usize = Counter::new(5)
        .map(|x| x * x)  // 제곱
        .filter(|x| x % 2 == 0)  // 짝수만
        .sum();
    
    println!("0-4의 제곱 중 짝수의 합: {}", sum);
}
```
  
이 코드는 러스트(Rust)에서 직접 **사용자 정의 반복자(Custom Iterator)**를 만드는 방법을 보여준다.

#### `Counter` 구조체와 생성자

```rust
struct Counter {
    current: usize,
    max: usize,
}

impl Counter {
    fn new(max: usize) -> Counter {
        Counter { current: 0, max }
    }
}
```

  - `Counter`는 현재 숫자(`current`)와 최대 숫자(`max`)를 필드로 가지는 구조체다.
  - `impl Counter` 블록은 `Counter` 구조체와 관련된 함수를 정의한다.
  - `new` 함수는 `Counter`의 인스턴스를 생성하는 생성자 역할을 한다.

#### `Iterator` 트레이트 구현

```rust
impl Iterator for Counter {
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.max {
            let current = self.current;
            self.current += 1;
            Some(current)
        } else {
            None
        }
    }
}
```

  - 이 코드는 `Counter` 구조체에 `Iterator` 트레이트(trait)를 구현하여 반복자로 동작하게 만든다.
  - `type Item = usize;`는 이 반복자가 반환할 아이템의 타입이 `usize`임을 지정한다.
  - `next` 메서드는 반복자의 핵심 로직을 담고 있다.
  - 현재 숫자가 최대값보다 작으면, 현재 숫자를 `Some`으로 감싸 반환하고 내부 숫자를 1 증가시킨다.
  - 현재 숫자가 최대값에 도달하면, 반복이 끝났음을 알리는 `None`을 반환한다.
  
#### 반복자 사용법

```rust
fn main() {
    let counter = Counter::new(5);

    for num in counter {
        println!("{}", num);
    }

    let sum: usize = Counter::new(5)
        .map(|x| x * x)
        .filter(|x| x % 2 == 0)
        .sum();

    println!("0-4의 제곱 중 짝수의 합: {}", sum);
}
```

  - `Counter`가 `Iterator`를 구현했기 때문에 `for` 루프에서 직접 사용할 수 있다.
  - `for` 루프는 내부적으로 `next` 메서드를 반복 호출하고 `None`이 반환되면 중단된다.
  - 또한, `map`, `filter`, `sum`과 같은 표준 라이브러리의 강력한 \*\*반복자 어댑터(iterator adapter)\*\*들을 자유롭게 연결하여 사용할 수 있다.
  - 두 번째 예시는 0부터 4까지의 숫자를 각각 제곱하고(`map`), 그중 짝수만 걸러내어(`filter`), 최종 합계(`sum`)를 구하는 과정을 보여준다.
  
</br>   
  

## 실습: 단어 카운터 프로그램
이제 배운 내용을 종합해서 단어 카운터 프로그램을 만들어보자:

```rust
use std::collections::HashMap;
use std::io;

fn main() {
    println!("=== 단어 카운터 프로그램 ===");
    
    loop {
        println!("\n1. 텍스트 입력하여 단어 카운트");
        println!("2. 파일에서 단어 카운트 (시뮬레이션)");
        println!("3. 단어 통계 분석");
        println!("4. 종료");
        
        let choice = get_input("선택하세요: ");
        
        match choice.trim() {
            "1" => count_words_from_input(),
            "2" => count_words_from_sample(),
            "3" => analyze_text_statistics(),
            "4" => {
                println!("프로그램을 종료합니다.");
                break;
            }
            _ => println!("잘못된 선택입니다."),
        }
    }
}

fn get_input(prompt: &str) -> String {
    println!("{}", prompt);
    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("입력 실패");
    input
}

fn count_words_from_input() {
    let text = get_input("텍스트를 입력하세요: ");
    let word_count = count_words(&text);
    
    print_word_count(&word_count);
    print_statistics(&word_count, &text);
}

fn count_words_from_sample() {
    let sample_text = "
        Rust is a systems programming language that runs blazingly fast,
        prevents segfaults, and guarantees thread safety. Rust achieves memory safety
        without garbage collection, making it a perfect choice for systems programming.
        The Rust programming language helps developers write faster, more reliable software.
    ";
    
    println!("샘플 텍스트:");
    println!("{}", sample_text.trim());
    println!("\n단어 카운트 결과:");
    
    let word_count = count_words(sample_text);
    print_word_count(&word_count);
    print_statistics(&word_count, sample_text);
}

fn analyze_text_statistics() {
    let text = get_input("분석할 텍스트를 입력하세요: ");
    
    println!("\n=== 텍스트 통계 분석 ===");
    
    // 기본 통계
    let char_count = text.chars().count();
    let word_count = text.split_whitespace().count();
    let line_count = text.lines().count();
    let byte_count = text.len();
    
    println!("문자 수: {}", char_count);
    println!("단어 수: {}", word_count);
    println!("줄 수: {}", line_count);
    println!("바이트 수: {}", byte_count);
    
    // 단어 길이 분석
    let word_lengths: Vec<usize> = text
        .split_whitespace()
        .map(|word| clean_word(word).len())
        .filter(|&len| len > 0)
        .collect();
    
    if !word_lengths.is_empty() {
        let avg_word_length: f64 = word_lengths.iter().sum::<usize>() as f64 
                                  / word_lengths.len() as f64;
        let max_word_length = word_lengths.iter().max().unwrap_or(&0);
        let min_word_length = word_lengths.iter().min().unwrap_or(&0);
        
        println!("평균 단어 길이: {:.2}", avg_word_length);
        println!("최대 단어 길이: {}", max_word_length);
        println!("최소 단어 길이: {}", min_word_length);
    }
    
    // 가장 긴 단어들
    let long_words: Vec<&str> = text
        .split_whitespace()
        .map(|word| clean_word(word))
        .filter(|word| word.len() > 5)
        .collect();
    
    if !long_words.is_empty() {
        println!("6글자 이상 단어들: {:?}", long_words);
    }
    
    // 문자 빈도 분석
    analyze_character_frequency(&text);
}

fn count_words(text: &str) -> HashMap<String, usize> {
    let mut word_count = HashMap::new();
    
    text.split_whitespace()
        .map(|word| clean_word(word).to_lowercase())
        .filter(|word| !word.is_empty())
        .for_each(|word| {
            *word_count.entry(word).or_insert(0) += 1;
        });
    
    word_count
}

fn clean_word(word: &str) -> &str {
    word.trim_matches(|c: char| !c.is_alphabetic())
}

fn print_word_count(word_count: &HashMap<String, usize>) {
    if word_count.is_empty() {
        println!("단어가 없습니다.");
        return;
    }
    
    // 빈도순으로 정렬
    let mut word_vec: Vec<(&String, &usize)> = word_count.iter().collect();
    word_vec.sort_by(|a, b| b.1.cmp(a.1));
    
    println!("\n단어 빈도 (내림차순):");
    println!("{:<15} {:<10}", "단어", "빈도");
    println!("{}", "-".repeat(25));
    
    for (word, count) in word_vec.iter().take(20) {  // 상위 20개만 표시
        println!("{:<15} {:<10}", word, count);
    }
    
    if word_vec.len() > 20 {
        println!("... ({}개 단어 중 상위 20개만 표시)", word_vec.len());
    }
}

fn print_statistics(word_count: &HashMap<String, usize>, text: &str) {
    let total_words = word_count.values().sum::<usize>();
    let unique_words = word_count.len();
    
    println!("\n=== 통계 정보 ===");
    println!("총 단어 수: {}", total_words);
    println!("고유 단어 수: {}", unique_words);
    
    if total_words > 0 {
        let diversity_ratio = unique_words as f64 / total_words as f64;
        println!("어휘 다양성: {:.2}%", diversity_ratio * 100.0);
    }
    
    // 가장 빈번한 단어들
    let mut frequent_words: Vec<(&String, &usize)> = word_count.iter().collect();
    frequent_words.sort_by(|a, b| b.1.cmp(a.1));
    
    println!("\n가장 빈번한 단어 TOP 5:");
    for (i, (word, count)) in frequent_words.iter().take(5).enumerate() {
        println!("{}. {} ({}회)", i + 1, word, count);
    }
    
    // 한 번만 나타나는 단어들
    let unique_occurrences: Vec<&String> = word_count
        .iter()
        .filter(|(_, &count)| count == 1)
        .map(|(word, _)| word)
        .collect();
    
    println!("\n한 번만 나타나는 단어 수: {}", unique_occurrences.len());
    
    if unique_occurrences.len() <= 10 {
        println!("한 번만 나타나는 단어들: {:?}", unique_occurrences);
    }
}

fn analyze_character_frequency(text: &str) {
    let mut char_count = HashMap::new();
    
    // 알파벳 문자만 카운트 (소문자로 변환)
    text.chars()
        .filter(|c| c.is_alphabetic())
        .map(|c| c.to_lowercase().next().unwrap())
        .for_each(|c| {
            *char_count.entry(c).or_insert(0) += 1;
        });
    
    if char_count.is_empty() {
        return;
    }
    
    // 빈도순으로 정렬
    let mut char_vec: Vec<(&char, &usize)> = char_count.iter().collect();
    char_vec.sort_by(|a, b| b.1.cmp(a.1));
    
    println!("\n=== 문자 빈도 분석 ===");
    println!("{:<5} {:<10} {}", "문자", "빈도", "비율");
    println!("{}", "-".repeat(25));
    
    let total_chars: usize = char_count.values().sum();
    
    for (c, count) in char_vec.iter().take(10) {
        let percentage = **count as f64 / total_chars as f64 * 100.0;
        println!("{:<5} {:<10} {:.1}%", c, count, percentage);
    }
}

// 추가 기능: 단어 검색
#[allow(dead_code)]
fn search_words(word_count: &HashMap<String, usize>, pattern: &str) {
    let matches: Vec<(&String, &usize)> = word_count
        .iter()
        .filter(|(word, _)| word.contains(&pattern.to_lowercase()))
        .collect();
    
    if matches.is_empty() {
        println!("'{}' 패턴을 포함하는 단어가 없습니다.", pattern);
    } else {
        println!("'{}' 패턴을 포함하는 단어들:", pattern);
        for (word, count) in matches {
            println!("  {} ({}회)", word, count);
        }
    }
}

// 추가 기능: 텍스트 요약
#[allow(dead_code)]
fn summarize_text(text: &str, word_count: &HashMap<String, usize>) {
    let sentences: Vec<&str> = text
        .split(|c| c == '.' || c == '!' || c == '?')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .collect();
    
    println!("\n=== 텍스트 요약 ===");
    println!("문장 수: {}", sentences.len());
    
    if !sentences.is_empty() {
        let avg_sentence_length = text.split_whitespace().count() as f64 / sentences.len() as f64;
        println!("평균 문장 길이: {:.1} 단어", avg_sentence_length);
    }
    
    // 중요 단어 (빈도 높은 단어) 기반 문장 스코어링
    let mut sentence_scores: Vec<(usize, &str)> = sentences
        .iter()
        .enumerate()
        .map(|(i, sentence)| {
            let score = sentence
                .split_whitespace()
                .map(|word| {
                    let clean = clean_word(word).to_lowercase();
                    word_count.get(&clean).unwrap_or(&0)
                })
                .sum::<usize>();
            (score, *sentence)
        })
        .collect();
    
    sentence_scores.sort_by(|a, b| b.0.cmp(&a.0));
    
    println!("\n가장 중요한 문장들 (단어 빈도 기반):");
    for (i, (score, sentence)) in sentence_scores.iter().take(3).enumerate() {
        println!("{}. [점수: {}] {}", i + 1, score, sentence);
    }
}
```

### 프로그램 실행 방법

```bash
cargo new word_counter
cd word_counter
# 위 코드를 src/main.rs에 복사
cargo run
```

### 실행 예시

```
=== 단어 카운터 프로그램 ===

1. 텍스트 입력하여 단어 카운트
2. 파일에서 단어 카운트 (시뮬레이션)
3. 단어 통계 분석
4. 종료
선택하세요: 2

샘플 텍스트:
Rust is a systems programming language that runs blazingly fast,
        prevents segfaults, and guarantees thread safety. Rust achieves memory safety
        without garbage collection, making it a perfect choice for systems programming.
        The Rust programming language helps developers write faster, more reliable software.

단어 카운트 결과:

단어 빈도 (내림차순):
단어            빈도      
-------------------------
rust            3         
programming     3         
systems         2         
language        2         
safety          2         
is              1         
a               1         
that            1         
...
```

### 프로그램에서 사용된 개념들
1. **Vec<T>**: 동적 배열로 단어들과 통계 데이터 저장
2. **String vs &str**: 소유된 문자열과 문자열 슬라이스의 적절한 사용
3. **HashMap**: 단어 빈도와 문자 빈도 카운팅
4. **Iterator**: 텍스트 처리, 필터링, 변환, 집계를 위한 함수형 스타일 프로그래밍
5. **소유권과 빌림**: 효율적인 메모리 사용과 안전한 데이터 접근

---

**이번 장 요약:**
1. **Vec<T>**: 동적 크기 배열로 push, pop, insert, remove 등의 메서드 제공
2. **String과 &str**: 소유된 문자열과 문자열 슬라이스의 차이와 상호 변환
3. **HashMap**: 키-값 쌍 저장으로 효율적인 데이터 검색과 카운팅
4. **Iterator**: 함수형 프로그래밍 스타일로 데이터 처리 (map, filter, fold 등)
5. **소유권 규칙**: 컬렉션과 반복자에서의 소유권 이전과 빌림 패턴

이 장에서 다룬 컬렉션들과 반복자는 Rust 프로그래밍에서 가장 자주 사용되는 도구들이다.     