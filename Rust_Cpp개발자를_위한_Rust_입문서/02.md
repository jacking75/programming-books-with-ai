# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
    
# 2장. 기본 문법과 데이터 타입

## 2.1 변수와 가변성 (let, mut)
C++에서는 변수를 선언할 때 타입을 명시하고, 기본적으로 변수는 변경 가능하다. 하지만 Rust는 정반대이다. 기본적으로 불변이고, 변경하려면 명시적으로 `mut` 키워드를 사용해야 한다.

### 기본 변수 선언

```rust
fn main() {
    // 불변 변수 (기본)
    let x = 5;
    println!("x의 값: {}", x);
    
    // 이런 코드는 컴파일 에러!
    // x = 10;  // error: cannot assign twice to immutable variable
}
```

### 가변 변수 선언

```rust
fn main() {
    // 가변 변수
    let mut y = 5;
    println!("y의 초기값: {}", y);
    
    y = 10;  // 이제 가능!
    println!("y의 변경된 값: {}", y);
}
```

### C++와의 비교

```cpp
// C++: 기본적으로 변경 가능
int x = 5;
x = 10;  // OK

const int y = 5;
// y = 10;  // 컴파일 에러

const int* ptr1;      // 포인터가 가리키는 값이 상수
int* const ptr2;      // 포인터 자체가 상수
const int* const ptr3; // 둘 다 상수
```

```rust
// Rust: 기본적으로 불변
let x = 5;
// x = 10;  // 컴파일 에러

let mut y = 5;
y = 10;  // OK

// 참조도 마찬가지
let z = 42;
let r1 = &z;         // 불변 참조
let mut w = 42;
let r2 = &mut w;     // 가변 참조
```

### 변수 섀도잉 (Variable Shadowing)
Rust에서는 같은 이름으로 새로운 변수를 선언할 수 있다. 이를 섀도잉이라고 한다:

```rust
fn main() {
    let x = 5;
    let x = x + 1;  // 새로운 변수 x
    let x = x * 2;  // 또 다른 새로운 변수 x
    
    println!("x의 값: {}", x);  // 12
    
    // 타입도 바꿀 수 있어
    let spaces = "   ";      // 문자열
    let spaces = spaces.len(); // 숫자
    println!("공백 개수: {}", spaces);
}
```

### 타입 추론과 명시

```rust
fn main() {
    // 타입 추론
    let guess = "42".parse().expect("숫자가 아님!");
    // 위 코드는 애매함! 어떤 타입으로 파싱할지 모름
    
    // 타입 명시 방법 1: 변수에 타입 지정
    let guess: u32 = "42".parse().expect("숫자가 아님!");
    
    // 타입 명시 방법 2: 터보피쉬 문법
    let guess = "42".parse::<u32>().expect("숫자가 아님!");
    
    println!("추측값: {}", guess);
}
```
   
</br>       
  

## 2.2 기본 데이터 타입 (정수, 부동소수점, 불린, 문자)
Rust는 C++보다 더 명확한 타입 시스템을 가지고 있다. 각 타입의 크기와 범위가 명확하게 정의되어 있다.

### 정수 타입

```rust
fn main() {
    // 부호 있는 정수
    let i8_val: i8 = -128;      // -128 ~ 127
    let i16_val: i16 = -32_768;  // -32,768 ~ 32,767
    let i32_val: i32 = -2_147_483_648; // 기본 정수 타입
    let i64_val: i64 = -9_223_372_036_854_775_808;
    let i128_val: i128 = -170_141_183_460_469_231_731_687_303_715_884_105_728;
    let isize_val: isize = -100; // 포인터 크기에 따라 (32비트 또는 64비트)
    
    // 부호 없는 정수
    let u8_val: u8 = 255;       // 0 ~ 255
    let u16_val: u16 = 65_535;   // 0 ~ 65,535
    let u32_val: u32 = 4_294_967_295;
    let u64_val: u64 = 18_446_744_073_709_551_615;
    let u128_val: u128 = 340_282_366_920_938_463_463_374_607_431_768_211_455;
    let usize_val: usize = 100; // 포인터 크기에 따라
    
    println!("i32: {}, u32: {}", i32_val, u32_val);
}
```

### 정수 리터럴 표현법

```rust
fn main() {
    let decimal = 98_222;        // 10진수 (언더스코어로 가독성 향상)
    let hex = 0xff;             // 16진수
    let octal = 0o77;           // 8진수
    let binary = 0b1111_0000;   // 2진수
    let byte = b'A';            // 바이트 (u8 타입만)
    
    println!("10진수: {}", decimal);
    println!("16진수: {}", hex);
    println!("8진수: {}", octal);
    println!("2진수: {}", binary);
    println!("바이트: {}", byte);
}
```

### 부동소수점 타입

```rust
fn main() {
    let f32_val: f32 = 3.14;    // 32비트 부동소수점
    let f64_val: f64 = 2.718;   // 64비트 부동소수점 (기본값)
    let implicit = 1.0;         // f64로 추론
    
    // 수학 연산
    let sum = f32_val + 1.0f32;  // 같은 타입끼리만 연산 가능
    let difference = f64_val - 1.0;
    let product = implicit * 2.0;
    let quotient = f64_val / 2.0;
    let remainder = 43.5 % 5.0;
    
    println!("합: {}, 차: {}, 곱: {}, 몫: {}, 나머지: {}", 
             sum, difference, product, quotient, remainder);
}
```

### 불린 타입

```rust
fn main() {
    let t: bool = true;
    let f: bool = false;
    
    // 조건식에서 자동 생성
    let is_bigger = 10 > 5;
    
    // 논리 연산
    let and_result = t && f;  // false
    let or_result = t || f;   // true
    let not_result = !t;      // false
    
    println!("불린값들: {}, {}, {}", and_result, or_result, not_result);
}
```

### 문자 타입

```rust
fn main() {
    let c: char = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
    
    // char는 4바이트 유니코드 스칼라 값
    println!("문자들: {}, {}, {}", c, z, heart_eyed_cat);
    
    // 문자열 리터럴은 &str 타입
    let hello = "안녕하세요!";
    println!("문자열: {}", hello);
}
```

### C++와의 타입 비교

```cpp
// C++
char c = 'A';           // 1바이트
wchar_t wc = L'A';      // 플랫폼 의존적
int i = 42;             // 플랫폼 의존적 (보통 32비트)
long l = 42L;           // 플랫폼 의존적
float f = 3.14f;        // 32비트
double d = 3.14;        // 64비트
bool b = true;          // 1바이트 (구현 의존적)
```

```rust
// Rust
let c: char = 'A';      // 4바이트 유니코드
let i: i32 = 42;        // 명확하게 32비트
let l: i64 = 42;        // 명확하게 64비트
let f: f32 = 3.14;      // 명확하게 32비트
let d: f64 = 3.14;      // 명확하게 64비트
let b: bool = true;     // 1바이트
```
     
</br>      
  

## 2.3 함수 정의와 호출

### 기본 함수 정의

```rust
// 매개변수가 없는 함수
fn greet() {
    println!("안녕하세요!");
}

// 매개변수가 있는 함수
fn greet_person(name: &str) {
    println!("안녕하세요, {}님!", name);
}

// 반환값이 있는 함수
fn add(a: i32, b: i32) -> i32 {
    a + b  // 세미콜론 없음 = 반환값
}

// 명시적 return 사용
fn subtract(a: i32, b: i32) -> i32 {
    return a - b;  // 세미콜론 있음
}

fn main() {
    greet();
    greet_person("철수");
    
    let sum = add(5, 3);
    let diff = subtract(10, 4);
    
    println!("합: {}, 차: {}", sum, diff);
}
```

### 표현식 vs 문장
Rust에서는 표현식(expression)과 문장(statement)을 구분해:

```rust
fn main() {
    // 문장: 값을 반환하지 않음
    let x = 5;
    
    // 표현식: 값을 반환함
    let y = {
        let x = 3;
        x + 1  // 4를 반환 (세미콜론 없음)
    };
    
    println!("x: {}, y: {}", x, y);
    
    // 함수 호출도 표현식
    let z = add_one(5);
    println!("z: {}", z);
}

fn add_one(x: i32) -> i32 {
    x + 1  // 표현식으로 반환
}
```

### 다양한 반환 타입

```rust
// 유닛 타입 () 반환 (C++의 void와 유사)
fn print_number(x: i32) {
    println!("숫자: {}", x);
    // () 타입을 반환 (생략 가능)
}

// 튜플 반환
fn get_coordinates() -> (f64, f64) {
    (3.14, 2.71)
}

// 조건부 반환
fn absolute_value(x: i32) -> i32 {
    if x < 0 {
        -x
    } else {
        x
    }
}

fn main() {
    print_number(42);
    
    let (x, y) = get_coordinates();
    println!("좌표: ({}, {})", x, y);
    
    println!("절댓값: {}", absolute_value(-10));
}
```
  
</br>      
  

## 2.4 제어문 (if, loop, while, for)

### if 표현식

```rust
fn main() {
    let number = 6;
    
    // 기본 if
    if number % 4 == 0 {
        println!("4로 나누어 떨어짐");
    } else if number % 3 == 0 {
        println!("3으로 나누어 떨어짐");
    } else if number % 2 == 0 {
        println!("2로 나누어 떨어짐");
    } else {
        println!("4, 3, 2로 나누어 떨어지지 않음");
    }
    
    // if는 표현식이므로 값을 반환할 수 있음
    let condition = true;
    let number = if condition { 5 } else { 6 };
    println!("조건부 할당 결과: {}", number);
}
```

### loop (무한 루프)

* `loop`는 **무한 반복문**을 만드는 키워드다.
* `break`로 명시적으로 종료하지 않으면 영원히 반복된다.
  
#### 기본 구조

```rust
loop {
    println!("반복 중");
}
```

#### `break`로 탈출
  
```rust
let mut count = 0;

loop {
    count += 1;
    if count == 3 {
        break; // 루프 종료
    }
}
```

#### `break`로 값 반환

* `break`는 **값을 반환할 수도 있다**
* `loop` 자체가 **표현식**이라서 결과를 변수에 할당할 수 있다

```rust
let result = loop {
    let val = compute();
    if val > 10 {
        break val; // val을 반환
    }
};
println!("결과: {}", result);
```

#### `continue`

* `continue`는 현재 반복을 건너뛰고 다음 반복으로 진행한다

```rust
let mut i = 0;

loop {
    if i >= 5 {
        break; // 범위 종료
    }

    if i == 2 {
        i += 1;
        continue; // 현재 반복 건너뜀
    }

    println!("{}", i);
    i += 1;
}
```

#### 중첩 루프와 `'label`

* `break`나 `continue`에 **라벨(label)** 을 붙여 바깥 루프를 제어할 수 있다

```rust
'outer: loop {
    loop {
        break 'outer; // 바깥 루프 종료
    }
}
```

#### 핵심 요약

| 키워드        | 의미          | 특징          |
| ---------- | ----------- | ----------- |
| `loop`     | 무한 반복       | 명시적 종료 필요   |
| `break`    | 루프 종료       | 값 반환 가능     |
| `continue` | 다음 반복으로 건너뜀 | 현재 반복만 스킵   |
| `'label`   | 루프 이름 지정    | 중첩 루프 제어 가능 |
  
  
### while 루프

```rust
fn main() {
    let mut number = 3;
    
    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }
    
    println!("발사!");
}
```

### for 루프

```rust
fn main() {
    // 범위를 이용한 반복
    for number in 1..4 {  // 1, 2, 3 (4 제외)
        println!("숫자: {}", number);
    }
    
    // 포함 범위
    for number in 1..=3 {  // 1, 2, 3 (3 포함)
        println!("포함 범위: {}", number);
    }
    
    // 배열 반복
    let arr = [10, 20, 30, 40, 50];
    
    for element in arr {
        println!("배열 요소: {}", element);
    }
    
    // 인덱스와 함께 반복
    for (index, value) in arr.iter().enumerate() {
        println!("인덱스 {}: 값 {}", index, value);
    }
    
    // 역순 반복
    for number in (1..4).rev() {  // 3, 2, 1
        println!("역순: {}", number);
    }
}
```

### 중첩 루프와 레이블

```rust
fn main() {
    'outer: loop {
        println!("외부 루프 시작");
        
        'inner: loop {
            println!("내부 루프");
            break 'outer;  // 외부 루프 탈출
        }
        
        println!("이 줄은 실행되지 않음");
    }
    
    println!("루프 종료");
}
```
  
### C++와의 제어문 비교

```cpp
// C++
int x = 5;
if (x > 0) {
    std::cout << "양수" << std::endl;
}

for (int i = 0; i < 5; i++) {
    std::cout << i << std::endl;
}

while (x > 0) {
    std::cout << x << std::endl;
    x--;
}
```
  
```rust
// Rust
let x = 5;
if x > 0 {
    println!("양수");
}

for i in 0..5 {
    println!("{}", i);
}

let mut x = 5;
while x > 0 {
    println!("{}", x);
    x -= 1;
}
```
  
</br>  
  

## 실습: 간단한 계산기 만들기
이제 배운 내용을 종합해서 간단한 계산기를 만들어보자:

```rust
use std::io;

fn main() {
    println!("=== 간단한 계산기 ===");
    
    loop {
        println!("\n메뉴를 선택하세요:");
        println!("1. 덧셈");
        println!("2. 뺄셈");
        println!("3. 곱셈");
        println!("4. 나눗셈");
        println!("5. 종료");
        
        let choice = get_user_input("선택: ");
        
        match choice.trim() {
            "1" => perform_operation('+'),
            "2" => perform_operation('-'),
            "3" => perform_operation('*'),
            "4" => perform_operation('/'),
            "5" => {
                println!("계산기를 종료합니다.");
                break;
            }
            _ => println!("잘못된 선택입니다. 1-5 사이의 숫자를 입력하세요."),
        }
    }
}

fn get_user_input(prompt: &str) -> String {
    println!("{}", prompt);
    let mut input = String::new();
    io::stdin()
        .read_line(&mut input)
        .expect("입력을 읽는데 실패했습니다.");
    input
}

fn get_number(prompt: &str) -> f64 {
    loop {
        let input = get_user_input(prompt);
        match input.trim().parse::<f64>() {
            Ok(num) => return num,
            Err(_) => println!("올바른 숫자를 입력하세요."),
        }
    }
}

fn perform_operation(operator: char) {
    let num1 = get_number("첫 번째 숫자를 입력하세요: ");
    let num2 = get_number("두 번째 숫자를 입력하세요: ");
    
    let result = match operator {
        '+' => num1 + num2,
        '-' => num1 - num2,
        '*' => num1 * num2,
        '/' => {
            if num2 == 0.0 {
                println!("0으로 나눌 수 없습니다!");
                return;
            }
            num1 / num2
        }
        _ => {
            println!("알 수 없는 연산자입니다.");
            return;
        }
    };
    
    println!("결과: {} {} {} = {}", num1, operator, num2, result);
}
```

### 계산기 실행 예시
프로젝트를 만들고 실행한다:  

```bash
cargo new simple_calculator
cd simple_calculator
# 위 코드를 src/main.rs에 복사
cargo run
```
  
실행 결과:  
```
=== 간단한 계산기 ===

메뉴를 선택하세요:
1. 덧셈
2. 뺄셈
3. 곱셈
4. 나눗셈
5. 종료
선택: 1
첫 번째 숫자를 입력하세요: 10
두 번째 숫자를 입력하세요: 5
결과: 10 + 5 = 15
```
  
### 계산기에서 사용한 개념들
1. **변수와 가변성**: `let mut input = String::new()`
2. **함수**: 기능별로 함수 분리
3. **제어문**: `loop`, `match`, `if` 사용
4. **데이터 타입**: 문자열, 부동소수점 숫자 처리
5. **에러 처리**: `match`와 `Result` 타입 활용

---

**이번 장 요약:**
1. Rust 변수는 기본적으로 불변이며, `mut`로 가변성을 명시해
2. 타입 시스템이 명확하고 크기가 고정되어 있어
3. 함수에서 표현식과 문장을 구분하며, 마지막 표현식이 반환값이야
4. 제어문들은 표현식으로 사용할 수 있어
5. 실습을 통해 사용자 입력, 에러 처리, 패턴 매칭을 경험했어  