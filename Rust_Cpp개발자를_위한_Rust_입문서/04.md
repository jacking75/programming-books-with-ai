# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
  
# 4장. 구조체와 열거형

## 들어가기 전에
C++에서 클래스와 구조체는 거의 동일하고, 열거형은 상당히 제한적이었다. Rust에서는 구조체가 데이터 구조화의 주된 방법이고, 열거형은 훨씬 강력한 기능을 제공한다. 이 장에서는 Rust의 사용자 정의 타입을 만들고 활용하는 방법을 배워보자.
  

## 4.1 구조체 정의와 사용

### 기본 구조체 정의

```rust
// 구조체 정의
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    // 구조체 인스턴스 생성
    let user1 = User {
        email: String::from("user@example.com"),
        username: String::from("rustacean"),
        active: true,
        sign_in_count: 1,
    };
    
    println!("사용자명: {}", user1.username);
    println!("이메일: {}", user1.email);
}
```

### C++와의 비교

```cpp
// C++
class User {
public:
    std::string username;
    std::string email;
    uint64_t sign_in_count;
    bool active;
    
    // 생성자
    User(const std::string& username, const std::string& email)
        : username(username), email(email), sign_in_count(1), active(true) {}
};

int main() {
    User user1("rustacean", "user@example.com");
    std::cout << "사용자명: " << user1.username << std::endl;
}
```

```rust
// Rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        username: String::from("rustacean"),
        email: String::from("user@example.com"),
        sign_in_count: 1,
        active: true,
    };
    
    println!("사용자명: {}", user1.username);
}
```

### 가변 구조체

```rust
struct Point {
    x: f64,
    y: f64,
}

fn main() {
    let mut point = Point { x: 0.0, y: 0.0 };
    
    println!("초기 좌표: ({}, {})", point.x, point.y);
    
    // 필드 값 변경
    point.x = 5.0;
    point.y = 10.0;
    
    println!("변경된 좌표: ({}, {})", point.x, point.y);
}
```

### 구조체 생성 함수와 필드 초기화 단축 문법

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn build_user(email: String, username: String) -> User {
    User {
        email,          // email: email과 동일 (필드 초기화 단축 문법)
        username,       // username: username과 동일
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("user@example.com"),
        String::from("rustacean"),
    );
    
    println!("생성된 사용자: {}", user1.username);
}
```

### 구조체 업데이트 문법

```rust
fn main() {
    let user1 = User {
        email: String::from("user1@example.com"),
        username: String::from("user1"),
        active: true,
        sign_in_count: 1,
    };
    
    // user1의 일부 필드를 재사용하여 user2 생성
    let user2 = User {
        email: String::from("user2@example.com"),
        username: String::from("user2"),
        ..user1  // 나머지 필드는 user1에서 가져옴
    };
    
    println!("user2 활성 상태: {}", user2.active);
    println!("user2 로그인 횟수: {}", user2.sign_in_count);
    
    // 주의: user1의 일부 필드가 이전되었으므로 user1은 더 이상 사용할 수 없음
    // println!("{}", user1.username); // 컴파일 에러!
}
```
  
### 튜플 구조체

```rust
// 색상을 나타내는 튜플 구조체
struct Color(i32, i32, i32);

// 3D 벡터를 나타내는 튜플 구조체
struct Point3D(f64, f64, f64);

fn main() {
    let red = Color(255, 0, 0);
    let origin = Point3D(0.0, 0.0, 0.0);
    
    // 인덱스로 접근
    println!("빨간색 RGB: ({}, {}, {})", red.0, red.1, red.2);
    println!("원점 좌표: ({}, {}, {})", origin.0, origin.1, origin.2);
    
    // 구조 분해
    let Color(r, g, b) = red;
    println!("분해된 색상: R={}, G={}, B={}", r, g, b);
}
```

### 유닛 구조체

```rust
// 유닛 구조체 (필드가 없는 구조체)
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
    
    // 유닛 구조체는 주로 트레이트 구현에 사용됨
}
```

### 구조체와 소유권

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    // 구조체 전체가 이전됨
    let rect2 = rect1;
    
    // println!("rect1: {:?}", rect1); // 컴파일 에러!
    println!("rect2: {:?}", rect2);   // OK
    
    // 참조 사용
    let rect3 = Rectangle { width: 20, height: 40 };
    print_rectangle(&rect3);
    println!("rect3는 여전히 사용 가능: {:?}", rect3);
}

fn print_rectangle(rect: &Rectangle) {
    println!("사각형: 너비 {}, 높이 {}", rect.width, rect.height);
}
```
    
</br>  
  
  
## 4.2 메서드와 연관 함수

### 메서드 정의

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 메서드 (첫 번째 매개변수가 &self)
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // 가변 메서드
    fn double(&mut self) {
        self.width *= 2;
        self.height *= 2;
    }
    
    // 소유권을 가져오는 메서드 (드물게 사용)
    fn destroy(self) -> (u32, u32) {
        println!("사각형을 파괴합니다!");
        (self.width, self.height)
    }
    
    // 다른 Rectangle과 비교
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    println!("사각형의 넓이: {}", rect1.area());
    
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    
    println!("rect1이 rect2를 포함할 수 있나? {}", rect1.can_hold(&rect2));
    
    // 가변 메서드 사용
    let mut rect3 = Rectangle { width: 5, height: 10 };
    println!("변경 전: {:?}", rect3);
    rect3.double();
    println!("변경 후: {:?}", rect3);
}
```

### 연관 함수 (Associated Functions)

```rust
impl Rectangle {
    // 연관 함수 (self 매개변수 없음) - C++의 static 멤버 함수와 유사
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
    
    // 또 다른 생성자 함수
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
}

fn main() {
    // 연관 함수 호출 (::문법 사용)
    let sq = Rectangle::square(3);
    let rect = Rectangle::new(10, 20);
    
    println!("정사각형: {:?}", sq);
    println!("사각형: {:?}", rect);
}
```

### 여러 impl 블록

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn perimeter(&self) -> u32 {
        2 * (self.width + self.height)
    }
}

// 둘 다 같은 타입에 대한 구현으로 유효함
```

### C++와의 메서드 비교

```cpp
// C++
class Rectangle {
private:
    uint32_t width, height;

public:
    Rectangle(uint32_t w, uint32_t h) : width(w), height(h) {}
    
    uint32_t area() const {          // const 메서드
        return width * height;
    }
    
    void double_size() {             // 비-const 메서드
        width *= 2;
        height *= 2;
    }
    
    static Rectangle square(uint32_t size) {  // static 메서드
        return Rectangle(size, size);
    }
};
```

```rust
// Rust
impl Rectangle {
    fn area(&self) -> u32 {          // 불변 참조 메서드
        self.width * self.height
    }
    
    fn double(&mut self) {           // 가변 참조 메서드
        self.width *= 2;
        self.height *= 2;
    }
    
    fn square(size: u32) -> Rectangle {  // 연관 함수
        Rectangle {
            width: size,
            height: size,
        }
    }
}
```
  
</br>    
  

## 4.3 열거형(enum)과 패턴 매칭

### 기본 열거형

```rust
// 기본 열거형
#[derive(Debug)]
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
    
    println!("IPv4: {:?}", four);
    println!("IPv6: {:?}", six);
    
    route(four);
    route(six);
}

fn route(ip_kind: IpAddrKind) {
    match ip_kind {
        IpAddrKind::V4 => println!("IPv4 주소로 라우팅"),
        IpAddrKind::V6 => println!("IPv6 주소로 라우팅"),
    }
}
```  
  
아래는 위 코드에 대한 설명이다.  

#### 1. 열거형(Enum) 정의

```rust
#[derive(Debug)]
enum IpAddrKind {
    V4,
    V6,
}
```  
  - 이 코드는 `IpAddrKind`라는 이름의 열거형을 정의한다.
  - 열거형은 관련된 값들을 하나의 타입으로 묶는 방법이다.
  - `V4`와 `V6`는 이 열거형이 가질 수 있는 값, 즉 배리언트(variant)다.
  - `IpAddrKind` 타입의 변수는 `V4` 또는 `V6` 중 하나의 값만 가진다.
  - `#[derive(Debug)]`는 디버깅 목적으로 값을 출력할 수 있도록 컴파일러가 관련 코드를 자동으로 생성해주는 어트리뷰트다.

#### 2. `main` 함수: 프로그램 실행 시작점

```rust
fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    println!("IPv4: {:?}", four);
    println!("IPv6: {:?}", six);

    route(four);
    route(six);
}
```

  - `main` 함수는 러스트 프로그램이 시작되는 진입점이다.
  - `let four = IpAddrKind::V4;` 코드는 `four` 변수에 `IpAddrKind`의 `V4` 배리언트를 할당한다.
  - `let six = IpAddrKind::V6;` 코드는 `six` 변수에 `V6` 배리언트를 할당한다.
  - `println!` 매크로는 변수의 값을 터미널에 출력한다.
  - `{:?}`는 `#[derive(Debug)]`로 인해 사용 가능한 디버그 출력 형식이다.
  - 마지막으로 `route` 함수를 `four`와 `six` 변수를 인자로 하여 각각 호출한다.

#### 3. `route` 함수와 `match` 표현식

```rust
fn route(ip_kind: IpAddrKind) {
    match ip_kind {
        IpAddrKind::V4 => println!("IPv4 주소로 라우팅"),
        IpAddrKind::V6 => println!("IPv6 주소로 라우팅"),
    }
}
```

  - `route` 함수는 `IpAddrKind` 타입의 인자 하나를 받는다.
  - `match`는 인자로 받은 `ip_kind`의 값을 확인하여 특정 코드 블록을 실행하는 제어 흐름 연산자다.
  - `ip_kind`의 값이 `IpAddrKind::V4`이면 "IPv4 주소로 라우팅"을 출력한다.
  - `ip_kind`의 값이 `IpAddrKind::V6`이면 "IPv6 주소로 라우팅"을 출력한다.
  - 러스트의 `match`는 모든 가능한 경우를 반드시 처리해야 하므로 코드의 안정성을 높인다.

#### 실행 결과
이 코드를 실행했을 때의 최종 결과는 다음과 같다.

```
IPv4: V4
IPv6: V6
IPv4 주소로 라우팅
IPv6 주소로 라우팅
```  
  

### 데이터를 포함하는 열거형

```rust
#[derive(Debug)]
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

fn main() {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
    
    println!("집 주소: {:?}", home);
    println!("루프백 주소: {:?}", loopback);
    
    print_ip_info(&home);
    print_ip_info(&loopback);
}

fn print_ip_info(ip: &IpAddr) {
    match ip {
        IpAddr::V4(a, b, c, d) => {
            println!("IPv4 주소: {}.{}.{}.{}", a, b, c, d);
        }
        IpAddr::V6(addr) => {
            println!("IPv6 주소: {}", addr);
        }
    }
}
```

### 복잡한 열거형

```rust
#[derive(Debug)]
enum Message {
    Quit,                       // 데이터 없음
    Move { x: i32, y: i32 },    // 구조체와 유사
    Write(String),              // 단일 값
    ChangeColor(i32, i32, i32), // 튜플과 유사
}

impl Message {
    // 열거형에도 메서드 구현 가능
    fn call(&self) {
        match self {
            Message::Quit => println!("프로그램을 종료합니다."),
            Message::Move { x, y } => println!("({}, {})로 이동합니다.", x, y),
            Message::Write(text) => println!("메시지 작성: {}", text),
            Message::ChangeColor(r, g, b) => {
                println!("색상 변경: RGB({}, {}, {})", r, g, b)
            }
        }
    }
}

fn main() {
    let messages = vec![
        Message::Quit,
        Message::Move { x: 10, y: 20 },
        Message::Write(String::from("안녕하세요")),
        Message::ChangeColor(255, 128, 0),
    ];
    
    for message in messages {
        message.call();
    }
}
```

### C++ union과의 비교

```cpp
// C++ (전통적인 union - 안전하지 않음)
union Data {
    int i;
    float f;
    char str[20];
};

// C++17 std::variant (Rust enum과 유사)
#include <variant>
#include <string>

using Message = std::variant<
    std::monostate,  // Quit에 해당
    std::pair<int, int>,  // Move
    std::string,     // Write
    std::tuple<int, int, int>  // ChangeColor
>;
```

```rust
// Rust enum (타입 안전함)
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

### match 표현식

```rust
#[derive(Debug)]
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // ... 나머지 주들
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("행운의 페니!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("{}주의 쿼터!", state);
            25
        }
    }
}

fn main() {
    let coin = Coin::Quarter(UsState::Alaska);
    println!("동전 가치: {}센트", value_in_cents(coin));
}
```

### if let 간단한 제어 흐름

```rust
fn main() {
    let some_u8_value = Some(3);
    
    // match를 사용한 방법
    match some_u8_value {
        Some(3) => println!("3이군요!"),
        _ => (),  // 나머지 경우는 무시
    }
    
    // if let을 사용한 더 간단한 방법
    if let Some(3) = some_u8_value {
        println!("3이군요!");
    }
    
    // else와 함께 사용
    if let Some(value) = some_u8_value {
        println!("값: {}", value);
    } else {
        println!("값이 없습니다.");
    }
}
```  
  
#### 1. `match`를 사용한 방법

```rust
// match를 사용한 방법
match some_u8_value {
    Some(3) => println!("3이군요!"),
    _ => (),  // 나머지 경우는 무시
}
```

  - `match`는 변수가 가질 수 있는 모든 패턴을 검사하는 제어 흐름 연산자다.
  - 첫 번째 줄은 변수의 값이 `Some(3)` 패턴과 정확히 일치하는지 확인한다.
  - `_`는 `Some(3)` 외의 모든 값을 의미하는 와일드카드 패턴이다.
  - `()`는 아무 동작도 하지 않음을 뜻하는 유닛(unit) 타입이다.
  - 따라서 이 `match` 구문은 값이 `Some(3)`일 때만 특정 동작을 하고, 나머지 모든 경우는 무시한다.
  - 하나의 값만 처리하려 할 때 `match`를 쓰는 것은 다소 장황할 수 있다.


#### 2. `if let`을 사용한 방법

```rust
// if let을 사용한 더 간단한 방법
if let Some(3) = some_u8_value {
    println!("3이군요!");
}
```

  - `if let`은 단 하나의 패턴만 검사하고 싶을 때 사용하는 `match`의 간결한 버전이다.
  - `if let 패턴 = 변수`의 형태로, 변수가 패턴과 일치할 경우에만 코드 블록이 실행된다.
  - 이 코드는 `some_u8_value`의 값이 `Some(3)`일 때만 `println!`을 실행한다.
  - `match`에서 필요했던 나머지 경우를 무시하는 `_ => ()` 코드가 필요 없어 더 깔끔하다.

  
#### 3. `if let`과 `else`의 조합

```rust
// else와 함께 사용
if let Some(value) = some_u8_value {
    println!("값: {}", value);
} else {
    println!("값이 없습니다.");
}
```

  - `if let`은 `else`와 함께 사용하여 `match`처럼 두 가지 경우를 처리할 수 있다.
  - `Some(value)` 패턴은 `Some`으로 감싸인 어떤 값이든 일치시킨다.
  - 패턴이 일치하면 `Some` 안의 값(`3`)이 `value`라는 새 변수에 담겨 `if` 블록 안에서 사용된다.
  - 패턴이 일치하지 않는 경우(예: 변수 값이 `None`일 때)에는 `else` 블록이 실행된다.

#### 핵심 요약
  - `match`는 모든 가능한 패턴을 개별적으로 처리해야 할 때 사용한다.
  - `if let`은 여러 패턴 중 단 하나에만 관심이 있을 때 코드를 간결하게 만들기 위해 사용한다.  

</br>  
  

## 4.4 Option과 Result 타입

### Option 타입

```rust
fn main() {
    let some_number = Some(5);
    let some_string = Some("hello");
    let absent_number: Option<i32> = None;
    
    // Option 값 사용하기
    if let Some(num) = some_number {
        println!("숫자가 있습니다: {}", num);
    }
    
    match absent_number {
        Some(num) => println!("숫자: {}", num),
        None => println!("숫자가 없습니다."),
    }
    
    // Option을 반환하는 함수 예제
    let result = divide(10.0, 2.0);
    match result {
        Some(value) => println!("결과: {}", value),
        None => println!("0으로 나눌 수 없습니다."),
    }
}

fn divide(numerator: f64, denominator: f64) -> Option<f64> {
    if denominator != 0.0 {
        Some(numerator / denominator)
    } else {
        None
    }
}
```   
  
결과: 
```
숫자가 있습니다: 5
숫자가 없습니다.
결과: 5
```
  
### Option의 유용한 메서드들

```rust
fn main() {
    let x = Some(2);
    let y: Option<i32> = None;
    
    // unwrap_or: None이면 기본값 사용
    println!("x 또는 0: {}", x.unwrap_or(0));
    println!("y 또는 0: {}", y.unwrap_or(0));
    
    // map: Option 안의 값을 변환
    let doubled = x.map(|val| val * 2);
    println!("x * 2: {:?}", doubled);  // Some(4)
    
    // and_then: Option을 반환하는 함수와 연결
    let result = x.and_then(|val| {
        if val > 0 {
            Some(val * val)
        } else {
            None
        }
    });
    println!("x의 제곱: {:?}", result);  // Some(4)
    
    // 여러 Option 값들 처리
    let a = Some(5);
    let b = Some(10);
    let c = None;
    
    match (a, b) {
        (Some(x), Some(y)) => println!("a + b = {}", x + y),
        _ => println!("값 중 하나가 None입니다."),
    }
}
```

### Result 타입

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    // Result를 반환하는 함수 사용
    let greeting_file_result = File::open("hello.txt");
    
    match greeting_file_result {
        Ok(file) => println!("파일을 열었습니다: {:?}", file),
        Err(error) => match error.kind() {
            ErrorKind::NotFound => {
                println!("파일을 찾을 수 없습니다: {:?}", error)
            }
            other_error => {
                println!("다른 에러가 발생했습니다: {:?}", other_error)
            }
        }
    }
    
    // Result를 반환하는 사용자 정의 함수
    let result = parse_number("42");
    match result {
        Ok(num) => println!("파싱된 숫자: {}", num),
        Err(msg) => println!("에러: {}", msg),
    }
    
    let result2 = parse_number("abc");
    match result2 {
        Ok(num) => println!("파싱된 숫자: {}", num),
        Err(msg) => println!("에러: {}", msg),
    }
}

fn parse_number(s: &str) -> Result<i32, String> {
    match s.parse() {
        Ok(num) => Ok(num),
        Err(_) => Err(format!("'{}' is not a valid number", s)),
    }
}
```

### Result의 유용한 메서드들

```rust
fn main() {
    let good_result: Result<i32, &str> = Ok(10);
    let bad_result: Result<i32, &str> = Err("에러 발생");
    
    // unwrap_or: Err이면 기본값 사용
    println!("good_result 또는 0: {}", good_result.unwrap_or(0));
    println!("bad_result 또는 0: {}", bad_result.unwrap_or(0));
    
    // map: Ok 값을 변환
    let doubled = good_result.map(|x| x * 2);
    println!("doubled: {:?}", doubled);  // Ok(20)
    
    // map_err: Err 값을 변환
    let converted_error = bad_result.map_err(|e| format!("변환된 에러: {}", e));
    println!("converted_error: {:?}", converted_error);
    
    // and_then: Result를 반환하는 함수와 연결
    let result = good_result.and_then(|x| {
        if x > 5 {
            Ok(x * x)
        } else {
            Err("너무 작은 값")
        }
    });
    println!("result: {:?}", result);  // Ok(100)
}
```
  
이 코드는 러스트(Rust)의 **`Result` 열거형**을 다루는 다양한 메서드를 보여준다.

`Result`는 성공(`Ok`) 또는 실패(`Err`)할 수 있는 연산의 결과를 나타내는 타입이다.

  
#### `Result` 변수 초기화

```rust
let good_result: Result<i32, &str> = Ok(10);
let bad_result: Result<i32, &str> = Err("에러 발생");
```

  - `good_result`는 `10`이라는 성공 값을 담은 `Ok` 배리언트(variant)다.
  - `bad_result`는 `"에러 발생"`이라는 실패 메시지를 담은 `Err` 배리언트다.


#### `unwrap_or` 메서드

```rust
println!("good_result 또는 0: {}", good_result.unwrap_or(0));
println!("bad_result 또는 0: {}", bad_result.unwrap_or(0));
```

  - `unwrap_or`는 `Result`가 `Ok`이면 안의 값을 꺼내고, `Err`이면 인자로 전달된 기본값을 반환한다.
  - 따라서 `good_result`에서는 `10`이 나오고, `bad_result`에서는 기본값 `0`이 나온다.


#### `map`과 `map_err` 메서드

```rust
let doubled = good_result.map(|x| x * 2);
let converted_error = bad_result.map_err(|e| format!("변환된 에러: {}", e));
```

  - `map`은 `Result`가 `Ok`일 경우에만 안의 값을 받아 연산을 수행하고 새로운 `Ok`로 감싸서 반환한다.
  - `map_err`는 `Result`가 `Err`일 경우에만 안의 에러 값을 받아 연산을 수행하고 새로운 `Err`로 감싸서 반환한다.
  
  
#### `and_then` 메서드

```rust
let result = good_result.and_then(|x| {
    if x > 5 {
        Ok(x * x)
    } else {
        Err("너무 작은 값")
    }
});
```

  - `and_then`은 `map`과 유사하지만, 연산의 결과로 또 다른 `Result`를 반환하는 함수를 연결할 때 사용한다.
  - 이 메서드는 `Ok`일 때만 인자로 받은 함수를 실행한다.
  - `good_result`는 `Ok(10)`이고 `10`은 `5`보다 크므로, `Ok(10 * 10)` 즉 `Ok(100)`이 최종 결과가 된다.
  - 이처럼 `and_then`은 여러 개의 실패 가능한 연산을 연쇄적으로 수행할 때 매우 유용하다.
  
</br>    
   

## 실습: 간단한 학생 성적 관리 시스템
이제 배운 내용을 종합해서 학생 성적 관리 시스템을 만들어보자:

```rust
use std::collections::HashMap;
use std::io;

// 성적을 나타내는 열거형
#[derive(Debug, Clone, PartialEq)]
enum Grade {
    A,
    B,
    C,
    D,
    F,
}

impl Grade {
    // 점수로부터 성적 계산
    fn from_score(score: f64) -> Grade {
        match score {
            90.0..=100.0 => Grade::A,
            80.0..=89.9 => Grade::B,
            70.0..=79.9 => Grade::C,
            60.0..=69.9 => Grade::D,
            _ => Grade::F,
        }
    }
    
    // 성적을 점수로 변환 (GPA 계산용)
    fn to_points(&self) -> f64 {
        match self {
            Grade::A => 4.0,
            Grade::B => 3.0,
            Grade::C => 2.0,
            Grade::D => 1.0,
            Grade::F => 0.0,
        }
    }
}

// 과목 정보
#[derive(Debug, Clone)]
struct Subject {
    name: String,
    credit: u32,
    score: f64,
}

impl Subject {
    fn new(name: String, credit: u32, score: f64) -> Result<Subject, String> {
        if score < 0.0 || score > 100.0 {
            return Err("점수는 0-100 사이여야 합니다.".to_string());
        }
        if credit == 0 {
            return Err("학점은 0보다 커야 합니다.".to_string());
        }
        
        Ok(Subject { name, credit, score })
    }
    
    fn get_grade(&self) -> Grade {
        Grade::from_score(self.score)
    }
}

// 학생 정보
#[derive(Debug)]
struct Student {
    id: String,
    name: String,
    subjects: HashMap<String, Subject>,
}

impl Student {
    fn new(id: String, name: String) -> Student {
        Student {
            id,
            name,
            subjects: HashMap::new(),
        }
    }
    
    // 과목 추가
    fn add_subject(&mut self, subject: Subject) -> Result<(), String> {
        if self.subjects.contains_key(&subject.name) {
            return Err("이미 등록된 과목입니다.".to_string());
        }
        
        self.subjects.insert(subject.name.clone(), subject);
        Ok(())
    }
    
    // 과목 점수 수정
    fn update_score(&mut self, subject_name: &str, new_score: f64) -> Result<(), String> {
        if new_score < 0.0 || new_score > 100.0 {
            return Err("점수는 0-100 사이여야 합니다.".to_string());
        }
        
        match self.subjects.get_mut(subject_name) {
            Some(subject) => {
                subject.score = new_score;
                Ok(())
            }
            None => Err("과목을 찾을 수 없습니다.".to_string()),
        }
    }
    
    // GPA 계산
    fn calculate_gpa(&self) -> Option<f64> {
        if self.subjects.is_empty() {
            return None;
        }
        
        let mut total_points = 0.0;
        let mut total_credits = 0;
        
        for subject in self.subjects.values() {
            total_points += subject.get_grade().to_points() * subject.credit as f64;
            total_credits += subject.credit;
        }
        
        Some(total_points / total_credits as f64)
    }
    
    // 평균 점수 계산
    fn calculate_average(&self) -> Option<f64> {
        if self.subjects.is_empty() {
            return None;
        }
        
        let total_score: f64 = self.subjects.values().map(|s| s.score).sum();
        Some(total_score / self.subjects.len() as f64)
    }
    
    // 성적표 출력
    fn print_report(&self) {
        println!("\n=== {} ({}) 성적표 ===", self.name, self.id);
        
        if self.subjects.is_empty() {
            println!("등록된 과목이 없습니다.");
            return;
        }
        
        println!("{:<15} {:<6} {:<6} {:<6}", "과목명", "학점", "점수", "성적");
        println!("{}", "-".repeat(35));
        
        for subject in self.subjects.values() {
            println!(
                "{:<15} {:<6} {:<6.1} {:<6?}",
                subject.name,
                subject.credit,
                subject.score,
                subject.get_grade()
            );
        }
        
        println!("{}", "-".repeat(35));
        
        if let Some(avg) = self.calculate_average() {
            println!("평균 점수: {:.2}", avg);
        }
        
        if let Some(gpa) = self.calculate_gpa() {
            println!("GPA: {:.2}", gpa);
        }
    }
}

// 성적 관리 시스템
struct GradeManager {
    students: HashMap<String, Student>,
}

impl GradeManager {
    fn new() -> GradeManager {
        GradeManager {
            students: HashMap::new(),
        }
    }
    
    fn add_student(&mut self, id: String, name: String) -> Result<(), String> {
        if self.students.contains_key(&id) {
            return Err("이미 등록된 학생입니다.".to_string());
        }
        
        self.students.insert(id.clone(), Student::new(id, name));
        Ok(())
    }
    
    fn add_subject_to_student(
        &mut self,
        student_id: &str,
        subject_name: String,
        credit: u32,
        score: f64,
    ) -> Result<(), String> {
        let student = self.students.get_mut(student_id)
            .ok_or("학생을 찾을 수 없습니다.")?;
        
        let subject = Subject::new(subject_name, credit, score)?;
        student.add_subject(subject)?;
        
        Ok(())
    }
    
    fn get_student(&self, id: &str) -> Option<&Student> {
        self.students.get(id)
    }
    
    fn list_students(&self) {
        if self.students.is_empty() {
            println!("등록된 학생이 없습니다.");
            return;
        }
        
        println!("\n등록된 학생 목록:");
        for (id, student) in &self.students {
            println!("ID: {}, 이름: {}, 과목 수: {}", 
                     id, student.name, student.subjects.len());
        }
    }
}

fn main() {
    let mut manager = GradeManager::new();
    
    loop {
        println!("\n=== 학생 성적 관리 시스템 ===");
        println!("1. 학생 등록");
        println!("2. 과목 성적 추가");
        println!("3. 학생 목록 보기");
        println!("4. 성적표 보기");
        println!("5. 종료");
        
        let choice = get_input("선택하세요: ");
        
        match choice.trim() {
            "1" => register_student(&mut manager),
            "2" => add_subject(&mut manager),
            "3" => manager.list_students(),
            "4" => show_report(&manager),
            "5" => {
                println!("프로그램을 종료합니다.");
                break;
            }
            _ => println!("잘못된 선택입니다."),
        }
    }
}

fn get_input(prompt: &str) -> String {
    println!("{}", prompt);
    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("입력 실패");
    input
}

fn register_student(manager: &mut GradeManager) {
    let id = get_input("학생 ID: ").trim().to_string();
    let name = get_input("학생 이름: ").trim().to_string();
    
    match manager.add_student(id, name) {
        Ok(()) => println!("학생이 등록되었습니다."),
        Err(e) => println!("에러: {}", e),
    }
}

fn add_subject(manager: &mut GradeManager) {
    let student_id = get_input("학생 ID: ").trim().to_string();
    let subject_name = get_input("과목명: ").trim().to_string();
    
    let credit: u32 = match get_input("학점: ").trim().parse() {
        Ok(c) => c,
        Err(_) => {
            println!("올바른 학점을 입력하세요.");
            return;
        }
    };
    
    let score: f64 = match get_input("점수: ").trim().parse() {
        Ok(s) => s,
        Err(_) => {
            println!("올바른 점수를 입력하세요.");
            return;
        }
    };
    
    match manager.add_subject_to_student(&student_id, subject_name, credit, score) {
        Ok(()) => println!("과목이 추가되었습니다."),
        Err(e) => println!("에러: {}", e),
    }
}

fn show_report(manager: &GradeManager) {
    let student_id = get_input("학생 ID: ").trim().to_string();
    
    match manager.get_student(&student_id) {
        Some(student) => student.print_report(),
        None => println!("학생을 찾을 수 없습니다."),
    }
}
```

### 프로그램 실행 방법

```bash
cargo new grade_manager
cd grade_manager
# 위 코드를 src/main.rs에 복사
cargo run
```

### 실행 예시

```
=== 학생 성적 관리 시스템 ===
1. 학생 등록
2. 과목 성적 추가
3. 학생 목록 보기
4. 성적표 보기
5. 종료
선택하세요: 1
학생 ID: 2021001
학생 이름: 김철수
학생이 등록되었습니다.

선택하세요: 2
학생 ID: 2021001
과목명: 수학
학점: 3
점수: 85
과목이 추가되었습니다.

선택하세요: 4
학생 ID: 2021001

=== 김철수 (2021001) 성적표 ===
과목명          학점   점수   성적
-----------------------------------
수학            3      85.0   B
-----------------------------------
평균 점수: 85.00
GPA: 3.00
```

### 프로그램에서 사용된 개념들

1. **구조체**: `Student`, `Subject`, `GradeManager`
2. **열거형**: `Grade` (패턴 매칭과 메서드 구현)
3. **Option**: GPA와 평균 계산에서 값이 없을 수 있는 경우 처리
4. **Result**: 에러 처리 (잘못된 입력, 중복 등록 등)
5. **메서드와 연관 함수**: 각 구조체에 기능 구현
6. **소유권과 빌림**: 적절한 참조 사용으로 성능 최적화

---

**이번 장 요약:**

1. **구조체**: 관련 데이터를 그룹화하고 메서드로 기능을 구현할 수 있어
2. **메서드**: `&self`, `&mut self`, `self`로 다양한 소유권 패턴 지원
3. **열거형**: C++보다 훨씬 강력하며, 데이터를 포함할 수 있어
4. **패턴 매칭**: `match`와 `if let`으로 안전한 분기 처리
5. **Option과 Result**: null 값과 에러를 안전하게 처리하는 Rust의 핵심 타입

구조체와 열거형은 Rust에서 안전하고 표현력 있는 프로그램을 작성하는 핵심 도구이다.   