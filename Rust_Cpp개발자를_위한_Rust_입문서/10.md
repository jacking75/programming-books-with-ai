# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
  
# 10장. 실전 프로젝트
이제까지 배운 Rust의 핵심 개념들을 실제 프로젝트를 통해 종합적으로 활용해보겠다. 이 장에서는 명령행 도구 제작, HTTP 서버 구현, 테스트 작성, 그리고 성능 최적화까지 실무에서 자주 마주치는 상황들을 다뤄본다.

## 10.1 명령행 도구 만들기
첫 번째 프로젝트로 파일 내용을 검색하는 간단한 명령행 도구를 만들어보겠다. C++의 `grep`과 비슷한 기능을 구현하면서 Rust의 실용적인 측면을 경험해보자.

### 프로젝트 설정

```bash
cargo new rust_grep
cd rust_grep
```

`Cargo.toml`에 필요한 의존성을 추가하자:

```toml
[package]
name = "rust_grep"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = { version = "4.0", features = ["derive"] }
```

### 기본 구조 설계
먼저 명령행 인자를 처리하는 구조체를 정의하자:

```rust
use clap::Parser;
use std::fs;
use std::error::Error;
use std::process;

#[derive(Parser)]
#[command(name = "rust_grep")]
#[command(about = "간단한 텍스트 검색 도구")]
struct Args {
    /// 검색할 패턴
    pattern: String,
    
    /// 검색할 파일 경로
    file_path: String,
    
    /// 대소문자 구분 안함
    #[arg(short, long)]
    ignore_case: bool,
    
    /// 줄 번호 표시
    #[arg(short = 'n', long)]
    line_number: bool,
}
```

### 검색 기능 구현
검색 로직을 별도 함수로 분리해보자:

```rust
pub struct SearchResult {
    pub line_number: usize,
    pub content: String,
}

pub fn search(pattern: &str, contents: &str, ignore_case: bool) -> Vec<SearchResult> {
    let pattern = if ignore_case {
        pattern.to_lowercase()
    } else {
        pattern.to_string()
    };
    
    contents
        .lines()
        .enumerate()
        .filter_map(|(index, line)| {
            let line_to_search = if ignore_case {
                line.to_lowercase()
            } else {
                line.to_string()
            };
            
            if line_to_search.contains(&pattern) {
                Some(SearchResult {
                    line_number: index + 1,
                    content: line.to_string(),
                })
            } else {
                None
            }
        })
        .collect()
}
```

### 메인 함수 구현

```rust
fn main() {
    let args = Args::parse();
    
    if let Err(e) = run(args) {
        eprintln!("오류 발생: {}", e);
        process::exit(1);
    }
}

fn run(args: Args) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(&args.file_path)?;
    
    let results = search(&args.pattern, &contents, args.ignore_case);
    
    if results.is_empty() {
        println!("'{}' 패턴을 찾을 수 없습니다.", args.pattern);
        return Ok(());
    }
    
    for result in results {
        if args.line_number {
            println!("{}: {}", result.line_number, result.content);
        } else {
            println!("{}", result.content);
        }
    }
    
    Ok(())
}
```

### 사용 예시

```bash
# 기본 검색
cargo run -- "Hello" sample.txt

# 대소문자 구분 없이 검색
cargo run -- -i "hello" sample.txt

# 줄 번호와 함께 표시
cargo run -- -n "fn" src/main.rs
```

**C++와 비교했을 때의 장점:**
- 메모리 안전성이 컴파일 타임에 보장됨
- 에러 처리가 `Result` 타입으로 명확하게 구조화됨
- 패턴 매칭과 이터레이터 체이닝으로 간결한 코드 작성 가능
  
</br>   


## 10.2 간단한 HTTP 서버 구현
두 번째 프로젝트로 기본적인 HTTP 서버를 만들어보겠다. 게임 서버 개발 경험이 있다면 네트워크 프로그래밍의 기본 개념은 익숙할 것이다.

### 프로젝트 설정

```bash
cargo new simple_http_server
cd simple_http_server
```

`Cargo.toml`:

```toml
[package]
name = "simple_http_server"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

### HTTP 요청 파싱

```rust
use std::collections::HashMap;
use std::io::prelude::*;
use std::net::{TcpListener, TcpStream};

#[derive(Debug)]
pub struct HttpRequest {
    pub method: String,
    pub path: String,
    pub headers: HashMap<String, String>,
    pub body: String,
}

impl HttpRequest {
    pub fn parse(request: &str) -> Option<HttpRequest> {
        let lines: Vec<&str> = request.split("\r\n").collect();
        
        if lines.is_empty() {
            return None;
        }
        
        // 첫 번째 줄에서 메서드와 경로 추출
        let first_line: Vec<&str> = lines[0].split_whitespace().collect();
        if first_line.len() < 2 {
            return None;
        }
        
        let method = first_line[0].to_string();
        let path = first_line[1].to_string();
        
        // 헤더 파싱
        let mut headers = HashMap::new();
        let mut body_start = 0;
        
        for (i, line) in lines.iter().enumerate().skip(1) {
            if line.is_empty() {
                body_start = i + 1;
                break;
            }
            
            if let Some((key, value)) = line.split_once(": ") {
                headers.insert(key.to_lowercase(), value.to_string());
            }
        }
        
        // 바디 추출
        let body = if body_start < lines.len() {
            lines[body_start..].join("\r\n")
        } else {
            String::new()
        };
        
        Some(HttpRequest {
            method,
            path,
            headers,
            body,
        })
    }
}
```

### HTTP 응답 구조체

```rust
#[derive(Debug)]
pub struct HttpResponse {
    pub status_code: u16,
    pub status_text: String,
    pub headers: HashMap<String, String>,
    pub body: String,
}

impl HttpResponse {
    pub fn new(status_code: u16, body: String) -> Self {
        let status_text = match status_code {
            200 => "OK",
            404 => "Not Found",
            500 => "Internal Server Error",
            _ => "Unknown",
        }.to_string();
        
        let mut headers = HashMap::new();
        headers.insert("Content-Type".to_string(), "text/html".to_string());
        headers.insert("Content-Length".to_string(), body.len().to_string());
        
        HttpResponse {
            status_code,
            status_text,
            headers,
            body,
        }
    }
    
    pub fn json(status_code: u16, json_body: &str) -> Self {
        let mut response = Self::new(status_code, json_body.to_string());
        response.headers.insert("Content-Type".to_string(), "application/json".to_string());
        response
    }
    
    pub fn to_string(&self) -> String {
        let mut response = format!(
            "HTTP/1.1 {} {}\r\n",
            self.status_code, self.status_text
        );
        
        for (key, value) in &self.headers {
            response.push_str(&format!("{}: {}\r\n", key, value));
        }
        
        response.push_str("\r\n");
        response.push_str(&self.body);
        response
    }
}
```

### 라우터 구현

```rust
use serde::{Deserialize, Serialize};

type HandlerFn = fn(&HttpRequest) -> HttpResponse;

pub struct Router {
    routes: HashMap<(String, String), HandlerFn>, // (method, path) -> handler
}

impl Router {
    pub fn new() -> Self {
        Router {
            routes: HashMap::new(),
        }
    }
    
    pub fn get(&mut self, path: &str, handler: HandlerFn) {
        self.routes.insert(("GET".to_string(), path.to_string()), handler);
    }
    
    pub fn post(&mut self, path: &str, handler: HandlerFn) {
        self.routes.insert(("POST".to_string(), path.to_string()), handler);
    }
    
    pub fn handle_request(&self, request: &HttpRequest) -> HttpResponse {
        let key = (request.method.clone(), request.path.clone());
        
        if let Some(handler) = self.routes.get(&key) {
            handler(request)
        } else {
            HttpResponse::new(404, "Page Not Found".to_string())
        }
    }
}
```

### 핸들러 함수들

```rust
#[derive(Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

fn home_handler(_request: &HttpRequest) -> HttpResponse {
    let html = r#"
    <!DOCTYPE html>
    <html>
    <head>
        <title>Rust HTTP Server</title>
    </head>
    <body>
        <h1>Rust로 만든 HTTP 서버</h1>
        <p>안녕하세요! 이것은 Rust로 만든 간단한 HTTP 서버입니다.</p>
        <a href="/api/users">사용자 API 테스트</a>
    </body>
    </html>
    "#;
    
    HttpResponse::new(200, html.to_string())
}

fn users_handler(_request: &HttpRequest) -> HttpResponse {
    let users = vec![
        User { id: 1, name: "김철수".to_string(), email: "kim@example.com".to_string() },
        User { id: 2, name: "이영희".to_string(), email: "lee@example.com".to_string() },
    ];
    
    match serde_json::to_string(&users) {
        Ok(json) => HttpResponse::json(200, &json),
        Err(_) => HttpResponse::new(500, "JSON 변환 오류".to_string()),
    }
}

fn echo_handler(request: &HttpRequest) -> HttpResponse {
    let response_body = format!("받은 요청:\nMethod: {}\nPath: {}\nBody: {}", 
        request.method, request.path, request.body);
    HttpResponse::new(200, response_body)
}
```

### 서버 메인 루프

```rust
fn main() {
    let mut router = Router::new();
    router.get("/", home_handler);
    router.get("/api/users", users_handler);
    router.post("/echo", echo_handler);
    
    let listener = TcpListener::bind("127.0.0.1:8080")
        .expect("서버 바인딩 실패");
        
    println!("서버가 http://127.0.0.1:8080 에서 실행 중입니다...");
    
    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                handle_connection(stream, &router);
            }
            Err(e) => {
                eprintln!("연결 오류: {}", e);
            }
        }
    }
}

fn handle_connection(mut stream: TcpStream, router: &Router) {
    let mut buffer = [0; 1024];
    
    match stream.read(&mut buffer) {
        Ok(_) => {
            let request_str = String::from_utf8_lossy(&buffer);
            
            if let Some(request) = HttpRequest::parse(&request_str) {
                let response = router.handle_request(&request);
                
                if let Err(e) = stream.write_all(response.to_string().as_bytes()) {
                    eprintln!("응답 전송 실패: {}", e);
                }
            }
        }
        Err(e) => {
            eprintln!("요청 읽기 실패: {}", e);
        }
    }
}
```

### 테스트 방법

```bash
# 서버 실행
cargo run

# 다른 터미널에서 테스트
curl http://localhost:8080
curl http://localhost:8080/api/users
curl -X POST -d "Hello World" http://localhost:8080/echo
```
  
</br>  
  

## 10.3 테스트 작성하기
Rust는 테스트 작성이 매우 용이하다. 앞서 만든 코드들에 대한 단위 테스트와 통합 테스트를 작성해보자.

### 단위 테스트
먼저 grep 프로젝트의 검색 함수에 대한 테스트를 작성해보자:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_search_case_sensitive() {
        let pattern = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        let results = search(pattern, contents, false);
        assert_eq!(results.len(), 1);
        assert_eq!(results[0].content, "safe, fast, productive.");
        assert_eq!(results[0].line_number, 2);
    }

    #[test]
    fn test_search_case_insensitive() {
        let pattern = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        let results = search(pattern, contents, true);
        assert_eq!(results.len(), 2);
        assert_eq!(results[0].content, "Rust:");
        assert_eq!(results[1].content, "Trust me.");
    }

    #[test]
    fn test_search_no_results() {
        let pattern = "monomorphization";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        let results = search(pattern, contents, false);
        assert_eq!(results.len(), 0);
    }
}
```

### HTTP 요청 파싱 테스트

```rust
#[cfg(test)]
mod http_tests {
    use super::*;

    #[test]
    fn test_parse_get_request() {
        let request_str = "GET /hello HTTP/1.1\r\nHost: localhost:8080\r\nUser-Agent: curl/7.64.1\r\n\r\n";
        
        let request = HttpRequest::parse(request_str).unwrap();
        
        assert_eq!(request.method, "GET");
        assert_eq!(request.path, "/hello");
        assert_eq!(request.headers.get("host"), Some(&"localhost:8080".to_string()));
        assert_eq!(request.body, "");
    }

    #[test]
    fn test_parse_post_request() {
        let request_str = "POST /api/users HTTP/1.1\r\nContent-Type: application/json\r\nContent-Length: 26\r\n\r\n{\"name\": \"test\", \"age\": 25}";
        
        let request = HttpRequest::parse(request_str).unwrap();
        
        assert_eq!(request.method, "POST");
        assert_eq!(request.path, "/api/users");
        assert_eq!(request.body, "{\"name\": \"test\", \"age\": 25}");
    }

    #[test]
    fn test_http_response_formatting() {
        let response = HttpResponse::new(200, "Hello World".to_string());
        let response_string = response.to_string();
        
        assert!(response_string.contains("HTTP/1.1 200 OK"));
        assert!(response_string.contains("Content-Length: 11"));
        assert!(response_string.contains("Hello World"));
    }
}
```

### 벤치마크 테스트
성능이 중요한 부분에 대해서는 벤치마크 테스트도 작성할 수 있다:

```rust
// Cargo.toml에 추가
// [dev-dependencies]
// criterion = "0.4"

#[cfg(test)]
mod benches {
    use super::*;
    
    #[bench]
    fn bench_search_large_text(b: &mut test::Bencher) {
        let pattern = "test";
        let contents = "test content ".repeat(1000);
        
        b.iter(|| {
            search(pattern, &contents, false)
        });
    }
}
```

### 통합 테스트
`tests/` 디렉터리에 통합 테스트를 작성해보자:

```rust
// tests/integration_test.rs
use rust_grep::{search, SearchResult};

#[test]
fn test_search_integration() {
    let pattern = "hello";
    let contents = "Hello World\nhello rust\nHELLO WORLD";
    
    // 대소문자 구분
    let results = search(pattern, contents, false);
    assert_eq!(results.len(), 1);
    
    // 대소문자 구분 안함
    let results = search(pattern, contents, true);
    assert_eq!(results.len(), 3);
}
```

### 테스트 실행

```bash
# 모든 테스트 실행
cargo test

# 특정 테스트만 실행
cargo test test_search_case_sensitive

# 테스트 출력 표시
cargo test -- --nocapture

# 벤치마크 실행 (nightly 필요)
cargo bench
```
   
</br>     
  
  
## 10.4 성능 최적화 팁
게임 서버 개발에서 성능은 매우 중요하다. Rust에서 자주 사용되는 성능 최적화 기법들을 알아보자.

### 메모리 할당 최적화
**String vs &str 선택**

```rust
// 비효율적: 불필요한 할당
fn process_bad(input: String) -> String {
    let trimmed = input.trim().to_string(); // 불필요한 할당
    format!("Processing: {}", trimmed)      // 또 다른 할당
}

// 효율적: 참조 활용
fn process_good(input: &str) -> String {
    let trimmed = input.trim(); // 참조만 생성
    format!("Processing: {}", trimmed)
}
```

**Vec 용량 미리 할당**

```rust
// 비효율적: 동적으로 확장
fn create_vec_bad() -> Vec<i32> {
    let mut vec = Vec::new();
    for i in 0..1000 {
        vec.push(i); // 여러 번 재할당 발생
    }
    vec
}

// 효율적: 미리 용량 할당
fn create_vec_good() -> Vec<i32> {
    let mut vec = Vec::with_capacity(1000);
    for i in 0..1000 {
        vec.push(i); // 재할당 없음
    }
    vec
}
```

### 이터레이터 최적화

```rust
// 효율적인 이터레이터 체이닝
fn process_numbers(numbers: &[i32]) -> Vec<i32> {
    numbers
        .iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .collect() // 한 번의 할당으로 완료
}

// 조건부 처리 최적화
fn find_first_match(items: &[String], pattern: &str) -> Option<String> {
    items
        .iter()
        .find(|item| item.contains(pattern))
        .map(|s| s.clone()) // 필요한 경우만 클론
}
```

### 제로 코스트 추상화 활용

```rust
// 제네릭을 활용한 컴파일 타임 최적화
fn sum_generic<I>(iter: I) -> i32 
where
    I: Iterator<Item = i32>
{
    iter.fold(0, |acc, x| acc + x) // 컴파일 타임에 인라이닝됨
}

// 트레이트 객체 대신 제네릭 사용
trait Processor {
    fn process(&self, data: &[u8]) -> Vec<u8>;
}

// 느림: 동적 디스패치
fn process_dynamic(processor: &dyn Processor, data: &[u8]) -> Vec<u8> {
    processor.process(data)
}

// 빠름: 정적 디스패치
fn process_static<P: Processor>(processor: &P, data: &[u8]) -> Vec<u8> {
    processor.process(data)
}
```

### 프로파일링과 최적화

**Cargo.toml 프로파일 설정**

```toml
[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"

[profile.dev]
opt-level = 0
debug = true
```

**성능 측정 코드**

```rust
use std::time::Instant;

fn benchmark_function<F, R>(name: &str, f: F) -> R
where
    F: FnOnce() -> R,
{
    let start = Instant::now();
    let result = f();
    let duration = start.elapsed();
    println!("{}: {:?}", name, duration);
    result
}

fn main() {
    let data = (0..1_000_000).collect::<Vec<i32>>();
    
    benchmark_function("Sum with fold", || {
        data.iter().fold(0, |acc, &x| acc + x)
    });
    
    benchmark_function("Sum with iterator", || {
        data.iter().sum::<i32>()
    });
}
```

### 메모리 사용량 최적화

```rust
// Box를 사용한 힙 할당 최적화
enum Message {
    Small(u8),
    Large(Box<LargeData>), // 큰 데이터는 힙에 할당
}

struct LargeData {
    data: [u8; 1024],
}

// Cow (Clone on Write) 활용
use std::borrow::Cow;

fn process_text(input: Cow<str>) -> Cow<str> {
    if input.contains("special") {
        Cow::Owned(input.replace("special", "modified"))
    } else {
        input // 수정 없으면 원본 사용
    }
}
```

### HTTP 서버 성능 개선
앞서 만든 HTTP 서버를 더 효율적으로 만들어보자:

```rust
use std::thread;
use std::sync::{Arc, Mutex};
use std::sync::mpsc;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Job>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);
        
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        
        let mut workers = Vec::with_capacity(size);
        
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }
        
        ThreadPool { workers, sender }
    }
    
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();
            job();
        });
        
        Worker { id, thread }
    }
}

// 서버에 스레드 풀 적용
fn main() {
    let pool = ThreadPool::new(4);
    let listener = TcpListener::bind("127.0.0.1:8080").unwrap();
    
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        let router = Arc::new(create_router());
        
        pool.execute(move || {
            handle_connection(stream, &router);
        });
    }
}
```

이렇게 Rust의 실전 프로젝트를 통해 명령행 도구 제작, HTTP 서버 구현, 테스트 작성, 그리고 성능 최적화까지 다뤄보았다. 

**핵심 포인트:**
- 에러 처리는 `Result` 타입으로 명확하게 구조화
- 소유권과 borrowing을 활용한 메모리 안전성 확보
- 이터레이터와 함수형 프로그래밍 스타일로 간결한 코드 작성
- 제로 코스트 추상화를 통한 성능 최적화
- 컴파일 타임 최적화로 런타임 오버헤드 최소화

C++에서 수동으로 관리해야 했던 메모리 관리와 에러 처리가 Rust에서는 타입 시스템의 도움으로 안전하고 효율적으로 처리됨을 경험할 수 있었을 것이다.   
