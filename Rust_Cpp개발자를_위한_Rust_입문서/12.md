# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
  
# 부록 - 참조 카운팅과 스마트 포인터
Rust의 소유권 시스템은 강력하지만, 때로는 여러 곳에서 동일한 데이터를 공유해야 하는 상황이 발생한다. 이럴 때 사용하는 것이 참조 카운팅 기반의 스마트 포인터들이다. 이번 장에서는 `Rc`, `Arc`, `RefCell`, `Weak`에 대해 자세히 알아보겠다.

## 1. std::rc::Rc (Reference Counted)

### 개념 설명
`Rc<T>`는 Reference Counted의 약자로, 단일 스레드 환경에서 여러 소유자가 같은 데이터를 공유할 수 있게 해주는 스마트 포인터다. `Rc`는 내부적으로 참조 카운트를 유지하며, 카운트가 0이 되면 자동으로 메모리를 해제한다.

**주요 특징:**
- 단일 스레드 환경에서만 사용 가능하다
- 불변 참조만 제공한다
- 참조 카운트를 통해 메모리를 자동 관리한다
- `clone()`을 호출해도 데이터를 복사하지 않고 참조 카운트만 증가시킨다

### 기본 사용법

```rust
use std::rc::Rc;

fn main() {
    // Rc로 데이터 생성
    let data = Rc::new(String::from("Hello, Rust!"));
    
    // 참조 카운트 확인
    println!("참조 카운트: {}", Rc::strong_count(&data));  // 1
    
    // clone으로 새로운 참조 생성
    let data2 = Rc::clone(&data);
    println!("참조 카운트: {}", Rc::strong_count(&data));  // 2
    
    {
        let data3 = Rc::clone(&data);
        println!("참조 카운트: {}", Rc::strong_count(&data));  // 3
    } // data3가 스코프를 벗어나면서 카운트 감소
    
    println!("참조 카운트: {}", Rc::strong_count(&data));  // 2
}
```

### 실용적인 예제: 그래프 구조

```rust
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    neighbors: Vec<Rc<Node>>,
}

fn main() {
    // 노드들 생성
    let node1 = Rc::new(Node {
        value: 1,
        neighbors: vec![],
    });
    
    let node2 = Rc::new(Node {
        value: 2,
        neighbors: vec![],
    });
    
    // node3는 node1과 node2를 모두 참조
    let node3 = Rc::new(Node {
        value: 3,
        neighbors: vec![Rc::clone(&node1), Rc::clone(&node2)],
    });
    
    println!("Node 1 참조 카운트: {}", Rc::strong_count(&node1));  // 2
    println!("Node 2 참조 카운트: {}", Rc::strong_count(&node2));  // 2
    println!("Node 3의 이웃들:");
    for neighbor in &node3.neighbors {
        println!("  - 값: {}", neighbor.value);
    }
}
```  
  
</br>  
  
  
## 2. RefCell<T>

### 개념 설명
`RefCell<T>`는 내부 가변성(interior mutability) 패턴을 구현한 타입이다. 컴파일 타임이 아닌 런타임에 빌림 규칙을 검사한다. 이를 통해 불변 참조를 가진 상태에서도 내부 데이터를 변경할 수 있다.

**주요 특징:**
- 단일 스레드 환경에서만 사용 가능하다
- 빌림 규칙을 런타임에 검사한다
- `borrow()`로 불변 참조, `borrow_mut()`로 가변 참조를 얻는다
- 빌림 규칙 위반 시 패닉이 발생한다

### 기본 사용법

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);
    
    // 불변 빌림
    {
        let borrowed = data.borrow();
        println!("값: {}", *borrowed);
    } // borrowed가 스코프를 벗어나면서 빌림 해제
    
    // 가변 빌림
    {
        let mut borrowed_mut = data.borrow_mut();
        *borrowed_mut += 10;
        println!("변경된 값: {}", *borrowed_mut);
    }
    
    // 다시 불변 빌림
    println!("최종 값: {}", *data.borrow());  // 15
}
```

### 런타임 빌림 규칙 검사

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(vec![1, 2, 3]);
    
    // 여러 개의 불변 빌림은 가능
    let borrow1 = data.borrow();
    let borrow2 = data.borrow();
    println!("불변 빌림 1: {:?}", *borrow1);
    println!("불변 빌림 2: {:?}", *borrow2);
    
    drop(borrow1);
    drop(borrow2);
    
    // 가변 빌림은 하나만 가능
    let mut borrow_mut = data.borrow_mut();
    borrow_mut.push(4);
    println!("가변 빌림: {:?}", *borrow_mut);
    
    // 아래 코드는 패닉 발생!
    // let borrow3 = data.borrow(); // 가변 빌림이 활성화된 상태에서 불변 빌림 시도
}
```
  
</br>  
  
  
## 3. Rc<RefCell<T>> 조합
`Rc`와 `RefCell`을 조합하면 여러 소유자가 데이터를 공유하면서도 변경할 수 있게 된다.

### 실용적인 예제: 공유 가능한 가변 리스트

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct SharedList {
    items: Rc<RefCell<Vec<String>>>,
}

impl SharedList {
    fn new() -> Self {
        SharedList {
            items: Rc::new(RefCell::new(Vec::new())),
        }
    }
    
    fn clone_list(&self) -> Self {
        SharedList {
            items: Rc::clone(&self.items),
        }
    }
    
    fn add(&self, item: String) {
        self.items.borrow_mut().push(item);
    }
    
    fn print(&self) {
        println!("리스트: {:?}", *self.items.borrow());
    }
}

fn main() {
    let list1 = SharedList::new();
    let list2 = list1.clone_list();
    
    list1.add(String::from("첫 번째 항목"));
    list2.add(String::from("두 번째 항목"));
    
    // 두 리스트가 같은 데이터를 가리킴
    list1.print();  // ["첫 번째 항목", "두 번째 항목"]
    list2.print();  // ["첫 번째 항목", "두 번째 항목"]
    
    println!("참조 카운트: {}", Rc::strong_count(&list1.items));  // 2
}
```

### 실용적인 예제: 트리 구조

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct TreeNode {
    value: i32,
    children: RefCell<Vec<Rc<TreeNode>>>,
}

impl TreeNode {
    fn new(value: i32) -> Rc<Self> {
        Rc::new(TreeNode {
            value,
            children: RefCell::new(Vec::new()),
        })
    }
    
    fn add_child(self_rc: &Rc<Self>, child: Rc<TreeNode>) {
        self_rc.children.borrow_mut().push(child);
    }
    
    fn print_tree(node: &Rc<TreeNode>, depth: usize) {
        println!("{}{}", "  ".repeat(depth), node.value);
        for child in node.children.borrow().iter() {
            TreeNode::print_tree(child, depth + 1);
        }
    }
}

fn main() {
    let root = TreeNode::new(1);
    let child1 = TreeNode::new(2);
    let child2 = TreeNode::new(3);
    let grandchild = TreeNode::new(4);
    
    TreeNode::add_child(&child1, grandchild);
    TreeNode::add_child(&root, child1);
    TreeNode::add_child(&root, child2);
    
    TreeNode::print_tree(&root, 0);
    // 출력:
    // 1
    //   2
    //     4
    //   3
}
```
   
</br>  
  
  
## 4. std::rc::Weak

### 개념 설명
`Weak<T>`는 순환 참조를 방지하기 위한 약한 참조다. `Rc`는 강한 참조로서 참조 카운트를 증가시키지만, `Weak`는 약한 참조로서 참조 카운트에 영향을 주지 않는다. 이를 통해 메모리 누수를 일으킬 수 있는 순환 참조 문제를 해결한다.

**주요 특징:**
- 참조 카운트를 증가시키지 않는다
- 데이터가 이미 해제되었을 수 있으므로 `upgrade()` 메서드로 `Option<Rc<T>>`를 얻어야 한다
- 순환 참조를 방지하는 데 사용된다

### 기본 사용법

```rust
use std::rc::{Rc, Weak};

fn main() {
    let strong = Rc::new(String::from("강한 참조"));
    
    // 약한 참조 생성
    let weak: Weak<String> = Rc::downgrade(&strong);
    
    println!("강한 참조 카운트: {}", Rc::strong_count(&strong));  // 1
    println!("약한 참조 카운트: {}", Rc::weak_count(&strong));    // 1
    
    // 약한 참조를 강한 참조로 업그레이드
    match weak.upgrade() {
        Some(rc) => println!("데이터: {}", rc),
        None => println!("데이터가 이미 해제됨"),
    }
    
    drop(strong);  // 강한 참조 해제
    
    // 데이터가 해제된 후 업그레이드 시도
    match weak.upgrade() {
        Some(rc) => println!("데이터: {}", rc),
        None => println!("데이터가 이미 해제됨"),  // 이 경로 실행
    }
}
```

### 실용적인 예제: 부모-자식 관계

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Parent {
    name: String,
    children: RefCell<Vec<Rc<Child>>>,
}

#[derive(Debug)]
struct Child {
    name: String,
    parent: RefCell<Weak<Parent>>,  // 순환 참조 방지를 위해 Weak 사용
}

impl Parent {
    fn new(name: &str) -> Rc<Self> {
        Rc::new(Parent {
            name: name.to_string(),
            children: RefCell::new(Vec::new()),
        })
    }
    
    fn add_child(parent: &Rc<Parent>, name: &str) -> Rc<Child> {
        let child = Rc::new(Child {
            name: name.to_string(),
            parent: RefCell::new(Rc::downgrade(parent)),
        });
        
        parent.children.borrow_mut().push(Rc::clone(&child));
        child
    }
}

impl Child {
    fn get_parent_name(&self) -> Option<String> {
        self.parent.borrow()
            .upgrade()
            .map(|p| p.name.clone())
    }
}

fn main() {
    let parent = Parent::new("부모");
    
    println!("초기 강한 참조 카운트: {}", Rc::strong_count(&parent));  // 1
    
    let child1 = Parent::add_child(&parent, "자식1");
    let child2 = Parent::add_child(&parent, "자식2");
    
    println!("자식 추가 후 강한 참조 카운트: {}", Rc::strong_count(&parent));  // 1 (Weak는 카운트 증가 안 함)
    println!("약한 참조 카운트: {}", Rc::weak_count(&parent));  // 2
    
    println!("자식1의 부모: {:?}", child1.get_parent_name());
    println!("자식2의 부모: {:?}", child2.get_parent_name());
    
    drop(parent);  // 부모 해제
    
    // 부모가 해제된 후
    println!("부모 해제 후 자식1의 부모: {:?}", child1.get_parent_name());  // None
}
```

### 순환 참조 문제 시연

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct NodeBad {
    value: i32,
    next: RefCell<Option<Rc<NodeBad>>>,
}

fn circular_reference_problem() {
    let node1 = Rc::new(NodeBad {
        value: 1,
        next: RefCell::new(None),
    });
    
    let node2 = Rc::new(NodeBad {
        value: 2,
        next: RefCell::new(Some(Rc::clone(&node1))),
    });
    
    // 순환 참조 생성
    *node1.next.borrow_mut() = Some(Rc::clone(&node2));
    
    println!("Node1 참조 카운트: {}", Rc::strong_count(&node1));  // 2
    println!("Node2 참조 카운트: {}", Rc::strong_count(&node2));  // 2
    
    // 이 함수가 끝나도 node1과 node2는 서로를 참조하므로 메모리 누수 발생!
}

// Weak를 사용한 해결책
use std::rc::Weak;

#[derive(Debug)]
struct NodeGood {
    value: i32,
    next: RefCell<Option<Weak<NodeGood>>>,  // Weak 사용
}

fn circular_reference_solved() {
    let node1 = Rc::new(NodeGood {
        value: 1,
        next: RefCell::new(None),
    });
    
    let node2 = Rc::new(NodeGood {
        value: 2,
        next: RefCell::new(Some(Rc::downgrade(&node1))),
    });
    
    *node1.next.borrow_mut() = Some(Rc::downgrade(&node2));
    
    println!("Node1 강한 참조 카운트: {}", Rc::strong_count(&node1));  // 1
    println!("Node2 강한 참조 카운트: {}", Rc::strong_count(&node2));  // 1
    
    // 함수가 끝나면 정상적으로 메모리 해제됨
}

fn main() {
    println!("=== 순환 참조 문제 ===");
    circular_reference_problem();
    
    println!("\n=== Weak를 사용한 해결 ===");
    circular_reference_solved();
}
```
  
</br>  
  
  
## 5. std::sync::Arc (Atomic Reference Counted)

### 개념 설명
`Arc<T>`는 Atomic Reference Counted의 약자로, 멀티스레드 환경에서 안전하게 사용할 수 있는 참조 카운팅 포인터다. `Rc`와 동일한 기능을 제공하지만, 원자적(atomic) 연산을 사용하여 스레드 안전성을 보장한다.

**주요 특징:**
- 멀티스레드 환경에서 안전하게 사용 가능하다
- `Send`와 `Sync` 트레이트를 구현한다
- `Rc`보다 약간의 성능 오버헤드가 있다
- 불변 참조만 제공한다

### 기본 사용법

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(vec![1, 2, 3, 4, 5]);
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            println!("스레드 {}: {:?}", i, data_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("참조 카운트: {}", Arc::strong_count(&data));  // 1
}
```

### 실용적인 예제: 병렬 처리

```rust
use std::sync::Arc;
use std::thread;

fn parallel_sum() {
    let numbers = Arc::new(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    let mut handles = vec![];
    let num_threads = 4;
    
    for i in 0..num_threads {
        let numbers_clone = Arc::clone(&numbers);
        let handle = thread::spawn(move || {
            let chunk_size = numbers_clone.len() / num_threads;
            let start = i * chunk_size;
            let end = if i == num_threads - 1 {
                numbers_clone.len()
            } else {
                (i + 1) * chunk_size
            };
            
            let sum: i32 = numbers_clone[start..end].iter().sum();
            println!("스레드 {} 부분 합: {}", i, sum);
            sum
        });
        handles.push(handle);
    }
    
    let total: i32 = handles.into_iter()
        .map(|h| h.join().unwrap())
        .sum();
    
    println!("전체 합: {}", total);
}

fn main() {
    parallel_sum();
}
```
  
</br>  
  
  
## 6. Arc<Mutex<T>> 및 Arc<RwLock<T>> 조합
멀티스레드 환경에서 데이터를 공유하면서 변경하려면 `Arc`와 동기화 프리미티브를 함께 사용해야 한다.

### Mutex를 사용한 예제

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("최종 카운터 값: {}", *counter.lock().unwrap());  // 10
}
```

### RwLock을 사용한 예제

```rust
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

#[derive(Debug)]
struct SharedData {
    value: i32,
}

fn main() {
    let data = Arc::new(RwLock::new(SharedData { value: 0 }));
    let mut handles = vec![];
    
    // 읽기 스레드들
    for i in 0..3 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            for _ in 0..5 {
                let data_read = data_clone.read().unwrap();
                println!("읽기 스레드 {}: {}", i, data_read.value);
                thread::sleep(Duration::from_millis(10));
            }
        });
        handles.push(handle);
    }
    
    // 쓰기 스레드
    let data_clone = Arc::clone(&data);
    let handle = thread::spawn(move || {
        for i in 1..=5 {
            let mut data_write = data_clone.write().unwrap();
            data_write.value = i;
            println!("쓰기 스레드: {} 저장", i);
            thread::sleep(Duration::from_millis(50));
        }
    });
    handles.push(handle);
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 실용적인 예제: 공유 캐시

```rust
use std::sync::{Arc, RwLock};
use std::collections::HashMap;
use std::thread;

struct Cache {
    data: Arc<RwLock<HashMap<String, String>>>,
}

impl Cache {
    fn new() -> Self {
        Cache {
            data: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    fn clone_cache(&self) -> Self {
        Cache {
            data: Arc::clone(&self.data),
        }
    }
    
    fn get(&self, key: &str) -> Option<String> {
        let cache = self.data.read().unwrap();
        cache.get(key).cloned()
    }
    
    fn set(&self, key: String, value: String) {
        let mut cache = self.data.write().unwrap();
        cache.insert(key, value);
    }
}

fn main() {
    let cache = Cache::new();
    let mut handles = vec![];
    
    // 쓰기 스레드
    for i in 0..3 {
        let cache_clone = cache.clone_cache();
        let handle = thread::spawn(move || {
            cache_clone.set(
                format!("key{}", i),
                format!("value{}", i)
            );
            println!("스레드 {}가 데이터 저장", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    // 읽기 스레드들
    let mut handles = vec![];
    for i in 0..3 {
        let cache_clone = cache.clone_cache();
        let handle = thread::spawn(move || {
            if let Some(value) = cache_clone.get(&format!("key{}", i)) {
                println!("스레드 {}가 데이터 읽음: {}", i, value);
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```
  
</br>  
  
  
## 7. 각 타입을 언제 사용해야 하는가

### Rc<T> 사용 시기
- 단일 스레드 환경에서 여러 소유자가 같은 데이터를 읽기만 할 때
- 그래프, 트리 등의 복잡한 데이터 구조를 구현할 때
- 데이터를 복사하는 비용이 큰 경우

```rust
use std::rc::Rc;

// 예: 설정 데이터를 여러 컴포넌트가 공유
struct Config {
    max_connections: usize,
    timeout: u64,
}

struct DatabaseConnection {
    config: Rc<Config>,
}

struct HttpServer {
    config: Rc<Config>,
}

fn main() {
    let config = Rc::new(Config {
        max_connections: 100,
        timeout: 30,
    });
    
    let db = DatabaseConnection {
        config: Rc::clone(&config),
    };
    
    let server = HttpServer {
        config: Rc::clone(&config),
    };
}
```

### Arc<T> 사용 시기
- 멀티스레드 환경에서 여러 스레드가 같은 데이터를 읽기만 할 때
- 스레드 간에 불변 데이터를 공유할 때

```rust
use std::sync::Arc;
use std::thread;

// 예: 설정을 여러 스레드에서 사용
fn main() {
    let config = Arc::new(vec!["설정1", "설정2", "설정3"]);
    let mut handles = vec![];
    
    for i in 0..3 {
        let config_clone = Arc::clone(&config);
        let handle = thread::spawn(move || {
            println!("스레드 {}: {:?}", i, config_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### RefCell<T> 사용 시기
- 런타임에 빌림 규칙을 확인해야 할 때
- 불변 참조로 받았지만 내부적으로 변경이 필요할 때
- 단일 스레드 환경에서만 사용

```rust
use std::cell::RefCell;

// 예: 캐시 기능이 있는 계산기
struct Calculator {
    cache: RefCell<Option<i32>>,
}

impl Calculator {
    fn new() -> Self {
        Calculator {
            cache: RefCell::new(None),
        }
    }
    
    fn calculate(&self, a: i32, b: i32) -> i32 {
        // 불변 참조(&self)이지만 내부적으로 캐시 변경 가능
        let result = a + b;
        *self.cache.borrow_mut() = Some(result);
        result
    }
    
    fn get_last_result(&self) -> Option<i32> {
        *self.cache.borrow()
    }
}

fn main() {
    let calc = Calculator::new();
    calc.calculate(5, 3);
    println!("마지막 결과: {:?}", calc.get_last_result());
}
```

### Rc<RefCell<T>> 사용 시기
- 단일 스레드에서 여러 소유자가 같은 데이터를 공유하면서 변경할 때
- 그래프 구조에서 노드를 변경해야 할 때

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Task {
    name: String,
    completed: RefCell<bool>,
}

struct TaskManager {
    tasks: Vec<Rc<Task>>,
}

impl TaskManager {
    fn new() -> Self {
        TaskManager { tasks: vec![] }
    }
    
    fn add_task(&mut self, task: Rc<Task>) {
        self.tasks.push(task);
    }
    
    fn complete_all(&self) {
        for task in &self.tasks {
            *task.completed.borrow_mut() = true;
        }
    }
}

fn main() {
    let task1 = Rc::new(Task {
        name: "작업1".to_string(),
        completed: RefCell::new(false),
    });
    
    let task2 = Rc::new(Task {
        name: "작업2".to_string(),
        completed: RefCell::new(false),
    });
    
    let mut manager1 = TaskManager::new();
    manager1.add_task(Rc::clone(&task1));
    manager1.add_task(Rc::clone(&task2));
    
    let mut manager2 = TaskManager::new();
    manager2.add_task(Rc::clone(&task1));
    
    manager1.complete_all();
    
    println!("Task1 완료: {}", *task1.completed.borrow());  // true
    println!("Task2 완료: {}", *task2.completed.borrow());  // true
}
```

### Arc<Mutex<T>> 사용 시기
- 멀티스레드 환경에서 여러 스레드가 데이터를 변경할 때
- 쓰기 작업이 많을 때

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// 예: 공유 로그 시스템
struct Logger {
    logs: Arc<Mutex<Vec<String>>>,
}

impl Logger {
    fn new() -> Self {
        Logger {
            logs: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    fn clone_logger(&self) -> Self {
        Logger {
            logs: Arc::clone(&self.logs),
        }
    }
    
    fn log(&self, message: String) {
        let mut logs = self.logs.lock().unwrap();
        logs.push(message);
    }
    
    fn print_all(&self) {
        let logs = self.logs.lock().unwrap();
        for (i, log) in logs.iter().enumerate() {
            println!("{}: {}", i, log);
        }
    }
}

fn main() {
    let logger = Logger::new();
    let mut handles = vec![];
    
    for i in 0..5 {
        let logger_clone = logger.clone_logger();
        let handle = thread::spawn(move || {
            logger_clone.log(format!("스레드 {}의 메시지", i));
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    logger.print_all();
}
```

### Arc<RwLock<T>> 사용 시기
- 멀티스레드 환경에서 읽기가 쓰기보다 훨씬 많을 때
- 여러 스레드가 동시에 읽기를 할 수 있어야 할 때

```rust
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

// 예: 통계 수집 시스템
struct Statistics {
    data: Arc<RwLock<Vec<i32>>>,
}

impl Statistics {
    fn new() -> Self {
        Statistics {
            data: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    fn clone_stats(&self) -> Self {
        Statistics {
            data: Arc::clone(&self.data),
        }
    }
    
    fn add_value(&self, value: i32) {
        let mut data = self.data.write().unwrap();
        data.push(value);
    }
    
    fn get_average(&self) -> f64 {
        let data = self.data.read().unwrap();
        if data.is_empty() {
            return 0.0;
        }
        let sum: i32 = data.iter().sum();
        sum as f64 / data.len() as f64
    }
}

fn main() {
    let stats = Statistics::new();
    let mut handles = vec![];
    
    // 쓰기 스레드
    let stats_clone = stats.clone_stats();
    let handle = thread::spawn(move || {
        for i in 1..=10 {
            stats_clone.add_value(i);
            thread::sleep(Duration::from_millis(100));
        }
    });
    handles.push(handle);
    
    // 읽기 스레드들
    for i in 0..3 {
        let stats_clone = stats.clone_stats();
        let handle = thread::spawn(move || {
            for _ in 0..5 {
                let avg = stats_clone.get_average();
                println!("스레드 {} 평균: {:.2}", i, avg);
                thread::sleep(Duration::from_millis(150));
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### Weak<T> 사용 시기
- 순환 참조를 방지해야 할 때
- 부모-자식 관계에서 자식이 부모를 참조할 때
- 옵저버 패턴을 구현할 때

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

// 예: 옵저버 패턴
struct Subject {
    observers: RefCell<Vec<Weak<Observer>>>,
    state: RefCell<i32>,
}

struct Observer {
    id: i32,
}

impl Subject {
    fn new() -> Rc<Self> {
        Rc::new(Subject {
            observers: RefCell::new(Vec::new()),
            state: RefCell::new(0),
        })
    }
    
    fn attach(&self, observer: &Rc<Observer>) {
        self.observers.borrow_mut().push(Rc::downgrade(observer));
    }
    
    fn set_state(&self, state: i32) {
        *self.state.borrow_mut() = state;
        self.notify();
    }
    
    fn notify(&self) {
        // 약한 참조를 정리하면서 통지
        self.observers.borrow_mut().retain(|weak| {
            if let Some(observer) = weak.upgrade() {
                println!("옵저버 {}에게 통지: 상태 = {}", 
                         observer.id, *self.state.borrow());
                true
            } else {
                false  // 옵저버가 해제되었으면 목록에서 제거
            }
        });
    }
}

fn main() {
    let subject = Subject::new();
    
    {
        let observer1 = Rc::new(Observer { id: 1 });
        let observer2 = Rc::new(Observer { id: 2 });
        
        subject.attach(&observer1);
        subject.attach(&observer2);
        
        subject.set_state(10);
        // observer1과 observer2가 스코프를 벗어나면서 해제됨
    }
    
    // 옵저버들이 해제된 후
    subject.set_state(20);  // 통지할 옵저버가 없음
}
```
  
</br>  
  
  
## 8. 요약 및 선택 가이드

### 단일 스레드 환경

| 상황 | 사용할 타입 |
|------|------------|
| 읽기만 필요, 여러 소유자 | `Rc<T>` |
| 읽기/쓰기 필요, 여러 소유자 | `Rc<RefCell<T>>` |
| 내부 가변성 필요, 단일 소유자 | `RefCell<T>` |
| 순환 참조 방지 필요 | `Weak<T>` |

### 멀티스레드 환경

| 상황 | 사용할 타입 |
|------|------------|
| 읽기만 필요, 여러 소유자 | `Arc<T>` |
| 읽기/쓰기 필요, 쓰기 빈도 높음 | `Arc<Mutex<T>>` |
| 읽기/쓰기 필요, 읽기 빈도 높음 | `Arc<RwLock<T>>` |
  

### 성능 고려사항
1. **Rc vs Arc**: 단일 스레드라면 항상 `Rc`를 사용한다. `Arc`는 원자적 연산 때문에 오버헤드가 있다.

2. **Mutex vs RwLock**: 읽기가 쓰기보다 훨씬 많다면 `RwLock`이 유리하다. 그렇지 않으면 `Mutex`가 더 간단하고 효율적이다.

3. **RefCell**: 런타임 검사로 인한 오버헤드가 있지만, 내부 가변성이 필요한 경우에는 불가피하다.

이러한 스마트 포인터들을 적절히 조합하면 Rust의 엄격한 소유권 규칙을 지키면서도 복잡한 데이터 구조와 동시성 프로그램을 안전하게 작성할 수 있다. 각 타입의 특성과 제약사항을 이해하고, 상황에 맞게 선택하는 것이 중요하다.   