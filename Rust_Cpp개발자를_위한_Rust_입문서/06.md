# C++ 개발자를 위한 Rust 입문서

저자: 최흥배, Claude

-----      
  
# 6장. 에러 처리

## 들어가기 전에
C++에서는 예외(exception)를 통해 에러를 처리하거나, 에러 코드를 반환하는 방식을 사용한다. 하지만 예외는 성능 오버헤드가 있고, 어떤 함수가 어떤 예외를 던질지 명확하지 않을 때가 있다. Rust는 다른 접근 방식을 취한다: 에러를 타입 시스템의 일부로 만들어서 컴파일 타임에 모든 에러 케이스를 처리하도록 강제한다. 
  
Rust에는 두 가지 종류의 에러가 있다:
1. **복구 가능한 에러** (Result<T, E>): 파일을 찾을 수 없음, 네트워크 연결 실패 등  
2. **복구 불가능한 에러** (panic!): 배열 범위 초과, 논리적 오류 등  
  

## 6.1 Result<T, E>를 이용한 에러 처리

### Result 타입 기본 이해

```rust
fn main() {
    // Result는 성공(Ok) 또는 실패(Err)를 나타내는 열거형
    let success: Result<i32, &str> = Ok(42);
    let failure: Result<i32, &str> = Err("뭔가 잘못됐어요");
    
    // match로 처리
    match success {
        Ok(value) => println!("성공: {}", value),
        Err(error) => println!("에러: {}", error),
    }
    
    match failure {
        Ok(value) => println!("성공: {}", value),
        Err(error) => println!("에러: {}", error),
    }
}
```

### C++와의 에러 처리 비교

```cpp
// C++ 예외 방식
#include <iostream>
#include <fstream>
#include <stdexcept>

int divide(int a, int b) {
    if (b == 0) {
        throw std::invalid_argument("Division by zero");
    }
    return a / b;
}

int main() {
    try {
        int result = divide(10, 0);
        std::cout << "결과: " << result << std::endl;
    } catch (const std::exception& e) {
        std::cout << "에러: " << e.what() << std::endl;
    }
}
```

```rust
// Rust Result 방식
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err("0으로 나눌 수 없습니다".to_string())
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10, 0) {
        Ok(result) => println!("결과: {}", result),
        Err(error) => println!("에러: {}", error),
    }
}
```

### 실제 파일 작업 예제

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    // 파일 열기 시도
    let greeting_file_result = File::open("hello.txt");
    
    match greeting_file_result {
        Ok(file) => println!("파일을 성공적으로 열었습니다: {:?}", file),
        Err(error) => match error.kind() {
            ErrorKind::NotFound => {
                println!("파일을 찾을 수 없습니다: {}", error);
                
                // 파일 생성 시도
                match File::create("hello.txt") {
                    Ok(fc) => println!("파일을 생성했습니다: {:?}", fc),
                    Err(e) => println!("파일 생성 실패: {}", e),
                }
            }
            other_error => {
                println!("파일을 여는 중 다른 에러 발생: {:?}", other_error);
            }
        }
    }
}
```

### Result를 반환하는 함수 작성

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file(filename: &str) -> Result<String, io::Error> {
    let mut username_file = File::open(filename)?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}

fn parse_config(content: &str) -> Result<(String, u16), String> {
    let lines: Vec<&str> = content.lines().collect();
    
    if lines.len() < 2 {
        return Err("설정 파일이 불완전합니다".to_string());
    }
    
    let host = lines[0].trim().to_string();
    let port: u16 = lines[1].trim().parse()
        .map_err(|_| "포트 번호가 올바르지 않습니다".to_string())?;
    
    Ok((host, port))
}

fn main() {
    // 파일에서 사용자명 읽기
    match read_username_from_file("username.txt") {
        Ok(username) => println!("사용자명: {}", username.trim()),
        Err(error) => println!("사용자명 읽기 실패: {}", error),
    }
    
    // 설정 파싱
    let config_content = "localhost\n8080\n";
    match parse_config(config_content) {
        Ok((host, port)) => println!("서버: {}:{}", host, port),
        Err(error) => println!("설정 파싱 실패: {}", error),
    }
    
    let bad_config = "localhost\nabc\n";
    match parse_config(bad_config) {
        Ok((host, port)) => println!("서버: {}:{}", host, port),
        Err(error) => println!("설정 파싱 실패: {}", error),
    }
}
```

### Result의 유용한 메서드들

```rust
fn main() {
    let good_result: Result<i32, &str> = Ok(10);
    let bad_result: Result<i32, &str> = Err("에러 발생");
    
    // is_ok, is_err - 상태 확인
    println!("good_result가 성공인가? {}", good_result.is_ok());
    println!("bad_result가 에러인가? {}", bad_result.is_err());
    
    // unwrap_or - 에러 시 기본값 사용
    let value1 = good_result.unwrap_or(0);
    let value2 = bad_result.unwrap_or(0);
    println!("value1: {}, value2: {}", value1, value2);
    
    // unwrap_or_else - 에러 시 클로저 실행
    let value3 = bad_result.unwrap_or_else(|err| {
        println!("에러 처리 중: {}", err);
        -1
    });
    println!("value3: {}", value3);
    
    // map - 성공값 변환
    let doubled = good_result.map(|x| x * 2);
    println!("doubled: {:?}", doubled);  // Ok(20)
    
    let doubled_bad = bad_result.map(|x| x * 2);
    println!("doubled_bad: {:?}", doubled_bad);  // Err("에러 발생")
    
    // map_err - 에러값 변환
    let converted_error = bad_result.map_err(|e| format!("변환된 에러: {}", e));
    println!("converted_error: {:?}", converted_error);
    
    // and_then - 성공 시 다른 Result 반환 함수 체이닝
    let result = good_result.and_then(|x| {
        if x > 5 {
            Ok(x * x)
        } else {
            Err("값이 너무 작습니다")
        }
    });
    println!("chained result: {:?}", result);  // Ok(100)
}
```
    
#### 상태 확인 메서드
**`is_ok()`와 `is_err()`**
- `is_ok()`: Result가 Ok 값인지 boolean으로 반환한다
- `is_err()`: Result가 Err 값인지 boolean으로 반환한다
- 실제 값을 소비하지 않고 상태만 확인할 때 사용한다

```rust
let result = Ok(42);
println!("{}", result.is_ok());  // true
println!("{}", result.is_err()); // false
```

#### 값 추출 메서드
**`unwrap_or(default)`**
- Ok인 경우: 내부 값을 반환한다
- Err인 경우: 제공된 기본값을 반환한다
- 에러를 무시하고 안전하게 값을 얻고 싶을 때 사용한다

```rust
Ok(10).unwrap_or(0);    // 10 반환
Err("error").unwrap_or(0); // 0 반환
```

**`unwrap_or_else(closure)`**
- Ok인 경우: 내부 값을 반환한다
- Err인 경우: 클로저를 실행하여 그 결과값을 반환한다
- 에러 상황에서 복잡한 처리나 로깅이 필요할 때 사용한다

```rust
bad_result.unwrap_or_else(|err| {
    eprintln!("에러 발생: {}", err);  // 로깅
    -1  // 기본값 반환
});
```

#### 함수형 변환 메서드

**`map(function)`**
- Ok인 경우: 내부 값에 함수를 적용하여 새로운 Ok를 반환한다
- Err인 경우: 에러를 그대로 유지한다
- 성공값만 변환하고 싶을 때 사용한다

```rust
Ok(5).map(|x| x * 2);     // Ok(10)
Err("error").map(|x| x * 2); // Err("error") - 변환되지 않음
```

**`map_err(function)`**
- Ok인 경우: 값을 그대로 유지한다
- Err인 경우: 에러 값에 함수를 적용하여 새로운 Err를 반환한다
- 에러 타입을 변환하거나 에러 메시지를 가공할 때 사용한다

```rust
Err("simple error").map_err(|e| format!("상세: {}", e));
// Err("상세: simple error")
```

#### 체이닝 메서드

**`and_then(function)`**
- Ok인 경우: 내부 값을 다른 Result를 반환하는 함수에 전달한다
- Err인 경우: 에러를 그대로 전파한다
- Result를 반환하는 함수들을 연쇄적으로 호출할 때 사용한다 (모나드의 flatMap과 유사)

```rust
Ok(10).and_then(|x| {
    if x > 5 { Ok(x * x) }
    else { Err("값이 작음") }
});  // Ok(100)
```

이러한 메서드들은 함수형 프로그래밍 패러다임을 따라 에러 처리를 안전하고 표현력 있게 만든다. C#의 LINQ나 Go의 if err != nil 패턴보다 더 체계적인 에러 처리가 가능하다.
  
</br>    
  
  
## 6.2 unwrap, expect 메서드

### unwrap() 메서드
**기본 동작**
- `Option<T>`이나 `Result<T, E>`에서 값을 강제로 추출한다
- 성공 시: 내부 값을 반환한다
- 실패 시: 프로그램이 패닉(panic)과 함께 즉시 종료된다

```rust
let some_value = Some(42);
let none_value: Option<i32> = None;

println!("{}", some_value.unwrap()); // 42 출력
// println!("{}", none_value.unwrap()); // 패닉 발생!

let ok_result: Result<i32, &str> = Ok(10);
let err_result: Result<i32, &str> = Err("에러 발생");

println!("{}", ok_result.unwrap()); // 10 출력  
// println!("{}", err_result.unwrap()); // 패닉 발생!
```

### expect(message) 메서드
**기본 동작**
- `unwrap()`과 동일하게 값을 강제 추출한다
- 차이점: 패닉 발생 시 사용자 정의 메시지를 출력한다
- 디버깅과 에러 추적에 훨씬 유용하다

```rust
let none_value: Option<i32> = None;
let err_result: Result<i32, &str> = Err("파일을 찾을 수 없음");

// none_value.expect("값이 존재해야 함"); 
// 패닉 메시지: "값이 존재해야 함"

// err_result.expect("설정 파일 로드 실패");
// 패닉 메시지: "설정 파일 로드 실패: 파일을 찾을 수 없음"
```

### 사용 시기와 주의사항
**unwrap() 사용이 적절한 경우**
- 프로토타이핑이나 예제 코드 작성 시
- 논리적으로 절대 실패할 수 없다고 확신하는 경우
- 빠른 테스트 코드 작성 시

```rust
let numbers = vec![1, 2, 3, 4, 5];
let first = numbers.first().unwrap(); // 벡터가 비어있지 않다는 것을 안다
```

**expect() 사용이 권장되는 경우**
- 프로덕션 코드에서 불가피하게 패닉을 허용해야 할 때
- 왜 이 지점에서 값이 존재해야 하는지 문맥을 제공하고 싶을 때
- 디버깅을 위한 명확한 에러 메시지가 필요할 때

```rust
let config_file = std::fs::read_to_string("config.toml")
    .expect("설정 파일이 반드시 존재해야 함");

let parsed_number = "123".parse::<i32>()
    .expect("하드코딩된 숫자 문자열 파싱 실패");
```

### 더 나은 대안들

**안전한 패턴 매칭**
```rust
match some_option {
    Some(value) => println!("값: {}", value),
    None => println!("값이 없음"),
}
```

**안전한 값 추출**
```rust
let value = some_result.unwrap_or(default_value);
let value = some_result.unwrap_or_else(|| compute_default());
```

**에러 전파**
```rust
fn process_file() -> Result<String, std::io::Error> {
    let content = std::fs::read_to_string("file.txt")?; // ? 연산자 사용
    Ok(content)
}
```
   
- `unwrap()`은 빠른 프로토타이핑용, 프로덕션에서는 피하라
- `expect()`는 패닉이 불가피할 때 명확한 메시지와 함께 사용하라
- 가능하면 패턴 매칭이나 `unwrap_or()` 같은 안전한 대안을 사용하라
- 두 메서드 모두 프로그램을 즉시 종료시키므로 신중하게 사용해야 한다

C#의 예외 던지기나 Go의 panic()과 비슷하지만, Rust는 이런 상황을 더 명시적으로 다루도록 설계되었다.
  
  
### unwrap과 expect 기본 사용법

```rust
fn main() {
    let good_result: Result<i32, &str> = Ok(10);
    let bad_result: Result<i32, &str> = Err("뭔가 잘못됨");
    
    // unwrap - 성공하면 값 반환, 실패하면 패닉
    let value = good_result.unwrap();
    println!("언래핑된 값: {}", value);
    
    // expect - unwrap과 같지만 커스텀 에러 메시지 제공
    let value2 = Ok(20).expect("20을 얻을 수 있어야 합니다");
    println!("기대된 값: {}", value2);
    
    // 이런 코드들은 패닉을 일으킴 (실제로는 주석 처리)
    // let bad_value = bad_result.unwrap();  // 패닉!
    // let bad_value2 = bad_result.expect("이건 실패해서는 안 되는데!");  // 패닉!
}
```
  

### 안전한 unwrap 대안들

```rust
fn main() {
    let maybe_number: Option<i32> = Some(5);
    let maybe_nothing: Option<i32> = None;
    
    // unwrap 대신 사용할 수 있는 안전한 방법들
    
    // 1. if let 사용
    if let Some(num) = maybe_number {
        println!("숫자가 있습니다: {}", num);
    }
    
    // 2. match 사용
    match maybe_nothing {
        Some(num) => println!("숫자: {}", num),
        None => println!("숫자가 없습니다"),
    }
    
    // 3. unwrap_or 사용
    let number = maybe_nothing.unwrap_or(0);
    println!("숫자 (기본값 포함): {}", number);
    
    // 4. unwrap_or_else 사용
    let number2 = maybe_nothing.unwrap_or_else(|| {
        println!("기본값을 생성 중...");
        42
    });
    println!("숫자 (지연 계산된 기본값): {}", number2);
    
    // Result에서도 마찬가지
    let result: Result<i32, &str> = Err("에러");
    
    let value = result.unwrap_or_else(|error| {
        eprintln!("에러 발생: {}", error);
        -1
    });
    println!("최종 값: {}", value);
}
```
  
</br>    
  
  
## 6.3 ? 연산자 사용법
  
### ? 연산자의 기본 동작
**핵심 개념**
- `Result<T, E>`나 `Option<T>`에서 에러나 None을 자동으로 전파하는 문법 설탕이다
- 성공값이 있으면 unwrap하고, 실패하면 현재 함수에서 즉시 리턴한다
- 에러 처리 코드를 대폭 줄여서 가독성을 높인다

```rust
// ? 연산자 사용 전
fn read_file_old() -> Result<String, std::io::Error> {
    let mut file = match std::fs::File::open("test.txt") {
        Ok(file) => file,
        Err(error) => return Err(error),
    };
    
    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(error) => Err(error),
    }
}

// ? 연산자 사용 후
fn read_file_new() -> Result<String, std::io::Error> {
    let mut file = std::fs::File::open("test.txt")?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

### Result<T, E>에서의 동작

```rust
fn parse_and_multiply(s: &str) -> Result<i32, std::num::ParseIntError> {
    let num = s.parse::<i32>()?; // 파싱 실패 시 에러 즉시 반환
    Ok(num * 2)
}

fn chain_operations() -> Result<i32, Box<dyn std::error::Error>> {
    let content = std::fs::read_to_string("numbers.txt")?;
    let number = content.trim().parse::<i32>()?;
    let result = calculate_something(number)?;
    Ok(result)
}
```

### Option<T>에서의 동작

```rust
fn get_first_char(s: &str) -> Option<char> {
    let first_word = s.split_whitespace().next()?; // None이면 즉시 None 반환
    first_word.chars().next() // 첫 번째 문자 반환
}

fn chain_options() -> Option<i32> {
    let numbers = vec![1, 2, 3];
    let first = numbers.get(0)?; // 인덱스 0이 없으면 None 반환
    let doubled = Some(first * 2);
    doubled
}
```

### ? 연산자 사용 조건

**반환 타입 제약**
- 함수의 반환 타입이 `Result`, `Option` 또는 이들과 호환되는 타입이어야 한다
- `main()` 함수에서도 사용 가능하다

```rust
// main에서 Result 반환
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let content = std::fs::read_to_string("config.txt")?;
    println!("설정: {}", content);
    Ok(())
}

// 컴파일 에러 - 반환 타입이 맞지 않음
fn invalid_usage() -> i32 {
    let result = "123".parse::<i32>()?; // 에러! i32를 반환하는데 ?를 사용
    result
}
```

### 에러 타입 변환 (From trait)
**자동 변환**
```rust
use std::fs::File;
use std::io::Read;

fn read_number_from_file() -> Result<i32, Box<dyn std::error::Error>> {
    let mut file = File::open("number.txt")?; // io::Error
    let mut contents = String::new();
    file.read_to_string(&mut contents)?; // io::Error
    let number = contents.trim().parse::<i32>()?; // ParseIntError
    Ok(number) // 모든 에러가 Box<dyn Error>로 자동 변환됨
}
```

### 실제 사용 예제

**웹 API 호출 예제**
```rust
use std::error::Error;

fn fetch_user_data(user_id: u32) -> Result<String, Box<dyn Error>> {
    let url = format!("https://api.example.com/users/{}", user_id);
    let response = reqwest::blocking::get(&url)?;
    let status = response.status();
    
    if !status.is_success() {
        return Err(format!("HTTP 에러: {}", status).into());
    }
    
    let body = response.text()?;
    Ok(body)
}
```

**설정 파일 파싱 예제**
```rust
#[derive(serde::Deserialize)]
struct Config {
    host: String,
    port: u16,
}

fn load_config() -> Result<Config, Box<dyn std::error::Error>> {
    let content = std::fs::read_to_string("config.toml")?;
    let config: Config = toml::from_str(&content)?;
    Ok(config)
}
```

### ? 연산자 vs 다른 방법들

**가독성 비교**
```rust
// match 사용 (장황함)
fn with_match() -> Result<i32, ParseIntError> {
    match "42".parse::<i32>() {
        Ok(num) => match num.checked_mul(2) {
            Some(result) => Ok(result),
            None => Err(/* ... */),
        },
        Err(e) => Err(e),
    }
}

// ? 연산자 사용 (간결함)
fn with_question_mark() -> Result<i32, ParseIntError> {
    let num = "42".parse::<i32>()?;
    let result = num.checked_mul(2).ok_or(/* ... */)?;
    Ok(result)
}
```

### 핵심 정리
- `?` 연산자는 에러 처리를 간결하게 만드는 핵심 도구다
- 성공 시 값을 unwrap하고, 실패 시 조기 반환한다
- 함수 반환 타입이 `Result`나 `Option`이어야 사용할 수 있다
- `From` trait을 통해 에러 타입 변환이 자동으로 이루어진다
- Go언어의 `if err != nil { return err }` 패턴을 간결하게 만든 것과 유사하다

C#의 null 조건부 연산자(`?.`)와 비슷하지만, 더 강력하고 타입 안전하다.


### ? 연산자 체이닝
**체이닝이란**
- 여러 개의 `?` 연산자를 연속적으로 사용하는 패턴이다
- 각 단계에서 에러가 발생하면 즉시 전체 체인이 중단되고 에러가 반환된다
- 모든 단계가 성공해야만 최종 결과를 얻는다

```rust
fn simple_chain() -> Result<i32, Box<dyn std::error::Error>> {
    let result = std::fs::read_to_string("input.txt")?  // 1단계: 파일 읽기
        .trim()                                         // 2단계: 공백 제거
        .parse::<i32>()?;                              // 3단계: 숫자 파싱
    Ok(result * 2)
}
```

#### 메서드 체이닝과의 결합
**함수형 스타일 체이닝**
```rust
fn process_file_data() -> Result<Vec<i32>, Box<dyn std::error::Error>> {
    let numbers: Vec<i32> = std::fs::read_to_string("numbers.txt")?
        .lines()
        .map(|line| line.trim().parse::<i32>())
        .collect::<Result<Vec<_>, _>>()?;  // collect에서 ?로 에러 처리
    
    Ok(numbers)
}

fn advanced_chain() -> Result<String, Box<dyn std::error::Error>> {
    let result = std::fs::read_to_string("data.json")?
        .parse::<serde_json::Value>()?
        .get("users")?
        .as_array()?
        .first()?
        .get("name")?
        .as_str()?
        .to_string();
    
    Ok(result)
}
```

#### 복잡한 체이닝 패턴

**중첩된 작업 체이닝**
```rust
use std::fs::File;
use std::io::{BufRead, BufReader};

fn process_config_file() -> Result<Config, ConfigError> {
    let file = File::open("config.ini")?;
    let reader = BufReader::new(file);
    
    let config = reader
        .lines()
        .map(|line| line?)  // IO 에러 처리
        .filter(|line| !line.trim().is_empty() && !line.starts_with('#'))
        .map(|line| parse_config_line(&line)?)  // 파싱 에러 처리
        .collect::<Result<Config, _>>()?;
    
    validate_config(&config)?;  // 검증 에러 처리
    Ok(config)
}
```

**데이터베이스 작업 체이닝**
```rust
async fn create_user_with_profile(
    user_data: CreateUserRequest
) -> Result<User, DatabaseError> {
    let user = insert_user(&user_data.user)?;
    let profile = insert_profile(&user.id, &user_data.profile)?;
    let settings = create_default_settings(&user.id)?;
    
    update_user_with_profile(&user.id, &profile.id)?;
    send_welcome_email(&user.email)?;
    
    Ok(User {
        id: user.id,
        profile: Some(profile),
        settings: Some(settings),
        ..user
    })
}
```

#### Option 체이닝

**안전한 속성 접근**
```rust
#[derive(Debug)]
struct Person {
    name: String,
    address: Option<Address>,
}

#[derive(Debug)]
struct Address {
    street: String,
    city: Option<City>,
}

#[derive(Debug)]
struct City {
    name: String,
    country: String,
}

fn get_country_name(person: &Person) -> Option<String> {
    person
        .address
        .as_ref()?
        .city
        .as_ref()?
        .country
        .clone()
        .into()
}

// 더 복잡한 Option 체이닝
fn find_user_city_population(users: &[Person]) -> Option<u32> {
    users
        .iter()
        .find(|user| user.name == "John")?
        .address
        .as_ref()?
        .city
        .as_ref()?
        .get_population()  // Option<u32>를 반환한다고 가정
}
```

#### 에러 타입 변환 체이닝

**서로 다른 에러 타입들의 자동 변환**
```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
enum AppError {
    Io(std::io::Error),
    Parse(std::num::ParseIntError),
    Http(reqwest::Error),
    Custom(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(e) => write!(f, "IO 에러: {}", e),
            AppError::Parse(e) => write!(f, "파싱 에러: {}", e),
            AppError::Http(e) => write!(f, "HTTP 에러: {}", e),
            AppError::Custom(msg) => write!(f, "커스텀 에러: {}", msg),
        }
    }
}

impl Error for AppError {}

impl From<std::io::Error> for AppError {
    fn from(error: std::io::Error) -> Self {
        AppError::Io(error)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(error: std::num::ParseIntError) -> Self {
        AppError::Parse(error)
    }
}

fn complex_operation() -> Result<String, AppError> {
    let content = std::fs::read_to_string("config.txt")?;  // IO에러 자동변환
    let number = content.trim().parse::<i32>()?;           // Parse에러 자동변환
    let response = reqwest::blocking::get(&format!("https://api.com/{}", number))?; // HTTP에러 자동변환
    let result = response.text()?;
    
    Ok(result)
}
```

#### 조건부 체이닝

**조건에 따른 체이닝 분기**
```rust
fn conditional_processing(input: &str, should_validate: bool) -> Result<i32, ProcessError> {
    let cleaned = input.trim();
    
    let validated = if should_validate {
        validate_input(cleaned)?  // 검증 실패 시 에러 반환
    } else {
        cleaned
    };
    
    let parsed = validated.parse::<i32>()?;
    let processed = apply_business_logic(parsed)?;
    let result = finalize_result(processed)?;
    
    Ok(result)
}
```

#### 성능과 최적화 고려사항

**체이닝 최적화**
```rust
// 비효율적인 체이닝 (불필요한 할당)
fn inefficient_chain() -> Result<String, Error> {
    let result = read_file("input.txt")?
        .to_uppercase()  // String 복사
        .trim()         // 또 다른 할당
        .to_string();   // 또 다른 할당
    Ok(result)
}

// 효율적인 체이닝
fn efficient_chain() -> Result<String, Error> {
    let mut content = read_file("input.txt")?;
    content.make_ascii_uppercase();  // in-place 변환
    Ok(content.trim().to_string())   // 마지막에만 할당
}
```

- `?` 연산자 체이닝은 복잡한 에러 처리 로직을 간결하게 만든다
- 각 단계에서 실패하면 즉시 전체 작업이 중단된다
- `From` trait을 통해 서로 다른 에러 타입들이 자동으로 변환된다
- 함수형 프로그래밍과 잘 결합되어 가독성 높은 코드를 작성할 수 있다
- 성능을 고려해서 불필요한 중간 할당을 피하는 것이 좋다

Go언어의 반복적인 `if err != nil` 체크를 대폭 줄이면서도, C#의 null 조건부 연산자보다 훨씬 강력한 에러 처리가 가능하다.  
  
#### 실전 코드
```rust
use std::collections::HashMap;

fn parse_server_config(content: &str) -> Result<HashMap<String, String>, String> {
    let mut config = HashMap::new();
    
    for line in content.lines() {
        let parts: Vec<&str> = line.split('=').collect();
        
        if parts.len() != 2 {
            return Err(format!("잘못된 설정 라인: {}", line));
        }
        
        let key = parts[0].trim();
        let value = parts[1].trim();
        
        if key.is_empty() || value.is_empty() {
            return Err("빈 키 또는 값".to_string());
        }
        
        config.insert(key.to_string(), value.to_string());
    }
    
    Ok(config)
}

fn get_server_port(config: &HashMap<String, String>) -> Result<u16, String> {
    let port_str = config.get("port")
        .ok_or("port 설정을 찾을 수 없습니다".to_string())?;
    
    let port = port_str.parse::<u16>()
        .map_err(|_| format!("올바르지 않은 포트 번호: {}", port_str))?;
    
    if port < 1024 {
        return Err("포트 번호는 1024 이상이어야 합니다".to_string());
    }
    
    Ok(port)
}

fn setup_server(config_content: &str) -> Result<u16, String> {
    let config = parse_server_config(config_content)?;
    let port = get_server_port(&config)?;
    
    println!("서버 설정 완료. 포트: {}", port);
    Ok(port)
}

fn main() {
    let good_config = "host=localhost\nport=8080\ndebug=true";
    let bad_config1 = "host=localhost\nport=abc\ndebug=true";
    let bad_config2 = "host=localhost\nport=80\ndebug=true";
    
    match setup_server(good_config) {
        Ok(port) => println!("서버가 포트 {}에서 시작됩니다", port),
        Err(error) => println!("서버 설정 실패: {}", error),
    }
    
    match setup_server(bad_config1) {
        Ok(port) => println!("서버가 포트 {}에서 시작됩니다", port),
        Err(error) => println!("서버 설정 실패: {}", error),
    }
    
    match setup_server(bad_config2) {
        Ok(port) => println!("서버가 포트 {}에서 시작됩니다", port),
        Err(error) => println!("서버 설정 실패: {}", error),
    }
}
```

### ? 연산자와 Option

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    match get_middle_element(&numbers) {
        Some(middle) => println!("중간 요소: {}", middle),
        None => println!("중간 요소를 찾을 수 없습니다"),
    }
    
    let empty: Vec<i32> = vec![];
    match get_middle_element(&empty) {
        Some(middle) => println!("중간 요소: {}", middle),
        None => println!("중간 요소를 찾을 수 없습니다"),
    }
}

fn get_middle_element(v: &Vec<i32>) -> Option<i32> {
    let middle_index = v.len() / 2;
    v.get(middle_index).copied()
}

// 더 복잡한 예제: 중첩된 데이터 구조에서 값 추출
fn extract_nested_value(data: &HashMap<String, HashMap<String, i32>>, 
                       outer_key: &str, 
                       inner_key: &str) -> Option<i32> {
    data.get(outer_key)?.get(inner_key).copied()
}

#[allow(dead_code)]
fn example_nested_extraction() {
    use std::collections::HashMap;
    
    let mut outer_map = HashMap::new();
    let mut inner_map = HashMap::new();
    inner_map.insert("score".to_string(), 100);
    outer_map.insert("player1".to_string(), inner_map);
    
    match extract_nested_value(&outer_map, "player1", "score") {
        Some(score) => println!("플레이어1의 점수: {}", score),
        None => println!("점수를 찾을 수 없습니다"),
    }
    
    match extract_nested_value(&outer_map, "player2", "score") {
        Some(score) => println!("플레이어2의 점수: {}", score),
        None => println!("점수를 찾을 수 없습니다"),
    }
}
```

### main 함수에서 ? 연산자 사용

```rust
use std::error::Error;
use std::fs;

// main 함수도 Result를 반환할 수 있음
fn main() -> Result<(), Box<dyn Error>> {
    let content = fs::read_to_string("important_config.txt")?;
    
    println!("설정 파일 내용:");
    println!("{}", content);
    
    // 다른 처리들...
    process_config(&content)?;
    
    println!("프로그램이 성공적으로 완료되었습니다!");
    Ok(())
}

fn process_config(content: &str) -> Result<(), Box<dyn Error>> {
    if content.trim().is_empty() {
        return Err("설정 파일이 비어있습니다".into());
    }
    
    println!("설정 처리 완료");
    Ok(())
}
```
   
</br>  
  
  
## 6.4 커스텀 에러 타입 정의

### 기본 커스텀 에러 타입

```rust
use std::fmt;

// 커스텀 에러 타입 정의
#[derive(Debug)]
enum CalculationError {
    DivisionByZero,
    Overflow,
    InvalidInput(String),
}

// Display 트레이트 구현 (에러 메시지 표시용)
impl fmt::Display for CalculationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CalculationError::DivisionByZero => write!(f, "0으로 나눌 수 없습니다"),
            CalculationError::Overflow => write!(f, "계산 결과가 오버플로우되었습니다"),
            CalculationError::InvalidInput(msg) => write!(f, "잘못된 입력: {}", msg),
        }
    }
}

// Error 트레이트 구현
impl std::error::Error for CalculationError {}

// 커스텀 에러를 사용하는 함수들
fn safe_divide(a: i32, b: i32) -> Result<i32, CalculationError> {
    if b == 0 {
        return Err(CalculationError::DivisionByZero);
    }
    Ok(a / b)
}

fn safe_multiply(a: i32, b: i32) -> Result<i32, CalculationError> {
    match a.checked_mul(b) {
        Some(result) => Ok(result),
        None => Err(CalculationError::Overflow),
    }
}

fn parse_and_calculate(input: &str) -> Result<i32, CalculationError> {
    let parts: Vec<&str> = input.split_whitespace().collect();
    
    if parts.len() != 3 {
        return Err(CalculationError::InvalidInput(
            "입력 형식: <숫자1> <연산자> <숫자2>".to_string()
        ));
    }
    
    let a: i32 = parts[0].parse()
        .map_err(|_| CalculationError::InvalidInput(format!("'{}' is not a number", parts[0])))?;
    
    let b: i32 = parts[2].parse()
        .map_err(|_| CalculationError::InvalidInput(format!("'{}' is not a number", parts[2])))?;
    
    match parts[1] {
        "+" => a.checked_add(b).ok_or(CalculationError::Overflow),
        "-" => a.checked_sub(b).ok_or(CalculationError::Overflow),
        "*" => safe_multiply(a, b),
        "/" => safe_divide(a, b),
        op => Err(CalculationError::InvalidInput(format!("Unknown operator: {}", op))),
    }
}

fn main() {
    let test_inputs = [
        "10 + 5",
        "10 / 0",
        "1000000 * 1000000",
        "abc + 5",
        "10",
        "10 % 3",
    ];
    
    for input in &test_inputs {
        match parse_and_calculate(input) {
            Ok(result) => println!("{} = {}", input, result),
            Err(error) => println!("{} -> 에러: {}", input, error),
        }
    }
}
```

### 복합 에러 타입과 에러 변환

```rust
use std::fmt;
use std::io;
use std::num::ParseIntError;

// 여러 종류의 에러를 포함할 수 있는 커스텀 에러 타입
#[derive(Debug)]
enum ConfigError {
    Io(io::Error),
    Parse(ParseIntError),
    Validation(String),
}

impl fmt::Display for ConfigError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ConfigError::Io(err) => write!(f, "I/O 에러: {}", err),
            ConfigError::Parse(err) => write!(f, "파싱 에러: {}", err),
            ConfigError::Validation(msg) => write!(f, "검증 에러: {}", msg),
        }
    }
}

impl std::error::Error for ConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            ConfigError::Io(err) => Some(err),
            ConfigError::Parse(err) => Some(err),
            ConfigError::Validation(_) => None,
        }
    }
}

// From 트레이트 구현으로 자동 에러 변환 지원
impl From<io::Error> for ConfigError {
    fn from(err: io::Error) -> ConfigError {
        ConfigError::Io(err)
    }
}

impl From<ParseIntError> for ConfigError {
    fn from(err: ParseIntError) -> ConfigError {
        ConfigError::Parse(err)
    }
}

// 설정 구조체
#[derive(Debug)]
struct ServerConfig {
    host: String,
    port: u16,
    max_connections: u32,
    timeout: u64,
}

impl ServerConfig {
    fn from_string(content: &str) -> Result<ServerConfig, ConfigError> {
        let mut host = String::from("localhost");
        let mut port = 8080u16;
        let mut max_connections = 1000u32;
        let mut timeout = 30u64;
        
        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            
            let parts: Vec<&str> = line.split('=').collect();
            if parts.len() != 2 {
                return Err(ConfigError::Validation(
                    format!("잘못된 설정 라인: {}", line)
                ));
            }
            
            let key = parts[0].trim();
            let value = parts[1].trim();
            
            match key {
                "host" => host = value.to_string(),
                "port" => {
                    port = value.parse()?; // ParseIntError가 자동으로 ConfigError로 변환
                    if port < 1024 {
                        return Err(ConfigError::Validation(
                            "포트는 1024 이상이어야 합니다".to_string()
                        ));
                    }
                },
                "max_connections" => {
                    max_connections = value.parse()?;
                    if max_connections == 0 {
                        return Err(ConfigError::Validation(
                            "최대 연결 수는 1 이상이어야 합니다".to_string()
                        ));
                    }
                },
                "timeout" => {
                    timeout = value.parse()?;
                },
                _ => {
                    return Err(ConfigError::Validation(
                        format!("알 수 없는 설정 키: {}", key)
                    ));
                }
            }
        }
        
        Ok(ServerConfig {
            host,
            port,
            max_connections,
            timeout,
        })
    }
}

fn load_config_from_file(filename: &str) -> Result<ServerConfig, ConfigError> {
    let content = std::fs::read_to_string(filename)?; // io::Error가 자동으로 ConfigError로 변환
    ServerConfig::from_string(&content)
}

fn main() {
    // 올바른 설정
    let good_config = "
        host = 0.0.0.0
        port = 8080
        max_connections = 1000
        timeout = 60
    ";
    
    match ServerConfig::from_string(good_config) {
        Ok(config) => println!("설정 로드 성공: {:?}", config),
        Err(error) => {
            println!("설정 로드 실패: {}", error);
            if let Some(source) = error.source() {
                println!("원인: {}", source);
            }
        }
    }
    
    // 잘못된 설정들
    let bad_configs = [
        "port = abc",
        "port = 80",
        "max_connections = 0",
        "unknown_key = value",
        "invalid line format",
    ];
    
    for bad_config in &bad_configs {
        match ServerConfig::from_string(bad_config) {
            Ok(config) => println!("예상치 못한 성공: {:?}", config),
            Err(error) => println!("예상된 에러: {}", error),
        }
    }
    
    // 파일에서 로드 시도 (파일이 없으므로 I/O 에러 발생)
    match load_config_from_file("nonexistent.conf") {
        Ok(config) => println!("설정: {:?}", config),
        Err(error) => println!("파일 로드 에러: {}", error),
    }
}
```
  
### 에러 체인과 디버깅

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct DatabaseError {
    message: String,
    source: Option<Box<dyn Error>>,
}

impl fmt::Display for DatabaseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "데이터베이스 에러: {}", self.message)
    }
}

impl Error for DatabaseError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        self.source.as_ref().map(|e| e.as_ref())
    }
}

#[derive(Debug)]
struct ServiceError {
    operation: String,
    source: Box<dyn Error>,
}

impl fmt::Display for ServiceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "서비스 에러 ({})", self.operation)
    }
}

impl Error for ServiceError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(self.source.as_ref())
    }
}

// 에러 체인 생성 함수들
fn database_operation() -> Result<String, DatabaseError> {
    Err(DatabaseError {
        message: "연결 시간 초과".to_string(),
        source: Some(Box::new(std::io::Error::new(
            std::io::ErrorKind::TimedOut,
            "TCP connection timed out"
        ))),
    })
}

fn service_operation() -> Result<String, ServiceError> {
    database_operation().map_err(|e| ServiceError {
        operation: "사용자 데이터 조회".to_string(),
        source: Box::new(e),
    })
}

// 에러 체인을 출력하는 유틸리티 함수
fn print_error_chain(err: &dyn Error) {
    eprintln!("에러: {}", err);
    
    let mut source = err.source();
    let mut level = 1;
    
    while let Some(err) = source {
        eprintln!("  {}원인: {}", "  ".repeat(level), err);
        source = err.source();
        level += 1;
    }
}

fn main() {
    match service_operation() {
        Ok(result) => println!("성공: {}", result),
        Err(error) => print_error_chain(&error),
    }
}
```
  
</br>  
    
  
## 실습: 파일 읽기/쓰기 프로그램
이제 배운 내용을 종합해서 파일 읽기/쓰기 프로그램을 만들어보자:

```rust
use std::collections::HashMap;
use std::error::Error;
use std::fmt;
use std::fs;
use std::io::{self, Write};
use std::path::Path;

// 커스텀 에러 타입 정의
#[derive(Debug)]
enum FileManagerError {
    Io(io::Error),
    InvalidFormat(String),
    NotFound(String),
    PermissionDenied(String),
}

impl fmt::Display for FileManagerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FileManagerError::Io(err) => write!(f, "I/O 에러: {}", err),
            FileManagerError::InvalidFormat(msg) => write!(f, "형식 에러: {}", msg),
            FileManagerError::NotFound(msg) => write!(f, "찾을 수 없음: {}", msg),
            FileManagerError::PermissionDenied(msg) => write!(f, "권한 거부: {}", msg),
        }
    }
}

impl Error for FileManagerError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            FileManagerError::Io(err) => Some(err),
            _ => None,
        }
    }
}

impl From<io::Error> for FileManagerError {
    fn from(err: io::Error) -> Self {
        match err.kind() {
            io::ErrorKind::NotFound => FileManagerError::NotFound(err.to_string()),
            io::ErrorKind::PermissionDenied => FileManagerError::PermissionDenied(err.to_string()),
            _ => FileManagerError::Io(err),
        }
    }
}

// 파일 메타데이터 구조체
#[derive(Debug, Clone)]
struct FileInfo {
    name: String,
    size: u64,
    content: String,
    checksum: u32,
}

impl FileInfo {
    fn new(name: String, content: String) -> Self {
        let size = content.len() as u64;
        let checksum = Self::calculate_checksum(&content);
        
        FileInfo {
            name,
            size,
            content,
            checksum,
        }
    }
    
    fn calculate_checksum(content: &str) -> u32 {
        content.chars()
            .map(|c| c as u32)
            .fold(0, |acc, x| acc.wrapping_add(x))
    }
    
    fn verify_checksum(&self) -> bool {
        Self::calculate_checksum(&self.content) == self.checksum
    }
}

// 파일 관리자 구조체
struct FileManager {
    base_directory: String,
    files: HashMap<String, FileInfo>,
}

impl FileManager {
    fn new(base_directory: String) -> Result<Self, FileManagerError> {
        // 디렉토리가 존재하지 않으면 생성
        if !Path::new(&base_directory).exists() {
            fs::create_dir_all(&base_directory)?;
        }
        
        Ok(FileManager {
            base_directory,
            files: HashMap::new(),
        })
    }
    
    fn get_file_path(&self, filename: &str) -> String {
        format!("{}/{}", self.base_directory, filename)
    }
    
    // 파일 읽기
    fn read_file(&mut self, filename: &str) -> Result<&FileInfo, FileManagerError> {
        // 캐시에서 먼저 확인
        if let Some(file_info) = self.files.get(filename) {
            if file_info.verify_checksum() {
                return Ok(file_info);
            }
        }
        
        // 디스크에서 읽기
        let file_path = self.get_file_path(filename);
        let content = fs::read_to_string(&file_path)?;
        
        let file_info = FileInfo::new(filename.to_string(), content);
        
        // 캐시에 저장
        self.files.insert(filename.to_string(), file_info);
        
        Ok(self.files.get(filename).unwrap())
    }
    
    // 파일 쓰기
    fn write_file(&mut self, filename: &str, content: &str) -> Result<(), FileManagerError> {
        let file_path = self.get_file_path(filename);
        
        // 디렉토리 존재 확인
        if let Some(parent) = Path::new(&file_path).parent() {
            if !parent.exists() {
                fs::create_dir_all(parent)?;
            }
        }
        
        // 파일 쓰기
        fs::write(&file_path, content)?;
        
        // 캐시 업데이트
        let file_info = FileInfo::new(filename.to_string(), content.to_string());
        self.files.insert(filename.to_string(), file_info);
        
        println!("파일 '{}' 저장 완료 ({} 바이트)", filename, content.len());
        Ok(())
    }
    
    // 파일 추가 (append)
    fn append_to_file(&mut self, filename: &str, content: &str) -> Result<(), FileManagerError> {
        let file_path = self.get_file_path(filename);
        
        // 기존 내용 읽기
        let existing_content = match fs::read_to_string(&file_path) {
            Ok(content) => content,
            Err(e) if e.kind() == io::ErrorKind::NotFound => String::new(),
            Err(e) => return Err(e.into()),
        };
        
        // 새 내용 추가
        let new_content = format!("{}{}", existing_content, content);
        
        // 파일 쓰기
        self.write_file(filename, &new_content)?;
        
        println!("파일 '{}' 에 내용 추가 완료", filename);
        Ok(())
    }
    
    // 파일 삭제
    fn delete_file(&mut self, filename: &str) -> Result<(), FileManagerError> {
        let file_path = self.get_file_path(filename);
        
        // 파일이 존재하는지 확인
        if !Path::new(&file_path).exists() {
            return Err(FileManagerError::NotFound(
                format!("파일 '{}'을 찾을 수 없습니다", filename)
            ));
        }
        
        // 파일 삭제
        fs::remove_file(&file_path)?;
        
        // 캐시에서 제거
        self.files.remove(filename);
        
        println!("파일 '{}' 삭제 완료", filename);
        Ok(())
    }
    
    // 파일 목록 조회
    fn list_files(&self) -> Result<Vec<String>, FileManagerError> {
        let entries = fs::read_dir(&self.base_directory)?;
        
        let mut files = Vec::new();
        for entry in entries {
            let entry = entry?;
            if entry.file_type()?.is_file() {
                if let Some(name) = entry.file_name().to_str() {
                    files.push(name.to_string());
                }
            }
        }
        
        Ok(files)
    }
    
    // 파일 정보 조회
    fn file_info(&mut self, filename: &str) -> Result<&FileInfo, FileManagerError> {
        self.read_file(filename)
    }
    
    // 파일 복사
    fn copy_file(&mut self, source: &str, destination: &str) -> Result<(), FileManagerError> {
        let source_info = self.read_file(source)?;
        let content = source_info.content.clone();
        
        self.write_file(destination, &content)?;
        println!("파일 '{}' -> '{}' 복사 완료", source, destination);
        Ok(())
    }
    
    // 백업 생성
    fn backup_file(&mut self, filename: &str) -> Result<String, FileManagerError> {
        let backup_name = format!("{}.backup", filename);
        self.copy_file(filename, &backup_name)?;
        Ok(backup_name)
    }
    
    // 파일 내용 검색
    fn search_in_file(&mut self, filename: &str, pattern: &str) -> Result<Vec<(usize, String)>, FileManagerError> {
        let file_info = self.read_file(filename)?;
        let mut matches = Vec::new();
        
        for (line_num, line) in file_info.content.lines().enumerate() {
            if line.contains(pattern) {
                matches.push((line_num + 1, line.to_string()));
            }
        }
        
        Ok(matches)
    }
    
    // 통계 정보
    fn get_statistics(&self) -> (usize, u64) {
        let file_count = self.files.len();
        let total_size = self.files.values()
            .map(|info| info.size)
            .sum();
        
        (file_count, total_size)
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    println!("=== 파일 관리 프로그램 ===");
    
    // 파일 관리자 초기화
    let mut manager = FileManager::new("./file_manager_data".to_string())?;
    
    loop {
        println!("\n메뉴:");
        println!("1. 파일 읽기");
        println!("2. 파일 쓰기");
        println!("3. 파일에 내용 추가");
        println!("4. 파일 삭제");
        println!("5. 파일 목록");
        println!("6. 파일 정보");
        println!("7. 파일 복사");
        println!("8. 파일 백업");
        println!("9. 파일 내용 검색");
        println!("10. 통계 정보");
        println!("11. 종료");
        
        let choice = get_input("선택하세요: ")?;
        
        let result = match choice.trim() {
            "1" => handle_read_file(&mut manager),
            "2" => handle_write_file(&mut manager),
            "3" => handle_append_file(&mut manager),
            "4" => handle_delete_file(&mut manager),
            "5" => handle_list_files(&manager),
            "6" => handle_file_info(&mut manager),
            "7" => handle_copy_file(&mut manager),
            "8" => handle_backup_file(&mut manager),
            "9" => handle_search_file(&mut manager),
            "10" => handle_statistics(&manager),
            "11" => {
                println!("프로그램을 종료합니다.");
                break;
            }
            _ => {
                println!("잘못된 선택입니다.");
                continue;
            }
        };
        
        if let Err(error) = result {
            eprintln!("에러 발생: {}", error);
            
            // 에러 체인 출력
            let mut source = error.source();
            while let Some(err) = source {
                eprintln!("  원인: {}", err);
                source = err.source();
            }
        }
    }
    
    Ok(())
}

fn get_input(prompt: &str) -> Result<String, io::Error> {
    print!("{}", prompt);
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    Ok(input)
}

fn handle_read_file(manager: &mut FileManager) -> Result<(), FileManagerError> {
    let filename = get_input("읽을 파일명: ")?.trim().to_string();
    
    if filename.is_empty() {
        return Err(FileManagerError::InvalidFormat("파일명이 비어있습니다".to_string()));
    }
    
    let file_info = manager.read_file(&filename)?;
    
    println!("\n=== 파일 내용 ===");
    println!("파일명: {}", file_info.name);
    println!("크기: {} 바이트", file_info.size);
    println!("체크섬: {}", file_info.checksum);
    println!("내용:");
    println!("{}", file_info.content);
    
    Ok(())
}

fn handle_write_file(manager: &mut FileManager) -> Result<(), FileManagerError> {
    let filename = get_input("저장할 파일명: ")?.trim().to_string();
    
    if filename.is_empty() {
        return Err(FileManagerError::InvalidFormat("파일명이 비어있습니다".to_string()));
    }
    
    println!("파일 내용을 입력하세요 (끝내려면 빈 줄에 'EOF' 입력):");
    let mut content = String::new();
    
    loop {
        let line = get_input("")?.trim().to_string();
        if line == "EOF" {
            break;
        }
        content.push_str(&line);
        content.push('\n');
    }
    
    manager.write_file(&filename, &content)?;
    Ok(())
}

fn handle_append_file(manager: &mut FileManager) -> Result<(), FileManagerError> {
    let filename = get_input("내용을 추가할 파일명: ")?.trim().to_string();
    let content = get_input("추가할 내용: ")?.trim().to_string();
    
    manager.append_to_file(&filename, &format!("{}\n", content))?;
    Ok(())
}

fn handle_delete_file(manager: &mut FileManager) -> Result<(), FileManagerError> {
    let filename = get_input("삭제할 파일명: ")?.trim().to_string();
    
    // 확인 메시지
    let confirmation = get_input(&format!("정말로 '{}'을 삭제하시겠습니까? (y/N): ", filename))?
        .trim().to_lowercase();
    
    if confirmation == "y" || confirmation == "yes" {
        manager.delete_file(&filename)?;
    } else {
        println!("삭제가 취소되었습니다.");
    }
    
    Ok(())
}

fn handle_list_files(manager: &FileManager) -> Result<(), FileManagerError> {
    let files = manager.list_files()?;
    
    if files.is_empty() {
        println!("디렉토리가 비어있습니다.");
    } else {
        println!("\n파일 목록:");
        for (i, file) in files.iter().enumerate() {
            println!("{}. {}", i + 1, file);
        }
    }
    
    Ok(())
}

fn handle_file_info(manager: &mut FileManager) -> Result<(), FileManagerError> {
    let filename = get_input("정보를 확인할 파일명: ")?.trim().to_string();
    
    let file_info = manager.file_info(&filename)?;
    
    println!("\n=== 파일 정보 ===");
    println!("파일명: {}", file_info.name);
    println!("크기: {} 바이트", file_info.size);
    println!("체크섬: {}", file_info.checksum);
    println!("줄 수: {}", file_info.content.lines().count());
    println!("단어 수: {}", file_info.content.split_whitespace().count());
    println!("체크섬 유효성: {}", if file_info.verify_checksum() { "유효" } else { "무효" });
    
    Ok(())
}

fn handle_copy_file(manager: &mut FileManager) -> Result<(), FileManagerError> {
    let source = get_input("복사할 파일명: ")?.trim().to_string();
    let destination = get_input("새 파일명: ")?.trim().to_string();
    
    manager.copy_file(&source, &destination)?;
    Ok(())
}

fn handle_backup_file(manager: &mut FileManager) -> Result<(), FileManagerError> {
    let filename = get_input("백업할 파일명: ")?.trim().to_string();
    
    let backup_name = manager.backup_file(&filename)?;
    println!("백업 파일 생성: {}", backup_name);
    Ok(())
}

fn handle_search_file(manager: &mut FileManager) -> Result<(), FileManagerError> {
    let filename = get_input("검색할 파일명: ")?.trim().to_string();
    let pattern = get_input("검색할 패턴: ")?.trim().to_string();
    
    let matches = manager.search_in_file(&filename, &pattern)?;
    
    if matches.is_empty() {
        println!("'{}' 패턴을 찾을 수 없습니다.", pattern);
    } else {
        println!("\n검색 결과:");
        for (line_num, line) in matches {
            println!("{}번째 줄: {}", line_num, line);
        }
    }
    
    Ok(())
}

fn handle_statistics(manager: &FileManager) -> Result<(), FileManagerError> {
    let (file_count, total_size) = manager.get_statistics();
    
    println!("\n=== 통계 정보 ===");
    println!("캐시된 파일 수: {}", file_count);
    println!("총 크기: {} 바이트", total_size);
    
    if file_count > 0 {
        println!("평균 파일 크기: {:.1} 바이트", total_size as f64 / file_count as f64);
    }
    
    Ok(())
}
```

### 프로그램 실행 방법

```bash
cargo new file_manager
cd file_manager
# 위 코드를 src/main.rs에 복사
cargo run
```

### 실행 예시

```
=== 파일 관리 프로그램 ===

메뉴:
1. 파일 읽기
2. 파일 쓰기
3. 파일에 내용 추가
4. 파일 삭제
5. 파일 목록
6. 파일 정보
7. 파일 복사
8. 파일 백업
9. 파일 내용 검색
10. 통계 정보
11. 종료
선택하세요: 2
저장할 파일명: test.txt
파일 내용을 입력하세요 (끝내려면 빈 줄에 'EOF' 입력):
안녕하세요, Rust 세계!
이것은 테스트 파일입니다.
EOF
파일 'test.txt' 저장 완료 (51 바이트)

선택하세요: 1
읽을 파일명: test.txt

=== 파일 내용 ===
파일명: test.txt
크기: 51 바이트
체크섬: 2847
내용:
안녕하세요, Rust 세계!
이것은 테스트 파일입니다.
```

### 프로그램에서 사용된 에러 처리 개념들

1. **커스텀 에러 타입**: `FileManagerError` enum으로 다양한 에러 상황 표현
2. **에러 변환**: `From` 트레이트로 `io::Error`를 자동 변환
3. **? 연산자**: 에러 전파를 간결하게 처리
4. **Result 체이닝**: 여러 작업을 안전하게 연결
5. **에러 소스**: 원본 에러 정보 유지 및 디버깅 지원
6. **복구 가능한 에러**: 사용자에게 적절한 피드백 제공

---

**이번 장 요약:**

1. **Result<T, E>**: Rust의 에러 처리 핵심 타입으로 성공과 실패를 명시적으로 표현
2. **unwrap과 expect**: 프로토타이핑용이지만 프로덕션에서는 신중히 사용
3. **? 연산자**: 에러 전파를 간결하고 읽기 쉽게 만드는 강력한 도구
4. **커스텀 에러 타입**: 도메인별 에러를 명확하게 표현하고 처리
5. **에러 체인**: 복합적인 에러 상황을 추적하고 디버깅 지원

Rust의 에러 처리 시스템은 컴파일 타임에 모든 에러 케이스를 다루도록 강제해서, 런타임 에러를 크게 줄일 수 있어. C++의 예외 처리보다 성능 오버헤드가 적고, 더 예측 가능한 코드를 작성할 수 있다.  