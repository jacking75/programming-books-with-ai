# ASP.NET Core Web API로 게임 서버 개발
  
저자: 최흥배, Claude AI   
-----------------------    
   
# 5부: 실전 프로젝트와 배포
  
# Chapter 15. 실전 프로젝트: 수집형 RPG 서버 구현
이번 장에서는 지금까지 배운 ASP.NET Core Web API 지식을 종합해 실제 모바일 수집형 RPG 게임 서버를 구현한다. 클라이언트 없이 서버 API만 개발하고 .http 파일로 테스트하는 전체 과정을 다룬다.

## 15.1 프로젝트 아키텍처 설계

### 15.1.1 수집형 RPG 게임의 핵심 기능 정의
수집형 RPG 게임의 주요 기능은 다음과 같다:

- **계정 관리**: 회원가입, 로그인, 세션 관리
- **캐릭터 시스템**: 캐릭터 획득, 육성, 진화
- **아이템 시스템**: 장비, 소모품, 재화 관리
- **전투 시스템**: PvE 스테이지, PvP 대전
- **가챠 시스템**: 캐릭터/아이템 뽑기
- **우편 시스템**: 보상 지급, 아이템 전송
- **친구 시스템**: 친구 추가/삭제, 선물
- **랭킹 시스템**: PvP 랭킹, 레이드 랭킹

### 15.1.2 아키텍처 구성
서버 아키텍처는 다음과 같은 계층 구조로 설계한다:

```
┌────────────────────────────────────────────────┐
│                  Controllers                   │
│ (API 엔드포인트, 요청/응답 처리, 유효성 검증)       │
└─────────────────────┬──────────────────────────┘
                      │
┌─────────────────────┼──────────────────────────┐
│                  Services                      │
│ (비즈니스 로직, 트랜잭션 관리)                     │
└─────────────────────┬──────────────────────────┘
                      │
┌─────────────────────┼──────────────────────────┐
│               Repositories                     │
│ (데이터 접근 계층, MySQL/Redis 연동)              │
└────────────────────────────────────────────────┘
```

### 15.1.3 데이터베이스 설계

#### MySQL 테이블 설계
주요 데이터는 MySQL에 저장하며, 다음과 같은 테이블을 구성한다:

- `accounts`: 사용자 계정 정보
- `characters`: 획득한 캐릭터 정보
- `items`: 획득한 아이템 정보
- `stages`: 스테이지 클리어 정보
- `gacha_history`: 가챠 이력
- `mails`: 우편함
- `friends`: 친구 관계
- `pvp_records`: PvP 전적

#### Redis 사용 계획
Redis는 다음 용도로 활용한다:

- 인증 토큰 및 세션 관리
- 실시간 PvP 매칭 및 랭킹 정보
- 임시 데이터 캐싱
- 이벤트성 데이터 저장

### 15.1.4 API 설계
모든 API는 POST 메서드를 사용하고, 요청/응답 형식은 JSON으로 통일한다. 주요 API 엔드포인트는 다음과 같다:

- `/api/account`: 계정 관련 API
- `/api/character`: 캐릭터 관련 API
- `/api/item`: 아이템 관련 API
- `/api/stage`: 스테이지/전투 관련 API
- `/api/gacha`: 가챠 관련 API
- `/api/mail`: 우편 관련 API
- `/api/friend`: 친구 관련 API
- `/api/ranking`: 랭킹 관련 API
  

## 15.2 핵심 시스템 통합 구현

### 15.2.1 프로젝트 생성 및 기본 설정
먼저 새 ASP.NET Core Web API 프로젝트를 생성한다:

```bash
dotnet new webapi -n RpgGameServer
cd RpgGameServer
```

필요한 패키지를 설치한다:

```bash
dotnet add package MySqlConnector
dotnet add package SqlKata
dotnet add package SqlKata.Execution
dotnet add package CloudStructures
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
```

appsettings.json 설정:

```json
{
  "ConnectionStrings": {
    "MySqlConnection": "Server=localhost;Database=rpg_game;User=root;Password=password;",
    "RedisConnection": "localhost:6379"
  },
  "JwtSettings": {
    "Secret": "YourSuperSecretKeyForJwtTokenGenerationAndValidation",
    "ExpiryMinutes": 60,
    "Issuer": "RpgGameServer",
    "Audience": "RpgGameClient"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
```

Program.cs 설정:

```csharp
var builder = WebApplication.CreateBuilder(args);

// 컨트롤러 추가
builder.Services.AddControllers();

// MySQL 설정
builder.Services.AddSingleton(serviceProvider =>
{
    var connectionString = builder.Configuration.GetConnectionString("MySqlConnection");
    var connection = new MySqlConnection(connectionString);
    var compiler = new MySqlCompiler();
    return new QueryFactory(connection, compiler);
});

// Redis 설정
builder.Services.AddSingleton(serviceProvider =>
{
    var redisConnection = builder.Configuration.GetConnectionString("RedisConnection");
    var configuration = new RedisConfiguration("default", redisConnection);
    return new RedisConnection(configuration);
});

// 의존성 주입 설정
builder.Services.AddScoped<IAccountRepository, AccountRepository>();
builder.Services.AddScoped<IAccountService, AccountService>();
// 나머지 서비스 및 리포지토리 등록...

// JWT 인증 설정
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(
                builder.Configuration["JwtSettings:Secret"])),
            ValidateIssuer = true,
            ValidIssuer = builder.Configuration["JwtSettings:Issuer"],
            ValidateAudience = true,
            ValidAudience = builder.Configuration["JwtSettings:Audience"],
            ValidateLifetime = true
        };
    });

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

app.Run();
```

### 15.2.2 계정 관리 시스템 구현

#### 모델 클래스

```csharp
public class Account
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string PasswordHash { get; set; }
    public string Email { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastLoginAt { get; set; }
}

// 요청/응답 DTO
public class RegisterRequest
{
    public string Username { get; set; }
    public string Password { get; set; }
    public string Email { get; set; }
}

public class RegisterResponse
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
    public int AccountId { get; set; }
}

public class LoginRequest
{
    public string Username { get; set; }
    public string Password { get; set; }
}

public class LoginResponse
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
    public string AccessToken { get; set; }
    public int AccountId { get; set; }
}
```

#### 리포지토리

```csharp
public interface IAccountRepository
{
    Task<int> CreateAccountAsync(Account account);
    Task<Account> GetAccountByUsernameAsync(string username);
    Task UpdateLastLoginAsync(int accountId);
}

public class AccountRepository : IAccountRepository
{
    private readonly QueryFactory _queryFactory;

    public AccountRepository(QueryFactory queryFactory)
    {
        _queryFactory = queryFactory;
    }

    public async Task<int> CreateAccountAsync(Account account)
    {
        return await _queryFactory.Query("accounts").InsertGetIdAsync<int>(new
        {
            username = account.Username,
            password_hash = account.PasswordHash,
            email = account.Email,
            created_at = DateTime.UtcNow,
            last_login_at = DateTime.UtcNow
        });
    }

    public async Task<Account> GetAccountByUsernameAsync(string username)
    {
        var result = await _queryFactory.Query("accounts")
            .Where("username", username)
            .FirstOrDefaultAsync<dynamic>();

        if (result == null)
            return null;

        return new Account
        {
            Id = result.id,
            Username = result.username,
            PasswordHash = result.password_hash,
            Email = result.email,
            CreatedAt = result.created_at,
            LastLoginAt = result.last_login_at
        };
    }

    public async Task UpdateLastLoginAsync(int accountId)
    {
        await _queryFactory.Query("accounts")
            .Where("id", accountId)
            .UpdateAsync(new { last_login_at = DateTime.UtcNow });
    }
}
```

#### 서비스

```csharp
public interface IAccountService
{
    Task<(bool isSuccess, string errorMessage, int accountId)> RegisterAsync(string username, string password, string email);
    Task<(bool isSuccess, string errorMessage, string accessToken, int accountId)> LoginAsync(string username, string password);
}

public class AccountService : IAccountService
{
    private readonly IAccountRepository _accountRepository;
    private readonly IConfiguration _configuration;
    private readonly RedisConnection _redisConnection;

    public AccountService(IAccountRepository accountRepository, IConfiguration configuration, RedisConnection redisConnection)
    {
        _accountRepository = accountRepository;
        _configuration = configuration;
        _redisConnection = redisConnection;
    }

    public async Task<(bool isSuccess, string errorMessage, int accountId)> RegisterAsync(string username, string password, string email)
    {
        // 사용자 이름 중복 확인
        var existingAccount = await _accountRepository.GetAccountByUsernameAsync(username);
        if (existingAccount != null)
        {
            return (false, "Username already exists", 0);
        }

        // 비밀번호 해싱
        string passwordHash = BCrypt.Net.BCrypt.HashPassword(password);

        // 계정 생성
        var account = new Account
        {
            Username = username,
            PasswordHash = passwordHash,
            Email = email,
            CreatedAt = DateTime.UtcNow,
            LastLoginAt = DateTime.UtcNow
        };

        int accountId = await _accountRepository.CreateAccountAsync(account);
        return (true, null, accountId);
    }

    public async Task<(bool isSuccess, string errorMessage, string accessToken, int accountId)> LoginAsync(string username, string password)
    {
        // 사용자 확인
        var account = await _accountRepository.GetAccountByUsernameAsync(username);
        if (account == null)
        {
            return (false, "Invalid username or password", null, 0);
        }

        // 비밀번호 검증
        bool isPasswordValid = BCrypt.Net.BCrypt.Verify(password, account.PasswordHash);
        if (!isPasswordValid)
        {
            return (false, "Invalid username or password", null, 0);
        }

        // JWT 토큰 생성
        var token = GenerateJwtToken(account);

        // 로그인 시간 업데이트
        await _accountRepository.UpdateLastLoginAsync(account.Id);

        // Redis에 세션 정보 저장
        var redis = new RedisString<string>(_redisConnection, $"session:{account.Id}", TimeSpan.FromHours(1));
        await redis.SetAsync(token);

        return (true, null, token, account.Id);
    }

    private string GenerateJwtToken(Account account)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_configuration["JwtSettings:Secret"]);
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
                new Claim(ClaimTypes.NameIdentifier, account.Id.ToString()),
                new Claim(ClaimTypes.Name, account.Username)
            }),
            Expires = DateTime.UtcNow.AddMinutes(Convert.ToDouble(_configuration["JwtSettings:ExpiryMinutes"])),
            Issuer = _configuration["JwtSettings:Issuer"],
            Audience = _configuration["JwtSettings:Audience"],
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
        };

        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
}
```

#### 컨트롤러

```csharp
[ApiController]
[Route("api/account")]
public class AccountController : ControllerBase
{
    private readonly IAccountService _accountService;

    public AccountController(IAccountService accountService)
    {
        _accountService = accountService;
    }

    [HttpPost("register")]
    public async Task<RegisterResponse> Register([FromBody] RegisterRequest request)
    {
        var (isSuccess, errorMessage, accountId) = await _accountService.RegisterAsync(
            request.Username, request.Password, request.Email);

        return new RegisterResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            AccountId = accountId
        };
    }

    [HttpPost("login")]
    public async Task<LoginResponse> Login([FromBody] LoginRequest request)
    {
        var (isSuccess, errorMessage, accessToken, accountId) = await _accountService.LoginAsync(
            request.Username, request.Password);

        return new LoginResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            AccessToken = accessToken,
            AccountId = accountId
        };
    }
}
```

### 15.2.3 캐릭터 시스템 구현

#### 모델 클래스

```csharp
public class Character
{
    public int Id { get; set; }
    public int AccountId { get; set; }
    public int TemplateId { get; set; }  // 캐릭터 마스터 데이터의 ID
    public string Name { get; set; }
    public int Level { get; set; }
    public int Experience { get; set; }
    public int Stars { get; set; }       // 등급/진화 단계
    public DateTime ObtainedAt { get; set; }
}

// 마스터 데이터 (게임 내 기본 캐릭터 정보)
public class CharacterTemplate
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public string Rarity { get; set; }   // Common, Rare, Epic, Legendary
    public int BaseHp { get; set; }
    public int BaseAttack { get; set; }
    public int BaseDefense { get; set; }
    public string SkillIds { get; set; } // 콤마로 구분된 스킬 ID 목록
}

// 요청/응답 DTO
public class GetCharactersRequest
{
    public int AccountId { get; set; }
}

public class CharacterDto
{
    public int Id { get; set; }
    public int TemplateId { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public string Rarity { get; set; }
    public int Level { get; set; }
    public int Experience { get; set; }
    public int Stars { get; set; }
    public int Hp { get; set; }
    public int Attack { get; set; }
    public int Defense { get; set; }
    public DateTime ObtainedAt { get; set; }
}

public class GetCharactersResponse
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
    public List<CharacterDto> Characters { get; set; }
}

public class LevelUpCharacterRequest
{
    public int AccountId { get; set; }
    public int CharacterId { get; set; }
    public int ExperienceToAdd { get; set; }
}

public class LevelUpCharacterResponse
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
    public CharacterDto Character { get; set; }
}
```

#### 리포지토리

```csharp
public interface ICharacterRepository
{
    Task<List<Character>> GetCharactersByAccountIdAsync(int accountId);
    Task<Character> GetCharacterByIdAsync(int id);
    Task<CharacterTemplate> GetCharacterTemplateByIdAsync(int templateId);
    Task<int> CreateCharacterAsync(Character character);
    Task UpdateCharacterAsync(Character character);
    Task<List<CharacterTemplate>> GetAllCharacterTemplatesAsync();
}

public class CharacterRepository : ICharacterRepository
{
    private readonly QueryFactory _queryFactory;

    public CharacterRepository(QueryFactory queryFactory)
    {
        _queryFactory = queryFactory;
    }

    public async Task<List<Character>> GetCharactersByAccountIdAsync(int accountId)
    {
        var results = await _queryFactory.Query("characters")
            .Where("account_id", accountId)
            .GetAsync<dynamic>();

        return results.Select(r => new Character
        {
            Id = r.id,
            AccountId = r.account_id,
            TemplateId = r.template_id,
            Name = r.name,
            Level = r.level,
            Experience = r.experience,
            Stars = r.stars,
            ObtainedAt = r.obtained_at
        }).ToList();
    }

    public async Task<Character> GetCharacterByIdAsync(int id)
    {
        var result = await _queryFactory.Query("characters")
            .Where("id", id)
            .FirstOrDefaultAsync<dynamic>();

        if (result == null)
            return null;

        return new Character
        {
            Id = result.id,
            AccountId = result.account_id,
            TemplateId = result.template_id,
            Name = result.name,
            Level = result.level,
            Experience = result.experience,
            Stars = result.stars,
            ObtainedAt = result.obtained_at
        };
    }

    public async Task<CharacterTemplate> GetCharacterTemplateByIdAsync(int templateId)
    {
        var result = await _queryFactory.Query("character_templates")
            .Where("id", templateId)
            .FirstOrDefaultAsync<dynamic>();

        if (result == null)
            return null;

        return new CharacterTemplate
        {
            Id = result.id,
            Name = result.name,
            Description = result.description,
            Rarity = result.rarity,
            BaseHp = result.base_hp,
            BaseAttack = result.base_attack,
            BaseDefense = result.base_defense,
            SkillIds = result.skill_ids
        };
    }

    public async Task<int> CreateCharacterAsync(Character character)
    {
        return await _queryFactory.Query("characters").InsertGetIdAsync<int>(new
        {
            account_id = character.AccountId,
            template_id = character.TemplateId,
            name = character.Name,
            level = character.Level,
            experience = character.Experience,
            stars = character.Stars,
            obtained_at = character.ObtainedAt
        });
    }

    public async Task UpdateCharacterAsync(Character character)
    {
        await _queryFactory.Query("characters")
            .Where("id", character.Id)
            .UpdateAsync(new
            {
                name = character.Name,
                level = character.Level,
                experience = character.Experience,
                stars = character.Stars
            });
    }

    public async Task<List<CharacterTemplate>> GetAllCharacterTemplatesAsync()
    {
        var results = await _queryFactory.Query("character_templates").GetAsync<dynamic>();

        return results.Select(r => new CharacterTemplate
        {
            Id = r.id,
            Name = r.name,
            Description = r.description,
            Rarity = r.rarity,
            BaseHp = r.base_hp,
            BaseAttack = r.base_attack,
            BaseDefense = r.base_defense,
            SkillIds = r.skill_ids
        }).ToList();
    }
}
```

#### 서비스

```csharp
public interface ICharacterService
{
    Task<(bool isSuccess, string errorMessage, List<CharacterDto> characters)> GetCharactersByAccountIdAsync(int accountId);
    Task<(bool isSuccess, string errorMessage, CharacterDto character)> LevelUpCharacterAsync(int accountId, int characterId, int experienceToAdd);
    Task<(bool isSuccess, string errorMessage, CharacterDto character)> AddCharacterToAccountAsync(int accountId, int templateId);
}

public class CharacterService : ICharacterService
{
    private readonly ICharacterRepository _characterRepository;
    private readonly RedisConnection _redisConnection;

    public CharacterService(ICharacterRepository characterRepository, RedisConnection redisConnection)
    {
        _characterRepository = characterRepository;
        _redisConnection = redisConnection;
    }

    public async Task<(bool isSuccess, string errorMessage, List<CharacterDto> characters)> GetCharactersByAccountIdAsync(int accountId)
    {
        // Redis 캐시에서 캐릭터 목록 확인
        var redis = new RedisString<string>(_redisConnection, $"characters:{accountId}", TimeSpan.FromMinutes(5));
        var cachedData = await redis.GetAsync();

        List<CharacterDto> characterDtos;

        if (!string.IsNullOrEmpty(cachedData.Value))
        {
            // 캐시된 데이터가 있으면 역직렬화
            characterDtos = JsonSerializer.Deserialize<List<CharacterDto>>(cachedData.Value);
        }
        else
        {
            // DB에서 캐릭터 목록 조회
            var characters = await _characterRepository.GetCharactersByAccountIdAsync(accountId);
            characterDtos = new List<CharacterDto>();

            foreach (var character in characters)
            {
                var template = await _characterRepository.GetCharacterTemplateByIdAsync(character.TemplateId);
                characterDtos.Add(await CreateCharacterDtoAsync(character, template));
            }

            // Redis에 캐시
            await redis.SetAsync(JsonSerializer.Serialize(characterDtos));
        }

        return (true, null, characterDtos);
    }

    public async Task<(bool isSuccess, string errorMessage, CharacterDto character)> LevelUpCharacterAsync(int accountId, int characterId, int experienceToAdd)
    {
        var character = await _characterRepository.GetCharacterByIdAsync(characterId);
        if (character == null)
        {
            return (false, "Character not found", null);
        }

        if (character.AccountId != accountId)
        {
            return (false, "Character does not belong to this account", null);
        }

        // 경험치 추가 및 레벨업 로직
        character.Experience += experienceToAdd;
        
        // 간단한 레벨업 공식: 레벨 * 100 경험치 필요
        while (character.Experience >= character.Level * 100)
        {
            character.Experience -= character.Level * 100;
            character.Level++;
        }

        // 캐릭터 정보 업데이트
        await _characterRepository.UpdateCharacterAsync(character);

        // 캐릭터 템플릿 정보 조회
        var template = await _characterRepository.GetCharacterTemplateByIdAsync(character.TemplateId);

        // Redis 캐시 무효화
        var redis = new RedisString<string>(_redisConnection, $"characters:{accountId}", TimeSpan.FromMinutes(5));
        await redis.DeleteAsync();

        return (true, null, await CreateCharacterDtoAsync(character, template));
    }

    public async Task<(bool isSuccess, string errorMessage, CharacterDto character)> AddCharacterToAccountAsync(int accountId, int templateId)
    {
        // 캐릭터 템플릿 확인
        var template = await _characterRepository.GetCharacterTemplateByIdAsync(templateId);
        if (template == null)
        {
            return (false, "Character template not found", null);
        }

        // 새 캐릭터 생성
        var character = new Character
        {
            AccountId = accountId,
            TemplateId = templateId,
            Name = template.Name,
            Level = 1,
            Experience = 0,
            Stars = 1,
            ObtainedAt = DateTime.UtcNow
        };

        // DB에 저장
        character.Id = await _characterRepository.CreateCharacterAsync(character);

        // Redis 캐시 무효화
        var redis = new RedisString<string>(_redisConnection, $"characters:{accountId}", TimeSpan.FromMinutes(5));
        await redis.DeleteAsync();

        return (true, null, await CreateCharacterDtoAsync(character, template));
    }

    private async Task<CharacterDto> CreateCharacterDtoAsync(Character character, CharacterTemplate template)
    {
        // 캐릭터 스탯 계산 (레벨, 등급에 따른 보정)
        double levelMultiplier = 1.0 + (character.Level - 1) * 0.1;
        double starMultiplier = 1.0 + (character.Stars - 1) * 0.2;

        return new CharacterDto
        {
            Id = character.Id,
            TemplateId = character.TemplateId,
            Name = character.Name,
            Description = template.Description,
            Rarity = template.Rarity,
            Level = character.Level,
            Experience = character.Experience,
            Stars = character.Stars,
            Hp = (int)(template.BaseHp * levelMultiplier * starMultiplier),
            Attack = (int)(template.BaseAttack * levelMultiplier * starMultiplier),
            Defense = (int)(template.BaseDefense * levelMultiplier * starMultiplier),
            ObtainedAt = character.ObtainedAt
        };
    }
}
```

#### 컨트롤러

```csharp
[ApiController]
[Route("api/character")]
[Authorize]
public class CharacterController : ControllerBase
{
    private readonly ICharacterService _characterService;

    public CharacterController(ICharacterService characterService)
    {
        _characterService = characterService;
    }

    [HttpPost("list")]
    public async Task<GetCharactersResponse> GetCharacters([FromBody] GetCharactersRequest request)
    {
        var (isSuccess, errorMessage, characters) = await _characterService.GetCharactersByAccountIdAsync(request.AccountId);

        return new GetCharactersResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            Characters = characters
        };
    }

    [HttpPost("levelup")]
    public async Task<LevelUpCharacterResponse> LevelUpCharacter([FromBody] LevelUpCharacterRequest request)
    {
        var (isSuccess, errorMessage, character) = await _characterService.LevelUpCharacterAsync(
            request.AccountId, request.CharacterId, request.ExperienceToAdd);

        return new LevelUpCharacterResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            Character = character
        };
    }
}
```

### 15.2.4 가챠 시스템 구현

#### 모델 클래스

```csharp
public class GachaPool
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
    public int CostItemId { get; set; }
    public int CostAmount { get; set; }
}

public class GachaItem
{
    public int Id { get; set; }
    public int GachaPoolId { get; set; }
    public string ItemType { get; set; } // Character, Item 등
    public int ItemId { get; set; }
    public double Weight { get; set; } // 확률
}

public class GachaHistory
{
    public int Id { get; set; }
    public int AccountId { get; set; }
    public int GachaPoolId { get; set; }
    public string ItemType { get; set; }
    public int ItemId { get; set; }
    public DateTime PulledAt { get; set; }
}

// 요청/응답 DTO
public class DrawGachaRequest
{
    public int AccountId { get; set; }
    public int GachaPoolId { get; set; }
    public int DrawCount { get; set; } // 1 또는 10회 뽑기
}

public class GachaResultItem
{
    public string ItemType { get; set; }
    public int ItemId { get; set; }
    public string Name { get; set; }
    public string Rarity { get; set; }
    public bool IsNew { get; set; }
}

public class DrawGachaResponse
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
    public List<GachaResultItem> Results { get; set; }
}
```

#### 리포지토리

```csharp
public interface IGachaRepository
{
    Task<GachaPool> GetGachaPoolByIdAsync(int poolId);
    Task<List<GachaItem>> GetGachaItemsByPoolIdAsync(int poolId);
    Task<List<GachaHistory>> GetGachaHistoryByAccountIdAsync(int accountId);
    Task AddGachaHistoryAsync(GachaHistory history);
}

public class GachaRepository : IGachaRepository
{
    private readonly QueryFactory _queryFactory;

    public GachaRepository(QueryFactory queryFactory)
    {
        _queryFactory = queryFactory;
    }

    public async Task<GachaPool> GetGachaPoolByIdAsync(int poolId)
    {
        var result = await _queryFactory.Query("gacha_pools")
            .Where("id", poolId)
            .FirstOrDefaultAsync<dynamic>();

        if (result == null)
            return null;

        return new GachaPool
        {
            Id = result.id,
            Name = result.name,
            Description = result.description,
            StartTime = result.start_time,
            EndTime = result.end_time,
            CostItemId = result.cost_item_id,
            CostAmount = result.cost_amount
        };
    }

    public async Task<List<GachaItem>> GetGachaItemsByPoolIdAsync(int poolId)
    {
        var results = await _queryFactory.Query("gacha_items")
            .Where("gacha_pool_id", poolId)
            .GetAsync<dynamic>();

        return results.Select(r => new GachaItem
        {
            Id = r.id,
            GachaPoolId = r.gacha_pool_id,
            ItemType = r.item_type,
            ItemId = r.item_id,
            Weight = r.weight
        }).ToList();
    }

    public async Task<List<GachaHistory>> GetGachaHistoryByAccountIdAsync(int accountId)
    {
        var results = await _queryFactory.Query("gacha_history")
            .Where("account_id", accountId)
            .OrderByDesc("pulled_at")
            .GetAsync<dynamic>();

        return results.Select(r => new GachaHistory
        {
            Id = r.id,
            AccountId = r.account_id,
            GachaPoolId = r.gacha_pool_id,
            ItemType = r.item_type,
            ItemId = r.item_id,
            PulledAt = r.pulled_at
        }).ToList();
    }

    public async Task AddGachaHistoryAsync(GachaHistory history)
    {
        await _queryFactory.Query("gacha_history").InsertAsync(new
        {
            account_id = history.AccountId,
            gacha_pool_id = history.GachaPoolId,
            item_type = history.ItemType,
            item_id = history.ItemId,
            pulled_at = history.PulledAt
        });
    }
}
```

#### 서비스

```csharp
public interface IGachaService
{
    Task<(bool isSuccess, string errorMessage, List<GachaResultItem> results)> DrawGachaAsync(int accountId, int gachaPoolId, int drawCount);
}

public class GachaService : IGachaService
{
    private readonly IGachaRepository _gachaRepository;
    private readonly IItemRepository _itemRepository;
    private readonly ICharacterRepository _characterRepository;
    private readonly ICharacterService _characterService;
    private readonly IItemService _itemService;

    public GachaService(
        IGachaRepository gachaRepository,
        IItemRepository itemRepository,
        ICharacterRepository characterRepository,
        ICharacterService characterService,
        IItemService itemService)
    {
        _gachaRepository = gachaRepository;
        _itemRepository = itemRepository;
        _characterRepository = characterRepository;
        _characterService = characterService;
        _itemService = itemService;
    }

    public async Task<(bool isSuccess, string errorMessage, List<GachaResultItem> results)> DrawGachaAsync(int accountId, int gachaPoolId, int drawCount)
    {
        // 가챠 풀 정보 조회
        var gachaPool = await _gachaRepository.GetGachaPoolByIdAsync(gachaPoolId);
        if (gachaPool == null)
        {
            return (false, "Gacha pool not found", null);
        }

        // 현재 시간이 가챠 기간 내인지 확인
        var now = DateTime.UtcNow;
        if (now < gachaPool.StartTime || now > gachaPool.EndTime)
        {
            return (false, "Gacha pool is not active", null);
        }

        // 뽑기 횟수 확인 (1회 또는 10회만 허용)
        if (drawCount != 1 && drawCount != 10)
        {
            return (false, "Invalid draw count. Only 1 or 10 allowed", null);
        }

        // 비용 아이템 차감 (아이템 서비스 구현 필요)
        var consumeResult = await _itemService.ConsumeItemAsync(accountId, gachaPool.CostItemId, gachaPool.CostAmount * drawCount);
        if (!consumeResult.isSuccess)
        {
            return (false, consumeResult.errorMessage, null);
        }

        // 가챠 아이템 목록 조회
        var gachaItems = await _gachaRepository.GetGachaItemsByPoolIdAsync(gachaPoolId);
        if (gachaItems.Count == 0)
        {
            return (false, "No items in this gacha pool", null);
        }

        // 이전 가챠 내역 조회 (중복 체크용)
        var gachaHistory = await _gachaRepository.GetGachaHistoryByAccountIdAsync(accountId);
        var previousCharacters = gachaHistory
            .Where(h => h.ItemType == "Character")
            .Select(h => h.ItemId)
            .ToHashSet();

        // 확률 계산을 위한 준비
        double totalWeight = gachaItems.Sum(i => i.Weight);
        Random random = new Random();
        List<GachaResultItem> results = new List<GachaResultItem>();

        // n회 뽑기 수행
        for (int i = 0; i < drawCount; i++)
        {
            double randomValue = random.NextDouble() * totalWeight;
            double accumulatedWeight = 0;
            
            // 가중치에 따른 아이템 선택
            GachaItem selectedItem = null;
            foreach (var item in gachaItems)
            {
                accumulatedWeight += item.Weight;
                if (randomValue <= accumulatedWeight)
                {
                    selectedItem = item;
                    break;
                }
            }

            // 선택된 아이템 처리
            bool isNew = false;
            string name = "";
            string rarity = "";

            if (selectedItem.ItemType == "Character")
            {
                // 캐릭터인 경우
                var template = await _characterRepository.GetCharacterTemplateByIdAsync(selectedItem.ItemId);
                name = template.Name;
                rarity = template.Rarity;
                
                isNew = !previousCharacters.Contains(selectedItem.ItemId);
                if (isNew)
                {
                    // 새 캐릭터면 계정에 추가
                    await _characterService.AddCharacterToAccountAsync(accountId, selectedItem.ItemId);
                    previousCharacters.Add(selectedItem.ItemId);
                }
                else
                {
                    // 이미 있는 캐릭터면 아이템 지급 (예: 캐릭터 조각)
                    await _itemService.AddItemToAccountAsync(accountId, 200, 5); // 예시: 캐릭터 조각 아이템
                }
            }
            else if (selectedItem.ItemType == "Item")
            {
                // 아이템인 경우
                var itemTemplate = await _itemRepository.GetItemTemplateByIdAsync(selectedItem.ItemId);
                name = itemTemplate.Name;
                rarity = itemTemplate.Rarity;
                
                // 아이템 지급
                await _itemService.AddItemToAccountAsync(accountId, selectedItem.ItemId, 1);
            }

            // 결과 저장
            results.Add(new GachaResultItem
            {
                ItemType = selectedItem.ItemType,
                ItemId = selectedItem.ItemId,
                Name = name,
                Rarity = rarity,
                IsNew = isNew
            });

            // 가챠 내역 기록
            await _gachaRepository.AddGachaHistoryAsync(new GachaHistory
            {
                AccountId = accountId,
                GachaPoolId = gachaPoolId,
                ItemType = selectedItem.ItemType,
                ItemId = selectedItem.ItemId,
                PulledAt = DateTime.UtcNow
            });
        }

        return (true, null, results);
    }
}
```

#### 컨트롤러

```csharp
[ApiController]
[Route("api/gacha")]
[Authorize]
public class GachaController : ControllerBase
{
    private readonly IGachaService _gachaService;

    public GachaController(IGachaService gachaService)
    {
        _gachaService = gachaService;
    }

    [HttpPost("draw")]
    public async Task<DrawGachaResponse> DrawGacha([FromBody] DrawGachaRequest request)
    {
        var (isSuccess, errorMessage, results) = await _gachaService.DrawGachaAsync(
            request.AccountId, request.GachaPoolId, request.DrawCount);

        return new DrawGachaResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            Results = results
        };
    }
}
```

### 15.2.5 PvP 랭킹 시스템 구현

#### 모델 클래스

```csharp
public class PvpBattle
{
    public int Id { get; set; }
    public int AttackerAccountId { get; set; }
    public int DefenderAccountId { get; set; }
    public bool IsAttackerWin { get; set; }
    public int AttackerRatingChange { get; set; }
    public int DefenderRatingChange { get; set; }
    public DateTime BattleTime { get; set; }
}

public class PvpRating
{
    public int AccountId { get; set; }
    public int Rating { get; set; }
    public int Wins { get; set; }
    public int Losses { get; set; }
    public DateTime LastBattleTime { get; set; }
}

// 요청/응답 DTO
public class StartPvpBattleRequest
{
    public int AttackerAccountId { get; set; }
    public int DefenderAccountId { get; set; }
    public List<int> AttackerCharacterIds { get; set; }
}

public class StartPvpBattleResponse
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
    public int BattleId { get; set; }
}

public class CompletePvpBattleRequest
{
    public int BattleId { get; set; }
    public bool IsAttackerWin { get; set; }
}

public class CompletePvpBattleResponse
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
    public int AttackerRatingChange { get; set; }
    public int DefenderRatingChange { get; set; }
    public int NewAttackerRating { get; set; }
}

public class GetPvpRankingRequest
{
    public int AccountId { get; set; }
    public int Limit { get; set; } = 100;
}

public class RankingEntry
{
    public int Rank { get; set; }
    public int AccountId { get; set; }
    public string Username { get; set; }
    public int Rating { get; set; }
    public int Wins { get; set; }
    public int Losses { get; set; }
}

public class GetPvpRankingResponse
{
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
    public List<RankingEntry> Rankings { get; set; }
    public RankingEntry UserRanking { get; set; }
}
```

#### Redis 기반 랭킹 서비스

```csharp
public interface IRankingService
{
    Task<(bool isSuccess, string errorMessage, int battleId)> StartPvpBattleAsync(
        int attackerAccountId, int defenderAccountId, List<int> attackerCharacterIds);
    Task<(bool isSuccess, string errorMessage, int attackerRatingChange, int defenderRatingChange, int newAttackerRating)> 
        CompletePvpBattleAsync(int battleId, bool isAttackerWin);
    Task<(bool isSuccess, string errorMessage, List<RankingEntry> rankings, RankingEntry userRanking)> 
        GetPvpRankingAsync(int accountId, int limit);
}

public class RankingService : IRankingService
{
    private readonly RedisConnection _redisConnection;
    private readonly QueryFactory _queryFactory;
    private readonly IAccountRepository _accountRepository;

    public RankingService(RedisConnection redisConnection, QueryFactory queryFactory, IAccountRepository accountRepository)
    {
        _redisConnection = redisConnection;
        _queryFactory = queryFactory;
        _accountRepository = accountRepository;
    }

    public async Task<(bool isSuccess, string errorMessage, int battleId)> StartPvpBattleAsync(
        int attackerAccountId, int defenderAccountId, List<int> attackerCharacterIds)
    {
        // 대전 상대가 존재하는지 확인
        var defender = await _accountRepository.GetAccountByIdAsync(defenderAccountId);
        if (defender == null)
        {
            return (false, "Defender not found", 0);
        }

        // 대전 정보 생성
        var battle = new PvpBattle
        {
            AttackerAccountId = attackerAccountId,
            DefenderAccountId = defenderAccountId,
            BattleTime = DateTime.UtcNow
        };

        // DB에 대전 정보 저장
        int battleId = await _queryFactory.Query("pvp_battles").InsertGetIdAsync<int>(new
        {
            attacker_account_id = battle.AttackerAccountId,
            defender_account_id = battle.DefenderAccountId,
            battle_time = battle.BattleTime
        });

        // Redis에 대전 정보 임시 저장 (타임아웃 10분)
        var redis = new RedisString<string>(_redisConnection, $"pvp_battle:{battleId}", TimeSpan.FromMinutes(10));
        await redis.SetAsync(JsonSerializer.Serialize(new
        {
            AttackerAccountId = attackerAccountId,
            DefenderAccountId = defenderAccountId,
            AttackerCharacterIds = attackerCharacterIds,
            StartTime = DateTime.UtcNow
        }));

        return (true, null, battleId);
    }

    public async Task<(bool isSuccess, string errorMessage, int attackerRatingChange, int defenderRatingChange, int newAttackerRating)> 
        CompletePvpBattleAsync(int battleId, bool isAttackerWin)
    {
        // Redis에서 대전 정보 조회
        var redis = new RedisString<string>(_redisConnection, $"pvp_battle:{battleId}", TimeSpan.FromMinutes(10));
        var battleData = await redis.GetAsync();

        if (string.IsNullOrEmpty(battleData.Value))
        {
            return (false, "Battle not found or expired", 0, 0, 0);
        }

        var battle = JsonSerializer.Deserialize<dynamic>(battleData.Value);
        int attackerAccountId = battle.GetProperty("AttackerAccountId").GetInt32();
        int defenderAccountId = battle.GetProperty("DefenderAccountId").GetInt32();

        // 레이팅 변경 계산 (ELO 시스템)
        var attackerRating = await GetOrCreateRatingAsync(attackerAccountId);
        var defenderRating = await GetOrCreateRatingAsync(defenderAccountId);

        int attackerRatingChange;
        int defenderRatingChange;

        // 간단한 ELO 레이팅 계산
        double expectedScore = 1.0 / (1.0 + Math.Pow(10, (defenderRating.Rating - attackerRating.Rating) / 400.0));
        int k = 32; // K 상수 (변화량 스케일)

        if (isAttackerWin)
        {
            attackerRatingChange = (int)(k * (1 - expectedScore));
            defenderRatingChange = -attackerRatingChange;
            attackerRating.Wins++;
            defenderRating.Losses++;
        }
        else
        {
            attackerRatingChange = (int)(k * (0 - expectedScore));
            defenderRatingChange = -attackerRatingChange;
            attackerRating.Losses++;
            defenderRating.Wins++;
        }

        // 레이팅 업데이트
        attackerRating.Rating += attackerRatingChange;
        defenderRating.Rating += defenderRatingChange;
        attackerRating.LastBattleTime = DateTime.UtcNow;
        defenderRating.LastBattleTime = DateTime.UtcNow;

        // DB에 레이팅 정보 업데이트
        await UpdateRatingAsync(attackerRating);
        await UpdateRatingAsync(defenderRating);

        // DB에 대전 결과 업데이트
        await _queryFactory.Query("pvp_battles")
            .Where("id", battleId)
            .UpdateAsync(new
            {
                is_attacker_win = isAttackerWin,
                attacker_rating_change = attackerRatingChange,
                defender_rating_change = defenderRatingChange
            });

        // Redis 랭킹 정보 업데이트
        await UpdateRedisRankingAsync(attackerRating);
        await UpdateRedisRankingAsync(defenderRating);

        // Redis 대전 정보 삭제
        await redis.DeleteAsync();

        return (true, null, attackerRatingChange, defenderRatingChange, attackerRating.Rating);
    }

    public async Task<(bool isSuccess, string errorMessage, List<RankingEntry> rankings, RankingEntry userRanking)> 
        GetPvpRankingAsync(int accountId, int limit)
    {
        // Redis에서 랭킹 정보 조회
        var redisSortedSet = new RedisSortedSet<int>(_redisConnection, "pvp_ranking");
        var redisRankings = await redisSortedSet.RangeByRankWithScoresAsync(0, limit - 1, Order.Descending);

        List<RankingEntry> rankings = new List<RankingEntry>();
        RankingEntry userRanking = null;
        int rank = 1;

        foreach (var entry in redisRankings)
        {
            var accountInfo = await _accountRepository.GetAccountByIdAsync(entry.Member);
            if (accountInfo == null) continue;

            var ratingInfo = await GetOrCreateRatingAsync(entry.Member);
            
            var rankingEntry = new RankingEntry
            {
                Rank = rank,
                AccountId = entry.Member,
                Username = accountInfo.Username,
                Rating = (int)entry.Score,
                Wins = ratingInfo.Wins,
                Losses = ratingInfo.Losses
            };

            rankings.Add(rankingEntry);

            if (entry.Member == accountId)
            {
                userRanking = rankingEntry;
            }

            rank++;
        }

        // 사용자가 랭킹에 없는 경우, 사용자 랭킹 정보 별도 조회
        if (userRanking == null)
        {
            var userRank = await redisSortedSet.RankAsync(accountId, Order.Descending);
            if (userRank.HasValue)
            {
                var accountInfo = await _accountRepository.GetAccountByIdAsync(accountId);
                var ratingInfo = await GetOrCreateRatingAsync(accountId);
                var score = await redisSortedSet.ScoreAsync(accountId);

                userRanking = new RankingEntry
                {
                    Rank = userRank.Value + 1,
                    AccountId = accountId,
                    Username = accountInfo.Username,
                    Rating = (int)score.Value,
                    Wins = ratingInfo.Wins,
                    Losses = ratingInfo.Losses
                };
            }
        }

        return (true, null, rankings, userRanking);
    }

    private async Task<PvpRating> GetOrCreateRatingAsync(int accountId)
    {
        // DB에서 레이팅 정보 조회
        var result = await _queryFactory.Query("pvp_ratings")
            .Where("account_id", accountId)
            .FirstOrDefaultAsync<dynamic>();

        if (result == null)
        {
            // 초기 레이팅 설정 (1000점 시작)
            var newRating = new PvpRating
            {
                AccountId = accountId,
                Rating = 1000,
                Wins = 0,
                Losses = 0,
                LastBattleTime = DateTime.UtcNow
            };

            await _queryFactory.Query("pvp_ratings").InsertAsync(new
            {
                account_id = newRating.AccountId,
                rating = newRating.Rating,
                wins = newRating.Wins,
                losses = newRating.Losses,
                last_battle_time = newRating.LastBattleTime
            });

            // Redis 랭킹 정보 업데이트
            await UpdateRedisRankingAsync(newRating);

            return newRating;
        }

        return new PvpRating
        {
            AccountId = result.account_id,
            Rating = result.rating,
            Wins = result.wins,
            Losses = result.losses,
            LastBattleTime = result.last_battle_time
        };
    }

    private async Task UpdateRatingAsync(PvpRating rating)
    {
        await _queryFactory.Query("pvp_ratings")
            .Where("account_id", rating.AccountId)
            .UpdateAsync(new
            {
                rating = rating.Rating,
                wins = rating.Wins,
                losses = rating.Losses,
                last_battle_time = rating.LastBattleTime
            });
    }

    private async Task UpdateRedisRankingAsync(PvpRating rating)
    {
        var redisSortedSet = new RedisSortedSet<int>(_redisConnection, "pvp_ranking");
        await redisSortedSet.AddAsync(rating.AccountId, rating.Rating);
    }
}
```

#### 컨트롤러

```csharp
[ApiController]
[Route("api/ranking")]
[Authorize]
public class RankingController : ControllerBase
{
    private readonly IRankingService _rankingService;

    public RankingController(IRankingService rankingService)
    {
        _rankingService = rankingService;
    }

    [HttpPost("pvp/start")]
    public async Task<StartPvpBattleResponse> StartPvpBattle([FromBody] StartPvpBattleRequest request)
    {
        var (isSuccess, errorMessage, battleId) = await _rankingService.StartPvpBattleAsync(
            request.AttackerAccountId, request.DefenderAccountId, request.AttackerCharacterIds);

        return new StartPvpBattleResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            BattleId = battleId
        };
    }

    [HttpPost("pvp/complete")]
    public async Task<CompletePvpBattleResponse> CompletePvpBattle([FromBody] CompletePvpBattleRequest request)
    {
        var (isSuccess, errorMessage, attackerRatingChange, defenderRatingChange, newAttackerRating) = 
            await _rankingService.CompletePvpBattleAsync(request.BattleId, request.IsAttackerWin);

        return new CompletePvpBattleResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            AttackerRatingChange = attackerRatingChange,
            DefenderRatingChange = defenderRatingChange,
            NewAttackerRating = newAttackerRating
        };
    }

    [HttpPost("pvp/list")]
    public async Task<GetPvpRankingResponse> GetPvpRanking([FromBody] GetPvpRankingRequest request)
    {
        var (isSuccess, errorMessage, rankings, userRanking) = 
            await _rankingService.GetPvpRankingAsync(request.AccountId, request.Limit);

        return new GetPvpRankingResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            Rankings = rankings,
            UserRanking = userRanking
        };
    }
}
```
  

## 15.3 .http 파일을 이용한 종합 테스트

### 15.3.1 .http 파일이란?
.http 파일은 HTTP 요청을 텍스트 파일로 정의해 API를 쉽게 테스트할 수 있는 방법이다. Visual Studio Code에서는 REST Client 확장을 설치하면 .http 파일을 실행할 수 있다.

### 15.3.2 .http 파일 작성법

기본 구조:

```
### 요청 이름
POST 엔드포인트
Content-Type: application/json
인증 헤더 등

요청 본문 (JSON 형식)
```

요청 간에는 `###`로 구분한다.

### 15.3.3 게임 서버 API 테스트 파일

#### account.http - 계정 관리 테스트

```
@baseUrl = http://localhost:5000
@contentType = application/json

### 회원 가입
POST {{baseUrl}}/api/account/register
Content-Type: {{contentType}}

{
  "username": "testuser",
  "password": "password123",
  "email": "test@example.com"
}

### 로그인
# @name login
POST {{baseUrl}}/api/account/login
Content-Type: {{contentType}}

{
  "username": "testuser",
  "password": "password123"
}

### 토큰 저장
@token = {{login.response.body.accessToken}}
@accountId = {{login.response.body.accountId}}
```

#### character.http - 캐릭터 관리 테스트

```
@baseUrl = http://localhost:5000
@token = eyJhbGc...  # login에서 받은 토큰 값
@accountId = 1  # login에서 받은 accountId 값

### 캐릭터 목록 조회
POST {{baseUrl}}/api/character/list
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}}
}

### 캐릭터 레벨업
POST {{baseUrl}}/api/character/levelup
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}},
  "characterId": 1,
  "experienceToAdd": 200
}
```

#### gacha.http - 가챠 시스템 테스트

```
@baseUrl = http://localhost:5000
@token = eyJhbGc...  # login에서 받은 토큰 값
@accountId = 1  # login에서 받은 accountId 값

### 가챠 1회 뽑기
POST {{baseUrl}}/api/gacha/draw
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}},
  "gachaPoolId": 1,
  "drawCount": 1
}

### 가챠 10회 뽑기
POST {{baseUrl}}/api/gacha/draw
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}},
  "gachaPoolId": 1,
  "drawCount": 10
}
```

#### pvp.http - PvP 랭킹 시스템 테스트

```
@baseUrl = http://localhost:5000
@token = eyJhbGc...  # login에서 받은 토큰 값
@accountId = 1  # login에서 받은 accountId 값

### PvP 대전 시작
# @name startPvp
POST {{baseUrl}}/api/ranking/pvp/start
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "attackerAccountId": {{accountId}},
  "defenderAccountId": 2,
  "attackerCharacterIds": [1, 2, 3]
}

### PvP 대전 결과 제출
POST {{baseUrl}}/api/ranking/pvp/complete
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "battleId": {{startPvp.response.body.battleId}},
  "isAttackerWin": true
}

### PvP 랭킹 조회
POST {{baseUrl}}/api/ranking/pvp/list
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}},
  "limit": 50
}
```

### 15.3.4 통합 테스트 시나리오
다음과 같은 시나리오로 전체 시스템을 테스트할 수 있다:

1. 계정 생성 및 로그인
2. 초기 캐릭터 목록 확인
3. 가챠 10회 뽑기
4. 획득한 캐릭터 확인
5. 캐릭터 레벨업
6. PvP 대전 수행
7. 랭킹 확인

이 시나리오를 다음과 같이 테스트할 수 있다:

```
# test-scenario.http

@baseUrl = http://localhost:5000
@contentType = application/json

### 1. 회원 가입
POST {{baseUrl}}/api/account/register
Content-Type: {{contentType}}

{
  "username": "scenario_user",
  "password": "test123",
  "email": "scenario@example.com"
}

### 2. 로그인
# @name login
POST {{baseUrl}}/api/account/login
Content-Type: {{contentType}}

{
  "username": "scenario_user",
  "password": "test123"
}

### 토큰 및 계정 ID 저장
@token = {{login.response.body.accessToken}}
@accountId = {{login.response.body.accountId}}

### 3. 초기 캐릭터 목록 확인
# @name initialCharacters
POST {{baseUrl}}/api/character/list
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}}
}

### 4. 가챠 10회 뽑기
# @name gachaDraw
POST {{baseUrl}}/api/gacha/draw
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}},
  "gachaPoolId": 1,
  "drawCount": 10
}

### 5. 획득한 캐릭터 확인
# @name afterGachaCharacters
POST {{baseUrl}}/api/character/list
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}}
}

### 6. 첫 번째 캐릭터 레벨업
# @name levelUp
POST {{baseUrl}}/api/character/levelup
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}},
  "characterId": {{afterGachaCharacters.response.body.characters[0].id}},
  "experienceToAdd": 500
}

### 7. PvP 대전 시작
# @name startPvp
POST {{baseUrl}}/api/ranking/pvp/start
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "attackerAccountId": {{accountId}},
  "defenderAccountId": 2,
  "attackerCharacterIds": [{{afterGachaCharacters.response.body.characters[0].id}}]
}

### 8. PvP 대전 결과 제출
# @name completePvp
POST {{baseUrl}}/api/ranking/pvp/complete
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "battleId": {{startPvp.response.body.battleId}},
  "isAttackerWin": true
}

### 9. PvP 랭킹 확인
POST {{baseUrl}}/api/ranking/pvp/list
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}},
  "limit": 20
}
```
  

## 15.4 성능 최적화 및 확장성 고려사항

### 15.4.1 성능 최적화 기법
1. **Redis 캐싱 활용**
   - 자주 접근하는 데이터(캐릭터 정보, 아이템 목록 등)는 Redis에 캐싱
   - TTL(Time To Live)을 적절히 설정해 데이터 일관성 확보

2. **비동기 처리**
   - 가챠 결과 처리, 우편 전송 등 시간이 걸리는 작업은 비동기로 처리
   - Task를 활용한 비차단 I/O 작업

3. **배치 처리**
   - 데이터베이스 쿼리 최적화를 위한 배치 처리
   - 다수의 아이템 지급, 경험치 증가 등을 일괄 처리

### 15.4.2 확장성 고려사항
1. **수평적 확장**
   - 스테이트리스(Stateless) API 서버로 설계해 여러 인스턴스 운영 가능
   - 로드 밸런서를 통한 트래픽 분산

2. **샤딩(Sharding)**
   - 사용자 수 증가에 따른 데이터베이스 샤딩 전략
   - 계정 ID를 기준으로 데이터 분산 저장

3. **마이크로서비스 아키텍처**
   - 기능별 독립적인 서비스로 분리 가능
   - 계정, 캐릭터, 전투, 가챠 등을 별도 서비스로 운영

## 15.5 결론
이번 장에서는 ASP.NET Core Web API를 활용한 수집형 RPG 게임 서버 구현 방법을 살펴봤다. MySQL과 Redis를 조합해 데이터를 효율적으로 관리하고, 필수적인 게임 시스템들(계정, 캐릭터, 가챠, PvP 등)을 구현했다. 또한 .http 파일을 통해 클라이언트 없이도 API를 테스트하는 방법을 배웠다.

실제 상용 게임 서버는 더 많은 기능과 최적화가 필요하지만, 이 장에서 배운 기초를 바탕으로 다양한 기능을 추가하고 확장할 수 있다. 특히 Redis를 활용한 캐싱과 실시간 데이터 처리, JWT를 이용한 인증, 비동기 처리 등은 대규모 서비스에서도 널리 사용되는 기술이다.

다음 단계로는 로깅 시스템 강화, 모니터링 도구 연동, CI/CD 파이프라인 구축 등을 통해 더욱 안정적인 서비스 환경을 구축할 수 있을 것이다.  


   