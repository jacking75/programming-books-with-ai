# ASP.NET Core Web API로 게임 서버 개발
  
저자: 최흥배, Claude AI   
-----------------------    
   
# Chapter 16. 보안 강화 기법
온라인 게임 서버는 사용자 데이터, 게임 내 재화, 결제 정보 등 중요한 자산을 다루기 때문에 보안이 매우 중요하다. 이번 장에서는 ASP.NET Core Web API 기반 게임 서버의 보안을 강화하는 방법을 살펴본다.

## 16.1 SQL 인젝션 방지
SQL 인젝션은 공격자가 악의적인 SQL 코드를 주입하여 데이터베이스를 조작하는 공격 기법이다. 이는 게임 서버에서 가장 흔하고 위험한 보안 취약점 중 하나다.
   
  
### 16.1.1 SQL 인젝션의 위험성
다음은 SQL 인젝션에 취약한 코드의 예시다:

```csharp
// 취약한 코드 - 절대 사용하지 말 것!
string username = request.Username;
string query = $"SELECT * FROM accounts WHERE username = '{username}'";
var result = await connection.QueryAsync(query);
```

만약 공격자가 `username` 파라미터로 `' OR 1=1 --`와 같은 값을 전달하면, 쿼리는 다음과 같이 변형된다:

```sql
SELECT * FROM accounts WHERE username = '' OR 1=1 --'
```

이 쿼리는 모든 계정 정보를 반환하게 되어 데이터 유출이 발생한다.

### 16.1.2 MySqlConnector와 SqlKata로 안전한 쿼리 작성
SqlKata는 SQL 인젝션을 방지하기 위한 매개변수화 쿼리(Parameterized Query)를 자동으로 적용한다. 다음은 SqlKata를 사용한 안전한 쿼리 예시다:

```csharp
// 안전한 방식
public async Task<Account> GetAccountByUsernameAsync(string username)
{
    var result = await _queryFactory.Query("accounts")
        .Where("username", username) // SqlKata가 자동으로 매개변수화
        .FirstOrDefaultAsync<dynamic>();
    
    // 결과 처리
    if (result == null)
        return null;
        
    return new Account
    {
        Id = result.id,
        Username = result.username,
        // 다른 속성들...
    };
}
```

SqlKata는 내부적으로 다음과 같이 매개변수화된 쿼리를 생성한다:

```sql
SELECT * FROM accounts WHERE username = @p0
```

그리고 `@p0`에 `username` 값을 바인딩하여 SQL 인젝션을 방지한다.

### 16.1.3 복잡한 쿼리의 안전한 작성법
때로는 복잡한 쿼리나 동적 조건이 필요할 수 있다. 이런 경우에도 SqlKata를 사용하면 안전하게 쿼리를 작성할 수 있다:

```csharp
public async Task<List<Character>> GetCharactersByFiltersAsync(
    int accountId, 
    string nameFilter = null, 
    int? minLevel = null, 
    List<string> rarities = null)
{
    var query = _queryFactory.Query("characters")
        .Where("account_id", accountId);
    
    // 동적 조건 추가
    if (!string.IsNullOrEmpty(nameFilter))
    {
        query = query.WhereLike("name", $"%{nameFilter}%");
    }
    
    if (minLevel.HasValue)
    {
        query = query.Where("level", ">=", minLevel.Value);
    }
    
    if (rarities != null && rarities.Count > 0)
    {
        query = query.WhereIn("rarity", rarities);
    }
    
    var results = await query.GetAsync<dynamic>();
    
    // 결과 매핑 및 반환
    return results.Select(r => new Character
    {
        Id = r.id,
        AccountId = r.account_id,
        Name = r.name,
        Level = r.level,
        Rarity = r.rarity,
        // 다른 속성들...
    }).ToList();
}
```

SqlKata는 각 조건에 대해 안전한 매개변수화를 적용하므로, 동적 쿼리도 안전하게 작성할 수 있다.

### 16.1.4 저장 프로시저 활용
보안이 중요한 작업의 경우 저장 프로시저를 활용하는 것도 좋은 방법이다:

```csharp
public async Task<bool> ProcessPurchaseAsync(int accountId, int itemId, int quantity)
{
    try
    {
        var parameters = new
        {
            p_account_id = accountId,
            p_item_id = itemId,
            p_quantity = quantity
        };
        
        var result = await _queryFactory.Query()
            .FromRaw("CALL process_purchase(@p_account_id, @p_item_id, @p_quantity)")
            .AddBinding(parameters)
            .GetAsync<dynamic>();
            
        return true;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to process purchase");
        return false;
    }
}
```

저장 프로시저는 데이터베이스 수준에서 권한을 제한하고, 복잡한 작업을 캡슐화하여 보안을 강화할 수 있다.
  
  
## 16.2 API 보안 강화
게임 서버 API의 보안을 강화하기 위한 다양한 기법을 살펴보자.

### 16.2.1 JWT 기반 인증 구현
JSON Web Token(JWT)은 보안 정보를 전송하기 위한 개방형 표준이다. 다음은 JWT 인증을 구현하는 방법이다:

#### JWT 설정 및 미들웨어 구성
Program.cs에 JWT 인증 설정을 추가한다:

```csharp
// JWT 인증 설정
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(
                builder.Configuration["JwtSettings:Secret"])),
            ValidateIssuer = true,
            ValidIssuer = builder.Configuration["JwtSettings:Issuer"],
            ValidateAudience = true,
            ValidAudience = builder.Configuration["JwtSettings:Audience"],
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero // 토큰 만료 시간을 정확히 적용
        };
        
        // 토큰 유효성 검사 이벤트 처리
        options.Events = new JwtBearerEvents
        {
            OnAuthenticationFailed = context =>
            {
                if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))
                {
                    context.Response.Headers.Add("Token-Expired", "true");
                }
                return Task.CompletedTask;
            }
        };
    });

// 인증 미들웨어 적용
app.UseAuthentication();
app.UseAuthorization();
```

#### 토큰 생성 및 검증

```csharp
public class TokenService : ITokenService
{
    private readonly IConfiguration _configuration;
    private readonly RedisConnection _redisConnection;
    
    public TokenService(IConfiguration configuration, RedisConnection redisConnection)
    {
        _configuration = configuration;
        _redisConnection = redisConnection;
    }
    
    public async Task<string> GenerateTokenAsync(Account account)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_configuration["JwtSettings:Secret"]);
        
        var claims = new List<Claim>
        {
            new Claim(ClaimTypes.NameIdentifier, account.Id.ToString()),
            new Claim(ClaimTypes.Name, account.Username),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) // 고유 토큰 ID
        };
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.AddHours(1),
            Issuer = _configuration["JwtSettings:Issuer"],
            Audience = _configuration["JwtSettings:Audience"],
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key), 
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        var tokenString = tokenHandler.WriteToken(token);
        
        // Redis에 토큰 저장 (블랙리스트 관리용)
        var redis = new RedisString<string>(
            _redisConnection, 
            $"token:{account.Id}", 
            TimeSpan.FromHours(1)
        );
        await redis.SetAsync(tokenString);
        
        return tokenString;
    }
    
    public async Task<bool> IsTokenValidAsync(int accountId, string token)
    {
        var redis = new RedisString<string>(_redisConnection, $"token:{accountId}");
        var storedToken = await redis.GetAsync();
        
        return storedToken.HasValue && storedToken.Value == token;
    }
    
    public async Task RevokeTokenAsync(int accountId)
    {
        var redis = new RedisString<string>(_redisConnection, $"token:{accountId}");
        await redis.DeleteAsync();
    }
}
```

#### 컨트롤러에 인증 적용

```csharp
[ApiController]
[Route("api/character")]
[Authorize] // 인증 필요
public class CharacterController : ControllerBase
{
    private readonly ICharacterService _characterService;
    
    public CharacterController(ICharacterService characterService)
    {
        _characterService = characterService;
    }
    
    [HttpPost("list")]
    public async Task<GetCharactersResponse> GetCharacters([FromBody] GetCharactersRequest request)
    {
        // 토큰에서 추출한 계정 ID와 요청의 계정 ID가 일치하는지 확인
        int tokenAccountId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
        
        if (tokenAccountId != request.AccountId)
        {
            return new GetCharactersResponse
            {
                IsSuccess = false,
                ErrorMessage = "Unauthorized access"
            };
        }
        
        var (isSuccess, errorMessage, characters) = 
            await _characterService.GetCharactersByAccountIdAsync(request.AccountId);
            
        return new GetCharactersResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            Characters = characters
        };
    }
    
    // 다른 API 메서드들...
}
```

### 16.2.2 요청 유효성 검증
클라이언트로부터 받은 데이터는 항상 유효성을 검증해야 한다. ASP.NET Core에서는 여러 방법으로 요청 데이터를 검증할 수 있다.

#### FluentValidation 활용
FluentValidation은 요청 객체의 유효성을 검증하는 강력한 라이브러리다:

```csharp
// 패키지 설치: dotnet add package FluentValidation.AspNetCore

// Program.cs에 서비스 등록
builder.Services.AddFluentValidationAutoValidation();
builder.Services.AddValidatorsFromAssemblyContaining<Program>();

// 유효성 검증기 작성
public class RegisterRequestValidator : AbstractValidator<RegisterRequest>
{
    public RegisterRequestValidator()
    {
        RuleFor(x => x.Username)
            .NotEmpty().WithMessage("Username is required")
            .Length(3, 20).WithMessage("Username must be between 3 and 20 characters")
            .Matches("^[a-zA-Z0-9_]+$").WithMessage("Username can only contain letters, numbers and underscore");
            
        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("Password is required")
            .MinimumLength(8).WithMessage("Password must be at least 8 characters")
            .Matches("[A-Z]").WithMessage("Password must contain at least one uppercase letter")
            .Matches("[0-9]").WithMessage("Password must contain at least one number")
            .Matches("[^a-zA-Z0-9]").WithMessage("Password must contain at least one special character");
            
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required")
            .EmailAddress().WithMessage("Invalid email format");
    }
}

// 컨트롤러에서 자동으로 유효성 검증
[ApiController]
[Route("api/account")]
public class AccountController : ControllerBase
{
    [HttpPost("register")]
    public async Task<RegisterResponse> Register([FromBody] RegisterRequest request)
    {
        // ModelState.IsValid가 자동으로 확인됨
        // 유효성 검증에 실패하면 400 Bad Request 반환
        
        // 비즈니스 로직 수행
    }
}
```

#### 수동 유효성 검증
경우에 따라 수동으로 유효성을 검증해야 할 때도 있다:

```csharp
[HttpPost("purchase")]
public async Task<PurchaseResponse> PurchaseItem([FromBody] PurchaseRequest request)
{
    // 기본 데이터 유효성 검증
    if (request.AccountId <= 0 || request.ItemId <= 0 || request.Quantity <= 0)
    {
        return new PurchaseResponse
        {
            IsSuccess = false,
            ErrorMessage = "Invalid request parameters"
        };
    }
    
    // 비즈니스 규칙 검증
    var (hasEnoughCurrency, currencyErrorMessage) = 
        await _itemService.CheckSufficientCurrencyAsync(request.AccountId, request.ItemId, request.Quantity);
        
    if (!hasEnoughCurrency)
    {
        return new PurchaseResponse
        {
            IsSuccess = false,
            ErrorMessage = currencyErrorMessage
        };
    }
    
    // 구매 처리 로직
    var (isSuccess, errorMessage, purchasedItem) = 
        await _itemService.ProcessPurchaseAsync(request.AccountId, request.ItemId, request.Quantity);
        
    return new PurchaseResponse
    {
        IsSuccess = isSuccess,
        ErrorMessage = errorMessage,
        PurchasedItem = purchasedItem
    };
}
```

### 16.2.3 속도 제한(Rate Limiting) 구현
API 남용을 방지하기 위해 속도 제한을 구현하는 것이 중요하다. ASP.NET Core 9.0에서는 내장 Rate Limiting 미들웨어를 사용할 수 있다:

```csharp
// Program.cs에 속도 제한 구성
builder.Services.AddRateLimiter(options =>
{
    // 일반 API 요청에 대한 제한 정책
    options.AddFixedWindowLimiter("general", opt =>
    {
        opt.PermitLimit = 100; // 시간 창당 최대 요청 수
        opt.Window = TimeSpan.FromMinutes(1); // 시간 창 크기
        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;
        opt.QueueLimit = 0; // 제한 초과 시 즉시 거부
    });
    
    // 로그인/가입 등 민감한 API에 대한 엄격한 제한 정책
    options.AddFixedWindowLimiter("authentication", opt =>
    {
        opt.PermitLimit = 10;
        opt.Window = TimeSpan.FromMinutes(5);
        opt.QueueLimit = 0;
    });
    
    // Redis 기반 분산 Rate Limiter (대규모 서비스용)
    options.AddRedisRateLimiter("premium", opt =>
    {
        opt.PermitLimit = 200;
        opt.Window = TimeSpan.FromMinutes(1);
        opt.ConnectionMultiplexerFactory = () => 
            ConnectionMultiplexer.Connect(builder.Configuration.GetConnectionString("RedisConnection"));
        opt.RedisKeyPrefix = "RL:";
    });
    
    // 제한 초과 시 응답 구성
    options.OnRejected = async (context, cancellationToken) =>
    {
        context.HttpContext.Response.StatusCode = StatusCodes.Status429TooManyRequests;
        
        var response = new
        {
            IsSuccess = false,
            ErrorMessage = "Too many requests. Please try again later.",
            RetryAfter = context.Lease.RetryAfter?.TotalSeconds ?? 60
        };
        
        await context.HttpContext.Response.WriteAsJsonAsync(response, cancellationToken);
    };
});

// 속도 제한 미들웨어 활성화
app.UseRateLimiter();
```

컨트롤러나 액션에 속도 제한 정책 적용:

```csharp
[ApiController]
[Route("api/account")]
public class AccountController : ControllerBase
{
    [HttpPost("register")]
    [EnableRateLimiting("authentication")] // 인증 정책 적용
    public async Task<RegisterResponse> Register([FromBody] RegisterRequest request)
    {
        // 등록 로직
    }
    
    [HttpPost("login")]
    [EnableRateLimiting("authentication")] // 인증 정책 적용
    public async Task<LoginResponse> Login([FromBody] LoginRequest request)
    {
        // 로그인 로직
    }
}

[ApiController]
[Route("api/gacha")]
[Authorize]
[EnableRateLimiting("general")] // 일반 정책을 컨트롤러 전체에 적용
public class GachaController : ControllerBase
{
    [HttpPost("draw")]
    public async Task<DrawGachaResponse> DrawGacha([FromBody] DrawGachaRequest request)
    {
        // 가챠 뽑기 로직
    }
    
    // 프리미엄 사용자용 특별 가챠 (더 높은 제한)
    [HttpPost("premium-draw")]
    [EnableRateLimiting("premium")] // 프리미엄 정책 적용
    public async Task<DrawGachaResponse> DrawPremiumGacha([FromBody] DrawGachaRequest request)
    {
        // 프리미엄 가챠 뽑기 로직
    }
}
```

### 16.2.4 Redis를 활용한 세션 관리
JWT 토큰과 함께 Redis를 사용하여 세션을 효과적으로 관리할 수 있다:

```csharp
public class SessionService : ISessionService
{
    private readonly RedisConnection _redisConnection;
    
    public SessionService(RedisConnection redisConnection)
    {
        _redisConnection = redisConnection;
    }
    
    public async Task CreateSessionAsync(int accountId, string deviceId, string token)
    {
        // 세션 정보 구성
        var sessionInfo = new SessionInfo
        {
            AccountId = accountId,
            DeviceId = deviceId,
            Token = token,
            CreatedAt = DateTime.UtcNow,
            LastActivity = DateTime.UtcNow
        };
        
        // Redis에 세션 저장 (1시간 만료)
        var redis = new RedisString<SessionInfo>(
            _redisConnection, 
            $"session:{accountId}:{deviceId}", 
            TimeSpan.FromHours(1)
        );
        await redis.SetAsync(sessionInfo);
        
        // 계정별 활성 세션 목록에 추가
        var sessionList = new RedisList<string>(
            _redisConnection, 
            $"account_sessions:{accountId}"
        );
        await sessionList.RightPushAsync(deviceId);
    }
    
    public async Task<SessionInfo> GetSessionAsync(int accountId, string deviceId)
    {
        var redis = new RedisString<SessionInfo>(
            _redisConnection, 
            $"session:{accountId}:{deviceId}"
        );
        var session = await redis.GetAsync();
        
        return session.Value;
    }
    
    public async Task UpdateSessionActivityAsync(int accountId, string deviceId)
    {
        var redis = new RedisString<SessionInfo>(
            _redisConnection, 
            $"session:{accountId}:{deviceId}"
        );
        var session = await redis.GetAsync();
        
        if (session.HasValue)
        {
            session.Value.LastActivity = DateTime.UtcNow;
            await redis.SetAsync(session.Value, TimeSpan.FromHours(1));
        }
    }
    
    public async Task InvalidateSessionAsync(int accountId, string deviceId)
    {
        // 세션 삭제
        var redis = new RedisString<SessionInfo>(
            _redisConnection, 
            $"session:{accountId}:{deviceId}"
        );
        await redis.DeleteAsync();
        
        // 계정별 활성 세션 목록에서 제거
        var sessionList = new RedisList<string>(
            _redisConnection, 
            $"account_sessions:{accountId}"
        );
        await sessionList.RemoveAsync(deviceId);
    }
    
    public async Task InvalidateAllSessionsAsync(int accountId)
    {
        // 계정의 모든 활성 세션 가져오기
        var sessionList = new RedisList<string>(
            _redisConnection, 
            $"account_sessions:{accountId}"
        );
        var deviceIds = await sessionList.RangeAsync(0, -1);
        
        // 각 세션 삭제
        foreach (var deviceId in deviceIds)
        {
            var redis = new RedisString<SessionInfo>(
                _redisConnection, 
                $"session:{accountId}:{deviceId}"
            );
            await redis.DeleteAsync();
        }
        
        // 세션 목록 삭제
        await sessionList.DeleteAsync();
    }
}

// 세션 정보 클래스
public class SessionInfo
{
    public int AccountId { get; set; }
    public string DeviceId { get; set; }
    public string Token { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastActivity { get; set; }
}
```

### 16.2.5 HTTPS 적용
프로덕션 환경에서는 반드시 HTTPS를 적용해야 한다. ASP.NET Core에서는 다음과 같이 HTTPS를 설정할 수 있다:

```csharp
// Program.cs에서 HTTPS 리디렉션 설정
if (!app.Environment.IsDevelopment())
{
    app.UseHsts(); // HTTP Strict Transport Security
    app.UseHttpsRedirection(); // HTTP에서 HTTPS로 리디렉션
}
```

Kestrel 서버에 HTTPS 인증서 구성:

```csharp
// Program.cs에서 Kestrel 서버 구성
builder.WebHost.ConfigureKestrel(serverOptions =>
{
    serverOptions.Listen(IPAddress.Any, 5000); // HTTP 엔드포인트
    serverOptions.Listen(IPAddress.Any, 5001, listenOptions =>
    {
        // HTTPS 인증서 설정
        listenOptions.UseHttps(httpsOptions =>
        {
            var certPath = builder.Configuration["Certificates:Path"];
            var certPassword = builder.Configuration["Certificates:Password"];
            httpsOptions.ServerCertificate = new X509Certificate2(certPath, certPassword);
        });
    });
});
```

appsettings.json에 인증서 설정 추가:

```json
{
  "Certificates": {
    "Path": "/path/to/certificate.pfx",
    "Password": "certificate-password"
  }
}
```

## 16.3 사용자 데이터 보호
게임 서버에서는 사용자의 개인 정보와 게임 데이터를 안전하게 보호해야 한다.

### 16.3.1 비밀번호 해싱
사용자 비밀번호는 절대 평문으로 저장하면 안 된다. 다음은 BCrypt를 사용한 안전한 비밀번호 관리 방법이다:

```csharp
// 패키지 설치: dotnet add package BCrypt.Net-Next

public class AccountService : IAccountService
{
    private readonly IAccountRepository _accountRepository;
    
    public AccountService(IAccountRepository accountRepository)
    {
        _accountRepository = accountRepository;
    }
    
    public async Task<(bool isSuccess, string errorMessage, int accountId)> RegisterAsync(
        string username, string password, string email)
    {
        // 비밀번호 해싱 (BCrypt)
        string passwordHash = BCrypt.Net.BCrypt.HashPassword(password, workFactor: 12);
        
        // 계정 생성 로직
        var account = new Account
        {
            Username = username,
            PasswordHash = passwordHash,
            Email = email,
            CreatedAt = DateTime.UtcNow
        };
        
        int accountId = await _accountRepository.CreateAccountAsync(account);
        return (true, null, accountId);
    }
    
    public async Task<(bool isSuccess, string errorMessage, string token, int accountId)> LoginAsync(
        string username, string password)
    {
        // 사용자 조회
        var account = await _accountRepository.GetAccountByUsernameAsync(username);
        if (account == null)
        {
            return (false, "Invalid username or password", null, 0);
        }
        
        // 비밀번호 검증
        bool isPasswordValid = BCrypt.Net.BCrypt.Verify(password, account.PasswordHash);
        if (!isPasswordValid)
        {
            return (false, "Invalid username or password", null, 0);
        }
        
        // 로그인 성공 처리
        // ...
    }
    
    public async Task<(bool isSuccess, string errorMessage)> ChangePasswordAsync(
        int accountId, string currentPassword, string newPassword)
    {
        // 계정 조회
        var account = await _accountRepository.GetAccountByIdAsync(accountId);
        if (account == null)
        {
            return (false, "Account not found");
        }
        
        // 현재 비밀번호 검증
        bool isCurrentPasswordValid = BCrypt.Net.BCrypt.Verify(currentPassword, account.PasswordHash);
        if (!isCurrentPasswordValid)
        {
            return (false, "Current password is incorrect");
        }
        
        // 새 비밀번호 해싱
        string newPasswordHash = BCrypt.Net.BCrypt.HashPassword(newPassword, workFactor: 12);
        
        // 비밀번호 업데이트
        await _accountRepository.UpdatePasswordAsync(accountId, newPasswordHash);
        
        // 모든 활성 세션 무효화 (선택적)
        // await _sessionService.InvalidateAllSessionsAsync(accountId);
        
        return (true, null);
    }
}
```

### 16.3.2 민감 정보 암호화
결제 정보나 개인 식별 정보와 같은 민감한 데이터는 암호화하여 저장해야 한다:

```csharp
public class EncryptionService : IEncryptionService
{
    private readonly IConfiguration _configuration;
    
    public EncryptionService(IConfiguration configuration)
    {
        _configuration = configuration;
    }
    
    public string Encrypt(string plainText)
    {
        if (string.IsNullOrEmpty(plainText))
            return plainText;
            
        try
        {
            // 암호화 키 및 IV 가져오기
            string keyString = _configuration["Encryption:Key"];
            string ivString = _configuration["Encryption:IV"];
            
            byte[] key = Convert.FromBase64String(keyString);
            byte[] iv = Convert.FromBase64String(ivString);
            
            // AES 암호화 구성
            using var aes = Aes.Create();
            aes.Key = key;
            aes.IV = iv;
            
            // 암호화 수행
            var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
            
            using var memoryStream = new MemoryStream();
            using var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
            using (var streamWriter = new StreamWriter(cryptoStream))
            {
                streamWriter.Write(plainText);
            }
            
            return Convert.ToBase64String(memoryStream.ToArray());
        }
        catch (Exception ex)
        {
            // 암호화 실패 시 로깅
            // _logger.LogError(ex, "Encryption failed");
            throw;
        }
    }
    
    public string Decrypt(string cipherText)
    {
        if (string.IsNullOrEmpty(cipherText))
            return cipherText;
            
        try
        {
            // 암호화 키 및 IV 가져오기
            string keyString = _configuration["Encryption:Key"];
            string ivString = _configuration["Encryption:IV"];
            
            byte[] key = Convert.FromBase64String(keyString);
            byte[] iv = Convert.FromBase64String(ivString);
            
            // AES 복호화 구성
            using var aes = Aes.Create();
            aes.Key = key;
            aes.IV = iv;
            
            // 복호화 수행
            var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
            
            byte[] cipherBytes = Convert.FromBase64String(cipherText);
            
            using var memoryStream = new MemoryStream(cipherBytes);
            using var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
            using var streamReader = new StreamReader(cryptoStream);
            
            return streamReader.ReadToEnd();
        }
        catch (Exception ex)
        {
            // 복호화 실패 시 로깅
            // _logger.LogError(ex, "Decryption failed");
            throw;
        }
    }
}
```

appsettings.json에 암호화 설정 추가:

```json
{
  "Encryption": {
    "Key": "base64EncodedKey==", // 32바이트 키
    "IV": "base64EncodedIV==" // 16바이트 IV
  }
}
```

암호화 서비스 사용 예:

```csharp
public class PaymentService : IPaymentService
{
    private readonly IEncryptionService _encryptionService;
    private readonly IPaymentRepository _paymentRepository;
    
    public PaymentService(IEncryptionService encryptionService, IPaymentRepository paymentRepository)
    {
        _encryptionService = encryptionService;
        _paymentRepository = paymentRepository;
    }
    
    public async Task<(bool isSuccess, string errorMessage)> SavePaymentMethodAsync(
        int accountId, string cardNumber, string cardHolderName, string expiryDate, string cvv)
    {
        // 민감 정보 암호화
        string encryptedCardNumber = _encryptionService.Encrypt(cardNumber);
        string encryptedCardHolderName = _encryptionService.Encrypt(cardHolderName);
        string encryptedExpiryDate = _encryptionService.Encrypt(expiryDate);
        string encryptedCvv = _encryptionService.Encrypt(cvv);
        
        // 마스킹된 카드 번호 (표시용)
        string maskedCardNumber = $"**** **** **** {cardNumber.Substring(cardNumber.Length - 4)}";
        
        // 암호화된 정보 저장
        var paymentMethod = new PaymentMethod
        {
            AccountId = accountId,
            CardNumberMasked = maskedCardNumber,
            CardNumberEncrypted = encryptedCardNumber,
            CardHolderNameEncrypted = encryptedCardHolderName,
            ExpiryDateEncrypted = encryptedExpiryDate,
            CvvEncrypted = encryptedCvv,
            CreatedAt = DateTime.UtcNow
        };
        
        await _paymentRepository.SavePaymentMethodAsync(paymentMethod);
        
        return (true, null);
    }
    
    public async Task<(bool isSuccess, string errorMessage, PaymentMethodDto paymentMethod)> GetPaymentMethodAsync(
        int accountId, int paymentMethodId)
    {
        var paymentMethod = await _paymentRepository.GetPaymentMethodAsync(accountId, paymentMethodId);
        if (paymentMethod == null)
        {
            return (false, "Payment method not found", null);
        }
        
        // CVV는 복호화하지 않음 (보안 강화)
        return (true, null, new PaymentMethodDto
        {
            Id = paymentMethod.Id,
            CardNumberMasked = paymentMethod.CardNumberMasked,
            CardHolderName = _encryptionService.Decrypt(paymentMethod.CardHolderNameEncrypted),
            ExpiryDate = _encryptionService.Decrypt(paymentMethod.ExpiryDateEncrypted)
        });
    }
}
```

### 16.3.3 데이터 접근 제어 및 감사
사용자 데이터 접근을 제어하고 감사하는 것이 중요하다:

```csharp
public class AuditMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<AuditMiddleware> _logger;
    
    public AuditMiddleware(RequestDelegate next, ILogger<AuditMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context, IAuditService auditService)
    {
        // 요청 정보 수집
        string requestPath = context.Request.Path;
        string httpMethod = context.Request.Method;
        string clientIp = context.Connection.RemoteIpAddress?.ToString();
        
        // 인증된 사용자 ID 가져오기
        int? accountId = null;
        if (context.User.Identity.IsAuthenticated)
        {
            var accountIdClaim = context.User.FindFirst(ClaimTypes.NameIdentifier);
            if (accountIdClaim != null && int.TryParse(accountIdClaim.Value, out int parsedAccountId))
            {
                accountId = parsedAccountId;
            }
        }
        
        // 요청 본문 읽기 (옵션)
        string requestBody = null;
        if (context.Request.ContentType?.Contains("application/json") == true)
        {
            context.Request.EnableBuffering();
            
            using var reader = new StreamReader(
                context.Request.Body,
                encoding: Encoding.UTF8,
                detectEncodingFromByteOrderMarks: false,
                leaveOpen: true);
                
            requestBody = await reader.ReadToEndAsync();
            context.Request.Body.Position = 0; // 스트림 위치 초기화
        }
        
        // 시작 시간 기록
        var startTime = DateTime.UtcNow;
        
        // 응답 처리
        var originalBodyStream = context.Response.Body;
        using var responseBody = new MemoryStream();
        context.Response.Body = responseBody;
        
        try
        {
            // 다음 미들웨어 호출
            await _next(context);
            
            // 응답 본문 수집 (옵션)
            string responseContent = null;
            if (context.Response.ContentType?.Contains("application/json") == true)
            {
                responseBody.Seek(0, SeekOrigin.Begin);
                responseContent = await new StreamReader(responseBody).ReadToEndAsync();
                responseBody.Seek(0, SeekOrigin.Begin);
            }
            
            // 응답 상태 코드
            int statusCode = context.Response.StatusCode;
            
            // 종료 시간 및 소요 시간 계산
            var endTime = DateTime.UtcNow;
            var duration = (endTime - startTime).TotalMilliseconds;
            
            // 감사 로그 기록
            await auditService.LogActivityAsync(new AuditLog
            {
                AccountId = accountId,
                RequestPath = requestPath,
                HttpMethod = httpMethod,
                ClientIp = clientIp,
                RequestBody = SanitizeRequestBody(requestPath, requestBody), // 민감 정보 제거
                ResponseStatus = statusCode,
                ResponseTime = duration,
                Timestamp = startTime
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during request processing");
            throw;
        }
        finally
        {
            // 원래 응답 스트림으로 복사
            responseBody.Seek(0, SeekOrigin.Begin);
            await responseBody.CopyToAsync(originalBodyStream);
            context.Response.Body = originalBodyStream;
        }
    }
    
    private string SanitizeRequestBody(string path, string body)
    {
        if (string.IsNullOrEmpty(body))
            return body;
            
        // 민감한 API의 경우 본문 내용 마스킹
        if (path.Contains("/api/account/login") || 
            path.Contains("/api/account/register") ||
            path.Contains("/api/payment"))
        {
            // JSON 파싱
            try
            {
                var jsonDoc = JsonDocument.Parse(body);
                var sanitized = new Dictionary<string, object>();
                
                // 루트 요소 처리
                foreach (var element in jsonDoc.RootElement.EnumerateObject())
                {
                    // 민감 필드 마스킹
                    if (element.Name.ToLower().Contains("password") ||
                        element.Name.ToLower().Contains("card") ||
                        element.Name.ToLower().Contains("cvv") ||
                        element.Name.ToLower().Contains("secure"))
                    {
                        sanitized[element.Name] = "********";
                    }
                    else
                    {
                        sanitized[element.Name] = element.Value.ToString();
                    }
                }
                
                // 마스킹된 JSON 반환
                return JsonSerializer.Serialize(sanitized);
            }
            catch
            {
                // JSON 파싱 실패 시 전체 마스킹
                return "*** SENSITIVE DATA ***";
            }
        }
        
        return body;
    }
}

// Program.cs에 미들웨어 등록
app.UseMiddleware<AuditMiddleware>();
```

감사 서비스 및 로그 모델:

```csharp
public class AuditLog
{
    public int Id { get; set; }
    public int? AccountId { get; set; }
    public string RequestPath { get; set; }
    public string HttpMethod { get; set; }
    public string ClientIp { get; set; }
    public string RequestBody { get; set; }
    public int ResponseStatus { get; set; }
    public double ResponseTime { get; set; }
    public DateTime Timestamp { get; set; }
}

public interface IAuditService
{
    Task LogActivityAsync(AuditLog log);
    Task<List<AuditLog>> GetAccountActivityAsync(int accountId, DateTime startDate, DateTime endDate);
}

public class AuditService : IAuditService
{
    private readonly QueryFactory _queryFactory;
    
    public AuditService(QueryFactory queryFactory)
    {
        _queryFactory = queryFactory;
    }
    
    public async Task LogActivityAsync(AuditLog log)
    {
        await _queryFactory.Query("audit_logs").InsertAsync(new
        {
            account_id = log.AccountId,
            request_path = log.RequestPath,
            http_method = log.HttpMethod,
            client_ip = log.ClientIp,
            request_body = log.RequestBody,
            response_status = log.ResponseStatus,
            response_time = log.ResponseTime,
            timestamp = log.Timestamp
        });
    }
    
    public async Task<List<AuditLog>> GetAccountActivityAsync(int accountId, DateTime startDate, DateTime endDate)
    {
        var results = await _queryFactory.Query("audit_logs")
            .Where("account_id", accountId)
            .WhereBetween("timestamp", startDate, endDate)
            .OrderByDesc("timestamp")
            .GetAsync<dynamic>();
            
        return results.Select(r => new AuditLog
        {
            Id = r.id,
            AccountId = r.account_id,
            RequestPath = r.request_path,
            HttpMethod = r.http_method,
            ClientIp = r.client_ip,
            RequestBody = r.request_body,
            ResponseStatus = r.response_status,
            ResponseTime = r.response_time,
            Timestamp = r.timestamp
        }).ToList();
    }
}
```

### 16.3.4 개인정보 보호 정책 구현
게임 서비스에는 개인정보 보호 정책을 구현하는 것이 중요하다:

```csharp
[ApiController]
[Route("api/privacy")]
public class PrivacyController : ControllerBase
{
    private readonly IPrivacyService _privacyService;
    
    public PrivacyController(IPrivacyService privacyService)
    {
        _privacyService = privacyService;
    }
    
    [HttpPost("preferences")]
    [Authorize]
    public async Task<UpdatePrivacyPreferencesResponse> UpdatePrivacyPreferences(
        [FromBody] UpdatePrivacyPreferencesRequest request)
    {
        int accountId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value);
        
        var (isSuccess, errorMessage) = await _privacyService.UpdatePrivacyPreferencesAsync(
            accountId,
            request.AllowDataCollection,
            request.AllowMarketingEmails,
            request.AllowThirdPartySharing);
            
        return new UpdatePrivacyPreferencesResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage
        };
    }
    
    [HttpPost("export")]
    [Authorize]
    public async Task<RequestDataExportResponse> RequestDataExport([FromBody] RequestDataExportRequest request)
    {
        int accountId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value);
        
        var (isSuccess, errorMessage, requestId) = await _privacyService.RequestDataExportAsync(accountId);
        
        return new RequestDataExportResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            RequestId = requestId
        };
    }
    
    [HttpPost("delete-account")]
    [Authorize]
    public async Task<DeleteAccountResponse> RequestAccountDeletion([FromBody] DeleteAccountRequest request)
    {
        int accountId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value);
        
        // 비밀번호 확인으로 추가 검증
        var (isSuccess, errorMessage, deletionRequestId) = 
            await _privacyService.RequestAccountDeletionAsync(accountId, request.Password);
            
        return new DeleteAccountResponse
        {
            IsSuccess = isSuccess,
            ErrorMessage = errorMessage,
            DeletionRequestId = deletionRequestId
        };
    }
}

public interface IPrivacyService
{
    Task<(bool isSuccess, string errorMessage)> UpdatePrivacyPreferencesAsync(
        int accountId, bool allowDataCollection, bool allowMarketingEmails, bool allowThirdPartySharing);
    Task<(bool isSuccess, string errorMessage, string requestId)> RequestDataExportAsync(int accountId);
    Task<(bool isSuccess, string errorMessage, string deletionRequestId)> RequestAccountDeletionAsync(
        int accountId, string password);
}
```

## 16.4 .http 파일을 이용한 보안 테스트
.http 파일을 사용하여 API의 보안 기능을 테스트할 수 있다.

### 16.4.1 인증 및 권한 테스트

```
@baseUrl = http://localhost:5000
@contentType = application/json

### 1. 계정 등록
POST {{baseUrl}}/api/account/register
Content-Type: {{contentType}}

{
  "username": "securitytest",
  "password": "StrongP@ssw0rd",
  "email": "security@example.com"
}

### 2. 로그인
# @name login
POST {{baseUrl}}/api/account/login
Content-Type: {{contentType}}

{
  "username": "securitytest",
  "password": "StrongP@ssw0rd"
}

### 토큰 저장
@token = {{login.response.body.accessToken}}
@accountId = {{login.response.body.accountId}}

### 3. 인증 필요한 API 호출 (토큰 없음) - 401 에러 예상
POST {{baseUrl}}/api/character/list
Content-Type: {{contentType}}

{
  "accountId": {{accountId}}
}

### 4. 인증 필요한 API 호출 (유효한 토큰)
POST {{baseUrl}}/api/character/list
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "accountId": {{accountId}}
}

### 5. 다른 계정의 데이터에 접근 시도 (권한 테스트) - 실패 예상
POST {{baseUrl}}/api/character/list
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "accountId": 999
}
```

### 16.4.2 입력 유효성 검증 테스트

```
@baseUrl = http://localhost:5000
@contentType = application/json
@token = eyJhbGc... # 로그인에서 받은 토큰

### 1. 유효하지 않은 이메일로 회원가입 시도
POST {{baseUrl}}/api/account/register
Content-Type: {{contentType}}

{
  "username": "validation_test",
  "password": "weak",
  "email": "not-an-email"
}

### 2. 짧은 비밀번호로 회원가입 시도
POST {{baseUrl}}/api/account/register
Content-Type: {{contentType}}

{
  "username": "validation_test",
  "password": "weak",
  "email": "valid@example.com"
}

### 3. SQL 인젝션 시도 (username에 인젝션 코드)
POST {{baseUrl}}/api/account/login
Content-Type: {{contentType}}

{
  "username": "' OR 1=1 --",
  "password": "anything"
}

### 4. 가챠 API에 음수 값 시도
POST {{baseUrl}}/api/gacha/draw
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "accountId": 1,
  "gachaPoolId": 1,
  "drawCount": -10
}
```

### 16.4.3 속도 제한 테스트

```
@baseUrl = http://localhost:5000
@contentType = application/json

### 속도 제한 테스트: 동일한 로그인 요청 반복
# 이 요청을 짧은 시간 내에 여러 번 실행하여 속도 제한 테스트
POST {{baseUrl}}/api/account/login
Content-Type: {{contentType}}

{
  "username": "ratelimit_test",
  "password": "password123"
}
```

### 16.4.4 세션 관리 테스트

```
@baseUrl = http://localhost:5000
@contentType = application/json

### 1. 첫 번째 기기에서 로그인
# @name login1
POST {{baseUrl}}/api/account/login
Content-Type: {{contentType}}

{
  "username": "multidevice_user",
  "password": "password123",
  "deviceId": "device1"
}

### 첫 번째 기기 토큰 저장
@token1 = {{login1.response.body.accessToken}}
@accountId = {{login1.response.body.accountId}}

### 2. 두 번째 기기에서 로그인
# @name login2
POST {{baseUrl}}/api/account/login
Content-Type: {{contentType}}

{
  "username": "multidevice_user",
  "password": "password123",
  "deviceId": "device2"
}

### 두 번째 기기 토큰 저장
@token2 = {{login2.response.body.accessToken}}

### 3. 첫 번째 기기 토큰으로 API 호출
POST {{baseUrl}}/api/character/list
Content-Type: {{contentType}}
Authorization: Bearer {{token1}}

{
  "accountId": {{accountId}}
}

### 4. 로그아웃 (모든 기기)
POST {{baseUrl}}/api/account/logout-all
Content-Type: {{contentType}}
Authorization: Bearer {{token1}}

{
  "accountId": {{accountId}}
}

### 5. 로그아웃 후 첫 번째 기기 토큰으로 API 호출 (실패 예상)
POST {{baseUrl}}/api/character/list
Content-Type: {{contentType}}
Authorization: Bearer {{token1}}

{
  "accountId": {{accountId}}
}

### 6. 로그아웃 후 두 번째 기기 토큰으로 API 호출 (실패 예상)
POST {{baseUrl}}/api/character/list
Content-Type: {{contentType}}
Authorization: Bearer {{token2}}

{
  "accountId": {{accountId}}
}
```
  

## 16.5 결론
이 장에서는 ASP.NET Core Web API 기반 게임 서버의 보안을 강화하는 방법을 살펴봤다. SQL 인젝션 방지, API 보안, 사용자 데이터 보호 등 다양한 보안 기법을 구현하는 방법을 알아봤으며, .http 파일을 사용한 보안 테스트 방법도 배웠다.

게임 서버의 보안은 지속적인 관리와 개선이 필요한 중요한 영역이다. 특히 다음 사항을 꾸준히 확인하고 관리해야 한다:

1. 정기적인 보안 업데이트 및 패치 적용
2. 취약점 스캐닝 및 침투 테스트 수행
3. 로깅 및 모니터링을 통한 이상 징후 감지
4. 새로운 보안 위협에 대한 지속적인 학습 및 대응책 마련

마지막으로, 보안은 개발 단계에서부터 고려해야 하는 "보안 중심 설계(Security by Design)" 원칙을 따르는 것이 중요하다. 이는 시스템 설계 초기부터 보안을 고려하고, 모든 개발 과정에서 보안 요구사항을 충족하는 방식으로 개발하는 접근 방식이다.



   