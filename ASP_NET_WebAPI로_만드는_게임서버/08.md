# ASP.NET Core Web API로 게임 서버 개발
  
저자: 최흥배, Claude AI   
-----------------------    
  
# Chapter 8. 기본 게임 데이터 관리 API

## 8.1 개요
수집형 RPG 게임에서 데이터 관리는 핵심 요소다. 게임 내 캐릭터, 아이템, 스테이지 등의 기본 정보인 마스터 데이터를 관리하고, 클라이언트에게 효율적으로 제공하는 API가 필요하다. 이 챕터에서는 게임 데이터 모델 설계부터 마스터 데이터 관리, 버전 관리까지 필요한 전체 시스템을 구현해보자.

```
┌─────────────────────┐       ┌─────────────────────┐      ┌─────────────────────┐
│                     │       │                     │      │                     │
│    클라이언트         │──────►│   ASP.NET Core     │◄────►│     Redis 캐시       │
│    모바일 앱         │       │   Web API Server    │      │                     │
└─────────────────────┘       │                     │      │  - 마스터 데이터      │
                              └──────────┬──────────┘      │  - 버전 정보         │
                                         │                 └─────────────────────┘
                                         │
                                         ▼
                              ┌─────────────────────┐
                              │                     │
                              │     MySQL DB        │
                              │                     │
                              │  - 마스터 데이터      │
                              └─────────────────────┘
```
  

## 8.2 데이터 모델 설계

### 8.2.1 게임 데이터 모델링 원칙
수집형 RPG 게임의 데이터 모델 설계 시 고려해야 할 핵심 원칙들은 다음과 같다:  

1. **유연성**: 게임 업데이트와 콘텐츠 추가를 쉽게 할 수 있도록 유연한 구조
2. **확장성**: 새로운 기능과 시스템을 추가할 수 있는 확장 가능한 구조
3. **성능**: 빠른 데이터 로딩 및 검색을 위한 최적화
4. **일관성**: 데이터 간의 관계와 무결성 유지
5. **버전 관리**: 데이터 변경에 따른 버전 관리 지원

### 8.2.2 주요 게임 엔티티 관계도
수집형 RPG의 핵심 데이터 모델은 다음과 같은 관계를 가진다:

```
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│   Character   │     │     Item      │     │     Stage     │
│ (캐릭터/영웅)   │     │  (아이템/장비) │     │ (스테이지/던전) │
└───────┬───────┘     └───────┬───────┘     └───────┬───────┘
        │                     │                     │
        ▼                     ▼                     ▼
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│     Skill     │     │  Item Option  │     │     Enemy     │
│  (스킬/능력)   │     │  (아이템 옵션)  │     │   (적/몬스터)  │
└───────────────┘     └───────────────┘     └───────────────┘
        ▲                     ▲                     ▲
        │                     │                     │
┌───────┴───────┐     ┌───────┴───────┐     ┌───────┴───────┐
│  Skill Effect │     │ Item Category │     │  Stage Drop   │
│  (스킬 효과)   │     │ (아이템 분류)   │     │  (드롭 정보)   │
└───────────────┘     └───────────────┘     └───────────────┘
```

### 8.2.3 MySQL 테이블 설계
마스터 데이터를 저장할 MySQL 테이블을 설계해보자. 대표적인 예시로 캐릭터, 아이템, 스테이지 테이블을 설계한다.

```sql
-- 캐릭터 마스터 테이블
CREATE TABLE master_characters (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    rarity INT NOT NULL, -- 1: 일반, 2: 고급, 3: 희귀, 4: 영웅, 5: 전설
    element VARCHAR(20) NOT NULL, -- fire, water, earth, wind, light, dark
    class VARCHAR(20) NOT NULL, -- warrior, mage, ranger, assassin, support
    base_hp INT NOT NULL,
    base_attack INT NOT NULL,
    base_defense INT NOT NULL,
    growth_hp FLOAT NOT NULL,
    growth_attack FLOAT NOT NULL,
    growth_defense FLOAT NOT NULL,
    skill_ids JSON NOT NULL, -- [1, 2, 3, 4] 형태로 스킬 ID 목록 저장
    image_path VARCHAR(200),
    release_date DATETIME NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    INDEX idx_rarity (rarity),
    INDEX idx_element (element),
    INDEX idx_class (class)
);

-- 스킬 마스터 테이블
CREATE TABLE master_skills (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    skill_type VARCHAR(20) NOT NULL, -- passive, active, ultimate
    cooldown INT,
    effect_ids JSON NOT NULL, -- [1, 2, 3] 형태로 효과 ID 목록 저장
    targeting VARCHAR(20) NOT NULL, -- self, single, aoe, random
    icon_path VARCHAR(200),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    INDEX idx_skill_type (skill_type)
);

-- 스킬 효과 마스터 테이블
CREATE TABLE master_skill_effects (
    id INT NOT NULL PRIMARY KEY,
    effect_type VARCHAR(50) NOT NULL, -- damage, heal, buff, debuff, etc.
    target_stat VARCHAR(30), -- hp, attack, defense, speed, etc.
    value_type VARCHAR(10) NOT NULL, -- flat, percent
    base_value FLOAT NOT NULL,
    scaling_stat VARCHAR(30), -- attack, defense, hp, etc.
    scaling_ratio FLOAT,
    duration INT, -- 효과 지속 턴 수 (영구적이면 NULL)
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    INDEX idx_effect_type (effect_type)
);

-- 아이템 마스터 테이블
CREATE TABLE master_items (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    category_id INT NOT NULL,
    rarity INT NOT NULL, -- 1: 일반, 2: 고급, 3: 희귀, 4: 영웅, 5: 전설
    level_required INT NOT NULL DEFAULT 1,
    stats JSON, -- {"attack": 10, "defense": 5} 형태로 기본 스탯
    option_pool_id INT, -- 옵션 풀 ID (장비 아이템인 경우)
    use_effect_id INT, -- 사용 효과 ID (소모품인 경우)
    stack_max INT NOT NULL DEFAULT 1, -- 최대 중첩 수
    sell_price INT NOT NULL DEFAULT 0,
    icon_path VARCHAR(200),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    INDEX idx_category (category_id),
    INDEX idx_rarity (rarity)
);

-- 아이템 카테고리 마스터 테이블
CREATE TABLE master_item_categories (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    parent_id INT, -- 상위 카테고리 ID (NULL이면 최상위)
    item_type VARCHAR(20) NOT NULL, -- equipment, consumable, material, currency
    equipment_slot VARCHAR(20), -- weapon, armor, accessory, etc. (장비인 경우)
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    INDEX idx_parent (parent_id),
    INDEX idx_item_type (item_type)
);

-- 스테이지 마스터 테이블
CREATE TABLE master_stages (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    chapter INT NOT NULL,
    stage_number INT NOT NULL,
    difficulty VARCHAR(20) NOT NULL, -- normal, hard, expert
    required_level INT NOT NULL DEFAULT 1,
    stamina_cost INT NOT NULL,
    enemy_groups JSON NOT NULL, -- 각 웨이브별 적 구성 [[1,2,3], [4,5,6], [7,8,9]]
    clear_rewards JSON NOT NULL, -- {"exp": 100, "gold": 500, "items": [{"id": 1, "count": 1, "chance": 0.5}]}
    first_clear_rewards JSON, -- 최초 클리어 시 보상
    background_path VARCHAR(200),
    bgm_path VARCHAR(200),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    INDEX idx_chapter (chapter, stage_number),
    INDEX idx_difficulty (difficulty)
);

-- 적 마스터 테이블
CREATE TABLE master_enemies (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    enemy_type VARCHAR(30) NOT NULL, -- normal, elite, boss
    element VARCHAR(20) NOT NULL, -- fire, water, earth, wind, light, dark
    level INT NOT NULL,
    hp INT NOT NULL,
    attack INT NOT NULL,
    defense INT NOT NULL,
    speed INT NOT NULL,
    skill_ids JSON, -- 사용 가능한 스킬 ID 목록
    drop_table_id INT, -- 드롭 테이블 ID
    exp_reward INT NOT NULL DEFAULT 0,
    gold_reward INT NOT NULL DEFAULT 0,
    image_path VARCHAR(200),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    INDEX idx_enemy_type (enemy_type),
    INDEX idx_element (element)
);

-- 게임 상수 마스터 테이블
CREATE TABLE master_game_constants (
    id VARCHAR(50) NOT NULL PRIMARY KEY, -- exp_table, drop_rate, etc.
    value JSON NOT NULL, -- 상수 값 (JSON 형식으로 저장)
    description TEXT,
    last_updated DATETIME NOT NULL
);

-- 게임 버전 관리 테이블
CREATE TABLE master_versions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    version VARCHAR(20) NOT NULL,
    data_version VARCHAR(20) NOT NULL,
    min_app_version VARCHAR(20) NOT NULL,
    update_url VARCHAR(255),
    maintenance BOOLEAN NOT NULL DEFAULT FALSE,
    maintenance_start DATETIME,
    maintenance_end DATETIME,
    notice TEXT,
    created_at DATETIME NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    INDEX idx_version (version)
);
```

### 8.2.4 C# 데이터 모델 클래스
이제 MySQL 테이블에 대응하는 C# 모델 클래스를 정의해보자.  

```csharp
// Models/GameData/Character.cs
public class Character
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public int Rarity { get; set; }
    public string Element { get; set; }
    public string Class { get; set; }
    public int BaseHp { get; set; }
    public int BaseAttack { get; set; }
    public int BaseDefense { get; set; }
    public float GrowthHp { get; set; }
    public float GrowthAttack { get; set; }
    public float GrowthDefense { get; set; }
    public List<int> SkillIds { get; set; }
    public string ImagePath { get; set; }
    public DateTime ReleaseDate { get; set; }
    public bool IsActive { get; set; }
}

// Models/GameData/Skill.cs
public class Skill
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public string SkillType { get; set; }
    public int? Cooldown { get; set; }
    public List<int> EffectIds { get; set; }
    public string Targeting { get; set; }
    public string IconPath { get; set; }
    public bool IsActive { get; set; }
}

// Models/GameData/SkillEffect.cs
public class SkillEffect
{
    public int Id { get; set; }
    public string EffectType { get; set; }
    public string TargetStat { get; set; }
    public string ValueType { get; set; }
    public float BaseValue { get; set; }
    public string ScalingStat { get; set; }
    public float? ScalingRatio { get; set; }
    public int? Duration { get; set; }
    public bool IsActive { get; set; }
}

// Models/GameData/Item.cs
public class Item
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public int CategoryId { get; set; }
    public int Rarity { get; set; }
    public int LevelRequired { get; set; }
    public Dictionary<string, int> Stats { get; set; }
    public int? OptionPoolId { get; set; }
    public int? UseEffectId { get; set; }
    public int StackMax { get; set; }
    public int SellPrice { get; set; }
    public string IconPath { get; set; }
    public bool IsActive { get; set; }
}

// Models/GameData/ItemCategory.cs
public class ItemCategory
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int? ParentId { get; set; }
    public string ItemType { get; set; }
    public string EquipmentSlot { get; set; }
    public bool IsActive { get; set; }
}

// Models/GameData/Stage.cs
public class Stage
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public int Chapter { get; set; }
    public int StageNumber { get; set; }
    public string Difficulty { get; set; }
    public int RequiredLevel { get; set; }
    public int StaminaCost { get; set; }
    public List<List<int>> EnemyGroups { get; set; }
    public StageClearRewards ClearRewards { get; set; }
    public StageClearRewards FirstClearRewards { get; set; }
    public string BackgroundPath { get; set; }
    public string BgmPath { get; set; }
    public bool IsActive { get; set; }
}

// Models/GameData/StageClearRewards.cs
public class StageClearRewards
{
    public int Exp { get; set; }
    public int Gold { get; set; }
    public List<StageItemDrop> Items { get; set; }
}

public class StageItemDrop
{
    public int Id { get; set; }
    public int Count { get; set; }
    public float Chance { get; set; }
}

// Models/GameData/Enemy.cs
public class Enemy
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string EnemyType { get; set; }
    public string Element { get; set; }
    public int Level { get; set; }
    public int Hp { get; set; }
    public int Attack { get; set; }
    public int Defense { get; set; }
    public int Speed { get; set; }
    public List<int> SkillIds { get; set; }
    public int? DropTableId { get; set; }
    public int ExpReward { get; set; }
    public int GoldReward { get; set; }
    public string ImagePath { get; set; }
    public bool IsActive { get; set; }
}

// Models/GameData/GameConstant.cs
public class GameConstant
{
    public string Id { get; set; }
    public object Value { get; set; }
    public string Description { get; set; }
    public DateTime LastUpdated { get; set; }
}

// Models/GameData/GameVersion.cs
public class GameVersion
{
    public int Id { get; set; }
    public string Version { get; set; }
    public string DataVersion { get; set; }
    public string MinAppVersion { get; set; }
    public string UpdateUrl { get; set; }
    public bool Maintenance { get; set; }
    public DateTime? MaintenanceStart { get; set; }
    public DateTime? MaintenanceEnd { get; set; }
    public string Notice { get; set; }
    public DateTime CreatedAt { get; set; }
    public bool IsActive { get; set; }
}
```

## 8.3 게임 마스터 데이터 관리

### 8.3.1 마스터 데이터 리포지토리
게임 마스터 데이터에 접근하기 위한 리포지토리를 구현한다. 여기서는 SqlKata를 사용하여 데이터를 조회한다.  

```csharp
// Repositories/MasterData/IMasterDataRepository.cs
public interface IMasterDataRepository<T> where T : class
{
    Task<List<T>> GetAllAsync();
    Task<T> GetByIdAsync(int id);
    Task<List<T>> GetByIdsAsync(IEnumerable<int> ids);
    Task<DateTime> GetLastUpdatedTimeAsync();
}

// Repositories/MasterData/CharacterRepository.cs
public class CharacterRepository : IMasterDataRepository<Character>
{
    private readonly QueryFactory _db;
    
    public CharacterRepository(QueryFactory db)
    {
        _db = db;
    }
    
    public async Task<List<Character>> GetAllAsync()
    {
        var characters = await _db.Query("master_characters")
            .Where("is_active", true)
            .GetAsync<Character>();
            
        // JSON 필드 처리
        foreach (var character in characters)
        {
            character.SkillIds = JsonSerializer.Deserialize<List<int>>(character.SkillIds.ToString());
        }
        
        return characters;
    }
    
    public async Task<Character> GetByIdAsync(int id)
    {
        var character = await _db.Query("master_characters")
            .Where("id", id)
            .Where("is_active", true)
            .FirstOrDefaultAsync<Character>();
            
        if (character != null)
        {
            character.SkillIds = JsonSerializer.Deserialize<List<int>>(character.SkillIds.ToString());
        }
        
        return character;
    }
    
    public async Task<List<Character>> GetByIdsAsync(IEnumerable<int> ids)
    {
        var characters = await _db.Query("master_characters")
            .WhereIn("id", ids)
            .Where("is_active", true)
            .GetAsync<Character>();
            
        foreach (var character in characters)
        {
            character.SkillIds = JsonSerializer.Deserialize<List<int>>(character.SkillIds.ToString());
        }
        
        return characters;
    }
    
    public async Task<DateTime> GetLastUpdatedTimeAsync()
    {
        // 테이블의 마지막 업데이트 시간 조회 (예: release_date 기준)
        var result = await _db.Query("master_characters")
            .Where("is_active", true)
            .OrderByDesc("release_date")
            .FirstOrDefaultAsync<Character>();
            
        return result?.ReleaseDate ?? DateTime.MinValue;
    }
}

// 다른 마스터 데이터 리포지토리도 유사하게 구현...
```

### 8.3.2 마스터 데이터 캐싱 서비스
게임 마스터 데이터는 자주 변경되지 않기 때문에 Redis에 캐싱하여 성능을 향상시킨다.  
또는 **게임 마스터 데이터는 자주 변경되지 않기 때문에 게임 서버의 메모리에 로딩해 놓고 사용할 수도 있다. 이렇게 하면 서버 메모리에서 데이터를 읽으므로 성능은 좋지만 게임 서비스 도중 데이터 변경이 발생하는 경우 데이터를 재 로딩하는 별도의 구현이 필요하다**.   
여기에서는 마스터 데이터를 캐싱해서 사용하고 있지만 실제 게임 서비스에서는 서버의 메모리에 로딩해서 사용하기를 추천한다.    
  
```csharp
// Services/MasterData/IMasterDataCacheService.cs
public interface IMasterDataCacheService<T> where T : class
{
    Task<List<T>> GetAllAsync();
    Task<T> GetByIdAsync(int id);
    Task<List<T>> GetByIdsAsync(IEnumerable<int> ids);
    Task<bool> RefreshCacheAsync();
    Task<DateTime> GetLastUpdatedTimeAsync();
}

// Services/MasterData/MasterDataCacheBase.cs
public abstract class MasterDataCacheBase<T> : IMasterDataCacheService<T> where T : class
{
    protected readonly RedisConfig _redisConfig;
    protected readonly IMasterDataRepository<T> _repository;
    protected readonly ILogger _logger;
    protected readonly string _cacheKeyPrefix;
    protected readonly TimeSpan _cacheExpiry = TimeSpan.FromDays(1); // 기본 캐시 유효기간
    
    protected MasterDataCacheBase(
        RedisConfig redisConfig,
        IMasterDataRepository<T> repository,
        ILogger logger,
        string cacheKeyPrefix)
    {
        _redisConfig = redisConfig;
        _repository = repository;
        _logger = logger;
        _cacheKeyPrefix = cacheKeyPrefix;
    }
    
    public async Task<List<T>> GetAllAsync()
    {
        var redis = new RedisString<List<T>>(_redisConfig, $"{_cacheKeyPrefix}:all");
        var result = await redis.GetAsync();
        
        if (result.HasValue)
        {
            return result.Value;
        }
        
        // 캐시에 없으면 DB에서 조회
        var data = await _repository.GetAllAsync();
        
        // 캐시에 저장
        await redis.SetAsync(data, _cacheExpiry);
        
        return data;
    }
    
    public async Task<T> GetByIdAsync(int id)
    {
        var redis = new RedisString<T>(_redisConfig, $"{_cacheKeyPrefix}:{id}");
        var result = await redis.GetAsync();
        
        if (result.HasValue)
        {
            return result.Value;
        }
        
        // 캐시에 없으면 DB에서 조회
        var data = await _repository.GetByIdAsync(id);
        
        if (data != null)
        {
            // 캐시에 저장
            await redis.SetAsync(data, _cacheExpiry);
        }
        
        return data;
    }
    
    public async Task<List<T>> GetByIdsAsync(IEnumerable<int> ids)
    {
        var idList = ids.ToList();
        var result = new List<T>();
        var missingIds = new List<int>();
        
        // 캐시에서 각 ID별로 조회
        foreach (var id in idList)
        {
            var redis = new RedisString<T>(_redisConfig, $"{_cacheKeyPrefix}:{id}");
            var item = await redis.GetAsync();
            
            if (item.HasValue)
            {
                result.Add(item.Value);
            }
            else
            {
                missingIds.Add(id);
            }
        }
        
        // 캐시에 없는 항목은 DB에서 조회
        if (missingIds.Count > 0)
        {
            var dataFromDb = await _repository.GetByIdsAsync(missingIds);
            
            // 캐시에 저장하고 결과에 추가
            foreach (var item in dataFromDb)
            {
                var id = (int)item.GetType().GetProperty("Id").GetValue(item);
                var redis = new RedisString<T>(_redisConfig, $"{_cacheKeyPrefix}:{id}");
                await redis.SetAsync(item, _cacheExpiry);
                
                result.Add(item);
            }
        }
        
        return result;
    }
    
    public async Task<bool> RefreshCacheAsync()
    {
        try
        {
            // 전체 데이터 새로 조회
            var allData = await _repository.GetAllAsync();
            
            // "all" 키 갱신
            var redisAll = new RedisString<List<T>>(_redisConfig, $"{_cacheKeyPrefix}:all");
            await redisAll.SetAsync(allData, _cacheExpiry);
            
            // 개별 항목 캐시 갱신
            foreach (var item in allData)
            {
                var id = (int)item.GetType().GetProperty("Id").GetValue(item);
                var redis = new RedisString<T>(_redisConfig, $"{_cacheKeyPrefix}:{id}");
                await redis.SetAsync(item, _cacheExpiry);
            }
            
            // 마지막 업데이트 시간 갱신
            var lastUpdated = await _repository.GetLastUpdatedTimeAsync();
            var redisLastUpdated = new RedisString<DateTime>(_redisConfig, $"{_cacheKeyPrefix}:last_updated");
            await redisLastUpdated.SetAsync(lastUpdated, _cacheExpiry);
            
            _logger.LogInformation("마스터 데이터 캐시 새로고침 완료: {CacheKey}", _cacheKeyPrefix);
            
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "마스터 데이터 캐시 새로고침 중 오류 발생: {CacheKey}", _cacheKeyPrefix);
            return false;
        }
    }
    
    public async Task<DateTime> GetLastUpdatedTimeAsync()
    {
        var redis = new RedisString<DateTime>(_redisConfig, $"{_cacheKeyPrefix}:last_updated");
        var result = await redis.GetAsync();
        
        if (result.HasValue)
        {
            return result.Value;
        }
        
        // 캐시에 없으면 DB에서 조회
        var lastUpdated = await _repository.GetLastUpdatedTimeAsync();
        
        // 캐시에 저장
        await redis.SetAsync(lastUpdated, _cacheExpiry);
        
        return lastUpdated;
    }
}

// Services/MasterData/CharacterCacheService.cs
public class CharacterCacheService : MasterDataCacheBase<Character>
{
    public CharacterCacheService(
        RedisConfig redisConfig,
        IMasterDataRepository<Character> repository,
        ILogger<CharacterCacheService> logger)
        : base(redisConfig, repository, logger, "master:character")
    {
    }
    
    // 추가적인 특화된 메서드가 필요한 경우 여기에 구현
}

// 다른 마스터 데이터 캐시 서비스도 유사하게 구현...
```

### 8.3.3 마스터 데이터 관리 서비스
다양한 마스터 데이터를 통합 관리하는 서비스를 구현한다.

```csharp
// Services/MasterData/IMasterDataService.cs
public interface IMasterDataService
{
    Task<List<Character>> GetAllCharactersAsync();
    Task<Character> GetCharacterByIdAsync(int id);
    Task<List<Character>> GetCharactersByIdsAsync(IEnumerable<int> ids);
    
    Task<List<Item>> GetAllItemsAsync();
    Task<Item> GetItemByIdAsync(int id);
    Task<List<Item>> GetItemsByIdsAsync(IEnumerable<int> ids);
    
    Task<List<Stage>> GetAllStagesAsync();
    Task<Stage> GetStageByIdAsync(int id);
    
    Task<GameVersion> GetLatestVersionAsync();
    
    Task<bool> RefreshAllCacheAsync();
    Task<Dictionary<string, DateTime>> GetAllLastUpdatedTimesAsync();
}

// Services/MasterData/MasterDataService.cs
public class MasterDataService : IMasterDataService
{
    private readonly IMasterDataCacheService<Character> _characterCache;
    private readonly IMasterDataCacheService<Item> _itemCache;
    private readonly IMasterDataCacheService<Stage> _stageCache;
    private readonly IMasterDataCacheService<GameVersion> _versionCache;
    private readonly ILogger<MasterDataService> _logger;
    
    public MasterDataService(
        IMasterDataCacheService<Character> characterCache,
        IMasterDataCacheService<Item> itemCache,
        IMasterDataCacheService<Stage> stageCache,
        IMasterDataCacheService<GameVersion> versionCache,
        ILogger<MasterDataService> logger)
    {
        _characterCache = characterCache;
        _itemCache = itemCache;
        _stageCache = stageCache;
        _versionCache = versionCache;
        _logger = logger;
    }
    
    public async Task<List<Character>> GetAllCharactersAsync()
    {
        return await _characterCache.GetAllAsync();
    }
    
    public async Task<Character> GetCharacterByIdAsync(int id)
    {
        return await _characterCache.GetByIdAsync(id);
    }
    
    public async Task<List<Character>> GetCharactersByIdsAsync(IEnumerable<int> ids)
    {
        return await _characterCache.GetByIdsAsync(ids);
    }
    
    public async Task<List<Item>> GetAllItemsAsync()
    {
        return await _itemCache.GetAllAsync();
    }
    
    public async Task<Item> GetItemByIdAsync(int id)
    {
        return await _itemCache.GetByIdAsync(id);
    }
    
    public async Task<List<Item>> GetItemsByIdsAsync(IEnumerable<int> ids)
    {
        return await _itemCache.GetByIdsAsync(ids);
    }
    
    public async Task<List<Stage>> GetAllStagesAsync()
    {
        return await _stageCache.GetAllAsync();
    }
    
    public async Task<Stage> GetStageByIdAsync(int id)
    {
        return await _stageCache.GetByIdAsync(id);
    }
    
    public async Task<GameVersion> GetLatestVersionAsync()
    {
        var allVersions = await _versionCache.GetAllAsync();
        return allVersions.OrderByDescending(v => v.CreatedAt).FirstOrDefault();
    }
    
    public async Task<bool> RefreshAllCacheAsync()
    {
        try
        {
            var characterTask = _characterCache.RefreshCacheAsync();
            var itemTask = _itemCache.RefreshCacheAsync();
            var stageTask = _stageCache.RefreshCacheAsync();
            var versionTask = _versionCache.RefreshCacheAsync();
            
            await Task.WhenAll(characterTask, itemTask, stageTask, versionTask);
            
            var allSucceeded = characterTask.Result && itemTask.Result && 
                              stageTask.Result && versionTask.Result;
                              
            _logger.LogInformation("모든 마스터 데이터 캐시 새로고침 완료. 성공: {Success}", allSucceeded);
            
            return allSucceeded;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "마스터 데이터 캐시 새로고침 중 오류 발생");
            return false;
        }
    }
    
    public async Task<Dictionary<string, DateTime>> GetAllLastUpdatedTimesAsync()
    {
        var characterTime = await _characterCache.GetLastUpdatedTimeAsync();
        var itemTime = await _itemCache.GetLastUpdatedTimeAsync();
        var stageTime = await _stageCache.GetLastUpdatedTimeAsync();
        var versionTime = await _versionCache.GetLastUpdatedTimeAsync();
        
        return new Dictionary<string, DateTime>
        {
            { "character", characterTime },
            { "item", itemTime },
            { "stage", stageTime },
            { "version", versionTime }
        };
    }
}
```
  

## 8.4 버전 관리 및 업데이트 체계
게임 버전 및 마스터 데이터 버전을 관리하는 시스템을 구현한다.

### 8.4.1 버전 관리 서비스

```csharp
// Services/GameVersion/IGameVersionService.cs
public interface IGameVersionService
{
    Task<GameVersion> GetLatestVersionAsync();
    Task<bool> CheckForUpdateAsync(string clientVersion);
    Task<bool> IsMaintenanceAsync();
    Task<bool> SetMaintenanceAsync(bool maintenance, DateTime? startTime, DateTime? endTime, string notice);
    Task<(bool Success, string Message)> UpdateVersionAsync(
        string version, string dataVersion, string minAppVersion, string updateUrl, string notice);
}

// Services/GameVersion/GameVersionService.cs
public class GameVersionService : IGameVersionService
{
    private readonly IMasterDataCacheService<GameVersion> _versionCache;
    private readonly QueryFactory _db;
    private readonly RedisConfig _redisConfig;
    private readonly ILogger<GameVersionService> _logger;
    
    public GameVersionService(
        IMasterDataCacheService<GameVersion> versionCache,
        QueryFactory db,
        RedisConfig redisConfig,
        ILogger<GameVersionService> logger)
    {
        _versionCache = versionCache;
        _db = db;
        _redisConfig = redisConfig;
        _logger = logger;
    }
    
    public async Task<GameVersion> GetLatestVersionAsync()
    {
        var versions = await _versionCache.GetAllAsync();
        return versions.Where(v => v.IsActive).OrderByDescending(v => v.CreatedAt).FirstOrDefault();
    }
    
    public async Task<bool> CheckForUpdateAsync(string clientVersion)
    {
        var latestVersion = await GetLatestVersionAsync();
        
        if (latestVersion == null)
        {
            return false;
        }
        
        return new Version(clientVersion) < new Version(latestVersion.MinAppVersion);
    }
    
    public async Task<bool> IsMaintenanceAsync()
    {
        var latestVersion = await GetLatestVersionAsync();
        
        if (latestVersion == null || !latestVersion.Maintenance)
        {
            return false;
        }
        
        // 현재 시간이 유지보수 시간 범위 내에 있는지 확인
        var now = DateTime.UtcNow;
        
        if (latestVersion.MaintenanceStart.HasValue && latestVersion.MaintenanceEnd.HasValue)
        {
            return now >= latestVersion.MaintenanceStart.Value && now <= latestVersion.MaintenanceEnd.Value;
        }
        
        return latestVersion.Maintenance;
    }
    
    public async Task<bool> SetMaintenanceAsync(bool maintenance, DateTime? startTime, DateTime? endTime, string notice)
    {
        try
        {
            var latestVersion = await GetLatestVersionAsync();
            
            if (latestVersion == null)
            {
                return false;
            }
            
            // 현재 버전 정보 업데이트
            var affected = await _db.Query("master_versions")
                .Where("id", latestVersion.Id)
                .UpdateAsync(new
                {
                    maintenance = maintenance,
                    maintenance_start = startTime,
                    maintenance_end = endTime,
                    notice = notice
                });
                
            if (affected > 0)
            {
                // 캐시 갱신
                await _versionCache.RefreshCacheAsync();
                
                // 유지보수 정보 별도 캐싱 (빠른 접근용)
                var redisMaintenance = new RedisString<bool>(_redisConfig, "game:maintenance");
                await redisMaintenance.SetAsync(maintenance, TimeSpan.FromHours(1));
                
                if (maintenance && startTime.HasValue && endTime.HasValue)
                {
                    var redisMaintenanceInfo = new RedisString<MaintenanceInfo>(_redisConfig, "game:maintenance:info");
                    await redisMaintenanceInfo.SetAsync(new MaintenanceInfo
                    {
                        Start = startTime.Value,
                        End = endTime.Value,
                        Notice = notice
                    }, TimeSpan.FromHours(1));
                }
                
                return true;
            }
            
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "유지보수 모드 설정 중 오류 발생");
            return false;
        }
    }
    
    public async Task<(bool Success, string Message)> UpdateVersionAsync(
        string version, string dataVersion, string minAppVersion, string updateUrl, string notice)
    {
        try
        {
            // 버전 형식 검증
            if (!IsValidVersion(version) || !IsValidVersion(dataVersion) || !IsValidVersion(minAppVersion))
            {
                return (false, "유효하지 않은 버전 형식입니다. (x.y.z 형식이어야 함)");
            }
            
            // 기존 활성 버전 비활성화
            await _db.Query("master_versions")
                .Where("is_active", true)
                .UpdateAsync(new { is_active = false });
                
            // 새 버전 정보 추가
            await _db.Query("master_versions").InsertAsync(new
            {
                version = version,
                data_version = dataVersion,
                min_app_version = minAppVersion,
                update_url = updateUrl,
                maintenance = false,
                notice = notice,
                created_at = DateTime.UtcNow,
                is_active = true
            });
            
            // 캐시 갱신
            await _versionCache.RefreshCacheAsync();
            
            return (true, "게임 버전이 업데이트되었습니다.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "게임 버전 업데이트 중 오류 발생");
            return (false, "게임 버전 업데이트 중 오류가 발생했습니다.");
        }
    }
    
    private bool IsValidVersion(string version)
    {
        // x.y.z 형식의 버전 확인
        try
        {
            var v = new Version(version);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

// Models/GameVersion/MaintenanceInfo.cs
public class MaintenanceInfo
{
    public DateTime Start { get; set; }
    public DateTime End { get; set; }
    public string Notice { get; set; }
}
```

### 8.4.2 버전 관리 컨트롤러
버전 정보와 유지보수 정보를 제공하는 API 컨트롤러를 구현한다.  

```csharp
// Controllers/GameVersionController.cs
[ApiController]
[Route("api/[controller]")]
public class GameVersionController : ControllerBase
{
    private readonly IGameVersionService _versionService;
    
    public GameVersionController(IGameVersionService versionService)
    {
        _versionService = versionService;
    }
    
    [HttpPost("check")]
    public async Task<VersionCheckResponse> CheckVersion([FromBody] VersionCheckRequest request)
    {
        if (string.IsNullOrEmpty(request.ClientVersion))
        {
            return new VersionCheckResponse
            {
                Success = false,
                Message = "클라이언트 버전 정보가 필요합니다."
            };
        }
        
        var latestVersion = await _versionService.GetLatestVersionAsync();
        var needsUpdate = await _versionService.CheckForUpdateAsync(request.ClientVersion);
        var isMaintenance = await _versionService.IsMaintenanceAsync();
        
        return new VersionCheckResponse
        {
            Success = true,
            CurrentVersion = latestVersion.Version,
            DataVersion = latestVersion.DataVersion,
            MinAppVersion = latestVersion.MinAppVersion,
            UpdateRequired = needsUpdate,
            UpdateUrl = needsUpdate ? latestVersion.UpdateUrl : null,
            Maintenance = isMaintenance,
            MaintenanceStart = isMaintenance ? latestVersion.MaintenanceStart : null,
            MaintenanceEnd = isMaintenance ? latestVersion.MaintenanceEnd : null,
            Notice = latestVersion.Notice
        };
    }
    
    [HttpPost("set-maintenance")]
    [Authorize(Roles = "Admin")] // 관리자만 접근 가능하도록 설정
    public async Task<MaintenanceResponse> SetMaintenance([FromBody] SetMaintenanceRequest request)
    {
        var result = await _versionService.SetMaintenanceAsync(
            request.Maintenance, request.StartTime, request.EndTime, request.Notice);
            
        return new MaintenanceResponse
        {
            Success = result,
            Message = result ? "유지보수 모드가 설정되었습니다." : "유지보수 모드 설정에 실패했습니다."
        };
    }
    
    [HttpPost("update-version")]
    [Authorize(Roles = "Admin")] // 관리자만 접근 가능하도록 설정
    public async Task<UpdateVersionResponse> UpdateVersion([FromBody] UpdateVersionRequest request)
    {
        var (success, message) = await _versionService.UpdateVersionAsync(
            request.Version, request.DataVersion, request.MinAppVersion, request.UpdateUrl, request.Notice);
            
        return new UpdateVersionResponse
        {
            Success = success,
            Message = message
        };
    }
}

// Models/GameVersion/VersionRequests.cs
public class VersionCheckRequest
{
    public string ClientVersion { get; set; }
}

public class SetMaintenanceRequest
{
    public bool Maintenance { get; set; }
    public DateTime? StartTime { get; set; }
    public DateTime? EndTime { get; set; }
    public string Notice { get; set; }
}

public class UpdateVersionRequest
{
    public string Version { get; set; }
    public string DataVersion { get; set; }
    public string MinAppVersion { get; set; }
    public string UpdateUrl { get; set; }
    public string Notice { get; set; }
}

// Models/GameVersion/VersionResponses.cs
public class VersionCheckResponse
{
    public bool Success { get; set; }
    public string CurrentVersion { get; set; }
    public string DataVersion { get; set; }
    public string MinAppVersion { get; set; }
    public bool UpdateRequired { get; set; }
    public string UpdateUrl { get; set; }
    public bool Maintenance { get; set; }
    public DateTime? MaintenanceStart { get; set; }
    public DateTime? MaintenanceEnd { get; set; }
    public string Notice { get; set; }
    public string Message { get; set; }
}

public class MaintenanceResponse
{
    public bool Success { get; set; }
    public string Message { get; set; }
}

public class UpdateVersionResponse
{
    public bool Success { get; set; }
    public string Message { get; set; }
}
```
   
  
## 8.5 서비스 등록
위에서 구현한 서비스들을 DI 컨테이너에 등록한다.

```csharp
// Program.cs
// 마스터 데이터 리포지토리 등록
builder.Services.AddScoped<IMasterDataRepository<Character>, CharacterRepository>();
builder.Services.AddScoped<IMasterDataRepository<Item>, ItemRepository>();
builder.Services.AddScoped<IMasterDataRepository<Stage>, StageRepository>();
builder.Services.AddScoped<IMasterDataRepository<GameVersion>, GameVersionRepository>();

// 마스터 데이터 캐시 서비스 등록
builder.Services.AddSingleton<IMasterDataCacheService<Character>, CharacterCacheService>();
builder.Services.AddSingleton<IMasterDataCacheService<Item>, ItemCacheService>();
builder.Services.AddSingleton<IMasterDataCacheService<Stage>, StageCacheService>();
builder.Services.AddSingleton<IMasterDataCacheService<GameVersion>, GameVersionCacheService>();

// 마스터 데이터 서비스 등록
builder.Services.AddScoped<IMasterDataService, MasterDataService>();

// 게임 버전 서비스 등록
builder.Services.AddScoped<IGameVersionService, GameVersionService>();
```

## 8.6 HTTP 테스트 파일 작성

구현한 API를 테스트하기 위한 HTTP 파일을 작성한다.

```
### 모든 캐릭터 조회
POST https://localhost:5001/api/masterdata/characters
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{}

### 특정 캐릭터 조회
POST https://localhost:5001/api/masterdata/characters/id
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "id": 1
}

### 여러 캐릭터 조회
POST https://localhost:5001/api/masterdata/characters/ids
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "ids": [1, 2, 3, 4, 5]
}

### 모든 아이템 조회
POST https://localhost:5001/api/masterdata/items
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{}

### 특정 아이템 조회
POST https://localhost:5001/api/masterdata/items/id
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "id": 101
}

### 모든 스테이지 조회
POST https://localhost:5001/api/masterdata/stages
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{}

### 특정 스테이지 조회
POST https://localhost:5001/api/masterdata/stages/id
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "id": 1001
}

### 마스터 데이터 마지막 업데이트 시간 조회
POST https://localhost:5001/api/masterdata/last-updated
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{}

### 마스터 데이터 캐시 새로고침 (관리자용)
POST https://localhost:5001/api/masterdata/refresh
Content-Type: application/json
Authorization: Bearer {{admin_auth_token}}

{}

### 버전 체크
POST https://localhost:5001/api/gameversion/check
Content-Type: application/json

{
  "clientVersion": "1.0.0"
}
```
  

## 8.7 실제 데이터 예시
간단한 예시 데이터를 살펴보자.

### 8.7.1 캐릭터 데이터 예시

```json
[
  {
    "id": 1,
    "name": "아서",
    "description": "균형 잡힌 능력을 가진 기사",
    "rarity": 4,
    "element": "light",
    "class": "warrior",
    "baseHp": 1000,
    "baseAttack": 100,
    "baseDefense": 80,
    "growthHp": 120,
    "growthAttack": 12,
    "growthDefense": 8,
    "skillIds": [101, 102, 103, 104],
    "imagePath": "characters/arthur.png",
    "releaseDate": "2023-01-01T00:00:00Z",
    "isActive": true
  },
  {
    "id": 2,
    "name": "모건",
    "description": "강력한 마법 공격을 가진 마법사",
    "rarity": 5,
    "element": "dark",
    "class": "mage",
    "baseHp": 800,
    "baseAttack": 120,
    "baseDefense": 50,
    "growthHp": 90,
    "growthAttack": 15,
    "growthDefense": 5,
    "skillIds": [201, 202, 203, 204],
    "imagePath": "characters/morgan.png",
    "releaseDate": "2023-01-01T00:00:00Z",
    "isActive": true
  }
]
```

### 8.7.2 아이템 데이터 예시

```json
[
  {
    "id": 101,
    "name": "대검",
    "description": "기본적인 대검",
    "categoryId": 1,
    "rarity": 2,
    "levelRequired": 1,
    "stats": {
      "attack": 10
    },
    "optionPoolId": 1,
    "useEffectId": null,
    "stackMax": 1,
    "sellPrice": 100,
    "iconPath": "items/greatsword.png",
    "isActive": true
  },
  {
    "id": 201,
    "name": "체력 포션",
    "description": "HP를 100 회복합니다",
    "categoryId": 3,
    "rarity": 1,
    "levelRequired": 1,
    "stats": null,
    "optionPoolId": null,
    "useEffectId": 1,
    "stackMax": 99,
    "sellPrice": 50,
    "iconPath": "items/health_potion.png",
    "isActive": true
  }
]
```

### 8.7.3 게임 버전 정보 예시

```json
{
  "id": 1,
  "version": "1.2.0",
  "dataVersion": "1.2.0",
  "minAppVersion": "1.1.0",
  "updateUrl": "https://example.com/update",
  "maintenance": false,
  "maintenanceStart": null,
  "maintenanceEnd": null,
  "notice": "새로운 캐릭터와 아이템이 추가되었습니다.",
  "createdAt": "2023-06-01T00:00:00Z",
  "isActive": true
}
```

  
## 8.8 정리
이 챕터에서는 수집형 RPG 게임의 기본 게임 데이터 관리 API를 구현했다. 주요 내용은 다음과 같다:

1. **데이터 모델 설계**: 게임 핵심 데이터(캐릭터, 아이템, 스테이지 등)의 모델과 MySQL 테이블을 설계했다.

2. **게임 마스터 데이터 관리**: 마스터 데이터를 효율적으로 조회하고 캐싱하는 시스템을 구현했다.

3. **버전 관리 및 업데이트 체계**: 게임 버전과 데이터 버전을 관리하고, 클라이언트의 버전 체크 및 업데이트 알림 시스템을 구현했다.

4. **데이터 마이그레이션**: 게임 업데이트 시 사용자 데이터를A 마이그레이션하는 시스템을 구현했다.

5. **관리자 도구**: 마스터 데이터를 관리하는 관리자 API를 구현했다.

게임 데이터 관리는 게임 개발의 핵심 부분으로, 확장성과 유연성을 고려하여 설계하는 것이 중요하다. 이 챕터에서 구현한 시스템은 데이터 변경과 게임 업데이트를 효율적으로 관리할 수 있도록 설계되었다.
  