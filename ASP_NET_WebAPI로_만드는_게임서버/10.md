# ASP.NET Core Web API로 게임 서버 개발
  
저자: 최흥배, Claude AI   
-----------------------    
  
# Chapter 10. 인벤토리 및 아이템 시스템

## 10.1 인벤토리 및 아이템 시스템 개요
수집형 RPG 게임에서 인벤토리와 아이템 시스템은 핵심 요소다. 플레이어는 다양한 아이템을 수집하고, 사용하며, 캐릭터에게 장착함으로써 게임 진행을 할 수 있다. 이 장에서는 서버 측에서 이러한 인벤토리 및 아이템 시스템을 구현하는 방법을 다룬다.
  
### 아이템 유형 분류
RPG 게임에서 아이템은 일반적으로 다음과 같이 분류할 수 있다:

1. **장비(Equipment)**: 무기, 방어구, 액세서리 등 캐릭터에게 장착하여 능력치를 상승시키는 아이템
2. **소비품(Consumable)**: 포션, 스크롤, 음식 등 사용 시 효과를 발휘하고 소모되는 아이템
3. **재료(Material)**: 제작, 강화, 진화 등에 사용되는 재료 아이템
4. **통화(Currency)**: 골드, 다이아몬드, 특수 토큰 등 게임 내 화폐
5. **퀘스트 아이템(Quest Item)**: 퀘스트 완료를 위해 필요한 특수 아이템
 
  
## 10.2 아이템 데이터 모델링

### 10.2.1 MySQL 테이블 설계
먼저 아이템과 인벤토리를 위한 데이터베이스 테이블을 설계한다:  

```sql
-- 아이템 마스터 데이터 테이블
CREATE TABLE item_masters (
    id INT AUTO_INCREMENT PRIMARY KEY,
    code VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    type TINYINT NOT NULL COMMENT '1-장비, 2-소비품, 3-재료, 4-통화, 5-퀘스트아이템',
    sub_type TINYINT NOT NULL COMMENT '장비일 경우: 1-무기, 2-방어구, 3-액세서리 등',
    rarity TINYINT NOT NULL COMMENT '1-일반, 2-고급, 3-희귀, 4-전설, 5-신화',
    max_stack INT NOT NULL DEFAULT 1 COMMENT '최대 중첩 수량',
    sell_price INT NOT NULL DEFAULT 0 COMMENT '판매 가격',
    is_tradable BOOLEAN NOT NULL DEFAULT false COMMENT '거래 가능 여부',
    stats JSON NULL COMMENT '아이템 능력치 (장비의 경우)',
    use_effects JSON NULL COMMENT '사용 효과 (소비품의 경우)',
    icon_path VARCHAR(200) NULL COMMENT '아이콘 경로',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_item_type (type)
);

-- 플레이어 인벤토리 테이블
CREATE TABLE player_inventories (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    player_id BIGINT NOT NULL,
    item_id INT NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    slot_index INT NULL COMMENT '인벤토리 슬롯 인덱스',
    is_locked BOOLEAN NOT NULL DEFAULT false COMMENT '잠금 여부',
    expire_at TIMESTAMP NULL COMMENT '만료 시간 (NULL은 영구)',
    attributes JSON NULL COMMENT '개별 아이템 속성 (강화 레벨 등)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_player_id (player_id),
    INDEX idx_item_id (item_id),
);

-- 장비 장착 정보 테이블
CREATE TABLE player_equipments (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    player_id BIGINT NOT NULL,
    character_id BIGINT NOT NULL,
    inventory_id BIGINT NOT NULL,
    slot_type TINYINT NOT NULL COMMENT '1-무기, 2-갑옷, 3-투구, 4-장갑, 5-신발, 6-액세서리1, 7-액세서리2',
    equipped_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uq_char_slot (character_id, slot_type),
);
```

### 10.2.2 엔티티 클래스 설계
C# 프로젝트에서 MySQL 테이블에 매핑되는 엔티티 클래스를 만든다:

```csharp
// Models/Items/ItemMaster.cs
public class ItemMaster
{
    public int Id { get; set; }
    public string Code { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public byte Type { get; set; }
    public byte SubType { get; set; }
    public byte Rarity { get; set; }
    public int MaxStack { get; set; }
    public int SellPrice { get; set; }
    public bool IsTradable { get; set; }
    public string Stats { get; set; } // JSON 문자열
    public string UseEffects { get; set; } // JSON 문자열
    public string IconPath { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    
    // 타입 상수
    public const byte TYPE_EQUIPMENT = 1;
    public const byte TYPE_CONSUMABLE = 2;
    public const byte TYPE_MATERIAL = 3;
    public const byte TYPE_CURRENCY = 4;
    public const byte TYPE_QUEST = 5;
    
    // 희귀도 상수
    public const byte RARITY_COMMON = 1;
    public const byte RARITY_UNCOMMON = 2;
    public const byte RARITY_RARE = 3;
    public const byte RARITY_EPIC = 4;
    public const byte RARITY_LEGENDARY = 5;
    
    // 장비 서브타입 상수
    public const byte EQUIP_WEAPON = 1;
    public const byte EQUIP_ARMOR = 2;
    public const byte EQUIP_ACCESSORY = 3;
    
    // JSON 속성 핸들링을 위한 확장 속성
    public Dictionary<string, int> StatsDict
    {
        get => string.IsNullOrEmpty(Stats) 
            ? new Dictionary<string, int>() 
            : System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, int>>(Stats);
        set => Stats = System.Text.Json.JsonSerializer.Serialize(value);
    }
    
    public List<ItemEffect> UseEffectsList
    {
        get => string.IsNullOrEmpty(UseEffects) 
            ? new List<ItemEffect>() 
            : System.Text.Json.JsonSerializer.Deserialize<List<ItemEffect>>(UseEffects);
        set => UseEffects = System.Text.Json.JsonSerializer.Serialize(value);
    }
}

// Models/Items/PlayerInventory.cs
public class PlayerInventory
{
    public long Id { get; set; }
    public long PlayerId { get; set; }
    public int ItemId { get; set; }
    public int Quantity { get; set; }
    public int? SlotIndex { get; set; }
    public bool IsLocked { get; set; }
    public DateTime? ExpireAt { get; set; }
    public string Attributes { get; set; } // JSON 문자열
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    
    // 탐색을 위한 참조 (실제 조인 결과 저장)
    [System.Text.Json.Serialization.JsonIgnore]
    public ItemMaster Item { get; set; }
    
    // JSON 속성 핸들링을 위한 확장 속성
    public Dictionary<string, object> AttributesDict
    {
        get => string.IsNullOrEmpty(Attributes) 
            ? new Dictionary<string, object>() 
            : System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, object>>(Attributes);
        set => Attributes = System.Text.Json.JsonSerializer.Serialize(value);
    }
    
    // 강화 레벨 간편 접근 속성
    public int EnhanceLevel
    {
        get
        {
            if (AttributesDict.TryGetValue("enhance_level", out var level))
            {
                return Convert.ToInt32(level);
            }
            return 0;
        }
        set
        {
            var attrs = AttributesDict;
            attrs["enhance_level"] = value;
            AttributesDict = attrs;
        }
    }
}

// Models/Items/PlayerEquipment.cs
public class PlayerEquipment
{
    public long Id { get; set; }
    public long PlayerId { get; set; }
    public long CharacterId { get; set; }
    public long InventoryId { get; set; }
    public byte SlotType { get; set; }
    public DateTime EquippedAt { get; set; }
    
    // 슬롯 타입 상수
    public const byte SLOT_WEAPON = 1;
    public const byte SLOT_ARMOR = 2;
    public const byte SLOT_HELMET = 3;
    public const byte SLOT_GLOVES = 4;
    public const byte SLOT_BOOTS = 5;
    public const byte SLOT_ACCESSORY1 = 6;
    public const byte SLOT_ACCESSORY2 = 7;
}

// Models/Items/ItemEffect.cs
public class ItemEffect
{
    public string Type { get; set; }
    public string Target { get; set; }
    public int Value { get; set; }
    public int Duration { get; set; } // 초 단위, 0은 영구
    
    // 효과 타입 상수
    public const string EFFECT_HEAL = "heal";
    public const string EFFECT_BUFF = "buff";
    public const string EFFECT_DEBUFF = "debuff";
    public const string EFFECT_DAMAGE = "damage";
    public const string EFFECT_RESOURCE = "resource"; // 자원 추가
}
```
  
  
## 10.3 인벤토리 관리 API 개발

### 10.3.1 데이터 액세스 레이어
먼저 MySqlConnector와 SqlKata를 사용하여 인벤토리 및 아이템 데이터 액세스 레이어를 구현한다:  

```csharp
// Services/Items/ItemRepository.cs
using MySqlConnector;
using SqlKata.Execution;
using SqlKata.Compilers;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

public class ItemRepository
{
    private readonly QueryFactory _queryFactory;
    
    public ItemRepository(string connectionString)
    {
        var connection = new MySqlConnection(connectionString);
        var compiler = new MySqlCompiler();
        _queryFactory = new QueryFactory(connection, compiler);
    }
    
    // 아이템 마스터 데이터 조회
    public async Task<ItemMaster> GetItemMasterByIdAsync(int id)
    {
        return await _queryFactory.Query("item_masters")
            .Where("id", id)
            .FirstOrDefaultAsync<ItemMaster>();
    }
    
    public async Task<ItemMaster> GetItemMasterByCodeAsync(string code)
    {
        return await _queryFactory.Query("item_masters")
            .Where("code", code)
            .FirstOrDefaultAsync<ItemMaster>();
    }
    
    // 플레이어의 인벤토리 아이템 조회
    public async Task<List<PlayerInventory>> GetPlayerInventoryAsync(long playerId)
    {
        var items = await _queryFactory.Query("player_inventories")
            .Where("player_id", playerId)
            .OrderBy("slot_index")
            .GetAsync<PlayerInventory>();
            
        var result = new List<PlayerInventory>();
        foreach (var item in items)
        {
            item.Item = await GetItemMasterByIdAsync(item.ItemId);
            result.Add(item);
        }
        
        return result;
    }
    
    // 특정 아이템 인벤토리 조회
    public async Task<PlayerInventory> GetInventoryItemAsync(long inventoryId)
    {
        var item = await _queryFactory.Query("player_inventories")
            .Where("id", inventoryId)
            .FirstOrDefaultAsync<PlayerInventory>();
            
        if (item != null)
        {
            item.Item = await GetItemMasterByIdAsync(item.ItemId);
        }
        
        return item;
    }
    
    // 같은 아이템이 있는지 확인 (중첩 가능한 아이템)
    public async Task<PlayerInventory> FindStackableInventoryItemAsync(long playerId, int itemId)
    {
        var item = await _queryFactory.Query("player_inventories")
            .Where("player_id", playerId)
            .Where("item_id", itemId)
            .Where("quantity < (SELECT max_stack FROM item_masters WHERE id = item_id)")
            .FirstOrDefaultAsync<PlayerInventory>();
            
        if (item != null)
        {
            item.Item = await GetItemMasterByIdAsync(item.ItemId);
        }
        
        return item;
    }
    
    // 인벤토리에 아이템 추가
    public async Task<long> AddInventoryItemAsync(PlayerInventory item)
    {
        return await _queryFactory.Query("player_inventories").InsertGetIdAsync<long>(new {
            player_id = item.PlayerId,
            item_id = item.ItemId,
            quantity = item.Quantity,
            slot_index = item.SlotIndex,
            is_locked = item.IsLocked,
            expire_at = item.ExpireAt,
            attributes = item.Attributes,
            created_at = DateTime.UtcNow,
            updated_at = DateTime.UtcNow
        });
    }
    
    // 인벤토리 아이템 수량 업데이트
    public async Task<bool> UpdateInventoryItemQuantityAsync(long inventoryId, int quantity)
    {
        int affectedRows = await _queryFactory.Query("player_inventories")
            .Where("id", inventoryId)
            .UpdateAsync(new {
                quantity = quantity,
                updated_at = DateTime.UtcNow
            });
            
        return affectedRows > 0;
    }
    
    // 인벤토리 아이템 속성 업데이트
    public async Task<bool> UpdateInventoryItemAttributesAsync(long inventoryId, string attributes)
    {
        int affectedRows = await _queryFactory.Query("player_inventories")
            .Where("id", inventoryId)
            .UpdateAsync(new {
                attributes = attributes,
                updated_at = DateTime.UtcNow
            });
            
        return affectedRows > 0;
    }
    
    // 인벤토리 아이템 삭제
    public async Task<bool> RemoveInventoryItemAsync(long inventoryId)
    {
        int affectedRows = await _queryFactory.Query("player_inventories")
            .Where("id", inventoryId)
            .DeleteAsync();
            
        return affectedRows > 0;
    }
    
    // 장비 장착 정보 추가
    public async Task<long> EquipItemAsync(PlayerEquipment equipment)
    {
        // 먼저 같은 슬롯에 장착된 장비가 있는지 확인하고 제거
        await _queryFactory.Query("player_equipments")
            .Where("character_id", equipment.CharacterId)
            .Where("slot_type", equipment.SlotType)
            .DeleteAsync();
            
        // 새 장비 장착
        return await _queryFactory.Query("player_equipments").InsertGetIdAsync<long>(new {
            player_id = equipment.PlayerId,
            character_id = equipment.CharacterId,
            inventory_id = equipment.InventoryId,
            slot_type = equipment.SlotType,
            equipped_at = DateTime.UtcNow
        });
    }
    
    // 장비 해제
    public async Task<bool> UnequipItemAsync(long characterId, byte slotType)
    {
        int affectedRows = await _queryFactory.Query("player_equipments")
            .Where("character_id", characterId)
            .Where("slot_type", slotType)
            .DeleteAsync();
            
        return affectedRows > 0;
    }
    
    // 캐릭터의 장착 장비 조회
    public async Task<Dictionary<byte, PlayerInventory>> GetCharacterEquipmentsAsync(long characterId)
    {
        var equipments = await _queryFactory.Query("player_equipments")
            .Where("character_id", characterId)
            .GetAsync<PlayerEquipment>();
            
        var result = new Dictionary<byte, PlayerInventory>();
        
        foreach (var equipment in equipments)
        {
            var inventoryItem = await GetInventoryItemAsync(equipment.InventoryId);
            if (inventoryItem != null)
            {
                result[equipment.SlotType] = inventoryItem;
            }
        }
        
        return result;
    }
}
```

### 10.3.2 인벤토리 서비스 구현
비즈니스 로직을 처리할 인벤토리 서비스를 구현한다:  

```csharp
// Services/Items/InventoryService.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

public class InventoryService
{
    private readonly ItemRepository _itemRepository;
    private readonly InventoryCacheService _cacheService;
    
    public InventoryService(ItemRepository itemRepository, InventoryCacheService cacheService)
    {
        _itemRepository = itemRepository;
        _cacheService = cacheService;
    }
    
    // 플레이어 인벤토리 조회
    public async Task<List<PlayerInventory>> GetPlayerInventoryAsync(long playerId)
    {
        // 캐시에서 먼저 조회 시도
        var cachedInventory = await _cacheService.GetPlayerInventoryAsync(playerId);
        if (cachedInventory != null)
        {
            return cachedInventory;
        }
        
        // DB에서 조회
        var inventory = await _itemRepository.GetPlayerInventoryAsync(playerId);
        
        // 캐시에 저장
        if (inventory != null && inventory.Count > 0)
        {
            await _cacheService.SetPlayerInventoryAsync(playerId, inventory);
        }
        
        return inventory;
    }
    
    // 특정 인벤토리 아이템 조회
    public async Task<PlayerInventory> GetInventoryItemAsync(long inventoryId)
    {
        // 캐시에서 먼저 조회 시도
        var cachedItem = await _cacheService.GetInventoryItemAsync(inventoryId);
        if (cachedItem != null)
        {
            return cachedItem;
        }
        
        // DB에서 조회
        var item = await _itemRepository.GetInventoryItemAsync(inventoryId);
        
        // 캐시에 저장
        if (item != null)
        {
            await _cacheService.SetInventoryItemAsync(item);
        }
        
        return item;
    }
    
    // 아이템 획득 처리
    public async Task<PlayerInventory> AddItemToInventoryAsync(long playerId, string itemCode, int quantity = 1, Dictionary<string, object> attributes = null)
    {
        // 아이템 마스터 데이터 조회
        var itemMaster = await _itemRepository.GetItemMasterByCodeAsync(itemCode);
        if (itemMaster == null)
        {
            throw new Exception($"Item not found: {itemCode}");
        }
        
        // 중첩 가능한 아이템인지 확인
        if (itemMaster.MaxStack > 1)
        {
            // 이미 있는 같은 아이템을 찾아서 수량 추가
            var existingItem = await _itemRepository.FindStackableInventoryItemAsync(playerId, itemMaster.Id);
            if (existingItem != null)
            {
                int newQuantity = existingItem.Quantity + quantity;
                // 최대 중첩 수량 제한
                if (newQuantity > itemMaster.MaxStack)
                {
                    // 초과분은 다른 슬롯에 추가
                    int overflow = newQuantity - itemMaster.MaxStack;
                    await _itemRepository.UpdateInventoryItemQuantityAsync(existingItem.Id, itemMaster.MaxStack);
                    
                    // 캐시 업데이트
                    existingItem.Quantity = itemMaster.MaxStack;
                    await _cacheService.SetInventoryItemAsync(existingItem);
                    
                    // 남은 수량으로 재귀 호출
                    return await AddItemToInventoryAsync(playerId, itemCode, overflow, attributes);
                }
                else
                {
                    // 수량 업데이트
                    await _itemRepository.UpdateInventoryItemQuantityAsync(existingItem.Id, newQuantity);
                    
                    // 캐시 업데이트
                    existingItem.Quantity = newQuantity;
                    await _cacheService.SetInventoryItemAsync(existingItem);
                    await _cacheService.InvalidatePlayerInventoryCache(playerId);
                    
                    return existingItem;
                }
            }
        }
        
        // 새 인벤토리 아이템 생성
        var newItem = new PlayerInventory
        {
            PlayerId = playerId,
            ItemId = itemMaster.Id,
            Quantity = Math.Min(quantity, itemMaster.MaxStack),
            IsLocked = false,
            AttributesDict = attributes ?? new Dictionary<string, object>()
        };
        
        // 빈 슬롯 찾기 (여기서는 간단히 null로 설정하고 클라이언트에서 정렬)
        newItem.SlotIndex = null;
        
        // DB에 저장
        newItem.Id = await _itemRepository.AddInventoryItemAsync(newItem);
        
        // 아이템 마스터 정보 설정
        newItem.Item = itemMaster;
        
        // 캐시 업데이트
        await _cacheService.SetInventoryItemAsync(newItem);
        await _cacheService.InvalidatePlayerInventoryCache(playerId);
        
        // 수량이 최대 중첩을 초과하는 경우 재귀 호출로 나머지 처리
        if (quantity > itemMaster.MaxStack)
        {
            int remaining = quantity - itemMaster.MaxStack;
            await AddItemToInventoryAsync(playerId, itemCode, remaining, attributes);
        }
        
        return newItem;
    }
    
    // 아이템 사용 (소비품)
    public async Task<ItemUseResult> UseItemAsync(long playerId, long inventoryId)
    {
        var inventoryItem = await GetInventoryItemAsync(inventoryId);
        if (inventoryItem == null || inventoryItem.PlayerId != playerId)
        {
            throw new Exception("Item not found or doesn't belong to player");
        }
        
        var itemMaster = inventoryItem.Item;
        if (itemMaster.Type != ItemMaster.TYPE_CONSUMABLE)
        {
            throw new Exception("Cannot use non-consumable item");
        }
        
        if (inventoryItem.Quantity <= 0)
        {
            throw new Exception("Item quantity is 0");
        }
        
        // 효과 목록 생성
        var effects = itemMaster.UseEffectsList;
        
        // 수량 감소
        int newQuantity = inventoryItem.Quantity - 1;
        if (newQuantity <= 0)
        {
            // 아이템 삭제
            await _itemRepository.RemoveInventoryItemAsync(inventoryId);
            
            // 캐시 업데이트
            await _cacheService.InvalidateInventoryItemCache(inventoryId);
        }
        else
        {
            // 수량 업데이트
            await _itemRepository.UpdateInventoryItemQuantityAsync(inventoryId, newQuantity);
            
            // 캐시 업데이트
            inventoryItem.Quantity = newQuantity;
            await _cacheService.SetInventoryItemAsync(inventoryItem);
        }
        
        await _cacheService.InvalidatePlayerInventoryCache(playerId);
        
        // 아이템 사용 결과 반환
        return new ItemUseResult
        {
            Effects = effects,
            RemainingQuantity = newQuantity
        };
    }
    
    // 아이템 삭제
    public async Task<bool> RemoveItemAsync(long playerId, long inventoryId, int quantity = 1)
    {
        var inventoryItem = await GetInventoryItemAsync(inventoryId);
        if (inventoryItem == null || inventoryItem.PlayerId != playerId)
        {
            throw new Exception("Item not found or doesn't belong to player");
        }
        
        if (inventoryItem.Quantity < quantity)
        {
            throw new Exception("Not enough quantity");
        }
        
        int newQuantity = inventoryItem.Quantity - quantity;
        if (newQuantity <= 0)
        {
            // 아이템 삭제
            await _itemRepository.RemoveInventoryItemAsync(inventoryId);
            
            // 캐시 업데이트
            await _cacheService.InvalidateInventoryItemCache(inventoryId);
        }
        else
        {
            // 수량 업데이트
            await _itemRepository.UpdateInventoryItemQuantityAsync(inventoryId, newQuantity);
            
            // 캐시 업데이트
            inventoryItem.Quantity = newQuantity;
            await _cacheService.SetInventoryItemAsync(inventoryItem);
        }
        
        await _cacheService.InvalidatePlayerInventoryCache(playerId);
        
        return true;
    }
    
    // 장비 장착
    public async Task<bool> EquipItemAsync(long playerId, long characterId, long inventoryId, byte slotType)
    {
        var inventoryItem = await GetInventoryItemAsync(inventoryId);
        if (inventoryItem == null || inventoryItem.PlayerId != playerId)
        {
            throw new Exception("Item not found or doesn't belong to player");
        }
        
        var itemMaster = inventoryItem.Item;
        if (itemMaster.Type != ItemMaster.TYPE_EQUIPMENT)
        {
            throw new Exception("Cannot equip non-equipment item");
        }
        
        // 슬롯 타입과 아이템 타입 검증
        // (여기서는 간단히 처리, 실제로는 더 복잡한 검증 필요)
        if ((slotType == PlayerEquipment.SLOT_WEAPON && itemMaster.SubType != ItemMaster.EQUIP_WEAPON) ||
            (slotType >= PlayerEquipment.SLOT_ARMOR && slotType <= PlayerEquipment.SLOT_BOOTS && itemMaster.SubType != ItemMaster.EQUIP_ARMOR) ||
            (slotType >= PlayerEquipment.SLOT_ACCESSORY1 && itemMaster.SubType != ItemMaster.EQUIP_ACCESSORY))
        {
            throw new Exception("Item type doesn't match slot type");
        }
        
        // 장비 장착 정보 생성
        var equipment = new PlayerEquipment
        {
            PlayerId = playerId,
            CharacterId = characterId,
            InventoryId = inventoryId,
            SlotType = slotType
        };
        
        // DB에 저장
        await _itemRepository.EquipItemAsync(equipment);
        
        // 캐시 업데이트 (캐릭터 장비 캐시)
        await _cacheService.InvalidateCharacterEquipmentsCache(characterId);
        
        return true;
    }
    
    // 장비 해제
    public async Task<bool> UnequipItemAsync(long playerId, long characterId, byte slotType)
    {
        // 캐릭터 소유 확인 로직 필요 (여기서는 생략)
        
        // 장비 해제
        await _itemRepository.UnequipItemAsync(characterId, slotType);
        
        // 캐시 업데이트
        await _cacheService.InvalidateCharacterEquipmentsCache(characterId);
        
        return true;
    }
    
    // 캐릭터 장비 조회
    public async Task<Dictionary<byte, PlayerInventory>> GetCharacterEquipmentsAsync(long characterId)
    {
        // 캐시에서 먼저 조회 시도
        var cachedEquipments = await _cacheService.GetCharacterEquipmentsAsync(characterId);
        if (cachedEquipments != null)
        {
            return cachedEquipments;
        }
        
        // DB에서 조회
        var equipments = await _itemRepository.GetCharacterEquipmentsAsync(characterId);
        
        // 캐시에 저장
        if (equipments != null && equipments.Count > 0)
        {
            await _cacheService.SetCharacterEquipmentsAsync(characterId, equipments);
        }
        
        return equipments;
    }
    
    // 아이템 강화
    public async Task<PlayerInventory> EnhanceItemAsync(long playerId, long inventoryId)
    {
        var inventoryItem = await GetInventoryItemAsync(inventoryId);
        if (inventoryItem == null || inventoryItem.PlayerId != playerId)
        {
            throw new Exception("Item not found or doesn't belong to player");
        }
        
        var itemMaster = inventoryItem.Item;
        if (itemMaster.Type != ItemMaster.TYPE_EQUIPMENT)
        {
            throw new Exception("Cannot enhance non-equipment item");
        }
        
        // 현재 강화 레벨 가져오기
        int currentLevel = inventoryItem.EnhanceLevel;
        
        // 최대 강화 레벨 (예: 10)
        int maxEnhanceLevel = 10;
        
        if (currentLevel >= maxEnhanceLevel)
        {
            throw new Exception("Item is already at max enhance level");
        }
        
        // 강화 레벨 증가
        inventoryItem.EnhanceLevel = currentLevel + 1;
        
        // DB 업데이트
        await _itemRepository.UpdateInventoryItemAttributesAsync(inventoryId, inventoryItem.Attributes);
        
        // 캐시 업데이트
        await _cacheService.SetInventoryItemAsync(inventoryItem);
        
        return inventoryItem;
    }
}

// 아이템 사용 결과 클래스
public class ItemUseResult
{
    public List<ItemEffect> Effects { get; set; }
    public int RemainingQuantity { get; set; }
}
```
  

### 10.3.3 Web API 컨트롤러
ASP.NET Core Web API 컨트롤러를 구현한다:

```csharp
// Controllers/InventoryController.cs
using Microsoft.AspNetCore.Mvc;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

[ApiController]
[Route("api/inventory")]
public class InventoryController : ControllerBase
{
    private readonly InventoryService _inventoryService;
    
    public InventoryController(InventoryService inventoryService)
    {
        _inventoryService = inventoryService;
    }
    
    // 인벤토리 목록 조회
    [HttpPost("list")]
    public async Task<InventoryListResponse> GetInventoryList([FromBody] InventoryListRequest request)
    {
        try
        {
            var inventory = await _inventoryService.GetPlayerInventoryAsync(request.PlayerId);
            
            return new InventoryListResponse
            {
                Success = true,
                Items = inventory
            };
        }
        catch (Exception ex)
        {
            return new InventoryListResponse
            {
                Success = false,
                ErrorCode = 500,
                ErrorMessage = ex.Message
            };
        }
    }
    
    // 아이템 획득
    [HttpPost("add")]
    public async Task<AddItemResponse> AddItem([FromBody] AddItemRequest request)
    {
        try
        {
            var addedItem = await _inventoryService.AddItemToInventoryAsync(
                request.PlayerId, 
                request.ItemCode, 
                request.Quantity, 
                request.Attributes);
            
            return new AddItemResponse
            {
                Success = true,
                Item = addedItem
            };
        }
        catch (Exception ex)
        {
            return new AddItemResponse
            {
                Success = false,
                ErrorCode = 500,
                ErrorMessage = ex.Message
            };
        }
    }
    
    // 아이템 사용
    [HttpPost("use")]
    public async Task<UseItemResponse> UseItem([FromBody] UseItemRequest request)
    {
        try
        {
            var result = await _inventoryService.UseItemAsync(request.PlayerId, request.InventoryId);
            
            return new UseItemResponse
            {
                Success = true,
                Effects = result.Effects,
                RemainingQuantity = result.RemainingQuantity
            };
        }
        catch (Exception ex)
        {
            return new UseItemResponse
            {
                Success = false,
                ErrorCode = 500,
                ErrorMessage = ex.Message
            };
        }
    }
    
    // 아이템 삭제
    [HttpPost("remove")]
    public async Task<RemoveItemResponse> RemoveItem([FromBody] RemoveItemRequest request)
    {
        try
        {
            await _inventoryService.RemoveItemAsync(request.PlayerId, request.InventoryId, request.Quantity);
            
            return new RemoveItemResponse
            {
                Success = true
            };
        }
        catch (Exception ex)
        {
            return new RemoveItemResponse
            {
                Success = false,
                ErrorCode = 500,
                ErrorMessage = ex.Message
            };
        }
    }
    
    // 장비 장착
    [HttpPost("equip")]
    public async Task<EquipItemResponse> EquipItem([FromBody] EquipItemRequest request)
    {
        try
        {
            await _inventoryService.EquipItemAsync(
                request.PlayerId, 
                request.CharacterId, 
                request.InventoryId, 
                request.SlotType);
            
            return new EquipItemResponse
            {
                Success = true
            };
        }
        catch (Exception ex)
        {
            return new EquipItemResponse
            {
                Success = false,
                ErrorCode = 500,
                ErrorMessage = ex.Message
            };
        }
    }
    
    // 장비 해제
    [HttpPost("unequip")]
    public async Task<UnequipItemResponse> UnequipItem([FromBody] UnequipItemRequest request)
    {
        try
        {
            await _inventoryService.UnequipItemAsync(
                request.PlayerId, 
                request.CharacterId, 
                request.SlotType);
            
            return new UnequipItemResponse
            {
                Success = true
            };
        }
        catch (Exception ex)
        {
            return new UnequipItemResponse
            {
                Success = false,
                ErrorCode = 500,
                ErrorMessage = ex.Message
            };
        }
    }
    
    // 캐릭터 장비 조회
    [HttpPost("equipment/list")]
    public async Task<CharacterEquipmentResponse> GetCharacterEquipment([FromBody] CharacterEquipmentRequest request)
    {
        try
        {
            var equipments = await _inventoryService.GetCharacterEquipmentsAsync(request.CharacterId);
            
            return new CharacterEquipmentResponse
            {
                Success = true,
                Equipments = equipments
            };
        }
        catch (Exception ex)
        {
            return new CharacterEquipmentResponse
            {
                Success = false,
                ErrorCode = 500,
                ErrorMessage = ex.Message
            };
        }
    }
    
    // 아이템 강화
    [HttpPost("enhance")]
    public async Task<EnhanceItemResponse> EnhanceItem([FromBody] EnhanceItemRequest request)
    {
        try
        {
            var enhancedItem = await _inventoryService.EnhanceItemAsync(
                request.PlayerId, 
                request.InventoryId);
            
            return new EnhanceItemResponse
            {
                Success = true,
                Item = enhancedItem
            };
        }
        catch (Exception ex)
        {
            return new EnhanceItemResponse
            {
                Success = false,
                ErrorCode = 500,
                ErrorMessage = ex.Message
            };
        }
    }
}
```

### 10.3.4 API 요청/응답 모델
API에서 사용할 요청 및 응답 모델을 정의한다:  

```csharp
// Models/Items/Requests.cs
public class InventoryListRequest
{
    public long PlayerId { get; set; }
}

public class AddItemRequest
{
    public long PlayerId { get; set; }
    public string ItemCode { get; set; }
    public int Quantity { get; set; } = 1;
    public Dictionary<string, object> Attributes { get; set; }
}

public class UseItemRequest
{
    public long PlayerId { get; set; }
    public long InventoryId { get; set; }
}

public class RemoveItemRequest
{
    public long PlayerId { get; set; }
    public long InventoryId { get; set; }
    public int Quantity { get; set; } = 1;
}

public class EquipItemRequest
{
    public long PlayerId { get; set; }
    public long CharacterId { get; set; }
    public long InventoryId { get; set; }
    public byte SlotType { get; set; }
}

public class UnequipItemRequest
{
    public long PlayerId { get; set; }
    public long CharacterId { get; set; }
    public byte SlotType { get; set; }
}

public class CharacterEquipmentRequest
{
    public long CharacterId { get; set; }
}

public class EnhanceItemRequest
{
    public long PlayerId { get; set; }
    public long InventoryId { get; set; }
}

// Models/Items/Responses.cs
public class BaseResponse
{
    public bool Success { get; set; }
    public int ErrorCode { get; set; }
    public string ErrorMessage { get; set; }
}

public class InventoryListResponse : BaseResponse
{
    public List<PlayerInventory> Items { get; set; }
}

public class AddItemResponse : BaseResponse
{
    public PlayerInventory Item { get; set; }
}

public class UseItemResponse : BaseResponse
{
    public List<ItemEffect> Effects { get; set; }
    public int RemainingQuantity { get; set; }
}

public class RemoveItemResponse : BaseResponse
{
}

public class EquipItemResponse : BaseResponse
{
}

public class UnequipItemResponse : BaseResponse
{
}

public class CharacterEquipmentResponse : BaseResponse
{
    public Dictionary<byte, PlayerInventory> Equipments { get; set; }
}

public class EnhanceItemResponse : BaseResponse
{
    public PlayerInventory Item { get; set; }
}
```
  

## 10.4 아이템 획득 및 소비 로직 구현
게임에서 아이템을 획득하고 소비하는 핵심 로직에 대해 자세히 살펴보자.

### 10.4.1 아이템 획득 로직 흐름
수집형 RPG에서 아이템을 획득하는 경로는 다양하다:

1. **퀘스트 보상**: 퀘스트 완료 시 지급되는 아이템
2. **몬스터 드롭**: 몬스터 처치 시 드롭되는 아이템
3. **상점 구매**: 게임 내 상점에서 구매하는 아이템
4. **가챠(뽑기)**: 랜덤 아이템 획득 시스템
5. **이벤트 보상**: 특별 이벤트에서 지급되는 아이템

이러한 다양한 경로에서 공통으로 사용할 수 있는 아이템 획득 로직 구현 예시를 살펴보자:

```csharp
// Services/Items/ItemAcquisitionService.cs
public class ItemAcquisitionService
{
    private readonly InventoryService _inventoryService;
    private readonly Random _random = new Random();
    
    public ItemAcquisitionService(InventoryService inventoryService)
    {
        _inventoryService = inventoryService;
    }
    
    // 퀘스트 보상 지급
    public async Task<List<PlayerInventory>> GrantQuestRewardsAsync(long playerId, string questCode)
    {
        // 퀘스트 보상 정의 (실제로는 DB에서 로드)
        var rewards = GetQuestRewards(questCode);
        
        var acquiredItems = new List<PlayerInventory>();
        
        foreach (var reward in rewards)
        {
            var item = await _inventoryService.AddItemToInventoryAsync(
                playerId, 
                reward.ItemCode, 
                reward.Quantity);
                
            acquiredItems.Add(item);
        }
        
        return acquiredItems;
    }
    
    // 몬스터 드롭 아이템 생성
    public async Task<List<PlayerInventory>> GenerateMonsterDropsAsync(long playerId, string monsterId)
    {
        // 몬스터별 드롭 테이블 (실제로는 DB에서 로드)
        var dropTable = GetMonsterDropTable(monsterId);
        
        var droppedItems = new List<PlayerInventory>();
        
        foreach (var dropEntry in dropTable)
        {
            // 드롭 확률 계산
            if (_random.NextDouble() <= dropEntry.DropRate)
            {
                // 수량 범위가 있는 경우 랜덤 생성
                int quantity = dropEntry.MinQuantity;
                if (dropEntry.MaxQuantity > dropEntry.MinQuantity)
                {
                    quantity = _random.Next(dropEntry.MinQuantity, dropEntry.MaxQuantity + 1);
                }
                
                var item = await _inventoryService.AddItemToInventoryAsync(
                    playerId,
                    dropEntry.ItemCode,
                    quantity);
                    
                droppedItems.Add(item);
            }
        }
        
        return droppedItems;
    }
    
    // 가챠 (뽑기) 시스템
    public async Task<PlayerInventory> PerformGachaAsync(long playerId, string gachaType)
    {
        // 가챠 풀 정의 (실제로는 DB에서 로드)
        var gachaPool = GetGachaPool(gachaType);
        
        // 총 확률 합계
        double totalWeight = gachaPool.Sum(entry => entry.Weight);
        
        // 랜덤 값 생성
        double randomValue = _random.NextDouble() * totalWeight;
        
        // 선택된 아이템 찾기
        double accumulatedWeight = 0;
        GachaEntry selectedEntry = null;
        
        foreach (var entry in gachaPool)
        {
            accumulatedWeight += entry.Weight;
            if (randomValue <= accumulatedWeight)
            {
                selectedEntry = entry;
                break;
            }
        }
        
        if (selectedEntry == null)
        {
            throw new Exception("Failed to select an item from gacha");
        }
        
        // 선택된 아이템 지급
        return await _inventoryService.AddItemToInventoryAsync(
            playerId,
            selectedEntry.ItemCode,
            1);
    }
    
    // 여러 아이템 한번에 지급 (다양한 보상에 사용)
    public async Task<List<PlayerInventory>> GrantMultipleItemsAsync(long playerId, List<ItemGrant> items)
    {
        var acquiredItems = new List<PlayerInventory>();
        
        foreach (var itemGrant in items)
        {
            var item = await _inventoryService.AddItemToInventoryAsync(
                playerId,
                itemGrant.ItemCode,
                itemGrant.Quantity,
                itemGrant.Attributes);
                
            acquiredItems.Add(item);
        }
        
        return acquiredItems;
    }
    
    // 테스트용 퀘스트 보상 정의
    private List<ItemGrant> GetQuestRewards(string questCode)
    {
        // 실제로는 DB에서 로드
        var questRewards = new Dictionary<string, List<ItemGrant>>
        {
            ["quest_101"] = new List<ItemGrant>
            {
                new ItemGrant { ItemCode = "gold", Quantity = 100 },
                new ItemGrant { ItemCode = "potion_small", Quantity = 3 }
            },
            ["quest_102"] = new List<ItemGrant>
            {
                new ItemGrant { ItemCode = "gold", Quantity = 200 },
                new ItemGrant { ItemCode = "sword_basic", Quantity = 1 }
            }
        };
        
        if (questRewards.TryGetValue(questCode, out var rewards))
        {
            return rewards;
        }
        
        return new List<ItemGrant>();
    }
    
    // 테스트용 몬스터 드롭 테이블 정의
    private List<MonsterDropEntry> GetMonsterDropTable(string monsterId)
    {
        // 실제로는 DB에서 로드
        var dropTables = new Dictionary<string, List<MonsterDropEntry>>
        {
            ["monster_001"] = new List<MonsterDropEntry>
            {
                new MonsterDropEntry { ItemCode = "gold", DropRate = 1.0, MinQuantity = 1, MaxQuantity = 10 },
                new MonsterDropEntry { ItemCode = "potion_small", DropRate = 0.3, MinQuantity = 1, MaxQuantity = 1 }
            },
            ["monster_002"] = new List<MonsterDropEntry>
            {
                new MonsterDropEntry { ItemCode = "gold", DropRate = 1.0, MinQuantity = 5, MaxQuantity = 20 },
                new MonsterDropEntry { ItemCode = "material_iron", DropRate = 0.5, MinQuantity = 1, MaxQuantity = 3 },
                new MonsterDropEntry { ItemCode = "armor_basic", DropRate = 0.1, MinQuantity = 1, MaxQuantity = 1 }
            }
        };
        
        if (dropTables.TryGetValue(monsterId, out var dropTable))
        {
            return dropTable;
        }
        
        return new List<MonsterDropEntry>();
    }
    
    // 테스트용 가챠 풀 정의
    private List<GachaEntry> GetGachaPool(string gachaType)
    {
        // 실제로는 DB에서 로드
        var gachaPools = new Dictionary<string, List<GachaEntry>>
        {
            ["gacha_character"] = new List<GachaEntry>
            {
                new GachaEntry { ItemCode = "character_101", Weight = 75.0 }, // 일반 (75%)
                new GachaEntry { ItemCode = "character_201", Weight = 20.0 }, // 고급 (20%)
                new GachaEntry { ItemCode = "character_301", Weight = 4.0 },  // 희귀 (4%)
                new GachaEntry { ItemCode = "character_401", Weight = 1.0 }   // 전설 (1%)
            },
            ["gacha_weapon"] = new List<GachaEntry>
            {
                new GachaEntry { ItemCode = "weapon_101", Weight = 60.0 },    // 일반 (60%)
                new GachaEntry { ItemCode = "weapon_201", Weight = 30.0 },    // 고급 (30%)
                new GachaEntry { ItemCode = "weapon_301", Weight = 9.0 },     // 희귀 (9%)
                new GachaEntry { ItemCode = "weapon_401", Weight = 1.0 }      // 전설 (1%)
            }
        };
        
        if (gachaPools.TryGetValue(gachaType, out var gachaPool))
        {
            return gachaPool;
        }
        
        return new List<GachaEntry>();
    }
}

// 아이템 지급 정보 클래스
public class ItemGrant
{
    public string ItemCode { get; set; }
    public int Quantity { get; set; }
    public Dictionary<string, object> Attributes { get; set; }
}

// 몬스터 드롭 항목 클래스
public class MonsterDropEntry
{
    public string ItemCode { get; set; }
    public double DropRate { get; set; } // 0.0 ~ 1.0
    public int MinQuantity { get; set; }
    public int MaxQuantity { get; set; }
}

// 가챠 항목 클래스
public class GachaEntry
{
    public string ItemCode { get; set; }
    public double Weight { get; set; } // 가중치 (확률)
}
```

### 10.4.2 아이템 소비 로직 흐름
아이템 소비는 다양한 방식으로 이루어질 수 있다:

1. **소비품 사용**: 포션 등의 소비품 사용
2. **장비 사용**: 장비 아이템 장착/해제
3. **재료 소비**: 강화, 제작 등에 재료 소비
4. **아이템 판매**: 상점에 아이템 판매

다음은 아이템 소비 관련 로직 구현 예시이다:

```csharp
// Services/Items/ItemConsumptionService.cs
public class ItemConsumptionService
{
    private readonly InventoryService _inventoryService;
    private readonly CharacterService _characterService; // 캐릭터 서비스 (전 장에서 구현)
    
    public ItemConsumptionService(InventoryService inventoryService, CharacterService characterService)
    {
        _inventoryService = inventoryService;
        _characterService = characterService;
    }
    
    // 소비품 아이템 사용
    public async Task<ItemEffectResult> UseConsumableItemAsync(long playerId, long inventoryId)
    {
        var result = await _inventoryService.UseItemAsync(playerId, inventoryId);
        
        // 아이템 효과 처리
        var effectResults = new List<EffectResult>();
        
        foreach (var effect in result.Effects)
        {
            var effectResult = await ProcessItemEffectAsync(playerId, effect);
            effectResults.Add(effectResult);
        }
        
        return new ItemEffectResult
        {
            EffectResults = effectResults,
            RemainingQuantity = result.RemainingQuantity
        };
    }
    
    // 아이템 효과 처리
    private async Task<EffectResult> ProcessItemEffectAsync(long playerId, ItemEffect effect)
    {
        var effectResult = new EffectResult
        {
            Type = effect.Type,
            Target = effect.Target,
            Value = effect.Value,
            Success = true
        };
        
        switch (effect.Type)
        {
            case ItemEffect.EFFECT_HEAL:
                // 치유 효과 처리 (캐릭터 HP 회복 등)
                if (long.TryParse(effect.Target, out var characterId))
                {
                    // 해당 캐릭터의 HP 회복 로직
                    // (실제 구현은 생략, 캐릭터 서비스 필요)
                    effectResult.Message = $"Healed character {characterId} for {effect.Value} HP";
                }
                break;
                
            case ItemEffect.EFFECT_BUFF:
                // 버프 효과 처리
                if (long.TryParse(effect.Target, out var buffCharacterId))
                {
                    // 해당 캐릭터에게 버프 적용 로직
                    effectResult.Message = $"Applied {effect.Target} buff to character {buffCharacterId} for {effect.Duration} seconds";
                }
                break;
                
            case ItemEffect.EFFECT_RESOURCE:
                // 자원 추가 처리 (재화, 스태미나 등)
                if (effect.Target == "gold")
                {
                    // 골드 추가 로직
                    // (실제 구현은 생략, 플레이어 재화 서비스 필요)
                    effectResult.Message = $"Added {effect.Value} gold";
                }
                else if (effect.Target == "stamina")
                {
                    // 스태미나 추가 로직
                    effectResult.Message = $"Restored {effect.Value} stamina";
                }
                break;
                
            default:
                effectResult.Success = false;
                effectResult.Message = $"Unknown effect type: {effect.Type}";
                break;
        }
        
        return effectResult;
    }
    
    // 장비 강화에 재료 소비
    public async Task<EnhanceResult> EnhanceEquipmentAsync(
        long playerId, 
        long equipmentId, 
        List<long> materialIds)
    {
        // 장비 아이템 조회
        var equipment = await _inventoryService.GetInventoryItemAsync(equipmentId);
        if (equipment == null || equipment.PlayerId != playerId)
        {
            throw new Exception("Equipment not found or doesn't belong to player");
        }
        
        // 장비 타입 확인
        if (equipment.Item.Type != ItemMaster.TYPE_EQUIPMENT)
        {
            throw new Exception("Item is not equipment");
        }
        
        // 재료 아이템 조회 및 검증
        var materials = new List<PlayerInventory>();
        foreach (var materialId in materialIds)
        {
            var material = await _inventoryService.GetInventoryItemAsync(materialId);
            if (material == null || material.PlayerId != playerId)
            {
                throw new Exception($"Material item not found: {materialId}");
            }
            materials.Add(material);
        }
        
        // 현재 강화 레벨
        int currentLevel = equipment.EnhanceLevel;
        
        // 강화 성공 확률 계산 (간단히 구현)
        double successRate = CalculateEnhanceSuccessRate(currentLevel, materials);
        
        // 재료 소비
        foreach (var material in materials)
        {
            await _inventoryService.RemoveItemAsync(playerId, material.Id, 1);
        }
        
        // 강화 성공 여부 결정
        bool success = new Random().NextDouble() <= successRate;
        
        if (success)
        {
            // 강화 성공
            await _inventoryService.EnhanceItemAsync(playerId, equipmentId);
            
            return new EnhanceResult
            {
                Success = true,
                NewLevel = currentLevel + 1,
                Message = "Enhancement successful!"
            };
        }
        else
        {
            // 강화 실패
            return new EnhanceResult
            {
                Success = false,
                NewLevel = currentLevel,
                Message = "Enhancement failed!"
            };
        }
    }
    
    // 강화 성공률 계산 (간단한 예시)
    private double CalculateEnhanceSuccessRate(int currentLevel, List<PlayerInventory> materials)
    {
        // 기본 성공률 (레벨에 따라 감소)
        double baseRate = Math.Max(0.1, 1.0 - (currentLevel * 0.1));
        
        // 재료로 인한 추가 성공률
        double materialBonus = 0;
        foreach (var material in materials)
        {
            // 재료의 희귀도에 따라 추가 성공률 부여
            materialBonus += 0.05 * material.Item.Rarity;
        }
        
        // 최종 성공률 (최대 95%)
        return Math.Min(0.95, baseRate + materialBonus);
    }
    
    // 아이템 판매
    public async Task<SellResult> SellItemsAsync(long playerId, List<SellItemEntry> sellItems)
    {
        int totalGold = 0;
        
        foreach (var sellItem in sellItems)
        {
            // 아이템 조회
            var item = await _inventoryService.GetInventoryItemAsync(sellItem.InventoryId);
            if (item == null || item.PlayerId != playerId)
            {
                throw new Exception($"Item not found: {sellItem.InventoryId}");
            }
            
            // 수량 확인
            if (item.Quantity < sellItem.Quantity)
            {
                throw new Exception($"Not enough quantity for item: {sellItem.InventoryId}");
            }
            
            // 판매 가격 계산
            int sellPrice = item.Item.SellPrice * sellItem.Quantity;
            totalGold += sellPrice;
            
            // 아이템 제거
            await _inventoryService.RemoveItemAsync(playerId, sellItem.InventoryId, sellItem.Quantity);
        }
        
        // 골드 지급 (실제로는 플레이어 재화 서비스 필요)
        // await _currencyService.AddCurrencyAsync(playerId, "gold", totalGold);
        
        return new SellResult
        {
            Success = true,
            GoldEarned = totalGold
        };
    }
}

// 아이템 효과 처리 결과 클래스
public class ItemEffectResult
{
    public List<EffectResult> EffectResults { get; set; }
    public int RemainingQuantity { get; set; }
}

public class EffectResult
{
    public string Type { get; set; }
    public string Target { get; set; }
    public int Value { get; set; }
    public bool Success { get; set; }
    public string Message { get; set; }
}

// 강화 결과 클래스
public class EnhanceResult
{
    public bool Success { get; set; }
    public int NewLevel { get; set; }
    public string Message { get; set; }
}

// 아이템 판매 항목 클래스
public class SellItemEntry
{
    public long InventoryId { get; set; }
    public int Quantity { get; set; }
}

// 판매 결과 클래스
public class SellResult
{
    public bool Success { get; set; }
    public int GoldEarned { get; set; }
}
```
  

## 10.5 Redis를 활용한 인벤토리 데이터 캐싱
게임 서버에서 데이터베이스 접근을 최소화하고 성능을 향상시키기 위해 Redis 캐싱을 구현한다.  

### 10.5.1 CloudStructures를 사용한 캐시 서비스 구현

```csharp
// Services/Cache/InventoryCacheService.cs
using CloudStructures;
using CloudStructures.Structures;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

public class InventoryCacheService
{
    private readonly RedisConnection _redisConnection;
    private readonly TimeSpan _defaultExpiry = TimeSpan.FromHours(1);
    
    public InventoryCacheService(RedisConnection redisConnection)
    {
        _redisConnection = redisConnection;
    }
    
    // 인벤토리 아이템 단일 캐싱 키 생성
    private string GetInventoryItemKey(long inventoryId)
    {
        return $"inventory:item:{inventoryId}";
    }
    
    // 플레이어의 전체 인벤토리 캐싱 키 생성
    private string GetPlayerInventoryKey(long playerId)
    {
        return $"player:{playerId}:inventory";
    }
    
    // 캐릭터 장비 캐싱 키 생성
    private string GetCharacterEquipmentsKey(long characterId)
    {
        return $"character:{characterId}:equipments";
    }
    
    // 단일 인벤토리 아이템 캐싱
    public async Task SetInventoryItemAsync(PlayerInventory item)
    {
        var redis = new RedisString<PlayerInventory>(_redisConnection, 
            GetInventoryItemKey(item.Id), _defaultExpiry);
        
        await redis.SetAsync(item);
    }
    
    // 단일 인벤토리 아이템 조회
    public async Task<PlayerInventory> GetInventoryItemAsync(long inventoryId)
    {
        var redis = new RedisString<PlayerInventory>(_redisConnection, 
            GetInventoryItemKey(inventoryId), _defaultExpiry);
        
        var result = await redis.GetAsync();
        return result.HasValue ? result.Value : null;
    }
    
    // 플레이어 인벤토리 전체 캐싱
    public async Task SetPlayerInventoryAsync(long playerId, List<PlayerInventory> inventory)
    {
        var redis = new RedisString<List<PlayerInventory>>(_redisConnection, 
            GetPlayerInventoryKey(playerId), _defaultExpiry);
        
        await redis.SetAsync(inventory);
    }
    
    // 플레이어 인벤토리 전체 조회
    public async Task<List<PlayerInventory>> GetPlayerInventoryAsync(long playerId)
    {
        var redis = new RedisString<List<PlayerInventory>>(_redisConnection, 
            GetPlayerInventoryKey(playerId), _defaultExpiry);
        
        var result = await redis.GetAsync();
        return result.HasValue ? result.Value : null;
    }
    
    // 캐릭터 장비 캐싱
    public async Task SetCharacterEquipmentsAsync(long characterId, Dictionary<byte, PlayerInventory> equipments)
    {
        var redis = new RedisString<Dictionary<byte, PlayerInventory>>(_redisConnection, 
            GetCharacterEquipmentsKey(characterId), _defaultExpiry);
        
        await redis.SetAsync(equipments);
    }
    
    // 캐릭터 장비 조회
    public async Task<Dictionary<byte, PlayerInventory>> GetCharacterEquipmentsAsync(long characterId)
    {
        var redis = new RedisString<Dictionary<byte, PlayerInventory>>(_redisConnection, 
            GetCharacterEquipmentsKey(characterId), _defaultExpiry);
        
        var result = await redis.GetAsync();
        return result.HasValue ? result.Value : null;
    }
    
    // 플레이어 인벤토리 캐시 무효화
    public async Task InvalidatePlayerInventoryCache(long playerId)
    {
        var redis = new RedisKey(_redisConnection, GetPlayerInventoryKey(playerId));
        await redis.DeleteAsync();
    }
    
    // 단일 인벤토리 아이템 캐시 무효화
    public async Task InvalidateInventoryItemCache(long inventoryId)
    {
        var redis = new RedisKey(_redisConnection, GetInventoryItemKey(inventoryId));
        await redis.DeleteAsync();
    }
    
    // 캐릭터 장비 캐시 무효화
    public async Task InvalidateCharacterEquipmentsCache(long characterId)
    {
        var redis = new RedisKey(_redisConnection, GetCharacterEquipmentsKey(characterId));
        await redis.DeleteAsync();
    }
}
```
  

## 10.6 HTTP 테스트 파일 작성
클라이언트 코드 대신 .http 파일을 사용해 API를 테스트한다.  

```http
// inventory.http
@baseUrl = http://localhost:5000/api/inventory
@playerId = 1001
@characterId = 1

### 인벤토리 목록 조회
POST {{baseUrl}}/list
Content-Type: application/json

{
    "PlayerId": {{playerId}}
}

### 아이템 획득
POST {{baseUrl}}/add
Content-Type: application/json

{
    "PlayerId": {{playerId}},
    "ItemCode": "potion_small",
    "Quantity": 5
}

### 장비 아이템 획득
POST {{baseUrl}}/add
Content-Type: application/json

{
    "PlayerId": {{playerId}},
    "ItemCode": "sword_basic",
    "Quantity": 1,
    "Attributes": {
        "enhance_level": 0,
        "durability": 100
    }
}

### 아이템 사용 (소비품)
POST {{baseUrl}}/use
Content-Type: application/json

{
    "PlayerId": {{playerId}},
    "InventoryId": 1
}

### 아이템 삭제
POST {{baseUrl}}/remove
Content-Type: application/json

{
    "PlayerId": {{playerId}},
    "InventoryId": 2,
    "Quantity": 1
}

### 장비 장착
POST {{baseUrl}}/equip
Content-Type: application/json

{
    "PlayerId": {{playerId}},
    "CharacterId": {{characterId}},
    "InventoryId": 3,
    "SlotType": 1
}

### 장비 해제
POST {{baseUrl}}/unequip
Content-Type: application/json

{
    "PlayerId": {{playerId}},
    "CharacterId": {{characterId}},
    "SlotType": 1
}

### 캐릭터 장비 조회
POST {{baseUrl}}/equipment/list
Content-Type: application/json

{
    "CharacterId": {{characterId}}
}

### 아이템 강화
POST {{baseUrl}}/enhance
Content-Type: application/json

{
    "PlayerId": {{playerId}},
    "InventoryId": 3
}
```
  

## 요약
이 장에서는 ASP.NET Core Web API를 사용하여 RPG 게임의 인벤토리 및 아이템 시스템을 구현했다. 주요 내용은 다음과 같다:

1. 아이템 시스템의 데이터베이스 설계 및 엔티티 클래스 구현
2. 인벤토리 관리 API 개발 (목록 조회, 아이템 추가/삭제/사용)
3. 장비 시스템 구현 (장착/해제, 강화)
4. 아이템 획득 및 소비 로직 구현 (퀘스트 보상, 몬스터 드롭, 가챠 시스템 등)
5. Redis를 활용한 인벤토리 데이터 캐싱
6. .http 파일을 사용한 API 테스트

이러한 기능들은 수집형 RPG 게임의 핵심 요소로, 게임 내 아이템 관리와 플레이어 진행을 위한 중요한 시스템이다. MySQL과 Redis를 활용하여 데이터를 효율적으로 관리하고, ASP.NET Core Web API로 클라이언트와의 통신을 처리하는 방법을 배웠다.
    

