# ASP.NET Core Web APIë¡œ ê²Œì„ ì„œë²„ ê°œë°œ
  
ì €ì: ìµœí¥ë°°, Claude AI   
-----------------------     
 
# Chapter 6. Redis ìºì‹œ ì‹œìŠ¤í…œ êµ¬í˜„

## 6.1 ê²Œì„ ì„œë²„ì—ì„œ Redisì˜ í•„ìš”ì„±
ìˆ˜ì§‘í˜• RPG ê²Œì„ ì„œë²„ëŠ” ìˆ˜ë§ì€ ë™ì‹œ ìš”ì²­ì„ ì²˜ë¦¬í•´ì•¼ í•œë‹¤. ì‚¬ìš©ìê°€ ì¦ê°€í• ìˆ˜ë¡ ë°ì´í„°ë² ì´ìŠ¤ì— ê°€í•´ì§€ëŠ” ë¶€í•˜ë„ ì¦ê°€í•œë‹¤.   ì´ëŸ¬í•œ ë¶€í•˜ë¥¼ ì¤„ì´ê³  ì‘ë‹µ ì‹œê°„ì„ ê°œì„ í•˜ê¸° ìœ„í•´ Redisì™€ ê°™ì€ ì¸ë©”ëª¨ë¦¬ ìºì‹œ ì‹œìŠ¤í…œì´ í•„ìš”í•˜ë‹¤.  

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     â”‚       â”‚                     â”‚      â”‚                     â”‚
â”‚   í´ë¼ì´ì–¸íŠ¸ ìš”ì²­     â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚   ASP.NET Core      â”‚â—„â”€â”€â”€â”€â–ºâ”‚     Redis ìºì‹œ       â”‚
â”‚                     â”‚       â”‚   Web API Server    â”‚      â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚                     â”‚      â”‚  - ë¹ ë¥¸ ì½ê¸°/ì“°ê¸°     â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚  - ì„¸ì…˜ ë°ì´í„°        â”‚
                                         â”‚                 â”‚  - ì„ì‹œ ê²Œì„ ë°ì´í„°   â”‚
                                         â–¼                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
                              â”‚                     â”‚               â”‚
                              â”‚     MySQL DB        â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚                     â”‚      (í•„ìš”ì‹œ ì˜êµ¬ ì €ì¥)
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.1.1 Redisê°€ ê²Œì„ ì„œë²„ì—ì„œ í•´ê²°í•˜ëŠ” ë¬¸ì œ
- **ë°ì´í„°ë² ì´ìŠ¤ ë¶€í•˜ ê°ì†Œ**: ìì£¼ ì ‘ê·¼í•˜ëŠ” ë°ì´í„°ë¥¼ ìºì‹±í•˜ì—¬ MySQL ë¶€í•˜ ê°ì†Œ
- **ë¹ ë¥¸ ì‘ë‹µ ì‹œê°„**: ì¸ë©”ëª¨ë¦¬ ìºì‹œë¡œ ë°€ë¦¬ì´ˆ ë‹¨ìœ„ì˜ ë¹ ë¥¸ ì‘ë‹µ ì œê³µ
- **ì„ì‹œ ë°ì´í„° ì €ì¥**: ì„¸ì…˜ ì •ë³´, ì„ì‹œ ê²Œì„ ìƒíƒœ ë“±ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬
- **ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬**: ë­í‚¹, ì±„íŒ…, ì•Œë¦¼ ë“± ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬ì— ì í•©
- **ë¶„ì‚° ì‹œìŠ¤í…œ ì§€ì›**: ì—¬ëŸ¬ ì„œë²„ ì¸ìŠ¤í„´ìŠ¤ ê°„ ë°ì´í„° ê³µìœ  ê°€ëŠ¥
  

## 6.2 CloudStructures ë¼ì´ë¸ŒëŸ¬ë¦¬ ì†Œê°œ
CloudStructuresëŠ” StackExchange.Redis ê¸°ë°˜ì˜ ê³ ìˆ˜ì¤€ Redis í´ë¼ì´ì–¸íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‹¤. íƒ€ì… ì•ˆì „ì„±ê³¼ ë¹„ë™ê¸° ì‘ì—…ì„ ì§€ì›í•˜ì—¬ .NET í™˜ê²½ì—ì„œ Redisë¥¼ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.

### 6.2.1 CloudStructuresì˜ ì£¼ìš” íŠ¹ì§•
- **íƒ€ì… ì•ˆì „ì„±**: ì œë„¤ë¦­ íƒ€ì…ì„ í™œìš©í•œ íƒ€ì… ì•ˆì „í•œ ë°ì´í„° ì²˜ë¦¬
- **ë¹„ë™ê¸° ì§€ì›**: Task ê¸°ë°˜ ë¹„ë™ê¸° ì‘ì—… ì§€ì›
- **ì§ë ¬í™” ì§€ì›**: MessagePack, JSON ë“± ë‹¤ì–‘í•œ ì§ë ¬í™” ì˜µì…˜
- **ê³ ìˆ˜ì¤€ ì¶”ìƒí™”**: Redis ë°ì´í„° êµ¬ì¡°ë¥¼ C# í´ë˜ìŠ¤ë¡œ ì¶”ìƒí™”
- **í’ë¶€í•œ ë°ì´í„° êµ¬ì¡°**: String, Hash, List, Set, Sorted Set ë“± Redis ë°ì´í„° êµ¬ì¡° ì§€ì›
  
#### CloudStructuresì˜ ì§ë ¬í™” ì˜µì…˜ë³„ ì˜ˆì œ ì½”ë“œ
  
**1. MessagePack ì§ë ¬í™” (ê¸°ë³¸ê°’)**  
```csharp
// ê¸°ë³¸ MessagePack ì§ë ¬í™” ì‚¬ìš©
var connection = new RedisConnection(connectionString);
var redis = new RedisString<Person>(connection, "user:1001", TimeSpan.FromMinutes(30));

var person = new Person { Name = "ê¹€ì² ìˆ˜", Age = 30, Email = "kim@example.com" };
await redis.SetAsync(person);

var retrievedPerson = await redis.GetAsync();
```
  
**2. JSON ì§ë ¬í™”**  
```csharp
// JSON ì§ë ¬í™” ì‚¬ìš©
var jsonConverter = new JsonValueConverter();
var redis = new RedisString<Person>(connection, "user:1002", TimeSpan.FromMinutes(30), jsonConverter);

var person = new Person { Name = "ì´ì˜í¬", Age = 25, Email = "lee@example.com" };
await redis.SetAsync(person);

// Redis CLIì—ì„œ í™•ì¸ ì‹œ JSON í˜•íƒœë¡œ ë³´ì„
// GET user:1002 -> {"Name":"ì´ì˜í¬","Age":25,"Email":"lee@example.com"}
```
  
**3. ì••ì¶•ëœ MessagePack**  
```csharp
// Gzip ì••ì¶•ê³¼ í•¨ê»˜ MessagePack ì‚¬ìš©
var compressedConverter = new GZipMessagePackValueConverter<Person>();
var redis = new RedisString<Person>(connection, "user:1003", TimeSpan.FromMinutes(30), compressedConverter);

await redis.SetAsync(person);
```
  
**4. ì‚¬ìš©ì ì •ì˜ ì§ë ¬í™”**  
```csharp
// ì»¤ìŠ¤í…€ ì»¨ë²„í„° êµ¬í˜„
public class CustomValueConverter<T> : IValueConverter<T>
{
    public RedisValue Serialize(T value)
    {
        // ì‚¬ìš©ì ì •ì˜ ì§ë ¬í™” ë¡œì§
        var json = JsonSerializer.Serialize(value);
        return $"CUSTOM:{json}";
    }

    public T Deserialize(RedisValue value)
    {
        // ì‚¬ìš©ì ì •ì˜ ì—­ì§ë ¬í™” ë¡œì§
        var jsonString = value.ToString().Substring(7); // "CUSTOM:" ì œê±°
        return JsonSerializer.Deserialize<T>(jsonString);
    }
}

// ì‚¬ìš©
var customConverter = new CustomValueConverter<Person>();
var redis = new RedisString<Person>(connection, "user:1004", TimeSpan.FromMinutes(30), customConverter);
```
  
**5. ì»¬ë ‰ì…˜ì—ì„œ ì§ë ¬í™” ì˜µì…˜ ì‚¬ìš©**  
```csharp
// Listì—ì„œ JSON ì§ë ¬í™” ì‚¬ìš©
var jsonConverter = new JsonValueConverter();
var redisList = new RedisList<Person>(connection, "users", jsonConverter);

await redisList.RightPushAsync(person);
var people = await redisList.RangeAsync(0, -1);
```

ê° ì§ë ¬í™” ë°©ì‹ì€ ì„±ëŠ¥ê³¼ ê°€ë…ì„± ì¸¡ë©´ì—ì„œ ì„œë¡œ ë‹¤ë¥¸ ì¥ë‹¨ì ì„ ê°€ì§€ë¯€ë¡œ í”„ë¡œì íŠ¸ ìš”êµ¬ì‚¬í•­ì— ë§ê²Œ ì„ íƒí•œë‹¤.   
  
  
## 6.3 CloudStructures ì„¤ì¹˜ ë° ì„¤ì •

### 6.3.1 NuGet íŒ¨í‚¤ì§€ ì„¤ì¹˜

```bash
dotnet add package CloudStructures
```

### 6.3.2 ê¸°ë³¸ ì„¤ì •

`appsettings.json` íŒŒì¼ì— Redis ì—°ê²° ì„¤ì •ì„ ì¶”ê°€í•œë‹¤:

```json
{
  "Redis": {
    "Configuration": "localhost:6379",
    "DefaultDatabase": 0,
    "ConnectionTimeout": 5000,
    "Password": ""
  }
}
```

### 6.3.3 DI ì»¨í…Œì´ë„ˆì— ì„œë¹„ìŠ¤ ë“±ë¡
`Program.cs` íŒŒì¼ì— CloudStructures ì„œë¹„ìŠ¤ë¥¼ ë“±ë¡í•œë‹¤:

```csharp
// Program.cs
using CloudStructures;
using CloudStructures.Structures;
using StackExchange.Redis;

// Redis ì„¤ì • ë¡œë“œ
var redisOptions = builder.Configuration.GetSection("Redis").Get<RedisOptions>();
var redisConfig = new RedisConfig("Default", redisOptions.Configuration, redisOptions.DefaultDatabase);
builder.Services.AddSingleton(redisConfig);

// ì¼ë°˜ì ì¸ Redis ì‘ì—…ì„ ìœ„í•œ ì„œë¹„ìŠ¤ ë“±ë¡
builder.Services.AddSingleton<IRedisService, RedisService>();

// ì„¸ì…˜ ê´€ë¦¬ë¥¼ ìœ„í•œ ì„œë¹„ìŠ¤ ë“±ë¡
builder.Services.AddSingleton<IPlayerSessionService, PlayerSessionService>();
```

### 6.3.4 RedisOptions ë° RedisService í´ë˜ìŠ¤ êµ¬í˜„

```csharp
// Models/Redis/RedisOptions.cs
public class RedisOptions
{
    public string Configuration { get; set; }
    public int DefaultDatabase { get; set; }
    public int ConnectionTimeout { get; set; }
    public string Password { get; set; }
}
```

```csharp
// Services/Redis/RedisService.cs
public interface IRedisService
{
    Task<T> GetAsync<T>(string key);
    Task<bool> SetAsync<T>(string key, T value, TimeSpan? expiry = null);
    Task<bool> DeleteAsync(string key);
    Task<bool> ExistsAsync(string key);
    Task<long> IncrementAsync(string key, long value = 1);
    Task<double> IncrementFloatAsync(string key, double value);
    Task<bool> ExpireAsync(string key, TimeSpan expiry);
    Task<TimeSpan?> GetTimeToLiveAsync(string key);
}

public class RedisService : IRedisService
{
    private readonly RedisConfig _redisConfig;

    public RedisService(RedisConfig redisConfig)
    {
        _redisConfig = redisConfig;
    }

    public async Task<T> GetAsync<T>(string key)
    {
        var redis = new RedisString<T>(_redisConfig, key);
        var result = await redis.GetAsync();
        return result.HasValue ? result.Value : default;
    }

    public async Task<bool> SetAsync<T>(string key, T value, TimeSpan? expiry = null)
    {
        var redis = new RedisString<T>(_redisConfig, key);
        return await redis.SetAsync(value, expiry);
    }

    public async Task<bool> DeleteAsync(string key)
    {
        var redis = new RedisString<object>(_redisConfig, key);
        return await redis.DeleteAsync();
    }

    public async Task<bool> ExistsAsync(string key)
    {
        var redis = new RedisString<object>(_redisConfig, key);
        return await redis.ExistsAsync();
    }

    public async Task<long> IncrementAsync(string key, long value = 1)
    {
        var redis = new RedisString<long>(_redisConfig, key);
        return await redis.IncrementAsync(value);
    }

    public async Task<double> IncrementFloatAsync(string key, double value)
    {
        var redis = new RedisString<double>(_redisConfig, key);
        return await redis.IncrementAsync(value);
    }

    public async Task<bool> ExpireAsync(string key, TimeSpan expiry)
    {
        var redis = new RedisString<object>(_redisConfig, key);
        return await redis.ExpireAsync(expiry);
    }

    public async Task<TimeSpan?> GetTimeToLiveAsync(string key)
    {
        var redis = new RedisString<object>(_redisConfig, key);
        return await redis.GetTimeToLiveAsync();
    }
}
```
  
  
## 6.4 ê²Œì„ ë°ì´í„° ìºì‹± ì „ëµ

### 6.4.1 ìºì‹± íŒ¨í„´
ê²Œì„ ì„œë²„ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì£¼ìš” ìºì‹± íŒ¨í„´ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

#### 1. ìºì‹œ-ì–´ì‚¬ì´ë“œ (Cache-Aside) íŒ¨í„´
ê°€ì¥ ì¼ë°˜ì ì¸ íŒ¨í„´ìœ¼ë¡œ, ë°ì´í„° ì¡°íšŒ ì‹œ ë¨¼ì € ìºì‹œë¥¼ í™•ì¸í•˜ê³  ì—†ìœ¼ë©´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ í›„ ìºì‹œì— ì €ì¥í•œë‹¤.

![ìºì‹œ-ì–´ì‚¬ì´ë“œ (Cache-Aside) íŒ¨í„´](./images/027.png)   

```csharp
public async Task<Player> GetPlayerByIdAsync(int playerId)
{
    // 1. ìºì‹œì—ì„œ ì¡°íšŒ
    string cacheKey = $"player:{playerId}";
    var player = await _redisService.GetAsync<Player>(cacheKey);
    
    if (player != null)
    {
        return player; // ìºì‹œ íˆíŠ¸
    }
    
    // 2. ìºì‹œì— ì—†ìœ¼ë©´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
    player = await _playerRepository.GetByIdAsync(playerId);
    
    if (player != null)
    {
        // 3. ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒí•œ ê²°ê³¼ë¥¼ ìºì‹œì— ì €ì¥ (10ë¶„ ë§Œë£Œ)
        await _redisService.SetAsync(cacheKey, player, TimeSpan.FromMinutes(10));
    }
    
    return player;
}
```  
  
ìºì‹œ íˆíŠ¸ì¸ ê²½ìš°:  
- ì• í”Œë¦¬ì¼€ì´ì…˜ â†’ ìºì‹œ ì¡°íšŒ â†’ ë°ì´í„° ì¡´ì¬ â†’ ì¦‰ì‹œ ë°˜í™˜
- ë¹ ë¥¸ ì‘ë‹µ ì‹œê°„, ë°ì´í„°ë² ì´ìŠ¤ ë¶€í•˜ ì—†ìŒ
  
ìºì‹œ ë¯¸ìŠ¤ì¸ ê²½ìš°:  
- ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ìºì‹œì—ì„œ ë°ì´í„° ì¡°íšŒ
- ìºì‹œì— ë°ì´í„° ì—†ìŒ (ë¯¸ìŠ¤)
- ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë°ì´í„° ì¡°íšŒ
- ì¡°íšŒí•œ ë°ì´í„°ë¥¼ ìºì‹œì— ì €ì¥ (TTL ì„¤ì •)
- ì• í”Œë¦¬ì¼€ì´ì…˜ì— ë°ì´í„° ë°˜í™˜
  
ì£¼ìš” íŠ¹ì§•:  
- ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ìºì‹œì™€ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ëª¨ë‘ ì§ì ‘ ê´€ë¦¬
- ê°€ì¥ ì¼ë°˜ì ì´ê³  êµ¬í˜„í•˜ê¸° ì‰¬ìš´ íŒ¨í„´
- ë°ì´í„° ì •í•©ì„±ì„ ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ ì œì–´
ìºì‹œ ë¬´íš¨í™” ë¡œì§ì„ ë³„ë„ë¡œ êµ¬í˜„í•´ì•¼ í•¨  
  
  
#### 2. ë¼ì´íŠ¸-ë¹„í•˜ì¸ë“œ (Write-Behind) íŒ¨í„´
ë°ì´í„°ë¥¼ ë¨¼ì € ìºì‹œì— ì“°ê³ , ë‚˜ì¤‘ì— ë¹„ë™ê¸°ì ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•œë‹¤. ì´ íŒ¨í„´ì€ ì“°ê¸° ì‘ì—…ì´ ë§ì€ ì‹œë‚˜ë¦¬ì˜¤ì— ì í•©í•˜ë‹¤.  
  
![](./images/028.png)       
  
```csharp
public async Task UpdatePlayerExperienceAsync(int playerId, int additionalExp)
{
    string cacheKey = $"player:{playerId}";
    
    // 1. ìºì‹œì—ì„œ í”Œë ˆì´ì–´ ë°ì´í„° ì¡°íšŒ
    var player = await _redisService.GetAsync<Player>(cacheKey);
    
    if (player == null)
    {
        // ìºì‹œì— ì—†ìœ¼ë©´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
        player = await _playerRepository.GetByIdAsync(playerId);
        
        if (player == null)
        {
            throw new NotFoundException("í”Œë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }
    }
    
    // 2. ê²½í—˜ì¹˜ ì—…ë°ì´íŠ¸
    player.Experience += additionalExp;
    
    // ê¸°ì¡´ ë ˆë²¨ ì €ì¥
    int oldLevel = player.Level;
    
    // ë ˆë²¨ì—… ì²´í¬ ë° ì²˜ë¦¬
    while (player.Experience >= GetExpForNextLevel(player.Level))
    {
        player.Level++;
    }
    
    // 3. ì—…ë°ì´íŠ¸ëœ ë°ì´í„°ë¥¼ ìºì‹œì— ì €ì¥
    await _redisService.SetAsync(cacheKey, player, TimeSpan.FromMinutes(10));
    
    // 4. ë³€ê²½ ì‚¬í•­ì„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
    _ = Task.Run(async () =>
    {
        try
        {
            await _playerRepository.UpdateAsync(player);
            
            // ë ˆë²¨ì—… ì´ë²¤íŠ¸ ë°œìƒ
            if (player.Level > oldLevel)
            {
                await _eventService.PublishLevelUpEventAsync(playerId, player.Level);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "í”Œë ˆì´ì–´ ê²½í—˜ì¹˜ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ. PlayerId: {PlayerId}", playerId);
            // ì¬ì‹œë„ ë¡œì§ ë˜ëŠ” ì˜¤ë¥˜ íì— ì¶”ê°€
        }
    });
}
```  
      
**ë™ì‘ ìˆœì„œ:**
1. **ë°ì´í„° ì¡°íšŒ**: ìºì‹œì—ì„œ ë¨¼ì € ì¡°íšŒ, ì—†ìœ¼ë©´ DBì—ì„œ ì¡°íšŒ
2. **ìºì‹œ ì—…ë°ì´íŠ¸**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì²˜ë¦¬ í›„ ìºì‹œì— ì¦‰ì‹œ ì €ì¥
3. **ì¦‰ì‹œ ì‘ë‹µ**: í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë°”ë¡œ ì‘ë‹µ ë°˜í™˜ (ë¹ ë¥¸ ì„±ëŠ¥)
4. **ë°±ê·¸ë¼ìš´ë“œ ì €ì¥**: `Task.Run()`ìœ¼ë¡œ ë¹„ë™ê¸°ì ìœ¼ë¡œ DB ì—…ë°ì´íŠ¸

**ì£¼ìš” ì¥ì :**
- ì“°ê¸° ì‘ì—…ì˜ ì‘ë‹µ ì‹œê°„ì´ ë§¤ìš° ë¹ ë¦„
- DB ë¶€í•˜ë¥¼ ì‹œê°„ì ìœ¼ë¡œ ë¶„ì‚°ì‹œí‚´
- ë°°ì¹˜ ì²˜ë¦¬ë¡œ íš¨ìœ¨ì„± í–¥ìƒ ê°€ëŠ¥

**ì£¼ìš” ë‹¨ì :**
- ìºì‹œì™€ DB ê°„ ì¼ì‹œì  ë¶ˆì¼ì¹˜ ë°œìƒ
- ì‹œìŠ¤í…œ ì¥ì•  ì‹œ ë°ì´í„° ì†ì‹¤ ìœ„í—˜
- ë³µì¡í•œ ì˜¤ë¥˜ ì²˜ë¦¬ ë° ì¬ì‹œë„ ë¡œì§ í•„ìš”

**ì ìš© ì˜ˆì‹œ:**
- ê²Œì„ì—ì„œ ê²½í—˜ì¹˜/ì ìˆ˜ ì—…ë°ì´íŠ¸
- ì‹¤ì‹œê°„ ì±„íŒ… ë©”ì‹œì§€ ì €ì¥
- ë¡œê·¸ ë°ì´í„° ìˆ˜ì§‘
- ì¹´ìš´í„°/í†µê³„ ì—…ë°ì´íŠ¸

ì´ íŒ¨í„´ì€ ì“°ê¸° ì„±ëŠ¥ì´ ì¤‘ìš”í•˜ê³  ì•½ê°„ì˜ ë°ì´í„° ì§€ì—°ì´ í—ˆìš©ë˜ëŠ” ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ë§¤ìš° ìœ ìš©í•˜ë‹¤.
  
  
#### 3. ì“°ê¸°-ìŠ¤ë£¨ (Write-Through) íŒ¨í„´
ë°ì´í„° ë³€ê²½ ì‹œ ìºì‹œì™€ ë°ì´í„°ë² ì´ìŠ¤ì— ë™ì‹œì— ì“°ëŠ” íŒ¨í„´ìœ¼ë¡œ, ë°ì´í„° ì¼ê´€ì„±ì´ ì¤‘ìš”í•œ ê²½ìš° ì‚¬ìš©í•œë‹¤.
  
![](./images/029.png)   

```csharp
public async Task<bool> UpdatePlayerGoldAsync(int playerId, int amount)
{
    string cacheKey = $"player:{playerId}";
    
    // íŠ¸ëœì­ì…˜ ì‹œì‘
    using var connection = new MySqlConnection(_connectionString);
    await connection.OpenAsync();
    using var transaction = await connection.BeginTransactionAsync();
    
    try
    {
        // 1. ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ í”Œë ˆì´ì–´ ì¡°íšŒ
        var player = await _playerRepository.GetByIdWithTransactionAsync(playerId, connection, transaction);
        
        if (player == null)
        {
            await transaction.RollbackAsync();
            return false;
        }
        
        // 2. ê³¨ë“œ ì—…ë°ì´íŠ¸
        player.Gold += amount;
        
        if (player.Gold < 0)
        {
            await transaction.RollbackAsync();
            return false; // ê³¨ë“œê°€ ë¶€ì¡±í•œ ê²½ìš°
        }
        
        // 3. ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
        await _playerRepository.UpdateWithTransactionAsync(player, connection, transaction);
        
        // 4. íŠ¸ëœì­ì…˜ ì»¤ë°‹
        await transaction.CommitAsync();
        
        // 5. ìºì‹œ ì—…ë°ì´íŠ¸
        await _redisService.SetAsync(cacheKey, player, TimeSpan.FromMinutes(10));
        
        return true;
    }
    catch (Exception)
    {
        await transaction.RollbackAsync();
        // ìºì‹œì—ì„œ í•´ë‹¹ í”Œë ˆì´ì–´ í‚¤ ì‚­ì œ (ì¼ê´€ì„± ìœ ì§€)
        await _redisService.DeleteAsync(cacheKey);
        throw;
    }
}
```
  
**í•µì‹¬ ì›ë¦¬: "DB ìš°ì„ , ìºì‹œ í›„"**
- ë°ì´í„°ë² ì´ìŠ¤ì— ë¨¼ì € ì €ì¥í•œ í›„ ìºì‹œ ì—…ë°ì´íŠ¸
- íŠ¸ëœì­ì…˜ì„ í†µí•œ ì›ìì„± ë³´ì¥
- ì˜¤ë¥˜ ë°œìƒ ì‹œ ì „ì²´ ë¡¤ë°±

**ì„±ê³µ ì‹œë‚˜ë¦¬ì˜¤:**
1. **íŠ¸ëœì­ì…˜ ì‹œì‘** â†’ DB ì—°ê²° ë° ë°ì´í„° ì¡°íšŒ
2. **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§** â†’ ê³¨ë“œ ê³„ì‚° ë° ìœ íš¨ì„± ê²€ì¦
3. **DB ì—…ë°ì´íŠ¸** â†’ ë°ì´í„° ì €ì¥ ë° íŠ¸ëœì­ì…˜ ì»¤ë°‹
4. **ìºì‹œ ì—…ë°ì´íŠ¸** â†’ ì¼ê´€ì„±ì„ ìœ„í•œ ìºì‹œ ë™ê¸°í™”
5. **ì„±ê³µ ì‘ë‹µ** â†’ í´ë¼ì´ì–¸íŠ¸ì— ê²°ê³¼ ë°˜í™˜

**ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤:**
- ì˜¤ë¥˜ ë°œìƒ ì‹œ íŠ¸ëœì­ì…˜ ë¡¤ë°±
- ìºì‹œ í‚¤ ì‚­ì œë¡œ ì¼ê´€ì„± ë³´ì¥
- ì˜ˆì™¸ ë°œìƒìœ¼ë¡œ ì‹¤íŒ¨ ì•Œë¦¼

**ì£¼ìš” ì¥ì :**
- ê°•ë ¥í•œ ë°ì´í„° ì¼ê´€ì„± ë³´ì¥
- ACID íŠ¸ëœì­ì…˜ íŠ¹ì„± í™œìš©
- ì¥ì•  ì‹œ ìë™ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜

**ì£¼ìš” ë‹¨ì :**
- ëŠë¦° ì“°ê¸° ì„±ëŠ¥ (DB ì‘ë‹µ ëŒ€ê¸°)
- ë†’ì€ ì‘ë‹µ ì§€ì—° ì‹œê°„
- ë³µì¡í•œ íŠ¸ëœì­ì…˜ ê´€ë¦¬

**ì ìš© ì‹œë‚˜ë¦¬ì˜¤:**
- ê¸ˆìœµ ê±°ë˜ (ì†¡ê¸ˆ, ê²°ì œ)
- ê²Œì„ ê³¨ë“œ/ì•„ì´í…œ ê±°ë˜
- ê³„ì • ì”ì•¡ ê´€ë¦¬
- ì¬ê³  ê´€ë¦¬ ì‹œìŠ¤í…œ

ì´ íŒ¨í„´ì€ ì„±ëŠ¥ë³´ë‹¤ ë°ì´í„° ì •í™•ì„±ê³¼ ì¼ê´€ì„±ì´ ë” ì¤‘ìš”í•œ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©í•œë‹¤.


### 6.4.2 ê²Œì„ ë°ì´í„° ìºì‹± ì „ëµ
ê²Œì„ ì„œë²„ì—ì„œ íš¨ê³¼ì ìœ¼ë¡œ ìºì‹±í•  ìˆ˜ ìˆëŠ” ë°ì´í„° ìœ í˜•ê³¼ ì „ëµì„ ì‚´í´ë³´ì:

#### 1. ì •ì  ë°ì´í„° ìºì‹±
ê²Œì„ì˜ ì •ì  ë°ì´í„°(ì•„ì´í…œ, ìŠ¤í‚¬, ìŠ¤í…Œì´ì§€ ì •ë³´ ë“±)ëŠ” ë³€ê²½ì´ ê±°ì˜ ì—†ìœ¼ë¯€ë¡œ ì¥ê¸° ìºì‹±ì— ì í•©í•˜ë‹¤.

```csharp
public async Task<List<GameItem>> GetAllGameItemsAsync()
{
    string cacheKey = "game:items:all";
    
    // 1. ìºì‹œì—ì„œ ì¡°íšŒ
    var items = await _redisService.GetAsync<List<GameItem>>(cacheKey);
    
    if (items != null)
    {
        return items;
    }
    
    // 2. ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
    items = await _itemRepository.GetAllItemsAsync();
    
    // 3. ìºì‹œì— ì €ì¥ (í•˜ë£¨ ë™ì•ˆ ìœ íš¨)
    await _redisService.SetAsync(cacheKey, items, TimeSpan.FromDays(1));
    
    return items;
}
```

#### 2. ì‚¬ìš©ì ë°ì´í„° ìºì‹±
ìì£¼ ë³€ê²½ë˜ëŠ” ì‚¬ìš©ì ë°ì´í„°(ë ˆë²¨, ê²½í—˜ì¹˜, ê³¨ë“œ ë“±)ëŠ” ì§§ì€ TTLë¡œ ìºì‹±í•œë‹¤.

```csharp
public async Task<PlayerStats> GetPlayerStatsAsync(int playerId)
{
    string cacheKey = $"player:{playerId}:stats";
    
    // 1. ìºì‹œì—ì„œ ì¡°íšŒ
    var stats = await _redisService.GetAsync<PlayerStats>(cacheKey);
    
    if (stats != null)
    {
        return stats;
    }
    
    // 2. ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
    var player = await _playerRepository.GetByIdAsync(playerId);
    
    if (player == null)
    {
        return null;
    }
    
    stats = new PlayerStats
    {
        PlayerId = player.Id,
        Level = player.Level,
        Experience = player.Experience,
        Gold = player.Gold,
        Gems = player.Gems,
        Power = await _playerService.CalculatePlayerPowerAsync(playerId)
    };
    
    // 3. ìºì‹œì— ì €ì¥ (5ë¶„ ë™ì•ˆ ìœ íš¨)
    await _redisService.SetAsync(cacheKey, stats, TimeSpan.FromMinutes(5));
    
    return stats;
}
```

#### 3. ì„¸ì…˜ ë°ì´í„° ê´€ë¦¬
í”Œë ˆì´ì–´ ì„¸ì…˜ ë°, ì¸ì¦ ì •ë³´ ë“± ì„ì‹œ ë°ì´í„° ê´€ë¦¬ì— Redisë¥¼ í™œìš©í•œë‹¤.
  
![Redis ì„¸ì…˜ ë°ì´í„° ê´€ë¦¬](./images/030.png)   

```csharp
// Services/PlayerSessionService.cs
public interface IPlayerSessionService
{
    Task<string> CreateSessionAsync(int playerId, string deviceId);
    Task<int?> ValidateSessionAsync(string sessionToken);
    Task<bool> InvalidateSessionAsync(string sessionToken);
}

public class PlayerSessionService : IPlayerSessionService
{
    private readonly RedisConfig _redisConfig;
    private readonly ILogger<PlayerSessionService> _logger;

    public PlayerSessionService(RedisConfig redisConfig, ILogger<PlayerSessionService> logger)
    {
        _redisConfig = redisConfig;
        _logger = logger;
    }

    public async Task<string> CreateSessionAsync(int playerId, string deviceId)
    {
        // ì„¸ì…˜ í† í° ìƒì„±
        string sessionToken = Guid.NewGuid().ToString("N");
        string sessionKey = $"session:{sessionToken}";
        
        // ì„¸ì…˜ ì •ë³´ ìƒì„±
        var sessionInfo = new PlayerSession
        {
            PlayerId = playerId,
            DeviceId = deviceId,
            CreatedAt = DateTime.UtcNow,
            LastActivityAt = DateTime.UtcNow
        };
        
        // Redisì— ì„¸ì…˜ ì €ì¥ (24ì‹œê°„ ìœ íš¨)
        var redis = new RedisString<PlayerSession>(_redisConfig, sessionKey);
        bool saved = await redis.SetAsync(sessionInfo, TimeSpan.FromHours(24));
        
        if (!saved)
        {
            _logger.LogError("ì„¸ì…˜ ì €ì¥ ì‹¤íŒ¨. PlayerId: {PlayerId}", playerId);
            return null;
        }
        
        // í”Œë ˆì´ì–´ID -> ì„¸ì…˜ í† í° ë§¤í•‘ ì €ì¥
        var playerSessionsKey = $"player:{playerId}:sessions";
        var playerSessions = new RedisSet<string>(_redisConfig, playerSessionsKey);
        await playerSessions.AddAsync(sessionToken);
        await playerSessions.ExpireAsync(TimeSpan.FromDays(7)); // í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ì€ 7ì¼ê°„ ìœ ì§€
        
        return sessionToken;
    }

    public async Task<int?> ValidateSessionAsync(string sessionToken)
    {
        if (string.IsNullOrEmpty(sessionToken))
        {
            return null;
        }
        
        string sessionKey = $"session:{sessionToken}";
        var redis = new RedisString<PlayerSession>(_redisConfig, sessionKey);
        var result = await redis.GetAsync();
        
        if (!result.HasValue)
        {
            return null; // ì„¸ì…˜ì´ ì—†ê±°ë‚˜ ë§Œë£Œë¨
        }
        
        var session = result.Value;
        
        // ì„¸ì…˜ í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸
        session.LastActivityAt = DateTime.UtcNow;
        await redis.SetAsync(session, TimeSpan.FromHours(24)); // ì„¸ì…˜ ê°±ì‹ 
        
        return session.PlayerId;
    }

    public async Task<bool> InvalidateSessionAsync(string sessionToken)
    {
        if (string.IsNullOrEmpty(sessionToken))
        {
            return false;
        }
        
        string sessionKey = $"session:{sessionToken}";
        
        // ì„¸ì…˜ ì •ë³´ ì¡°íšŒ
        var redis = new RedisString<PlayerSession>(_redisConfig, sessionKey);
        var result = await redis.GetAsync();
        
        if (result.HasValue)
        {
            var session = result.Value;
            
            // í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ì—ì„œ ì„¸ì…˜ í† í° ì œê±°
            var playerSessionsKey = $"player:{session.PlayerId}:sessions";
            var playerSessions = new RedisSet<string>(_redisConfig, playerSessionsKey);
            await playerSessions.RemoveAsync(sessionToken);
        }
        
        // ì„¸ì…˜ ì‚­ì œ
        return await redis.DeleteAsync();
    }
}

public class PlayerSession
{
    public int PlayerId { get; set; }
    public string DeviceId { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastActivityAt { get; set; }
}
```
  
**1. ì„¸ì…˜ ìƒì„± (CreateSessionAsync)**
- GUIDë¡œ ê³ ìœ í•œ ì„¸ì…˜ í† í° ìƒì„±
- Redisì— ë‘ ê°€ì§€ í‚¤ íŒ¨í„´ìœ¼ë¡œ ì €ì¥:
  - `session:{token}` â†’ PlayerSession ê°ì²´ (TTL: 24ì‹œê°„)
  - `player:{id}:sessions` â†’ ì„¸ì…˜ í† í° Set (TTL: 7ì¼)

**2. ì„¸ì…˜ ê²€ì¦ (ValidateSessionAsync)**
- í† í°ìœ¼ë¡œ Redisì—ì„œ ì„¸ì…˜ ì •ë³´ ì¡°íšŒ
- ì„¸ì…˜ ì¡´ì¬ ì‹œ LastActivityAt ê°±ì‹  ë° TTL ì—°ì¥
- PlayerId ë°˜í™˜ìœ¼ë¡œ ì¸ì¦ ì™„ë£Œ

**3. ì„¸ì…˜ ë¬´íš¨í™” (InvalidateSessionAsync)**
- ì„¸ì…˜ ì •ë³´ë¡œ PlayerId íšë“
- í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ì—ì„œ í† í° ì œê±°
- Redisì—ì„œ ì„¸ì…˜ ì™„ì „ ì‚­ì œ

**ì£¼ìš” ì¥ì :**
- **í™•ì¥ì„±**: ë¶„ì‚° í™˜ê²½ì—ì„œ ì„¸ì…˜ ê³µìœ  ê°€ëŠ¥
- **ì„±ëŠ¥**: Redisì˜ ë¹ ë¥¸ ë©”ëª¨ë¦¬ ê¸°ë°˜ ì ‘ê·¼
- **ìë™ ì •ë¦¬**: TTLì„ í†µí•œ ë§Œë£Œëœ ì„¸ì…˜ ìë™ ì‚­ì œ
- **ë³´ì•ˆ**: GUID í† í°ê³¼ ë””ë°”ì´ìŠ¤ ID ê²€ì¦

**ë°ì´í„° êµ¬ì¡°:**
- ì„¸ì…˜ë³„ ìƒì„¸ ì •ë³´ì™€ í”Œë ˆì´ì–´ë³„ ì„¸ì…˜ ëª©ë¡ì„ ë¶„ë¦¬ ì €ì¥
- ë‹¤ì¤‘ ë””ë°”ì´ìŠ¤ ë¡œê·¸ì¸ ì§€ì›
- ìë™ ë§Œë£Œ ì •ì±…ìœ¼ë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± í™•ë³´

ì´ êµ¬ì¡°ëŠ” ê²Œì„ ì„œë²„ì˜ ë‹¤ì¤‘ ì¸ìŠ¤í„´ìŠ¤ í™˜ê²½ì—ì„œë„ ì¼ê´€ëœ ì„¸ì…˜ ê´€ë¦¬ë¥¼ ì œê³µí•œë‹¤.


#### 4. ë­í‚¹ ì‹œìŠ¤í…œ êµ¬í˜„
Redisì˜ Sorted Setì„ í™œìš©í•œ íš¨ìœ¨ì ì¸ ë­í‚¹ ì‹œìŠ¤í…œì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```csharp
// Services/RankingService.cs
public interface IRankingService
{
    Task UpdatePlayerScoreAsync(int playerId, long score);
    Task<long?> GetPlayerScoreAsync(int playerId);
    Task<int?> GetPlayerRankAsync(int playerId);
    Task<List<RankingEntry>> GetTopRankingsAsync(int count = 100);
    Task<List<RankingEntry>> GetRankingsAroundPlayerAsync(int playerId, int range = 5);
}

public class RankingService : IRankingService
{
    private readonly RedisConfig _redisConfig;
    private readonly IPlayerRepository _playerRepository;
    private const string PowerRankingKey = "ranking:power";

    public RankingService(RedisConfig redisConfig, IPlayerRepository playerRepository)
    {
        _redisConfig = redisConfig;
        _playerRepository = playerRepository;
    }

    public async Task UpdatePlayerScoreAsync(int playerId, long score)
    {
        var redis = new RedisSortedSet<int>(_redisConfig, PowerRankingKey);
        await redis.AddAsync(playerId, score);
    }

    public async Task<long?> GetPlayerScoreAsync(int playerId)
    {
        var redis = new RedisSortedSet<int>(_redisConfig, PowerRankingKey);
        return await redis.GetScoreAsync(playerId);
    }

    public async Task<int?> GetPlayerRankAsync(int playerId)
    {
        var redis = new RedisSortedSet<int>(_redisConfig, PowerRankingKey);
        return (int?)await redis.GetRankAsync(playerId, order: Order.Descending); // ì ìˆ˜ê°€ ë†’ì€ ìˆœ
    }

    public async Task<List<RankingEntry>> GetTopRankingsAsync(int count = 100)
    {
        var redis = new RedisSortedSet<int>(_redisConfig, PowerRankingKey);
        var entries = await redis.RangeByRankWithScoresAsync(0, count - 1, order: Order.Descending);
        
        return await EnrichRankingEntriesAsync(entries);
    }

    public async Task<List<RankingEntry>> GetRankingsAroundPlayerAsync(int playerId, int range = 5)
    {
        var redis = new RedisSortedSet<int>(_redisConfig, PowerRankingKey);
        var playerRank = await redis.GetRankAsync(playerId, order: Order.Descending);
        
        if (!playerRank.HasValue)
        {
            return new List<RankingEntry>();
        }
        
        // í”Œë ˆì´ì–´ ì£¼ë³€ ë­í‚¹ ë²”ìœ„ ê³„ì‚°
        int startRank = Math.Max(0, (int)playerRank.Value - range);
        int endRank = (int)playerRank.Value + range;
        
        var entries = await redis.RangeByRankWithScoresAsync(startRank, endRank, order: Order.Descending);
        
        return await EnrichRankingEntriesAsync(entries);
    }

    private async Task<List<RankingEntry>> EnrichRankingEntriesAsync(IReadOnlyCollection<SortedSetEntry<int>> entries)
    {
        var result = new List<RankingEntry>();
        
        if (entries.Count == 0)
        {
            return result;
        }
        
        // í”Œë ˆì´ì–´ ID ëª©ë¡
        var playerIds = entries.Select(e => e.Value).ToList();
        
        // í”Œë ˆì´ì–´ ì •ë³´ ì¡°íšŒ
        var playerNameDict = await _playerRepository.GetPlayerNamesAsync(playerIds);
        
        // ë­í‚¹ ì •ë³´ êµ¬ì„±
        int rank = 0;
        foreach (var entry in entries)
        {
            rank++;
            string playerName = playerNameDict.TryGetValue(entry.Value, out var name) ? name : "Unknown";
            
            result.Add(new RankingEntry
            {
                Rank = rank,
                PlayerId = entry.Value,
                PlayerName = playerName,
                Score = (long)entry.Score
            });
        }
        
        return result;
    }
}

public class RankingEntry
{
    public int Rank { get; set; }
    public int PlayerId { get; set; }
    public string PlayerName { get; set; }
    public long Score { get; set; }
}
```
  

## 6.5 ì‹¤ì œ ê²Œì„ ì‹œìŠ¤í…œ êµ¬í˜„ ì˜ˆì‹œ
ì´ì œ ìœ„ì—ì„œ ì„¤ëª…í•œ ê°œë…ì„ ë°”íƒ•ìœ¼ë¡œ ì‹¤ì œ ê²Œì„ ì‹œìŠ¤í…œ ëª‡ ê°€ì§€ë¥¼ êµ¬í˜„í•´ë³´ì.  

### 6.5.1 ì¸ì¦ ë° ì„¸ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

```csharp
// Controllers/AuthController.cs
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IPlayerRepository _playerRepository;
    private readonly IPlayerSessionService _sessionService;

    public AuthController(IPlayerRepository playerRepository, IPlayerSessionService sessionService)
    {
        _playerRepository = playerRepository;
        _sessionService = sessionService;
    }

    [HttpPost("login")]
    public async Task<LoginResponse> Login([FromBody] LoginRequest request)
    {
        // í”Œë ˆì´ì–´ ì¡°íšŒ (ì‹¤ì œë¡œëŠ” ì¸ì¦ ë¡œì§ì´ í•„ìš”)
        var player = await _playerRepository.GetByUsernameAsync(request.Username);
        
        if (player == null)
        {
            return new LoginResponse
            {
                Success = false,
                Message = "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
            };
        }
        
        // ì„¸ì…˜ ìƒì„±
        string sessionToken = await _sessionService.CreateSessionAsync(player.Id, request.DeviceId);
        
        if (string.IsNullOrEmpty(sessionToken))
        {
            return new LoginResponse
            {
                Success = false,
                Message = "ì„¸ì…˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
            };
        }
        
        // ë§ˆì§€ë§‰ ë¡œê·¸ì¸ ì‹œê°„ ì—…ë°ì´íŠ¸
        player.LastLoginAt = DateTime.UtcNow;
        await _playerRepository.UpdateAsync(player);
        
        return new LoginResponse
        {
            Success = true,
            SessionToken = sessionToken,
            Player = player
        };
    }

    [HttpPost("logout")]
    public async Task<LogoutResponse> Logout([FromBody] LogoutRequest request)
    {
        bool result = await _sessionService.InvalidateSessionAsync(request.SessionToken);
        
        return new LogoutResponse
        {
            Success = result
        };
    }
}

public class LoginRequest
{
    public string Username { get; set; }
    public string DeviceId { get; set; }
}

public class LoginResponse
{
    public bool Success { get; set; }
    public string SessionToken { get; set; }
    public Player Player { get; set; }
    public string Message { get; set; }
}

public class LogoutRequest
{
    public string SessionToken { get; set; }
}

public class LogoutResponse
{
    public bool Success { get; set; }
}
```  
  
PlayerSessionService:      
```
// Services/IPlayerSessionService.cs
public interface IPlayerSessionService
{
    Task<string> CreateSessionAsync(int playerId, string deviceId);
    Task<int?> ValidateSessionAsync(string sessionToken);
    Task<bool> InvalidateSessionAsync(string sessionToken);
    Task<bool> InvalidateAllSessionsAsync(int playerId);
}

// Services/PlayerSessionService.cs
public class PlayerSessionService : IPlayerSessionService
{
    private readonly RedisConnection _redisConnection;
    private readonly ILogger<PlayerSessionService> _logger;

    public PlayerSessionService(RedisConnection redisConnection, ILogger<PlayerSessionService> logger)
    {
        _redisConnection = redisConnection;
        _logger = logger;
    }

    public async Task<string> CreateSessionAsync(int playerId, string deviceId)
    {
        try
        {
            // ì„¸ì…˜ í† í° ìƒì„±
            string sessionToken = Guid.NewGuid().ToString("N");
            string sessionKey = $"session:{sessionToken}";
            
            // ì„¸ì…˜ ì •ë³´ ìƒì„±
            var sessionInfo = new PlayerSession
            {
                PlayerId = playerId,
                DeviceId = deviceId,
                CreatedAt = DateTime.UtcNow,
                LastActivityAt = DateTime.UtcNow
            };
            
            // Redisì— ì„¸ì…˜ ì €ì¥ (24ì‹œê°„ ìœ íš¨)
            var sessionRedis = new RedisString<PlayerSession>(_redisConnection, sessionKey, TimeSpan.FromHours(24));
            bool sessionSaved = await sessionRedis.SetAsync(sessionInfo);
            
            if (!sessionSaved)
            {
                _logger.LogError("ì„¸ì…˜ ì €ì¥ ì‹¤íŒ¨. PlayerId: {PlayerId}, SessionToken: {SessionToken}", playerId, sessionToken);
                return null;
            }
            
            // í”Œë ˆì´ì–´ID -> ì„¸ì…˜ í† í° ë§¤í•‘ ì €ì¥ (Set ì‚¬ìš©)
            var playerSessionsKey = $"player:{playerId}:sessions";
            var playerSessions = new RedisSet<string>(_redisConnection, playerSessionsKey, TimeSpan.FromDays(7));
            await playerSessions.AddAsync(sessionToken);
            
            _logger.LogInformation("ì„¸ì…˜ ìƒì„± ì™„ë£Œ. PlayerId: {PlayerId}, SessionToken: {SessionToken}, DeviceId: {DeviceId}", 
                playerId, sessionToken, deviceId);
            
            return sessionToken;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ì„¸ì…˜ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ. PlayerId: {PlayerId}", playerId);
            return null;
        }
    }

    public async Task<int?> ValidateSessionAsync(string sessionToken)
    {
        if (string.IsNullOrEmpty(sessionToken))
        {
            return null;
        }
        
        try
        {
            string sessionKey = $"session:{sessionToken}";
            var sessionRedis = new RedisString<PlayerSession>(_redisConnection, sessionKey, TimeSpan.FromHours(24));
            
            var result = await sessionRedis.GetAsync();
            
            if (!result.HasValue)
            {
                _logger.LogWarning("ìœ íš¨í•˜ì§€ ì•Šì€ ì„¸ì…˜ í† í°: {SessionToken}", sessionToken);
                return null; // ì„¸ì…˜ì´ ì—†ê±°ë‚˜ ë§Œë£Œë¨
            }
            
            var session = result.Value;
            
            // ì„¸ì…˜ í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸
            session.LastActivityAt = DateTime.UtcNow;
            await sessionRedis.SetAsync(session); // ì„¸ì…˜ ê°±ì‹  (TTLë„ í•¨ê»˜ ê°±ì‹ ë¨)
            
            _logger.LogDebug("ì„¸ì…˜ ê²€ì¦ ì„±ê³µ. PlayerId: {PlayerId}, SessionToken: {SessionToken}", 
                session.PlayerId, sessionToken);
            
            return session.PlayerId;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ì„¸ì…˜ ê²€ì¦ ì¤‘ ì˜¤ë¥˜ ë°œìƒ. SessionToken: {SessionToken}", sessionToken);
            return null;
        }
    }

    public async Task<bool> InvalidateSessionAsync(string sessionToken)
    {
        if (string.IsNullOrEmpty(sessionToken))
        {
            return false;
        }
        
        try
        {
            string sessionKey = $"session:{sessionToken}";
            var sessionRedis = new RedisString<PlayerSession>(_redisConnection, sessionKey, TimeSpan.FromHours(24));
            
            // ì„¸ì…˜ ì •ë³´ ì¡°íšŒ
            var result = await sessionRedis.GetAsync();
            
            if (result.HasValue)
            {
                var session = result.Value;
                
                // í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ì—ì„œ ì„¸ì…˜ í† í° ì œê±°
                var playerSessionsKey = $"player:{session.PlayerId}:sessions";
                var playerSessions = new RedisSet<string>(_redisConnection, playerSessionsKey, TimeSpan.FromDays(7));
                await playerSessions.RemoveAsync(sessionToken);
                
                _logger.LogInformation("í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ì—ì„œ í† í° ì œê±°. PlayerId: {PlayerId}, SessionToken: {SessionToken}", 
                    session.PlayerId, sessionToken);
            }
            
            // ì„¸ì…˜ ì‚­ì œ
            bool deleted = await sessionRedis.DeleteAsync();
            
            if (deleted)
            {
                _logger.LogInformation("ì„¸ì…˜ ë¬´íš¨í™” ì™„ë£Œ. SessionToken: {SessionToken}", sessionToken);
            }
            
            return deleted;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ì„¸ì…˜ ë¬´íš¨í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ. SessionToken: {SessionToken}", sessionToken);
            return false;
        }
    }

    // í”Œë ˆì´ì–´ì˜ ëª¨ë“  ì„¸ì…˜ ë¬´íš¨í™” (ë‹¤ì¤‘ ë¡œê·¸ì¸ ê´€ë¦¬ìš©)
    public async Task<bool> InvalidateAllSessionsAsync(int playerId)
    {
        try
        {
            var playerSessionsKey = $"player:{playerId}:sessions";
            var playerSessions = new RedisSet<string>(_redisConnection, playerSessionsKey, TimeSpan.FromDays(7));
            
            // í”Œë ˆì´ì–´ì˜ ëª¨ë“  ì„¸ì…˜ í† í° ì¡°íšŒ
            var sessionTokens = await playerSessions.MembersAsync();
            
            if (sessionTokens == null || sessionTokens.Length == 0)
            {
                return true; // ì‚­ì œí•  ì„¸ì…˜ì´ ì—†ìŒ
            }
            
            // ê° ì„¸ì…˜ ê°œë³„ ì‚­ì œ
            int deletedCount = 0;
            foreach (var sessionToken in sessionTokens)
            {
                string sessionKey = $"session:{sessionToken}";
                var sessionRedis = new RedisString<PlayerSession>(_redisConnection, sessionKey, TimeSpan.FromHours(24));
                
                if (await sessionRedis.DeleteAsync())
                {
                    deletedCount++;
                }
            }
            
            // í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ ì‚­ì œ
            await playerSessions.DeleteAsync();
            
            _logger.LogInformation("í”Œë ˆì´ì–´ì˜ ëª¨ë“  ì„¸ì…˜ ë¬´íš¨í™” ì™„ë£Œ. PlayerId: {PlayerId}, ì‚­ì œëœ ì„¸ì…˜ ìˆ˜: {DeletedCount}", 
                playerId, deletedCount);
            
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "í”Œë ˆì´ì–´ ëª¨ë“  ì„¸ì…˜ ë¬´íš¨í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ. PlayerId: {PlayerId}", playerId);
            return false;
        }
    }
}

// Models/PlayerSession.cs
public class PlayerSession
{
    public int PlayerId { get; set; }
    public string DeviceId { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastActivityAt { get; set; }
}
```  
  
#### ì„¸ì…˜ ê´€ë¦¬ í•¨ìˆ˜ íë¦„ë„

CreateSessionAsync í•¨ìˆ˜ íë¦„ë„  

```mermaid
flowchart TD
    A[ì‹œì‘: CreateSessionAsync] --> B[ì„¸ì…˜ í† í° ìƒì„±<br/>Guid.NewGuid]
    B --> C[ì„¸ì…˜ ì •ë³´ ìƒì„±<br/>PlayerSession ê°ì²´]
    C --> D[Redisì— ì„¸ì…˜ ì €ì¥<br/>24ì‹œê°„ TTL]
    D --> E{ì„¸ì…˜ ì €ì¥ ì„±ê³µ?}
    E -->|ì‹¤íŒ¨| F[ë¡œê·¸ ì—ëŸ¬ ê¸°ë¡]
    F --> G[null ë°˜í™˜]
    E -->|ì„±ê³µ| H[í”Œë ˆì´ì–´ ì„¸ì…˜ ë§¤í•‘ ì €ì¥<br/>Setì— í† í° ì¶”ê°€]
    H --> I[ì„±ê³µ ë¡œê·¸ ê¸°ë¡]
    I --> J[ì„¸ì…˜ í† í° ë°˜í™˜]
    
    K[ì˜ˆì™¸ ë°œìƒ] --> L[ì—ëŸ¬ ë¡œê·¸ ê¸°ë¡]
    L --> M[null ë°˜í™˜]
    
    style A fill:#e1f5fe
    style J fill:#c8e6c9
    style G fill:#ffcdd2
    style M fill:#ffcdd2
```
  
ValidateSessionAsync í•¨ìˆ˜ íë¦„ë„

```mermaid
flowchart TD
    A[ì‹œì‘: ValidateSessionAsync] --> B{ì„¸ì…˜ í† í°ì´<br/>ë¹„ì–´ìˆëŠ”ê°€?}
    B -->|ì˜ˆ| C[null ë°˜í™˜]
    B -->|ì•„ë‹ˆì˜¤| D[Redisì—ì„œ ì„¸ì…˜ ì¡°íšŒ]
    D --> E{ì„¸ì…˜ì´ ì¡´ì¬í•˜ëŠ”ê°€?}
    E -->|ì—†ìŒ| F[ê²½ê³  ë¡œê·¸ ê¸°ë¡]
    F --> G[null ë°˜í™˜]
    E -->|ìˆìŒ| H[ì„¸ì…˜ í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸<br/>LastActivityAt = UtcNow]
    H --> I[Redisì— ì„¸ì…˜ ê°±ì‹ <br/>TTLë„ í•¨ê»˜ ê°±ì‹ ]
    I --> J[ë””ë²„ê·¸ ë¡œê·¸ ê¸°ë¡]
    J --> K[PlayerId ë°˜í™˜]
    
    L[ì˜ˆì™¸ ë°œìƒ] --> M[ì—ëŸ¬ ë¡œê·¸ ê¸°ë¡]
    M --> N[null ë°˜í™˜]
    
    style A fill:#e1f5fe
    style K fill:#c8e6c9
    style C fill:#ffcdd2
    style G fill:#ffcdd2
    style N fill:#ffcdd2
```

InvalidateSessionAsync í•¨ìˆ˜ íë¦„ë„

```mermaid
flowchart TD
    A[ì‹œì‘: InvalidateSessionAsync] --> B{ì„¸ì…˜ í† í°ì´<br/>ë¹„ì–´ìˆëŠ”ê°€?}
    B -->|ì˜ˆ| C[false ë°˜í™˜]
    B -->|ì•„ë‹ˆì˜¤| D[Redisì—ì„œ ì„¸ì…˜ ì¡°íšŒ]
    D --> E{ì„¸ì…˜ì´ ì¡´ì¬í•˜ëŠ”ê°€?}
    E -->|ìˆìŒ| F[í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ì—ì„œ<br/>í† í° ì œê±°]
    F --> G[ì •ë³´ ë¡œê·¸ ê¸°ë¡<br/>í† í° ì œê±° ì™„ë£Œ]
    E -->|ì—†ìŒ| H[ì„¸ì…˜ ì‚­ì œ ì‹œë„]
    G --> H
    H --> I{ì‚­ì œ ì„±ê³µ?}
    I -->|ì„±ê³µ| J[ì •ë³´ ë¡œê·¸ ê¸°ë¡<br/>ë¬´íš¨í™” ì™„ë£Œ]
    I -->|ì‹¤íŒ¨| K[ì‚­ì œ ê²°ê³¼ ë°˜í™˜]
    J --> K
    
    L[ì˜ˆì™¸ ë°œìƒ] --> M[ì—ëŸ¬ ë¡œê·¸ ê¸°ë¡]
    M --> N[false ë°˜í™˜]
    
    style A fill:#e1f5fe
    style K fill:#c8e6c9
    style C fill:#ffcdd2
    style N fill:#ffcdd2
```

InvalidateAllSessionsAsync í•¨ìˆ˜ íë¦„ë„

```mermaid
flowchart TD
    A[ì‹œì‘: InvalidateAllSessionsAsync] --> B[í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ ì¡°íšŒ<br/>Redis Setì—ì„œ í† í°ë“¤ ê°€ì ¸ì˜¤ê¸°]
    B --> C{ì„¸ì…˜ í† í°ë“¤ì´<br/>ì¡´ì¬í•˜ëŠ”ê°€?}
    C -->|ì—†ìŒ| D[true ë°˜í™˜<br/>ì‚­ì œí•  ì„¸ì…˜ ì—†ìŒ]
    C -->|ìˆìŒ| E[ê° ì„¸ì…˜ í† í° ìˆœíšŒ ì‹œì‘<br/>deletedCount = 0]
    E --> F[ê°œë³„ ì„¸ì…˜ ì‚­ì œ ì‹œë„]
    F --> G{ì‚­ì œ ì„±ê³µ?}
    G -->|ì„±ê³µ| H[deletedCount ì¦ê°€]
    G -->|ì‹¤íŒ¨| I{ë‹¤ìŒ ì„¸ì…˜ì´<br/>ìˆëŠ”ê°€?}
    H --> I
    I -->|ìˆìŒ| F
    I -->|ì—†ìŒ| J[í”Œë ˆì´ì–´ ì„¸ì…˜ ëª©ë¡ ì‚­ì œ<br/>Redis Set ì‚­ì œ]
    J --> K[ì •ë³´ ë¡œê·¸ ê¸°ë¡<br/>ì‚­ì œëœ ì„¸ì…˜ ìˆ˜ í¬í•¨]
    K --> L[true ë°˜í™˜]
    
    M[ì˜ˆì™¸ ë°œìƒ] --> N[ì—ëŸ¬ ë¡œê·¸ ê¸°ë¡]
    N --> O[false ë°˜í™˜]
    
    style A fill:#e1f5fe
    style D fill:#c8e6c9
    style L fill:#c8e6c9
    style O fill:#ffcdd2
```

## ìƒ‰ìƒ ë²”ë¡€

- ğŸ”µ **íŒŒë€ìƒ‰ (fill:#e1f5fe)**: ì‹œì‘ì 
- ğŸŸ¢ **ì´ˆë¡ìƒ‰ (fill:#c8e6c9)**: ì„±ê³µ ë°˜í™˜
- ğŸ”´ **ë¹¨ê°„ìƒ‰ (fill:#ffcdd2)**: ì‹¤íŒ¨ ë°˜í™˜
  

### 6.5.2 ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ êµ¬í˜„

```csharp
// Middlewares/SessionAuthMiddleware.cs
public class SessionAuthMiddleware
{
    private readonly RequestDelegate _next;

    public SessionAuthMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context, IPlayerSessionService sessionService)
    {
        // ì¸ì¦ì´ í•„ìš” ì—†ëŠ” ê²½ë¡œëŠ” ê±´ë„ˆë›´ë‹¤
        if (IsExcludedPath(context.Request.Path))
        {
            await _next(context);
            return;
        }
        
        // ì„¸ì…˜ í† í° ì¶”ì¶œ
        if (!context.Request.Headers.TryGetValue("X-Session-Token", out var sessionTokenValues))
        {
            await HandleUnauthorized(context, "ì„¸ì…˜ í† í°ì´ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }
        
        string sessionToken = sessionTokenValues.FirstOrDefault();
        
        if (string.IsNullOrEmpty(sessionToken))
        {
            await HandleUnauthorized(context, "ìœ íš¨í•˜ì§€ ì•Šì€ ì„¸ì…˜ í† í°ì…ë‹ˆë‹¤.");
            return;
        }
        
        // ì„¸ì…˜ ìœ íš¨ì„± ê²€ì‚¬
        var playerId = await sessionService.ValidateSessionAsync(sessionToken);
        
        if (!playerId.HasValue)
        {
            await HandleUnauthorized(context, "ë§Œë£Œë˜ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ì„¸ì…˜ì…ë‹ˆë‹¤.");
            return;
        }
        
        // í˜„ì¬ ìš”ì²­ì— í”Œë ˆì´ì–´ ID ì¶”ê°€
        context.Items["PlayerId"] = playerId.Value;
        context.Items["SessionToken"] = sessionToken;
        
        await _next(context);
    }

    private bool IsExcludedPath(PathString path)
    {
        // ì¸ì¦ì´ í•„ìš” ì—†ëŠ” ê²½ë¡œ ëª©ë¡
        var excludedPaths = new[]
        {
            "/api/auth/login",
            "/api/auth/register",
            "/health",
            "/api/version"
        };
        
        return excludedPaths.Any(p => path.StartsWithSegments(p, StringComparison.OrdinalIgnoreCase));
    }

    private async Task HandleUnauthorized(HttpContext context, string message)
    {
        context.Response.StatusCode = StatusCodes.Status401Unauthorized;
        context.Response.ContentType = "application/json";
        
        var response = new
        {
            Success = false,
            Message = message
        };
        
        await context.Response.WriteAsJsonAsync(response);
    }
}

// Program.csì— ë¯¸ë“¤ì›¨ì–´ ë“±ë¡
app.UseMiddleware<SessionAuthMiddleware>();
```
  

### 6.5.3 í”Œë ˆì´ì–´ ì¸ë²¤í† ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œ

```csharp
// Services/InventoryService.cs
public interface IInventoryService
{
    Task<List<PlayerItem>> GetPlayerInventoryAsync(int playerId);
    Task<bool> AddItemToInventoryAsync(int playerId, int itemId, int quantity = 1);
    Task<bool> RemoveItemFromInventoryAsync(int playerId, int playerItemId, int quantity = 1);
    Task<bool> UseItemAsync(int playerId, int playerItemId);
}

public class InventoryService : IInventoryService
{
    private readonly RedisConfig _redisConfig;
    private readonly IPlayerItemRepository _playerItemRepository;
    private readonly IItemRepository _itemRepository;

    public InventoryService(
        RedisConfig redisConfig,
        IPlayerItemRepository playerItemRepository,
        IItemRepository itemRepository)
    {
        _redisConfig = redisConfig;
        _playerItemRepository = playerItemRepository;
        _itemRepository = itemRepository;
    }

    public async Task<List<PlayerItem>> GetPlayerInventoryAsync(int playerId)
    {
        // ìºì‹œ í‚¤ ìƒì„±
        string cacheKey = $"player:{playerId}:inventory";
        
        // ìºì‹œì—ì„œ ì¸ë²¤í† ë¦¬ ì¡°íšŒ
        var redis = new RedisString<List<PlayerItem>>(_redisConfig, cacheKey);
        var result = await redis.GetAsync();
        
        if (result.HasValue)
        {
            return result.Value;
        }
        
        // ìºì‹œì— ì—†ìœ¼ë©´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
        var inventory = await _playerItemRepository.GetPlayerItemsAsync(playerId);
        
        // ì•„ì´í…œ ì •ë³´ë¥¼ í•¨ê»˜ ë¡œë“œ
        foreach (var item in inventory)
        {
            item.ItemDetails = await _itemRepository.GetByIdAsync(item.ItemId);
        }
        
        // ìºì‹œì— ì €ì¥ (5ë¶„ ìœ íš¨)
        await redis.SetAsync(inventory, TimeSpan.FromMinutes(5));
        
        return inventory;
    }

    public async Task<bool> AddItemToInventoryAsync(int playerId, int itemId, int quantity = 1)
    {
        // íŠ¸ëœì­ì…˜ ì²˜ë¦¬ëŠ” ìƒëµ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í¬í•¨í•´ì•¼ í•¨)
        
        // ì•„ì´í…œì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        var item = await _itemRepository.GetByIdAsync(itemId);
        
        if (item == null)
        {
            return false;
        }
        
        // ì•„ì´í…œ ì¶”ê°€
        bool success = await _playerItemRepository.AddItemAsync(playerId, itemId, quantity);
        
        if (success)
        {
            // ìºì‹œ ë¬´íš¨í™”
            await InvalidateInventoryCacheAsync(playerId);
        }
        
        return success;
    }

    public async Task<bool> RemoveItemFromInventoryAsync(int playerId, int playerItemId, int quantity = 1)
    {
        // ì•„ì´í…œ ì œê±°
        bool success = await _playerItemRepository.RemoveItemAsync(playerId, playerItemId, quantity);
        
        if (success)
        {
            // ìºì‹œ ë¬´íš¨í™”
            await InvalidateInventoryCacheAsync(playerId);
        }
        
        return success;
    }

    public async Task<bool> UseItemAsync(int playerId, int playerItemId)
    {
        // ì•„ì´í…œ ì¡´ì¬ í™•ì¸
        var playerItem = await _playerItemRepository.GetByIdAsync(playerItemId);
        
        if (playerItem == null || playerItem.PlayerId != playerId)
        {
            return false;
        }
        
        // ì•„ì´í…œ ì •ë³´ ì¡°íšŒ
        var item = await _itemRepository.GetByIdAsync(playerItem.ItemId);
        
        if (item == null)
        {
            return false;
        }
        
        // ì•„ì´í…œ íƒ€ì…ì— ë”°ë¥¸ íš¨ê³¼ ì ìš©
        switch (item.Type)
        {
            case "potion":
                // í¬ì…˜ íš¨ê³¼ ì ìš© ë¡œì§
                break;
            case "equipment":
                // ì¥ë¹„ ì¥ì°© ë¡œì§
                break;
            case "material":
                // ì¬ë£Œ ì•„ì´í…œì€ ì‚¬ìš© ë¶ˆê°€
                return false;
            default:
                // ì •ì˜ë˜ì§€ ì•Šì€ ì•„ì´í…œ íƒ€ì…
                return false;
        }
        
        // ì†Œëª¨ì„± ì•„ì´í…œì´ë©´ ìˆ˜ëŸ‰ ê°ì†Œ
        if (item.IsConsumable)
        {
            await RemoveItemFromInventoryAsync(playerId, playerItemId, 1);
        }
        
        return true;
    }

    private async Task InvalidateInventoryCacheAsync(int playerId)
    {
        string cacheKey = $"player:{playerId}:inventory";
        var redis = new RedisString<List<PlayerItem>>(_redisConfig, cacheKey);
        await redis.DeleteAsync();
    }
}
```
  
#### 1. ì½”ë“œì˜ ì „ì²´ êµ¬ì¡° (ì¸í„°í˜ì´ìŠ¤ì™€ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤)
ì´ ì½”ë“œëŠ” ë‘ ë¶€ë¶„ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤.

* **`IInventoryService` (ì¸í„°í˜ì´ìŠ¤ ğŸ“œ):**
    * ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œì´ **'ë¬´ì—‡ì„ í•  ìˆ˜ ìˆëŠ”ì§€'**ì— ëŒ€í•œ **ì„¤ê³„ë„ ë˜ëŠ” ê³„ì•½ì„œ**ì´ë‹¤.
    * `GetPlayerInventoryAsync` (ì¸ë²¤í† ë¦¬ ì¡°íšŒ), `AddItemToInventoryAsync` (ì•„ì´í…œ ì¶”ê°€) ë“± ì¸ë²¤í† ë¦¬ê°€ ê°€ì ¸ì•¼ í•  ê¸°ëŠ¥ì˜ ëª©ë¡ì„ ì •ì˜í•œë‹¤.
    * ì´ë ‡ê²Œ ê¸°ëŠ¥ì„ ë¯¸ë¦¬ ì •ì˜í•´ë‘ë©´, ë‚˜ì¤‘ì— ë‹¤ë¥¸ ì½”ë“œì—ì„œ ì¸ë²¤í† ë¦¬ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ë•Œ ì‹¤ì œ êµ¬í˜„ ë‚´ìš©ì— ì–½ë§¤ì´ì§€ ì•Šê³  ìœ ì—°í•˜ê²Œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤. (ì˜ì¡´ì„± ì£¼ì…, í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ë“±)

* **`InventoryService` (ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ ğŸ› ï¸):**
    * `IInventoryService`ë¼ëŠ” ì„¤ê³„ë„ë¥¼ ì‹¤ì œë¡œ **'ì–´ë–»ê²Œ êµ¬í˜„í• ì§€'**ì— ëŒ€í•œ êµ¬ì²´ì ì¸ ì½”ë“œë¥¼ ë‹´ê³  ìˆë‹¤.
    * ë°ì´í„°ë² ì´ìŠ¤(`Repository`)ì™€ Redis ìºì‹œë¥¼ ì‚¬ìš©í•˜ì—¬ ê° ê¸°ëŠ¥ì˜ ì‹¤ì œ ë™ì‘ì„ êµ¬í˜„í•œë‹¤.
    * **ì˜ì¡´ì„± ì£¼ì…(Dependency Injection)**ì„ í†µí•´ `RedisConfig`, `IPlayerItemRepository`, `IItemRepository` ë“± í•„ìš”í•œ ë¶€í’ˆë“¤ì„ ì™¸ë¶€ì—ì„œ ë°›ì•„ì˜¨ë‹¤.

  
#### 2. í•µì‹¬ íŒ¨í„´: ë ˆë””ìŠ¤(Redis)ë¥¼ ì´ìš©í•œ ìºì‹± ì „ëµ âš¡ï¸
ì´ ì½”ë“œì˜ ê°€ì¥ ì¤‘ìš”í•œ íŠ¹ì§•ì€ **ìºì‹œ ì–´ì‚¬ì´ë“œ(Cache-Aside) íŒ¨í„´**ì„ ì‚¬ìš©í•œë‹¤ëŠ” ì ì´ë‹¤. ì¸ë²¤í† ë¦¬ ì •ë³´ëŠ” ê²Œì„ í”Œë ˆì´ ì¤‘ì— ë§¤ìš° ìì£¼ ì¡°íšŒë˜ë¯€ë¡œ, ë§¤ë²ˆ ë°ì´í„°ë² ì´ìŠ¤(DB)ì— ì ‘ê·¼í•˜ë©´ ë¶€í•˜ê°€ ì»¤ì§€ê³  ì†ë„ê°€ ëŠë ¤ì§„ë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë¹ ë¥¸ ë©”ëª¨ë¦¬ ì €ì¥ì†Œì¸ Redisë¥¼ ìºì‹œë¡œ ì‚¬ìš©í•œë‹¤.

##### **`GetPlayerInventoryAsync` (ì¸ë²¤í† ë¦¬ ì¡°íšŒ) ë™ì‘ ë°©ì‹:**

1.  **ìºì‹œ ìš°ì„  ì¡°íšŒ:** ë¨¼ì € Redisì— í•´ë‹¹ í”Œë ˆì´ì–´ì˜ ì¸ë²¤í† ë¦¬ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤. (`redis.GetAsync()`)
2.  **ìºì‹œ íˆíŠ¸ (Cache Hit):** ë§Œì•½ Redisì— ë°ì´í„°ê°€ ìˆë‹¤ë©´, DBê¹Œì§€ ê°ˆ í•„ìš” ì—†ì´ **ì¦‰ì‹œ Redisì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì™€ ë°˜í™˜**í•œë‹¤. (ë§¤ìš° ë¹ ë¦„)
3.  **ìºì‹œ ë¯¸ìŠ¤ (Cache Miss):** Redisì— ë°ì´í„°ê°€ ì—†ë‹¤ë©´, **DBì—ì„œ ì¸ë²¤í† ë¦¬ ì •ë³´ë¥¼ ì¡°íšŒ**í•œë‹¤. (`_playerItemRepository.GetPlayerItemsAsync()`)
4.  **ìºì‹œ ì €ì¥:** DBì—ì„œ ê°€ì ¸ì˜¨ ìµœì‹  ë°ì´í„°ë¥¼ **ë‹¤ìŒì— ë˜ ì‚¬ìš©í•˜ê¸° ìœ„í•´ Redisì— ì €ì¥**í•œë‹¤. (`redis.SetAsync()`) ì—¬ê¸°ì„œëŠ” 5ë¶„ì˜ ìœ íš¨ì‹œê°„ì„ ì„¤ì •í–ˆë‹¤.
5.  **ë°ì´í„° ë°˜í™˜:** DBì—ì„œ ê°€ì ¸ì˜¨ ë°ì´í„°ë¥¼ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë°˜í™˜í•œë‹¤.

#### 3. ë°ì´í„° ë³€ê²½ê³¼ ìºì‹œ ë¬´íš¨í™” ğŸ—‘ï¸
ìºì‹œë¥¼ ì‚¬ìš©í•  ë•Œ ê°€ì¥ ì¤‘ìš”í•œ ê²ƒì€ **DBì˜ ì›ë³¸ ë°ì´í„°ì™€ ìºì‹œì˜ ë°ì´í„° ê°„ì˜ ì¼ê´€ì„±ì„ ìœ ì§€**í•˜ëŠ” ê²ƒì´ë‹¤. ë§Œì•½ DB ë°ì´í„°ê°€ ë°”ë€Œì—ˆëŠ”ë° ìºì‹œ ë°ì´í„°ëŠ” ê·¸ëŒ€ë¡œë¼ë©´, ìœ ì €ëŠ” ì˜¤ë˜ëœ ì •ë³´ë¥¼ ë³´ê²Œ ëœë‹¤.  
  
##### **`AddItemToInventoryAsync` / `RemoveItemFromInventoryAsync` ë™ì‘ ë°©ì‹:**

1.  **DB ë°ì´í„° ë³€ê²½:** ë¨¼ì € ë°ì´í„°ë² ì´ìŠ¤ì— ì•„ì´í…œì„ ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°í•˜ëŠ” ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.
2.  **ìºì‹œ ë¬´íš¨í™” (Cache Invalidation):** DB ì‘ì—…ì´ ì„±ê³µí•˜ë©´, `InvalidateInventoryCacheAsync` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.
3.  **ìºì‹œ ì‚­ì œ:** ì´ ë©”ì„œë“œëŠ” Redisì— ì €ì¥ë˜ì–´ ìˆë˜ **ê¸°ì¡´ì˜ ì¸ë²¤í† ë¦¬ ìºì‹œ ë°ì´í„°ë¥¼ ì‚­ì œ**í•œë‹¤.
4.  **ë°ì´í„° ìµœì‹ í™”:** ì´ì œ ìºì‹œê°€ ë¹„ì›Œì¡Œìœ¼ë¯€ë¡œ, ë‹¤ìŒì— ì´ í”Œë ˆì´ì–´ê°€ ì¸ë²¤í† ë¦¬ë¥¼ ì¡°íšŒí•˜ë©´ 'ìºì‹œ ë¯¸ìŠ¤'ê°€ ë°œìƒí•˜ì—¬ **DBì—ì„œ ìµœì‹  ë°ì´í„°ë¥¼ ì½ì–´ì™€ ìƒˆë¡œìš´ ìºì‹œë¥¼ ë§Œë“¤ê²Œ ëœë‹¤.**

ì´ ê³¼ì •ì„ í†µí•´ ì¸ë²¤í† ë¦¬ì— ë³€ë™ì´ ìƒê¸¸ ë•Œë§ˆë‹¤ ìºì‹œë¥¼ ë˜‘ë˜‘í•˜ê²Œ ë¹„ì›Œ ë°ì´í„° ë¶ˆì¼ì¹˜ ë¬¸ì œë¥¼ ë°©ì§€í•œë‹¤.

#### 4. `UseItemAsync` (ì•„ì´í…œ ì‚¬ìš© ë¡œì§)
ì´ ë©”ì„œë“œëŠ” ì‹¤ì œ ê²Œì„ì˜ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ê³  ìˆë‹¤.

* í”Œë ˆì´ì–´ê°€ í•´ë‹¹ ì•„ì´í…œì„ ì •ë§ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.
* ì•„ì´í…œì˜ ì¢…ë¥˜(`Type`)ì— ë”°ë¼ ê°ê¸° ë‹¤ë¥¸ íš¨ê³¼ë¥¼ ì ìš©í•œë‹¤. (`switch` ë¬¸)
    * `potion`: ì²´ë ¥ì„ íšŒë³µì‹œí‚¤ëŠ” ë“±ì˜ ë¡œì§ ìˆ˜í–‰
    * `equipment`: ìºë¦­í„°ì—ê²Œ ì¥ë¹„ë¥¼ ì¥ì°©í•˜ëŠ” ë¡œì§ ìˆ˜í–‰
    * `material`: ì¬ë£Œ ì•„ì´í…œì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° `false` ë°˜í™˜
* í¬ì…˜ì²˜ëŸ¼ **ì‚¬ë¼ì§€ëŠ” ì•„ì´í…œ(`IsConsumable`)**ì´ë¼ë©´, `RemoveItemFromInventoryAsync`ë¥¼ í˜¸ì¶œí•˜ì—¬ ì•„ì´í…œì„ 1ê°œ ì¤„ì´ê³  **ìºì‹œë„ í•¨ê»˜ ë¬´íš¨í™”**í•œë‹¤.  
  

### 6.5.4 ì‹¤ì‹œê°„ ë­í‚¹ ì»¨íŠ¸ë¡¤ëŸ¬

```csharp
// Controllers/RankingController.cs
[ApiController]
[Route("api/[controller]")]
public class RankingController : ControllerBase
{
    private readonly IRankingService _rankingService;

    public RankingController(IRankingService rankingService)
    {
        _rankingService = rankingService;
    }

    [HttpPost("top")]
    public async Task<RankingResponse> GetTopRankings([FromBody] GetTopRankingsRequest request)
    {
        var count = Math.Min(request.Count, 100); // ìµœëŒ€ 100ëª…ê¹Œì§€ë§Œ ì¡°íšŒ
        var rankings = await _rankingService.GetTopRankingsAsync(count);
        
        return new RankingResponse
        {
            Success = true,
            Rankings = rankings
        };
    }

    [HttpPost("player")]
    public async Task<PlayerRankingResponse> GetPlayerRanking([FromBody] GetPlayerRankingRequest request)
    {
        var playerRank = await _rankingService.GetPlayerRankAsync(request.PlayerId);
        var playerScore = await _rankingService.GetPlayerScoreAsync(request.PlayerId);
        
        if (!playerRank.HasValue || !playerScore.HasValue)
        {
            return new PlayerRankingResponse
            {
                Success = false,
                Message = "í”Œë ˆì´ì–´ ë­í‚¹ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
            };
        }
        
        var rankingsAround = await _rankingService.GetRankingsAroundPlayerAsync(request.PlayerId, request.Range);
        
        return new PlayerRankingResponse
        {
            Success = true,
            PlayerRank = playerRank.Value,
            PlayerScore = playerScore.Value,
            RankingsAround = rankingsAround
        };
    }
}

public class GetTopRankingsRequest
{
    public int Count { get; set; } = 20;
}

public class RankingResponse
{
    public bool Success { get; set; }
    public List<RankingEntry> Rankings { get; set; }
    public string Message { get; set; }
}

public class GetPlayerRankingRequest
{
    public int PlayerId { get; set; }
    public int Range { get; set; } = 5;
}

public class PlayerRankingResponse
{
    public bool Success { get; set; }
    public int PlayerRank { get; set; }
    public long PlayerScore { get; set; }
    public List<RankingEntry> RankingsAround { get; set; }
    public string Message { get; set; }
}
```
 
  
### 6.5.5. HTTP ìš”ì²­ í…ŒìŠ¤íŠ¸ íŒŒì¼

```
### ë¡œê·¸ì¸
POST https://localhost:5001/api/auth/login
Content-Type: application/json

{
  "username": "dragon_slayer",
  "deviceId": "device_123456"
}

### ì¸ë²¤í† ë¦¬ ì¡°íšŒ
POST https://localhost:5001/api/inventory/items
Content-Type: application/json
X-Session-Token: {{sessionToken}}

{
  "playerId": 1
}

### ì•„ì´í…œ ì‚¬ìš©
POST https://localhost:5001/api/inventory/use
Content-Type: application/json
X-Session-Token: {{sessionToken}}

{
  "playerId": 1,
  "playerItemId": 42
}

### í†± ë­í‚¹ ì¡°íšŒ
POST https://localhost:5001/api/ranking/top
Content-Type: application/json
X-Session-Token: {{sessionToken}}

{
  "count": 20
}

### í”Œë ˆì´ì–´ ë­í‚¹ ì¡°íšŒ
POST https://localhost:5001/api/ranking/player
Content-Type: application/json
X-Session-Token: {{sessionToken}}

{
  "playerId": 1,
  "range": 5
}

### ë¡œê·¸ì•„ì›ƒ
POST https://localhost:5001/api/auth/logout
Content-Type: application/json
X-Session-Token: {{sessionToken}}

{
  "sessionToken": "{{sessionToken}}"
}
```
  

## 6.6 ê³ ê¸‰ Redis ìºì‹± ì „ëµ

### 6.6.1 ìºì‹œ ë§Œë£Œ ì „ëµ
ì ì ˆí•œ TTL(Time-To-Live) ì„¤ì •ì€ ìºì‹œ íš¨ìœ¨ì„±ì— í° ì˜í–¥ì„ ë¯¸ì¹œë‹¤.

1. **ì •ì  ë°ì´í„°**: ê²Œì„ ì•„ì´í…œ, ìŠ¤í‚¬ ì •ì˜ ë“±ì€ ì—…ë°ì´íŠ¸ê°€ ë“œë¬¼ë¯€ë¡œ ê¸´ TTL(1ì¼~1ì£¼ì¼)
2. **ì¤€ì •ì  ë°ì´í„°**: ë­í‚¹, ë¦¬ë”ë³´ë“œ ë“±ì€ ì¤‘ê°„ TTL(10ë¶„~1ì‹œê°„)
3. **ë™ì  ë°ì´í„°**: í”Œë ˆì´ì–´ ìƒíƒœ, ì¸ë²¤í† ë¦¬ ë“±ì€ ì§§ì€ TTL(1ë¶„~5ë¶„)
4. **ì„¸ì…˜ ë°ì´í„°**: ì¸ì¦ í† í°, ì„¸ì…˜ ë“±ì€ ë³´ì•ˆê³¼ ê´€ë ¨ëœ TTL(1ì‹œê°„~24ì‹œê°„)
  

### 6.6.2 ìºì‹œ ë¬´íš¨í™” ì „ëµ
ë°ì´í„°ê°€ ë³€ê²½ë  ë•Œ ìºì‹œë¥¼ ì ì ˆíˆ ë¬´íš¨í™”í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.

```csharp
public class CacheInvalidationService : ICacheInvalidationService
{
    private readonly RedisConfig _redisConfig;
    private readonly ILogger<CacheInvalidationService> _logger;

    public CacheInvalidationService(RedisConfig redisConfig, ILogger<CacheInvalidationService> logger)
    {
        _redisConfig = redisConfig;
        _logger = logger;
    }

    public async Task InvalidatePlayerCacheAsync(int playerId)
    {
        try
        {
            // í”Œë ˆì´ì–´ ê¸°ë³¸ ì •ë³´
            await DeleteKeyAsync($"player:{playerId}");
            
            // í”Œë ˆì´ì–´ í†µê³„
            await DeleteKeyAsync($"player:{playerId}:stats");
            
            // í”Œë ˆì´ì–´ ì¸ë²¤í† ë¦¬
            await DeleteKeyAsync($"player:{playerId}:inventory");
            
            // í”Œë ˆì´ì–´ ìºë¦­í„° ëª©ë¡
            await DeleteKeyAsync($"player:{playerId}:characters");
            
            _logger.LogInformation("í”Œë ˆì´ì–´ ìºì‹œ ë¬´íš¨í™” ì™„ë£Œ. PlayerId: {PlayerId}", playerId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "í”Œë ˆì´ì–´ ìºì‹œ ë¬´íš¨í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ. PlayerId: {PlayerId}", playerId);
        }
    }

    public async Task InvalidateItemCacheAsync(int itemId)
    {
        try
        {
            // ì•„ì´í…œ ì •ë³´
            await DeleteKeyAsync($"item:{itemId}");
            
            // ì „ì²´ ì•„ì´í…œ ëª©ë¡
            await DeleteKeyAsync("game:items:all");
            
            _logger.LogInformation("ì•„ì´í…œ ìºì‹œ ë¬´íš¨í™” ì™„ë£Œ. ItemId: {ItemId}", itemId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ì•„ì´í…œ ìºì‹œ ë¬´íš¨í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ. ItemId: {ItemId}", itemId);
        }
    }

    private async Task DeleteKeyAsync(string key)
    {
        var redis = new RedisString<object>(_redisConfig, key);
        await redis.DeleteAsync();
    }
}
```

### 6.6.3 ìºì‹œ í”„ë¦¬ì›Œë°(Prewarming)
ì„œë²„ ì‹œì‘ ì‹œë‚˜ ì •ê¸°ì ìœ¼ë¡œ ìì£¼ ì‚¬ìš©ë˜ëŠ” ë°ì´í„°ë¥¼ ë¯¸ë¦¬ ìºì‹œì— ë¡œë“œí•˜ì—¬ ì½œë“œ ìŠ¤íƒ€íŠ¸ ë¬¸ì œë¥¼ ë°©ì§€í•œë‹¤.

```csharp
// Services/CachePrewarmingService.cs
public class CachePrewarmingService : IHostedService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<CachePrewarmingService> _logger;

    public CachePrewarmingService(IServiceProvider serviceProvider, ILogger<CachePrewarmingService> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
    }

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("ìºì‹œ í”„ë¦¬ì›Œë° ì‹œì‘...");
        
        using var scope = _serviceProvider.CreateScope();
        
        // 1. ê²Œì„ ì•„ì´í…œ ìºì‹±
        await PrewarmItemsAsync(scope.ServiceProvider, cancellationToken);
        
        // 2. ê²Œì„ ìŠ¤í…Œì´ì§€ ìºì‹±
        await PrewarmStagesAsync(scope.ServiceProvider, cancellationToken);
        
        // 3. íƒ‘ í”Œë ˆì´ì–´ ë­í‚¹ ìºì‹±
        await PrewarmRankingsAsync(scope.ServiceProvider, cancellationToken);
        
        _logger.LogInformation("ìºì‹œ í”„ë¦¬ì›Œë° ì™„ë£Œ");
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    private async Task PrewarmItemsAsync(IServiceProvider provider, CancellationToken cancellationToken)
    {
        try
        {
            var itemRepository = provider.GetRequiredService<IItemRepository>();
            var redisService = provider.GetRequiredService<IRedisService>();
            
            _logger.LogInformation("ì•„ì´í…œ ë°ì´í„° í”„ë¦¬ì›Œë°...");
            
            var items = await itemRepository.GetAllItemsAsync();
            await redisService.SetAsync("game:items:all", items, TimeSpan.FromDays(1));
            
            _logger.LogInformation("ì•„ì´í…œ ë°ì´í„° í”„ë¦¬ì›Œë° ì™„ë£Œ. {Count}ê°œ í•­ëª©", items.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ì•„ì´í…œ ë°ì´í„° í”„ë¦¬ì›Œë° ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
        }
    }

    private async Task PrewarmStagesAsync(IServiceProvider provider, CancellationToken cancellationToken)
    {
        // ê²Œì„ ìŠ¤í…Œì´ì§€ ë°ì´í„° ìºì‹± êµ¬í˜„
    }

    private async Task PrewarmRankingsAsync(IServiceProvider provider, CancellationToken cancellationToken)
    {
        try
        {
            var rankingService = provider.GetRequiredService<IRankingService>();
            
            _logger.LogInformation("ë­í‚¹ ë°ì´í„° í”„ë¦¬ì›Œë°...");
            
            // íƒ‘ ë­í‚¹ ê°€ì ¸ì˜¤ê¸° - ì´ ì‘ì—…ì´ Redis Sorted Setì„ ì¤€ë¹„í•˜ê²Œ ë¨
            var topRankings = await rankingService.GetTopRankingsAsync(100);
            
            _logger.LogInformation("ë­í‚¹ ë°ì´í„° í”„ë¦¬ì›Œë° ì™„ë£Œ. {Count}ê°œ í•­ëª©", topRankings.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ë­í‚¹ ë°ì´í„° í”„ë¦¬ì›Œë° ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
        }
    }
}

// Program.csì— í˜¸ìŠ¤í‹°ë“œ ì„œë¹„ìŠ¤ ë“±ë¡
builder.Services.AddHostedService<CachePrewarmingService>();
```

### 6.6.4 ë¶„ì‚° ë½(Distributed Lock) êµ¬í˜„
ì—¬ëŸ¬ ì„œë²„ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ë™ì‹œì— ê°™ì€ ë¦¬ì†ŒìŠ¤ì— ì ‘ê·¼í•  ë•Œ ê²½ìŸ ìƒíƒœë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•œ ë¶„ì‚° ë½ì„ êµ¬í˜„í•œë‹¤.
  
![ë¶„ì‚° ë½(Distributed Lock)](./images/031.png)   

```csharp
// Services/RedisLockService.cs
public interface IRedisLockService
{
    Task<IDisposable> AcquireLockAsync(string resource, TimeSpan expiryTime, TimeSpan waitTime = default, TimeSpan retryTime = default);
}

public class RedisLockService : IRedisLockService
{
    private readonly RedisConfig _redisConfig;
    private readonly ILogger<RedisLockService> _logger;

    public RedisLockService(RedisConfig redisConfig, ILogger<RedisLockService> logger)
    {
        _redisConfig = redisConfig;
        _logger = logger;
    }

    public async Task<IDisposable> AcquireLockAsync(
        string resource,
        TimeSpan expiryTime,
        TimeSpan waitTime = default,
        TimeSpan retryTime = default)
    {
        if (retryTime == default)
        {
            retryTime = TimeSpan.FromMilliseconds(100);
        }
        
        var connection = await ConnectionMultiplexer.ConnectAsync(_redisConfig.Configuration);
        var db = connection.GetDatabase(_redisConfig.DefaultDatabase);
        
        var lockId = Guid.NewGuid().ToString();
        var lockKey = $"lock:{resource}";
        
        var startTime = DateTime.UtcNow;
        var expiry = waitTime == default ? TimeSpan.FromMilliseconds(-1) : waitTime;
        
        while (expiry == TimeSpan.FromMilliseconds(-1) || DateTime.UtcNow - startTime < expiry)
        {
            if (await db.LockTakeAsync(lockKey, lockId, expiryTime))
            {
                _logger.LogDebug("ë¦¬ì†ŒìŠ¤ {Resource}ì— ëŒ€í•œ ë½ íšë“. ë½ ID: {LockId}", resource, lockId);
                
                return new RedisLock(db, lockKey, lockId, _logger);
            }
            
            await Task.Delay(retryTime);
        }
        
        _logger.LogWarning("ë¦¬ì†ŒìŠ¤ {Resource}ì— ëŒ€í•œ ë½ íšë“ ì‹¤íŒ¨. ì œí•œ ì‹œê°„ ì´ˆê³¼", resource);
        throw new TimeoutException($"ë¦¬ì†ŒìŠ¤ '{resource}'ì— ëŒ€í•œ ë½ì„ íšë“í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
    }

    private class RedisLock : IDisposable
    {
        private readonly IDatabase _db;
        private readonly string _lockKey;
        private readonly string _lockId;
        private readonly ILogger _logger;
        private bool _disposed;

        public RedisLock(IDatabase db, string lockKey, string lockId, ILogger logger)
        {
            _db = db;
            _lockKey = lockKey;
            _lockId = lockId;
            _logger = logger;
            _disposed = false;
        }

        public void Dispose()
        {
            if (!_disposed)
            {
                _db.LockReleaseAsync(_lockKey, _lockId).ConfigureAwait(false).GetAwaiter().GetResult();
                _logger.LogDebug("ë¦¬ì†ŒìŠ¤ {Resource}ì— ëŒ€í•œ ë½ í•´ì œ. ë½ ID: {LockId}", _lockKey, _lockId);
                _disposed = true;
            }
        }
    }
}
```

### 6.6.5 ë¶„ì‚° ë½ì„ ì‚¬ìš©í•œ ì•„ì´í…œ êµ¬ë§¤ ë¡œì§

```csharp
public async Task<(bool Success, string Message)> PurchaseItemWithLockAsync(int playerId, int itemId, int quantity)
{
    string lockResource = $"player:{playerId}:purchase";
    
    try
    {
        // ë¶„ì‚° ë½ íšë“ ì‹œë„ (5ì´ˆ íƒ€ì„ì•„ì›ƒ, 10ì´ˆ ë§Œë£Œ)
        using (await _lockService.AcquireLockAsync(lockResource, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(5)))
        {
            // ì´ì œ í•´ë‹¹ í”Œë ˆì´ì–´ì˜ êµ¬ë§¤ ì‘ì—…ì— ëŒ€í•œ ë…ì ì  ì ‘ê·¼ ê¶Œí•œì´ ìˆìŒ
            
            // 1. í”Œë ˆì´ì–´ ì •ë³´ ì¡°íšŒ
            var player = await _redisService.GetAsync<Player>($"player:{playerId}");
            
            if (player == null)
            {
                // Redisì— ì—†ìœ¼ë©´ DBì—ì„œ ì¡°íšŒ
                player = await _playerRepository.GetByIdAsync(playerId);
                
                if (player == null)
                {
                    return (false, "í”Œë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                }
                
                // Redisì— ì €ì¥
                await _redisService.SetAsync($"player:{playerId}", player, TimeSpan.FromMinutes(10));
            }
            
            // 2. ì•„ì´í…œ ì •ë³´ ì¡°íšŒ
            var item = await _redisService.GetAsync<Item>($"item:{itemId}");
            
            if (item == null)
            {
                item = await _itemRepository.GetByIdAsync(itemId);
                
                if (item == null)
                {
                    return (false, "ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                }
                
                await _redisService.SetAsync($"item:{itemId}", item, TimeSpan.FromHours(1));
            }
            
            // 3. ì•„ì´í…œ ê°€ê²© ê³„ì‚°
            int totalPrice = item.Price * quantity;
            
            // 4. ê³¨ë“œ ì°¨ê°
            if (player.Gold < totalPrice)
            {
                return (false, "ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
            }
            
            player.Gold -= totalPrice;
            
            // 5. ì•„ì´í…œ ì¶”ê°€
            await _playerItemRepository.AddItemAsync(playerId, itemId, quantity);
            
            // 6. í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸
            await _playerRepository.UpdateAsync(player);
            
            // 7. Redis ìºì‹œ ì—…ë°ì´íŠ¸
            await _redisService.SetAsync($"player:{playerId}", player, TimeSpan.FromMinutes(10));
            
            // 8. ì¸ë²¤í† ë¦¬ ìºì‹œ ë¬´íš¨í™”
            await _redisService.DeleteAsync($"player:{playerId}:inventory");
            
            return (true, "ì•„ì´í…œ êµ¬ë§¤ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
        }
    }
    catch (TimeoutException)
    {
        return (false, "ì„œë²„ê°€ í˜¼ì¡í•©ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "ì•„ì´í…œ êµ¬ë§¤ ì¤‘ ì˜¤ë¥˜ ë°œìƒ. PlayerId: {PlayerId}, ItemId: {ItemId}", playerId, itemId);
        return (false, "ì•„ì´í…œ êµ¬ë§¤ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
    }
}
```
  

## 6.7 Redis ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”

### 6.7.1 Redis ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```csharp
// Services/RedisMonitoringService.cs
public class RedisMonitoringService : IHostedService, IDisposable
{
    private readonly RedisConfig _redisConfig;
    private readonly ILogger<RedisMonitoringService> _logger;
    private Timer _timer;
    private ConnectionMultiplexer _connection;

    public RedisMonitoringService(RedisConfig redisConfig, ILogger<RedisMonitoringService> logger)
    {
        _redisConfig = redisConfig;
        _logger = logger;
    }

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Redis ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì‹œì‘...");
        
        _connection = await ConnectionMultiplexer.ConnectAsync(_redisConfig.Configuration);
        
        // 15ë¶„ë§ˆë‹¤ ì‹¤í–‰
        _timer = new Timer(CollectMetrics, null, TimeSpan.Zero, TimeSpan.FromMinutes(15));
    }

    private void CollectMetrics(object state)
    {
        try
        {
            var server = _connection.GetServer(_redisConfig.GetServerEndPoint());
            var info = server.Info();
            
            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
            var memory = info.FirstOrDefault(x => x.Key == "memory");
            var usedMemory = memory.Value.FirstOrDefault(x => x.Key == "used_memory_human").Value;
            
            // ì—°ê²° ìˆ˜
            var clients = info.FirstOrDefault(x => x.Key == "clients");
            var connectedClients = clients.Value.FirstOrDefault(x => x.Key == "connected_clients").Value;
            
            // í‚¤ ê°œìˆ˜
            var database = _connection.GetDatabase(_redisConfig.DefaultDatabase);
            var keyCount = server.DatabaseSizeAsync(_redisConfig.DefaultDatabase).Result;
            
            // ëª…ë ¹ì–´ ì²˜ë¦¬ëŸ‰
            var stats = info.FirstOrDefault(x => x.Key == "stats");
            var totalCommands = stats.Value.FirstOrDefault(x => x.Key == "total_commands_processed").Value;
            
            _logger.LogInformation("Redis ì„±ëŠ¥ ë©”íŠ¸ë¦­ - ë©”ëª¨ë¦¬: {Memory}, ì—°ê²°: {Connections}, í‚¤: {Keys}, ëª…ë ¹ì–´: {Commands}",
                usedMemory, connectedClients, keyCount, totalCommands);
            
            // ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” ì´ ë©”íŠ¸ë¦­ì„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ(Prometheus, Grafana ë“±)ì— ë³´ë‚´ëŠ” ì½”ë“œë¥¼ ì¶”ê°€
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Redis ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
        }
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Redis ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì¤‘ì§€...");
        
        _timer?.Change(Timeout.Infinite, 0);
        
        return Task.CompletedTask;
    }

    public void Dispose()
    {
        _timer?.Dispose();
        _connection?.Dispose();
    }
}

// Program.csì— ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ë“±ë¡
builder.Services.AddHostedService<RedisMonitoringService>();
```

### 6.7.2 ìºì‹œ íˆíŠ¸ ë ˆì´íŠ¸ ì¸¡ì •

```csharp
// Services/CacheMetricsService.cs
public class CacheMetricsService
{
    private readonly ILogger<CacheMetricsService> _logger;
    private long _cacheHits;
    private long _cacheMisses;

    public CacheMetricsService(ILogger<CacheMetricsService> logger)
    {
        _logger = logger;
    }

    public void RecordHit()
    {
        Interlocked.Increment(ref _cacheHits);
    }

    public void RecordMiss()
    {
        Interlocked.Increment(ref _cacheMisses);
    }

    public double GetHitRate()
    {
        long hits = Interlocked.Read(ref _cacheHits);
        long misses = Interlocked.Read(ref _cacheMisses);
        
        long total = hits + misses;
        
        return total > 0 ? (double)hits / total : 0;
    }

    public void LogMetrics()
    {
        long hits = Interlocked.Read(ref _cacheHits);
        long misses = Interlocked.Read(ref _cacheMisses);
        long total = hits + misses;
        
        double hitRate = total > 0 ? (double)hits / total * 100 : 0;
        
        _logger.LogInformation("ìºì‹œ ì„±ëŠ¥ ë©”íŠ¸ë¦­ - íˆíŠ¸: {Hits}, ë¯¸ìŠ¤: {Misses}, íˆíŠ¸ìœ¨: {HitRate:F2}%",
            hits, misses, hitRate);
    }

    public void Reset()
    {
        Interlocked.Exchange(ref _cacheHits, 0);
        Interlocked.Exchange(ref _cacheMisses, 0);
    }
}
```

ìºì‹œ ë©”íŠ¸ë¦­ì„ ì‚¬ìš©í•˜ëŠ” ì„œë¹„ìŠ¤ ì˜ˆì œ:

```csharp
// Services/EnhancedRedisService.cs
public class EnhancedRedisService : IRedisService
{
    private readonly RedisConfig _redisConfig;
    private readonly CacheMetricsService _metricsService;
    
    // ê¸°ì¡´ êµ¬í˜„ ì¤‘ GetAsync ë©”ì„œë“œì— ë©”íŠ¸ë¦­ ê¸°ë¡ ì¶”ê°€
    public async Task<T> GetAsync<T>(string key)
    {
        var redis = new RedisString<T>(_redisConfig, key);
        var result = await redis.GetAsync();
        
        if (result.HasValue)
        {
            _metricsService.RecordHit();
            return result.Value;
        }
        
        _metricsService.RecordMiss();
        return default;
    }
    
    // ë‚˜ë¨¸ì§€ ë©”ì„œë“œ êµ¬í˜„...
}
```
  

## 6.8 ì¢…í•© ì˜ˆì œ: ì¼ì¼ ë³´ìƒ ì‹œìŠ¤í…œ
ë§ˆì§€ë§‰ìœ¼ë¡œ, Redisë¥¼ í™œìš©í•œ ì¼ì¼ ë³´ìƒ ì‹œìŠ¤í…œì„ êµ¬í˜„í•´ë³´ì. ì´ ì‹œìŠ¤í…œì€ í”Œë ˆì´ì–´ê°€ í•˜ë£¨ì— í•œ ë²ˆ ë¡œê·¸ì¸ ë³´ìƒì„ ë°›ì„ ìˆ˜ ìˆë„ë¡ í•œë‹¤.

### 6.8.1 ì¼ì¼ ë³´ìƒ ëª¨ë¸

```csharp
// Models/DailyReward.cs
public class DailyReward
{
    public int Day { get; set; }
    
    public List<RewardItem> Rewards { get; set; }
}

public class RewardItem
{
    public string Type { get; set; } // "gold", "gem", "item" ë“±
    public int Id { get; set; } // ì•„ì´í…œì¸ ê²½ìš° ì•„ì´í…œ ID
    public int Amount { get; set; } // ìˆ˜ëŸ‰
}

public class PlayerDailyRewardStatus
{
    public int PlayerId { get; set; }
    public int CurrentDay { get; set; } // í˜„ì¬ ì¼ì°¨
    public DateTime LastClaimTime { get; set; } // ë§ˆì§€ë§‰ ë³´ìƒ ìˆ˜ë ¹ ì‹œê°„
    public bool CanClaimToday { get; set; } // ì˜¤ëŠ˜ ë³´ìƒ ìˆ˜ë ¹ ê°€ëŠ¥ ì—¬ë¶€
}

public class ClaimDailyRewardRequest
{
    public int PlayerId { get; set; }
}

public class ClaimDailyRewardResponse
{
    public bool Success { get; set; }
    public DailyReward Reward { get; set; }
    public PlayerDailyRewardStatus Status { get; set; }
    public string Message { get; set; }
}
```

### 6.8.2 ì¼ì¼ ë³´ìƒ ì„œë¹„ìŠ¤
  
![ì¼ì¼ ë³´ìƒ ì„œë¹„ìŠ¤](./images/032.png)   

```csharp
// Services/DailyRewardService.cs
public interface IDailyRewardService
{
    Task<PlayerDailyRewardStatus> GetPlayerStatusAsync(int playerId);
    Task<(bool Success, DailyReward Reward, PlayerDailyRewardStatus Status, string Message)> ClaimDailyRewardAsync(int playerId);
}

public class DailyRewardService : IDailyRewardService
{
    private readonly RedisConfig _redisConfig;
    private readonly IPlayerRepository _playerRepository;
    private readonly IInventoryService _inventoryService;
    private readonly IRedisLockService _lockService;
    private readonly ILogger<DailyRewardService> _logger;
    
    // ì¼ì¼ ë³´ìƒ ì •ì˜ (ì‹¤ì œë¡œëŠ” DBë‚˜ ì„¤ì • íŒŒì¼ì—ì„œ ë¡œë“œ)
    private readonly List<DailyReward> _dailyRewards = new List<DailyReward>
    {
        new DailyReward { Day = 1, Rewards = new List<RewardItem> { new RewardItem { Type = "gold", Amount = 1000 } } },
        new DailyReward { Day = 2, Rewards = new List<RewardItem> { new RewardItem { Type = "gem", Amount = 50 } } },
        new DailyReward { Day = 3, Rewards = new List<RewardItem> { new RewardItem { Type = "item", Id = 101, Amount = 1 } } },
        new DailyReward { Day = 4, Rewards = new List<RewardItem> { new RewardItem { Type = "gold", Amount = 2000 } } },
        new DailyReward { Day = 5, Rewards = new List<RewardItem> { new RewardItem { Type = "gem", Amount = 100 } } },
        new DailyReward { Day = 6, Rewards = new List<RewardItem> { new RewardItem { Type = "item", Id = 102, Amount = 1 } } },
        new DailyReward { Day = 7, Rewards = new List<RewardItem> { 
            new RewardItem { Type = "gold", Amount = 5000 },
            new RewardItem { Type = "gem", Amount = 200 },
            new RewardItem { Type = "item", Id = 103, Amount = 1 }
        }}
    };

    public DailyRewardService(
        RedisConfig redisConfig,
        IPlayerRepository playerRepository,
        IInventoryService inventoryService,
        IRedisLockService lockService,
        ILogger<DailyRewardService> logger)
    {
        _redisConfig = redisConfig;
        _playerRepository = playerRepository;
        _inventoryService = inventoryService;
        _lockService = lockService;
        _logger = logger;
    }

    public async Task<PlayerDailyRewardStatus> GetPlayerStatusAsync(int playerId)
    {
        string key = $"player:{playerId}:daily_reward";
        
        // Redisì—ì„œ ì¼ì¼ ë³´ìƒ ìƒíƒœ ì¡°íšŒ
        var redis = new RedisString<PlayerDailyRewardStatus>(_redisConfig, key);
        var result = await redis.GetAsync();
        
        if (result.HasValue)
        {
            var status = result.Value;
            
            // ë‚ ì§œê°€ ë°”ë€Œì—ˆëŠ”ì§€ í™•ì¸
            bool isNewDay = IsNewDay(status.LastClaimTime);
            status.CanClaimToday = isNewDay;
            
            return status;
        }
        
        // ì²˜ìŒ ì ‘ì†í•˜ëŠ” í”Œë ˆì´ì–´ì¸ ê²½ìš° ê¸°ë³¸ ìƒíƒœ ìƒì„±
        var newStatus = new PlayerDailyRewardStatus
        {
            PlayerId = playerId,
            CurrentDay = 0, // ì•„ì§ ë³´ìƒì„ ë°›ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ 0ì¼ì°¨
            LastClaimTime = DateTime.MinValue,
            CanClaimToday = true // ì²˜ìŒì´ë¯€ë¡œ ë°›ì„ ìˆ˜ ìˆìŒ
        };
        
        // Redisì— ì €ì¥ (7ì¼ ìœ ì§€)
        await redis.SetAsync(newStatus, TimeSpan.FromDays(7));
        
        return newStatus;
    }

    public async Task<(bool Success, DailyReward Reward, PlayerDailyRewardStatus Status, string Message)> ClaimDailyRewardAsync(int playerId)
    {
        string lockKey = $"player:{playerId}:daily_reward:lock";
        
        try
        {
            // ë¶„ì‚° ë½ íšë“ (ë™ì‹œ ìš”ì²­ ë°©ì§€)
            using (await _lockService.AcquireLockAsync(lockKey, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(5)))
            {
                // í˜„ì¬ ìƒíƒœ ì¡°íšŒ
                var status = await GetPlayerStatusAsync(playerId);
                
                // ì´ë¯¸ ì˜¤ëŠ˜ ë³´ìƒì„ ë°›ì•˜ëŠ”ì§€ í™•ì¸
                if (!status.CanClaimToday)
                {
                    return (false, null, status, "ì˜¤ëŠ˜ì€ ì´ë¯¸ ì¼ì¼ ë³´ìƒì„ ë°›ì•˜ìŠµë‹ˆë‹¤.");
                }
                
                // ë‹¤ìŒ ì¼ì°¨ ê³„ì‚°
                int nextDay = status.CurrentDay + 1;
                
                // 7ì¼ ì£¼ê¸°ë¡œ ë¦¬ì…‹
                if (nextDay > 7)
                {
                    nextDay = 1;
                }
                
                // í•´ë‹¹ ì¼ì°¨ ë³´ìƒ ê°€ì ¸ì˜¤ê¸°
                var reward = _dailyRewards.FirstOrDefault(r => r.Day == nextDay);
                
                if (reward == null)
                {
                    return (false, null, status, "ë³´ìƒ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                }
                
                // í”Œë ˆì´ì–´ ì¡°íšŒ
                var player = await _playerRepository.GetByIdAsync(playerId);
                
                if (player == null)
                {
                    return (false, null, status, "í”Œë ˆì´ì–´ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                }
                
                // ë³´ìƒ ì§€ê¸‰
                foreach (var item in reward.Rewards)
                {
                    switch (item.Type)
                    {
                        case "gold":
                            player.Gold += item.Amount;
                            break;
                            
                        case "gem":
                            player.Gems += item.Amount;
                            break;
                            
                        case "item":
                            await _inventoryService.AddItemToInventoryAsync(playerId, item.Id, item.Amount);
                            break;
                    }
                }
                
                // í”Œë ˆì´ì–´ ì •ë³´ ì—…ë°ì´íŠ¸
                await _playerRepository.UpdateAsync(player);
                
                // ì¼ì¼ ë³´ìƒ ìƒíƒœ ì—…ë°ì´íŠ¸
                status.CurrentDay = nextDay;
                status.LastClaimTime = DateTime.UtcNow;
                status.CanClaimToday = false;
                
                // Redisì— ì—…ë°ì´íŠ¸ëœ ìƒíƒœ ì €ì¥
                string key = $"player:{playerId}:daily_reward";
                var redis = new RedisString<PlayerDailyRewardStatus>(_redisConfig, key);
                await redis.SetAsync(status, TimeSpan.FromDays(7));
                
                return (true, reward, status, "ì¼ì¼ ë³´ìƒì´ ì§€ê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤.");
            }
        }
        catch (TimeoutException)
        {
            return (false, null, null, "ì„œë²„ê°€ í˜¼ì¡í•©ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ì¼ì¼ ë³´ìƒ ì§€ê¸‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ. PlayerId: {PlayerId}", playerId);
            return (false, null, null, "ë³´ìƒ ì§€ê¸‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
        }
    }

    private bool IsNewDay(DateTime lastClaimTime)
    {
        // UTC ê¸°ì¤€ í˜„ì¬ ì‹œê°„
        var now = DateTime.UtcNow;
        
        // ë§ˆì§€ë§‰ ë³´ìƒ ì‹œê°„ì´ ì˜¤ëŠ˜ì´ ì•„ë‹Œ ê²½ìš°
        return lastClaimTime.Date < now.Date;
    }
}
```    
    
  
**ì‹œìŠ¤í…œ êµ¬ì¡°:**
- **7ì¼ ì£¼ê¸° ë³´ìƒ**: 1~7ì¼ì°¨ ë³´ìƒ í›„ 1ì¼ì°¨ë¡œ ë¦¬ì…‹
- **Redis ìºì‹±**: í”Œë ˆì´ì–´ ìƒíƒœë¥¼ ë¹ ë¥´ê²Œ ì¡°íšŒ/ì—…ë°ì´íŠ¸
- **ë¶„ì‚° ë½**: ë™ì‹œ ìš”ì²­ ë°©ì§€ë¡œ ì¤‘ë³µ ì§€ê¸‰ ì°¨ë‹¨

**ì£¼ìš” ê¸°ëŠ¥:**
1. **ìƒíƒœ ì¡°íšŒ (GetPlayerStatusAsync)**
   - Redisì—ì„œ í”Œë ˆì´ì–´ ë³´ìƒ ìƒíƒœ ì¡°íšŒ
   - ë‚ ì§œ ë³€ê²½ ê²€ì¦ìœ¼ë¡œ `CanClaimToday` ì—…ë°ì´íŠ¸
   - ì²« ì ‘ì†ìëŠ” ê¸°ë³¸ ìƒíƒœ ìƒì„±

2. **ë³´ìƒ ì§€ê¸‰ (ClaimDailyRewardAsync)**
   - ë¶„ì‚° ë½ìœ¼ë¡œ ë™ì‹œ ìš”ì²­ ë°©ì§€
   - ì§€ê¸‰ ê°€ëŠ¥ ì—¬ë¶€ ê²€ì¦
   - ë‹¤ìŒ ì¼ì°¨ ê³„ì‚° (7ì¼ ì´ˆê³¼ ì‹œ 1ì¼ë¡œ ë¦¬ì…‹)
   - ê³¨ë“œ/ì ¬/ì•„ì´í…œ ì§€ê¸‰
   - DB ë° Redis ìƒíƒœ ì—…ë°ì´íŠ¸

**ë³´ìƒ íƒ€ì…:**
- **ê³¨ë“œ**: í”Œë ˆì´ì–´ ê³¨ë“œ ì§ì ‘ ì¦ê°€
- **ì ¬**: í”Œë ˆì´ì–´ ì ¬ ì§ì ‘ ì¦ê°€  
- **ì•„ì´í…œ**: ì¸ë²¤í† ë¦¬ ì„œë¹„ìŠ¤ë¥¼ í†µí•œ ì•„ì´í…œ ì§€ê¸‰

**ì•ˆì „ ì¥ì¹˜:**
- **ë¶„ì‚° ë½**: ì¤‘ë³µ ì§€ê¸‰ ë°©ì§€
- **ë‚ ì§œ ê²€ì¦**: í•˜ë£¨ í•œ ë²ˆë§Œ ì§€ê¸‰
- **ì˜ˆì™¸ ì²˜ë¦¬**: íƒ€ì„ì•„ì›ƒ, ì˜¤ë¥˜ ìƒí™© ëŒ€ì‘
- **TTL ê´€ë¦¬**: 7ì¼ ìë™ ë§Œë£Œë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±

**ë°ì´í„° êµ¬ì¡°:**
- `player:{playerId}:daily_reward` â†’ í”Œë ˆì´ì–´ ë³´ìƒ ìƒíƒœ
- `player:{playerId}:daily_reward:lock` â†’ ë¶„ì‚° ë½ í‚¤
- TTL 7ì¼ë¡œ ìë™ ì •ë¦¬

ì´ ì‹œìŠ¤í…œì€ ê²Œì„ì˜ ì‚¬ìš©ì ìœ ì§€ìœ¨ í–¥ìƒì„ ìœ„í•œ í•µì‹¬ ê¸°ëŠ¥ìœ¼ë¡œ, ì•ˆì •ì ì´ê³  í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°ë¥¼ ì œê³µí•œë‹¤.


### 6.8.3 ì¼ì¼ ë³´ìƒ ì»¨íŠ¸ë¡¤ëŸ¬

```csharp
// Controllers/DailyRewardController.cs
[ApiController]
[Route("api/[controller]")]
public class DailyRewardController : ControllerBase
{
    private readonly IDailyRewardService _dailyRewardService;

    public DailyRewardController(IDailyRewardService dailyRewardService)
    {
        _dailyRewardService = dailyRewardService;
    }

    [HttpPost("status")]
    public async Task<DailyRewardStatusResponse> GetStatus([FromBody] DailyRewardStatusRequest request)
    {
        var status = await _dailyRewardService.GetPlayerStatusAsync(request.PlayerId);
        
        return new DailyRewardStatusResponse
        {
            Success = true,
            Status = status
        };
    }

    [HttpPost("claim")]
    public async Task<ClaimDailyRewardResponse> ClaimReward([FromBody] ClaimDailyRewardRequest request)
    {
        var (success, reward, status, message) = await _dailyRewardService.ClaimDailyRewardAsync(request.PlayerId);
        
        return new ClaimDailyRewardResponse
        {
            Success = success,
            Reward = reward,
            Status = status,
            Message = message
        };
    }
}

public class DailyRewardStatusRequest
{
    public int PlayerId { get; set; }
}

public class DailyRewardStatusResponse
{
    public bool Success { get; set; }
    public PlayerDailyRewardStatus Status { get; set; }
    public string Message { get; set; }
}
```

### 6.8.4 ì¼ì¼ ë³´ìƒ HTTP ìš”ì²­ í…ŒìŠ¤íŠ¸

```
### ì¼ì¼ ë³´ìƒ ìƒíƒœ í™•ì¸
POST https://localhost:5001/api/dailyreward/status
Content-Type: application/json
X-Session-Token: {{sessionToken}}

{
  "playerId": 1
}

### ì¼ì¼ ë³´ìƒ ìˆ˜ë ¹
POST https://localhost:5001/api/dailyreward/claim
Content-Type: application/json
X-Session-Token: {{sessionToken}}

{
  "playerId": 1
}
```
  

## 6.9 ì •ë¦¬
ì´ ì±•í„°ì—ì„œëŠ” ê²Œì„ ì„œë²„ ê°œë°œì— í•„ìˆ˜ì ì¸ Redis ìºì‹œ ì‹œìŠ¤í…œì„ CloudStructures ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ì‚´í´ë´¤ë‹¤. ì£¼ìš” ë‚´ìš©ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

1. **Redisì˜ í•„ìš”ì„±**: ê²Œì„ ì„œë²„ì—ì„œ Redisê°€ ë°ì´í„°ë² ì´ìŠ¤ ë¶€í•˜ ê°ì†Œ, ë¹ ë¥¸ ì‘ë‹µ ì‹œê°„, ì„ì‹œ ë°ì´í„° ì €ì¥ ë“±ì— ì–´ë–»ê²Œ ë„ì›€ì´ ë˜ëŠ”ì§€ ì„¤ëª…í–ˆë‹¤.

2. **CloudStructures ì†Œê°œ**: íƒ€ì… ì•ˆì „ì„±ê³¼ ë¹„ë™ê¸° ì§€ì›ì„ ì œê³µí•˜ëŠ” ê³ ìˆ˜ì¤€ Redis í´ë¼ì´ì–¸íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì¸ CloudStructuresì˜ íŠ¹ì§•ì„ ì•Œì•„ë´¤ë‹¤.

3. **ìºì‹± ì „ëµ**: ìºì‹œ-ì–´ì‚¬ì´ë“œ, ë¼ì´íŠ¸-ë¹„í•˜ì¸ë“œ, ì“°ê¸°-ìŠ¤ë£¨ ë“± ë‹¤ì–‘í•œ ìºì‹± íŒ¨í„´ê³¼ ê²Œì„ ë°ì´í„°ì— ì í•©í•œ ìºì‹± ì „ëµì„ ì„¤ëª…í–ˆë‹¤.

4. **ì‹¤ì œ ì‹œìŠ¤í…œ êµ¬í˜„**: ì¸ì¦ ë° ì„¸ì…˜ ê´€ë¦¬, ì¸ë²¤í† ë¦¬ ê´€ë¦¬, ë­í‚¹ ì‹œìŠ¤í…œ ë“± ê²Œì„ ì„œë²„ì˜ ì£¼ìš” ê¸°ëŠ¥ì„ Redisë¥¼ í™œìš©í•˜ì—¬ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ì½”ë“œì™€ í•¨ê»˜ ìì„¸íˆ ì„¤ëª…í–ˆë‹¤.

5. **ê³ ê¸‰ Redis í™œìš©**: ìºì‹œ ë¬´íš¨í™”, ë¶„ì‚° ë½, ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë“± ê³ ê¸‰ Redis í™œìš© ê¸°ë²•ì„ ë‹¤ë¤˜ë‹¤.

6. **ì¢…í•© ì˜ˆì œ**: ì¼ì¼ ë³´ìƒ ì‹œìŠ¤í…œì„ í†µí•´ Redisë¥¼ í™œìš©í•œ ì‹¤ì œ ê²Œì„ ê¸°ëŠ¥ êµ¬í˜„ ë°©ë²•ì„ ì¢…í•©ì ìœ¼ë¡œ ì•Œì•„ë´¤ë‹¤.

Redisë¥¼ íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•˜ë©´ ê²Œì„ ì„œë²„ì˜ ì„±ëŠ¥ê³¼ í™•ì¥ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤. ë‹¤ì–‘í•œ ë°ì´í„° êµ¬ì¡°ë¥¼ ì œê³µí•˜ëŠ” Redisë¥¼ CloudStructures ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ë©´ ë³µì¡í•œ ê²Œì„ ê¸°ëŠ¥ë„ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
