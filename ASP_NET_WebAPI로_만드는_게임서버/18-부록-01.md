# ASP.NET Core Web API로 게임 서버 개발
  
저자: 최흥배, Claude AI   
-----------------------    
   
# 부록: 게임 서버 개발 참조 자료

## 1. MySQL 및 Redis 명령어 레퍼런스

### MySQL 주요 명령어

#### 기본 쿼리 명령어

```sql
-- 데이터베이스 생성
CREATE DATABASE game_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 테이블 생성 예시 (유저 테이블)
CREATE TABLE users (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    account_id VARCHAR(50) NOT NULL UNIQUE,
    nickname VARCHAR(30) NOT NULL,
    level INT NOT NULL DEFAULT 1,
    exp INT NOT NULL DEFAULT 0,
    gold INT NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_login_at DATETIME NULL
);

-- 인덱스 생성
CREATE INDEX idx_nickname ON users(nickname);

-- 조회
SELECT * FROM users WHERE level > 10 ORDER BY exp DESC LIMIT 100;

-- 삽입
INSERT INTO users (account_id, nickname) VALUES ('player123', 'DragonSlayer');

-- 업데이트
UPDATE users SET gold = gold + 1000 WHERE id = 1;

-- 트랜잭션
START TRANSACTION;
UPDATE users SET gold = gold - 100 WHERE id = 1;
INSERT INTO item_inventory (user_id, item_id, quantity) VALUES (1, 5, 1);
COMMIT;
```

#### MySqlConnector 및 SqlKata 사용 예제

```csharp
// MySqlConnector 및 SqlKata 설정
public static class DatabaseSetup
{
    public static void AddGameDatabase(this IServiceCollection services, IConfiguration configuration)
    {
        var connectionString = configuration.GetConnectionString("GameDB");
        
        services.AddSingleton<QueryFactory>(provider =>
        {
            var connection = new MySqlConnection(connectionString);
            var compiler = new MySqlCompiler();
            
            return new QueryFactory(connection, compiler);
        });
    }
}

// 쿼리 예제 (UserRepository)
public class UserRepository : IUserRepository
{
    private readonly QueryFactory _db;
    
    public UserRepository(QueryFactory db)
    {
        _db = db;
    }
    
    public async Task<User> GetUserByIdAsync(long userId)
    {
        return await _db.Query("users")
                        .Where("id", userId)
                        .FirstOrDefaultAsync<User>();
    }
    
    public async Task<bool> UpdateUserGoldAsync(long userId, int goldAmount)
    {
        var affected = await _db.Query("users")
                               .Where("id", userId)
                               .IncrementAsync("gold", goldAmount);
                               
        return affected > 0;
    }
    
    public async Task<List<User>> GetTopUsersByLevelAsync(int limit = 100)
    {
        return await _db.Query("users")
                        .OrderByDesc("level")
                        .ThenByDesc("exp")
                        .LimitAsync<User>(limit);
    }
    
    public async Task<bool> ExecuteItemPurchaseAsync(long userId, int itemId, int price)
    {
        using var connection = (MySqlConnection)_db.Connection;
        await connection.OpenAsync();
        
        using var transaction = await connection.BeginTransactionAsync();
        try
        {
            // 골드 차감
            var deductGoldResult = await _db.Query("users")
                                           .Where("id", userId)
                                           .Where("gold", ">=", price)
                                           .DecrementAsync("gold", price);
                                           
            if (deductGoldResult == 0)
                throw new InvalidOperationException("Not enough gold");
                
            // 아이템 인벤토리에 추가
            await _db.Query("item_inventory").InsertAsync(new {
                user_id = userId,
                item_id = itemId,
                quantity = 1,
                created_at = DateTime.UtcNow
            });
            
            await transaction.CommitAsync();
            return true;
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}
```

### Redis 주요 명령어

#### 기본 Redis 명령어

```
# 문자열 저장 및 조회
SET user:1:nickname "DragonSlayer"
GET user:1:nickname

# 숫자형 증가 및 감소
SET user:1:gold 1000
INCRBY user:1:gold 500
DECRBY user:1:gold 200

# 해시 데이터 처리
HMSET user:1 id 1 nickname "DragonSlayer" level 10 exp 1500 gold 1300
HGETALL user:1
HGET user:1 gold

# 목록 데이터 처리 (최근 활동 기록)
LPUSH user:1:activities "로그인"
LPUSH user:1:activities "아이템 구매"
LRANGE user:1:activities 0 -1

# 집합 데이터 처리 (보유 아이템)
SADD user:1:items 101 102 103
SMEMBERS user:1:items
SISMEMBER user:1:items 101

# 정렬 집합 데이터 처리 (랭킹)
ZADD leaderboard:level 10 "user:1"
ZADD leaderboard:level 15 "user:2"
ZREVRANGE leaderboard:level 0 9 WITHSCORES

# 키 만료 설정 (임시 이벤트)
SET event:special "2배 경험치" EX 86400

# 트랜잭션
MULTI
DECRBY user:1:gold 100
SADD user:1:items 104
EXEC
```

#### CloudStructures 사용 예제

```csharp
// Redis 설정
public static class RedisSetup
{
    public static void AddRedisCache(this IServiceCollection services, IConfiguration configuration)
    {
        var redisConfig = new RedisConfig("GameCache", configuration["Redis:ConnectionString"]);
        services.AddSingleton(redisConfig);
        
        // 일반적인 Redis 캐시 서비스 등록
        services.AddSingleton<IGameCacheService, RedisCacheService>();
        
        // 랭킹 서비스 등록
        services.AddSingleton<IRankingService, RedisRankingService>();
    }
}

// 기본 캐시 서비스 구현
public class RedisCacheService : IGameCacheService
{
    private readonly RedisConfig _config;
    
    public RedisCacheService(RedisConfig config)
    {
        _config = config;
    }
    
    // 유저 데이터 캐싱
    public async Task<bool> SetUserDataAsync(long userId, UserData userData, TimeSpan? expiry = null)
    {
        var redis = new RedisString<UserData>(_config, $"user:{userId}");
        return await redis.SetAsync(userData, expiry ?? TimeSpan.FromHours(1));
    }
    
    public async Task<UserData?> GetUserDataAsync(long userId)
    {
        var redis = new RedisString<UserData>(_config, $"user:{userId}");
        var result = await redis.GetAsync();
        return result.HasValue ? result.Value : null;
    }
    
    // 아이템 인벤토리 관리
    public async Task<bool> AddUserItemAsync(long userId, int itemId)
    {
        var redis = new RedisSet<int>(_config, $"user:{userId}:items");
        return await redis.AddAsync(itemId);
    }
    
    public async Task<List<int>> GetUserItemsAsync(long userId)
    {
        var redis = new RedisSet<int>(_config, $"user:{userId}:items");
        var result = await redis.MembersAsync();
        return result.ToList();
    }
    
    // 활동 로그 기록
    public async Task AddUserActivityAsync(long userId, string activity)
    {
        var redis = new RedisList<string>(_config, $"user:{userId}:activities");
        await redis.LeftPushAsync(activity);
        // 최대 100개 활동만 유지
        await redis.TrimAsync(0, 99);
    }
    
    // 세션 토큰 관리
    public async Task<bool> SetSessionTokenAsync(string token, long userId)
    {
        var redis = new RedisString<long>(_config, $"session:{token}");
        return await redis.SetAsync(userId, TimeSpan.FromDays(1));
    }
    
    public async Task<long?> GetUserIdBySessionTokenAsync(string token)
    {
        var redis = new RedisString<long>(_config, $"session:{token}");
        var result = await redis.GetAsync();
        return result.HasValue ? result.Value : null;
    }
}

// 랭킹 서비스 구현
public class RedisRankingService : IRankingService
{
    private readonly RedisConfig _config;
    private const string LevelLeaderboard = "leaderboard:level";
    private const string PowerLeaderboard = "leaderboard:power";
    
    public RedisRankingService(RedisConfig config)
    {
        _config = config;
    }
    
    public async Task UpdateUserRankAsync(long userId, int level, int power)
    {
        var levelRank = new RedisSortedSet<string>(_config, LevelLeaderboard);
        var powerRank = new RedisSortedSet<string>(_config, PowerLeaderboard);
        
        await levelRank.AddAsync($"user:{userId}", level);
        await powerRank.AddAsync($"user:{userId}", power);
    }
    
    public async Task<List<RankingEntry>> GetTopLevelRankingsAsync(int count = 100)
    {
        var redis = new RedisSortedSet<string>(_config, LevelLeaderboard);
        var result = await redis.RangeByRankAsync(0, count - 1, true);
        
        return result.Select((item, index) => new RankingEntry
        {
            Rank = index + 1,
            UserId = long.Parse(item.Value.Split(':')[1]),
            Score = (int)item.Score
        }).ToList();
    }
    
    public async Task<int?> GetUserLevelRankAsync(long userId)
    {
        var redis = new RedisSortedSet<string>(_config, LevelLeaderboard);
        var rank = await redis.RankAsync($"user:{userId}", true);
        
        return rank.HasValue ? (int)rank.Value + 1 : null;
    }
}
```
  

## 2. .http 파일 예제 모음

### .http 파일 기본 구성 및 사용법

```http
### 변수 정의
@baseUrl = https://localhost:5001/api
@authToken = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

### 계정 생성
POST {{baseUrl}}/account/create
Content-Type: application/json

{
    "email": "player@example.com",
    "password": "SecurePassword123!",
    "deviceId": "device-12345"
}

### 로그인
POST {{baseUrl}}/account/login
Content-Type: application/json

{
    "email": "player@example.com",
    "password": "SecurePassword123!",
    "deviceId": "device-12345"
}

### 인증이 필요한 요청 예시 (캐릭터 생성)
POST {{baseUrl}}/game/character/create
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "nickname": "DragonSlayer",
    "characterClass": 1
}
```

### 게임 API 테스트 시나리오 예제

#### 계정 및 인증 관련 API

```http
@baseUrl = https://localhost:5001/api
@email = player@example.com
@password = SecurePassword123!
@deviceId = device-12345

### 1. 계정 생성
POST {{baseUrl}}/account/create
Content-Type: application/json

{
    "email": "{{email}}",
    "password": "{{password}}",
    "deviceId": "{{deviceId}}"
}

### 2. 로그인
# @name login
POST {{baseUrl}}/account/login
Content-Type: application/json

{
    "email": "{{email}}",
    "password": "{{password}}",
    "deviceId": "{{deviceId}}"
}

### 응답에서 토큰 추출
@authToken = {{login.response.body.data.token}}

### 3. 토큰 갱신
POST {{baseUrl}}/account/refresh-token
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "refreshToken": "{{login.response.body.data.refreshToken}}"
}

### 4. 비밀번호 변경
POST {{baseUrl}}/account/change-password
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "currentPassword": "{{password}}",
    "newPassword": "NewSecurePassword456!"
}

### 5. 로그아웃
POST {{baseUrl}}/account/logout
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "deviceId": "{{deviceId}}"
}
```

#### 게임 플레이 관련 API

```http
@baseUrl = https://localhost:5001/api
@authToken = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

### 1. 캐릭터 정보 조회
POST {{baseUrl}}/game/character/info
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345
}

### 2. 아이템 인벤토리 조회
POST {{baseUrl}}/game/inventory
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345
}

### 3. 상점 아이템 구매
POST {{baseUrl}}/game/shop/purchase
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "itemId": 1001,
    "quantity": 1
}

### 4. 아이템 사용
POST {{baseUrl}}/game/item/use
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "inventoryItemId": 5001
}

### 5. 친구 목록 조회
POST {{baseUrl}}/game/friends
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345
}

### 6. 친구 추가
POST {{baseUrl}}/game/friends/add
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "friendNickname": "FriendPlayer"
}

### 7. 퀘스트 목록 조회
POST {{baseUrl}}/game/quests
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345
}

### 8. 퀘스트 완료 요청
POST {{baseUrl}}/game/quests/complete
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "questId": 2001
}

### 9. 던전 입장
POST {{baseUrl}}/game/dungeon/enter
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "dungeonId": 3001,
    "difficulty": 2
}

### 10. 던전 결과 제출
POST {{baseUrl}}/game/dungeon/complete
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "dungeonId": 3001,
    "difficulty": 2,
    "clearTime": 125,
    "killCount": 45,
    "damageDealt": 12500,
    "damageTaken": 3200
}
```

#### 가챠 시스템 API

```http
@baseUrl = https://localhost:5001/api
@authToken = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

### 1. 가챠 목록 조회
POST {{baseUrl}}/game/gacha/list
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345
}

### 2. 가챠 확률 조회
POST {{baseUrl}}/game/gacha/rates
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "gachaId": 1
}

### 3. 단일 가챠 실행
POST {{baseUrl}}/game/gacha/draw
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "gachaId": 1
}

### 4. 10연속 가챠 실행
POST {{baseUrl}}/game/gacha/draw-multi
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "gachaId": 1,
    "count": 10
}
```

#### 길드 시스템 API

```http
@baseUrl = https://localhost:5001/api
@authToken = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

### 1. 길드 목록 조회
POST {{baseUrl}}/game/guild/list
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "page": 1,
    "pageSize": 20
}

### 2. 길드 생성
POST {{baseUrl}}/game/guild/create
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "guildName": "DragonSlayers",
    "description": "We slay dragons together!"
}

### 3. 길드 가입 신청
POST {{baseUrl}}/game/guild/apply
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "guildId": 100
}

### 4. 길드 가입 신청 처리 (길드 관리자)
POST {{baseUrl}}/game/guild/process-application
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "guildId": 100,
    "applicantId": 54321,
    "accept": true
}

### 5. 길드 정보 조회
POST {{baseUrl}}/game/guild/info
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "guildId": 100
}

### 6. 길드원 목록 조회
POST {{baseUrl}}/game/guild/members
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "guildId": 100
}

### 7. 길드 채팅 메시지 전송
POST {{baseUrl}}/game/guild/chat
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "guildId": 100,
    "message": "안녕하세요, 모두!"
}

### 8. 길드 채팅 메시지 조회
POST {{baseUrl}}/game/guild/chat/history
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "characterId": 12345,
    "guildId": 100,
    "lastMessageId": 0,
    "limit": 50
}
```
  

## 3. 유용한 ASP.NET Core 확장 라이브러리

### 성능 최적화 및 캐싱 라이브러리

#### 1. Polly - 오류 처리 및 복원력

```csharp
// Polly 설치: dotnet add package Polly

// 예제: 데이터베이스 연결 재시도 정책 구현
public static class PollyExtensions
{
    public static IServiceCollection AddRetryPolicy(this IServiceCollection services)
    {
        var retryPolicy = Policy
            .Handle<MySqlException>()
            .Or<TimeoutException>()
            .WaitAndRetryAsync(
                3, 
                retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                onRetry: (exception, timeSpan, retryCount, context) =>
                {
                    Log.Warning($"Retry {retryCount} after {timeSpan.TotalSeconds}s due to: {exception.Message}");
                });

        services.AddSingleton<IAsyncPolicy>(retryPolicy);
        
        return services;
    }
}

// 사용 예시
public class UserRepository : IUserRepository
{
    private readonly QueryFactory _db;
    private readonly IAsyncPolicy _retryPolicy;
    
    public UserRepository(QueryFactory db, IAsyncPolicy retryPolicy)
    {
        _db = db;
        _retryPolicy = retryPolicy;
    }
    
    public async Task<User> GetUserByIdAsync(long userId)
    {
        return await _retryPolicy.ExecuteAsync(async () =>
        {
            return await _db.Query("users")
                           .Where("id", userId)
                           .FirstOrDefaultAsync<User>();
        });
    }
}
```

#### 2. Response Caching 및 Output Caching

```csharp
// Program.cs에 추가 설정
builder.Services.AddResponseCaching();
builder.Services.AddOutputCache(options =>
{
    // 기본 만료 시간 설정
    options.DefaultExpirationTimeSpan = TimeSpan.FromMinutes(5);
    
    // 특정 요청 패턴에 대한 캐시 정책 설정
    options.AddPolicy("GameStaticData", builder => 
        builder.Cache()
               .Expire(TimeSpan.FromHours(1)));
});

// 미들웨어 등록
app.UseResponseCaching();
app.UseOutputCache();

// 컨트롤러에서 사용
[HttpPost("items/list")]
[OutputCache(PolicyName = "GameStaticData")]
public async Task<ItemListResponse> GetItemList([FromBody] ItemListRequest request)
{
    var items = await _itemService.GetItemsAsync();
    
    return new ItemListResponse
    {
        Result = GameResultCode.Success,
        Items = items
    };
}
```

#### 3. MiniProfiler - 성능 분석

```csharp
// MiniProfiler 설치: dotnet add package MiniProfiler.AspNetCore.Mvc

// Program.cs에 추가
builder.Services.AddMiniProfiler(options =>
{
    // 개발 환경에서만 활성화
    options.RouteBasePath = "/profiler";
    
    // 특정 경로만 프로파일링
    options.ShouldProfile = request => 
        request.Path.StartsWithSegments("/api/game");
        
    // SQL 프로파일링 추가
    options.SqlFormatter = new StackExchange.Profiling.SqlFormatters.SqlServerFormatter();
});

// 미들웨어 등록 (개발 환경에서만)
if (app.Environment.IsDevelopment())
{
    app.UseMiniProfiler();
}

// 서비스에서 사용
public class GameService : IGameService
{
    private readonly IUserRepository _userRepository;
    
    public GameService(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }
    
    public async Task<User> GetUserProfileAsync(long userId)
    {
        using (MiniProfiler.Current.Step("GetUserProfile"))
        {
            using (MiniProfiler.Current.Step("Database Query"))
            {
                var user = await _userRepository.GetUserByIdAsync(userId);
                
                using (MiniProfiler.Current.Step("Post Processing"))
                {
                    // 추가 처리 로직
                    return user;
                }
            }
        }
    }
}
```

### 인증 및 보안 라이브러리

#### 1. JWT 인증

```csharp
// 설치: dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer

// Program.cs에 JWT 인증 추가
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = builder.Configuration["Jwt:Issuer"],
        ValidAudience = builder.Configuration["Jwt:Audience"],
        IssuerSigningKey = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
    };
    
    // 토큰 검증 실패 시 로깅
    options.Events = new JwtBearerEvents
    {
        OnAuthenticationFailed = context =>
        {
            Log.Warning("JWT Authentication failed: {Exception}", context.Exception);
            return Task.CompletedTask;
        }
    };
});

// JWT 서비스 구현
public class JwtService : IJwtService
{
    private readonly IConfiguration _configuration;
    
    public JwtService(IConfiguration configuration)
    {
        _configuration = configuration;
    }
    
    public string GenerateToken(User user)
    {
        var securityKey = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
        var credentials = new SigningCredentials(
            securityKey, SecurityAlgorithms.HmacSha256);
            
        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
            new Claim("nickname", user.Nickname),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };
        
        var token = new JwtSecurityToken(
            issuer: _configuration["Jwt:Issuer"],
            audience: _configuration["Jwt:Audience"],
            claims: claims,
            expires: DateTime.UtcNow.AddHours(1),
            signingCredentials: credentials
        );
        
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
```

#### 2. Rate Limiting

```csharp
// 설치: dotnet add package AspNetCoreRateLimit

// Program.cs에 Rate Limit 설정
// 메모리 캐시 추가
builder.Services.AddMemoryCache();

// IP 기반 제한 설정
builder.Services.Configure<IpRateLimitOptions>(builder.Configuration.GetSection("IpRateLimiting"));
builder.Services.Configure<IpRateLimitPolicies>(builder.Configuration.GetSection("IpRateLimitPolicies"));
builder.Services.AddSingleton<IIpPolicyStore, MemoryCacheIpPolicyStore>();
builder.Services.AddSingleton<IRateLimitCounterStore, MemoryCacheRateLimitCounterStore>();
builder.Services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();

// 클라이언트 ID 기반 제한 설정
builder.Services.Configure<ClientRateLimitOptions>(builder.Configuration.GetSection("ClientRateLimiting"));
builder.Services.Configure<ClientRateLimitPolicies>(builder.Configuration.GetSection("ClientRateLimitPolicies"));
builder.Services.AddSingleton<IClientPolicyStore, MemoryCacheClientPolicyStore>();

// 미들웨어 등록
app.UseIpRateLimiting();
app.UseClientRateLimiting();

// appsettings.json 예시
/*
{
  "IpRateLimiting": {
    "EnableEndpointRateLimiting": true,
    "StackBlockedRequests": false,
    "RealIpHeader": "X-Real-IP",
    "ClientIdHeader": "X-ClientId",
    "HttpStatusCode": 429,
    "GeneralRules": [
      {
        "Endpoint": "*/api/*",
        "Period": "1m",
        "Limit": 60
      },
      {
        "Endpoint": "*/api/account/login",
        "Period": "5m",
        "Limit": 5
      }
    ]
  }
}
*/
```

#### 3. 액세스 제어를 위한 커스텀 미들웨어

```csharp
// 요청 검증 미들웨어
public class RequestValidationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestValidationMiddleware> _logger;
    
    public RequestValidationMiddleware(RequestDelegate next, ILogger<RequestValidationMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        // 요청 본문 읽기
        context.Request.EnableBuffering();
        
        using var reader = new StreamReader(
            context.Request.Body, 
            Encoding.UTF8, 
            leaveOpen: true);
            
        var body = await reader.ReadToEndAsync();
        
        // 본문 재설정
        context.Request.Body.Position = 0;
        
        // 유효한 JSON인지 확인
        if (!IsValidJson(body))
        {
            _logger.LogWarning("Invalid JSON request received: {IpAddress}", context.Connection.RemoteIpAddress);
            context.Response.StatusCode = StatusCodes.Status400BadRequest;
            await context.Response.WriteAsJsonAsync(new 
            {
                Result = "InvalidRequest",
                Message = "Invalid request format"
            });
            return;
        }
        
        await _next(context);
    }
    
    private bool IsValidJson(string json)
    {
        if (string.IsNullOrWhiteSpace(json)) return false;
        
        try
        {
            JsonDocument.Parse(json);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

// 확장 메서드
public static class RequestValidationMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestValidation(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<RequestValidationMiddleware>();
    }
}

// Program.cs에 등록
app.UseRequestValidation();
```

### 로깅 및 모니터링

#### 1. Serilog - 구조화된 로깅

```csharp
// 설치: 
// dotnet add package Serilog.AspNetCore
// dotnet add package Serilog.Sinks.Console
// dotnet add package Serilog.Sinks.File
// dotnet add package Serilog.Sinks.Seq

// Program.cs에서 설정
builder.Host.UseSerilog((context, services, configuration) => configuration
    .ReadFrom.Configuration(context.Configuration)
    .ReadFrom.Services(services)
    .Enrich.FromLogContext()
    .Enrich.WithProperty("ApplicationName", "GameServer")
    .WriteTo.Console(outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}")
    .WriteTo.File("logs/gameserver-.log", 
        rollingInterval: RollingInterval.Day, 
        outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{Level:u3}] {Message:lj}{NewLine}{Properties:j}{NewLine}{Exception}")
    .WriteTo.Seq("http://localhost:5341")
);

// appsettings.json에 Serilog 설정 추가
/*
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning",
        "Microsoft.AspNetCore.Authentication": "Information"
      }
    }
  }
}
*/

// 로깅 미들웨어 추가
app.UseSerilogRequestLogging(options =>
{
    options.EnrichDiagnosticContext = (diagnosticContext, httpContext) =>
    {
        diagnosticContext.Set("RemoteIpAddress", httpContext.Connection.RemoteIpAddress);
        if (httpContext.User.Identity?.IsAuthenticated == true)
        {
            diagnosticContext.Set("UserId", httpContext.User.FindFirst("sub")?.Value);
        }
    };
    
    // 로깅 포맷 커스터마이징
    options.MessageTemplate = "HTTP {RequestMethod} {RequestPath} responded {StatusCode} in {Elapsed:0.0000} ms";
});

// 서비스에서 로깅 사용
public class UserService : IUserService
{
    private readonly ILogger<UserService> _logger;
    private readonly IUserRepository _userRepository;
    
    public UserService(ILogger<UserService> logger, IUserRepository userRepository)
    {
        _logger = logger;
        _userRepository = userRepository;
    }
    
    public async Task<User> GetUserByIdAsync(long userId)
    {
        _logger.LogInformation("Retrieving user data for ID: {UserId}", userId);
        
        try
        {
            var user = await _userRepository.GetUserByIdAsync(userId);
            
            if (user == null)
            {
                _logger.LogWarning("User not found: {UserId}", userId);
                return null;
            }
            
            _logger.LogInformation("User retrieved successfully: {UserId}, Level: {Level}", 
                userId, user.Level);
                
            return user;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving user {UserId}", userId);
            throw;
        }
    }
}
```

#### 2. HealthChecks - 시스템 상태 모니터링

```csharp
// 설치:
// dotnet add package Microsoft.Extensions.Diagnostics.HealthChecks
// dotnet add package AspNetCore.HealthChecks.MySql
// dotnet add package AspNetCore.HealthChecks.Redis
// dotnet add package AspNetCore.HealthChecks.UI.Client

// Program.cs에 상태 체크 추가
builder.Services.AddHealthChecks()
    .AddMySql(
        builder.Configuration.GetConnectionString("GameDB"),
        name: "database",
        tags: new[] { "db", "mysql", "gamedata" })
    .AddRedis(
        builder.Configuration["Redis:ConnectionString"],
        name: "redis",
        tags: new[] { "cache", "redis" })
    .AddCheck<GameLogicHealthCheck>(
        "game-logic", 
        tags: new[] { "application", "logic" });

// 상태 체크 미들웨어 등록
app.MapHealthChecks("/health", new HealthCheckOptions
{
    Predicate = _ => true,
    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
});

// 태그 기반 부분 상태 체크 엔드포인트
app.MapHealthChecks("/health/db", new HealthCheckOptions
{
    Predicate = check => check.Tags.Contains("db"),
    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
});

// 커스텀 헬스 체크 구현
public class GameLogicHealthCheck : IHealthCheck
{
    private readonly IServiceProvider _serviceProvider;
    
    public GameLogicHealthCheck(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    
    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            // 필요한 서비스 확인
            using var scope = _serviceProvider.CreateScope();
            var userService = scope.ServiceProvider.GetRequiredService<IUserService>();
            var itemService = scope.ServiceProvider.GetRequiredService<IItemService>();
            var rankingService = scope.ServiceProvider.GetRequiredService<IRankingService>();
            
            // 각 서비스 동작 간단히 테스트
            var itemCount = await itemService.GetItemCountAsync();
            var rankingsAvailable = await rankingService.IsRankingAvailableAsync();
            
            var data = new Dictionary<string, object>
            {
                { "ItemCount", itemCount },
                { "RankingsAvailable", rankingsAvailable },
                { "LastChecked", DateTime.UtcNow }
            };
            
            if (itemCount > 0 && rankingsAvailable)
            {
                return HealthCheckResult.Healthy("All game services are operational", data);
            }
            
            return HealthCheckResult.Degraded("Some game services are not fully operational", data: data);
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Game logic health check failed", ex);
        }
    }
}
```

### 게임 서버 특화 라이브러리

#### 1. SignalR - 실시간 통신

```csharp
// 설치: dotnet add package Microsoft.AspNetCore.SignalR

// Program.cs에 SignalR 추가
builder.Services.AddSignalR()
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.PropertyNamingPolicy = null;
    })
    .AddHubOptions<GameHub>(options =>
    {
        options.EnableDetailedErrors = true;
        options.KeepAliveInterval = TimeSpan.FromSeconds(15);
        options.ClientTimeoutInterval = TimeSpan.FromSeconds(30);
        options.MaximumReceiveMessageSize = 1024 * 1024; // 1MB
    });

// 허브 구성
app.MapHub<GameHub>("/hubs/game");

// GameHub 구현
public class GameHub : Hub
{
    private readonly ILogger<GameHub> _logger;
    private readonly IUserService _userService;
    private readonly IChatService _chatService;
    
    public GameHub(
        ILogger<GameHub> logger,
        IUserService userService,
        IChatService chatService)
    {
        _logger = logger;
        _userService = userService;
        _chatService = chatService;
    }
    
    public override async Task OnConnectedAsync()
    {
        var userId = Context.User.FindFirst("sub")?.Value;
        if (!string.IsNullOrEmpty(userId))
        {
            await Groups.AddToGroupAsync(Context.ConnectionId, $"user:{userId}");
            _logger.LogInformation("User {UserId} connected to GameHub", userId);
            
            // 유저의 길드가 있다면 해당 길드 그룹에도 추가
            var user = await _userService.GetUserByIdAsync(long.Parse(userId));
            if (user?.GuildId > 0)
            {
                await Groups.AddToGroupAsync(Context.ConnectionId, $"guild:{user.GuildId}");
                _logger.LogInformation("User {UserId} joined guild group {GuildId}", 
                    userId, user.GuildId);
            }
        }
        
        await base.OnConnectedAsync();
    }
    
    public override async Task OnDisconnectedAsync(Exception exception)
    {
        var userId = Context.User.FindFirst("sub")?.Value;
        if (!string.IsNullOrEmpty(userId))
        {
            _logger.LogInformation("User {UserId} disconnected from GameHub: {Message}", 
                userId, exception?.Message ?? "Normal disconnect");
        }
        
        await base.OnDisconnectedAsync(exception);
    }
    
    // 길드 채팅 메시지 전송
    public async Task SendGuildMessage(long guildId, string message)
    {
        var userId = Context.User.FindFirst("sub")?.Value;
        if (string.IsNullOrEmpty(userId))
        {
            throw new HubException("User not authenticated");
        }
        
        var user = await _userService.GetUserByIdAsync(long.Parse(userId));
        if (user?.GuildId != guildId)
        {
            throw new HubException("User is not a member of this guild");
        }
        
        // 메시지 저장
        var chatMessage = await _chatService.SaveGuildMessageAsync(
            guildId, user.Id, user.Nickname, message);
        
        // 길드원들에게 메시지 브로드캐스트
        await Clients.Group($"guild:{guildId}").SendAsync(
            "ReceiveGuildMessage", 
            new
            {
                MessageId = chatMessage.Id,
                SenderId = user.Id,
                SenderName = user.Nickname,
                Message = message,
                Timestamp = chatMessage.CreatedAt
            });
    }
    
    // 개인 메시지 전송
    public async Task SendPrivateMessage(long targetUserId, string message)
    {
        var userId = Context.User.FindFirst("sub")?.Value;
        if (string.IsNullOrEmpty(userId))
        {
            throw new HubException("User not authenticated");
        }
        
        var senderId = long.Parse(userId);
        var sender = await _userService.GetUserByIdAsync(senderId);
        
        // 메시지 저장
        var privateMessage = await _chatService.SavePrivateMessageAsync(
            senderId, targetUserId, message);
        
        // 발신자에게 메시지 전송 확인
        await Clients.Caller.SendAsync(
            "PrivateMessageSent", 
            new { 
                MessageId = privateMessage.Id,
                TargetUserId = targetUserId,
                Message = message,
                Timestamp = privateMessage.CreatedAt
            });
        
        // 수신자에게 메시지 전송
        await Clients.Group($"user:{targetUserId}").SendAsync(
            "ReceivePrivateMessage", 
            new
            {
                MessageId = privateMessage.Id,
                SenderId = sender.Id,
                SenderName = sender.Nickname,
                Message = message,
                Timestamp = privateMessage.CreatedAt
            });
    }
    
    // 게임 내 이벤트 구독
    public async Task SubscribeToEvents(string[] eventTypes)
    {
        foreach (var eventType in eventTypes)
        {
            if (IsValidEventType(eventType))
            {
                await Groups.AddToGroupAsync(Context.ConnectionId, $"event:{eventType}");
                _logger.LogInformation("User {UserId} subscribed to event {EventType}", 
                    Context.User.FindFirst("sub")?.Value, eventType);
            }
        }
    }
    
    private bool IsValidEventType(string eventType)
    {
        // 허용된 이벤트 타입인지 확인
        var validEventTypes = new[] { 
            "system-announcement", 
            "guild-war", 
            "world-boss",
            "arena-matchmaking" 
        };
        
        return validEventTypes.Contains(eventType);
    }
}

// 알림 전송 서비스
public class NotificationService : INotificationService
{
    private readonly IHubContext<GameHub> _hubContext;
    private readonly ILogger<NotificationService> _logger;
    
    public NotificationService(
        IHubContext<GameHub> hubContext,
        ILogger<NotificationService> logger)
    {
        _hubContext = hubContext;
        _logger = logger;
    }
    
    // 시스템 공지 전송
    public async Task SendSystemAnnouncementAsync(string title, string message)
    {
        _logger.LogInformation("Sending system announcement: {Title}", title);
        
        await _hubContext.Clients.Group("event:system-announcement").SendAsync(
            "SystemAnnouncement", 
            new
            {
                Title = title,
                Message = message,
                Timestamp = DateTime.UtcNow
            });
    }
    
    // 길드에 알림 전송
    public async Task SendGuildNotificationAsync(long guildId, string title, string message)
    {
        _logger.LogInformation("Sending guild notification to Guild {GuildId}: {Title}", 
            guildId, title);
            
        await _hubContext.Clients.Group($"guild:{guildId}").SendAsync(
            "GuildNotification",
            new
            {
                Title = title,
                Message = message,
                Timestamp = DateTime.UtcNow
            });
    }
    
    // 개인 알림 전송
    public async Task SendUserNotificationAsync(long userId, string title, string message)
    {
        _logger.LogInformation("Sending personal notification to User {UserId}: {Title}", 
            userId, title);
            
        await _hubContext.Clients.Group($"user:{userId}").SendAsync(
            "UserNotification",
            new
            {
                Title = title,
                Message = message,
                Timestamp = DateTime.UtcNow
            });
    }
    
    // 이벤트 진행 상태 업데이트
    public async Task UpdateEventStatusAsync(string eventType, string status, object data)
    {
        _logger.LogInformation("Updating {EventType} status: {Status}", eventType, status);
        
        await _hubContext.Clients.Group($"event:{eventType}").SendAsync(
            "EventStatusUpdate",
            new
            {
                EventType = eventType,
                Status = status,
                Data = data,
                Timestamp = DateTime.UtcNow
            });
    }
}
```

#### 2. Background Service - 게임 이벤트 스케줄러

```csharp
// 게임 이벤트 스케줄러 구현
public class GameEventScheduler : BackgroundService
{
    private readonly ILogger<GameEventScheduler> _logger;
    private readonly IServiceProvider _serviceProvider;
    private readonly IConfiguration _configuration;
    
    public GameEventScheduler(
        ILogger<GameEventScheduler> logger,
        IServiceProvider serviceProvider,
        IConfiguration configuration)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
        _configuration = configuration;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Game Event Scheduler starting");
        
        // 각 이벤트 스케줄링
        var dailyReset = CreateDailyResetTimer(stoppingToken);
        var weeklyReset = CreateWeeklyResetTimer(stoppingToken);
        var worldBossSpawn = CreateWorldBossTimer(stoppingToken);
        var guildWarPreparation = CreateGuildWarTimer(stoppingToken);
        
        // 모든 스케줄러 대기
        await Task.WhenAll(dailyReset, weeklyReset, worldBossSpawn, guildWarPreparation);
        
        _logger.LogInformation("Game Event Scheduler stopping");
    }
    
    private async Task CreateDailyResetTimer(CancellationToken stoppingToken)
    {
        // 매일 자정(UTC)에 실행
        while (!stoppingToken.IsCancellationRequested)
        {
            var now = DateTime.UtcNow;
            var nextRun = now.Date.AddDays(1);
            var delay = nextRun - now;
            
            _logger.LogInformation("Daily reset scheduled for {NextRun} (in {Delay})",
                nextRun, delay);
                
            await Task.Delay(delay, stoppingToken);
            
            if (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    using var scope = _serviceProvider.CreateScope();
                    var resetService = scope.ServiceProvider.GetRequiredService<IDailyResetService>();
                    var notificationService = scope.ServiceProvider.GetRequiredService<INotificationService>();
                    
                    _logger.LogInformation("Executing daily reset tasks");
                    
                    await resetService.ExecuteDailyResetAsync();
                    await notificationService.SendSystemAnnouncementAsync(
                        "일일 초기화", 
                        "일일 임무와 상점이 초기화되었습니다.");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error executing daily reset");
                }
            }
        }
    }
    
    private async Task CreateWeeklyResetTimer(CancellationToken stoppingToken)
    {
        // 매주 월요일 자정(UTC)에 실행
        while (!stoppingToken.IsCancellationRequested)
        {
            var now = DateTime.UtcNow;
            var daysUntilMonday = ((int)DayOfWeek.Monday - (int)now.DayOfWeek + 7) % 7;
            var nextRun = now.Date.AddDays(daysUntilMonday == 0 ? 7 : daysUntilMonday);
            var delay = nextRun - now;
            
            _logger.LogInformation("Weekly reset scheduled for {NextRun} (in {Delay})",
                nextRun, delay);
                
            await Task.Delay(delay, stoppingToken);
            
            if (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    using var scope = _serviceProvider.CreateScope();
                    var resetService = scope.ServiceProvider.GetRequiredService<IWeeklyResetService>();
                    var notificationService = scope.ServiceProvider.GetRequiredService<INotificationService>();
                    
                    _logger.LogInformation("Executing weekly reset tasks");
                    
                    await resetService.ExecuteWeeklyResetAsync();
                    await notificationService.SendSystemAnnouncementAsync(
                        "주간 초기화", 
                        "주간 던전과 상점이 초기화되었습니다. 이번 주의 길드 보스도 등장했습니다!");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error executing weekly reset");
                }
            }
        }
    }
    
    private async Task CreateWorldBossTimer(CancellationToken stoppingToken)
    {
        // 매일 특정 시간(UTC)에 실행
        var worldBossTimes = _configuration.GetSection("GameEvents:WorldBossTimes")
            .Get<string[]>()
            ?.Select(TimeSpan.Parse)
            .ToArray() ?? new[] { TimeSpan.FromHours(12), TimeSpan.FromHours(20) };
            
        while (!stoppingToken.IsCancellationRequested)
        {
            var now = DateTime.UtcNow;
            var todayTimes = worldBossTimes
                .Select(t => now.Date.Add(t))
                .Where(t => t > now)
                .ToList();
                
            DateTime nextRun;
            if (todayTimes.Any())
            {
                nextRun = todayTimes.Min();
            }
            else
            {
                // 오늘 남은 시간이 없으면 내일 첫 번째 시간
                nextRun = now.Date.AddDays(1).Add(worldBossTimes.Min());
            }
            
            var delay = nextRun - now;
            
            _logger.LogInformation("World Boss spawn scheduled for {NextRun} (in {Delay})",
                nextRun, delay);
                
            await Task.Delay(delay, stoppingToken);
            
            if (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    using var scope = _serviceProvider.CreateScope();
                    var worldBossService = scope.ServiceProvider.GetRequiredService<IWorldBossService>();
                    var notificationService = scope.ServiceProvider.GetRequiredService<INotificationService>();
                    
                    _logger.LogInformation("Spawning World Boss");
                    
                    var bossInfo = await worldBossService.SpawnRandomWorldBossAsync();
                    await notificationService.SendSystemAnnouncementAsync(
                        "월드 보스 출현", 
                        $"{bossInfo.Name} 보스가 {bossInfo.Location}에 출현했습니다! 보스는 1시간 동안 활동합니다.");
                        
                    // 이벤트 채널 구독자에게 상세 정보 전송
                    await notificationService.UpdateEventStatusAsync(
                        "world-boss",
                        "spawned",
                        new 
                        {
                            BossId = bossInfo.Id,
                            Name = bossInfo.Name,
                            Level = bossInfo.Level,
                            Location = bossInfo.Location,
                            MaxHp = bossInfo.MaxHp,
                            ExpireAt = DateTime.UtcNow.AddHours(1)
                        });
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error spawning World Boss");
                }
            }
        }
    }
    
    private async Task CreateGuildWarTimer(CancellationToken stoppingToken)
    {
        // 매주 금요일, 토요일, 일요일에 길드전 진행
        while (!stoppingToken.IsCancellationRequested)
        {
            var now = DateTime.UtcNow;
            
            // 다음 길드전 준비 시간 계산 (금요일 18:00 UTC)
            var daysUntilFriday = ((int)DayOfWeek.Friday - (int)now.DayOfWeek + 7) % 7;
            var nextPrepTime = now.Date.AddDays(daysUntilFriday).Add(TimeSpan.FromHours(18));
            
            // 이미 금요일 18시 이후라면 다음 주로
            if (now.DayOfWeek == DayOfWeek.Friday && now.TimeOfDay >= TimeSpan.FromHours(18) ||
                now.DayOfWeek == DayOfWeek.Saturday || now.DayOfWeek == DayOfWeek.Sunday)
            {
                nextPrepTime = nextPrepTime.AddDays(7);
            }
            
            var delay = nextPrepTime - now;
            
            _logger.LogInformation("Guild War preparation scheduled for {NextRun} (in {Delay})",
                nextPrepTime, delay);
                
            await Task.Delay(delay, stoppingToken);
            
            if (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    using var scope = _serviceProvider.CreateScope();
                    var guildWarService = scope.ServiceProvider.GetRequiredService<IGuildWarService>();
                    var notificationService = scope.ServiceProvider.GetRequiredService<INotificationService>();
                    
                    _logger.LogInformation("Starting Guild War preparation phase");
                    
                    var warInfo = await guildWarService.StartPreparationPhaseAsync();
                    await notificationService.SendSystemAnnouncementAsync(
                        "길드전 준비 단계", 
                        "길드전 준비 단계가 시작되었습니다. 토요일 12:00(UTC)에 길드전이 시작됩니다!");
                        
                    // 길드전 매칭 결과 각 길드에 통보
                    foreach (var match in warInfo.Matches)
                    {
                        await notificationService.SendGuildNotificationAsync(
                            match.Guild1Id,
                            "길드전 매칭 완료",
                            $"상대 길드: {match.Guild2Name} (레벨: {match.Guild2Level})");
                            
                        await notificationService.SendGuildNotificationAsync(
                            match.Guild2Id,
                            "길드전 매칭 완료",
                            $"상대 길드: {match.Guild1Name} (레벨: {match.Guild1Level})");
                    }
                    
                    // 이벤트 구독자에게 알림
                    await notificationService.UpdateEventStatusAsync(
                        "guild-war",
                        "preparation",
                        new 
                        {
                            Season = warInfo.Season,
                            MatchCount = warInfo.Matches.Count,
                            BattleStartTime = nextPrepTime.AddDays(1).AddHours(-6), // 토요일 12:00 UTC
                            BattleEndTime = nextPrepTime.AddDays(2).AddHours(0)     // 일요일 18:00 UTC
                        });
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error starting Guild War preparation phase");
                }
            }
        }
    }
}

// Program.cs에 등록
builder.Services.AddHostedService<GameEventScheduler>();
```

#### 3. Minimal API로 관리자 도구 구현

```csharp
// Program.cs에서 관리자 API 엔드포인트 구성
var adminGroup = app.MapGroup("/admin")
    .RequireAuthorization(policy => policy.RequireRole("admin"))
    .AddEndpointFilter(async (context, next) =>
    {
        var logger = context.HttpContext.RequestServices.GetRequiredService<ILogger<Program>>();
        var user = context.HttpContext.User;
        
        logger.LogInformation(
            "Admin API called: {Path} by {AdminId}", 
            context.HttpContext.Request.Path,
            user.FindFirst("sub")?.Value);
            
        return await next(context);
    });

// 서버 상태 및 통계
adminGroup.MapPost("/stats", async (
    [FromServices] IServerStatsService statsService) =>
{
    var stats = await statsService.GetServerStatsAsync();
    return Results.Ok(new
    {
        Result = "Success",
        Stats = stats
    });
});

// 공지사항 발송
adminGroup.MapPost("/announce", async (
    [FromBody] AdminAnnouncementRequest request,
    [FromServices] INotificationService notificationService) =>
{
    await notificationService.SendSystemAnnouncementAsync(
        request.Title, 
        request.Message);
        
    return Results.Ok(new
    {
        Result = "Success",
        Message = "Announcement sent successfully"
    });
});

// 사용자 계정 제재
adminGroup.MapPost("/ban-user", async (
    [FromBody] AdminBanUserRequest request,
    [FromServices] IAdminService adminService,
    [FromServices] ILogger<Program> logger) =>
{
    logger.LogWarning("Banning user {UserId} for {Reason}, Duration: {DurationHours}h",
        request.UserId, request.Reason, request.DurationHours);
        
    await adminService.BanUserAsync(
        request.UserId, 
        request.Reason, 
        TimeSpan.FromHours(request.DurationHours));
        
    return Results.Ok(new
    {
        Result = "Success",
        Message = $"User {request.UserId} banned successfully"
    });
});

// 아이템 지급
adminGroup.MapPost("/give-item", async (
    [FromBody] AdminGiveItemRequest request,
    [FromServices] IAdminService adminService,
    [FromServices] ILogger<Program> logger) =>
{
    logger.LogInformation("Giving {Quantity}x item {ItemId} to user {UserId}, Reason: {Reason}",
        request.Quantity, request.ItemId, request.UserId, request.Reason);
        
    await adminService.GiveItemToUserAsync(
        request.UserId,
        request.ItemId,
        request.Quantity,
        request.Reason);
        
    return Results.Ok(new
    {
        Result = "Success",
        Message = $"Item {request.ItemId} ({request.Quantity}) given to user {request.UserId}"
    });
});

// 이벤트 시작
adminGroup.MapPost("/start-event", async (
    [FromBody] AdminStartEventRequest request,
    [FromServices] IEventService eventService,
    [FromServices] ILogger<Program> logger) =>
{
    logger.LogInformation("Starting event: {EventType}, Duration: {DurationHours}h",
        request.EventType, request.DurationHours);
        
    var eventInfo = await eventService.StartEventAsync(
        request.EventType,
        request.EventParams,
        TimeSpan.FromHours(request.DurationHours));
        
    return Results.Ok(new
    {
        Result = "Success",
        EventId = eventInfo.Id,
        StartTime = eventInfo.StartTime,
        EndTime = eventInfo.EndTime
    });
});

// 서버 유지보수 예약
adminGroup.MapPost("/schedule-maintenance", async (
    [FromBody] AdminMaintenanceRequest request,
    [FromServices] IMaintenanceService maintenanceService,
    [FromServices] INotificationService notificationService,
    [FromServices] ILogger<Program> logger) =>
{
    logger.LogWarning("Scheduling maintenance at {StartTime}, Duration: {DurationMinutes}m",
        request.StartTime, request.DurationMinutes);
        
    var maintenanceInfo = await maintenanceService.ScheduleMaintenanceAsync(
        request.StartTime,
        TimeSpan.FromMinutes(request.DurationMinutes),
        request.Reason);
        
    // 유저들에게 공지
    await notificationService.SendSystemAnnouncementAsync(
        "서버 점검 안내",
        $"서버 점검이 {request.StartTime:yyyy-MM-dd HH:mm}에 예정되어 있습니다. " +
        $"예상 소요 시간은 {request.DurationMinutes}분입니다. " +
        $"점검 사유: {request.Reason}");
        
    return Results.Ok(new
    {
        Result = "Success",
        MaintenanceId = maintenanceInfo.Id,
        ScheduledStartTime = maintenanceInfo.StartTime,
        EstimatedEndTime = maintenanceInfo.EndTime
    });
});
```
  

## 4. 일반적인 게임 서버 문제 해결 가이드

### 성능 최적화

#### 데이터베이스 쿼리 최적화

```csharp
// 비효율적인 쿼리
public async Task<List<User>> GetActiveUsersInefficient()
{
    // 문제점: 불필요한 전체 데이터 로드 후 필터링
    var allUsers = await _db.Query("users").GetAsync<User>();
    return allUsers.Where(u => u.LastLoginAt > DateTime.UtcNow.AddDays(-7)).ToList();
}

// 최적화된 쿼리
public async Task<List<User>> GetActiveUsersOptimized()
{
    // 개선: 데이터베이스 수준에서 필터링
    var sevenDaysAgo = DateTime.UtcNow.AddDays(-7);
    return await _db.Query("users")
                   .Where("last_login_at", ">", sevenDaysAgo)
                   .GetAsync<User>();
}

// 페이지네이션 적용
public async Task<(List<User> Users, int TotalCount)> GetUsersPaginated(int page, int pageSize)
{
    var totalCount = await _db.Query("users").CountAsync<int>();
    
    var users = await _db.Query("users")
                        .OrderByDesc("level")
                        .Skip((page - 1) * pageSize)
                        .Take(pageSize)
                        .GetAsync<User>();
                        
    return (users, totalCount);
}
```

#### 캐싱 전략

```csharp
// 다중 레이어 캐싱 패턴
public class ItemService : IItemService
{
    private readonly IItemRepository _itemRepository;
    private readonly IGameCacheService _cacheService;
    private readonly IMemoryCache _memoryCache;
    private readonly ILogger<ItemService> _logger;
    
    private const string MemCacheKeyPrefix = "item:";
    private readonly TimeSpan _memCacheDuration = TimeSpan.FromMinutes(10);
    
    public ItemService(
        IItemRepository itemRepository,
        IGameCacheService cacheService,
        IMemoryCache memoryCache,
        ILogger<ItemService> logger)
    {
        _itemRepository = itemRepository;
        _cacheService = cacheService;
        _memoryCache = memoryCache;
        _logger = logger;
    }
    
    public async Task<Item> GetItemByIdAsync(int itemId)
    {
        var memCacheKey = $"{MemCacheKeyPrefix}{itemId}";
        
        // 1단계: 로컬 메모리 캐시 확인 (가장 빠름)
        if (_memoryCache.TryGetValue(memCacheKey, out Item memCachedItem))
        {
            _logger.LogDebug("Item {ItemId} retrieved from memory cache", itemId);
            return memCachedItem;
        }
        
        // 2단계: Redis 캐시 확인
        var redisCachedItem = await _cacheService.GetItemAsync(itemId);
        if (redisCachedItem != null)
        {
            _logger.LogDebug("Item {ItemId} retrieved from Redis cache", itemId);
            
            // 메모리 캐시에도 저장
            _memoryCache.Set(memCacheKey, redisCachedItem, _memCacheDuration);
            
            return redisCachedItem;
        }
        
        // 3단계: 데이터베이스에서 로드
        var item = await _itemRepository.GetItemByIdAsync(itemId);
        if (item != null)
        {
            _logger.LogDebug("Item {ItemId} retrieved from database", itemId);
            
            // 두 캐시 모두에 저장
            await _cacheService.SetItemAsync(item);
            _memoryCache.Set(memCacheKey, item, _memCacheDuration);
        }
        
        return item;
    }
    
    public async Task<bool> InvalidateItemCacheAsync(int itemId)
    {
        var memCacheKey = $"{MemCacheKeyPrefix}{itemId}";
        
        // 두 캐시 모두 무효화
        _memoryCache.Remove(memCacheKey);
        return await _cacheService.RemoveItemAsync(itemId);
    }
}
```

#### 비동기 처리를 위한 백그라운드 작업

```csharp
// 백그라운드 작업 처리 서비스
public class BackgroundTaskService : IBackgroundTaskService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<BackgroundTaskService> _logger;
    private readonly BackgroundTaskQueue _taskQueue;
    
    public BackgroundTaskService(
        IServiceProvider serviceProvider,
        ILogger<BackgroundTaskService> logger,
        BackgroundTaskQueue taskQueue)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
        _taskQueue = taskQueue;
    }
    
    // 메일 발송을 비동기로 예약
    public void QueueSendMail(long userId, string title, string content, List<MailAttachment> attachments)
    {
        _logger.LogInformation("Queuing mail send to user {UserId}", userId);
        
        _taskQueue.QueueTask(async (serviceProvider, cancellationToken) =>
        {
            try
            {
                using var scope = serviceProvider.CreateScope();
                var mailService = scope.ServiceProvider.GetRequiredService<IMailService>();
                
                await mailService.SendMailAsync(userId, title, content, attachments);
                
                _logger.LogInformation("Mail successfully sent to user {UserId}", userId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error sending mail to user {UserId}", userId);
            }
        });
    }
    
    // 가챠 보상 지급을 비동기로 처리
    public void QueueProcessGachaReward(long userId, int gachaId, List<GachaResult> results)
    {
        _logger.LogInformation("Queuing gacha reward processing for user {UserId}", userId);
        
        _taskQueue.QueueTask(async (serviceProvider, cancellationToken) =>
        {
            try
            {
                using var scope = serviceProvider.CreateScope();
                var inventoryService = scope.ServiceProvider.GetRequiredService<IInventoryService>();
                var userService = scope.ServiceProvider.GetRequiredService<IUserService>();
                var logService = scope.ServiceProvider.GetRequiredService<IGameLogService>();
                
                // 아이템 지급
                foreach (var result in results)
                {
                    await inventoryService.AddItemToUserAsync(
                        userId, result.ItemId, result.Quantity);
                }
                
                // 로그 기록
                await logService.LogGachaResultAsync(userId, gachaId, results);
                
                _logger.LogInformation("Gacha rewards processed for user {UserId}", userId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing gacha rewards for user {UserId}", userId);
            }
        });
    }
    
    // 유저 통계 업데이트를 비동기로 처리
    public void QueueUpdateUserStats(long userId)
    {
        _taskQueue.QueueTask(async (serviceProvider, cancellationToken) =>
        {
            try
            {
                using var scope = serviceProvider.CreateScope();
                var statsService = scope.ServiceProvider.GetRequiredService<IUserStatsService>();
                
                await statsService.RecalculateUserStatsAsync(userId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating stats for user {UserId}", userId);
            }
        });
    }
}

// 백그라운드 작업 큐 구현
public class BackgroundTaskQueue : IBackgroundTaskQueue
{
    private readonly Channel<Func<IServiceProvider, CancellationToken, Task>> _queue;
    
    public BackgroundTaskQueue(int capacity = 100)
    {
        var options = new BoundedChannelOptions(capacity)
        {
            FullMode = BoundedChannelFullMode.Wait
        };
        
        _queue = Channel.CreateBounded<Func<IServiceProvider, CancellationToken, Task>>(options);
    }
    
    public async ValueTask QueueTask(Func<IServiceProvider, CancellationToken, Task> task)
    {
        await _queue.Writer.WriteAsync(task);
    }
    
    public async ValueTask<Func<IServiceProvider, CancellationToken, Task>> DequeueAsync(CancellationToken cancellationToken)
    {
        return await _queue.Reader.ReadAsync(cancellationToken);
    }
}

// 백그라운드 작업 처리 워커
public class QueuedHostedService : BackgroundService
{
    private readonly ILogger<QueuedHostedService> _logger;
    private readonly IServiceProvider _serviceProvider;
    private readonly BackgroundTaskQueue _taskQueue;
    
    public QueuedHostedService(
        ILogger<QueuedHostedService> logger,
        IServiceProvider serviceProvider,
        BackgroundTaskQueue taskQueue)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
        _taskQueue = taskQueue;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Background Task Service is starting");
        
        await BackgroundProcessing(stoppingToken);
    }
    
    private async Task BackgroundProcessing(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            var task = await _taskQueue.DequeueAsync(stoppingToken);
            
            try
            {
                await task(_serviceProvider, stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred executing background task");
            }
        }
    }
    
    public override async Task StopAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Background Task Service is stopping");
        
        await base.StopAsync(stoppingToken);
    }
}
```

### 동시성 및 데이터 일관성

#### 분산 락 구현

```csharp
// Redis 기반 분산 락 서비스
public class RedisLockService : IDistributedLockService
{
    private readonly RedisConfig _redisConfig;
    private readonly ILogger<RedisLockService> _logger;
    
    // 락 획득 재시도 설정
    private const int MaxRetries = 3;
    private const int RetryDelayMs = 200;
    
    public RedisLockService(RedisConfig redisConfig, ILogger<RedisLockService> logger)
    {
        _redisConfig = redisConfig;
        _logger = logger;
    }
    
    public async Task<IAsyncDisposable> AcquireLockAsync(string resource, TimeSpan expiry, CancellationToken cancellationToken = default)
    {
        var lockId = Guid.NewGuid().ToString("N");
        var lockKey = $"lock:{resource}";
        
        _logger.LogDebug("Trying to acquire lock {LockKey} with ID {LockId}", lockKey, lockId);
        
        var retryCount = 0;
        bool acquired = false;
        
        while (!acquired && retryCount < MaxRetries && !cancellationToken.IsCancellationRequested)
        {
            var redis = new RedisString<string>(_redisConfig, lockKey);
            
            // NX 옵션으로 락 획득 시도 (키가 없을 경우에만 설정)
            acquired = await redis.SetAsync(lockId, expiry, When.NotExists);
            
            if (!acquired)
            {
                retryCount++;
                _logger.LogDebug("Lock {LockKey} acquisition failed, retry {RetryCount}/{MaxRetries}", 
                    lockKey, retryCount, MaxRetries);
                    
                if (retryCount < MaxRetries)
                {
                    // 지수 백오프로 재시도 간격 증가
                    var delay = RetryDelayMs * Math.Pow(2, retryCount - 1);
                    await Task.Delay((int)delay, cancellationToken);
                }
            }
        }
        
        if (!acquired)
        {
            _logger.LogWarning("Failed to acquire lock {LockKey} after {MaxRetries} retries", 
                lockKey, MaxRetries);
                
            throw new LockAcquisitionException(
                $"Failed to acquire distributed lock for resource '{resource}'");
        }
        
        _logger.LogDebug("Successfully acquired lock {LockKey} with ID {LockId}", lockKey, lockId);
        
        // 락 해제를 위한 disposable 객체 반환
        return new RedisLockHandle(_redisConfig, lockKey, lockId, _logger);
    }
    
    // 락 해제용 disposable 클래스
    private class RedisLockHandle : IAsyncDisposable
    {
        private readonly RedisConfig _redisConfig;
        private readonly string _lockKey;
        private readonly string _lockId;
        private readonly ILogger _logger;
        private bool _disposed;
        
        public RedisLockHandle(RedisConfig redisConfig, string lockKey, string lockId, ILogger logger)
        {
            _redisConfig = redisConfig;
            _lockKey = lockKey;
            _lockId = lockId;
            _logger = logger;
            _disposed = false;
        }
        
        public async ValueTask DisposeAsync()
        {
            if (_disposed) return;
            
            _logger.LogDebug("Releasing lock {LockKey} with ID {LockId}", _lockKey, _lockId);
            
            try
            {
                // Lua 스크립트로 안전하게 락 해제 (내가 설정한 락만 해제)
                var script = @"
                    if redis.call('GET', KEYS[1]) == ARGV[1] then
                        return redis.call('DEL', KEYS[1])
                    else
                        return 0
                    end";
                
                var redis = new RedisConnection(_redisConfig);
                var result = await redis.ScriptEvaluateAsync<long>(
                    script, 
                    new[] { _lockKey }, 
                    new[] { _lockId }
                );
                
                if (result == 1)
                {
                    _logger.LogDebug("Successfully released lock {LockKey} with ID {LockId}", 
                        _lockKey, _lockId);
                }
                else
                {
                    _logger.LogWarning("Lock {LockKey} with ID {LockId} was not released (already expired or owned by another process)", 
                        _lockKey, _lockId);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error releasing lock {LockKey} with ID {LockId}", 
                    _lockKey, _lockId);
            }
            
            _disposed = true;
        }
    }
}

// 아이템 구매 시 분산 락 활용 예제
public class ShopService : IShopService
{
    private readonly IUserRepository _userRepository;
    private readonly IInventoryRepository _inventoryRepository;
    private readonly IDistributedLockService _lockService;
    private readonly ILogger<ShopService> _logger;
    
    public ShopService(
        IUserRepository userRepository,
        IInventoryRepository inventoryRepository,
        IDistributedLockService lockService,
        ILogger<ShopService> logger)
    {
        _userRepository = userRepository;
        _inventoryRepository = inventoryRepository;
        _lockService = lockService;
        _logger = logger;
    }
    
    public async Task<PurchaseResult> PurchaseItemAsync(long userId, int itemId, int quantity)
    {
        // 동시에 같은 유저의 구매 트랜잭션을 막기 위한 분산 락
        var lockResource = $"user:{userId}:purchase";
        
        try
        {
            // 락 획득 (최대 10초)
            await using var lockHandle = await _lockService.AcquireLockAsync(
                lockResource, TimeSpan.FromSeconds(10));
                
            // 아이템 정보 조회
            var item = await _itemRepository.GetItemByIdAsync(itemId);
            if (item == null)
            {
                return new PurchaseResult
                {
                    Success = false,
                    ErrorCode = "ITEM_NOT_FOUND"
                };
            }
            
            // 구매 비용 계산
            var totalCost = item.Price * quantity;
            
            // 유저 골드 차감 시도
            var deductResult = await _userRepository.DeductGoldAsync(userId, totalCost);
            if (!deductResult.Success)
            {
                return new PurchaseResult
                {
                    Success = false,
                    ErrorCode = "INSUFFICIENT_GOLD"
                };
            }
            
            // 인벤토리에 아이템 추가
            await _inventoryRepository.AddItemToUserAsync(userId, itemId, quantity);
            
            // 구매 로그 기록
            await _gameLogRepository.LogItemPurchaseAsync(userId, itemId, quantity, totalCost);
            
            return new PurchaseResult
            {
                Success = true,
                PurchasedItemId = itemId,
                Quantity = quantity,
                GoldSpent = totalCost,
                RemainingGold = deductResult.RemainingGold
            };
        }
        catch (LockAcquisitionException ex)
        {
            _logger.LogWarning(ex, "Failed to acquire lock for user {UserId} purchase", userId);
            
            return new PurchaseResult
            {
                Success = false,
                ErrorCode = "CONCURRENT_OPERATION",
                ErrorMessage = "Another purchase is already in progress. Please try again."
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during item purchase for user {UserId}", userId);
            
            return new PurchaseResult
            {
                Success = false,
                ErrorCode = "INTERNAL_ERROR",
                ErrorMessage = "An unexpected error occurred. Please try again."
            };
        }
    }
}
```

#### 멱등성 보장 패턴

```csharp
// 요청 멱등성 보장을 위한 핸들러
public class IdempotencyHandler
{
    private readonly IGameCacheService _cacheService;
    private readonly ILogger<IdempotencyHandler> _logger;
    
    // 멱등성 키 만료 시간
    private readonly TimeSpan _idempotencyKeyExpiry = TimeSpan.FromHours(24);
    
    public IdempotencyHandler(
        IGameCacheService cacheService, 
        ILogger<IdempotencyHandler> logger)
    {
        _cacheService = cacheService;
        _logger = logger;
    }
    
    public async Task<(bool IsFirstExecution, T CachedResult)> ProcessRequestAsync<T>(
        string idempotencyKey, 
        Func<Task<T>> action)
        where T : class
    {
        if (string.IsNullOrEmpty(idempotencyKey))
        {
            throw new ArgumentException("Idempotency key cannot be null or empty", nameof(idempotencyKey));
        }
        
        // 캐시에서 이전 실행 결과 확인
        var cacheKey = $"idempotency:{idempotencyKey}";
        var cachedResult = await _cacheService.GetValueAsync<T>(cacheKey);
        
        if (cachedResult != null)
        {
            _logger.LogInformation("Found cached result for idempotency key: {IdempotencyKey}", 
                idempotencyKey);
                
            return (false, cachedResult);
        }
        
        // 첫 실행인 경우 액션 수행
        _logger.LogInformation("Executing action for idempotency key: {IdempotencyKey}", 
            idempotencyKey);
            
        var result = await action();
        
        // 결과 캐싱
        await _cacheService.SetValueAsync(cacheKey, result, _idempotencyKeyExpiry);
        
        return (true, result);
    }
}

// 컨트롤러에서 멱등성 핸들러 사용 예제
[ApiController]
[Route("api/game")]
public class GachaController : ControllerBase
{
    private readonly IGachaService _gachaService;
    private readonly IdempotencyHandler _idempotencyHandler;
    private readonly ILogger<GachaController> _logger;
    
    public GachaController(
        IGachaService gachaService,
        IdempotencyHandler idempotencyHandler,
        ILogger<GachaController> logger)
    {
        _gachaService = gachaService;
        _idempotencyHandler = idempotencyHandler;
        _logger = logger;
    }
    
    [HttpPost("gacha/draw")]
    public async Task<GachaDrawResponse> DrawGacha([FromBody] GachaDrawRequest request)
    {
        if (string.IsNullOrEmpty(request.IdempotencyKey))
        {
            return new GachaDrawResponse
            {
                Result = GameResultCode.InvalidRequest,
                ErrorMessage = "Idempotency key is required"
            };
        }
        
        try
        {
            var (isFirstExecution, result) = await _idempotencyHandler.ProcessRequestAsync<GachaDrawResponse>(
                request.IdempotencyKey,
                async () => await PerformGachaDraw(request));
                
            if (!isFirstExecution)
            {
                _logger.LogInformation("Returning cached gacha result for idempotency key: {IdempotencyKey}",
                    request.IdempotencyKey);
            }
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing gacha draw request");
            
            return new GachaDrawResponse
            {
                Result = GameResultCode.ServerError,
                ErrorMessage = "An unexpected error occurred"
            };
        }
    }
    
    private async Task<GachaDrawResponse> PerformGachaDraw(GachaDrawRequest request)
    {
        // 실제 가챠 로직 수행
        return await _gachaService.DrawGachaAsync(
            request.CharacterId,
            request.GachaId);
    }
}
```

### 보안 및 악용 방지

#### 입력 검증 및 필터링

```csharp
// 입력 검증 속성
public class SafeStringAttribute : ValidationAttribute
{
    protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    {
        if (value == null)
            return ValidationResult.Success;
            
        var str = value.ToString();
        
        // 위험한 문자 패턴 검사
        var dangerousPatterns = new[]
        {
            @"<script.*?>.*?</script>",  // 스크립트 태그
            @"javascript:",              // 자바스크립트 프로토콜
            @"on\w+=",                   // 온로드 이벤트 등
            @"(\%27)|(\')|(\-\-)|(\%23)|(#)", // SQL 인젝션 시도
            @"((\%3D)|(=))[^\n]*((\%27)|(\')|(\-\-)|(\%3B)|(\;))" // SQL 인젝션 시도
        };
        
        foreach (var pattern in dangerousPatterns)
        {
            if (Regex.IsMatch(str, pattern, RegexOptions.IgnoreCase))
            {
                return new ValidationResult(
                    "The input contains potentially dangerous content.");
            }
        }
        
        return ValidationResult.Success;
    }
}
  
// 요청 모델 검증
public class ChatMessageRequest
{
    [Required]
    public long CharacterId { get; set; }
    
    [Required]
    public long ChannelId { get; set; }
    
    [Required]
    [StringLength(200, MinimumLength = 1)]
    [SafeString]  // 위에 정의한 커스텀 검증 속성
    public string Message { get; set; }
}

// 닉네임 필터링 서비스
public class ContentFilterService : IContentFilterService
{
    private readonly IOptions<FilterOptions> _options;
    private readonly ILogger<ContentFilterService> _logger;
    private readonly Regex _badWordsRegex;
    
    public ContentFilterService(
        IOptions<FilterOptions> options,
        ILogger<ContentFilterService> logger)
    {
        _options = options;
        _logger = logger;
        
        // 금지어 패턴 준비
        var badWords = _options.Value.BadWords;
        if (badWords?.Any() == true)
        {
            var pattern = string.Join("|", badWords.Select(word => Regex.Escape(word)));
            _badWordsRegex = new Regex(pattern, RegexOptions.IgnoreCase);
        }
        else
        {
            _badWordsRegex = new Regex("^$"); // 매칭되지 않는 패턴
        }
    }
    
    public bool ContainsBadWords(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return false;
            
        return _badWordsRegex.IsMatch(text);
    }
    
    public string FilterBadWords(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return text;
            
        return _badWordsRegex.Replace(text, match => new string('*', match.Length));
    }
    
    public ValidationResult ValidateNickname(string nickname)
    {
        if (string.IsNullOrWhiteSpace(nickname))
        {
            return new ValidationResult
            {
                IsValid = false,
                ReasonCode = "EMPTY_NICKNAME",
                Message = "Nickname cannot be empty"
            };
        }
        
        if (nickname.Length < 2 || nickname.Length > 16)
        {
            return new ValidationResult
            {
                IsValid = false,
                ReasonCode = "INVALID_LENGTH",
                Message = "Nickname must be between 2 and 16 characters"
            };
        }
        
        // 알파벳, 숫자, 특정 특수문자만 허용
        var allowedPattern = new Regex(@"^[a-zA-Z0-9_\-\.]+$");
        if (!allowedPattern.IsMatch(nickname))
        {
            return new ValidationResult
            {
                IsValid = false,
                ReasonCode = "INVALID_CHARACTERS",
                Message = "Nickname can only contain letters, numbers, and the characters _-."
            };
        }
        
        if (ContainsBadWords(nickname))
        {
            return new ValidationResult
            {
                IsValid = false,
                ReasonCode = "PROHIBITED_WORDS",
                Message = "Nickname contains prohibited words"
            };
        }
        
        return new ValidationResult { IsValid = true };
    }
}
```

#### 레이트 리미팅 및 IP 필터링

```csharp
// IP 기반 보안 미들웨어
public class IpSecurityMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<IpSecurityMiddleware> _logger;
    private readonly IOptions<IpSecurityOptions> _options;
    private readonly IMemoryCache _cache;
    
    // IP별 요청 횟수 추적용 캐시 키 접두사
    private const string CacheKeyPrefix = "IpSecurity:";
    
    public IpSecurityMiddleware(
        RequestDelegate next,
        ILogger<IpSecurityMiddleware> logger,
        IOptions<IpSecurityOptions> options,
        IMemoryCache cache)
    {
        _next = next;
        _logger = logger;
        _options = options;
        _cache = cache;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        var remoteIp = context.Connection.RemoteIpAddress?.ToString();
        
        if (string.IsNullOrEmpty(remoteIp))
        {
            context.Response.StatusCode = StatusCodes.Status403Forbidden;
            await context.Response.WriteAsJsonAsync(new 
            {
                Error = "IP address could not be determined"
            });
            return;
        }
        
        // 차단된 IP 확인
        if (_options.Value.BlockedIps?.Contains(remoteIp) == true)
        {
            _logger.LogWarning("Blocked request from blocked IP: {IpAddress}", remoteIp);
            
            context.Response.StatusCode = StatusCodes.Status403Forbidden;
            await context.Response.WriteAsJsonAsync(new
            {
                Error = "Access denied"
            });
            return;
        }
        
        // 요청 비율 제한 확인
        if (_options.Value.RequestsPerMinuteLimit > 0)
        {
            var cacheKey = $"{CacheKeyPrefix}{remoteIp}";
            
            // 현재 요청 수 가져오기
            var requestCount = _cache.GetOrCreate(cacheKey, entry =>
            {
                entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(1);
                return 0;
            });
            
            // 요청 수 증가
            _cache.Set(cacheKey, requestCount + 1, TimeSpan.FromMinutes(1));
            
            if (requestCount >= _options.Value.RequestsPerMinuteLimit)
            {
                _logger.LogWarning("Rate limit exceeded for IP: {IpAddress}", remoteIp);
                
                context.Response.StatusCode = StatusCodes.Status429TooManyRequests;
                context.Response.Headers.Append("Retry-After", "60");
                await context.Response.WriteAsJsonAsync(new
                {
                    Error = "Rate limit exceeded. Please try again later."
                });
                return;
            }
        }
        
        await _next(context);
    }
}

// 확장 메서드
public static class IpSecurityMiddlewareExtensions
{
    public static IApplicationBuilder UseIpSecurity(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<IpSecurityMiddleware>();
    }
}

// 설정 옵션 클래스
public class IpSecurityOptions
{
    public List<string> BlockedIps { get; set; } = new List<string>();
    public int RequestsPerMinuteLimit { get; set; } = 300;
}

// Program.cs에 등록
builder.Services.Configure<IpSecurityOptions>(builder.Configuration.GetSection("IpSecurity"));
app.UseIpSecurity();

// appsettings.json 예시
/*
{
  "IpSecurity": {
    "BlockedIps": [
      "10.0.0.1",
      "192.168.1.100"
    ],
    "RequestsPerMinuteLimit": 300
  }
}
*/
```

#### 토큰 및 API 보안

```csharp
// 액세스 토큰 요청 모델
public class TokenRequest
{
    [Required]
    public string GrantType { get; set; }
    
    [Required]
    public string DeviceId { get; set; }
    
    // 인증 방식에 따라 필요한 필드
    public string Email { get; set; }
    public string Password { get; set; }
    public string RefreshToken { get; set; }
}

// 토큰 응답 모델
public class TokenResponse
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
    public int ExpiresIn { get; set; }
    public string TokenType { get; set; } = "Bearer";
}

// 토큰 서비스 구현
public class TokenService : ITokenService
{
    private readonly IConfiguration _configuration;
    private readonly IRedisLockService _redisLockService;
    private readonly IGameCacheService _cacheService;
    private readonly IUserService _userService;
    private readonly ILogger<TokenService> _logger;
    
    // 토큰 설정
    private readonly TimeSpan _accessTokenExpiry = TimeSpan.FromHours(1);
    private readonly TimeSpan _refreshTokenExpiry = TimeSpan.FromDays(30);
    
    public TokenService(
        IConfiguration configuration,
        IRedisLockService redisLockService,
        IGameCacheService cacheService,
        IUserService userService,
        ILogger<TokenService> logger)
    {
        _configuration = configuration;
        _redisLockService = redisLockService;
        _cacheService = cacheService;
        _userService = userService;
        _logger = logger;
    }
    
    public async Task<TokenResponse> GenerateTokensAsync(long userId, string deviceId)
    {
        // JWT 액세스 토큰 생성
        var accessToken = GenerateAccessToken(userId);
        
        // 리프레시 토큰 생성 (GUID 사용)
        var refreshToken = Guid.NewGuid().ToString("N");
        
        // 리프레시 토큰 저장
        var refreshTokenKey = $"refresh_token:{refreshToken}";
        await _cacheService.SetValueAsync(refreshTokenKey, new RefreshTokenInfo
        {
            UserId = userId,
            DeviceId = deviceId,
            CreatedAt = DateTime.UtcNow
        }, _refreshTokenExpiry);
        
        // 유저별 디바이스 토큰 매핑 (여러 기기에서 로그인 관리용)
        var userDeviceTokenKey = $"user:{userId}:device:{deviceId}";
        await _cacheService.SetValueAsync(userDeviceTokenKey, refreshToken, _refreshTokenExpiry);
        
        // 응답 생성
        return new TokenResponse
        {
            AccessToken = accessToken,
            RefreshToken = refreshToken,
            ExpiresIn = (int)_accessTokenExpiry.TotalSeconds
        };
    }
    
    public async Task<TokenResponse> RefreshTokenAsync(string refreshToken, string deviceId)
    {
        // 리프레시 토큰 확인
        var refreshTokenKey = $"refresh_token:{refreshToken}";
        var tokenInfo = await _cacheService.GetValueAsync<RefreshTokenInfo>(refreshTokenKey);
        
        if (tokenInfo == null)
        {
            _logger.LogWarning("Invalid refresh token attempted: {RefreshToken}", refreshToken);
            throw new InvalidTokenException("Invalid refresh token");
        }
        
        // 디바이스 ID 확인
        if (tokenInfo.DeviceId != deviceId)
        {
            _logger.LogWarning("Device ID mismatch for refresh token: {RefreshToken}", refreshToken);
            throw new InvalidTokenException("Device ID mismatch");
        }
        
        // 기존 토큰 무효화
        await _cacheService.RemoveValueAsync(refreshTokenKey);
        
        // 새 토큰 발급
        return await GenerateTokensAsync(tokenInfo.UserId, deviceId);
    }
    
    public async Task RevokeTokenAsync(long userId, string deviceId = null)
    {
        // 특정 디바이스 토큰만 무효화
        if (!string.IsNullOrEmpty(deviceId))
        {
            var userDeviceTokenKey = $"user:{userId}:device:{deviceId}";
            var refreshToken = await _cacheService.GetValueAsync<string>(userDeviceTokenKey);
            
            if (!string.IsNullOrEmpty(refreshToken))
            {
                await _cacheService.RemoveValueAsync($"refresh_token:{refreshToken}");
                await _cacheService.RemoveValueAsync(userDeviceTokenKey);
            }
            
            return;
        }
        
        // 모든 디바이스 토큰 무효화 (계정 이상 감지 시)
        var lockKey = $"user:{userId}:token_revocation";
        
        try
        {
            await using var lockHandle = await _redisLockService.AcquireLockAsync(
                lockKey, TimeSpan.FromSeconds(30));
                
            // 유저의 모든 디바이스 키 패턴
            var userDevicePattern = $"user:{userId}:device:*";
            var deviceKeys = await _cacheService.GetKeysByPatternAsync(userDevicePattern);
            
            foreach (var deviceKey in deviceKeys)
            {
                var refreshToken = await _cacheService.GetValueAsync<string>(deviceKey);
                if (!string.IsNullOrEmpty(refreshToken))
                {
                    await _cacheService.RemoveValueAsync($"refresh_token:{refreshToken}");
                }
                
                await _cacheService.RemoveValueAsync(deviceKey);
            }
            
            _logger.LogInformation("Revoked all tokens for user {UserId}", userId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error revoking tokens for user {UserId}", userId);
            throw;
        }
    }
    
    private string GenerateAccessToken(long userId)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_configuration["Jwt:Key"]);
        
        var claims = new List<Claim>
        {
            new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
            new Claim(JwtRegisteredClaimNames.Iat, DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString())
        };
        
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(claims),
            Expires = DateTime.UtcNow.Add(_accessTokenExpiry),
            Issuer = _configuration["Jwt:Issuer"],
            Audience = _configuration["Jwt:Audience"],
            SigningCredentials = new SigningCredentials(
                new SymmetricSecurityKey(key), 
                SecurityAlgorithms.HmacSha256Signature)
        };
        
        var token = tokenHandler.CreateToken(tokenDescriptor);
        return tokenHandler.WriteToken(token);
    }
    
    private class RefreshTokenInfo
    {
        public long UserId { get; set; }
        public string DeviceId { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
```

### 확장성 및 스케일링

#### 로드 밸런싱 구성

```csharp
// 프로그램을 서버 배포용으로 구성
// Program.cs 수정

// 프로덕션 환경에서 필요한 추가 설정
if (builder.Environment.IsProduction())
{
    builder.WebHost.ConfigureKestrel(options =>
    {
        // HTTPS 설정
        options.ListenAnyIP(443, listenOptions =>
        {
            listenOptions.UseHttps(builder.Configuration["Certificates:HTTPS"]);
        });
        
        // HTTP/2 활성화
        options.ConfigureEndpointDefaults(defaults =>
        {
            defaults.Protocols = HttpProtocols.Http1AndHttp2;
        });
        
        // 연결 제한 설정
        options.Limits.MaxConcurrentConnections = 100;
        options.Limits.MaxRequestBodySize = 10 * 1024 * 1024; // 10MB
        options.Limits.KeepAliveTimeout = TimeSpan.FromMinutes(2);
        options.Limits.RequestHeadersTimeout = TimeSpan.FromSeconds(30);
    });
    
    // 역방향 프록시 설정
    builder.Services.Configure<ForwardedHeadersOptions>(options =>
    {
        options.ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;
        
        // 알려진 프록시/로드 밸런서 IP 추가
        options.KnownProxies.Add(IPAddress.Parse(builder.Configuration["LoadBalancer:IP"]));
    });
    
    // 응용 프로그램 상태 관리를 위한 상태 점검
    builder.Services.AddHealthChecks();
}

// 미들웨어 순서 중요
if (builder.Environment.IsProduction())
{
    app.UseForwardedHeaders();
}

// 세션 선호도를 위한 쿠키 설정
app.UseCookiePolicy(new CookiePolicyOptions
{
    MinimumSameSitePolicy = SameSiteMode.Lax,
    Secure = CookieSecurePolicy.Always
});

// appsettings.Production.json 예시
/*
{
  "Certificates": {
    "HTTPS": "/etc/ssl/certs/game-server.pfx"
  },
  "LoadBalancer": {
    "IP": "10.0.0.100"
  },
  "ConnectionStrings": {
    "GameDB": "server=game-db-cluster;port=3306;database=game_db;user=game_user;password=StrongPassword123!;DefaultCommandTimeout=30;SslMode=Required;"
  },
  "Redis": {
    "ConnectionString": "game-redis-cluster:6379,password=StrongRedisPassword123!,ssl=true,abortConnect=false"
  }
}
*/
```

#### 서비스 분리 및 모듈화

```csharp
// 기능별 모듈화 구조 예시
// 모듈 등록 기본 클래스
public abstract class GameServerModule
{
    public abstract void RegisterServices(IServiceCollection services, IConfiguration configuration);
    public abstract void ConfigureMiddleware(IApplicationBuilder app);
    public virtual void ConfigureEndpoints(IEndpointRouteBuilder endpoints) { }
}

// 계정 관리 모듈
public class AccountModule : GameServerModule
{
    public override void RegisterServices(IServiceCollection services, IConfiguration configuration)
    {
        // 계정 관련 서비스 등록
        services.AddScoped<IAccountService, AccountService>();
        services.AddScoped<IAuthenticationService, AuthenticationService>();
        services.AddScoped<ITokenService, TokenService>();
        
        // 계정 관련 저장소 등록
        services.AddScoped<IAccountRepository, AccountRepository>();
    }
    
    public override void ConfigureMiddleware(IApplicationBuilder app)
    {
        // 필요한 경우 계정 관련 미들웨어 등록
    }
    
    public override void ConfigureEndpoints(IEndpointRouteBuilder endpoints)
    {
        // 계정 API 엔드포인트 등록
        endpoints.MapControllerRoute(
            name: "account_api",
            pattern: "api/account/{action}",
            defaults: new { controller = "Account" });
    }
}

// 게임 콘텐츠 모듈
public class GameContentModule : GameServerModule
{
    public override void RegisterServices(IServiceCollection services, IConfiguration configuration)
    {
        // 게임 관련 서비스 등록
        services.AddScoped<ICharacterService, CharacterService>();
        services.AddScoped<IInventoryService, InventoryService>();
        services.AddScoped<IShopService, ShopService>();
        services.AddScoped<IGachaService, GachaService>();
        services.AddScoped<IQuestService, QuestService>();
        services.AddScoped<IDungeonService, DungeonService>();
        
        // 게임 관련 저장소 등록
        services.AddScoped<ICharacterRepository, CharacterRepository>();
        services.AddScoped<IInventoryRepository, InventoryRepository>();
        services.AddScoped<IShopRepository, ShopRepository>();
        services.AddScoped<IGachaRepository, GachaRepository>();
        services.AddScoped<IQuestRepository, QuestRepository>();
        services.AddScoped<IDungeonRepository, DungeonRepository>();
        
        // 게임 관련 백그라운드 서비스 등록
        services.AddHostedService<DungeonRewardProcessor>();
        services.AddHostedService<GachaRatesUpdateService>();
    }
    
    public override void ConfigureMiddleware(IApplicationBuilder app)
    {
        // 게임 콘텐츠 관련 미들웨어 등록
    }
    
    public override void ConfigureEndpoints(IEndpointRouteBuilder endpoints)
    {
        // 게임 API 엔드포인트 등록
        endpoints.MapControllerRoute(
            name: "game_api",
            pattern: "api/game/{controller=Character}/{action=Info}");
    }
}

// 소셜 기능 모듈
public class SocialModule : GameServerModule
{
    public override void RegisterServices(IServiceCollection services, IConfiguration configuration)
    {
        // 소셜 관련 서비스 등록
        services.AddScoped<IFriendService, FriendService>();
        services.AddScoped<IGuildService, GuildService>();
        services.AddScoped<IChatService, ChatService>();
        services.AddScoped<IMailService, MailService>();
        
        // 소셜 관련 저장소 등록
        services.AddScoped<IFriendRepository, FriendRepository>();
        services.AddScoped<IGuildRepository, GuildRepository>();
        services.AddScoped<IChatRepository, ChatRepository>();
        services.AddScoped<IMailRepository, MailRepository>();
        
        // SignalR 추가 (실시간 채팅 등)
        services.AddSignalR();
    }
    
    public override void ConfigureMiddleware(IApplicationBuilder app)
    {
        // 소셜 관련 미들웨어 등록
    }
    
    public override void ConfigureEndpoints(IEndpointRouteBuilder endpoints)
    {
        // 소셜 API 엔드포인트 등록
        endpoints.MapControllerRoute(
            name: "social_api",
            pattern: "api/social/{controller=Friend}/{action=List}");
            
        // SignalR 허브 엔드포인트 등록
        endpoints.MapHub<ChatHub>("/hubs/chat");
        endpoints.MapHub<GuildHub>("/hubs/guild");
    }
}

// 모듈 등록 확장 메서드
public static class ModuleExtensions
{
    public static IServiceCollection RegisterModules(
        this IServiceCollection services, 
        IConfiguration configuration,
        params GameServerModule[] modules)
    {
        foreach (var module in modules)
        {
            module.RegisterServices(services, configuration);
        }
        
        return services;
    }
    
    public static IApplicationBuilder UseGameModules(
        this IApplicationBuilder app,
        params GameServerModule[] modules)
    {
        foreach (var module in modules)
        {
            module.ConfigureMiddleware(app);
        }
        
        return app;
    }
    
    public static IEndpointRouteBuilder MapGameModuleEndpoints(
        this IEndpointRouteBuilder endpoints,
        params GameServerModule[] modules)
    {
        foreach (var module in modules)
        {
            module.ConfigureEndpoints(endpoints);
        }
        
        return endpoints;
    }
}

// Program.cs에서 모듈 등록
// 모듈 인스턴스 생성
var accountModule = new AccountModule();
var gameContentModule = new GameContentModule();
var socialModule = new SocialModule();

// 서비스 등록
builder.Services.RegisterModules(
    builder.Configuration,
    accountModule,
    gameContentModule,
    socialModule);

// 미들웨어 구성
app.UseGameModules(
    accountModule,
    gameContentModule,
    socialModule);

// 엔드포인트 구성
app.MapGameModuleEndpoints(
    accountModule,
    gameContentModule,
    socialModule);
```

#### 비동기 메시징 패턴

```csharp
// 이벤트 기반 메시징 시스템
// 이벤트 인터페이스
public interface IGameEvent
{
    Guid Id { get; }
    DateTime Timestamp { get; }
    string EventType { get; }
}

// 기본 이벤트 클래스
public abstract class GameEvent : IGameEvent
{
    public Guid Id { get; } = Guid.NewGuid();
    public DateTime Timestamp { get; } = DateTime.UtcNow;
    public abstract string EventType { get; }
}

// 이벤트 예시: 유저 로그인
public class UserLoggedInEvent : GameEvent
{
    public override string EventType => "UserLoggedIn";
    public long UserId { get; set; }
    public string DeviceId { get; set; }
    public string IpAddress { get; set; }
}

// 이벤트 예시: 아이템 획득
public class ItemAcquiredEvent : GameEvent
{
    public override string EventType => "ItemAcquired";
    public long UserId { get; set; }
    public int ItemId { get; set; }
    public int Quantity { get; set; }
    public string Source { get; set; }  // 획득 경로 (상점, 던전, 퀘스트 등)
}

// 이벤트 핸들러 인터페이스
public interface IGameEventHandler<in TEvent> where TEvent : IGameEvent
{
    Task HandleAsync(TEvent @event);
}

// 인메모리 이벤트 버스
public class InMemoryEventBus : IGameEventBus
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<InMemoryEventBus> _logger;
    
    public InMemoryEventBus(
        IServiceProvider serviceProvider,
        ILogger<InMemoryEventBus> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
    }
    
    public async Task PublishAsync<TEvent>(TEvent @event) where TEvent : IGameEvent
    {
        _logger.LogDebug("Publishing event {EventType} with ID {EventId}",
            @event.EventType, @event.Id);
            
        try
        {
            using var scope = _serviceProvider.CreateScope();
            var handlerType = typeof(IGameEventHandler<>).MakeGenericType(@event.GetType());
            
            // 등록된 모든 핸들러 검색
            var handlers = scope.ServiceProvider.GetServices(handlerType);
            
            var tasks = new List<Task>();
            foreach (var handler in handlers)
            {
                var method = handlerType.GetMethod("HandleAsync");
                var task = (Task)method.Invoke(handler, new object[] { @event });
                tasks.Add(task);
            }
            
            // 모든 핸들러 비동기 실행
            await Task.WhenAll(tasks);
            
            _logger.LogDebug("Event {EventType} with ID {EventId} handled by {HandlerCount} handlers",
                @event.EventType, @event.Id, tasks.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error publishing event {EventType} with ID {EventId}",
                @event.EventType, @event.Id);
                
            throw;
        }
    }
}

// 이벤트 핸들러 예시: 유저 로그인 기록
public class UserLoginHistoryHandler : IGameEventHandler<UserLoggedInEvent>
{
    private readonly IUserHistoryRepository _historyRepository;
    private readonly ILogger<UserLoginHistoryHandler> _logger;
    
    public UserLoginHistoryHandler(
        IUserHistoryRepository historyRepository,
        ILogger<UserLoginHistoryHandler> logger)
    {
        _historyRepository = historyRepository;
        _logger = logger;
    }
    
    public async Task HandleAsync(UserLoggedInEvent @event)
    {
        try
        {
            _logger.LogDebug("Recording login history for user {UserId}", @event.UserId);
            
            await _historyRepository.AddLoginHistoryAsync(new LoginHistory
            {
                UserId = @event.UserId,
                DeviceId = @event.DeviceId,
                IpAddress = @event.IpAddress,
                LoginTime = @event.Timestamp
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error recording login history for user {UserId}", @event.UserId);
        }
    }
}

// 이벤트 핸들러 예시: 일일 미션 업데이트
public class DailyMissionHandler : IGameEventHandler<ItemAcquiredEvent>
{
    private readonly IMissionService _missionService;
    private readonly ILogger<DailyMissionHandler> _logger;
    
    public DailyMissionHandler(
        IMissionService missionService,
        ILogger<DailyMissionHandler> logger)
    {
        _missionService = missionService;
        _logger = logger;
    }
    
    public async Task HandleAsync(ItemAcquiredEvent @event)
    {
        try
        {
            _logger.LogDebug("Updating daily missions for user {UserId} - Item {ItemId} acquired",
                @event.UserId, @event.ItemId);
                
            // 아이템 수집 미션 업데이트
            await _missionService.UpdateCollectionMissionAsync(
                @event.UserId, @event.ItemId, @event.Quantity);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating daily missions for user {UserId}", @event.UserId);
        }
    }
}

// 서비스 등록
builder.Services.AddSingleton<IGameEventBus, InMemoryEventBus>();

// 이벤트 핸들러 등록
builder.Services.AddScoped<IGameEventHandler<UserLoggedInEvent>, UserLoginHistoryHandler>();
builder.Services.AddScoped<IGameEventHandler<UserLoggedInEvent>, UserRewardHandler>();
builder.Services.AddScoped<IGameEventHandler<ItemAcquiredEvent>, DailyMissionHandler>();
builder.Services.AddScoped<IGameEventHandler<ItemAcquiredEvent>, InventoryUpdateHandler>();

// 서비스에서 이벤트 발행 예시
public class AuthenticationService : IAuthenticationService
{
    private readonly IAccountRepository _accountRepository;
    private readonly ITokenService _tokenService;
    private readonly IGameEventBus _eventBus;
    private readonly ILogger<AuthenticationService> _logger;
    
    public AuthenticationService(
        IAccountRepository accountRepository,
        ITokenService tokenService,
        IGameEventBus eventBus,
        ILogger<AuthenticationService> logger)
    {
        _accountRepository = accountRepository;
        _tokenService = tokenService;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public async Task<LoginResult> LoginAsync(string email, string password, string deviceId, string ipAddress)
    {
        try
        {
            var account = await _accountRepository.GetByEmailAsync(email);
            
            if (account == null || !VerifyPassword(password, account.PasswordHash))
            {
                return new LoginResult
                {
                    Success = false,
                    ErrorCode = "INVALID_CREDENTIALS"
                };
            }
            
            // 토큰 생성
            var tokenResponse = await _tokenService.GenerateTokensAsync(account.Id, deviceId);
            
            // 로그인 이벤트 발행
            await _eventBus.PublishAsync(new UserLoggedInEvent
            {
                UserId = account.Id,
                DeviceId = deviceId,
                IpAddress = ipAddress
            });
            
            return new LoginResult
            {
                Success = true,
                UserId = account.Id,
                AccessToken = tokenResponse.AccessToken,
                RefreshToken = tokenResponse.RefreshToken,
                ExpiresIn = tokenResponse.ExpiresIn
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during login for email {Email}", email);
            
            return new LoginResult
            {
                Success = false,
                ErrorCode = "SERVER_ERROR"
            };
        }
    }
    
    private bool VerifyPassword(string password, string passwordHash)
    {
        return BCrypt.Net.BCrypt.Verify(password, passwordHash);
    }
}
```

   
  
