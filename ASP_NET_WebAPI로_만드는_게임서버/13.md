# ASP.NET Core Web APIë¡œ ê²Œì„ ì„œë²„ ê°œë°œ
  
ì €ì: ìµœí¥ë°°, Claude AI   
-----------------------    
   
# 4ë¶€: ê³ ê¸‰ ê¸°ëŠ¥ ë° ìµœì í™”
  
# Chapter 13. ë¹„ë™ê¸° ì‘ì—… ì²˜ë¦¬
    
## ê²Œì„ ì„œë²„ì—ì„œì˜ ë¹„ë™ê¸° ì‘ì—… í•„ìš”ì„±
ìˆ˜ì§‘í˜• RPG ê²Œì„ì—ì„œëŠ” ì¦‰ì‹œ ì²˜ë¦¬í•  í•„ìš”ê°€ ì—†ëŠ” ë§ì€ ì‘ì—…ì´ ì¡´ì¬í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´:

- ì¼ì¼ ë¦¬ì…‹ ì²˜ë¦¬
- ì£¼ê°„ ë­í‚¹ ê³„ì‚°
- ì´ë²¤íŠ¸ ë³´ìƒ ì§€ê¸‰
- ê¸¸ë“œ ì „íˆ¬ ê²°ê³¼ ì •ì‚°
- ëŒ€ëŸ‰ í‘¸ì‹œ ì•Œë¦¼ ì „ì†¡

ì´ëŸ¬í•œ ì‘ì—…ì„ API ìš”ì²­ ì²˜ë¦¬ íë¦„ì—ì„œ ë™ê¸°ì ìœ¼ë¡œ ìˆ˜í–‰í•˜ë©´ ì‚¬ìš©ì ê²½í—˜ì´ ì €í•˜ë˜ê³  ì„œë²„ ë¦¬ì†ŒìŠ¤ê°€ ë¹„íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©ëœë‹¤. ë¹„ë™ê¸° ì‘ì—… ì²˜ë¦¬ëŠ” ì´ëŸ° ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ í•„ìˆ˜ì ì¸ ê¸°ìˆ ì´ë‹¤.

```
ğŸ” ê²Œì„ ì„œë²„ì—ì„œ ë¹„ë™ê¸° ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš°
- ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—… (ë°ì´í„° ì§‘ê³„, ë¦¬í¬íŠ¸ ìƒì„±)
- ì •í•´ì§„ ì‹œê°„ì— ì‹¤í–‰í•´ì•¼ í•˜ëŠ” ì‘ì—… (ì¼ì¼ ë¦¬ì…‹, ì´ë²¤íŠ¸ ì‹œì‘/ì¢…ë£Œ)
- ì‹¤íŒ¨í•´ë„ ì¬ì‹œë„ê°€ í•„ìš”í•œ ì‘ì—… (í‘¸ì‹œ ì•Œë¦¼, ì´ë©”ì¼ ë°œì†¡)
- ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‘ì—… (ì „ì²´ ìœ ì € ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜)
```
  

## ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… êµ¬í˜„

### IHostedServiceì™€ BackgroundService
ASP.NET Coreì—ì„œëŠ” `IHostedService` ì¸í„°í˜ì´ìŠ¤ì™€ `BackgroundService` ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.  
  
![ASP.NET Coreì˜ ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ ì‹¤í–‰ íë¦„](./images/005.png)  
  
ì•„ë˜ëŠ” ê°„ë‹¨í•œ ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ êµ¬í˜„ ì˜ˆì‹œë‹¤:  
  
```csharp
public class DailyResetService : BackgroundService
{
    private readonly ILogger<DailyResetService> _logger;
    private readonly IServiceProvider _serviceProvider;
    
    public DailyResetService(
        ILogger<DailyResetService> logger,
        IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                // ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ê¹Œì§€ ëŒ€ê¸°
                var now = DateTime.UtcNow;
                var resetTime = new DateTime(now.Year, now.Month, now.Day, 0, 0, 0, DateTimeKind.Utc)
                    .AddDays(now.Hour >= 0 ? 1 : 0);
                var delay = resetTime - now;
                
                _logger.LogInformation("ë‹¤ìŒ ì¼ì¼ ë¦¬ì…‹ê¹Œì§€ {Delay} ëŒ€ê¸°", delay);
                await Task.Delay(delay, stoppingToken);
                
                // ìŠ¤ì½”í”„ ìƒì„±í•˜ì—¬ ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸°
                using var scope = _serviceProvider.CreateScope();
                var resetService = scope.ServiceProvider.GetRequiredService<IGameResetService>();
                
                // ì¼ì¼ ë¦¬ì…‹ ì‘ì—… ìˆ˜í–‰
                await resetService.PerformDailyResetAsync(stoppingToken);
                _logger.LogInformation("ì¼ì¼ ë¦¬ì…‹ ì‘ì—… ì™„ë£Œ: {Time}", DateTime.UtcNow);
            }
            catch (OperationCanceledException)
            {
                // ì •ìƒì ì¸ ì·¨ì†Œ ì²˜ë¦¬
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "ì¼ì¼ ë¦¬ì…‹ ì‘ì—… ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
                // ì˜¤ë¥˜ ë°œìƒ ì‹œ 1ë¶„ í›„ ì¬ì‹œë„
                await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
            }
        }
    }
    
    public override Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("ì¼ì¼ ë¦¬ì…‹ ì„œë¹„ìŠ¤ ì¢…ë£Œ ì¤‘...");
        return base.StopAsync(cancellationToken);
    }
}
```

ì„œë¹„ìŠ¤ ë“±ë¡ì€ `Program.cs`ì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ í•œë‹¤:

```csharp
var builder = WebApplication.CreateBuilder(args);

// ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤ ë“±ë¡
builder.Services.AddHostedService<DailyResetService>();

// í•„ìš”í•œ ì„œë¹„ìŠ¤ ë“±ë¡
builder.Services.AddScoped<IGameResetService, GameResetService>();

// ë‚˜ë¨¸ì§€ ì„œë¹„ìŠ¤ êµ¬ì„±...
```

### ì‘ì—… í êµ¬í˜„
ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ì‘ì—…ë“¤ì„ ìœ„í•œ ê°„ë‹¨í•œ ì‘ì—… íë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤:

```csharp
public interface IBackgroundTaskQueue
{
    ValueTask QueueTaskAsync(Func<CancellationToken, ValueTask> workItem);
    ValueTask<Func<CancellationToken, ValueTask>> DequeueAsync(CancellationToken cancellationToken);
}

public class BackgroundTaskQueue : IBackgroundTaskQueue
{
    private readonly Channel<Func<CancellationToken, ValueTask>> _queue;
    
    public BackgroundTaskQueue(int capacity)
    {
        // ì œí•œëœ ìš©ëŸ‰ì˜ ì±„ë„ ìƒì„±
        var options = new BoundedChannelOptions(capacity)
        {
            FullMode = BoundedChannelFullMode.Wait
        };
        _queue = Channel.CreateBounded<Func<CancellationToken, ValueTask>>(options);
    }
    
    public async ValueTask QueueTaskAsync(Func<CancellationToken, ValueTask> workItem)
    {
        if (workItem is null)
        {
            throw new ArgumentNullException(nameof(workItem));
        }
        
        await _queue.Writer.WriteAsync(workItem);
    }
    
    public async ValueTask<Func<CancellationToken, ValueTask>> DequeueAsync(
        CancellationToken cancellationToken)
    {
        return await _queue.Reader.ReadAsync(cancellationToken);
    }
}
```

ì‘ì—… í ì„œë¹„ìŠ¤:

```csharp
public class QueuedHostedService : BackgroundService
{
    private readonly ILogger<QueuedHostedService> _logger;
    private readonly IBackgroundTaskQueue _taskQueue;
    
    public QueuedHostedService(
        ILogger<QueuedHostedService> logger,
        IBackgroundTaskQueue taskQueue)
    {
        _logger = logger;
        _taskQueue = taskQueue;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("í ì²˜ë¦¬ ì„œë¹„ìŠ¤ ì‹œì‘");
        
        await BackgroundProcessing(stoppingToken);
    }
    
    private async Task BackgroundProcessing(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                var workItem = await _taskQueue.DequeueAsync(stoppingToken);
                
                await workItem(stoppingToken);
            }
            catch (OperationCanceledException)
            {
                // ì •ìƒì ì¸ ì·¨ì†Œ ì²˜ë¦¬
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "ì‘ì—… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
            }
        }
    }
    
    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("í ì²˜ë¦¬ ì„œë¹„ìŠ¤ ì¢…ë£Œ ì¤‘...");
        
        await base.StopAsync(cancellationToken);
    }
}
```

ë“±ë¡ ë° ì‚¬ìš©:

```csharp
// Program.cs
builder.Services.AddSingleton<IBackgroundTaskQueue>(sp => 
    new BackgroundTaskQueue(100));
builder.Services.AddHostedService<QueuedHostedService>();

// ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì‚¬ìš©
[ApiController]
[Route("api/[controller]")]
public class RewardController : ControllerBase
{
    private readonly IBackgroundTaskQueue _taskQueue;
    private readonly ILogger<RewardController> _logger;
    
    public RewardController(
        IBackgroundTaskQueue taskQueue,
        ILogger<RewardController> logger)
    {
        _taskQueue = taskQueue;
        _logger = logger;
    }
    
    [HttpPost("SendRewards")]
    public async Task<SendRewardsResponse> SendRewards([FromBody] SendRewardsRequest request)
    {
        // ì‘ì—…ì„ íì— ì¶”ê°€
        await _taskQueue.QueueTaskAsync(async token =>
        {
            // CPU ì§‘ì•½ì ì¸ ì‘ì—…ì´ë‚˜ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—…
            await ProcessBulkRewards(request.UserIds, request.RewardId, token);
        });
        
        return new SendRewardsResponse
        {
            Result = true,
            Message = "ë³´ìƒ ì§€ê¸‰ ì‘ì—…ì´ íì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤."
        };
    }
    
    private async Task ProcessBulkRewards(List<long> userIds, int rewardId, CancellationToken token)
    {
        _logger.LogInformation("ëŒ€ëŸ‰ ë³´ìƒ ì²˜ë¦¬ ì‹œì‘: {Count}ëª…ì˜ ì‚¬ìš©ì, ë³´ìƒ ID {RewardId}", 
            userIds.Count, rewardId);
            
        // ì‹¤ì œ ë³´ìƒ ì²˜ë¦¬ ë¡œì§...
        await Task.Delay(5000, token); // ì˜ˆì‹œ ì§€ì—°
        
        _logger.LogInformation("ëŒ€ëŸ‰ ë³´ìƒ ì²˜ë¦¬ ì™„ë£Œ");
    }
}

public class SendRewardsRequest
{
    public List<long> UserIds { get; set; } = new();
    public int RewardId { get; set; }
}

public class SendRewardsResponse
{
    public bool Result { get; set; }
    public string Message { get; set; } = string.Empty;
}
```
  

## Hangfireë¥¼ í™œìš©í•œ ìŠ¤ì¼€ì¤„ë§
HangfireëŠ” ASP.NET Core ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì„ ì‰½ê²Œ ìŠ¤ì¼€ì¤„ë§í•˜ê³  ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‹¤.

### Hangfire ì„¤ì¹˜ ë° ì„¤ì •

```csharp
// NuGet íŒ¨í‚¤ì§€ ì„¤ì¹˜
// dotnet add package Hangfire.Core
// dotnet add package Hangfire.AspNetCore
// dotnet add package Hangfire.MySqlStorage

// Program.csì— Hangfire ì„œë¹„ìŠ¤ ë“±ë¡
builder.Services.AddHangfire(configuration => configuration
    .SetDataCompatibilityLevel(CompatibilityLevel.Version_180)
    .UseSimpleAssemblyNameTypeSerializer()
    .UseRecommendedSerializerSettings()
    .UseStorage(new MySqlStorage(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        new MySqlStorageOptions
        {
            TablesPrefix = "Hangfire_"
        }))
);

// Hangfire ì„œë²„ ë“±ë¡
builder.Services.AddHangfireServer(options =>
{
    options.WorkerCount = 10; // ì‘ì—…ì ìŠ¤ë ˆë“œ ìˆ˜
    options.Queues = new[] { "default", "critical", "notifications" }; // í ìš°ì„ ìˆœìœ„
});

var app = builder.Build();

// ë¯¸ë“¤ì›¨ì–´ ë“±ë¡
app.UseHangfireDashboard("/hangfire", new DashboardOptions
{
    Authorization = new[] { new HangfireAuthorizationFilter() }
});

// ì¸ì¦ í•„í„° êµ¬í˜„
public class HangfireAuthorizationFilter : IDashboardAuthorizationFilter
{
    public bool Authorize(DashboardContext context)
    {
        // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ëª¨ë“  ì ‘ê·¼ í—ˆìš©
        var httpContext = context.GetHttpContext();
        return httpContext.Request.Host.Host.Equals("localhost", StringComparison.OrdinalIgnoreCase);
    }
}
```

### ì‘ì—… ì˜ˆì•½ ë° ê´€ë¦¬
ë‹¤ì–‘í•œ ìœ í˜•ì˜ ì‘ì—… ìŠ¤ì¼€ì¤„ë§ ë°©ë²•:

```csharp
// ì¦‰ì‹œ ì‹¤í–‰
BackgroundJob.Enqueue<IMailService>(x => x.SendMail("user@example.com", "ì œëª©", "ë‚´ìš©"));

// ì§€ì—° ì‹¤í–‰ (30ì´ˆ í›„)
BackgroundJob.Schedule<INotificationService>(
    x => x.SendPushNotification(1001, "ê²Œì„ ì—ë„ˆì§€ê°€ ë‹¤ ì°¼ìŠµë‹ˆë‹¤!"), 
    TimeSpan.FromSeconds(30));

// ë°˜ë³µ ì‘ì—… (Cron í‘œí˜„ì‹)
RecurringJob.AddOrUpdate<IRankingService>(
    "weekly-ranking-calculation",
    x => x.CalculateWeeklyRanking(),
    Cron.Weekly(DayOfWeek.Monday, 0)); // ë§¤ì£¼ ì›”ìš”ì¼ ìì •
    
// ì—°ì† ì‘ì—… (ì´ì „ ì‘ì—… ì™„ë£Œ í›„ ì‹¤í–‰)
var jobId = BackgroundJob.Enqueue<IBattleService>(x => x.CalculateBattleResults(100));
BackgroundJob.ContinueJobWith<IRewardService>(
    jobId, 
    x => x.DistributeRewards(100));
```

ì‹¤ì œ ê²Œì„ ì„œë²„ì—ì„œ í™œìš© ì˜ˆì‹œ:

```csharp
public class GameScheduleService : IGameScheduleService
{
    private readonly ILogger<GameScheduleService> _logger;
    
    public GameScheduleService(ILogger<GameScheduleService> logger)
    {
        _logger = logger;
    }
    
    public void SetupRecurringJobs()
    {
        // ì¼ì¼ ë¦¬ì…‹ (ë§¤ì¼ ìì •)
        RecurringJob.AddOrUpdate<IGameResetService>(
            "daily-reset",
            x => x.PerformDailyReset(),
            Cron.Daily);
            
        // ì£¼ê°„ ë­í‚¹ ê³„ì‚° (ë§¤ì£¼ ì¼ìš”ì¼ 23:50)
        RecurringJob.AddOrUpdate<IRankingService>(
            "weekly-ranking",
            x => x.ProcessWeeklyRanking(),
            Cron.Weekly(DayOfWeek.Sunday, 23, 50));
            
        // ê¸¸ë“œ ì „íˆ¬ ì‹œì‘ (ë§¤ì£¼ ê¸ˆìš”ì¼ 20:00)
        RecurringJob.AddOrUpdate<IGuildBattleService>(
            "guild-battle-start",
            x => x.StartGuildBattle(),
            Cron.Weekly(DayOfWeek.Friday, 20));
            
        // ê¸¸ë“œ ì „íˆ¬ ì¢…ë£Œ (ë§¤ì£¼ ì¼ìš”ì¼ 20:00)
        RecurringJob.AddOrUpdate<IGuildBattleService>(
            "guild-battle-end",
            x => x.EndGuildBattle(),
            Cron.Weekly(DayOfWeek.Sunday, 20));
            
        // ë°ì´í„° ë°±ì—… (ë§¤ì¼ 04:00)
        RecurringJob.AddOrUpdate<IDataBackupService>(
            "daily-backup",
            x => x.PerformDailyBackup(),
            "0 4 * * *");
            
        _logger.LogInformation("ëª¨ë“  ì •ê¸° ì‘ì—… ë“±ë¡ ì™„ë£Œ");
    }
    
    public void ScheduleEventStart(int eventId, DateTime startTime)
    {
        var jobId = $"event-start-{eventId}";
        var delay = startTime - DateTime.UtcNow;
        
        if (delay < TimeSpan.Zero)
        {
            _logger.LogWarning("ì´ë²¤íŠ¸ {EventId}ì˜ ì‹œì‘ ì‹œê°„ì´ ì´ë¯¸ ì§€ë‚¬ìŠµë‹ˆë‹¤", eventId);
            return;
        }
        
        BackgroundJob.Schedule<IEventService>(
            x => x.StartEvent(eventId),
            delay);
            
        _logger.LogInformation("ì´ë²¤íŠ¸ {EventId} ì‹œì‘ ì˜ˆì•½: {StartTime}", eventId, startTime);
    }
    
    public void ScheduleEventEnd(int eventId, DateTime endTime)
    {
        var jobId = $"event-end-{eventId}";
        var delay = endTime - DateTime.UtcNow;
        
        if (delay < TimeSpan.Zero)
        {
            _logger.LogWarning("ì´ë²¤íŠ¸ {EventId}ì˜ ì¢…ë£Œ ì‹œê°„ì´ ì´ë¯¸ ì§€ë‚¬ìŠµë‹ˆë‹¤", eventId);
            return;
        }
        
        BackgroundJob.Schedule<IEventService>(
            x => x.EndEvent(eventId),
            delay);
            
        _logger.LogInformation("ì´ë²¤íŠ¸ {EventId} ì¢…ë£Œ ì˜ˆì•½: {EndTime}", eventId, endTime);
    }
}
```

Hangfire ëŒ€ì‹œë³´ë“œ ì ‘ê·¼ìš© ì»¨íŠ¸ë¡¤ëŸ¬:

```csharp
[ApiController]
[Route("api/[controller]")]
public class AdminController : ControllerBase
{
    private readonly IGameScheduleService _scheduleService;
    
    public AdminController(IGameScheduleService scheduleService)
    {
        _scheduleService = scheduleService;
    }
    
    [HttpPost("ScheduleEvent")]
    public ScheduleEventResponse ScheduleEvent([FromBody] ScheduleEventRequest request)
    {
        _scheduleService.ScheduleEventStart(request.EventId, request.StartTime);
        _scheduleService.ScheduleEventEnd(request.EventId, request.EndTime);
        
        return new ScheduleEventResponse
        {
            Result = true,
            Message = "ì´ë²¤íŠ¸ ìŠ¤ì¼€ì¤„ë§ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
        };
    }
}

public class ScheduleEventRequest
{
    public int EventId { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
}

public class ScheduleEventResponse
{
    public bool Result { get; set; }
    public string Message { get; set; } = string.Empty;
}
```
  

## ë¹„ë™ê¸° ì´ë²¤íŠ¸ ì²˜ë¦¬ íŒ¨í„´
ê²Œì„ ì„œë²„ì—ì„œëŠ” ë‹¤ì–‘í•œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ë©°, ì´ë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤. ì—¬ê¸°ì„œëŠ” ê²Œì„ ì„œë²„ì— ì í•©í•œ ì´ë²¤íŠ¸ ì²˜ë¦¬ íŒ¨í„´ì„ ì‚´í´ë³¸ë‹¤.  
  
### ë©”ëª¨ë¦¬ ë‚´ ì´ë²¤íŠ¸ ë²„ìŠ¤ êµ¬í˜„

```csharp
public interface IGameEvent
{
    Guid Id { get; }
    DateTime Timestamp { get; }
}

public class GameEventBase : IGameEvent
{
    public Guid Id { get; } = Guid.NewGuid();
    public DateTime Timestamp { get; } = DateTime.UtcNow;
}

public interface IGameEventHandler<TEvent> where TEvent : IGameEvent
{
    Task HandleAsync(TEvent @event, CancellationToken cancellationToken);
}

public interface IGameEventBus
{
    Task PublishAsync<TEvent>(TEvent @event, CancellationToken cancellationToken = default) 
        where TEvent : IGameEvent;
    void Subscribe<TEvent>(IGameEventHandler<TEvent> handler) 
        where TEvent : IGameEvent;
    void Unsubscribe<TEvent>(IGameEventHandler<TEvent> handler) 
        where TEvent : IGameEvent;
}

public class InMemoryGameEventBus : IGameEventBus
{
    private readonly Dictionary<Type, List<object>> _handlers = new();
    private readonly ILogger<InMemoryGameEventBus> _logger;
    private readonly IServiceProvider _serviceProvider;
    
    public InMemoryGameEventBus(
        ILogger<InMemoryGameEventBus> logger,
        IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }
    
    public async Task PublishAsync<TEvent>(TEvent @event, CancellationToken cancellationToken = default)
        where TEvent : IGameEvent
    {
        var eventType = typeof(TEvent);
        
        _logger.LogDebug("ì´ë²¤íŠ¸ ë°œí–‰: {EventType}, ID: {@EventId}", eventType.Name, @event.Id);
        
        if (!_handlers.TryGetValue(eventType, out var handlers))
        {
            _logger.LogWarning("ì´ë²¤íŠ¸ {EventType}ì— ëŒ€í•œ í•¸ë“¤ëŸ¬ê°€ ì—†ìŠµë‹ˆë‹¤", eventType.Name);
            return;
        }
        
        using var scope = _serviceProvider.CreateScope();
        
        var tasks = new List<Task>();
        foreach (var handler in handlers)
        {
            var handlerInstance = handler as IGameEventHandler<TEvent>;
            if (handlerInstance != null)
            {
                try
                {
                    tasks.Add(handlerInstance.HandleAsync(@event, cancellationToken));
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "ì´ë²¤íŠ¸ {EventType} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ", eventType.Name);
                }
            }
        }
        
        await Task.WhenAll(tasks);
    }
    
    public void Subscribe<TEvent>(IGameEventHandler<TEvent> handler) where TEvent : IGameEvent
    {
        var eventType = typeof(TEvent);
        
        if (!_handlers.ContainsKey(eventType))
        {
            _handlers[eventType] = new List<object>();
        }
        
        _handlers[eventType].Add(handler);
        _logger.LogDebug("í•¸ë“¤ëŸ¬ ë“±ë¡: {HandlerType} -> {EventType}", 
            handler.GetType().Name, eventType.Name);
    }
    
    public void Unsubscribe<TEvent>(IGameEventHandler<TEvent> handler) where TEvent : IGameEvent
    {
        var eventType = typeof(TEvent);
        
        if (!_handlers.ContainsKey(eventType))
        {
            return;
        }
        
        _handlers[eventType].Remove(handler);
        _logger.LogDebug("í•¸ë“¤ëŸ¬ ì œê±°: {HandlerType} -> {EventType}", 
            handler.GetType().Name, eventType.Name);
    }
}
```

ì´ë²¤íŠ¸ ë° í•¸ë“¤ëŸ¬ ì˜ˆì‹œ:

```csharp
// ì´ë²¤íŠ¸ ì •ì˜
public class ItemPurchasedEvent : GameEventBase
{
    public long UserId { get; set; }
    public int ItemId { get; set; }
    public int Quantity { get; set; }
    public int Cost { get; set; }
    public string Currency { get; set; } = "Gold";
}

// ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
public class UserInventoryHandler : IGameEventHandler<ItemPurchasedEvent>
{
    private readonly IUserInventoryRepository _repository;
    private readonly ILogger<UserInventoryHandler> _logger;
    
    public UserInventoryHandler(
        IUserInventoryRepository repository,
        ILogger<UserInventoryHandler> logger)
    {
        _repository = repository;
        _logger = logger;
    }
    
    public async Task HandleAsync(ItemPurchasedEvent @event, CancellationToken cancellationToken)
    {
        _logger.LogInformation(
            "ì•„ì´í…œ êµ¬ë§¤ ì´ë²¤íŠ¸ ì²˜ë¦¬: ìœ ì € {UserId}, ì•„ì´í…œ {ItemId}, ìˆ˜ëŸ‰ {Quantity}",
            @event.UserId, @event.ItemId, @event.Quantity);
            
        try
        {
            await _repository.AddItemToUserInventoryAsync(
                @event.UserId, @event.ItemId, @event.Quantity, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ì¸ë²¤í† ë¦¬ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
            // ì—¬ê¸°ì„œ ë³´ìƒ ì²˜ë¦¬ë‚˜ ì¬ì‹œë„ ë¡œì§ ì¶”ê°€
        }
    }
}

public class AchievementHandler : IGameEventHandler<ItemPurchasedEvent>
{
    private readonly IAchievementService _achievementService;
    private readonly ILogger<AchievementHandler> _logger;
    
    public AchievementHandler(
        IAchievementService achievementService,
        ILogger<AchievementHandler> logger)
    {
        _achievementService = achievementService;
        _logger = logger;
    }
    
    public async Task HandleAsync(ItemPurchasedEvent @event, CancellationToken cancellationToken)
    {
        _logger.LogInformation(
            "ì•„ì´í…œ êµ¬ë§¤ì— ë”°ë¥¸ ì—…ì  í™•ì¸: ìœ ì € {UserId}, ì•„ì´í…œ {ItemId}",
            @event.UserId, @event.ItemId);
            
        await _achievementService.CheckItemCollectionAchievementsAsync(
            @event.UserId, @event.ItemId, cancellationToken);
    }
}
```

ì„œë¹„ìŠ¤ ë“±ë¡ ë° ì‚¬ìš©:

```csharp
// Program.cs
builder.Services.AddSingleton<IGameEventBus, InMemoryGameEventBus>();
builder.Services.AddScoped<IGameEventHandler<ItemPurchasedEvent>, UserInventoryHandler>();
builder.Services.AddScoped<IGameEventHandler<ItemPurchasedEvent>, AchievementHandler>();

// ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì´ë²¤íŠ¸ ë°œí–‰
[ApiController]
[Route("api/[controller]")]
public class ShopController : ControllerBase
{
    private readonly IGameEventBus _eventBus;
    
    public ShopController(IGameEventBus eventBus)
    {
        _eventBus = eventBus;
    }
    
    [HttpPost("PurchaseItem")]
    public async Task<PurchaseItemResponse> PurchaseItem([FromBody] PurchaseItemRequest request)
    {
        // êµ¬ë§¤ ë¡œì§ ì²˜ë¦¬...
        
        // ì´ë²¤íŠ¸ ë°œí–‰
        await _eventBus.PublishAsync(new ItemPurchasedEvent
        {
            UserId = request.UserId,
            ItemId = request.ItemId,
            Quantity = request.Quantity,
            Cost = request.Cost,
            Currency = request.Currency
        });
        
        return new PurchaseItemResponse
        {
            Result = true,
            Message = "ì•„ì´í…œ êµ¬ë§¤ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
        };
    }
}

public class PurchaseItemRequest
{
    public long UserId { get; set; }
    public int ItemId { get; set; }
    public int Quantity { get; set; } = 1;
    public int Cost { get; set; }
    public string Currency { get; set; } = "Gold";
}

public class PurchaseItemResponse
{
    public bool Result { get; set; }
    public string Message { get; set; } = string.Empty;
}
```

### Redisë¥¼ í™œìš©í•œ ë¶„ì‚° ì´ë²¤íŠ¸ ì²˜ë¦¬
ì—¬ëŸ¬ ì„œë²„ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì´ë²¤íŠ¸ë¥¼ ê³µìœ í•´ì•¼ í•  ê²½ìš° Redisì˜ Pub/Sub ê¸°ëŠ¥ì„ í™œìš©í•  ìˆ˜ ìˆë‹¤:

```csharp
public class RedisGameEventBus : IGameEventBus, IDisposable
{
    private readonly ILogger<RedisGameEventBus> _logger;
    private readonly IServiceProvider _serviceProvider;
    private readonly CloudStructures.Redis.RedisConnection _connection;
    private readonly ConnectionMultiplexer _multiplexer;
    private readonly ISubscriber _subscriber;
    private readonly Dictionary<Type, List<object>> _handlers = new();
    private readonly string _channelPrefix;
    private bool _disposed;
    
    public RedisGameEventBus(
        ILogger<RedisGameEventBus> logger,
        IServiceProvider serviceProvider,
        CloudStructures.Redis.RedisConnection connection,
        string channelPrefix = "game:events:")
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
        _connection = connection;
        _channelPrefix = channelPrefix;
        
        // Redis ì—°ê²° ë° êµ¬ë… ì„¤ì •
        _multiplexer = _connection.ConnectionMultiplexer;
        _subscriber = _multiplexer.GetSubscriber();
    }
    
    public async Task PublishAsync<TEvent>(TEvent @event, CancellationToken cancellationToken = default)
        where TEvent : IGameEvent
    {
        var eventType = typeof(TEvent);
        var channelName = $"{_channelPrefix}{eventType.Name}";
        var eventJson = JsonSerializer.Serialize(@event);
        
        _logger.LogDebug("Redis ì´ë²¤íŠ¸ ë°œí–‰: {Channel}, ID: {@EventId}", channelName, @event.Id);
        
        // Redisì— ì´ë²¤íŠ¸ ë°œí–‰
        await _subscriber.PublishAsync(channelName, eventJson);
        
        // ë¡œì»¬ í•¸ë“¤ëŸ¬ë„ ì²˜ë¦¬
        await ProcessLocalHandlersAsync(@event, cancellationToken);
    }
    
    private async Task ProcessLocalHandlersAsync<TEvent>(TEvent @event, CancellationToken cancellationToken)
        where TEvent : IGameEvent
    {
        var eventType = typeof(TEvent);
        
        if (!_handlers.TryGetValue(eventType, out var handlers))
        {
            return;
        }
        
        using var scope = _serviceProvider.CreateScope();
        
        var tasks = new List<Task>();
        foreach (var handler in handlers)
        {
            var handlerInstance = handler as IGameEventHandler<TEvent>;
            if (handlerInstance != null)
            {
                try
                {
                    tasks.Add(handlerInstance.HandleAsync(@event, cancellationToken));
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "ì´ë²¤íŠ¸ {EventType} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ", eventType.Name);
                }
            }
        }
        
        await Task.WhenAll(tasks);
    }
    
    public void Subscribe<TEvent>(IGameEventHandler<TEvent> handler) where TEvent : IGameEvent
    {
        var eventType = typeof(TEvent);
        var channelName = $"{_channelPrefix}{eventType.Name}";
        
        if (!_handlers.ContainsKey(eventType))
        {
            _handlers[eventType] = new List<object>();
            
            // Redis ì±„ë„ êµ¬ë…
            _subscriber.Subscribe(channelName, (channel, message) =>
            {
                try
                {
                    var @event = JsonSerializer.Deserialize<TEvent>(message);
                    if (@event != null)
                    {
                        // ë¹„ë™ê¸° ì²˜ë¦¬ ì‹œì‘
                        _ = ProcessLocalHandlersAsync(@event, CancellationToken.None);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Redis ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {Channel}", channel);
                }
            });
        }
        
        _handlers[eventType].Add(handler);
        _logger.LogDebug("Redis ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡: {HandlerType} -> {Channel}", 
            handler.GetType().Name, channelName);
    }
    
    public void Unsubscribe<TEvent>(IGameEventHandler<TEvent> handler) where TEvent : IGameEvent
    {
        var eventType = typeof(TEvent);
        
        if (!_handlers.ContainsKey(eventType))
        {
            return;
        }
        
        _handlers[eventType].Remove(handler);
        
        // í•¸ë“¤ëŸ¬ê°€ ì—†ìœ¼ë©´ êµ¬ë… ì·¨ì†Œ
        if (_handlers[eventType].Count == 0)
        {
            var channelName = $"{_channelPrefix}{eventType.Name}";
            _subscriber.Unsubscribe(channelName);
            _handlers.Remove(eventType);
            
            _logger.LogDebug("Redis ì±„ë„ êµ¬ë… ì·¨ì†Œ: {Channel}", channelName);
        }
    }
    
    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }
        
        _disposed = true;
        
        // ëª¨ë“  êµ¬ë… ì·¨ì†Œ
        foreach (var eventType in _handlers.Keys)
        {
            var channelName = $"{_channelPrefix}{eventType.Name}";
            _subscriber.Unsubscribe(channelName);
        }
        
        _handlers.Clear();
    }
}
```

CloudStructuresë¥¼ ì‚¬ìš©í•œ Redis ì—°ê²° ì„¤ì •:

```csharp
// Program.cs
// Redis ì—°ê²° ì„¤ì •
var redisConfig = new CloudStructures.RedisConfig("GameEvents", 
    builder.Configuration.GetConnectionString("RedisConnection"));
builder.Services.AddSingleton(new CloudStructures.Redis.RedisConnection(redisConfig));

// ì´ë²¤íŠ¸ ë²„ìŠ¤ ë“±ë¡
builder.Services.AddSingleton<IGameEventBus, RedisGameEventBus>();
```
  

## ì‹¤ì „ ì‘ìš© ì˜ˆì œ
ì•„ë˜ ì˜ˆì œëŠ” ë¹„ë™ê¸° ì‘ì—…, ìŠ¤ì¼€ì¤„ë§, ì´ë²¤íŠ¸ ì²˜ë¦¬ë¥¼ ì¢…í•©ì ìœ¼ë¡œ í™œìš©í•˜ëŠ” ê²Œì„ ì„œë²„ ê¸°ëŠ¥ êµ¬í˜„ì´ë‹¤.

### ê¸¸ë“œ ì „íˆ¬ ìë™í™” ì‹œìŠ¤í…œ

```csharp
// ê¸¸ë“œ ì „íˆ¬ ì„œë¹„ìŠ¤
public interface IGuildBattleService
{
    Task StartGuildBattle();
    Task EndGuildBattle();
    Task ProcessRoundResults(int roundId);
}

public class GuildBattleService : IGuildBattleService
{
    private readonly ILogger<GuildBattleService> _logger;
    private readonly IGameEventBus _eventBus;
    private readonly IBackgroundTaskQueue _taskQueue;
    
    public GuildBattleService(
        ILogger<GuildBattleService> logger,
        IGameEventBus eventBus,
        IBackgroundTaskQueue taskQueue)
    {
        _logger = logger;
        _eventBus = eventBus;
        _taskQueue = taskQueue;
    }
    
    public async Task StartGuildBattle()
    {
        _logger.LogInformation("ê¸¸ë“œ ì „íˆ¬ ì‹œì‘ ì²˜ë¦¬");
        
        // ì´ë²¤íŠ¸ ë°œí–‰
        await _eventBus.PublishAsync(new GuildBattleStartedEvent
        {
            BattleId = 123, // ì‹¤ì œë¡œëŠ” DBì—ì„œ ê°€ì ¸ì˜¨ ê°’
            StartTime = DateTime.UtcNow,
            EndTime = DateTime.UtcNow.AddDays(2)
        });
        
        // ë¼ìš´ë“œë³„ ìŠ¤ì¼€ì¤„ë§ (4ì‹œê°„ë§ˆë‹¤ ë¼ìš´ë“œ ê²°ê³¼ ì²˜ë¦¬)
        for (int i = 1; i <= 12; i++)
        {
            var roundId = i;
            var delay = TimeSpan.FromHours(4 * i);
            
            BackgroundJob.Schedule<IGuildBattleService>(
                x => x.ProcessRoundResults(roundId),
                delay);
        }
    }
    
    public async Task EndGuildBattle()
    {
        _logger.LogInformation("ê¸¸ë“œ ì „íˆ¬ ì¢…ë£Œ ì²˜ë¦¬");
        
        // íì— ì‘ì—… ì¶”ê°€ (CPU ì§‘ì•½ì  ì‘ì—…)
        await _taskQueue.QueueTaskAsync(async token =>
        {
            _logger.LogInformation("ê¸¸ë“œ ì „íˆ¬ ìµœì¢… ê²°ê³¼ ê³„ì‚° ì‹œì‘");
            
            // ê¸¸ë“œ ì „íˆ¬ ê²°ê³¼ ì§‘ê³„ (ê°€ì •) - ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—…
            await Task.Delay(10000, token);
            
            _logger.LogInformation("ê¸¸ë“œ ì „íˆ¬ ìµœì¢… ê²°ê³¼ ê³„ì‚° ì™„ë£Œ");
            
            // ì´ë²¤íŠ¸ ë°œí–‰
            await _eventBus.PublishAsync(new GuildBattleEndedEvent
            {
                BattleId = 123,
                WinnerGuildId = 456
            });
        });
        
        // ë³´ìƒ ì§€ê¸‰ ì‘ì—… ì˜ˆì•½ (ê¸¸ë“œ ì „íˆ¬ ì¢…ë£Œ 10ë¶„ í›„)
        BackgroundJob.Schedule<IRewardService>(
            x => x.DistributeGuildBattleRewards(123),
            TimeSpan.FromMinutes(10));
    }
    
    public async Task ProcessRoundResults(int roundId)
    {
        _logger.LogInformation("ê¸¸ë“œ ì „íˆ¬ ë¼ìš´ë“œ {RoundId} ê²°ê³¼ ì²˜ë¦¬", roundId);
        
        // ë¼ìš´ë“œ ê²°ê³¼ ì²˜ë¦¬ ë¡œì§...
        
        // ì´ë²¤íŠ¸ ë°œí–‰
        await _eventBus.PublishAsync(new GuildBattleRoundEndedEvent
        {
            BattleId = 123,
            RoundId = roundId,
            NextRoundStartTime = roundId < 12 ? DateTime.UtcNow.AddHours(4) : null
        });
    }
}

// ì´ë²¤íŠ¸ ì •ì˜
public class GuildBattleStartedEvent : GameEventBase
{
    public int BattleId { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
}

public class GuildBattleRoundEndedEvent : GameEventBase
{
    public int BattleId { get; set; }
    public int RoundId { get; set; }
    public DateTime? NextRoundStartTime { get; set; }
}

public class GuildBattleEndedEvent : GameEventBase
{
    public int BattleId { get; set; }
    public int WinnerGuildId { get; set; }
}

// ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
public class NotificationHandler : IGameEventHandler<GuildBattleStartedEvent>,
                                  IGameEventHandler<GuildBattleRoundEndedEvent>,
                                  IGameEventHandler<GuildBattleEndedEvent>
{
    private readonly INotificationService _notificationService;
    private readonly ILogger<NotificationHandler> _logger;
    
    public NotificationHandler(
        INotificationService notificationService,
        ILogger<NotificationHandler> logger)
    {
        _notificationService = notificationService;
        _logger = logger;
    }
    
    public async Task HandleAsync(GuildBattleStartedEvent @event, CancellationToken cancellationToken)
    {
        _logger.LogInformation("ê¸¸ë“œ ì „íˆ¬ ì‹œì‘ ì•Œë¦¼ ì „ì†¡");
        
        // ì°¸ê°€ ê¸¸ë“œì›ë“¤ì—ê²Œ í‘¸ì‹œ ì•Œë¦¼ ì „ì†¡
        await _notificationService.SendGuildBattleNotificationAsync(
            @event.BattleId,
            "ê¸¸ë“œ ì „íˆ¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!",
            "ê¸¸ë“œì›ë“¤ê³¼ í•¨ê»˜ ì „íˆ¬ì— ì°¸ì—¬í•˜ì„¸ìš”.",
            cancellationToken);
    }
    
    public async Task HandleAsync(GuildBattleRoundEndedEvent @event, CancellationToken cancellationToken)
    {
        _logger.LogInformation("ê¸¸ë“œ ì „íˆ¬ ë¼ìš´ë“œ {RoundId} ì¢…ë£Œ ì•Œë¦¼ ì „ì†¡", @event.RoundId);
        
        var message = @event.NextRoundStartTime.HasValue
            ? $"ë‹¤ìŒ ë¼ìš´ë“œëŠ” {(@event.NextRoundStartTime.Value.ToLocalTime().ToString("HH:mm"))}ì— ì‹œì‘ë©ë‹ˆë‹¤."
            : "ì´ë²ˆ ë¼ìš´ë“œê°€ ë§ˆì§€ë§‰ ë¼ìš´ë“œì…ë‹ˆë‹¤.";
            
        await _notificationService.SendGuildBattleNotificationAsync(
            @event.BattleId,
            $"ê¸¸ë“œ ì „íˆ¬ ë¼ìš´ë“œ {@event.RoundId} ì¢…ë£Œ",
            message,
            cancellationToken);
    }
    
    public async Task HandleAsync(GuildBattleEndedEvent @event, CancellationToken cancellationToken)
    {
        _logger.LogInformation("ê¸¸ë“œ ì „íˆ¬ ì¢…ë£Œ ì•Œë¦¼ ì „ì†¡");
        
        await _notificationService.SendGuildBattleEndNotificationAsync(
            @event.BattleId,
            @event.WinnerGuildId,
            cancellationToken);
    }
}

// .http íŒŒì¼ ì˜ˆì‹œ
// @host = https://localhost:5001
// @content-type = application/json

### ê¸¸ë“œ ì „íˆ¬ ì‹œì‘ ì˜ˆì•½
POST {{host}}/api/GuildBattle/ScheduleStart
Content-Type: {{content-type}}

{
  "battleId": 123,
  "startTime": "2025-05-02T20:00:00Z",
  "endTime": "2025-05-04T20:00:00Z"
}

### ê¸¸ë“œ ì „íˆ¬ ìˆ˜ë™ ì‹œì‘
POST {{host}}/api/GuildBattle/Start
Content-Type: {{content-type}}

{
  "battleId": 123
}

### ê¸¸ë“œ ì „íˆ¬ ìˆ˜ë™ ì¢…ë£Œ
POST {{host}}/api/GuildBattle/End
Content-Type: {{content-type}}

{
  "battleId": 123
}

### ê¸¸ë“œ ì „íˆ¬ ìƒíƒœ í™•ì¸
POST {{host}}/api/GuildBattle/Status
Content-Type: {{content-type}}

{
  "battleId": 123
}
```

### ì»¨íŠ¸ë¡¤ëŸ¬ êµ¬í˜„

```csharp
[ApiController]
[Route("api/[controller]")]
public class GuildBattleController : ControllerBase
{
    private readonly IGuildBattleService _guildBattleService;
    private readonly IGameScheduleService _scheduleService;
    
    public GuildBattleController(
        IGuildBattleService guildBattleService,
        IGameScheduleService scheduleService)
    {
        _guildBattleService = guildBattleService;
        _scheduleService = scheduleService;
    }
    
    [HttpPost("ScheduleStart")]
    public GuildBattleResponse ScheduleStart([FromBody] ScheduleGuildBattleRequest request)
    {
        // Hangfireë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸¸ë“œ ì „íˆ¬ ì‹œì‘ ì¼ì • ì˜ˆì•½
        BackgroundJob.Schedule<IGuildBattleService>(
            x => x.StartGuildBattle(),
            request.StartTime - DateTime.UtcNow);
            
        // ê¸¸ë“œ ì „íˆ¬ ì¢…ë£Œ ì¼ì • ì˜ˆì•½
        BackgroundJob.Schedule<IGuildBattleService>(
            x => x.EndGuildBattle(),
            request.EndTime - DateTime.UtcNow);
            
        return new GuildBattleResponse
        {
            Result = true,
            Message = "ê¸¸ë“œ ì „íˆ¬ ì¼ì •ì´ ì˜ˆì•½ë˜ì—ˆìŠµë‹ˆë‹¤."
        };
    }
    
    [HttpPost("Start")]
    public async Task<GuildBattleResponse> Start([FromBody] GuildBattleRequest request)
    {
        await _guildBattleService.StartGuildBattle();
        
        return new GuildBattleResponse
        {
            Result = true,
            Message = "ê¸¸ë“œ ì „íˆ¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤."
        };
    }
    
    [HttpPost("End")]
    public async Task<GuildBattleResponse> End([FromBody] GuildBattleRequest request)
    {
        await _guildBattleService.EndGuildBattle();
        
        return new GuildBattleResponse
        {
            Result = true,
            Message = "ê¸¸ë“œ ì „íˆ¬ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
        };
    }
    
    [HttpPost("Status")]
    public GuildBattleStatusResponse Status([FromBody] GuildBattleRequest request)
    {
        // ì‹¤ì œë¡œëŠ” DBì—ì„œ ìƒíƒœ ì¡°íšŒ
        
        return new GuildBattleStatusResponse
        {
            BattleId = request.BattleId,
            Status = "Active",
            CurrentRound = 3,
            NextRoundTime = DateTime.UtcNow.AddHours(1),
            ParticipatingGuilds = 24,
            TopGuild = new GuildInfo { Id = 456, Name = "ë“œë˜ê³¤ ìŠ¬ë ˆì´ì–´" }
        };
    }
}

public class ScheduleGuildBattleRequest
{
    public int BattleId { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
}

public class GuildBattleRequest
{
    public int BattleId { get; set; }
}

public class GuildBattleResponse
{
    public bool Result { get; set; }
    public string Message { get; set; } = string.Empty;
}

public class GuildBattleStatusResponse
{
    public int BattleId { get; set; }
    public string Status { get; set; } = string.Empty;
    public int CurrentRound { get; set; }
    public DateTime? NextRoundTime { get; set; }
    public int ParticipatingGuilds { get; set; }
    public GuildInfo? TopGuild { get; set; }
}

public class GuildInfo
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
}
```

ë¹„ë™ê¸° ì‘ì—… ì²˜ë¦¬, Hangfire ìŠ¤ì¼€ì¤„ë§, ì´ë²¤íŠ¸ ì²˜ë¦¬ íŒ¨í„´ì€ ê²Œì„ ì„œë²„ì˜ íš¨ìœ¨ì„±ê³¼ í™•ì¥ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚¨ë‹¤. ì´ëŸ¬í•œ íŒ¨í„´ë“¤ì„ ì ì ˆíˆ ì¡°í•©í•˜ì—¬ ì‚¬ìš©í•˜ë©´ ì‚¬ìš©ì ê²½í—˜ì„ ì €í•´í•˜ì§€ ì•Šìœ¼ë©´ì„œë„ ë³µì¡í•œ ê²Œì„ ë¡œì§ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

ê²Œì„ ì„œë²„ ê°œë°œì—ì„œ ë¹„ë™ê¸° ì‘ì—… ì²˜ë¦¬ëŠ” í•„ìˆ˜ì ì¸ ë¶€ë¶„ì´ë©°, ASP.NET CoreëŠ” ì´ë¥¼ ìœ„í•œ ë‹¤ì–‘í•œ ë„êµ¬ì™€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì œê³µí•œë‹¤. ì´ ì¥ì—ì„œ ì„¤ëª…í•œ íŒ¨í„´ê³¼ ê¸°ë²•ë“¤ì„ í™œìš©í•˜ì—¬ íš¨ìœ¨ì ì´ê³  í™•ì¥ ê°€ëŠ¥í•œ ê²Œì„ ì„œë²„ë¥¼ êµ¬ì¶•í•  ìˆ˜ ìˆë‹¤.   
  
  


   