# ASP.NET Core Web API로 게임 서버 개발
  
저자: 최흥배, Claude AI   
-----------------------      
   
# 2부: 데이터베이스 연동 및 기본 기능 구현
  
--------------     

# Chapter 5. MySQL 데이터베이스 연동
      
## 5.1 게임 서버에서 MySQL의 역할
게임 서버에서 MySQL은 플레이어 정보, 캐릭터 데이터, 아이템 인벤토리 등 영구적으로 저장해야 할 데이터를 관리한다. 수집형 RPG 게임에서는 특히 다양한 캐릭터와 아이템 정보, 사용자 진행 상태 등을 안정적으로 저장하고 조회할 필요가 있다.

```
┌─────────────────────┐       ┌─────────────────────┐
│                     │       │                     │
│   ASP.NET Core      │◄─────►│     MySQL DB        │
│   Web API Server    │       │                     │
│                     │       │  - 플레이어 정보      │
└─────────────────────┘       │  - 캐릭터 데이터      │
                              │  - 아이템 정보       │
                              │  - 퀘스트 진행상태    │
                              └─────────────────────┘
```

## 5.2 MySqlConnector 소개
MySqlConnector는 MySQL 데이터베이스에 접속하기 위한 오픈소스 .NET 데이터 공급자다. 기존의 MySQL Connector/NET(MySql.Data)보다 성능이 뛰어나고 비동기 작업을 더 잘 지원한다.

### 5.2.1 MySqlConnector 설치
프로젝트에 MySqlConnector를 설치하려면 다음 명령을 실행한다:

```bash
dotnet add package MySqlConnector
```

### 5.2.2 데이터베이스 연결 설정
`appsettings.json` 파일에 MySQL 연결 문자열을 추가한다:

```json
{
  "ConnectionStrings": {
    "GameDatabase": "Server=localhost;Database=rpg_game;User=gameuser;Password=password;SslMode=none;"
  }
}
```
  

## 5.3 MySqlConnector 기본 사용법

### 5.3.1 연결 및 기본 쿼리 실행
다음은 MySqlConnector를 사용하여 데이터베이스에 연결하고 쿼리를 실행하는 기본 예제다:

```csharp
using MySqlConnector;
using System.Threading.Tasks;

public class PlayerRepository
{
    private readonly string _connectionString;

    public PlayerRepository(string connectionString)
    {
        _connectionString = connectionString;
    }

    public async Task<Player> GetPlayerByIdAsync(int playerId)
    {
        using var connection = new MySqlConnection(_connectionString);
        await connection.OpenAsync();

        using var command = connection.CreateCommand();
        command.CommandText = "SELECT id, username, level, experience FROM players WHERE id = @playerId";
        command.Parameters.AddWithValue("@playerId", playerId);

        using var reader = await command.ExecuteReaderAsync();
        if (await reader.ReadAsync())
        {
            return new Player
            {
                Id = reader.GetInt32(0),
                Username = reader.GetString(1),
                Level = reader.GetInt32(2),
                Experience = reader.GetInt32(3)
            };
        }

        return null;
    }
}
```
  
#### 코드 동작 순서 (단계별 설명)
코드는 `GetPlayerByIdAsync` 메서드가 호출되면 아래 순서대로 동작한다.

1.  **초기화**: `PlayerRepository` 객체가 생성될 때 외부에서 데이터베이스 **연결 정보(`connectionString`)**를 받아와 저장한다.

2.  **DB 연결 (Connect)**: `MySqlConnection` 객체를 생성하고, `connection.OpenAsync()`를 통해 데이터베이스에 **비동기적으로 연결**을 시도한다.

3.  **명령 생성 (Create Command)**: 실행할 SQL 쿼리(`SELECT ...`)를 담을 `MySqlCommand` 객체를 만든다.

4.  **파라미터 설정 (Set Parameter)**: SQL 쿼리문 안의 `@playerId`라는 placeholder(자리 표시자)에 메서드로 전달받은 `playerId` 값을 **안전하게 설정**한다.

5.  **쿼리 실행 (Execute)**: `command.ExecuteReaderAsync()`를 호출하여 데이터베이스에 쿼리를 **비동기적으로 실행**하고, 그 결과를 읽을 수 있는 `MySqlDataReader` 객체를 받는다.

6.  **결과 확인 및 변환 (Read & Map)**:
    * `reader.ReadAsync()`를 통해 결과 데이터가 있는지 확인한다.
    * 데이터가 **있다면**(플레이어를 찾았다면), 각 컬럼의 값을 인덱스(`0`, `1`, `2`...)로 읽어와 새로운 `Player` 객체를 만들어 그 값을 채운 뒤 반환한다.
    * 데이터가 **없다면**(플레이어를 못 찾았다면), `null`을 반환한다.

7.  **리소스 해제 (Dispose)**: `using` 문 덕분에 메서드가 종료될 때(값을 반환하거나 오류 발생 시) 사용했던 `connection`, `command`, `reader` 객체들이 **자동으로 정리**된다.
  

### 5.3.2 트랜잭션 사용
게임에서 아이템 교환이나 캐릭터 강화와 같은 작업은 여러 쿼리가 모두 성공적으로 실행되어야 한다. 이런 경우 트랜잭션을 사용한다:  
  
```csharp
public async Task<bool> EnhanceCharacterAsync(int characterId, int itemId)
{
    using var connection = new MySqlConnection(_connectionString);
    await connection.OpenAsync();

    using var transaction = await connection.BeginTransactionAsync();
    
    try
    {
        // 1. 캐릭터 강화 아이템 확인
        using var checkCommand = connection.CreateCommand();
        checkCommand.Transaction = transaction;
        checkCommand.CommandText = "SELECT count(*) FROM player_items WHERE id = @itemId AND item_type = 'enhancement'";
        checkCommand.Parameters.AddWithValue("@itemId", itemId);
        
        var itemExists = (long)await checkCommand.ExecuteScalarAsync() > 0;
        if (!itemExists)
        {
            await transaction.RollbackAsync();
            return false;
        }
        
        // 2. 캐릭터 능력치 증가
        using var updateCommand = connection.CreateCommand();
        updateCommand.Transaction = transaction;
        updateCommand.CommandText = "UPDATE characters SET power = power + 10, level = level + 1 WHERE id = @characterId";
        updateCommand.Parameters.AddWithValue("@characterId", characterId);
        await updateCommand.ExecuteNonQueryAsync();
        
        // 3. 소모된 아이템 제거
        using var deleteCommand = connection.CreateCommand();
        deleteCommand.Transaction = transaction;
        deleteCommand.CommandText = "DELETE FROM player_items WHERE id = @itemId";
        deleteCommand.Parameters.AddWithValue("@itemId", itemId);
        await deleteCommand.ExecuteNonQueryAsync();
        
        await transaction.CommitAsync();
        return true;
    }
    catch (Exception)
    {
        await transaction.RollbackAsync();
        throw;
    }
}
```

### 참고 자료 
- [MySqlConnector 간단 정리](https://gist.github.com/jacking75/51a1c96f4efa1b7a27030a7410f39bc6 )  

 
## 5.4 SqlKata 소개
SqlKata는 SQL 쿼리 빌더로, 타입 안전성과 가독성을 높여주는 도구다. 여러 데이터베이스 시스템을 지원하며, 복잡한 SQL 쿼리를 C# 코드로 쉽게 작성할 수 있게 해준다.  
[SqlKata](https://sqlkata.com )  

### 5.4.1 SqlKata 설치
프로젝트에 SqlKata와 MySqlConnector용 컴파일러를 설치한다:  

```bash
dotnet add package SqlKata
dotnet add package SqlKata.Execution
```

### 5.4.2 SqlKata 설정
다음은 SqlKata를 설정하는 방법이다:

```csharp
using SqlKata.Compilers;
using SqlKata.Execution;


IDbConnection _dbConn = new MySqlConnection(_dbConfig.Value.AccountDb);
_dbConn.Open();

SqlKata.Compilers.MySqlCompiler _compiler;
QueryFactory _queryFactory;  

_compiler = new SqlKata.Compilers.MySqlCompiler();
_queryFactory = new SqlKata.Execution.QueryFactory(_dbConn, _compiler);

// 사용하기
var count = await _queryFactory.Query("account").InsertAsync(new {
                                                                   Email = email,
                                                                   SaltValue = saltValue,
                                                                   HashedPassword = hashingPassword
                                                                 });
```
    
    
## 5.5 SqlKata 쿼리 빌더 패턴 활용
SqlKata를 사용하면 SQL 쿼리를 C# 코드로 표현할 수 있어 가독성과 유지보수성이 향상된다.

### 5.5.1 기본 쿼리 작성

```csharp
public class PlayerRepository
{
    private readonly QueryFactory _db;

    public PlayerRepository(QueryFactory db)
    {
        _db = db;
    }

    public async Task<Player> GetPlayerByIdAsync(int playerId)
    {
        return await _db.Query("players")
            .Where("id", playerId)
            .FirstOrDefaultAsync<Player>();
    }

    public async Task<List<Player>> GetTopPlayersByLevelAsync(int limit = 10)
    {
        return await _db.Query("players")
            .OrderByDesc("level")
            .ThenByDesc("experience")
            .LimitAsync<Player>(limit);
    }
}
```

### 5.5.2 복잡한 쿼리 작성

```csharp
public async Task<List<CharacterWithItems>> GetCharactersWithItemsAsync(int playerId)
{
    var query = _db.Query("characters as c")
        .Select("c.id", "c.name", "c.level", "c.class", "c.power")
        .Where("c.player_id", playerId)
        .OrderByDesc("c.level");
        
    var characters = await query.GetAsync<Character>();
    
    var result = new List<CharacterWithItems>();
    
    foreach (var character in characters)
    {
        var items = await _db.Query("character_items as ci")
            .Join("items as i", "i.id", "ci.item_id")
            .Select("i.id", "i.name", "i.type", "i.rarity", "i.stat_bonus")
            .Where("ci.character_id", character.Id)
            .GetAsync<Item>();
            
        result.Add(new CharacterWithItems
        {
            Character = character,
            Items = items.ToList()
        });
    }
    
    return result;
}
```
    
#### 1. 첫 번째 쿼리: 플레이어의 캐릭터 목록 조회 🔍

```csharp
var query = _db.Query("characters as c")
    .Select("c.id", "c.name", "c.level", "c.class", "c.power")
    .Where("c.player_id", playerId)
    .OrderByDesc("c.level");
```

이 코드는 C# 코드로 SQL 쿼리를 만드는 **쿼리 빌더(Query Builder)** 구문입니다. 실제 데이터베이스에 실행될 때는 아래와 같은 SQL 문으로 변환된다.
  
```sql
SELECT
  c.id,
  c.name,
  c.level,
  c.class,
  c.power
FROM characters AS c
WHERE c.player_id = @playerId -- @playerId에는 입력받은 playerId 값이 들어감
ORDER BY c.level DESC;
```

  * **FROM `characters` AS `c`**: `characters` 테이블을 `c`라는 별칭으로 사용한다.
  * **SELECT `c.id`, `c.name`, ...**: `c` 테이블(즉, `characters` 테이블)에서 `id`, `name` 등 지정된 컬럼들을 선택한다.
  * **WHERE `c.player_id` = @playerId**: **`player_id`**가 매개변수로 받은 `playerId`와 일치하는 캐릭터만 필터링한다.
  * **ORDER BY `c.level` DESC**: 조회된 캐릭터 목록을 **`level`** 기준으로 **내림차순(DESC)** 정렬한다. 즉, 레벨이 높은 캐릭터부터 순서대로 가져온다.  
  
**결론적으로 이 쿼리는 특정 플레이어의 모든 캐릭터를 레벨 높은 순으로 정렬하여 가져오는 역할을 한다.**


#### 2. 두 번째 쿼리: 각 캐릭터의 아이템 목록 조회 (반복 실행) 🔄
  
```csharp
var items = await _db.Query("character_items as ci")
    .Join("items as i", "i.id", "ci.item_id")
    .Select("i.id", "i.name", "i.type", "i.rarity", "i.stat_bonus")
    .Where("ci.character_id", character.Id)
    .GetAsync<Item>();
```

이 쿼리는 첫 번째 쿼리에서 가져온 캐릭터 목록을 순회하는 **`foreach` 반복문 안에서 실행**된다. 즉, **캐릭터의 수만큼 반복해서 실행**된다.

이 구문이 변환되는 SQL 문은 다음과 같다.  
  
```sql
SELECT
  i.id,
  i.name,
  i.type,
  i.rarity,
  i.stat_bonus
FROM character_items AS ci
JOIN items AS i ON i.id = ci.item_id
WHERE ci.character_id = @characterId; -- @characterId에는 루프 중인 현재 캐릭터의 ID가 들어감
```

  * **FROM `character_items` AS `ci`**: 캐릭터와 아이템의 관계를 저장하는 중간 테이블인 `character_items`를 `ci`라는 별칭으로 사용한다.
  * **JOIN `items` AS `i` ON `i.id` = `ci.item_id`**: `character_items` 테이블과 `items` 테이블을 **`JOIN`** 합니다. `ci` 테이블의 `item_id`와 `i` 테이블의 `id`가 같은 데이터를 연결하여, 캐릭터가 장착한 아이템의 상세 정보를 가져올 수 있게 한다.
  * **SELECT `i.id`, `i.name`, ...**: `items` 테이블에서 아이템의 상세 정보 컬럼들을 선택한다.
  * **WHERE `ci.character_id` = @characterId**: `character_items` 테이블에서 현재 루프 중인 **특정 캐릭터의 ID(`character.Id`)**와 일치하는 데이터만 필터링한다.

**결론적으로 이 쿼리는 특정 캐릭터 한 명이 장착하고 있는 모든 아이템의 상세 정보를 가져오는 역할을 한다.**  
  
  
### 5.5.3 조건부 쿼리 구성

```csharp
public async Task<List<Character>> SearchCharactersAsync(CharacterSearchFilter filter)
{
    var query = _db.Query("characters");
    
    if (filter.PlayerId.HasValue)
    {
        query = query.Where("player_id", filter.PlayerId.Value);
    }
    
    if (!string.IsNullOrEmpty(filter.Name))
    {
        query = query.WhereLike("name", $"%{filter.Name}%");
    }
    
    if (filter.MinLevel.HasValue)
    {
        query = query.Where("level", ">=", filter.MinLevel.Value);
    }
    
    if (filter.MaxLevel.HasValue)
    {
        query = query.Where("level", "<=", filter.MaxLevel.Value);
    }
    
    if (!string.IsNullOrEmpty(filter.Class))
    {
        query = query.Where("class", filter.Class);
    }
    
    if (filter.SortBy == "level")
    {
        query = filter.SortDirection == "desc" 
            ? query.OrderByDesc("level") 
            : query.OrderBy("level");
    }
    else
    {
        query = filter.SortDirection == "desc" 
            ? query.OrderByDesc("power") 
            : query.OrderBy("power");
    }
    
    return await query.LimitAsync<Character>(filter.Limit ?? 20);
}
```
    

## 5.6 실제 게임 시스템 구현 예제
이제 실제 게임 서버의 API 엔드포인트와 MySqlConnector 및 SqlKata를 활용한 데이터 액세스 계층을 구현해보자.
  
### 5.6.1 플레이어 모델 및 리포지토리

**모델:**  

```csharp
// Models/Player.cs
public class Player
{
    public int Id { get; set; }
    public string Username { get; set; }
    public int Level { get; set; }
    public int Experience { get; set; }
    public int Gold { get; set; }
    public int Gems { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime LastLoginAt { get; set; }
}

public class PlayerResponse
{
    public bool Success { get; set; }
    public Player Data { get; set; }
    public string Message { get; set; }
}

public class PlayerListResponse
{
    public bool Success { get; set; }
    public List<Player> Data { get; set; }
    public string Message { get; set; }
}
```

**리포지토리:**  

```csharp
// Repositories/PlayerRepository.cs
public class PlayerRepository : IPlayerRepository
{
    private readonly QueryFactory _db;

    public PlayerRepository(QueryFactory db)
    {
        _db = db;
    }

    public async Task<Player> GetByIdAsync(int id)
    {
        return await _db.Query("players")
            .Where("id", id)
            .FirstOrDefaultAsync<Player>();
    }

    public async Task<Player> GetByUsernameAsync(string username)
    {
        return await _db.Query("players")
            .Where("username", username)
            .FirstOrDefaultAsync<Player>();
    }

    public async Task<int> CreateAsync(Player player)
    {
        player.CreatedAt = DateTime.UtcNow;
        player.LastLoginAt = DateTime.UtcNow;
        
        return await _db.Query("players").InsertGetIdAsync<int>(new
        {
            player.Username,
            player.Level,
            player.Experience,
            player.Gold,
            player.Gems,
            player.CreatedAt,
            player.LastLoginAt
        });
    }

    public async Task<bool> UpdateAsync(Player player)
    {
        var affected = await _db.Query("players")
            .Where("id", player.Id)
            .UpdateAsync(new
            {
                player.Level,
                player.Experience,
                player.Gold,
                player.Gems,
                player.LastLoginAt
            });
            
        return affected > 0;
    }

    public async Task<List<Player>> GetTopPlayersAsync(int limit = 10)
    {
        return await _db.Query("players")
            .OrderByDesc("level")
            .ThenByDesc("experience")
            .LimitAsync<Player>(limit);
    }
}
```
  
  
### 5.6.2 컨트롤러 구현

```csharp
// Controllers/PlayerController.cs
[ApiController]
[Route("api/[controller]")]
public class PlayerController : ControllerBase
{
    private readonly IPlayerRepository _playerRepository;

    public PlayerController(IPlayerRepository playerRepository)
    {
        _playerRepository = playerRepository;
    }

    [HttpPost("get")]
    public async Task<PlayerResponse> GetPlayer([FromBody] GetPlayerRequest request)
    {
        var player = await _playerRepository.GetByIdAsync(request.PlayerId);
        
        if (player == null)
        {
            return new PlayerResponse 
            { 
                Success = false, 
                Message = "플레이어를 찾을 수 없습니다." 
            };
        }
        
        return new PlayerResponse
        {
            Success = true,
            Data = player
        };
    }

    [HttpPost("create")]
    public async Task<PlayerResponse> CreatePlayer([FromBody] CreatePlayerRequest request)
    {
        var existingPlayer = await _playerRepository.GetByUsernameAsync(request.Username);
        
        if (existingPlayer != null)
        {
            return new PlayerResponse 
            { 
                Success = false, 
                Message = "이미 존재하는 사용자 이름입니다." 
            };
        }
        
        var player = new Player
        {
            Username = request.Username,
            Level = 1,
            Experience = 0,
            Gold = 1000,
            Gems = 100
        };
        
        player.Id = await _playerRepository.CreateAsync(player);
        
        return new PlayerResponse
        {
            Success = true,
            Data = player,
            Message = "플레이어가 성공적으로 생성되었습니다."
        };
    }

    [HttpPost("top")]
    public async Task<PlayerListResponse> GetTopPlayers([FromBody] GetTopPlayersRequest request)
    {
        var limit = request.Limit > 0 ? request.Limit : 10;
        var players = await _playerRepository.GetTopPlayersAsync(limit);
        
        return new PlayerListResponse
        {
            Success = true,
            Data = players
        };
    }
}
```

### 5.6.3 요청 및 응답 모델

```csharp
// Models/Requests/PlayerRequests.cs
public class GetPlayerRequest
{
    public int PlayerId { get; set; }
}

public class CreatePlayerRequest
{
    public string Username { get; set; }
}

public class GetTopPlayersRequest
{
    public int Limit { get; set; } = 10;
}
```
  

### 5.6.4 HTTP 요청 테스트 파일

```
### 플레이어 생성
POST https://localhost:5001/api/player/create
Content-Type: application/json

{
  "username": "dragon_slayer"
}

### 플레이어 정보 조회
POST https://localhost:5001/api/player/get
Content-Type: application/json

{
  "playerId": 1
}

### 최상위 플레이어 목록 조회
POST https://localhost:5001/api/player/top
Content-Type: application/json

{
  "limit": 5
}
```
  
  
## 5.7 데이터베이스 마이그레이션 및 초기 설정
게임 서버 개발에서는 데이터베이스 스키마를 코드로 관리하는 것이 중요하다. 다음은 게임 데이터베이스 스키마 생성 스크립트다:  
  
```sql
-- 플레이어 테이블
CREATE TABLE players (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    level INT NOT NULL DEFAULT 1,
    experience INT NOT NULL DEFAULT 0,
    gold INT NOT NULL DEFAULT 1000,
    gems INT NOT NULL DEFAULT 100,
    created_at DATETIME NOT NULL,
    last_login_at DATETIME NOT NULL,
    INDEX idx_username (username),
    INDEX idx_level (level)
);

-- 캐릭터 테이블
CREATE TABLE characters (
    id INT AUTO_INCREMENT PRIMARY KEY,
    player_id INT NOT NULL,
    name VARCHAR(50) NOT NULL,
    class VARCHAR(30) NOT NULL,
    level INT NOT NULL DEFAULT 1,
    experience INT NOT NULL DEFAULT 0,
    power INT NOT NULL DEFAULT 100,
    created_at DATETIME NOT NULL,
    INDEX idx_player_id (player_id),
    INDEX idx_class (class),
    INDEX idx_level (level)
);

-- 아이템 마스터 테이블
CREATE TABLE items (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    type VARCHAR(30) NOT NULL,
    rarity VARCHAR(20) NOT NULL,
    stat_bonus JSON,
    icon_url VARCHAR(255)
);

-- 플레이어 소유 아이템 테이블
CREATE TABLE player_items (
    id INT AUTO_INCREMENT PRIMARY KEY,
    player_id INT NOT NULL,
    item_id INT NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    acquired_at DATETIME NOT NULL,
    INDEX idx_player_id (player_id)
);

-- 캐릭터 장착 아이템 테이블
CREATE TABLE character_items (
    id INT AUTO_INCREMENT PRIMARY KEY,
    character_id INT NOT NULL,
    item_id INT NOT NULL,
    slot VARCHAR(30) NOT NULL,
    equipped_at DATETIME NOT NULL,
    UNIQUE KEY unique_character_slot (character_id, slot),
    INDEX idx_character_id (character_id)
);

-- 퀘스트 테이블
CREATE TABLE quests (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(100) NOT NULL,
    description TEXT,
    min_level INT NOT NULL DEFAULT 1,
    rewards JSON NOT NULL,
    type VARCHAR(30) NOT NULL
);

-- 플레이어 퀘스트 상태 테이블
CREATE TABLE player_quests (
    id INT AUTO_INCREMENT PRIMARY KEY,
    player_id INT NOT NULL,
    quest_id INT NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'available',
    progress JSON,
    completed_at DATETIME NULL,
    UNIQUE KEY unique_player_quest (player_id, quest_id),
    INDEX idx_player_id (player_id),
    INDEX idx_status (status)
);
```
  

## 5.8 쿼리 최적화 및 성능 향상 기법
게임 서버는 많은 동시 접속자를 처리해야 하므로 데이터베이스 쿼리 최적화가 중요하다.

### 5.8.1 인덱스 설계
적절한 인덱스 설계는 쿼리 성능에 큰 영향을 미친다:

```csharp
// 인덱스 생성 예제
await _db.Statement("CREATE INDEX idx_player_level_exp ON players(level DESC, experience DESC)");
```

### 5.8.2 쿼리 캐싱
자주 조회되지만 자주 변경되지 않는 데이터는 Redis를 사용해 캐싱하는 것이 좋다:

```csharp
public async Task<List<Player>> GetTopPlayersAsync(int limit = 10)
{
    var cacheKey = $"top_players:{limit}";
    
    // Redis에서 캐시된 결과 확인
    var cachedResult = await _redisCache.GetAsync<List<Player>>(cacheKey);
    if (cachedResult != null)
    {
        return cachedResult;
    }
    
    // 캐시에 없으면 데이터베이스에서 조회
    var players = await _db.Query("players")
        .OrderByDesc("level")
        .ThenByDesc("experience")
        .LimitAsync<Player>(limit);
    
    // 결과를 캐시에 저장 (1시간 만료)
    await _redisCache.SetAsync(cacheKey, players, TimeSpan.FromHours(1));
    
    return players;
}
```

### 5.8.3 배치 처리
여러 플레이어에게 보상 지급 같은 대량 작업은 배치 처리를 사용한다:

```csharp
public async Task<int> GiveRewardsToPlayersAsync(List<PlayerReward> rewards)
{
    // 배치 처리를 위한 트랜잭션 시작
    using var connection = new MySqlConnection(_connectionString);
    await connection.OpenAsync();
    using var transaction = await connection.BeginTransactionAsync();
    
    try
    {
        var factory = new QueryFactory(connection, new MySqlCompiler());
        factory.Transaction = transaction;
        
        int successCount = 0;
        
        foreach (var batch in rewards.Chunk(100)) // 100개씩 처리
        {
            var updateTasks = batch.Select(async reward =>
            {
                var affected = await factory.Query("players")
                    .Where("id", reward.PlayerId)
                    .IncrementAsync(new Dictionary<string, object>
                    {
                        { "gold", reward.Gold },
                        { "gems", reward.Gems },
                        { "experience", reward.Experience }
                    });
                    
                if (affected > 0)
                {
                    // 보상 지급 로그 기록
                    await factory.Query("reward_logs").InsertAsync(new
                    {
                        player_id = reward.PlayerId,
                        gold = reward.Gold,
                        gems = reward.Gems,
                        experience = reward.Experience,
                        reason = reward.Reason,
                        timestamp = DateTime.UtcNow
                    });
                    
                    return 1;
                }
                
                return 0;
            });
            
            var batchResults = await Task.WhenAll(updateTasks);
            successCount += batchResults.Sum();
        }
        
        await transaction.CommitAsync();
        return successCount;
    }
    catch
    {
        await transaction.RollbackAsync();
        throw;
    }
}
```
  

## 5.9 종합 예제: 게임 아이템 상점 시스템
마지막으로, MySqlConnector와 SqlKata를 활용한 게임 내 상점 시스템을 구현해보자.

### 5.9.1 상점 아이템 모델

```csharp
// Models/Shop/ShopItem.cs
public class ShopItem
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public string Type { get; set; }
    public string Rarity { get; set; }
    public int Price { get; set; }
    public string CurrencyType { get; set; } // "gold" 또는 "gems"
    public bool IsLimited { get; set; }
    public int? RemainingStock { get; set; }
    public DateTime? AvailableUntil { get; set; }
}

public class ShopItemResponse
{
    public bool Success { get; set; }
    public List<ShopItem> Items { get; set; }
    public string Message { get; set; }
}

public class PurchaseRequest
{
    public int PlayerId { get; set; }
    public int ShopItemId { get; set; }
    public int Quantity { get; set; } = 1;
}

public class PurchaseResponse
{
    public bool Success { get; set; }
    public Player UpdatedPlayer { get; set; }
    public List<PlayerItem> AcquiredItems { get; set; }
    public string Message { get; set; }
}
```

### 5.9.2 상점 리포지토리

```csharp
// Repositories/ShopRepository.cs
public class ShopRepository : IShopRepository
{
    private readonly QueryFactory _db;

    public ShopRepository(QueryFactory db)
    {
        _db = db;
    }

    public async Task<List<ShopItem>> GetAvailableItemsAsync()
    {
        var now = DateTime.UtcNow;
        
        return await _db.Query("shop_items")
            .Where(q => q
                .WhereNull("available_until")
                .OrWhere("available_until", ">", now))
            .Where(q => q
                .WhereNull("remaining_stock")
                .OrWhere("remaining_stock", ">", 0))
            .OrderBy("price")
            .GetAsync<ShopItem>();
    }

    public async Task<ShopItem> GetShopItemByIdAsync(int id)
    {
        return await _db.Query("shop_items")
            .Where("id", id)
            .FirstOrDefaultAsync<ShopItem>();
    }

    public async Task<bool> ReduceStockAsync(int shopItemId, int quantity)
    {
        var affected = await _db.Query("shop_items")
            .Where("id", shopItemId)
            .Where(q => q
                .WhereNull("remaining_stock")
                .OrWhere("remaining_stock", ">=", quantity))
            .DecrementAsync("remaining_stock", quantity);
            
        return affected > 0;
    }
}
```

### 5.9.3 상점 서비스

```csharp
// Services/ShopService.cs
public class ShopService : IShopService
{
    private readonly IShopRepository _shopRepository;
    private readonly IPlayerRepository _playerRepository;
    private readonly IPlayerItemRepository _playerItemRepository;
    private readonly ILogger<ShopService> _logger;

    public ShopService(
        IShopRepository shopRepository,
        IPlayerRepository playerRepository,
        IPlayerItemRepository playerItemRepository,
        ILogger<ShopService> logger)
    {
        _shopRepository = shopRepository;
        _playerRepository = playerRepository;
        _playerItemRepository = playerItemRepository;
        _logger = logger;
    }

    public async Task<(bool Success, List<ShopItem> Items, string Message)> GetShopItemsAsync()
    {
        try
        {
            var items = await _shopRepository.GetAvailableItemsAsync();
            return (true, items, null);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "상점 아이템을 조회하는 중 오류가 발생했습니다.");
            return (false, null, "상점 아이템을 조회하는 중 오류가 발생했습니다.");
        }
    }

    public async Task<(bool Success, Player UpdatedPlayer, List<PlayerItem> AcquiredItems, string Message)> PurchaseItemAsync(
        int playerId, int shopItemId, int quantity)
    {
        using var connection = new MySqlConnection(_connectionString);
        await connection.OpenAsync();
        using var transaction = await connection.BeginTransactionAsync();
        
        try
        {
            var factory = new QueryFactory(connection, new MySqlCompiler())
            {
                Transaction = transaction
            };
            
            // 1. 플레이어 정보 조회
            var player = await factory.Query("players")
                .Where("id", playerId)
                .FirstOrDefaultAsync<Player>();
                
            if (player == null)
            {
                await transaction.RollbackAsync();
                return (false, null, null, "플레이어를 찾을 수 없습니다.");
            }
            
            // 2. 상점 아이템 정보 조회
            var shopItem = await factory.Query("shop_items")
                .Where("id", shopItemId)
                .Where(q => q
                    .WhereNull("available_until")
                    .OrWhere("available_until", ">", DateTime.UtcNow))
                .FirstOrDefaultAsync<ShopItem>();
                
            if (shopItem == null)
            {
                await transaction.RollbackAsync();
                return (false, null, null, "해당 상점 아이템을 찾을 수 없거나 판매 기간이 종료되었습니다.");
            }
            
            // 3. 재고 확인
            if (shopItem.IsLimited && shopItem.RemainingStock.HasValue && shopItem.RemainingStock.Value < quantity)
            {
                await transaction.RollbackAsync();
                return (false, null, null, "상품의 재고가 부족합니다.");
            }
            
            // 4. 가격 계산
            int totalPrice = shopItem.Price * quantity;
            
            // 5. 플레이어 보유 화폐 확인
            if (shopItem.CurrencyType == "gold" && player.Gold < totalPrice)
            {
                await transaction.RollbackAsync();
                return (false, null, null, "골드가 부족합니다.");
            }
            else if (shopItem.CurrencyType == "gems" && player.Gems < totalPrice)
            {
                await transaction.RollbackAsync();
                return (false, null, null, "젬이 부족합니다.");
            }
            
            // 6. 화폐 차감
            if (shopItem.CurrencyType == "gold")
            {
                player.Gold -= totalPrice;
                await factory.Query("players")
                    .Where("id", playerId)
                    .DecrementAsync("gold", totalPrice);
            }
            else
            {
                player.Gems -= totalPrice;
                await factory.Query("players")
                    .Where("id", playerId)
                    .DecrementAsync("gems", totalPrice);
            }
            
            // 7. 재고 감소
            if (shopItem.IsLimited && shopItem.RemainingStock.HasValue)
            {
                await factory.Query("shop_items")
                    .Where("id", shopItemId)
                    .DecrementAsync("remaining_stock", quantity);
            }
            
            // 8. 아이템 지급
            var acquiredItems = new List<PlayerItem>();
            var now = DateTime.UtcNow;
            
            for (int i = 0; i < quantity; i++)
            {
                int playerItemId = await factory.Query("player_items").InsertGetIdAsync<int>(new
                {
                    player_id = playerId,
                    item_id = shopItem.Id,
                    acquired_at = now,
                    source = "shop_purchase"
                });
                
                acquiredItems.Add(new PlayerItem
                {
                    Id = playerItemId,
                    PlayerId = playerId,
                    ItemId = shopItem.Id,
                    AcquiredAt = now
                });
            }
            
            // 9. 구매 로그 기록
            await factory.Query("purchase_logs").InsertAsync(new
            {
                player_id = playerId,
                shop_item_id = shopItemId,
                quantity = quantity,
                total_price = totalPrice,
                currency_type = shopItem.CurrencyType,
                purchased_at = now
            });
            
            await transaction.CommitAsync();
            
            return (true, player, acquiredItems, "구매가 완료되었습니다.");
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _logger.LogError(ex, "아이템 구매 중 오류가 발생했습니다. PlayerId: {PlayerId}, ShopItemId: {ShopItemId}", playerId, shopItemId);
            return (false, null, null, "아이템 구매 중 오류가 발생했습니다.");
        }
    }
}
```

### 5.9.4 상점 컨트롤러

```csharp
// Controllers/ShopController.cs
[ApiController]
[Route("api/[controller]")]
public class ShopController : ControllerBase
{
    private readonly IShopService _shopService;

    public ShopController(IShopService shopService)
    {
        _shopService = shopService;
    }

    [HttpPost("items")]
    public async Task<ShopItemResponse> GetShopItems()
    {
        var (success, items, message) = await _shopService.GetShopItemsAsync();
        
        return new ShopItemResponse
        {
            Success = success,
            Items = items,
            Message = message
        };
    }

    [HttpPost("purchase")]
    public async Task<PurchaseResponse> PurchaseItem([FromBody] PurchaseRequest request)
    {
        if (request.Quantity <= 0)
        {
            return new PurchaseResponse
            {
                Success = false,
                Message = "구매 수량은 1개 이상이어야 합니다."
            };
        }
        
        var (success, player, items, message) = await _shopService.PurchaseItemAsync(
            request.PlayerId, 
            request.ShopItemId, 
            request.Quantity);
            
        return new PurchaseResponse
        {
            Success = success,
            UpdatedPlayer = player,
            AcquiredItems = items,
            Message = message
        };
    }
}
```

### 5.9.5 상점 HTTP 요청 테스트

```
### 상점 아이템 목록 조회
POST https://localhost:5001/api/shop/items
Content-Type: application/json

{}

### 아이템 구매
POST https://localhost:5001/api/shop/purchase
Content-Type: application/json

{
  "playerId": 1,
  "shopItemId": 3,
  "quantity": 1
}
```
  

## 5.10 정리

이 챕터에서는 ASP.NET Core Web API 게임 서버에서 MySQL 데이터베이스를 연동하는 방법을 살펴봤다. MySqlConnector와 SqlKata를 사용하여 데이터 액세스 계층을 구현하고, 수집형 RPG 게임에 필요한 여러 기능을 개발했다.

주요 내용:
- MySqlConnector를 사용한 MySQL 연결 및 쿼리 실행
- SqlKata를 활용한 타입 안전한 쿼리 빌더 패턴 구현
- 트랜잭션을 통한 데이터 일관성 유지
- 성능 최적화 기법
- 실제 게임 기능(플레이어 관리, 상점 시스템 등) 구현 예제

다음 챕터에서는 Redis를 사용한 캐싱과 실시간 기능 구현에 대해 알아볼 것이다.  
  

