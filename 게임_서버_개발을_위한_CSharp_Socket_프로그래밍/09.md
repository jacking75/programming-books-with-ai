# 게임 서버 개발을 위한 C# Socket 프로그래밍

저자: 최흥배, Claude AI  

- .NET 9
- Windows 11
- Visual Studio Code, Visual Studio 2022 이상


# 제4부: 실전 애플리케이션 개발  
  
# 9장: 채팅 서버 개발 

## 9.1 채팅 서버 아키텍처 설계
채팅 서버는 실시간 메시지 전달과 사용자 관리 기능을 갖춘 네트워크 애플리케이션의 핵심적인 예시입니다. 이번 장에서는 7장에서 만든 네트워크 라이브러리를 활용하여, 단일 워크 스레드 기반의 패킷 처리와 별도의 DB 처리 스레드를 갖춘 효율적인 채팅 서버를 구현하는 방법을 알아본다.

### 9.1.1 채팅 서버의 핵심 요구사항
1.  **사용자 관리**: 연결, 인증, 상태 관리
2.  **채널 관리**: 채팅방 생성, 참여, 퇴장
3.  **메시지 처리**: 수신, 필터링, 브로드캐스팅
4.  **데이터 지속성**: 메시지 기록, 사용자 정보 저장
5.  **성능과 안정성**: 다수의 동시 접속자를 안정적으로 처리

### 9.1.2 아키텍처 개요
이번에 설계할 아키텍처는 명확한 역할 분담을 통해 코드의 복잡성을 낮추고 안정성을 높이는 데 중점을 둔다.

  * **메인 스레드**: 서버를 시작하고 종료하며, 핵심 스레드들을 관리한다.
  * **네트워크 스레드**: `TcpListener`가 클라이언트의 연결을 수락하고 각 클라이언트에 대한 세션을 생성한다. 각 세션은 자체 스레드에서 메시지를 수신한다.
  * **패킷 처리 스레드 (Worker Thread)**: 모든 클라이언트 세션으로부터 받은 패킷을 **단 하나의 스레드**에서 순차적으로 처리한다. 모든 게임 로직과 상태 변경은 이 스레드에서만 발생하여 동시성 문제를 원천적으로 방지한다.
  * **DB 스레드**: 데이터베이스와 관련된 모든 작업(조회, 저장 등)을 전담하는 별도의 스레드이다. 패킷 처리 스레드로부터 요청을 받아 처리하고, 그 결과를 다시 내부 패킷으로 만들어 패킷 처리 큐에 전달한다.  
  
이 구조의 핵심은 각 스레드가 **Blocking Queue(큐)**를 통해 통신하는 것이다. 네트워크 스레드는 수신한 데이터를 '패킷 큐'에 넣고, 패킷 처리 스레드는 이 큐에서 데이터를 꺼내 처리한다. DB 작업이 필요하면 'DB 요청 큐'에 작업을 넣고, DB 스레드는 처리 후 결과를 다시 '패킷 큐'로 전달한다.  
  
### 9.1.3 코드 구조 설계
이 아키텍처를 코드로 구현하면 다음과 같은 모습이 된다. `Thread`와 `BlockingCollection`을 사용한다.  
  
```csharp
// ChatServer/Program.cs
using ChatServer;
using NetServerLib;

class Program
{
    static void Main(string[] args)
    {
        var server = new ChattingServer();
        server.Start();

        Console.WriteLine("Server Started. Press ENTER to stop.");
        Console.ReadLine();

        server.Stop();
    }
}
```

```csharp
// ChatServer/ChattingServer.cs
public class ChattingServer
{
    private readonly PacketProcessor _packetProcessor;
    private readonly TcpNetworkServer _networkServer;
    private readonly PacketHandler _packetHandler;
    private readonly DBHandler _dbHandler;
    private Thread _packetWorkThread;
    private Thread _dbWorkThread;

    public ChattingServer()
    {
        _packetProcessor = new PacketProcessor();
        _dbHandler = new DBHandler();
        _packetHandler = new PacketHandler(_packetProcessor, _dbHandler);
        
        // 네트워크 서버 생성 시, 패킷을 직접 처리하지 않고 PacketHandler의 큐에 넣는 람다 함수를 전달
        _networkServer = new TcpNetworkServer(
            () => new LengthPrefixedMessageFramer(),
            _packetProcessor,
            (session, data) => _packetHandler.EnqueuePacket(session, data)
        );

        RegisterPacketHandlers();
    }

    public void Start()
    {
        // DB 스레드 시작
        _dbWorkThread = new Thread(_dbHandler.Process);
        _dbWorkThread.Start();

        // 패킷 처리 스레드 시작
        _packetWorkThread = new Thread(_packetHandler.Process);
        _packetWorkThread.Start();

        // 네트워크 서버 시작 (내부적으로 Accept 스레드 동작)
        _networkServer.Start(7777);
    }
    
    // ... Stop 및 핸들러 등록 로직 ...
}
```

-----

## 9.2 패킷 처리 및 DB 연동 구현

### 9.2.1 단일 스레드 패킷 처리
`PacketHandler` 클래스는 서버의 심장부 역할을 한다. `BlockingCollection`을 사용해 스레드로부터 안전한 큐를 만들고, 단일 스레드에서 이 큐의 패킷을 무한 루프로 처리한다.  

```csharp
// ChatServer/PacketHandler.cs
public class PacketHandler
{
    // (세션, 패킷 데이터) 튜플을 저장하는 큐
    private readonly BlockingCollection<(ISession, byte[])> _packetQueue = new();
    private readonly PacketProcessor _packetProcessor;
    private readonly DBHandler _dbHandler;

    public PacketHandler(PacketProcessor packetProcessor, DBHandler dbHandler)
    {
        _packetProcessor = packetProcessor;
        _dbHandler = dbHandler;
    }

    public void EnqueuePacket(ISession session, byte[] data)
    {
        _packetQueue.Add((session, data));
    }

    // 패킷 처리 스레드에서 실행될 메인 루프
    public void Process()
    {
        while (true)
        {
            var (session, data) = _packetQueue.Take(); // 큐에 아이템이 올 때까지 대기
            try
            {
                // 패킷 데이터를 역직렬화하고 등록된 핸들러를 호출
                _packetProcessor.ProcessPacket(data, session);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Packet processing error: {ex.Message}");
            }
        }
    }
}
```

### 9.2.2 별도 스레드를 이용한 DB 처리
`DBHandler` 클래스는 데이터베이스 작업을 전담한다. `PacketHandler`와 마찬가지로 `BlockingCollection`을 작업 큐로 사용한다. DB 작업이 끝나면, 그 결과를 `InternalPacket` 형태로 만들어 다시 `PacketHandler`의 큐로 보낸다.

```csharp
// ChatServer/DBHandler.cs
public class DBHandler
{
    // DB 작업을 정의하는 Action 델리게이트를 저장하는 큐
    private readonly BlockingCollection<Action> _dbRequestQueue = new();

    public void EnqueueRequest(Action request)
    {
        _dbRequestQueue.Add(request);
    }

    // DB 스레드에서 실행될 메인 루프
    public void Process()
    {
        // 실제 DB 커넥션은 여기서 초기화
        // var dbConnection = new MySqlConnection("...");
        // dbConnection.Open();

        while (true)
        {
            var request = _dbRequestQueue.Take();
            try
            {
                request(); // 큐에서 꺼낸 DB 작업 실행
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DB processing error: {ex.Message}");
            }
        }
    }
}

// 사용 예시 (PacketHandler 내부)
public void HandleLoginRequest(LoginRequestPacket packet, ISession session)
{
    // DB 스레드에 작업 요청
    _dbHandler.EnqueueRequest(() =>
    {
        // DB에서 사용자 인증 처리
        bool loginSuccess = AuthenticateUserFromDB(packet.Username, packet.Password);
        
        // 결과를 내부 패킷으로 만들어 다시 패킷 큐에 넣음
        var resultPacket = new InternalLoginResult { Success = loginSuccess, SessionId = session.Id };
        EnqueuePacket(session, _packetProcessor.SerializePacket(resultPacket));
    });
}
```

이 구조를 통해 DB 작업이 패킷 처리를 막지 않으면서도, 모든 상태 변경은 `PacketHandler`의 단일 스레드에서 순차적으로 일어나 데이터 정합성을 보장한다.

-----

## 9.3 채팅 서버 전체 코드
이제 위 아키텍처에 따라 완성된 전체 코드를 제공한다. 프로젝트는 **`NetServerLib`** 라이브러리 프로젝트와 **`ChatServer`** 실행 프로젝트로 구성된다.

### `ChatServer` 프로젝트 코드
채팅 서버의 로직을 담당하는 코드이다.

#### **`ChatServer.csproj`**
`NetServerLib` 프로젝트를 참조하도록 설정한다.  

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\NetServerLib\NetServerLib.csproj" />
  </ItemGroup>
</Project>
```

#### **`Program.cs`**

```csharp
// ChatServer/Program.cs
using ChatServer;

class Program
{
    static void Main(string[] args)
    {
        var server = new ChattingServer();
        server.Start();

        Console.WriteLine("Server Started. Press ENTER to stop.");
        Console.ReadLine();

        server.Stop();
    }
}
```

#### **`Packets.cs`**
클라이언트와 서버가 주고받을 패킷들을 정의한다.  
  
```csharp
// ChatServer/Packets.cs
using NetServerLib;
using System.IO;

namespace ChatServer.Packets
{
    // C -> S : 채팅 메시지 요청
    public class ChatReq : IPacket
    {
        public ushort Id => 101;
        public string Message { get; set; }

        public void Serialize(BinaryWriter writer) => writer.Write(Message ?? "");
        public void Deserialize(BinaryReader reader) => Message = reader.ReadString();
    }

    // S -> C : 채팅 메시지 브로드캐스트
    public class ChatNtf : IPacket
    {
        public ushort Id => 102;
        public string SenderInfo { get; set; }
        public string Message { get; set; }

        public void Serialize(BinaryWriter writer)
        {
            writer.Write(SenderInfo ?? "");
            writer.Write(Message ?? "");
        }
        public void Deserialize(BinaryReader reader)
        {
            SenderInfo = reader.ReadString();
            Message = reader.ReadString();
        }
    }

    // C -> S : DB 조회 요청 (예시)
    public class UserInfoReq : IPacket
    {
        public ushort Id => 201;
        public string UserId { get; set; }
        
        public void Serialize(BinaryWriter writer) => writer.Write(UserId ?? "");
        public void Deserialize(BinaryReader reader) => UserId = reader.ReadString();
    }
    
    // S -> C : DB 조회 결과 (내부 패킷)
    // 이 패킷은 클라이언트로 직접 가지 않고, PacketHandler 내부에서만 사용됨
    public class InternalUserInfoRes : IPacket
    {
        public ushort Id => 202;
        public Guid ResponseSessionId { get; set; } // 응답을 받을 세션
        public bool Found { get; set; }
        public string UserNickname { get; set; }

        public void Serialize(BinaryWriter writer)
        {
            writer.Write(ResponseSessionId.ToByteArray());
            writer.Write(Found);
            writer.Write(UserNickname ?? "");
        }

        public void Deserialize(BinaryReader reader)
        {
            ResponseSessionId = new Guid(reader.ReadBytes(16));
            Found = reader.ReadBoolean();
            UserNickname = reader.ReadString();
        }
    }
}
```

#### **`ChattingServer.cs`**
서버의 전체적인 흐름을 관리하는 메인 클래스이다.

```csharp
// ChatServer/ChattingServer.cs
using System.Collections.Concurrent;
using ChatServer.Packets;
using NetServerLib;

namespace ChatServer;

public class ChattingServer
{
    private readonly PacketProcessor _packetProcessor;
    private readonly TcpNetworkServer _networkServer;
    private readonly PacketHandler _packetHandler;
    private readonly DBHandler _dbHandler;
    private readonly UserManager _userManager = new();

    private Thread _packetWorkThread;
    private Thread _dbWorkThread;
    private bool _isRunning = false;

    public ChattingServer()
    {
        _packetProcessor = new PacketProcessor();
        _dbHandler = new DBHandler(_packetProcessor, EnqueuePacketFromAnotherThread);
        _packetHandler = new PacketHandler(_packetProcessor, _dbHandler, _userManager);

        _networkServer = new TcpNetworkServer(
            () => new LengthPrefixedMessageFramer(),
            _packetProcessor,
            _packetHandler.EnqueuePacket
        );

        _networkServer.SessionConnected += _userManager.OnSessionConnected;
        _networkServer.SessionDisconnected += _userManager.OnSessionDisconnected;

        RegisterPackets();
        RegisterPacketHandlers();
    }

    // DB 스레드 등 다른 스레드에서 패킷 큐에 작업을 넣을 때 사용
    private void EnqueuePacketFromAnotherThread(ISession session, IPacket packet)
    {
        byte[] data = _packetProcessor.SerializePacket(packet);
        _packetHandler.EnqueuePacket(session, data);
    }

    private void RegisterPackets()
    {
        _packetProcessor.RegisterPacket<ChatReq>();
        _packetProcessor.RegisterPacket<ChatNtf>();
        _packetProcessor.RegisterPacket<UserInfoReq>();
        _packetProcessor.RegisterPacket<InternalUserInfoRes>();
    }

    private void RegisterPacketHandlers()
    {
        // 채팅 요청 처리
        _packetProcessor.RegisterPacketHandler<ChatReq>((packet, session) =>
        {
            _packetHandler.HandleChatReq(packet, session);
        });
        
        // DB 조회 요청 처리
        _packetProcessor.RegisterPacketHandler<UserInfoReq>((packet, session) =>
        {
            _packetHandler.HandleUserInfoReq(packet, session);
        });

        // DB 조회 결과(내부 패킷) 처리
        _packetProcessor.RegisterPacketHandler<InternalUserInfoRes>((packet, session) =>
        {
            _packetHandler.HandleInternalUserInfoRes(packet, session);
        });
    }

    public void Start()
    {
        _isRunning = true;
        _dbWorkThread = new Thread(_dbHandler.Process);
        _dbWorkThread.Start();

        _packetWorkThread = new Thread(_packetHandler.Process);
        _packetWorkThread.Start();
        
        _networkServer.Start(7777);
    }

    public void Stop()
    {
        if (!_isRunning) return;
        _isRunning = false;

        _packetHandler.Stop();
        _dbHandler.Stop();

        _packetWorkThread?.Join();
        _dbWorkThread?.Join();

        _networkServer.Stop();
    }
}
```

#### **`PacketHandler.cs`**
패킷을 순차적으로 처리하는 워크 스레드의 로직이다.  
  
```csharp
// ChatServer/PacketHandler.cs
using System.Collections.Concurrent;
using ChatServer.Packets;
using NetServerLib;

namespace ChatServer;

public class PacketHandler
{
    private readonly BlockingCollection<(ISession, byte[])> _packetQueue = new();
    private readonly PacketProcessor _packetProcessor;
    private readonly DBHandler _dbHandler;
    private readonly UserManager _userManager;

    public PacketHandler(PacketProcessor packetProcessor, DBHandler dbHandler, UserManager userManager)
    {
        _packetProcessor = packetProcessor;
        _dbHandler = dbHandler;
        _userManager = userManager;
    }

    public void EnqueuePacket(ISession session, byte[] data)
    {
        if (!_packetQueue.IsAddingCompleted)
        {
            _packetQueue.Add((session, data));
        }
    }

    public void Process()
    {
        while (!_packetQueue.IsCompleted)
        {
            try
            {
                var (session, data) = _packetQueue.Take();
                _packetProcessor.ProcessPacket(data, session);
            }
            catch (InvalidOperationException)
            {
                // 큐가 닫혔을 때 Take()에서 예외 발생, 루프 종료
                break;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Packet processing error: {ex.Message}");
            }
        }
    }

    public void Stop()
    {
        _packetQueue.CompleteAdding();
    }

    // 실제 패킷 처리 로직
    public void HandleChatReq(ChatReq packet, ISession session)
    {
        var user = _userManager.GetUser(session.Id);
        if (user == null) return;
        
        Console.WriteLine($"Received from {user.Name}: {packet.Message}");

        var broadcastPacket = new ChatNtf
        {
            SenderInfo = user.Name,
            Message = packet.Message
        };

        foreach (var otherUser in _userManager.GetAllUsers())
        {
            otherUser.Session.Send(broadcastPacket);
        }
    }
    
    public void HandleUserInfoReq(UserInfoReq packet, ISession session)
    {
        Console.WriteLine($"Received user info request for {packet.UserId}");
        _dbHandler.EnqueueRequest(() =>
        {
            // DB에서 사용자 정보 조회 시뮬레이션
            Thread.Sleep(500); // DB I/O 지연 흉내
            var found = packet.UserId == "test";
            var nickname = found ? "TestUserNickname" : "Unknown";
            
            // 결과를 내부 패킷으로 만들어 콜백을 통해 패킷 큐에 다시 넣음
            var resultPacket = new InternalUserInfoRes
            {
                ResponseSessionId = session.Id,
                Found = found,
                UserNickname = nickname
            };
            _dbHandler.EnqueueResult(session, resultPacket);
        });
    }
    
    public void HandleInternalUserInfoRes(InternalUserInfoRes packet, ISession originalSession)
    {
        var user = _userManager.GetUser(packet.ResponseSessionId);
        if (user == null) return;
        
        Console.WriteLine($"Sending DB result to {user.Name}");
        
        var responsePacket = new ChatNtf
        {
            SenderInfo = "SYSTEM",
            Message = packet.Found
                ? $"User found. Nickname: {packet.UserNickname}"
                : "User not found."
        };
        
        user.Session.Send(responsePacket);
    }
}
```

#### **`DBHandler.cs`**
DB 작업을 처리하는 스레드의 로직이다.   
  
```csharp
// ChatServer/DBHandler.cs
using System.Collections.Concurrent;
using NetServerLib;

namespace ChatServer;

public class DBHandler
{
    private readonly BlockingCollection<Action> _dbRequestQueue = new();
    private readonly PacketProcessor _packetProcessor;
    
    // DB 처리 결과를 다시 PacketHandler로 보내기 위한 콜백
    public Action<ISession, IPacket> EnqueueResult { get; }

    public DBHandler(PacketProcessor packetProcessor, Action<ISession, IPacket> enqueueResultCallback)
    {
        _packetProcessor = packetProcessor;
        EnqueueResult = enqueueResultCallback;
    }

    public void EnqueueRequest(Action request)
    {
        if (!_dbRequestQueue.IsAddingCompleted)
        {
            _dbRequestQueue.Add(request);
        }
    }

    public void Process()
    {
        // 실제 DB 커넥션은 여기에...
        
        while (!_dbRequestQueue.IsCompleted)
        {
            try
            {
                var request = _dbRequestQueue.Take();
                request();
            }
            catch (InvalidOperationException)
            {
                break; // 큐가 닫힘
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DB processing error: {ex.Message}");
            }
        }
    }

    public void Stop()
    {
        _dbRequestQueue.CompleteAdding();
    }
}
```

#### **`User.cs` & `UserManager.cs`**
연결된 사용자의 상태를 관리하는 클래스이다.

```csharp
// ChatServer/User.cs
using NetServerLib;

namespace ChatServer;

public class User
{
    public ISession Session { get; }
    public string Name { get; }

    public User(ISession session)
    {
        Session = session;
        Name = $"User-{session.Id.ToString().Substring(0, 4)}";
    }
}
```

```csharp
// ChatServer/UserManager.cs
using System.Collections.Concurrent;
using NetServerLib;

namespace ChatServer;

public class UserManager
{
    private readonly ConcurrentDictionary<Guid, User> _users = new();

    public void OnSessionConnected(ISession session)
    {
        var user = new User(session);
        _users.TryAdd(session.Id, user);
        Console.WriteLine($"{user.Name} connected.");
    }

    public void OnSessionDisconnected(ISession session)
    {
        if (_users.TryRemove(session.Id, out var user))
        {
            Console.WriteLine($"{user.Name} disconnected.");
        }
    }

    public User GetUser(Guid sessionId)
    {
        _users.TryGetValue(sessionId, out var user);
        return user;
    }
    
    public IEnumerable<User> GetAllUsers()
    {
        return _users.Values;
    }
}
```  
  
  
    
## 9.4 학습 확인 과제
채팅 서버 개발에 대한 학습 내용을 실습하기 위한 과제를 제공한다.

### 과제 1: 기본 채팅 서버 구현
다음 요구사항을 충족하는 간단한 채팅 서버를 구현하세요:

1. TCP 소켓 기반 채팅 서버 구현
2. 사용자 인증 (로그인/로그아웃) 기능
3. 채널 생성 및 참여 기능
4. 채널 내 메시지 브로드캐스팅
5. 1:1 개인 메시지 전송

**평가 기준:**
- 코드 구조 및 설계 품질
- 비동기 처리 적용 여부
- 오류 처리 완성도
- 기능 동작 정확성

### 과제 2: 고급 채팅 서버 기능 확장
기본 채팅 서버에 다음 고급 기능을 추가하세요:

1. 메시지 필터링 (부적절한 단어 필터링)
2. 파일 전송 기능
3. 메시지 이력 조회 기능
4. 사용자 상태 관리 (온라인, 오프라인, 자리비움 등)
5. 채널 권한 관리 (관리자, 일반 사용자)

**구현 조건:**
- 데이터베이스 연동 (Entity Framework Core 사용)
- 메시지 큐를 활용한 처리 최적화
- 단위 테스트 작성
- 성능 측정 및 최적화 보고서 작성

### 과제 3: 웹소켓 기반 채팅 서버 구현
WebSocket 프로토콜을 사용한 채팅 서버를 구현하세요:

1. WebSocket 기반 통신 구현
2. JSON 메시지 포맷 정의
3. ASP.NET Core SignalR 활용
4. 간단한 웹 클라이언트 구현

**평가 포인트:**
- WebSocket 프로토콜 이해도
- 실시간 양방향 통신 구현 능력
- 클라이언트-서버 통신 설계
- 확장성 고려 여부

### 과제 4: 실시간 채팅 애플리케이션 프로젝트
팀 프로젝트로 완전한 채팅 애플리케이션을 개발하세요:

1. 서버 애플리케이션: .NET 9.0 기반 채팅 서버
2. 클라이언트 애플리케이션: 콘솔 또는 WPF UI
3. 기능 요구사항:
   - 사용자 관리 (등록, 로그인, 프로필)
   - 채널 관리 (생성, 참여, 퇴장)
   - 메시지 전송 (텍스트, 이모티콘, 파일)
   - 알림 기능 (멘션, 새 메시지)
   - 관리자 기능 (사용자 관리, 채널 관리)

**제출물:**
- 소스 코드 및 실행 파일
- 설계 문서 (아키텍처, 클래스 다이어그램)
- 테스트 결과 보고서
- 사용자 매뉴얼
  

## 요약
이번 장에서는 채팅 서버의 기본 아키텍처부터 구현까지 전반적인 내용을 다뤘다. 채팅 서버 개발에서 가장 중요한 부분은 다음과 같다:

1. **모듈화된 설계**: 네트워크, 사용자, 채널, 메시지 처리 등 주요 컴포넌트를 분리하여 관리
2. **효율적인 메시지 처리**: 메시지 브로드캐스팅 최적화 및 비동기 처리 적용
3. **상태 관리**: 사용자 및 채널 상태 관리와 데이터 지속성 구현
4. **확장성 고려**: 대규모 사용자를 처리할 수 있는 아키텍처 설계

다음 장에서는 이번 장에서 배운 채팅 서버 구현 기술을 응용하여 오목 게임 서버를 구현하는 방법을 알아볼 것이다.
