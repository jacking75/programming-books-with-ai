# ê²Œì„ ì„œë²„ ê°œë°œì„ ìœ„í•œ C# Socket í”„ë¡œê·¸ë˜ë°

ì €ì: ìµœí¥ë°°, Claude AI  

- .NET 9
- Windows 11
- Visual Studio Code, Visual Studio 2022 ì´ìƒ
  
-----  
  
# 10ì¥. `SocketAsyncEventArgs` (EAP) ëª¨ë¸ ì‹¬í™”
.NET Framework 3.5ì—ì„œëŠ” ê³ ì„±ëŠ¥ ë° ê³ í™•ì¥ì„±(High Scalability) ë„¤íŠ¸ì›Œí¬ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ìœ„í•´ **`System.Net.Sockets.SocketAsyncEventArgs` í´ë˜ìŠ¤ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ í•˜ëŠ” ìƒˆë¡œìš´ ì†Œì¼“ API ì„¸íŠ¸**ê°€ ë„ì…ë˜ì—ˆë‹¤.   
ì´ì „ì˜ `Begin/End` ë°©ì‹(ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ëª¨ë¸, APM)ì— ë¹„í•´ ì„±ëŠ¥ì´ í¬ê²Œ í–¥ìƒë˜ì—ˆìœ¼ë©°, íŠ¹íˆ ëŒ€ê·œëª¨ ë™ì‹œ ì ‘ì†ì„ ì²˜ë¦¬í•˜ëŠ” ì„œë²„ ê°œë°œì— ìµœì í™”ë˜ì–´ ìˆë‹¤.
  
## SocketAsyncEventArgsë€?
**SocketAsyncEventArgs**ëŠ” .NET Frameworkì—ì„œ ì œê³µí•˜ëŠ” **Event-based Asynchronous Pattern (EAP)** ëª¨ë¸ì„ êµ¬í˜„í•œ í´ë˜ìŠ¤ì´ë‹¤. ê³ ì„±ëŠ¥ ë„¤íŠ¸ì›Œí¬ ì„œë²„ ê°œë°œì—ì„œ **ìŠ¤ë ˆë“œ í’€ ê³ ê°ˆ ë¬¸ì œ**ë¥¼ í•´ê²°í•˜ê³  **ë©”ëª¨ë¦¬ í• ë‹¹ì„ ìµœì†Œí™”**í•˜ê¸° ìœ„í•´ ì„¤ê³„ë˜ì—ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SocketAsyncEventArgs                     â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Buffer    â”‚    â”‚ UserToken   â”‚    â”‚ Completed   â”‚      â”‚
â”‚  â”‚   Pool      â”‚    â”‚   Object    â”‚    â”‚   Event     â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚SocketError  â”‚    â”‚LastOperationâ”‚    â”‚BytesTransferâ”‚      â”‚
â”‚  â”‚             â”‚    â”‚             â”‚    â”‚    red      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ¯ í•µì‹¬ íŠ¹ì§•
1. **ê°ì²´ ì¬ì‚¬ìš©**: SAEA ê°ì²´ë¥¼ í’€ë§í•˜ì—¬ ë©”ëª¨ë¦¬ í• ë‹¹/í•´ì œ ì˜¤ë²„í—¤ë“œ ì œê±°
2. **ì´ë²¤íŠ¸ ê¸°ë°˜**: ì½œë°± ë°©ì‹ìœ¼ë¡œ ë¹„ë™ê¸° ì™„ë£Œ í†µì§€
3. **Zero-copy**: ë²„í¼ë¥¼ ë¯¸ë¦¬ í• ë‹¹í•˜ê³  ì¬ì‚¬ìš©
4. **ìŠ¤ë ˆë“œ íš¨ìœ¨ì„±**: I/O ì™„ë£Œ í¬íŠ¸(IOCP) í™œìš©ìœ¼ë¡œ ìŠ¤ë ˆë“œ ì‚¬ìš©ëŸ‰ ìµœì†Œí™”

---

## EAP vs ê¸°ì¡´ ë°©ì‹ ë¹„êµ

```mermaid
graph TB
    subgraph "ì „í†µì ì¸ Thread-per-Connection"
        A[Client 1] --> B[Thread 1]
        C[Client 2] --> D[Thread 2]
        E[Client 3] --> F[Thread 3]
        G[Client N] --> H[Thread N]
        I[1000 Clients] --> J[1000 Threads = Memory Crash!]
    end
    
    subgraph "SocketAsyncEventArgs Pattern"
        K[Client 1] --> M[SAEA Pool]
        L[Client 2] --> M
        N[Client 3] --> M
        O[Client N] --> M
        P[1000+ Clients] --> Q[Small Thread Pool + IOCP]
    end
```

### ğŸ“Š ì„±ëŠ¥ ë¹„êµ

| ë°©ì‹ | ìŠ¤ë ˆë“œ ìˆ˜ | ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ | ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ | í™•ì¥ì„± |
|------|-----------|---------------|----------------|--------|
| Thread-per-Connection | Nê°œ í´ë¼ì´ì–¸íŠ¸ = Nê°œ ìŠ¤ë ˆë“œ | ë†’ìŒ (ê° ìŠ¤ë ˆë“œë‹¹ 1MB) | ë§¤ìš° ë†’ìŒ | ì œí•œì  (~100-200 ë™ì‹œì ‘ì†) |
| SocketAsyncEventArgs | ê³ ì •ëœ ì ì€ ìˆ˜ | ë‚®ìŒ (ë²„í¼ í’€ë§) | ë‚®ìŒ | ë†’ìŒ (10,000+ ë™ì‹œì ‘ì†) |

---

## API ì„¤ëª… ë° ì‚¬ìš©ë²•

### ğŸ”§ ì£¼ìš” ì†ì„± ë° ë©”ì„œë“œ

```csharp
public class SocketAsyncEventArgs : EventArgs, IDisposable
{
    // í•µì‹¬ ì†ì„±ë“¤
    public byte[] Buffer { get; }           // ë°ì´í„° ë²„í¼
    public int Offset { get; set; }         // ë²„í¼ ì‹œì‘ ì˜¤í”„ì…‹
    public int Count { get; set; }          // ì²˜ë¦¬í•  ë°”ì´íŠ¸ ìˆ˜
    public int BytesTransferred { get; }    // ì‹¤ì œ ì „ì†¡ëœ ë°”ì´íŠ¸ ìˆ˜
    public SocketError SocketError { get; } // ì†Œì¼“ ì—ëŸ¬ ìƒíƒœ
    public object UserToken { get; set; }   // ì‚¬ìš©ì ì •ì˜ ë°ì´í„°
    public Socket AcceptSocket { get; set; } // Accept ì‹œ ì—°ê²°ëœ ì†Œì¼“
    public SocketAsyncOperation LastOperation { get; } // ë§ˆì§€ë§‰ ìˆ˜í–‰ ì‘ì—…
    
    // í•µì‹¬ ì´ë²¤íŠ¸
    public event EventHandler<SocketAsyncEventArgs> Completed;
    
    // í•µì‹¬ ë©”ì„œë“œ
    public void SetBuffer(byte[] buffer, int offset, int count);
    public void SetBuffer(int offset, int count);
    public void Dispose();
}
```

### ğŸ”„ ê¸°ë³¸ ì‚¬ìš© íŒ¨í„´

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   SAEA ì‚¬ìš© íŒ¨í„´                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   1. SAEA ê°ì²´ ìƒì„±      â”‚
              â”‚      ë° ì´ˆê¸°í™”           â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   2. ë²„í¼ ì„¤ì • ë°        â”‚
              â”‚   Completed ì´ë²¤íŠ¸ ë“±ë¡  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   3. ë¹„ë™ê¸° ì‘ì—… ì‹œì‘     â”‚
              â”‚   (AcceptAsync,         â”‚
              â”‚    ReceiveAsync ë“±)     â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   4. ê²°ê³¼ í™•ì¸          â”‚
              â”‚   (true = ë¹„ë™ê¸° ì§„í–‰,  â”‚
              â”‚    false = ì¦‰ì‹œ ì™„ë£Œ)   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚              â”‚
                false â”‚              â”‚ true
                     â–¼              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   ì¦‰ì‹œ ê²°ê³¼ ì²˜ë¦¬     â”‚     â”‚  Completed ì´ë²¤íŠ¸ â”‚
    â”‚   ProcessXXX() í˜¸ì¶œ  â”‚    â”‚  ì½œë°±ì—ì„œ ì²˜ë¦¬     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚              â”‚
                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                            â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   5. SAEA ê°ì²´ í’€ë¡œ      â”‚
              â”‚      ë°˜í™˜ ë˜ëŠ” ì¬ì‚¬ìš©     â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ì½”ë“œ ìƒì„¸ ë¶„ì„

### ì „ì²´ ì•„í‚¤í…ì²˜

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚           TcpNetworkServer          â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
                    â”‚  â”‚     SAEA Pool Manager       â”‚    â”‚
                    â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
                    â”‚  â”‚  â”‚ Accept  â”‚ â”‚ Receive â”‚    â”‚    â”‚
                    â”‚  â”‚  â”‚  Pool   â”‚ â”‚  Pool   â”‚    â”‚    â”‚
                    â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                 â”‚                 â”‚
                    â–¼                 â–¼                 â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   TcpSession    â”‚ â”‚   TcpSession    â”‚ â”‚   TcpSession    â”‚
        â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚
        â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
        â”‚ â”‚MessageFramerâ”‚ â”‚ â”‚ â”‚MessageFramerâ”‚ â”‚ â”‚ â”‚MessageFramerâ”‚ â”‚
        â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                 â”‚                 â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ PacketProcessor â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ” í•µì‹¬ êµ¬ì„± ìš”ì†Œ ë¶„ì„

#### 1. **TcpNetworkServer** - SAEA í’€ ê´€ë¦¬ì

```csharp
public class TcpNetworkServer : INetworkServer
{
    // SocketAsyncEventArgs ê°ì²´ë“¤ì„ ì¬ì‚¬ìš©í•˜ê¸° ìœ„í•œ í’€
    private readonly Stack<SocketAsyncEventArgs> _acceptEventArgsPool;
    private readonly Stack<SocketAsyncEventArgs> _receiveEventArgsPool;
```

**ğŸ’¡ í•µì‹¬ ì•„ì´ë””ì–´**: 
- `Stack<T>`ì„ ì‚¬ìš©í•˜ì—¬ SAEA ê°ì²´ë¥¼ í’€ë§
- `Accept`ìš©ê³¼ `Receive`ìš©ì„ ë¶„ë¦¬í•˜ì—¬ ê´€ë¦¬
- ì„œë²„ ì‹œì‘ ì‹œ ë¯¸ë¦¬ ëª¨ë“  SAEA ê°ì²´ë¥¼ ìƒì„±

```
Stack<SocketAsyncEventArgs> Pool:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚SAEA3â”‚  â”‚SAEA2â”‚  â”‚SAEA1â”‚ â† Topâ”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–²         â–²         â–²
      â”‚         â”‚         â”‚
   Push()    Push()    Pop()
  (ë°˜í™˜)     (ë°˜í™˜)    (ì‚¬ìš©)
```

#### 2. **Accept ì²˜ë¦¬ ê³¼ì •**

```csharp
private void StartAccept(SocketAsyncEventArgs acceptEventArg)
{
    if (acceptEventArg == null)
    {
        // í’€ì—ì„œ Accept SAEAë¥¼ ê°€ì ¸ì˜´
        if (!_acceptEventArgsPool.TryPop(out acceptEventArg))
        {
            Console.WriteLine("Warning: No available SocketAsyncEventArgs for accept operation.");
            return;
        }
    }
    else
    {
        // ì¬ì‚¬ìš©ì„ ìœ„í•´ ì´ì „ ì†Œì¼“ ì •ë³´ ì´ˆê¸°í™”
        acceptEventArg.AcceptSocket = null;
    }

    try
    {
        bool willRaiseEvent = _listenSocket.AcceptAsync(acceptEventArg);
        if (!willRaiseEvent)
        {
            ProcessAccept(acceptEventArg);
        }
    }
    catch (ObjectDisposedException) { /* ì„œë²„ê°€ ë©ˆì¶”ëŠ” ì¤‘ */ }
    catch (Exception ex)
    {
        Console.WriteLine($"Error starting accept: {ex.Message}");
    }
}
```

**ğŸ¯ Accept í”Œë¡œìš° ì°¨íŠ¸**:

```mermaid
flowchart TD
    A[í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìš”ì²­] --> B{SAEA í’€ì—ì„œ<br/>ê°ì²´ ê°€ì ¸ì˜¤ê¸°}
    B -->|ì„±ê³µ| C[AcceptSocket ì´ˆê¸°í™”]
    B -->|ì‹¤íŒ¨| D[ê²½ê³  ë©”ì‹œì§€ ì¶œë ¥ í›„ ì¢…ë£Œ]
    C --> E[ListenSocket.AcceptAsync í˜¸ì¶œ]
    E --> F{ì¦‰ì‹œ ì™„ë£Œ?}
    F -->|false<br/>ì¦‰ì‹œ ì™„ë£Œ| G[ProcessAccept ì§ì ‘ í˜¸ì¶œ]
    F -->|true<br/>ë¹„ë™ê¸° ì§„í–‰| H[Completed ì´ë²¤íŠ¸ ëŒ€ê¸°]
    H --> I[AcceptEventArg_Completed í˜¸ì¶œ]
    G --> J[ProcessAccept ì‹¤í–‰]
    I --> J
    J --> K{ì—°ê²° ì„±ê³µ?}
    K -->|ì„±ê³µ| L[ìƒˆ TcpSession ìƒì„±]
    K -->|ì‹¤íŒ¨| M[ì—ëŸ¬ ë¡œê·¸ ì¶œë ¥]
    L --> N[ì„¸ì…˜ì„ ë”•ì…”ë„ˆë¦¬ì— ì¶”ê°€]
    N --> O[Receiveìš© SAEA í• ë‹¹]
    O --> P[StartReceive í˜¸ì¶œ]
    M --> Q[ë‹¤ìŒ Accept ì‹œì‘]
    P --> Q
    Q --> A
```

#### 3. **Receive ì²˜ë¦¬ ê³¼ì •**

```csharp
private void StartReceive(SocketAsyncEventArgs e)
{
    var session = (TcpSession)e.UserToken;

    try
    {
        bool willRaiseEvent = session.IsConnected && session.RemoteEndPoint != null && ((Socket)session.GetType().GetField("_socket", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance).GetValue(session)).ReceiveAsync(e);
        if (!willRaiseEvent)
        {
            ProcessReceive(e);
        }
    }
    catch (ObjectDisposedException)
    {
            // ì„¸ì…˜ì´ ì´ë¯¸ ë‹«í˜”ì„ ìˆ˜ ìˆìŒ
            ReturnReceiveEventArgs(e);
    }
    catch (Exception ex)
    {
            Console.WriteLine($"Error starting receive for session {session.Id}: {ex.Message}");
            session.Close();
            ReturnReceiveEventArgs(e);
    }
}
```

**ğŸ“¡ Receive ë°ì´í„° í”Œë¡œìš°**:

```
Client â†’ TCP Buffer â†’ Socket.ReceiveAsync() â†’ SAEA Buffer
                                                    â”‚
                                                    â–¼
                                            ProcessReceive()
                                                    â”‚
                                                    â–¼
                                          TcpSession.ProcessReceive()
                                                    â”‚
                                                    â–¼
                                        MessageFramer.ProcessReceivedData()
                                                    â”‚
                                                    â–¼
                                            Complete Messages
                                                    â”‚
                                                    â–¼
                                          PacketProcessor.HandlePacket()
```

#### 4. **TcpSession** - ê°œë³„ í´ë¼ì´ì–¸íŠ¸ ê´€ë¦¬

```csharp
public class TcpSession : ISession
{
    internal void ProcessReceive(byte[] buffer, int offset, int count)
    {
        // MessageFramerë¥¼ í†µí•´ ë©”ì‹œì§€ë¥¼ íŒŒì‹±í•©ë‹ˆë‹¤.
        _messageFramer.ProcessReceivedData(new ArraySegment<byte>(buffer, offset, count));
    }

    public void Send(IPacket packet)
    {
        if (!IsConnected)
        {
            return;
        }

        byte[] packetData = _packetProcessor.SerializePacket(packet);
        byte[] framedData = _messageFramer.FrameMessage(packetData);

        // Sendë¥¼ ìœ„í•œ ìƒˆë¡œìš´ SocketAsyncEventArgsë¥¼ ìƒì„±í•˜ì—¬ ë¹„ë™ê¸° ì „ì†¡
        var sendArgs = new SocketAsyncEventArgs();
        sendArgs.SetBuffer(framedData, 0, framedData.Length);
        sendArgs.Completed += IO_Completed;
        sendArgs.UserToken = this;

        try
        {
            bool willRaiseEvent = _socket.SendAsync(sendArgs);
            if (!willRaiseEvent)
            {
                ProcessSend(sendArgs);
            }
        }
        catch (ObjectDisposedException)
        {
            Close();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Send Error: {ex.Message}");
            Close();
        }
    }
}
```

**ğŸ”„ Send ì‘ì—… íŠ¹ì´ì **:
- **Receive SAEAëŠ” í’€ë§**í•˜ì§€ë§Œ, **Send SAEAëŠ” ë§¤ë²ˆ ìƒˆë¡œ ìƒì„±**
- ì´ìœ : SendëŠ” íŒ¨í‚·ë§ˆë‹¤ ë‹¤ë¥¸ ë°ì´í„°ë¥¼ ë‹´ê³  ìˆì–´ ì¬ì‚¬ìš©ì´ ë³µì¡í•¨
- Send ì™„ë£Œ í›„ `Dispose()`ë¡œ ì¦‰ì‹œ í•´ì œ
- ì´ ì˜ˆì œì—ì„œëŠ” ë§¤ë²ˆ ìƒì„±ì„ í–ˆì§€ë§Œ ê³ ì„±ëŠ¥ ì„œë²„ë¥¼ ë§Œë“¤ ë•ŒëŠ” ì´ê²ƒë„ í’€ë§ì„ í•´ì•¼í•œë‹¤.  

#### 5. **MessageFramer** - TCP ìŠ¤íŠ¸ë¦¼ ë¶„í•  ì²˜ë¦¬

```csharp
public void ProcessReceivedData(ArraySegment<byte> data)
{
    _receiveBuffer.Write(data.Array, data.Offset, data.Count);

    while (true)
    {
        _receiveBuffer.Position = 0;

        if (_receiveBuffer.Length < HeaderSize)
        {
            break; // í—¤ë”ë¥¼ ì½ê¸°ì— ì¶©ë¶„í•œ ë°ì´í„°ê°€ ì—†ìŒ
        }

        byte[] lengthBuffer = new byte[HeaderSize];
        _receiveBuffer.Read(lengthBuffer, 0, HeaderSize);
        int messageLength = BitConverter.ToInt32(lengthBuffer, 0);

        if (_receiveBuffer.Length < HeaderSize + messageLength)
        {
            break; // ì „ì²´ ë©”ì‹œì§€ë¥¼ ì½ê¸°ì— ì¶©ë¶„í•œ ë°ì´í„°ê°€ ì—†ìŒ
        }

        byte[] message = new byte[messageLength];
        _receiveBuffer.Read(message, 0, messageLength);

        MessageReceived?.Invoke(message); // ì™„ì „í•œ ë©”ì‹œì§€ ì „ë‹¬

        // ë‚¨ì€ ë°ì´í„° ì²˜ë¦¬...
    }
}
```

**ğŸ“¦ TCP ìŠ¤íŠ¸ë¦¼ íŒŒì‹± ì›ë¦¬**:

```
TCP Stream: [Length][Data][Length][Data][Partial...]
                â†“
   MemoryStream Buffer: ëˆ„ì  ì €ì¥
                â†“
   While Loop: ì™„ì „í•œ ë©”ì‹œì§€ ì¶”ì¶œ
                â†“
   Event Trigger: MessageReceived ë°œìƒ
```

### ğŸ® ì±„íŒ… ì„œë²„ ì˜ˆì œ ë¶„ì„

#### **ì„œë²„ ì´ˆê¸°í™” ê³¼ì •**

```csharp
// ìµœëŒ€ ì—°ê²° 1000ê°œ, ë²„í¼ í¬ê¸° 4096ìœ¼ë¡œ ì„œë²„ ì´ˆê¸°í™”
_server = new TcpNetworkServer(1000, 4096, _packetProcessor, OnPacketReceived);
```

**ğŸ’¾ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê³„ì‚°**:
- Accept SAEA Pool: 1000ê°œ Ã— ì‘ì€ ë©”ëª¨ë¦¬ = ~ìˆ˜ KB
- Receive SAEA Pool: 1000ê°œ Ã— 4096 bytes = ~4MB
- **ì´í•©**: ì•½ 4MB (vs Thread-per-Connection: 1000MB!)

```
Memory Usage Comparison:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Thread-per-Connection         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ 1MB â”‚â”‚ 1MB â”‚â”‚ 1MB â”‚ ... â”‚ 1MB â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         Total: 1000MB                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               vs
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          SocketAsyncEventArgs           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     SAEA Pool: ~4MB              â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚4KB â”‚â”‚4KB â”‚â”‚4KB â”‚... â”‚4KB â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         Total: 4MB                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **íŒ¨í‚· ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸**

```mermaid
sequenceDiagram
    participant C as Client
    participant S as Server SAEA
    participant Sess as TcpSession
    participant MF as MessageFramer
    participant PP as PacketProcessor
    participant App as Application

    C->>S: TCP Data
    S->>Sess: ProcessReceive(buffer, offset, count)
    Sess->>MF: ProcessReceivedData(ArraySegment)
    MF->>MF: Parse Length Prefix
    MF->>App: MessageReceived Event
    App->>PP: HandlePacket(data, session)
    PP->>PP: Deserialize Packet
    PP->>App: Handler Callback
    App->>Sess: session.Send(response)
    Sess->>S: SendAsync with new SAEA
    S->>C: TCP Response
```

### âš¡ ì„±ëŠ¥ ìµœì í™” í¬ì¸íŠ¸

#### 1. **ë²„í¼ í¬ê¸° íŠœë‹**
```csharp
// ì‘ì€ ë²„í¼: ë©”ëª¨ë¦¬ ì ˆì•½, í•˜ì§€ë§Œ ë” ë§ì€ Receive í˜¸ì¶œ
private readonly int _bufferSize = 1024;  // ê²Œì„: ì‘ì€ íŒ¨í‚· ìœ„ì£¼

// í° ë²„í¼: ì²˜ë¦¬ëŸ‰ ì¦ê°€, í•˜ì§€ë§Œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€  
private readonly int _bufferSize = 8192;  // íŒŒì¼ ì „ì†¡: í° ë°ì´í„° ìœ„ì£¼
```

#### 2. **í’€ í¬ê¸° ìµœì í™”**
```csharp
// ë³´ìˆ˜ì  ì ‘ê·¼: ì˜ˆìƒ ë™ì‹œì ‘ì†ìì™€ ë™ì¼
int poolSize = maxConnections;

// ì ê·¹ì  ì ‘ê·¼: 10-20% ë” í• ë‹¹ (ë²„ìŠ¤íŠ¸ íŠ¸ë˜í”½ ëŒ€ì‘)
int poolSize = (int)(maxConnections * 1.2);
```

#### 3. **CPU ì½”ì–´ í™œìš©**
```
Single Thread IOCP:
CPU Core 1: [====IOCP Thread====]
CPU Core 2: [        ]
CPU Core 3: [        ]
CPU Core 4: [        ]

Multi-threaded Processing:
CPU Core 1: [====IOCP Thread====]
CPU Core 2: [==Packet Process==]  
CPU Core 3: [==Game Logic====]
CPU Core 4: [==Database====]
```

### ğŸ”§ ì‹¤ì „ ê°œë°œ íŒ

#### 1. **ì—ëŸ¬ ì²˜ë¦¬ ì „ëµ**
```csharp
private void ProcessReceive(SocketAsyncEventArgs e)
{
    var session = (TcpSession)e.UserToken;
    
    // ì •ìƒ ìˆ˜ì‹ 
    if (e.BytesTransferred > 0 && e.SocketError == SocketError.Success)
    {
        session.ProcessReceive(e.Buffer, e.Offset, e.BytesTransferred);
        StartReceive(e); // ê³„ì† ìˆ˜ì‹ 
    }
    // ì—°ê²° ì¢…ë£Œ ë˜ëŠ” ì—ëŸ¬
    else
    {
        session.Close();
        ReturnReceiveEventArgs(e); // í’€ë¡œ ë°˜í™˜
    }
}
```

#### 2. **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€**
```csharp
public void Stop()
{
    // ëª¨ë“  ì„¸ì…˜ ì •ë¦¬
    foreach (var session in _sessions.Values.ToList())
    {
        session.Disconnect();
    }
    _sessions.Clear();
    
    // SAEA í’€ ì •ë¦¬ - ì¤‘ìš”!
    while(_acceptEventArgsPool.TryPop(out var args)) 
        args.Dispose();
    while(_receiveEventArgsPool.TryPop(out var args)) 
        args.Dispose();
}
```

#### 3. **ëª¨ë‹ˆí„°ë§ ì§€í‘œ**
```csharp
// ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì„ ìœ„í•œ ì¹´ìš´í„°ë“¤
private long _totalBytesReceived = 0;
private long _totalBytesSent = 0;
private int _activeConnections = 0;
private int _availableReceiveEventArgs => _receiveEventArgsPool.Count;
private int _availableAcceptEventArgs => _acceptEventArgsPool.Count;
```

ì´ SocketAsyncEventArgs íŒ¨í„´ì„ ë§ˆìŠ¤í„°í•˜ë©´ **ìˆ˜ì²œ ëª…ì˜ ë™ì‹œ ì ‘ì†ì**ë¥¼ ì•ˆì •ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ê³ ì„±ëŠ¥ ê²Œì„ ì„œë²„ë¥¼ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€
  
---
  
## SocketAsyncEventArgs í´ë˜ìŠ¤ ì™„ì „ ë¶„ì„

### ğŸ¯ SocketAsyncEventArgs ê°œìš”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SocketAsyncEventArgs                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                   ì£¼ìš” ì†ì„±ë“¤                             â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚    â”‚
â”‚  â”‚  â”‚   Buffer    â”‚ â”‚  UserToken  â”‚ â”‚SocketError  â”‚        â”‚    â”‚
â”‚  â”‚  â”‚Management   â”‚ â”‚  Context    â”‚ â”‚  Handling   â”‚        â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                   ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ                           â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚    â”‚
â”‚  â”‚  â”‚ Completed   â”‚ â”‚LastOperationâ”‚ â”‚BytesTransferâ”‚        â”‚    â”‚
â”‚  â”‚  â”‚   Event     â”‚ â”‚  Tracking   â”‚ â”‚   Results   â”‚        â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”§ í•µì‹¬ ì†ì„± ìƒì„¸ ë¶„ì„

#### 1. **Buffer ê´€ë¦¬ ì†ì„±ë“¤**

```csharp
public class SocketAsyncEventArgs : EventArgs, IDisposable
{
    // í•µì‹¬ ë²„í¼ ì†ì„±ë“¤
    public byte[] Buffer { get; }           // ì‹¤ì œ ë°ì´í„° ë²„í¼
    public IList<ArraySegment<byte>> BufferList { get; set; }  // ë¶„ì‚° ë²„í¼ ë¦¬ìŠ¤íŠ¸
    public int Offset { get; set; }         // ë²„í¼ ë‚´ ì‹œì‘ ìœ„ì¹˜
    public int Count { get; set; }          // ì²˜ë¦¬í•  ë°”ì´íŠ¸ ìˆ˜
    public int BytesTransferred { get; }    // ì‹¤ì œ ì „ì†¡/ìˆ˜ì‹ ëœ ë°”ì´íŠ¸ ìˆ˜
}
```

**ğŸ“¦ Buffer vs BufferList ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤**:

```csharp
// === ë‹¨ì¼ ë²„í¼ ì‚¬ìš© ì˜ˆì œ ===
public class SingleBufferExample
{
    private SocketAsyncEventArgs _receiveArgs;
    private byte[] _buffer = new byte[4096];

    public void InitializeSingleBuffer()
    {
        _receiveArgs = new SocketAsyncEventArgs();
        
        // ì „ì²´ ë²„í¼ ì„¤ì •
        _receiveArgs.SetBuffer(_buffer, 0, _buffer.Length);
        
        Console.WriteLine($"Buffer Size: {_receiveArgs.Count}");
        Console.WriteLine($"Buffer Offset: {_receiveArgs.Offset}");
        
        _receiveArgs.Completed += OnReceiveCompleted;
    }

    private void OnReceiveCompleted(object sender, SocketAsyncEventArgs e)
    {
        Console.WriteLine($"Received {e.BytesTransferred} bytes");
        
        // ì‹¤ì œ ìˆ˜ì‹ ëœ ë°ì´í„° ì²˜ë¦¬
        for (int i = e.Offset; i < e.Offset + e.BytesTransferred; i++)
        {
            byte receivedByte = e.Buffer[i];
            // ë°ì´í„° ì²˜ë¦¬...
        }
    }
}

// === ë¶„ì‚° ë²„í¼ ì‚¬ìš© ì˜ˆì œ ===
public class ScatterGatherExample
{
    private SocketAsyncEventArgs _sendArgs;

    public void InitializeScatterGather()
    {
        _sendArgs = new SocketAsyncEventArgs();
        
        // ì—¬ëŸ¬ ë²„í¼ ì¡°ê°ì„ í•˜ë‚˜ì˜ ì „ì†¡ ì‘ì—…ìœ¼ë¡œ ê²°í•©
        var bufferList = new List<ArraySegment<byte>>
        {
            new ArraySegment<byte>(Encoding.UTF8.GetBytes("HTTP/1.1 200 OK\r\n")),
            new ArraySegment<byte>(Encoding.UTF8.GetBytes("Content-Type: text/html\r\n")),
            new ArraySegment<byte>(Encoding.UTF8.GetBytes("Content-Length: 13\r\n\r\n")),
            new ArraySegment<byte>(Encoding.UTF8.GetBytes("Hello, World!"))
        };
        
        _sendArgs.BufferList = bufferList;
        _sendArgs.Completed += OnSendCompleted;
        
        Console.WriteLine($"Total segments: {bufferList.Count}");
    }

    private void OnSendCompleted(object sender, SocketAsyncEventArgs e)
    {
        Console.WriteLine($"Sent {e.BytesTransferred} bytes using scatter-gather");
    }
}
```

**ğŸ’¡ Buffer vs BufferList ì„ íƒ ê°€ì´ë“œ**:

```
ë‹¨ì¼ ë²„í¼ (Buffer):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     ì—°ì†ëœ í•˜ë‚˜ì˜ ë©”ëª¨ë¦¬ ë¸”ë¡       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚    â†‘ ë‹¨ìˆœí•œ ë°ì´í„° ì „ì†¡ì— ìµœì       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ë¶„ì‚° ë²„í¼ (BufferList):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ì—¬ëŸ¬ ë©”ëª¨ë¦¬ ì¡°ê°ë“¤ì„ ê²°í•©      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚ â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚ â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜        â”‚
â”‚    â†‘ HTTP í—¤ë”+ë°”ë””, ë³µí•© íŒ¨í‚·     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2. **ì†Œì¼“ ì •ë³´ ë° ìƒíƒœ ì†ì„±ë“¤**

```csharp
public class SocketAsyncEventArgs : EventArgs, IDisposable
{
    // ì†Œì¼“ ì—°ê²° ê´€ë ¨
    public Socket AcceptSocket { get; set; }           // Accept ì‘ì—…ì—ì„œ ìƒì„±ëœ ì†Œì¼“
    public Socket ConnectSocket { get; }               // Connect ì‘ì—…ì— ì‚¬ìš©í•  ì†Œì¼“
    public EndPoint RemoteEndPoint { get; set; }       // ì›ê²© ì—”ë“œí¬ì¸íŠ¸
    
    // ì‘ì—… ìƒíƒœ ë° ê²°ê³¼
    public SocketError SocketError { get; }            // ì‘ì—… ì™„ë£Œ í›„ ì—ëŸ¬ ìƒíƒœ
    public SocketAsyncOperation LastOperation { get; } // ë§ˆì§€ë§‰ ìˆ˜í–‰ëœ ì‘ì—… ìœ í˜•
    public Exception ConnectByNameError { get; }       // ì´ë¦„ìœ¼ë¡œ ì—°ê²° ì‹œ ë°œìƒí•œ ì—ëŸ¬
    
    // ì‚¬ìš©ì ì •ì˜ ë°ì´í„°
    public object UserToken { get; set; }              // ì‚¬ìš©ì ì •ì˜ ì»¨í…ìŠ¤íŠ¸ ê°ì²´
}
```

**ğŸª UserToken í™œìš© íŒ¨í„´**:

```csharp
// === UserTokenì„ í™œìš©í•œ ì„¸ì…˜ ê´€ë¦¬ ===
public class SessionContext
{
    public Guid SessionId { get; set; }
    public DateTime ConnectedTime { get; set; }
    public string UserName { get; set; }
    public long TotalBytesReceived { get; set; }
    public Queue<byte[]> SendQueue { get; set; } = new Queue<byte[]>();
}

public class TokenBasedSessionManager
{
    private Dictionary<Guid, Socket> _sessionSockets = new Dictionary<Guid, Socket>();

    public void StartReceive(Socket clientSocket)
    {
        var receiveArgs = new SocketAsyncEventArgs();
        receiveArgs.SetBuffer(new byte[4096], 0, 4096);
        
        // UserTokenì— ì„¸ì…˜ ì •ë³´ ì €ì¥
        var sessionContext = new SessionContext
        {
            SessionId = Guid.NewGuid(),
            ConnectedTime = DateTime.Now,
            UserName = "Unknown"
        };
        
        receiveArgs.UserToken = sessionContext;
        receiveArgs.Completed += OnReceiveCompleted;
        
        _sessionSockets[sessionContext.SessionId] = clientSocket;
        
        bool willRaiseEvent = clientSocket.ReceiveAsync(receiveArgs);
        if (!willRaiseEvent)
        {
            OnReceiveCompleted(null, receiveArgs);
        }
    }

    private void OnReceiveCompleted(object sender, SocketAsyncEventArgs e)
    {
        var context = (SessionContext)e.UserToken;
        
        if (e.SocketError == SocketError.Success && e.BytesTransferred > 0)
        {
            context.TotalBytesReceived += e.BytesTransferred;
            
            Console.WriteLine($"Session {context.SessionId}: " +
                            $"Received {e.BytesTransferred} bytes, " +
                            $"Total: {context.TotalBytesReceived} bytes");
            
            // ë°ì´í„° ì²˜ë¦¬...
            ProcessReceivedData(context, e.Buffer, e.Offset, e.BytesTransferred);
            
            // ë‹¤ìŒ ìˆ˜ì‹  ì¤€ë¹„
            bool willRaiseEvent = _sessionSockets[context.SessionId].ReceiveAsync(e);
            if (!willRaiseEvent)
            {
                OnReceiveCompleted(null, e);
            }
        }
        else
        {
            // ì—°ê²° ì¢…ë£Œ ì²˜ë¦¬
            CleanupSession(context.SessionId);
            e.Dispose();
        }
    }

    private void ProcessReceivedData(SessionContext context, byte[] buffer, int offset, int count)
    {
        // ì‹¤ì œ ë°ì´í„° ì²˜ë¦¬ ë¡œì§
        string receivedText = Encoding.UTF8.GetString(buffer, offset, count);
        Console.WriteLine($"[{context.UserName}]: {receivedText}");
    }

    private void CleanupSession(Guid sessionId)
    {
        if (_sessionSockets.TryRemove(sessionId, out Socket socket))
        {
            socket.Close();
            Console.WriteLine($"Session {sessionId} cleaned up");
        }
    }
}
```

#### 3. **ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ**

```csharp
public class SocketAsyncEventArgs : EventArgs, IDisposable
{
    // í•µì‹¬ ì´ë²¤íŠ¸
    public event EventHandler<SocketAsyncEventArgs> Completed;
    
    // ì‘ì—… ì™„ë£Œ ìƒíƒœ
    public SocketAsyncOperation LastOperation { get; }
}

// LastOperation ì—´ê±°í˜• ê°’ë“¤
public enum SocketAsyncOperation
{
    None,           // ì‘ì—… ì—†ìŒ
    Accept,         // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½
    Connect,        // ì„œë²„ì— ì—°ê²°
    Disconnect,     // ì—°ê²° í•´ì œ
    Receive,        // ë°ì´í„° ìˆ˜ì‹ 
    ReceiveFrom,    // UDP ë°ì´í„° ìˆ˜ì‹ 
    ReceiveMessageFrom, // UDP ë©”ì‹œì§€ ìˆ˜ì‹  (ì¶”ê°€ ì •ë³´ í¬í•¨)
    Send,           // ë°ì´í„° ì†¡ì‹ 
    SendPackets,    // ë‹¤ì¤‘ íŒ¨í‚· ì†¡ì‹ 
    SendTo          // UDP ë°ì´í„° ì†¡ì‹ 
}
```

**ğŸ­ í†µí•© ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ íŒ¨í„´**:

```csharp
public class UnifiedEventHandler
{
    private SocketAsyncEventArgs _multiPurposeArgs;

    public void InitializeUnifiedHandler()
    {
        _multiPurposeArgs = new SocketAsyncEventArgs();
        _multiPurposeArgs.Completed += OnIOCompleted;
        _multiPurposeArgs.SetBuffer(new byte[4096], 0, 4096);
    }

    // ëª¨ë“  ë¹„ë™ê¸° ì‘ì—…ì— ëŒ€í•œ í†µí•© í•¸ë“¤ëŸ¬
    private void OnIOCompleted(object sender, SocketAsyncEventArgs e)
    {
        switch (e.LastOperation)
        {
            case SocketAsyncOperation.Accept:
                ProcessAccept(e);
                break;
                
            case SocketAsyncOperation.Connect:
                ProcessConnect(e);
                break;
                
            case SocketAsyncOperation.Receive:
                ProcessReceive(e);
                break;
                
            case SocketAsyncOperation.Send:
                ProcessSend(e);
                break;
                
            case SocketAsyncOperation.Disconnect:
                ProcessDisconnect(e);
                break;
                
            default:
                Console.WriteLine($"Unknown operation: {e.LastOperation}");
                break;
        }
    }

    private void ProcessAccept(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Console.WriteLine($"Client accepted: {e.AcceptSocket.RemoteEndPoint}");
            // ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ë¡œì§
        }
        else
        {
            Console.WriteLine($"Accept failed: {e.SocketError}");
        }
    }

    private void ProcessConnect(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Console.WriteLine("Successfully connected to server");
            // ì—°ê²° í›„ ì²˜ë¦¬ ë¡œì§
        }
        else
        {
            Console.WriteLine($"Connection failed: {e.SocketError}");
        }
    }

    private void ProcessReceive(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success && e.BytesTransferred > 0)
        {
            Console.WriteLine($"Received {e.BytesTransferred} bytes");
            // ìˆ˜ì‹  ë°ì´í„° ì²˜ë¦¬
            
            // ASCII ì•„íŠ¸ë¡œ ë°ì´í„° ì‹œê°í™”
            Console.WriteLine("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
            Console.WriteLine("â”‚        Received Data            â”‚");
            Console.WriteLine("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
            
            string data = Encoding.UTF8.GetString(e.Buffer, e.Offset, e.BytesTransferred);
            Console.WriteLine($"â”‚ {data.PadRight(31)} â”‚");
            
            Console.WriteLine("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");
        }
        else
        {
            Console.WriteLine("Connection closed or error occurred");
        }
    }

    private void ProcessSend(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Console.WriteLine($"Successfully sent {e.BytesTransferred} bytes");
        }
        else
        {
            Console.WriteLine($"Send failed: {e.SocketError}");
        }
    }

    private void ProcessDisconnect(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Console.WriteLine("Successfully disconnected");
        }
        else
        {
            Console.WriteLine($"Disconnect failed: {e.SocketError}");
        }
    }
}
```

---

## Socket í´ë˜ìŠ¤ ë¹„ë™ê¸° ë©”ì„œë“œ ì™„ì „ ë¶„ì„

### ğŸ”Œ AcceptAsync ë©”ì„œë“œ

```csharp
public bool AcceptAsync(SocketAsyncEventArgs e)
```

**ğŸ¯ ê¸°ëŠ¥**: í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìš”ì²­ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ìˆ˜ë½

**ğŸ“ ë°˜í™˜ê°’ ì˜ë¯¸**:
- `true`: ë¹„ë™ê¸° ì‘ì—…ì´ ì‹œì‘ë¨, `Completed` ì´ë²¤íŠ¸ë¡œ ì™„ë£Œ í†µì§€
- `false`: ì‘ì—…ì´ ì¦‰ì‹œ ì™„ë£Œë¨, ë°”ë¡œ ê²°ê³¼ ì²˜ë¦¬ ê°€ëŠ¥

```csharp
public class AcceptAsyncExample
{
    private Socket _listenSocket;
    private SocketAsyncEventArgs _acceptArgs;

    public void StartListening(int port)
    {
        // ë¦¬ìŠ¤ë‹ ì†Œì¼“ ì„¤ì •
        _listenSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        _listenSocket.Bind(new IPEndPoint(IPAddress.Any, port));
        _listenSocket.Listen(100);

        // Acceptìš© SocketAsyncEventArgs ì„¤ì •
        _acceptArgs = new SocketAsyncEventArgs();
        _acceptArgs.Completed += OnAcceptCompleted;

        Console.WriteLine($"Server listening on port {port}");
        StartAccept();
    }

    private void StartAccept()
    {
        // ì´ì „ Accept ì†Œì¼“ ì´ˆê¸°í™” (ì¬ì‚¬ìš©ì„ ìœ„í•´)
        _acceptArgs.AcceptSocket = null;

        try
        {
            bool willRaiseEvent = _listenSocket.AcceptAsync(_acceptArgs);
            
            if (!willRaiseEvent)
            {
                // ì¦‰ì‹œ ì™„ë£Œëœ ê²½ìš° ì§ì ‘ ì²˜ë¦¬
                ProcessAccept(_acceptArgs);
            }
            // trueì¸ ê²½ìš° OnAcceptCompletedì—ì„œ ì²˜ë¦¬ë¨
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Accept error: {ex.Message}");
        }
    }

    private void OnAcceptCompleted(object sender, SocketAsyncEventArgs e)
    {
        ProcessAccept(e);
    }

    private void ProcessAccept(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Socket clientSocket = e.AcceptSocket;
            
            Console.WriteLine("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
            Console.WriteLine("â”‚         New Client Connected       â”‚");
            Console.WriteLine("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
            Console.WriteLine($"â”‚ Remote: {clientSocket.RemoteEndPoint?.ToString().PadRight(23)} â”‚");
            Console.WriteLine($"â”‚ Local:  {clientSocket.LocalEndPoint?.ToString().PadRight(23)} â”‚");
            Console.WriteLine("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

            // ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ ì‹œì‘
            StartReceiveFromClient(clientSocket);
        }
        else
        {
            Console.WriteLine($"Accept failed: {e.SocketError}");
        }

        // ë‹¤ìŒ ì—°ê²° ëŒ€ê¸°
        StartAccept();
    }

    private void StartReceiveFromClient(Socket clientSocket)
    {
        var receiveArgs = new SocketAsyncEventArgs();
        receiveArgs.SetBuffer(new byte[1024], 0, 1024);
        receiveArgs.UserToken = clientSocket;
        receiveArgs.Completed += OnReceiveCompleted;

        bool willRaiseEvent = clientSocket.ReceiveAsync(receiveArgs);
        if (!willRaiseEvent)
        {
            OnReceiveCompleted(null, receiveArgs);
        }
    }

    private void OnReceiveCompleted(object sender, SocketAsyncEventArgs e)
    {
        var clientSocket = (Socket)e.UserToken;
        
        if (e.SocketError == SocketError.Success && e.BytesTransferred > 0)
        {
            string receivedData = Encoding.UTF8.GetString(e.Buffer, 0, e.BytesTransferred);
            Console.WriteLine($"Received from client: {receivedData}");

            // Echo back to client
            byte[] echoData = Encoding.UTF8.GetBytes($"Echo: {receivedData}");
            clientSocket.Send(echoData);

            // Continue receiving
            bool willRaiseEvent = clientSocket.ReceiveAsync(e);
            if (!willRaiseEvent)
            {
                OnReceiveCompleted(null, e);
            }
        }
        else
        {
            // Client disconnected
            Console.WriteLine("Client disconnected");
            clientSocket.Close();
            e.Dispose();
        }
    }
}
```

### ğŸ”— ConnectAsync ë©”ì„œë“œ

```csharp
public bool ConnectAsync(SocketAsyncEventArgs e)
```

**ğŸ¯ ê¸°ëŠ¥**: ì›ê²© ì„œë²„ì— ë¹„ë™ê¸°ì ìœ¼ë¡œ ì—°ê²°

```csharp
public class ConnectAsyncExample
{
    private Socket _clientSocket;
    private SocketAsyncEventArgs _connectArgs;

    public void ConnectToServer(string host, int port)
    {
        _clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        
        _connectArgs = new SocketAsyncEventArgs();
        _connectArgs.RemoteEndPoint = new IPEndPoint(IPAddress.Parse(host), port);
        _connectArgs.Completed += OnConnectCompleted;

        Console.WriteLine($"Attempting to connect to {host}:{port}...");

        bool willRaiseEvent = _clientSocket.ConnectAsync(_connectArgs);
        if (!willRaiseEvent)
        {
            ProcessConnect(_connectArgs);
        }
    }

    private void OnConnectCompleted(object sender, SocketAsyncEventArgs e)
    {
        ProcessConnect(e);
    }

    private void ProcessConnect(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Console.WriteLine("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
            Console.WriteLine("â”‚       Connection Successful        â”‚");
            Console.WriteLine("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
            Console.WriteLine($"â”‚ Connected to: {e.RemoteEndPoint?.ToString().PadRight(19)} â”‚");
            Console.WriteLine($"â”‚ Local address: {_clientSocket.LocalEndPoint?.ToString().PadRight(18)} â”‚");
            Console.WriteLine("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

            // ì—°ê²° í›„ ë°ì´í„° ì „ì†¡ ì‹œì‘
            StartCommunication();
        }
        else
        {
            Console.WriteLine($"Connection failed: {e.SocketError}");
            
            // ì¬ì—°ê²° ë¡œì§ ì˜ˆì œ
            if (ShouldRetryConnection(e.SocketError))
            {
                Console.WriteLine("Retrying connection in 3 seconds...");
                Task.Delay(3000).ContinueWith(_ => RetryConnection());
            }
        }
    }

    private bool ShouldRetryConnection(SocketError error)
    {
        return error == SocketError.ConnectionRefused || 
               error == SocketError.TimedOut ||
               error == SocketError.NetworkUnreachable;
    }

    private void RetryConnection()
    {
        _clientSocket?.Close();
        _clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        
        bool willRaiseEvent = _clientSocket.ConnectAsync(_connectArgs);
        if (!willRaiseEvent)
        {
            ProcessConnect(_connectArgs);
        }
    }

    private void StartCommunication()
    {
        // ì„œë²„ì— ì´ˆê¸° ë©”ì‹œì§€ ì „ì†¡
        string greeting = "Hello from client!";
        byte[] data = Encoding.UTF8.GetBytes(greeting);
        
        var sendArgs = new SocketAsyncEventArgs();
        sendArgs.SetBuffer(data, 0, data.Length);
        sendArgs.Completed += OnSendCompleted;

        bool willRaiseEvent = _clientSocket.SendAsync(sendArgs);
        if (!willRaiseEvent)
        {
            OnSendCompleted(null, sendArgs);
        }
    }

    private void OnSendCompleted(object sender, SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Console.WriteLine($"Successfully sent {e.BytesTransferred} bytes");
            e.Dispose();
        }
        else
        {
            Console.WriteLine($"Send failed: {e.SocketError}");
        }
    }
}
```

### ğŸ“¥ ReceiveAsync ë©”ì„œë“œ

```csharp
public bool ReceiveAsync(SocketAsyncEventArgs e)
```

**ğŸ¯ ê¸°ëŠ¥**: ì†Œì¼“ì—ì„œ ë°ì´í„°ë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ìˆ˜ì‹ 

```csharp
public class ReceiveAsyncExample
{
    private Socket _socket;
    private SocketAsyncEventArgs _receiveArgs;
    private MemoryStream _messageBuffer = new MemoryStream();

    public void StartReceiving(Socket connectedSocket)
    {
        _socket = connectedSocket;
        
        _receiveArgs = new SocketAsyncEventArgs();
        _receiveArgs.SetBuffer(new byte[4096], 0, 4096);
        _receiveArgs.Completed += OnReceiveCompleted;

        StartReceive();
    }

    private void StartReceive()
    {
        try
        {
            bool willRaiseEvent = _socket.ReceiveAsync(_receiveArgs);
            if (!willRaiseEvent)
            {
                ProcessReceive(_receiveArgs);
            }
        }
        catch (ObjectDisposedException)
        {
            Console.WriteLine("Socket has been disposed");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Receive error: {ex.Message}");
        }
    }

    private void OnReceiveCompleted(object sender, SocketAsyncEventArgs e)
    {
        ProcessReceive(e);
    }

    private void ProcessReceive(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success && e.BytesTransferred > 0)
        {
            // ìˆ˜ì‹ ëœ ë°ì´í„°ë¥¼ ë²„í¼ì— ëˆ„ì 
            _messageBuffer.Write(e.Buffer, e.Offset, e.BytesTransferred);

            // ë°ì´í„° ì‹œê°í™”
            DisplayReceivedData(e.Buffer, e.Offset, e.BytesTransferred);

            // ì™„ì „í•œ ë©”ì‹œì§€ íŒŒì‹± ì‹œë„
            TryParseCompleteMessages();

            // ë‹¤ìŒ ë°ì´í„° ìˆ˜ì‹  ê³„ì†
            StartReceive();
        }
        else if (e.BytesTransferred == 0)
        {
            Console.WriteLine("Remote endpoint closed the connection gracefully");
            CleanupConnection();
        }
        else
        {
            Console.WriteLine($"Receive error: {e.SocketError}");
            CleanupConnection();
        }
    }

    private void DisplayReceivedData(byte[] buffer, int offset, int count)
    {
        Console.WriteLine("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
        Console.WriteLine($"â”‚ Received {count,3} bytes                            â”‚");
        Console.WriteLine("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
        
        // Hex dump í˜•íƒœë¡œ ë°ì´í„° í‘œì‹œ
        for (int i = 0; i < count; i += 16)
        {
            string hexPart = "";
            string asciiPart = "";
            
            for (int j = 0; j < 16 && i + j < count; j++)
            {
                byte b = buffer[offset + i + j];
                hexPart += $"{b:X2} ";
                asciiPart += (b >= 32 && b <= 126) ? (char)b : '.';
            }
            
            Console.WriteLine($"â”‚ {hexPart.PadRight(48)} {asciiPart.PadRight(16)} â”‚");
        }
        
        Console.WriteLine("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");
    }

    private void TryParseCompleteMessages()
    {
        byte[] bufferData = _messageBuffer.ToArray();
        int processedBytes = 0;

        // ê°„ë‹¨í•œ length-prefixed ë©”ì‹œì§€ íŒŒì‹± ì˜ˆì œ
        while (processedBytes + 4 <= bufferData.Length)
        {
            // ë©”ì‹œì§€ ê¸¸ì´ ì½ê¸° (4ë°”ì´íŠ¸)
            int messageLength = BitConverter.ToInt32(bufferData, processedBytes);
            
            if (messageLength <= 0 || messageLength > 65536) // ìœ íš¨ì„± ê²€ì‚¬
            {
                Console.WriteLine("Invalid message length detected");
                break;
            }

            if (processedBytes + 4 + messageLength <= bufferData.Length)
            {
                // ì™„ì „í•œ ë©”ì‹œì§€ ì¶”ì¶œ
                byte[] messageData = new byte[messageLength];
                Array.Copy(bufferData, processedBytes + 4, messageData, 0, messageLength);
                
                ProcessCompleteMessage(messageData);
                processedBytes += 4 + messageLength;
            }
            else
            {
                // ì•„ì§ ì™„ì „í•œ ë©”ì‹œì§€ê°€ ì•„ë‹˜
                break;
            }
        }

        // ì²˜ë¦¬ëœ ë°”ì´íŠ¸ ì œê±°
        if (processedBytes > 0)
        {
            byte[] remainingData = new byte[bufferData.Length - processedBytes];
            Array.Copy(bufferData, processedBytes, remainingData, 0, remainingData.Length);
            
            _messageBuffer.SetLength(0);
            _messageBuffer.Write(remainingData, 0, remainingData.Length);
        }
    }

    private void ProcessCompleteMessage(byte[] messageData)
    {
        string message = Encoding.UTF8.GetString(messageData);
        Console.WriteLine($"ğŸ“¨ Complete message received: {message}");
    }

    private void CleanupConnection()
    {
        _socket?.Close();
        _receiveArgs?.Dispose();
        _messageBuffer?.Dispose();
    }
}
```

### ğŸ“¤ SendAsync ë©”ì„œë“œ

```csharp
public bool SendAsync(SocketAsyncEventArgs e)
```

**ğŸ¯ ê¸°ëŠ¥**: ì†Œì¼“ì„ í†µí•´ ë°ì´í„°ë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì „ì†¡

```csharp
public class SendAsyncExample
{
    private Socket _socket;
    private Queue<byte[]> _sendQueue = new Queue<byte[]>();
    private bool _isSending = false;
    private readonly object _sendLock = new object();

    public void Initialize(Socket connectedSocket)
    {
        _socket = connectedSocket;
    }

    public void QueueMessage(string message)
    {
        // ë©”ì‹œì§€ë¥¼ length-prefixed í˜•íƒœë¡œ í”„ë ˆì´ë°
        byte[] messageBytes = Encoding.UTF8.GetBytes(message);
        byte[] lengthPrefix = BitConverter.GetBytes(messageBytes.Length);
        
        byte[] framedMessage = new byte[4 + messageBytes.Length];
        Array.Copy(lengthPrefix, 0, framedMessage, 0, 4);
        Array.Copy(messageBytes, 0, framedMessage, 4, messageBytes.Length);

        lock (_sendLock)
        {
            _sendQueue.Enqueue(framedMessage);
            
            if (!_isSending)
            {
                _isSending = true;
                StartSend();
            }
        }
    }

    private void StartSend()
    {
        if (_sendQueue.Count == 0)
        {
            _isSending = false;
            return;
        }

        byte[] dataToSend = _sendQueue.Dequeue();
        
        var sendArgs = new SocketAsyncEventArgs();
        sendArgs.SetBuffer(dataToSend, 0, dataToSend.Length);
        sendArgs.Completed += OnSendCompleted;
        sendArgs.UserToken = dataToSend; // ì „ì†¡ ë°ì´í„° ì°¸ì¡° ë³´ê´€

        Console.WriteLine($"ğŸ“¤ Sending {dataToSend.Length} bytes...");
        
        try
        {
            bool willRaiseEvent = _socket.SendAsync(sendArgs);
            if (!willRaiseEvent)
            {
                ProcessSend(sendArgs);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Send error: {ex.Message}");
            sendArgs.Dispose();
            _isSending = false;
        }
    }

    private void OnSendCompleted(object sender, SocketAsyncEventArgs e)
    {
        ProcessSend(e);
    }

    private void ProcessSend(SocketAsyncEventArgs e)
    {
        var originalData = (byte[])e.UserToken;
        
        if (e.SocketError == SocketError.Success)
        {
            if (e.BytesTransferred == originalData.Length)
            {
                // ì „ì²´ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ì „ì†¡ë¨
                Console.WriteLine("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
                Console.WriteLine("â”‚        Send Successful              â”‚");
                Console.WriteLine("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
                Console.WriteLine($"â”‚ Bytes sent: {e.BytesTransferred,23} â”‚");
                Console.WriteLine($"â”‚ Queue size: {_sendQueue.Count,23} â”‚");
                Console.WriteLine("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

                // ë‹¤ìŒ ë©”ì‹œì§€ ì „ì†¡
                e.Dispose();
                StartSend();
            }
            else
            {
                // ë¶€ë¶„ ì „ì†¡ - ë‚˜ë¨¸ì§€ ë°ì´í„° ê³„ì† ì „ì†¡
                HandlePartialSend(e, originalData);
            }
        }
        else
        {
            Console.WriteLine($"Send failed: {e.SocketError}");
            e.Dispose();
            _isSending = false;
        }
    }

    private void HandlePartialSend(SocketAsyncEventArgs e, byte[] originalData)
    {
        // ì „ì†¡ë˜ì§€ ì•Šì€ ë‚˜ë¨¸ì§€ ë°ì´í„° ê³„ì‚°
        int remainingBytes = originalData.Length - e.BytesTransferred;
        byte[] remainingData = new byte[remainingBytes];
        Array.Copy(originalData, e.BytesTransferred, remainingData, 0, remainingBytes);

        Console.WriteLine($"âš ï¸  Partial send: {e.BytesTransferred}/{originalData.Length} bytes");
        Console.WriteLine($"ğŸ”„ Continuing with remaining {remainingBytes} bytes...");

        // ë‚˜ë¨¸ì§€ ë°ì´í„°ë¡œ ë²„í¼ ì—…ë°ì´íŠ¸
        e.SetBuffer(remainingData, 0, remainingData.Length);
        e.UserToken = remainingData;

        try
        {
            bool willRaiseEvent = _socket.SendAsync(e);
            if (!willRaiseEvent)
            {
                ProcessSend(e);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Continuation send error: {ex.Message}");
            e.Dispose();
            _isSending = false;
        }
    }

    // ëŒ€ìš©ëŸ‰ íŒŒì¼ ì „ì†¡ ì˜ˆì œ
    public void SendFileAsync(string filePath)
    {
        if (!File.Exists(filePath))
        {
            Console.WriteLine("File not found");
            return;
        }

        Task.Run(() =>
        {
            using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
            {
                byte[] buffer = new byte[64 * 1024]; // 64KB ì²­í¬
                int bytesRead;
                long totalSent = 0;
                long fileSize = fileStream.Length;

                while ((bytesRead = fileStream.Read(buffer, 0, buffer.Length)) > 0)
                {
                    byte[] chunkToSend = new byte[bytesRead];
                    Array.Copy(buffer, 0, chunkToSend, 0, bytesRead);

                    lock (_sendLock)
                    {
                        _sendQueue.Enqueue(chunkToSend);
                        if (!_isSending)
                        {
                            _isSending = true;
                            StartSend();
                        }
                    }

                    totalSent += bytesRead;
                    
                    // ì§„í–‰ë¥  í‘œì‹œ
                    double progress = (double)totalSent / fileSize * 100;
                    Console.WriteLine($"ğŸ“ File transfer progress: {progress:F1}% ({totalSent}/{fileSize} bytes)");

                    // íê°€ ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šë„ë¡ ì œì–´
                    while (_sendQueue.Count > 10)
                    {
                        Thread.Sleep(10);
                    }
                }
            }
        });
    }
}
```

### ğŸ”Œ DisconnectAsync ë©”ì„œë“œ

```csharp
public bool DisconnectAsync(SocketAsyncEventArgs e)
```

**ğŸ¯ ê¸°ëŠ¥**: ì†Œì¼“ ì—°ê²°ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ í•´ì œí•˜ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ ì¤€ë¹„

```csharp
public class DisconnectAsyncExample
{
    private Socket _socket;
    private SocketAsyncEventArgs _disconnectArgs;

    public void Initialize(Socket connectedSocket)
    {
        _socket = connectedSocket;
        
        _disconnectArgs = new SocketAsyncEventArgs();
        _disconnectArgs.DisconnectReuseSocket = true; // ì†Œì¼“ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
        _disconnectArgs.Completed += OnDisconnectCompleted;
    }

    public void GracefulDisconnect()
    {
        Console.WriteLine("Initiating graceful disconnect...");
        
        try
        {
            bool willRaiseEvent = _socket.DisconnectAsync(_disconnectArgs);
            if (!willRaiseEvent)
            {
                ProcessDisconnect(_disconnectArgs);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Disconnect error: {ex.Message}");
            ForceClose();
        }
    }

    private void OnDisconnectCompleted(object sender, SocketAsyncEventArgs e)
    {
        ProcessDisconnect(e);
    }

    private void ProcessDisconnect(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Console.WriteLine("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
            Console.WriteLine("â”‚       Disconnect Successful        â”‚");
            Console.WriteLine("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
            Console.WriteLine("â”‚ Socket is ready for reuse          â”‚");
            Console.WriteLine($"â”‚ DisconnectReuseSocket: {e.DisconnectReuseSocket,11} â”‚");
            Console.WriteLine("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

            // ì†Œì¼“ì„ ë‹¤ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
            if (e.DisconnectReuseSocket)
            {
                PrepareSocketForReuse();
            }
        }
        else
        {
            Console.WriteLine($"Disconnect failed: {e.SocketError}");
            ForceClose();
        }
    }

    private void PrepareSocketForReuse()
    {
        Console.WriteLine("ğŸ”„ Socket prepared for reuse - can reconnect without creating new socket");
        
        // ì†Œì¼“ ìƒíƒœ ì´ˆê¸°í™”
        // ì´ì œ ì´ ì†Œì¼“ìœ¼ë¡œ ë‹¤ì‹œ ConnectAsyncë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŒ
    }

    private void ForceClose()
    {
        try
        {
            _socket?.Shutdown(SocketShutdown.Both);
        }
        catch { }
        finally
        {
            _socket?.Close();
            Console.WriteLine("ğŸ’¥ Socket forcefully closed");
        }
    }
}
```

### ğŸ“¡ UDP ê´€ë ¨ ë©”ì„œë“œë“¤

#### **SendToAsync / ReceiveFromAsync**

```csharp
// UDP ì „ìš© ë©”ì„œë“œë“¤
public bool SendToAsync(SocketAsyncEventArgs e)      // UDP ë°ì´í„° ì „ì†¡
public bool ReceiveFromAsync(SocketAsyncEventArgs e) // UDP ë°ì´í„° ìˆ˜ì‹ 
```

```csharp
public class UdpAsyncExample
{
    private Socket _udpSocket;
    private SocketAsyncEventArgs _receiveArgs;
    private SocketAsyncEventArgs _sendArgs;

    public void InitializeUdpServer(int port)
    {
        _udpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
        _udpSocket.Bind(new IPEndPoint(IPAddress.Any, port));

        // Receive ì„¤ì •
        _receiveArgs = new SocketAsyncEventArgs();
        _receiveArgs.SetBuffer(new byte[1024], 0, 1024);
        _receiveArgs.RemoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
        _receiveArgs.Completed += OnReceiveFromCompleted;

        // Send ì„¤ì •
        _sendArgs = new SocketAsyncEventArgs();
        _sendArgs.Completed += OnSendToCompleted;

        Console.WriteLine($"UDP Server listening on port {port}");
        StartReceiveFrom();
    }

    private void StartReceiveFrom()
    {
        try
        {
            bool willRaiseEvent = _udpSocket.ReceiveFromAsync(_receiveArgs);
            if (!willRaiseEvent)
            {
                ProcessReceiveFrom(_receiveArgs);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ReceiveFrom error: {ex.Message}");
        }
    }

    private void OnReceiveFromCompleted(object sender, SocketAsyncEventArgs e)
    {
        ProcessReceiveFrom(e);
    }

    private void ProcessReceiveFrom(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success && e.BytesTransferred > 0)
        {
            string receivedData = Encoding.UTF8.GetString(e.Buffer, 0, e.BytesTransferred);
            
            Console.WriteLine("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
            Console.WriteLine("â”‚              UDP Packet Received               â”‚");
            Console.WriteLine("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
            Console.WriteLine($"â”‚ From: {e.RemoteEndPoint?.ToString().PadRight(39)} â”‚");
            Console.WriteLine($"â”‚ Size: {e.BytesTransferred,39} bytes â”‚");
            Console.WriteLine($"â”‚ Data: {receivedData.PadRight(39)} â”‚");
            Console.WriteLine("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

            // Echo back to sender
            SendEcho(e.RemoteEndPoint, $"Echo: {receivedData}");
        }
        else
        {
            Console.WriteLine($"ReceiveFrom error: {e.SocketError}");
        }

        // Continue receiving
        StartReceiveFrom();
    }

    private void SendEcho(EndPoint clientEndPoint, string message)
    {
        byte[] responseData = Encoding.UTF8.GetBytes(message);
        
        _sendArgs.SetBuffer(responseData, 0, responseData.Length);
        _sendArgs.RemoteEndPoint = clientEndPoint;

        try
        {
            bool willRaiseEvent = _udpSocket.SendToAsync(_sendArgs);
            if (!willRaiseEvent)
            {
                ProcessSendTo(_sendArgs);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SendTo error: {ex.Message}");
        }
    }

    private void OnSendToCompleted(object sender, SocketAsyncEventArgs e)
    {
        ProcessSendTo(e);
    }

    private void ProcessSendTo(SocketAsyncEventArgs e)
    {
        if (e.SocketError == SocketError.Success)
        {
            Console.WriteLine($"ğŸ“¤ UDP response sent to {e.RemoteEndPoint}: {e.BytesTransferred} bytes");
        }
        else
        {
            Console.WriteLine($"SendTo failed: {e.SocketError}");
        }
    }
}
```

### ğŸ¯ ì¢…í•© ì„±ëŠ¥ ë¹„êµ

```
API ë©”ì„œë“œë³„ ì„±ëŠ¥ íŠ¹ì„±:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ë©”ì„œë“œë³„ íŠ¹ì„± ë¹„êµ                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     ë©”ì„œë“œ      â”‚   ë¹ˆë„      â”‚  ë©”ëª¨ë¦¬     â”‚   ë³µì¡ë„    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AcceptAsync     â”‚    ë‚®ìŒ     â”‚    ë‚®ìŒ     â”‚    ë‚®ìŒ     â”‚
â”‚ ConnectAsync    â”‚    ë‚®ìŒ     â”‚    ë‚®ìŒ     â”‚    ì¤‘ê°„     â”‚
â”‚ ReceiveAsync    â”‚    ë†’ìŒ     â”‚    ì¤‘ê°„     â”‚    ë†’ìŒ     â”‚
â”‚ SendAsync       â”‚    ë†’ìŒ     â”‚    ì¤‘ê°„     â”‚    ì¤‘ê°„     â”‚
â”‚ DisconnectAsync â”‚    ë‚®ìŒ     â”‚    ë‚®ìŒ     â”‚    ë‚®ìŒ     â”‚
â”‚ SendToAsync     â”‚    ë†’ìŒ     â”‚    ë‚®ìŒ     â”‚    ë‚®ìŒ     â”‚
â”‚ ReceiveFromAsyncâ”‚    ë†’ìŒ     â”‚    ë‚®ìŒ     â”‚    ì¤‘ê°„     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ìµœì í™” í¬ì¸íŠ¸:
ğŸ”¥ ReceiveAsync: ë²„í¼ í’€ë§ + ë©”ì‹œì§€ íŒŒì‹± ìµœì í™” í•„ìˆ˜
ğŸ”¥ SendAsync: íì‰ ì‹œìŠ¤í…œ + ë¶€ë¶„ ì „ì†¡ ì²˜ë¦¬ í•„ìš”
âš¡ UDP ë©”ì„œë“œë“¤: ë‹¨ìˆœí•˜ì§€ë§Œ íŒ¨í‚· ì†ì‹¤ ê³ ë ¤ í•„ìš”
```

ì´ëŸ¬í•œ APIë“¤ì„ ë§ˆìŠ¤í„°í•˜ë©´ **ì´ˆê³ ì„±ëŠ¥ ë„¤íŠ¸ì›Œí¬ ì• í”Œë¦¬ì¼€ì´ì…˜**ì„ êµ¬ì¶•í•  ìˆ˜ ìˆë‹¤! ğŸš€

