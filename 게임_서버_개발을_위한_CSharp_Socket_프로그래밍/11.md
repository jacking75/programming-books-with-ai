# 게임 서버 개발을 위한 C# Socket 프로그래밍

저자: 최흥배, Claude AI  

- .NET 9
- Windows 11
- Visual Studio Code, Visual Studio 2022 이상

-----  
  
# 11장: 오목 게임 서버 개발
  
## 11.1 오목 게임 서버 개요
오목 게임은 두 플레이어가 번갈아가며 바둑판에 돌을 놓고, 먼저 다섯 개의 돌을 일직선으로 연결하는 플레이어가 승리하는 게임이다. 이번 장에서는 이전에 개발한 네트워크 라이브러리를 활용하여 완전한 오목 게임 서버를 구현해 보겠다.

### 11.1.1 오목 게임 규칙
일반적인 오목 게임 규칙은 다음과 같다:
- 15x15 바둑판 사용
- 흑돌이 선공, 백돌이 후공
- 가로, 세로, 대각선 방향으로 정확히 5개의 돌을 연결하면 승리
- 일반적으로 금수(렌주룰) 적용: 흑은 33, 44, 장목(6목 이상) 금지

우리의 서버는 기본적인 오목 규칙을 구현하되, 선택적으로 렌주룰도 적용할 수 있게 설계하겠다.

### 11.1.2 서버 요구사항
오목 게임 서버는 다음과 같은 기능을 제공해야 한다:

1. 사용자 계정 관리 (로그인, 회원가입)
2. 매치메이킹 (상대방 찾기)
3. 게임 방 생성 및 관리
4. 턴 기반 게임 로직 처리
5. 게임 상태 관리 및 동기화
6. 승패 판정 및 기록
7. 랭킹 시스템
   

## 11.2 게임 상태 관리 설계
게임 상태 관리는 서버 개발에서 가장 중요한 부분 중 하나이다. 각 게임의 현재 상태를 추적하고, 클라이언트와 동기화해야 한다.

### 11.2.1 게임 상태 데이터 구조
먼저 오목 게임의 상태를 나타내는 데이터 구조를 설계한다.

```csharp
public enum StoneType
{
    None = 0,
    Black = 1,
    White = 2
}

public enum GameState
{
    Waiting,    // 게임 시작 대기
    Playing,    // 게임 진행 중
    Finished    // 게임 종료
}

public class GameRoom
{
    public Guid RoomId { get; private set; }
    public Player BlackPlayer { get; private set; }
    public Player WhitePlayer { get; private set; }
    public StoneType[,] Board { get; private set; }
    public GameState State { get; private set; }
    public StoneType CurrentTurn { get; private set; }
    public DateTime LastMoveTime { get; private set; }
    public bool IsRenjuRule { get; set; }
    
    // 게임 룸 생성
    public GameRoom(Player player1, Player player2, bool isRenjuRule = false)
    {
        RoomId = Guid.NewGuid();
        
        // 랜덤하게 흑백 결정
        if (Random.Shared.Next(2) == 0)
        {
            BlackPlayer = player1;
            WhitePlayer = player2;
        }
        else
        {
            BlackPlayer = player2;
            WhitePlayer = player1;
        }
        
        Board = new StoneType[15, 15];
        State = GameState.Waiting;
        CurrentTurn = StoneType.Black;
        LastMoveTime = DateTime.UtcNow;
        IsRenjuRule = isRenjuRule;
    }
    
    // 기타 메서드...
}

public class Player
{
    public Guid PlayerId { get; private set; }
    public string Username { get; private set; }
    public int Rating { get; set; }
    public PlayerState State { get; set; }
    
    // 생성자 및 기타 메서드...
}

public enum PlayerState
{
    Offline,
    Online,
    InGame,
    Spectating
}
```

### 11.2.2 게임 상태 머신
오목 게임의 상태 전이를 다음과 같이 설계한다.

```csharp
public class OmokGameStateMachine
{
    private readonly GameRoom _gameRoom;
    
    public OmokGameStateMachine(GameRoom gameRoom)
    {
        _gameRoom = gameRoom;
    }
    
    public void StartGame()
    {
        if (_gameRoom.State != GameState.Waiting)
            throw new InvalidOperationException("게임이 이미 시작되었습니다.");
        
        _gameRoom.State = GameState.Playing;
        // 게임 시작 이벤트 발생
    }
    
    public MoveResult PlaceStone(Player player, int x, int y)
    {
        // 현재 차례인지 확인
        StoneType currentPlayerType = GetPlayerStoneType(player);
        if (currentPlayerType != _gameRoom.CurrentTurn)
            return new MoveResult { Success = false, ErrorMessage = "당신의 차례가 아닙니다." };
        
        // 게임 상태 확인
        if (_gameRoom.State != GameState.Playing)
            return new MoveResult { Success = false, ErrorMessage = "게임이 진행 중이 아닙니다." };
        
        // 해당 위치가 유효한지 확인
        if (x < 0 || x >= 15 || y < 0 || y >= 15)
            return new MoveResult { Success = false, ErrorMessage = "유효하지 않은 위치입니다." };
        
        // 이미 돌이 놓여있는지 확인
        if (_gameRoom.Board[x, y] != StoneType.None)
            return new MoveResult { Success = false, ErrorMessage = "이미 돌이 놓여있는 위치입니다." };
        
        // 렌주룰 체크 (흑돌의 경우)
        if (_gameRoom.IsRenjuRule && currentPlayerType == StoneType.Black)
        {
            if (IsThreeThree(x, y, currentPlayerType))
                return new MoveResult { Success = false, ErrorMessage = "삼삼 금수입니다." };
            
            if (IsFourFour(x, y, currentPlayerType))
                return new MoveResult { Success = false, ErrorMessage = "사사 금수입니다." };
            
            if (IsOverline(x, y, currentPlayerType))
                return new MoveResult { Success = false, ErrorMessage = "장목(6목 이상)은 금지됩니다." };
        }
        
        // 돌 배치
        _gameRoom.Board[x, y] = currentPlayerType;
        _gameRoom.LastMoveTime = DateTime.UtcNow;
        
        // 승리 조건 확인
        if (CheckWin(x, y, currentPlayerType))
        {
            _gameRoom.State = GameState.Finished;
            return new MoveResult { 
                Success = true, 
                GameEnded = true, 
                Winner = player 
            };
        }
        
        // 무승부 확인 (보드가 가득 찬 경우)
        if (IsBoardFull())
        {
            _gameRoom.State = GameState.Finished;
            return new MoveResult { 
                Success = true, 
                GameEnded = true, 
                IsDraw = true 
            };
        }
        
        // 차례 변경
        _gameRoom.CurrentTurn = currentPlayerType == StoneType.Black ? StoneType.White : StoneType.Black;
        
        return new MoveResult { Success = true };
    }
    
    private StoneType GetPlayerStoneType(Player player)
    {
        if (player.PlayerId == _gameRoom.BlackPlayer.PlayerId)
            return StoneType.Black;
        if (player.PlayerId == _gameRoom.WhitePlayer.PlayerId)
            return StoneType.White;
        return StoneType.None;
    }
    
    // 승리 조건, 렌주룰, 기타 게임 로직 체크 메서드...
}

public class MoveResult
{
    public bool Success { get; set; }
    public string ErrorMessage { get; set; }
    public bool GameEnded { get; set; }
    public Player Winner { get; set; }
    public bool IsDraw { get; set; }
}
```

### 11.2.3 상태 관리 다이어그램
다음은 게임 상태 전이를 보여주는 다이어그램이다:

```
[대기 상태(Waiting)]
      │
      │ StartGame()
      ▼
[게임 중(Playing)] ◄────┐
      │                │
      │ PlaceStone()   │ 유효한 위치에 돌 놓기
      │                │ (승리 조건 미달성)
      ▼                │
 [승리 조건 확인] ────────┘
      │
      │ 승리 조건 달성 또는 무승부
      ▼
[게임 종료(Finished)]
```
  

## 11.3 턴 기반 게임 로직 구현
턴 기반 게임은 각 플레이어가 순서대로 행동을 취하는 방식으로 진행된다. 오목의 경우 흑돌, 백돌이 번갈아가면서 돌을 놓는다.

### 11.3.1 승리 조건 검사
5목 판정은 가로, 세로, 대각선 네 방향으로 연속된 돌을 검사하여 이루어진다.

```csharp
private bool CheckWin(int x, int y, StoneType stoneType)
{
    // 가로, 세로, 대각선 네 방향으로 연속된 돌 검사
    int[] dx = { 1, 0, 1, 1 };  // 가로, 세로, 대각선(\), 대각선(/)
    int[] dy = { 0, 1, 1, -1 };
    
    for (int dir = 0; dir < 4; dir++)
    {
        int count = 1;  // 현재 놓은 돌부터 시작
        
        // 정방향 확인
        for (int i = 1; i <= 5; i++)
        {
            int nx = x + dx[dir] * i;
            int ny = y + dy[dir] * i;
            
            if (nx < 0 || nx >= 15 || ny < 0 || ny >= 15 || _gameRoom.Board[nx, ny] != stoneType)
                break;
                
            count++;
        }
        
        // 역방향 확인
        for (int i = 1; i <= 5; i++)
        {
            int nx = x - dx[dir] * i;
            int ny = y - dy[dir] * i;
            
            if (nx < 0 || nx >= 15 || ny < 0 || ny >= 15 || _gameRoom.Board[nx, ny] != stoneType)
                break;
                
            count++;
        }
        
        // 렌주룰이 적용된 경우 흑돌은 정확히 5개, 백돌은 5개 이상
        if (_gameRoom.IsRenjuRule && stoneType == StoneType.Black)
        {
            if (count == 5)
                return true;
        }
        else
        {
            // 렌주룰이 적용되지 않거나 백돌인 경우 5개 이상
            if (count >= 5)
                return true;
        }
    }
    
    return false;
}
```

### 11.3.2 렌주룰 구현 (금수 처리)
렌주룰에서는 흑돌에게 다음과 같은 제약이 있다:
1. 삼삼금수: 한 수로 인해 3-3 상황이 두 개 이상 생기는 것 금지
2. 사사금수: 한 수로 인해 4-4 상황이 두 개 이상 생기는 것 금지
3. 장목금수: 5목을 초과하는 6목 이상 금지

다음은 삼삼금수 판정 메서드의 예이다:

```csharp
private bool IsThreeThree(int x, int y, StoneType stoneType)
{
    if (stoneType != StoneType.Black)
        return false;
        
    // 임시로 돌 배치
    _gameRoom.Board[x, y] = stoneType;
    
    int threeCount = 0;
    
    // 8방향 체크
    int[] dx = { 1, 1, 0, -1, -1, -1, 0, 1 };
    int[] dy = { 0, 1, 1, 1, 0, -1, -1, -1 };
    
    for (int dir = 0; dir < 4; dir++)
    {
        // 양쪽 방향으로 열린 3 체크
        if (IsOpenThree(x, y, dir, stoneType))
            threeCount++;
            
        // 반대 방향으로 열린 3 체크
        if (IsOpenThree(x, y, dir + 4, stoneType))
            threeCount++;
    }
    
    // 돌 제거 (원상복구)
    _gameRoom.Board[x, y] = StoneType.None;
    
    return threeCount >= 2;
}

private bool IsOpenThree(int x, int y, int direction, StoneType stoneType)
{
    // 열린 3 판정 로직...
    // 복잡한 로직이므로 실제 구현은 매우 상세할 수 있음
    return false; // 예시
}
```

### 11.3.3 타임아웃 처리
플레이어가 일정 시간 동안 돌을 놓지 않으면 자동으로 턴을 넘기거나 게임을 종료하는 로직도 필요하다.  
  
```csharp
public void CheckTimeout()
{
    if (_gameRoom.State != GameState.Playing)
        return;
        
    TimeSpan elapsed = DateTime.UtcNow - _gameRoom.LastMoveTime;
    
    // 60초 타임아웃
    if (elapsed.TotalSeconds > 60)
    {
        // 현재 턴 플레이어가 시간 초과
        Player timeoutPlayer = _gameRoom.CurrentTurn == StoneType.Black 
            ? _gameRoom.BlackPlayer 
            : _gameRoom.WhitePlayer;
            
        Player winner = _gameRoom.CurrentTurn == StoneType.Black 
            ? _gameRoom.WhitePlayer 
            : _gameRoom.BlackPlayer;
            
        _gameRoom.State = GameState.Finished;
        
        // 타임아웃 이벤트 발생
        OnGameTimeout(timeoutPlayer, winner);
    }
}
```
  

## 11.4 매치메이킹 시스템
매치메이킹은 비슷한 실력의 플레이어를 찾아 게임을 시작할 수 있도록 도와주는 시스템이다.

### 11.4.1 매치메이킹 큐 구현

```csharp
public class MatchmakingSystem
{
    private readonly List<MatchRequest> _waitingPlayers = new();
    private readonly object _lockObject = new();
    private readonly GameRoomManager _roomManager;
    
    public MatchmakingSystem(GameRoomManager roomManager)
    {
        _roomManager = roomManager;
    }
    
    public void EnqueuePlayer(Player player, bool useRenjuRule)
    {
        lock (_lockObject)
        {
            // 이미 큐에 있는지 확인
            if (_waitingPlayers.Any(req => req.Player.PlayerId == player.PlayerId))
                return;
                
            _waitingPlayers.Add(new MatchRequest
            {
                Player = player,
                JoinTime = DateTime.UtcNow,
                UseRenjuRule = useRenjuRule
            });
            
            // 매치메이킹 시도
            TryMatchmaking();
        }
    }
    
    public void DequeuePlayer(Player player)
    {
        lock (_lockObject)
        {
            _waitingPlayers.RemoveAll(req => req.Player.PlayerId == player.PlayerId);
        }
    }
    
    private void TryMatchmaking()
    {
        if (_waitingPlayers.Count < 2)
            return;
            
        // 대기 시간이 긴 플레이어부터 정렬
        _waitingPlayers.Sort((a, b) => a.JoinTime.CompareTo(b.JoinTime));
        
        for (int i = 0; i < _waitingPlayers.Count; i++)
        {
            var request1 = _waitingPlayers[i];
            
            for (int j = i + 1; j < _waitingPlayers.Count; j++)
            {
                var request2 = _waitingPlayers[j];
                
                // 렌주룰 설정이 같은지 확인
                if (request1.UseRenjuRule != request2.UseRenjuRule)
                    continue;
                    
                // 레이팅 차이가 200 이내인 경우 매치
                int ratingDiff = Math.Abs(request1.Player.Rating - request2.Player.Rating);
                
                // 대기 시간에 따라 허용 레이팅 차이 증가
                TimeSpan waitTime = DateTime.UtcNow - request1.JoinTime;
                int allowedDiff = 200 + (int)waitTime.TotalMinutes * 50;
                
                if (ratingDiff <= allowedDiff)
                {
                    // 매치 성사
                    var gameRoom = _roomManager.CreateRoom(request1.Player, request2.Player, request1.UseRenjuRule);
                    
                    // 매치 성공 이벤트 발생
                    OnMatchCreated(gameRoom);
                    
                    // 큐에서 제거
                    _waitingPlayers.RemoveAt(j);
                    _waitingPlayers.RemoveAt(i);
                    
                    // 다시 매치메이킹 시도
                    TryMatchmaking();
                    return;
                }
            }
        }
    }
    
    // 이벤트 핸들러
    private void OnMatchCreated(GameRoom gameRoom)
    {
        // 매치 성사 처리...
    }
}

public class MatchRequest
{
    public Player Player { get; set; }
    public DateTime JoinTime { get; set; }
    public bool UseRenjuRule { get; set; }
}
```

### 11.4.2 ELO 레이팅 시스템
플레이어의 실력을 평가하기 위한 ELO 레이팅 시스템을 구현한다:

```csharp
public class RatingSystem
{
    // K 요소: 레이팅 변동 크기를 결정
    private const int K_FACTOR = 32;
    
    public (int newRating1, int newRating2) CalculateNewRatings(
        int rating1, int rating2, GameResult result)
    {
        // 예상 승률 계산
        double expectedScore1 = 1.0 / (1.0 + Math.Pow(10, (rating2 - rating1) / 400.0));
        double expectedScore2 = 1.0 / (1.0 + Math.Pow(10, (rating1 - rating2) / 400.0));
        
        // 실제 점수
        double actualScore1, actualScore2;
        
        switch (result)
        {
            case GameResult.Player1Win:
                actualScore1 = 1.0;
                actualScore2 = 0.0;
                break;
            case GameResult.Player2Win:
                actualScore1 = 0.0;
                actualScore2 = 1.0;
                break;
            case GameResult.Draw:
                actualScore1 = 0.5;
                actualScore2 = 0.5;
                break;
            default:
                throw new ArgumentException("잘못된 게임 결과입니다.");
        }
        
        // 새 레이팅 계산
        int newRating1 = (int)(rating1 + K_FACTOR * (actualScore1 - expectedScore1));
        int newRating2 = (int)(rating2 + K_FACTOR * (actualScore2 - expectedScore2));
        
        return (newRating1, newRating2);
    }
}

public enum GameResult
{
    Player1Win,
    Player2Win,
    Draw
}
```
  

## 11.5 게임 결과 처리와 랭킹 시스템

### 11.5.1 게임 결과 저장
게임이 종료된 후 결과를 데이터베이스에 저장하는 로직이다:

```csharp
public class GameResultManager
{
    private readonly RatingSystem _ratingSystem;
    private readonly IGameResultRepository _repository;
    
    public GameResultManager(RatingSystem ratingSystem, IGameResultRepository repository)
    {
        _ratingSystem = ratingSystem;
        _repository = repository;
    }
    
    public async Task ProcessGameResult(GameRoom gameRoom, Player winner, bool isDraw)
    {
        var blackPlayer = gameRoom.BlackPlayer;
        var whitePlayer = gameRoom.WhitePlayer;
        
        GameResult result;
        if (isDraw)
        {
            result = GameResult.Draw;
        }
        else if (winner.PlayerId == blackPlayer.PlayerId)
        {
            result = GameResult.Player1Win;
        }
        else
        {
            result = GameResult.Player2Win;
        }
        
        // 새 레이팅 계산
        var (newBlackRating, newWhiteRating) = _ratingSystem.CalculateNewRatings(
            blackPlayer.Rating, whitePlayer.Rating, result);
            
        // 플레이어 레이팅 업데이트
        blackPlayer.Rating = newBlackRating;
        whitePlayer.Rating = newWhiteRating;
        
        // 게임 결과 저장
        var gameResult = new GameResultRecord
        {
            GameId = gameRoom.RoomId,
            BlackPlayerId = blackPlayer.PlayerId,
            WhitePlayerId = whitePlayer.PlayerId,
            WinnerId = isDraw ? null : winner.PlayerId,
            IsDraw = isDraw,
            BlackRatingBefore = blackPlayer.Rating - (newBlackRating - blackPlayer.Rating),
            WhiteRatingBefore = whitePlayer.Rating - (newWhiteRating - whitePlayer.Rating),
            BlackRatingAfter = newBlackRating,
            WhiteRatingAfter = newWhiteRating,
            GameStartTime = gameRoom.CreationTime,
            GameEndTime = DateTime.UtcNow,
            IsRenjuRule = gameRoom.IsRenjuRule
        };
        
        await _repository.SaveGameResultAsync(gameResult);
        
        // 플레이어 정보 업데이트
        await _repository.UpdatePlayerRatingAsync(blackPlayer.PlayerId, newBlackRating);
        await _repository.UpdatePlayerRatingAsync(whitePlayer.PlayerId, newWhiteRating);
    }
}

public class GameResultRecord
{
    public Guid GameId { get; set; }
    public Guid BlackPlayerId { get; set; }
    public Guid WhitePlayerId { get; set; }
    public Guid? WinnerId { get; set; }
    public bool IsDraw { get; set; }
    public int BlackRatingBefore { get; set; }
    public int WhiteRatingBefore { get; set; }
    public int BlackRatingAfter { get; set; }
    public int WhiteRatingAfter { get; set; }
    public DateTime GameStartTime { get; set; }
    public DateTime GameEndTime { get; set; }
    public bool IsRenjuRule { get; set; }
}

public interface IGameResultRepository
{
    Task SaveGameResultAsync(GameResultRecord result);
    Task UpdatePlayerRatingAsync(Guid playerId, int newRating);
    Task<List<GameResultRecord>> GetPlayerGameHistoryAsync(Guid playerId, int count);
    Task<List<PlayerRankingRecord>> GetTopRankingPlayersAsync(int count);
}
```

### 11.5.2 랭킹 시스템 구현

```csharp
public class RankingSystem
{
    private readonly IGameResultRepository _repository;
    
    public RankingSystem(IGameResultRepository repository)
    {
        _repository = repository;
    }
    
    public async Task<List<PlayerRankingRecord>> GetTopPlayersAsync(int count = 100)
    {
        return await _repository.GetTopRankingPlayersAsync(count);
    }
    
    public async Task<PlayerStats> GetPlayerStatsAsync(Guid playerId)
    {
        var gameHistory = await _repository.GetPlayerGameHistoryAsync(playerId, 1000);
        
        int totalGames = gameHistory.Count;
        int wins = gameHistory.Count(g => g.WinnerId == playerId);
        int losses = gameHistory.Count(g => g.WinnerId != null && g.WinnerId != playerId);
        int draws = gameHistory.Count(g => g.IsDraw);
        
        // 승률 계산
        double winRate = totalGames > 0 ? (double)wins / totalGames * 100 : 0;
        
        // 최근 10경기 성적
        var recent10Games = gameHistory.OrderByDescending(g => g.GameEndTime).Take(10).ToList();
        int recent10Wins = recent10Games.Count(g => g.WinnerId == playerId);
        
        return new PlayerStats
        {
            PlayerId = playerId,
            TotalGames = totalGames,
            Wins = wins,
            Losses = losses,
            Draws = draws,
            WinRate = winRate,
            Recent10Wins = recent10Wins,
            Recent10Games = recent10Games.Count
        };
    }
}

public class PlayerRankingRecord
{
    public Guid PlayerId { get; set; }
    public string Username { get; set; }
    public int Rating { get; set; }
    public int Rank { get; set; }
    public int TotalGames { get; set; }
    public int Wins { get; set; }
    public double WinRate { get; set; }
}

public class PlayerStats
{
    public Guid PlayerId { get; set; }
    public int TotalGames { get; set; }
    public int Wins { get; set; }
    public int Losses { get; set; }
    public int Draws { get; set; }
    public double WinRate { get; set; }
    public int Recent10Wins { get; set; }
    public int Recent10Games { get; set; }
}
```
  

## 11.6 클라이언트-서버 통신 프로토콜
오목 게임을 위한 통신 프로토콜을 설계한다.

### 11.6.1 메시지 형식 정의

```csharp
// 기본 메시지 구조
public abstract class GameMessage
{
    public string MessageType { get; set; }
}

// 클라이언트 -> 서버 메시지
public class PlaceStoneRequest : GameMessage
{
    public int X { get; set; }
    public int Y { get; set; }
}

public class JoinMatchmakingRequest : GameMessage
{
    public bool UseRenjuRule { get; set; }
}

public class LeaveMatchmakingRequest : GameMessage
{
}

public class ResignGameRequest : GameMessage
{
}

// 서버 -> 클라이언트 메시지
public class GameStateUpdate : GameMessage
{
    public StoneType[,] Board { get; set; }
    public StoneType CurrentTurn { get; set; }
    public GameState State { get; set; }
}

public class MatchFoundNotification : GameMessage
{
    public Guid GameId { get; set; }
    public Player Opponent { get; set; }
    public StoneType YourStoneType { get; set; }
    public bool IsRenjuRule { get; set; }
}

public class GameResultNotification : GameMessage
{
    public bool IsWin { get; set; }
    public bool IsDraw { get; set; }
    public int NewRating { get; set; }
    public int RatingChange { get; set; }
}

public class IllegalMoveNotification : GameMessage
{
    public string Reason { get; set; }
}
```
  
### 11.6.2 메시지 처리기 구현

```csharp
public class GameMessageHandler
{
    private readonly GameRoomManager _roomManager;
    private readonly MatchmakingSystem _matchmakingSystem;
    private readonly PlayerManager _playerManager;
    
    public GameMessageHandler(
        GameRoomManager roomManager,
        MatchmakingSystem matchmakingSystem,
        PlayerManager playerManager)
    {
        _roomManager = roomManager;
        _matchmakingSystem = matchmakingSystem;
        _playerManager = playerManager;
    }
    
    public async Task HandleMessageAsync(ClientSession session, string messageJson)
    {
        // JSON 파싱하여 메시지 타입 확인
        var messageType = JsonDocument.Parse(messageJson)
            .RootElement.GetProperty("MessageType").GetString();
            
        switch (messageType)
        {
            case "PlaceStoneRequest":
                await HandlePlaceStoneRequestAsync(session, messageJson);
                break;
            case "JoinMatchmakingRequest":
                await HandleJoinMatchmakingRequestAsync(session, messageJson);
                break;
            case "LeaveMatchmakingRequest":
                await HandleLeaveMatchmakingRequestAsync(session, messageJson);
                break;
            case "ResignGameRequest":
                await HandleResignGameRequestAsync(session, messageJson);
                break;
            default:
                // 알 수 없는 메시지 처리
                break;
        }
    }
    
    private async Task HandlePlaceStoneRequestAsync(ClientSession session, string messageJson)
    {
        var request = JsonSerializer.Deserialize<PlaceStoneRequest>(messageJson);
        var player = _playerManager.GetPlayerBySessionId(session.SessionId);
        
        if (player == null)
            return;
            
        var gameRoom = _roomManager.GetPlayerCurrentRoom(player.PlayerId);
        
        if (gameRoom == null)
        {
            await session.SendAsync(new IllegalMoveNotification
            {
                MessageType = "IllegalMoveNotification",
                Reason = "현재 게임 중이 아닙니다."
            });
            return;
        }
        
        // 게임 상태 머신을 통해 돌 놓기 시도
        var stateMachine = new OmokGameStateMachine(gameRoom);
        var result = stateMachine.PlaceStone(player, request.X, request.Y);
        
        if (!result.Success)
        {
            await session.SendAsync(new IllegalMoveNotification
            {
                MessageType = "IllegalMoveNotification",
                Reason = result.ErrorMessage
            });
            return;
        }
        
        // 게임 상태 업데이트를 양쪽 플레이어에게 전송
        await BroadcastGameStateAsync(gameRoom);
        
        // 게임이 종료된 경우 결과 처리
        if (result.GameEnded)
        {
            await HandleGameEndAsync(gameRoom, result.Winner, result.IsDraw);
        }
    }
    
    // 다른 메시지 핸들러 메서드...
    
    private async Task BroadcastGameStateAsync(GameRoom gameRoom)
    {
        var blackSession = _playerManager.GetPlayerSession(gameRoom.BlackPlayer.PlayerId);
        var whiteSession = _playerManager.GetPlayerSession(gameRoom.WhitePlayer.PlayerId);
        
        var gameStateUpdate = new GameStateUpdate
        {
            MessageType = "GameStateUpdate",
            Board = gameRoom.Board,
            CurrentTurn = gameRoom.CurrentTurn,
            State = gameRoom.State
        };
        
        if (blackSession != null)
            await blackSession.SendAsync(gameStateUpdate);
            
        if (whiteSession != null)
            await whiteSession.SendAsync(gameStateUpdate);
    }
    
    private async Task HandleGameEndAsync(GameRoom gameRoom, Player winner, bool isDraw)
    {
        // 게임 결과 처리 및 저장...
    }
}
```
  

## 11.7 오목 게임 서버 구현 완성
여기서는 앞에서 만든 모든 컴포넌트를 조합하여 완전한 오목 게임 서버를 구현한다.

```csharp
public class OmokGameServer
{
    private readonly TcpListener _listener;
    private readonly GameRoomManager _roomManager;
    private readonly PlayerManager _playerManager;
    private readonly MatchmakingSystem _matchmakingSystem;
    private readonly GameResultManager _gameResultManager;
    private readonly RankingSystem _rankingSystem;
    private readonly GameMessageHandler _messageHandler;
    
    private bool _isRunning;
    
    public OmokGameServer(int port)
    {
        _listener = new TcpListener(IPAddress.Any, port);
        
        // 컴포넌트 초기화
        var gameResultRepository = new GameResultRepository(); // DB 연결 구현 필요
        
        _roomManager = new GameRoomManager();
        _playerManager = new PlayerManager();
        _matchmakingSystem = new MatchmakingSystem(_roomManager);
        
        var ratingSystem = new RatingSystem();
        _gameResultManager = new GameResultManager(ratingSystem, gameResultRepository);
        _rankingSystem = new RankingSystem(gameResultRepository);
        
        _messageHandler = new GameMessageHandler(_roomManager, _matchmakingSystem, _playerManager);
    }
    
    public async Task StartAsync()
    {
        _listener.Start();
        _isRunning = true;
        
        Console.WriteLine($"오목 게임 서버가 시작되었습니다.");
        
        // 타임아웃 체크 타이머 시작
        StartTimeoutCheckerAsync();
        
        // 클라이언트 연결 수락 루프
        while (_isRunning)
        {
            try
            {
                var tcpClient = await _listener.AcceptTcpClientAsync();
                _ = HandleClientAsync(tcpClient);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"클라이언트 연결 수락 중 오류: {ex.Message}");
            }
        }
    }
    
    private async Task HandleClientAsync(TcpClient tcpClient)
    {
        var clientSession = new ClientSession(tcpClient);
        
        try
        {
            // 세션 초기화 및 인증 처리
            await clientSession.InitializeAsync();
            
            // 메시지 처리 루프
            while (clientSession.IsConnected)
            {
                var message = await clientSession.ReceiveAsync();
                if (message == null)
                    break;
                
                await _messageHandler.HandleMessageAsync(clientSession, message);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"클라이언트 처리 중 오류: {ex.Message}");
        }
        finally
        {
            // 클라이언트 연결 해제 처리
            var player = _playerManager.GetPlayerBySessionId(clientSession.SessionId);
            if (player != null)
            {
                _matchmakingSystem.DequeuePlayer(player);
                var gameRoom = _roomManager.GetPlayerCurrentRoom(player.PlayerId);
                if (gameRoom != null)
                {
                    // 게임 중이었다면 기권 처리
                    HandlePlayerDisconnect(player, gameRoom);
                }
                
                _playerManager.RemovePlayerSession(player.PlayerId);
            }
            
            clientSession.Dispose();
        }
    }
    
    private void HandlePlayerDisconnect(Player player, GameRoom gameRoom)
    {
        // 게임이 아직 진행 중이라면 기권 처리
        if (gameRoom.State == GameState.Playing)
        {
            Player opponent = gameRoom.BlackPlayer.PlayerId == player.PlayerId
                ? gameRoom.WhitePlayer
                : gameRoom.BlackPlayer;
                
            gameRoom.State = GameState.Finished;
            
            // 기권 처리 및 결과 저장
            _gameResultManager.ProcessGameResult(gameRoom, opponent, false);
            
            // 상대방에게 알림
            var opponentSession = _playerManager.GetPlayerSession(opponent.PlayerId);
            if (opponentSession != null)
            {
                opponentSession.SendAsync(new GameResultNotification
                {
                    MessageType = "GameResultNotification",
                    IsWin = true,
                    IsDraw = false,
                    NewRating = opponent.Rating,
                    RatingChange = 0 // 계산 필요
                });
            }
        }
    }
    
    private async Task StartTimeoutCheckerAsync()
    {
        while (_isRunning)
        {
            try
            {
                // 모든 진행 중인 게임에 대해 타임아웃 체크
                foreach (var gameRoom in _roomManager.GetActiveGameRooms())
                {
                    var stateMachine = new OmokGameStateMachine(gameRoom);
                    stateMachine.CheckTimeout();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"타임아웃 체크 중 오류: {ex.Message}");
            }
            
            await Task.Delay(1000); // 1초마다 체크
        }
    }
    
    public void Stop()
    {
        _isRunning = false;
        _listener.Stop();
        Console.WriteLine("오목 게임 서버가 중지되었습니다.");
    }
}
```
  

## 11.8 오목 게임 서버의 테스트와 디버깅

### 11.8.1 단위 테스트 작성
오목 게임 서버의 핵심 로직에 대한 단위 테스트를 작성한다.

```csharp
public class OmokGameLogicTests
{
    [Fact]
    public void CheckWin_HorizontalFiveStonesInARow_ReturnsTrue()
    {
        // Arrange
        var blackPlayer = new Player { PlayerId = Guid.NewGuid(), Username = "Black" };
        var whitePlayer = new Player { PlayerId = Guid.NewGuid(), Username = "White" };
        var gameRoom = new GameRoom(blackPlayer, whitePlayer);
        var stateMachine = new OmokGameStateMachine(gameRoom);
        
        // 가로로 5개의 돌 놓기
        for (int i = 0; i < 5; i++)
        {
            if (i % 2 == 0) // 흑돌 차례
            {
                stateMachine.PlaceStone(blackPlayer, 3 + i, 7);
            }
            else // 백돌 차례
            {
                stateMachine.PlaceStone(whitePlayer, 3 + i, 8);
            }
        }
        
        // Act
        var result = stateMachine.PlaceStone(blackPlayer, 8, 7);
        
        // Assert
        Assert.True(result.Success);
        Assert.True(result.GameEnded);
        Assert.Equal(blackPlayer, result.Winner);
        Assert.False(result.IsDraw);
    }
    
    [Fact]
    public void PlaceStone_SamePosition_ReturnsFalse()
    {
        // Arrange
        var blackPlayer = new Player { PlayerId = Guid.NewGuid(), Username = "Black" };
        var whitePlayer = new Player { PlayerId = Guid.NewGuid(), Username = "White" };
        var gameRoom = new GameRoom(blackPlayer, whitePlayer);
        var stateMachine = new OmokGameStateMachine(gameRoom);
        
        // Act
        var result1 = stateMachine.PlaceStone(blackPlayer, 7, 7);
        var result2 = stateMachine.PlaceStone(whitePlayer, 7, 7);
        
        // Assert
        Assert.True(result1.Success);
        Assert.False(result2.Success);
        Assert.Contains("이미 돌이 놓여있는 위치입니다", result2.ErrorMessage);
    }
    
    // 더 많은 테스트 케이스...
}
```

### 11.8.2 통합 테스트

```csharp
public class OmokGameServerIntegrationTests
{
    [Fact]
    public async Task CompleteGameFlow_Success()
    {
        // Arrange
        var server = new OmokGameServer(8080);
        var client1 = new TestClient();
        var client2 = new TestClient();
        
        // Start server
        var serverTask = server.StartAsync();
        
        // Connect clients
        await client1.ConnectAsync("localhost", 8080);
        await client2.ConnectAsync("localhost", 8080);
        
        // Login
        await client1.LoginAsync("player1", "password1");
        await client2.LoginAsync("player2", "password2");
        
        // Join matchmaking
        await client1.JoinMatchmakingAsync(false); // 렌주룰 사용 안 함
        await client2.JoinMatchmakingAsync(false);
        
        // Wait for match
        var matchNotification1 = await client1.WaitForMessageAsync<MatchFoundNotification>();
        var matchNotification2 = await client2.WaitForMessageAsync<MatchFoundNotification>();
        
        Assert.NotNull(matchNotification1);
        Assert.NotNull(matchNotification2);
        Assert.Equal(matchNotification1.GameId, matchNotification2.GameId);
        
        // Play game
        if (matchNotification1.YourStoneType == StoneType.Black)
        {
            // client1이 흑돌
            await PlayGameAsync(client1, client2);
        }
        else
        {
            // client2가 흑돌
            await PlayGameAsync(client2, client1);
        }
        
        // Cleanup
        server.Stop();
    }
    
    private async Task PlayGameAsync(TestClient blackClient, TestClient whiteClient)
    {
        // 흑돌 플레이어부터 시작하여 번갈아가며 돌 놓기
        // 간단한 패턴으로 승리 조건 달성
        
        // 흑돌 (7,7)
        await blackClient.PlaceStoneAsync(7, 7);
        var update1 = await whiteClient.WaitForMessageAsync<GameStateUpdate>();
        Assert.Equal(StoneType.White, update1.CurrentTurn);
        
        // 백돌 (8,8)
        await whiteClient.PlaceStoneAsync(8, 8);
        var update2 = await blackClient.WaitForMessageAsync<GameStateUpdate>();
        Assert.Equal(StoneType.Black, update2.CurrentTurn);
        
        // 흑돌 (7,8)
        await blackClient.PlaceStoneAsync(7, 8);
        await whiteClient.WaitForMessageAsync<GameStateUpdate>();
        
        // 백돌 (8,7)
        await whiteClient.PlaceStoneAsync(8, 7);
        await blackClient.WaitForMessageAsync<GameStateUpdate>();
        
        // 흑돌 (7,9)
        await blackClient.PlaceStoneAsync(7, 9);
        await whiteClient.WaitForMessageAsync<GameStateUpdate>();
        
        // 백돌 (8,6)
        await whiteClient.PlaceStoneAsync(8, 6);
        await blackClient.WaitForMessageAsync<GameStateUpdate>();
        
        // 흑돌 (7,10)
        await blackClient.PlaceStoneAsync(7, 10);
        await whiteClient.WaitForMessageAsync<GameStateUpdate>();
        
        // 백돌 (8,5)
        await whiteClient.PlaceStoneAsync(8, 5);
        await blackClient.WaitForMessageAsync<GameStateUpdate>();
        
        // 흑돌 (7,11) - 흑돌 승리 (세로로 5개 연결)
        await blackClient.PlaceStoneAsync(7, 11);
        
        // 게임 결과 확인
        var blackResult = await blackClient.WaitForMessageAsync<GameResultNotification>();
        var whiteResult = await whiteClient.WaitForMessageAsync<GameResultNotification>();
        
        Assert.True(blackResult.IsWin);
        Assert.False(whiteResult.IsWin);
    }
}

// 테스트용 클라이언트 구현
public class TestClient
{
    private TcpClient _client;
    private NetworkStream _stream;
    private readonly Queue<string> _messageQueue = new Queue<string>();
    
    public async Task ConnectAsync(string host, int port)
    {
        _client = new TcpClient();
        await _client.ConnectAsync(host, port);
        _stream = _client.GetStream();
        
        // 메시지 수신 루프 시작
        _ = ReceiveLoopAsync();
    }
    
    // 구현 생략...
}
```
  

## 11.9 학습 내용 확인 과제
이 장에서 배운 내용을 확인하기 위한 과제이다.

### 과제 1: 오목 게임 기능 확장
다음 기능을 오목 게임 서버에 추가해보세요:

1. **관전 기능**: 현재 진행 중인 게임을 다른 사용자가 관전할 수 있는 기능을 구현하세요.
   - 관전자 목록 관리
   - 관전자에게 게임 상태 동기화
   - 관전 채팅 기능

2. **게임 기록 재생 기능**: 이전에 진행된 게임의 기록을 저장하고, 다시 재생할 수 있는 기능을 구현하세요.
   - 각 턴마다 돌 위치 기록
   - 기록된 게임 목록 조회
   - 선택한 게임 재생 (턴별로 진행)

3. **토너먼트 시스템**: 여러 플레이어가 참여하는 토너먼트를 개최하고 관리하는 기능을 구현하세요.
   - 토너먼트 생성 및 참가 신청
   - 대진표 자동 생성
   - 경기 결과에 따른 진출자 관리
   - 우승자 결정 및 상금 지급

### 과제 2: 성능 최적화
1. 다음 시나리오에서 오목 게임 서버의 성능을 분석하고 최적화하세요:
   - 동시 접속자 1,000명
   - 동시 진행 게임 500개
   
2. 다음 지표를 측정하고 개선해보세요:
   - 메모리 사용량
   - CPU 사용률
   - 응답 시간
   - 네트워크 대역폭 사용량

3. 다음 기법을 적용하여 최적화를 진행하세요:
   - 메시지 배치 처리
   - 객체 풀링
   - 비동기 처리 최적화
   - 데이터베이스 쿼리 최적화

### 과제 3: 보안 강화
1. 다음 보안 위협에 대응하는 방안을 구현하세요:
   - 패킷 조작 방지
   - DDoS 공격 대응
   - 치팅 방지 (불법 프로그램 사용)
   - 계정 해킹 방지

2. 다음 보안 기능을 추가하세요:
   - 패킷 암호화
   - 세션 토큰 관리
   - 비정상 행동 탐지
   - IP 차단 시스템

### 과제 4: 실제 서비스 배포
1. 개발한 오목 게임 서버를 클라우드 환경(AWS, Azure, GCP 등)에 배포하세요.
2. 로드 밸런싱과 오토 스케일링을 구성하세요.
3. 장애 복구 계획을 수립하고 테스트하세요.
4. 모니터링 시스템을 구축하여 서버 상태를 실시간으로 확인할 수 있게 하세요.