# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 5: 스마트 포인터로 완성하는 메모리 안전성

## 들어가며: 포인터의 악명을 벗기다
C++에 대해 비판할 때 가장 많이 나오는 말 중 하나가 "포인터 때문에 위험하다"는 것이다. 하지만 이것은 과거 C++의 이야기이다. Modern C++의 스마트 포인터는 이 악명을 완전히 씻어내준다.

스마트 포인터를 이해하면 다음을 깨닫게 된다:
- 메모리 누수가 거의 불가능해진다
- 수동으로 delete를 호출할 필요가 없다
- 포인터의 소유권이 명확해진다
- Rust의 소유권 개념을 C++에서도 구현할 수 있다
  
이 장에서는 스마트 포인터의 세 가지 종류(`unique_ptr`, `shared_ptr`, `weak_ptr`)를 자세히 살펴보고, 이들을 어떻게 올바르게 사용하는지 배우겠다.

---  
  
## 5.1 unique_ptr의 완벽 활용법

### 5.1.1 unique_ptr이란?
`unique_ptr`은 "오직 한 사람만 소유할 수 있는 포인터"이다. 말 그대로 유일한 소유권을 가진다.  

**과거의 위험한 코드:**
```cpp
void processData() {
    int* data = new int[1000];
    
    // 어딘가에서 예외가 발생하면?
    doSomething(data);
    
    delete[] data;  // 실행되지 않을 수도 있다!
}
```

**Modern C++의 안전한 코드:**
```cpp
void processData() {
    std::unique_ptr<int[]> data(new int[1000]);
    
    // 예외가 발생해도, 함수를 나가도
    // data는 자동으로 메모리를 해제합니다
    doSomething(data.get());
}  // 여기서 자동으로 delete[] data 실행
```

`unique_ptr`을 선언하는 가장 권장되는 방식은 `std::make_unique`를 사용하는 것이다:

```cpp
#include <memory>

void processData() {
    auto data = std::make_unique<int[]>(1000);
    
    // auto로 타입을 추론하면 더 간결합니다
    doSomething(data.get());
}  // 자동 해제
```

### 5.1.2 소유권의 전달 (Move Semantics)
`unique_ptr`의 핵심은 **소유권을 한 번에 하나만 가질 수 있다**는 것이다. 소유권을 전달하려면 move를 사용한다.

```cpp
class FileHandler {
private:
    std::unique_ptr<FILE, decltype(&fclose)> file;
    
public:
    FileHandler(const std::string& filename) 
        : file(fopen(filename.c_str(), "r"), &fclose) {
        if (!file) {
            throw std::runtime_error("파일을 열 수 없습니다");
        }
    }
};

void example() {
    auto handler1 = std::make_unique<FileHandler>("test.txt");
    
    // 소유권을 handler2로 이전
    auto handler2 = std::move(handler1);
    
    // handler1은 이제 nullptr입니다
    // handler2만 리소스를 소유합니다
}  // handler2가 해제되며 파일 닫힘
```

### 5.1.3 함수에서 unique_ptr 반환하기
팩토리 패턴(Factory Pattern)에서 `unique_ptr`을 반환하면 소유권이 명확해진다:

```cpp
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
};

class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : radius(r) {}
    void draw() const override {
        std::cout << "원을 그립니다 (반지름: " << radius << ")\n";
    }
};

// 호출자가 생성된 객체의 소유권을 가집니다
std::unique_ptr<Shape> createShape(const std::string& type) {
    if (type == "circle") {
        return std::make_unique<Circle>(5.0);
    }
    throw std::invalid_argument("알 수 없는 도형");
}

int main() {
    auto shape = createShape("circle");
    shape->draw();
    
    // shape이 스코프를 벗어나면 자동 해제
}
```

### 5.1.4 배열과 커스텀 deleter
`unique_ptr`은 단일 객체뿐 아니라 배열도 관리한다:

```cpp
// 배열 관리
void arrayExample() {
    auto arr = std::make_unique<int[]>(100);
    arr[0] = 42;
    
    // 자동으로 delete[]가 호출됩니다
}

// 커스텀 deleter
void customDeleterExample() {
    auto ptr = std::unique_ptr<FILE, decltype(&fclose)>(
        fopen("data.txt", "r"),
        &fclose
    );
    
    if (ptr) {
        // FILE 사용
    }
    // ptr이 스코프를 벗어나면 fclose가 호출됩니다
}

// C 라이브러리와의 통합도 안전합니다
auto createBuffer = []() {
    auto buffer = std::unique_ptr<uint8_t[], decltype(&free)>(
        static_cast<uint8_t*>(malloc(1024)),
        &free
    );
    return buffer;
};
```

### 5.1.5 C++ Core Guidelines와 unique_ptr

**Rule: R.20: Use `unique_ptr` to represent exclusive ownership**

```cpp
// ✓ Good
std::unique_ptr<Widget> createWidget() {
    return std::make_unique<Widget>();
}

// ✗ Bad
Widget* createWidget() {
    return new Widget();  // 소유권이 불명확합니다
}
```

---
   

## 5.2 shared_ptr과 참조 카운팅 전략

### 5.2.1 shared_ptr이 필요한 경우
`unique_ptr`은 훌륭하지만, 때로는 여러 객체가 같은 리소스를 공유해야 할 때가 있다. 이때가 바로 `shared_ptr`의 출장이다.

```cpp
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const std::string& message) = 0;
};

class EmailObserver : public Observer {
public:
    void update(const std::string& message) override {
        std::cout << "이메일 발송: " << message << "\n";
    }
};

class NotificationSystem {
private:
    std::vector<std::shared_ptr<Observer>> observers;
    
public:
    void addObserver(std::shared_ptr<Observer> observer) {
        observers.push_back(observer);
    }
    
    void notify(const std::string& message) {
        for (auto& observer : observers) {
            observer->update(message);
        }
    }
};

int main() {
    NotificationSystem system;
    
    // 같은 observer를 여러 곳에서 공유
    auto emailObs = std::make_shared<EmailObserver>();
    
    system.addObserver(emailObs);
    system.addObserver(emailObs);
    
    system.notify("긴급 알림!");
    
    // emailObs, system이 모두 스코프를 벗어날 때
    // 참조 카운트가 0이 되어 자동 해제됩니다
}
```

### 5.2.2 참조 카운팅 이해하기
`shared_ptr`은 내부적으로 참조 카운트를 유지한다. 언제 메모리가 해제되는지 이해하는 것이 중요하다:  
  
```cpp
void referenceCountingExample() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
    
    std::cout << "참조 카운트: " << ptr1.use_count() << "\n";  // 1
    
    {
        std::shared_ptr<int> ptr2 = ptr1;
        std::cout << "참조 카운트: " << ptr1.use_count() << "\n";  // 2
        
        std::shared_ptr<int> ptr3 = ptr1;
        std::cout << "참조 카운트: " << ptr1.use_count() << "\n";  // 3
    }  // ptr2, ptr3 스코프 벗어남
    
    std::cout << "참조 카운트: " << ptr1.use_count() << "\n";  // 1
}  // ptr1 스코프 벗어남, 메모리 해제
```

`make_shared`를 사용하는 것이 권장되는 이유:

```cpp
// ✗ 권장되지 않음 - 두 번의 할당
std::shared_ptr<int> ptr1(new int(42));

// ✓ 권장됨 - 한 번의 할당
auto ptr2 = std::make_shared<int>(42);
```

`make_shared`는 데이터와 참조 카운트를 한 번에 할당하여 성능이 더 좋다.

### 5.2.3 복잡한 리소스 관리
데이터베이스 연결과 같은 복잡한 리소스를 `shared_ptr`로 관리하는 예제이다:

```cpp
class DatabaseConnection {
private:
    std::string connectionString;
    bool connected = false;
    
public:
    DatabaseConnection(const std::string& connStr) 
        : connectionString(connStr) {
        // 데이터베이스 연결 초기화
        std::cout << "DB 연결: " << connectionString << "\n";
        connected = true;
    }
    
    ~DatabaseConnection() {
        if (connected) {
            std::cout << "DB 연결 해제: " << connectionString << "\n";
        }
    }
    
    bool execute(const std::string& query) {
        if (!connected) return false;
        std::cout << "쿼리 실행: " << query << "\n";
        return true;
    }
};

class DataRepository {
private:
    std::shared_ptr<DatabaseConnection> db;
    
public:
    DataRepository(std::shared_ptr<DatabaseConnection> connection) 
        : db(connection) {}
    
    void loadData() {
        if (db) {
            db->execute("SELECT * FROM users");
        }
    }
};

class CacheManager {
private:
    std::shared_ptr<DatabaseConnection> db;
    
public:
    CacheManager(std::shared_ptr<DatabaseConnection> connection) 
        : db(connection) {}
    
    void refreshCache() {
        if (db) {
            db->execute("SELECT COUNT(*) FROM cache");
        }
    }
};

int main() {
    auto connection = std::make_shared<DatabaseConnection>("Server=localhost");
    
    DataRepository repo(connection);
    CacheManager cache(connection);
    
    repo.loadData();      // DB 연결 사용
    cache.refreshCache(); // 같은 DB 연결 사용
    
    // connection, repo, cache가 모두 스코프를 벗어날 때
    // 참조 카운트가 0이 되고 DB 연결이 해제됩니다
}
```

### 5.2.4 shared_ptr의 성능 고려사항
`shared_ptr`은 편하지만 성능 비용이 있다:

```cpp
// 성능 문제 예제 1: 불필요한 shared_ptr 사용
class BadDesign {
private:
    std::vector<std::shared_ptr<int>> values;  // 오버헤드!
    
public:
    void add(int val) {
        values.push_back(std::make_shared<int>(val));
    }
};

// ✓ 개선: 값 직접 저장
class GoodDesign {
private:
    std::vector<int> values;  // 단순하고 빠릅니다
    
public:
    void add(int val) {
        values.push_back(val);
    }
};

// 성능 문제 예제 2: 루프에서의 복사
void badLoop(const std::vector<std::shared_ptr<Data>>& items) {
    for (auto ptr : items) {  // 불필요한 참조 카운팅 증가/감소
        ptr->process();
    }
}

// ✓ 개선: const 참조 사용
void goodLoop(const std::vector<std::shared_ptr<Data>>& items) {
    for (const auto& ptr : items) {  // 참조 카운팅 오버헤드 없음
        ptr->process();
    }
}
```

### 5.2.5 C++ Core Guidelines와 shared_ptr

**Rule: R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership**

```cpp
// ✓ Good: shared_ptr이 실제로 필요합니다
class ResourcePool {
private:
    std::vector<std::shared_ptr<Resource>> pool;
};

// ✗ Bad: unique_ptr만으로도 충분합니다
void processFile() {
    auto file = std::make_shared<FileHandle>("data.txt");  // 왜 shared?
    processData(file);
}
```

---

## 5.3 weak_ptr로 순환 참조 해결

### 5.3.1 순환 참조의 문제
`shared_ptr`은 강력하지만 치명적인 약점이 있다: 순환 참조이다.

```cpp
class Node {
public:
    std::shared_ptr<Node> parent;
    std::shared_ptr<Node> child;
    
    ~Node() {
        std::cout << "Node 소멸\n";
    }
};

void circularReferenceExample() {
    auto node1 = std::make_shared<Node>();
    auto node2 = std::make_shared<Node>();
    
    // 순환 참조 발생!
    node1->child = node2;
    node2->parent = node1;
    
    // 스코프를 벗어나면 어떻게 될까요?
}
// 출력: (아무것도 출력되지 않음!)
// 메모리 누수 발생! 두 Node가 해제되지 않습니다.
```

이유를 분석해보자:
1. `node1`의 참조 카운트: 2 (node1 변수, node2->parent)
2. `node2`의 참조 카운트: 2 (node2 변수, node1->child)
3. 스코프 벗어나면: node1, node2 변수가 제거되어도 카운트가 각각 1
4. 서로를 가리키고 있어서 절대 0이 될 수 없음 → 메모리 누수!

### 5.3.2 weak_ptr로 해결하기
`weak_ptr`은 "약한" 참조를 제공한다. 참조 카운트를 증가시키지 않으면서도 객체에 접근할 수 있다:

```cpp
class Node {
public:
    std::shared_ptr<Node> child;
    std::weak_ptr<Node> parent;  // 부모는 weak_ptr로!
    
    ~Node() {
        std::cout << "Node 소멸\n";
    }
};

void weakPtrExample() {
    auto node1 = std::make_shared<Node>();
    auto node2 = std::make_shared<Node>();
    
    node1->child = node2;
    node2->parent = node1;  // weak_ptr이므로 순환참조 없음!
    
    // 스코프를 벗어나면:
}
// 출력:
// Node 소멸
// Node 소멸
// 메모리가 제대로 해제됩니다!
```

### 5.3.3 weak_ptr 사용 패턴
`weak_ptr`에서 실제로 사용하려면 `lock()`으로 `shared_ptr`로 변환해야 한다:

```cpp
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update() = 0;
};

class Subject {
private:
    std::vector<std::weak_ptr<Observer>> observers;  // weak_ptr 저장
    
public:
    void attach(std::shared_ptr<Observer> observer) {
        observers.push_back(observer);
    }
    
    void notify() {
        for (auto it = observers.begin(); it != observers.end();) {
            if (auto obs = it->lock()) {  // weak_ptr을 shared_ptr로 변환
                obs->update();
                ++it;
            } else {
                // Observer가 이미 소멸했으면 제거
                it = observers.erase(it);
            }
        }
    }
};

class ConcreteObserver : public Observer {
public:
    void update() override {
        std::cout << "업데이트됨\n";
    }
};

int main() {
    auto subject = std::make_shared<Subject>();
    
    {
        auto obs = std::make_shared<ConcreteObserver>();
        subject->attach(obs);
        subject->notify();  // 출력: 업데이트됨
    }  // obs 소멸
    
    subject->notify();  // weak_ptr이 자동으로 정리되므로 아무것도 실행 안 됨
}
```

### 5.3.4 실제 사용 사례: 캐시 관리
약한 참조를 이용한 자동 캐시 정리:

```cpp
class ExpensiveResource {
private:
    std::string data;
    
public:
    ExpensiveResource(const std::string& d) : data(d) {
        std::cout << "리소스 생성: " << data << "\n";
    }
    
    ~ExpensiveResource() {
        std::cout << "리소스 소멸: " << data << "\n";
    }
};

class ResourceCache {
private:
    std::map<std::string, std::weak_ptr<ExpensiveResource>> cache;
    
public:
    std::shared_ptr<ExpensiveResource> get(const std::string& key) {
        auto it = cache.find(key);
        
        if (it != cache.end()) {
            if (auto resource = it->second.lock()) {
                std::cout << "캐시 히트: " << key << "\n";
                return resource;
            } else {
                // 리소스가 소멸했으므로 캐시 항목 제거
                cache.erase(it);
            }
        }
        
        // 새 리소스 생성
        auto resource = std::make_shared<ExpensiveResource>(key);
        cache[key] = resource;
        return resource;
    }
};

int main() {
    ResourceCache cache;
    
    {
        auto res1 = cache.get("image.jpg");
        auto res1_again = cache.get("image.jpg");  // 캐시 히트
    }  // res1, res1_again 소멸
    
    auto res2 = cache.get("image.jpg");  // 새로 생성 (이전 캐시 항목 자동 정리)
}
```

### 5.3.5 C++ Core Guidelines와 weak_ptr

**Rule: R.22: Use `weak_ptr` to break cycles of `shared_ptr`s**

```cpp
// ✓ Good: 부모-자식 관계에서 부모는 weak_ptr
class TreeNode {
private:
    std::shared_ptr<TreeNode> left;
    std::shared_ptr<TreeNode> right;
    std::weak_ptr<TreeNode> parent;  // 순환참조 방지
};

// ✗ Bad: 양쪽 모두 shared_ptr
class BadTreeNode {
private:
    std::shared_ptr<BadTreeNode> child;
    std::shared_ptr<BadTreeNode> parent;  // 메모리 누수!
};
```

---

## 5.4 성능 최적화와 안전성의 균형

### 5.4.1 메모리 할당 최적화
스마트 포인터의 성능을 최대화하는 방법들:

```cpp
// 성능 측정을 위한 헬퍼
#include <chrono>
#include <iostream>

template<typename Func>
auto measure(Func f) {
    auto start = std::chrono::high_resolution_clock::now();
    f();
    auto end = std::chrono::high_resolution_clock::now();
    return std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
}

// 최적화 전: 여러 번의 할당
void unoptimized() {
    std::vector<std::shared_ptr<int>> vec;
    for (int i = 0; i < 1000000; ++i) {
        vec.push_back(std::shared_ptr<int>(new int(i)));  // 두 번의 할당!
    }
}

// 최적화 후: make_shared 사용
void optimized() {
    std::vector<std::shared_ptr<int>> vec;
    for (int i = 0; i < 1000000; ++i) {
        vec.push_back(std::make_shared<int>(i));  // 한 번의 할당
    }
}

int main() {
    auto t1 = measure(unoptimized);
    auto t2 = measure(optimized);
    
    std::cout << "최적화 전: " << t1.count() << "ms\n";
    std::cout << "최적화 후: " << t2.count() << "ms\n";
}
```

### 5.4.2 이동 의미론을 활용한 최적화
스마트 포인터를 함수에 전달할 때 고려해야 할 사항:

```cpp
class HeavyObject {
private:
    std::vector<int> data;
    
public:
    HeavyObject() : data(1000000) {}
};

// ✗ 비효율적: 참조 카운트 증가/감소 오버헤드
void process1(std::shared_ptr<HeavyObject> obj) {
    // obj 사용
}

// ✓ 소유권 이전 필요 없음: const 참조
void process2(const std::shared_ptr<HeavyObject>& obj) {
    // obj 사용, 참조 카운트 변화 없음
}

// ✓ 소유권을 가져야 함: move 전달
void takeOwnership(std::shared_ptr<HeavyObject>&& obj) {
    // obj의 소유권을 받습니다
}

int main() {
    auto obj = std::make_shared<HeavyObject>();
    
    process2(obj);           // 효율적
    takeOwnership(std::move(obj));  // 효율적
}
```

### 5.4.3 메모리 풀 패턴
대량의 객체를 빈번하게 생성/소멸하는 경우 메모리 풀을 사용한다:

```cpp
template<typename T>
class ObjectPool {
private:
    std::vector<std::unique_ptr<T>> pool;
    std::queue<T*> available;
    std::mutex mutex;
    
public:
    std::shared_ptr<T> acquire() {
        std::lock_guard<std::mutex> lock(mutex);
        
        T* ptr;
        if (!available.empty()) {
            ptr = available.front();
            available.pop();
        } else {
            ptr = new T();
            pool.push_back(std::unique_ptr<T>(ptr));
        }
        
        // 커스텀 deleter를 사용하여 메모리 풀로 반환
        return std::shared_ptr<T>(ptr, [this](T* p) {
            std::lock_guard<std::mutex> lock(mutex);
            available.push(p);
        });
    }
};

class NetworkPacket {
public:
    std::vector<uint8_t> payload;
    
    NetworkPacket() : payload(1024) {}
};

int main() {
    ObjectPool<NetworkPacket> pool;
    
    {
        auto packet1 = pool.acquire();
        auto packet2 = pool.acquire();
        
        // 사용...
    }  // packet1, packet2 반환, 메모리는 풀에 남음
    
    {
        auto packet3 = pool.acquire();  // 이전 메모리 재사용
    }
}
```

### 5.4.4 컴파일 타임 최적화
컴파일러가 많은 스마트 포인터 오버헤드를 제거할 수 있다:

```cpp
class Widget {
private:
    int value = 0;
    
public:
    void setValue(int v) { value = v; }
    int getValue() const { return value; }
};

// 컴파일러 최적화로 오버헤드 제거 가능
inline void efficientCode() {
    auto widget = std::make_unique<Widget>();
    widget->setValue(42);
    int v = widget->getValue();
}  // 컴파일러가 스택 할당으로 최적화 가능
```

Visual Studio 2022에서 `/O2` 최적화 플래그를 사용하면 많은 스마트 포인터 오버헤드가 제거된다.    
  
### 5.4.5 안전성과 성능의 균형

```cpp
// 규칙 1: 소유권이 명확하면 unique_ptr 사용
class DataProcessor {
private:
    std::unique_ptr<DataBuffer> buffer;  // 유일한 소유자
};

// 규칙 2: 공유가 필요하면 shared_ptr, 아니면 const 참조
void processData(const std::shared_ptr<Data>& data) {
    // shared_ptr이 필요한 경우만 사용
    // 단순히 접근하려면 const 참조나 포인터 사용
}

// 규칙 3: 순환 참조는 weak_ptr로 해결
class Node {
public:
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;  // 순환참조 방지
};

// 규칙 4: 반복문에서는 const 참조 사용
void efficientLoop(const std::vector<std::shared_ptr<Item>>& items) {
    for (const auto& item : items) {  // const 참조
        item->process();
    }
}
```

---

## 5.5 실전 프로젝트: 게임 엔티티 매니저
이제 배운 모든 내용을 실전 프로젝트에 적용해보자. 게임 엔진의 엔티티 관리 시스템을 구현한다:

```cpp
#include <memory>
#include <vector>
#include <map>
#include <stdexcept>

// 컴포넌트 인터페이스
class Component {
public:
    virtual ~Component() = default;
    virtual void update(float deltaTime) = 0;
};

// 구체적인 컴포넌트들
class Transform : public Component {
private:
    float x, y;
    
public:
    Transform(float x = 0, float y = 0) : x(x), y(y) {}
    void update(float deltaTime) override {}
    
    void setPosition(float nx, float ny) { x = nx; y = ny; }
    std::pair<float, float> getPosition() const { return {x, y}; }
};

class Physics : public Component {
private:
    float velocityX, velocityY;
    std::weak_ptr<Transform> transform;  // 순환참조 방지
    
public:
    Physics(float vx = 0, float vy = 0) 
        : velocityX(vx), velocityY(vy) {}
    
    void setTransform(std::shared_ptr<Transform> t) {
        transform = t;
    }
    
    void update(float deltaTime) override {
        if (auto t = transform.lock()) {
            auto [x, y] = t->getPosition();
            t->setPosition(x + velocityX * deltaTime, 
                          y + velocityY * deltaTime);
        }
    }
};

class Renderer : public Component {
private:
    std::string sprite;
    std::weak_ptr<Transform> transform;
    
public:
    explicit Renderer(const std::string& s) : sprite(s) {}
    
    void setTransform(std::shared_ptr<Transform> t) {
        transform = t;
    }
    
    void update(float deltaTime) override {}
    
    void render() const {
        if (auto t = transform.lock()) {
            auto [x, y] = t->getPosition();
            std::cout << "그리기: " << sprite 
                     << " at (" << x << ", " << y << ")\n";
        }
    }
};

// 엔티티 클래스
class Entity {
private:
    std::string name;
    std::map<std::type_index, std::shared_ptr<Component>> components;
    std::shared_ptr<Transform> transform;
    
public:
    explicit Entity(const std::string& n) : name(n) {
        // 모든 엔티티는 Transform을 가짐
        addComponent<Transform>();
    }
    
    const std::string& getName() const { return name; }
    
    template<typename T, typename... Args>
    std::shared_ptr<T> addComponent(Args&&... args) {
        auto component = std::make_shared<T>(
            std::forward<Args>(args)...
        );
        components[std::type_index(typeid(T))] = component;
        
        // Transform 참조 업데이트
        if constexpr (std::is_same_v<T, Transform>) {
            transform = component;
        } else if constexpr (requires { component->setTransform(transform); }) {
            // 컴파일 타임 검사: setTransform 메서드가 있으면 호출
            component->setTransform(transform);
        }
        
        return component;
    }
    
    template<typename T>
    std::shared_ptr<T> getComponent() {
        auto it = components.find(std::type_index(typeid(T)));
        if (it != components.end()) {
            return std::dynamic_pointer_cast<T>(it->second);
        }
        return nullptr;
    }
    
    void update(float deltaTime) {
        for (auto& [type, component] : components) {
            component->update(deltaTime);
        }
    }
};

// 엔티티 매니저
class EntityManager {
private:
    std::vector<std::shared_ptr<Entity>> entities;
    std::map<std::string, std::weak_ptr<Entity>> entityMap;
    
public:
    std::shared_ptr<Entity> createEntity(const std::string& name) {
        auto entity = std::make_shared<Entity>(name);
        entities.push_back(entity);
        entityMap[name] = entity;
        return entity;
    }
    
    std::shared_ptr<Entity> getEntity(const std::string& name) {
        auto it = entityMap.find(name);
        if (it != entityMap.end()) {
            if (auto entity = it->second.lock()) {
                return entity;
            }
            // 엔티티가 소멸했으면 맵에서 제거
            entityMap.erase(it);
        }
        return nullptr;
    }
    
    void destroyEntity(const std::string& name) {
        auto it = std::find_if(
            entities.begin(), entities.end(),
            [&name](const std::shared_ptr<Entity>& e) {
                return e->getName() == name;
            }
        );
        
        if (it != entities.end()) {
            entityMap.erase(name);
            entities.erase(it);
        }
    }
    
    void update(float deltaTime) {
        for (auto& entity : entities) {
            entity->update(deltaTime);
        }
    }
    
    void render() {
        for (auto& entity : entities) {
            if (auto renderer = entity->getComponent<Renderer>()) {
                renderer->render();
            }
        }
    }
    
    size_t getEntityCount() const { return entities.size(); }
};

// 실제 사용
int main() {
    EntityManager manager;
    
    // 플레이어 생성
    auto player = manager.createEntity("Player");
    player->getComponent<Transform>()->setPosition(0, 0);
    player->addComponent<Physics>(10, 5);
    player->addComponent<Renderer>("player.sprite");
    
    // 적 생성
    auto enemy = manager.createEntity("Enemy");
    enemy->getComponent<Transform>()->setPosition(100, 100);
    enemy->addComponent<Physics>(-5, 0);
    enemy->addComponent<Renderer>("enemy.sprite");
    
    std::cout << "엔티티 개수: " << manager.getEntityCount() << "\n\n";
    
    // 게임 루프 시뮬레이션
    for (int frame = 0; frame < 3; ++frame) {
        std::cout << "--- 프레임 " << frame << " ---\n";
        manager.update(0.016f);  // 약 60fps
        manager.render();
        std::cout << "\n";
    }
    
    // 엔티티 제거
    std::cout << "플레이어 제거\n";
    manager.destroyEntity("Player");
    
    std::cout << "남은 엔티티 개수: " << manager.getEntityCount() << "\n";
    
    // 모든 리소스는 자동으로 정리됩니다!
}
```

**실행 결과:**
```
엔티티 개수: 2

--- 프레임 0 ---
그리기: player.sprite at (0, 0)
그리기: enemy.sprite at (100, 100)

--- 프레임 1 ---
그리기: player.sprite at (0.16, 0.08)
그리기: enemy.sprite at (99.92, 100)

--- 프레임 2 ---
그리기: player.sprite at (0.32, 0.16)
그리기: enemy.sprite at (99.84, 100)

플레이어 제거
남은 엔티티 개수: 1
```

이 예제는 다음을 보여준다:

1. **unique_ptr 대신 shared_ptr 사용**: 여러 시스템이 엔티티를 참조해야 하므로
2. **weak_ptr 사용**: Transform과 Physics/Renderer 간의 순환참조 방지
3. **자동 메모리 관리**: 엔티티 제거 시 모든 컴포넌트 자동 해제
4. **타입 안전성**: 템플릿으로 컴포넌트 관리
5. **RAII 원칙**: 리소스 획득 시 초기화, 소멸 시 자동 정리

---

## 5.6 자주 하는 실수와 해결책

### 실수 1: get()으로 얻은 포인터를 delete로 해제하기

```cpp
// ✗ 위험: 이중 해제!
{
    auto ptr = std::make_unique<int>(42);
    int* raw = ptr.get();
    delete raw;  // unique_ptr이 또 delete 호출 → 크래시!
}

// ✓ 올바른 방법
{
    auto ptr = std::make_unique<int>(42);
    int* raw = ptr.get();
    // 여기서는 delete 호출 금지
}  // unique_ptr이 자동으로 해제
```

### 실수 2: shared_ptr에서 this 포인터 사용

```cpp
class MyClass {
public:
    // ✗ 위험: this는 생(raw) 포인터
    std::shared_ptr<MyClass> getSelf() {
        return std::shared_ptr<MyClass>(this);  // 문제!
    }
};

// ✓ 올바른 방법: enable_shared_from_this 사용
class MyClass : public std::enable_shared_from_this<MyClass> {
public:
    std::shared_ptr<MyClass> getSelf() {
        return shared_from_this();
    }
};
```

### 실수 3: 순환참조 간과

```cpp
// ✗ 메모리 누수
class Parent {
public:
    std::shared_ptr<Child> child;  // Parent → Child
};

class Child {
public:
    std::shared_ptr<Parent> parent;  // Child → Parent (순환!)
};

// ✓ 해결
class Parent {
public:
    std::shared_ptr<Child> child;
};

class Child {
public:
    std::weak_ptr<Parent> parent;  // Parent의 참조 카운트 증가 안 함
};
```

### 실수 4: STL 컨테이너와 shared_ptr

```cpp
// ✗ 비효율적: 불필요한 복사
std::vector<std::shared_ptr<int>> vec;
for (auto ptr : vec) {  // 참조 카운트 증가/감소
    process(ptr);
}

// ✓ 효율적: const 참조
std::vector<std::shared_ptr<int>> vec;
for (const auto& ptr : vec) {  // 참조 카운트 변화 없음
    process(ptr);
}
```

---

## 5.7 Modern C++ vs Rust: 스마트 포인터 비교
흥미롭게도 Rust의 소유권 시스템과 C++의 스마트 포인터는 매우 유사한 개념이다:

| 개념 | Rust | Modern C++ |
|------|------|-----------|
| 독점 소유권 | `Box<T>` | `unique_ptr<T>` |
| 공유 소유권 | `Rc<T>` | `shared_ptr<T>` |
| 약한 참조 | `Weak<T>` | `weak_ptr<T>` |
| 참조 | `&T` | `const T*` 또는 `const T&` |
| 가변 참조 | `&mut T` | `T*` 또는 `T&` |

**Rust:**
```rust
fn main() {
    let s1 = Box::new(String::from("hello"));
    let s2 = s1;  // s1의 소유권이 s2로 이동
    // println!("{}", s1);  // 에러! s1은 더 이상 소유하지 않음
    println!("{}", s2);  // OK
}
```

**Modern C++:**
```cpp
int main() {
    auto s1 = std::make_unique<std::string>("hello");
    auto s2 = std::move(s1);  // s1의 소유권이 s2로 이동
    // std::cout << *s1;  // 에러! s1은 nullptr
    std::cout << *s2;  // OK
}
```

완벽하게 동일한 개념이다!

--- 

## 5.8 요약: 메모리 안전성 달성
Modern C++의 스마트 포인터를 올바르게 사용하면:

1. **메모리 누수 제거**: RAII와 결합하여 자동 정리
2. **댕글링 포인터 방지**: 객체가 살아있는 동안만 접근
3. **소유권 명확화**: 누가 리소스를 소유하는지 코드에서 명시
4. **Rust 수준의 안전성**: 컴파일 타임 검증은 덜하지만, 실행 타임에 대부분 보장
5. **성능**: 제대로 사용하면 C-style 포인터와 동일한 성능
6. **유연성**: 필요에 따라 다양한 소유권 모델 선택 가능

C++의 스마트 포인터는 일반적인 인식과 달리, Rust만큼 강력하고 안전한 메모리 관리를 제공한다. 중요한 것은 **정확한 이해와 일관된 사용**이다.  
  
다음 장에서는 STL 컨테이너가 어떻게 이러한 메모리 안전성을 보장하는지 살펴보겠다.

