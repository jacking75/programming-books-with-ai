# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 14: 병렬 알고리즘과 성능 최적화

## 소개
Modern C++의 여정에서 우리는 지금까지 안전성에 중점을 두고 학습해왔다. 이제 성능이라는 측면을 함께 고려해야 한다. 흥미롭게도, 안전성과 성능은 상충하지 않는다. 오히려 안전한 코드 구조는 컴파일러가 더 적극적으로 최적화할 수 있게 만든다.

Chapter 14는 멀티코어 프로세서의 능력을 활용하여 코드를 빠르게 만드는 방법에 집중한다. C++17에서 도입된 `std::execution` 정책을 사용하면, 몇 줄의 코드 변경으로 기존 알고리즘을 병렬화할 수 있다. 또한 SIMD(Single Instruction Multiple Data) 명령어를 활용하면 CPU 레벨에서의 병렬성도 활용할 수 있다. 이러한 최적화 기법들은 모두 타입 안전성을 유지하면서 성능을 극대화한다.

우리는 Rust와의 성능 비교에서도 자신감을 가질 수 있다. Modern C++의 병렬 알고리즘은 Rust와 같은 수준의 성능을 제공하며, 때로는 더 뛰어나다. 핵심은 올바른 도구를 선택하고, 성능을 측정하는 것이다.



## 1. std::execution 정책의 이해와 활용

### 1.1 순차 실행에서 병렬 실행으로
전통적인 STL 알고리즘은 단일 스레드에서만 실행된다. 예를 들어, `std::sort()`는 main 스레드에서만 작동한다. 하지만 멀티코어 프로세서에서는 이것이 자원 낭비다.

C++17에서 도입된 실행 정책(execution policies)은 알고리즘이 어떻게 실행되어야 하는지를 명시한다. 코드 변경이 최소한이면서도 병렬성을 활용할 수 있다.

### 1.2 기본 실행 정책들

```cpp
#include <iostream>
#include <algorithm>
#include <execution>
#include <vector>
#include <random>
#include <chrono>

int main() {
    std::vector<int> data(1000000);
    
    // 벡터를 무작위 값으로 채운다
    std::mt19937 gen(std::random_device{}());
    std::uniform_int_distribution<> dis(1, 1000);
    std::generate(data.begin(), data.end(), 
                  [&]() { return dis(gen); });
    
    // 1. std::execution::seq - 순차 실행
    {
        auto copy1 = data;
        auto start = std::chrono::high_resolution_clock::now();
        std::sort(std::execution::seq, copy1.begin(), copy1.end());
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "순차 정렬: " << duration.count() << "ms\n";
    }
    
    // 2. std::execution::par - 병렬 실행
    {
        auto copy2 = data;
        auto start = std::chrono::high_resolution_clock::now();
        std::sort(std::execution::par, copy2.begin(), copy2.end());
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "병렬 정렬: " << duration.count() << "ms\n";
    }
    
    // 3. std::execution::par_unseq - 병렬 + SIMD 활용
    {
        auto copy3 = data;
        auto start = std::chrono::high_resolution_clock::now();
        std::sort(std::execution::par_unseq, copy3.begin(), copy3.end());
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "병렬 + SIMD 정렬: " << duration.count() << "ms\n";
    }
    
    // 4. std::execution::unseq - SIMD만 활용 (단일 스레드)
    {
        auto copy4 = data;
        auto start = std::chrono::high_resolution_clock::now();
        std::sort(std::execution::unseq, copy4.begin(), copy4.end());
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "SIMD 정렬: " << duration.count() << "ms\n";
    }
    
    return 0;
}
```

이 코드는 네 가지 실행 정책을 비교한다. 각 정책의 의미를 정확히 이해하는 것이 중요하다:

- `std::execution::seq`: 순차적으로 한 번에 하나씩 처리한다. 가장 느리지만 가장 예측 가능하다.
- `std::execution::par`: 여러 스레드를 사용해 병렬로 처리한다. 멀티코어 시스템에서 빠르다.
- `std::execution::par_unseq`: 병렬 실행 + SIMD 벡터화를 모두 활용한다. 가장 빠르지만 가장 최적화된 하드웨어가 필요하다.
- `std::execution::unseq`: SIMD만 사용한다. 단일 스레드이지만 데이터 수준 병렬성을 활용한다.

일반적으로 대규모 데이터에서는 `par` 또는 `par_unseq`가 큰 성능 향상을 제공한다.

### 1.3 실행 정책의 주의사항과 안전성
실행 정책을 사용할 때는 특정 규칙을 따라야 한다. 이는 안전성을 보장하기 위해서다.

```cpp
#include <iostream>
#include <algorithm>
#include <execution>
#include <vector>

int main() {
    std::vector<int> data = {1, 2, 3, 4, 5};
    std::vector<int> results;
    
    // 잘못된 예: 병렬 실행 중에 벡터에 push_back을 하면 안 된다
    // 이는 데이터 레이스를 초래한다
    // std::for_each(std::execution::par, data.begin(), data.end(),
    //     [&results](int x) {
    //         results.push_back(x * 2);  // 위험!
    //     }
    // );
    
    // 올바른 예 1: 미리 크기를 할당한다
    results.resize(data.size());
    std::transform(std::execution::par, data.begin(), data.end(),
                   results.begin(),
                   [](int x) { return x * 2; });
    
    std::cout << "결과: ";
    for (int r : results) {
        std::cout << r << " ";
    }
    std::cout << "\n";
    
    // 올바른 예 2: 순차 실행을 사용한다
    std::vector<int> results2;
    std::for_each(std::execution::seq, data.begin(), data.end(),
        [&results2](int x) {
            results2.push_back(x * 2);
        }
    );
    
    return 0;
}
```

C++ Core Guidelines의 관점에서 볼 때, 병렬 실행 정책을 사용할 때는 다음을 따라야 한다:

- 함수 객체는 **사이드 이펙트가 없어야** 한다. (const 연산)
- 함수 객체는 **스레드 안전**해야 한다.
- 결과 컨테이너는 **미리 할당**되어야 한다.

이러한 제약은 안전성을 보장하면서도 프레임워크가 최적화를 수행할 수 있게 한다.



## 2. 병렬 STL 알고리즘 완전 정복

### 2.1 병렬 변환: transform
`std::transform`은 가장 많이 사용되는 알고리즘 중 하나다. 병렬 버전은 대규모 데이터 처리에서 큰 성능 향상을 제공한다.

```cpp
#include <iostream>
#include <algorithm>
#include <execution>
#include <vector>
#include <cmath>

int main() {
    std::vector<double> input(10000);
    std::vector<double> output(10000);
    
    // 입력 데이터 채우기
    for (size_t i = 0; i < input.size(); ++i) {
        input[i] = static_cast<double>(i) / 100.0;
    }
    
    // 병렬로 각 요소에 복잡한 계산을 적용한다
    std::transform(std::execution::par, input.begin(), input.end(),
                   output.begin(),
                   [](double x) {
                       // 복잡한 수학 연산
                       return std::sin(x) * std::cos(x) + std::sqrt(std::abs(x));
                   });
    
    std::cout << "처음 5개 결과: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << output[i] << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

### 2.2 병렬 축약: reduce와 accumulate의 차이
`std::accumulate`는 순차적이고 순서가 중요하지만, `std::reduce`는 병렬화를 위해 설계되었다.

```cpp
#include <iostream>
#include <algorithm>
#include <execution>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> data(1000000);
    
    // 데이터 채우기
    for (size_t i = 0; i < data.size(); ++i) {
        data[i] = 1;
    }
    
    // 1. 순차 accumulate (느리고, 순서 의존적)
    int sum1 = std::accumulate(data.begin(), data.end(), 0);
    std::cout << "Accumulate 합: " << sum1 << "\n";
    
    // 2. 병렬 reduce (빠르고, 순서 독립적)
    // reduce는 연산이 교환법칙과 결합법칙을 만족할 때 안전하다
    int sum2 = std::reduce(std::execution::par, 
                           data.begin(), data.end(), 
                           0,  // 초기값
                           std::plus<>());  // 연산
    std::cout << "Reduce 합: " << sum2 << "\n";
    
    return 0;
}
```

`std::reduce`와 `std::accumulate`의 중요한 차이점은 다음과 같다:

- **accumulate**: `(((init + a[0]) + a[1]) + a[2]) ...` 순서대로 계산한다. 부동소수점 덧셈에서는 순서에 따라 결과가 달라질 수 있다.
- **reduce**: 데이터를 여러 부분으로 나누어 병렬로 처리한 후 결합한다. 연산이 교환 법칙과 결합 법칙을 만족해야 안전하다.

### 2.3 병렬 필터링: copy_if
데이터 필터링도 병렬화할 수 있지만, 출력 위치를 미리 알 수 없다는 문제가 있다.

```cpp
#include <iostream>
#include <algorithm>
#include <execution>
#include <vector>

int main() {
    std::vector<int> data(1000);
    for (size_t i = 0; i < data.size(); ++i) {
        data[i] = i;
    }
    
    // 방법 1: 순차적으로 필터링 (안전하지만 느림)
    std::vector<int> even1;
    std::copy_if(std::execution::seq, data.begin(), data.end(),
                 std::back_inserter(even1),
                 [](int x) { return x % 2 == 0; });
    
    std::cout << "필터링된 원소 개수 (방법 1): " << even1.size() << "\n";
    
    // 방법 2: 미리 크기가 큰 벡터를 할당하고, 실제 크기를 구한다
    std::vector<int> even2(data.size());
    auto end_it = std::copy_if(std::execution::par, data.begin(), data.end(),
                               even2.begin(),
                               [](int x) { return x % 2 == 0; });
    even2.erase(end_it, even2.end());  // 사용하지 않는 부분 제거
    
    std::cout << "필터링된 원소 개수 (방법 2): " << even2.size() << "\n";
    
    return 0;
}
```

이 예제에서 중요한 점은 병렬 `copy_if`도 순차 버전과 같은 의미이지만, 내부적으로 스레드를 사용한다는 것이다. 그러나 `back_inserter`는 스레드 안전하지 않으므로, 미리 충분한 크기의 벡터를 할당해야 한다.

### 2.4 병렬 검색과 정렬

```cpp
#include <iostream>
#include <algorithm>
#include <execution>
#include <vector>

int main() {
    std::vector<int> data = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // 병렬 정렬
    std::sort(std::execution::par, data.begin(), data.end());
    
    std::cout << "정렬된 데이터: ";
    for (int x : data) {
        std::cout << x << " ";
    }
    std::cout << "\n";
    
    // 병렬 검색
    auto it = std::find(std::execution::par, data.begin(), data.end(), 5);
    if (it != data.end()) {
        std::cout << "5를 찾았습니다. 인덱스: " << std::distance(data.begin(), it) << "\n";
    }
    
    // 병렬 모든 조건 확인
    bool all_positive = std::all_of(std::execution::par, 
                                    data.begin(), data.end(),
                                    [](int x) { return x > 0; });
    std::cout << "모든 원소가 양수: " << (all_positive ? "예" : "아니오") << "\n";
    
    return 0;
}
```

   

## 3. SIMD와 벡터화 최적화

### 3.1 SIMD의 기본 개념
SIMD(Single Instruction Multiple Data)는 하나의 CPU 명령어로 여러 데이터 항목을 동시에 처리한다. 예를 들어, SSE4.2는 128비트 레지스터에 4개의 32비트 정수를 저장하고, 한 번에 4개의 덧셈을 수행할 수 있다.

C++에서 SIMD를 활용하는 방법은 여러 가지가 있다:

1. **자동 벡터화**: 컴파일러가 자동으로 SIMD 명령어를 생성한다.
2. **Intrinsics**: 저수준 SIMD 명령어를 직접 사용한다.
3. **라이브러리**: std::simd (C++23 제안) 또는 외부 라이브러리를 사용한다.

### 3.2 컴파일러 자동 벡터화
대부분의 경우, 현대 컴파일러는 단순한 루프를 자동으로 벡터화한다.

```cpp
#include <iostream>
#include <vector>
#include <chrono>

// 자동 벡터화 가능한 코드
void vector_add_auto(const std::vector<float>& a, 
                     const std::vector<float>& b,
                     std::vector<float>& result) {
    for (size_t i = 0; i < a.size(); ++i) {
        result[i] = a[i] + b[i];
    }
}

int main() {
    const size_t size = 10000000;
    std::vector<float> a(size, 1.0f);
    std::vector<float> b(size, 2.0f);
    std::vector<float> result(size);
    
    auto start = std::chrono::high_resolution_clock::now();
    vector_add_auto(a, b, result);
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "자동 벡터화 덧셈 시간: " << duration.count() << "ms\n";
    std::cout << "처음 5개 결과: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << result[i] << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

자동 벡터화를 최대화하려면:

- 반복문이 단순해야 한다.
- 반복문 내의 작업이 명확해야 한다.
- 데이터 의존성이 없어야 한다.

### 3.3 컴파일러 최적화 플래그
Visual Studio 2022에서 벡터화를 활용하려면 올바른 컴파일러 설정이 필요하다.

```cpp
// Visual Studio 프로젝트 설정:
// 1. 프로젝트 속성 → C/C++ → 최적화
//    - 최적화: /O2 (최대 속도)
// 2. 고급 설정
//    - 부동 소수점 모델: /fp:fast (더 빠른 부동소수점 연산)
//    - 인라인 함수 확장: /Ob2 (공격적 인라이닝)

// 코드 레벨에서도 컴파일러에 힌트를 줄 수 있다
#include <vector>

void optimized_loop(const std::vector<float>& input,
                    std::vector<float>& output) {
    // 이 루프는 벡터화될 수 있음을 컴파일러에 알린다
    #pragma omp simd
    for (size_t i = 0; i < input.size(); ++i) {
        output[i] = input[i] * 2.0f + 1.0f;
    }
}
```

### 3.4 SIMD Intrinsics의 예 (고급)
더 정밀한 제어가 필요할 때는 SIMD Intrinsics를 사용할 수 있다. 하지만 이는 포터빌리티 문제가 있으므로, 최후의 수단으로 고려해야 한다.

```cpp
#include <iostream>
#include <immintrin.h>  // SSE/AVX intrinsics
#include <vector>
#include <chrono>

// SSE를 사용한 4개의 float 동시 처리
void vector_add_sse(const float* a, const float* b, float* result, size_t size) {
    size_t i = 0;
    
    // SSE는 128비트 = 4개의 float를 처리
    for (; i + 3 < size; i += 4) {
        __m128 va = _mm_loadu_ps(&a[i]);      // 메모리에서 4개의 float 로드
        __m128 vb = _mm_loadu_ps(&b[i]);
        __m128 vresult = _mm_add_ps(va, vb);  // 4개의 덧셈 동시 수행
        _mm_storeu_ps(&result[i], vresult);   // 메모리에 저장
    }
    
    // 남은 원소들은 순차적으로 처리
    for (; i < size; ++i) {
        result[i] = a[i] + b[i];
    }
}

int main() {
    const size_t size = 10000000;
    std::vector<float> a(size, 1.0f);
    std::vector<float> b(size, 2.0f);
    std::vector<float> result(size);
    
    auto start = std::chrono::high_resolution_clock::now();
    vector_add_sse(a.data(), b.data(), result.data(), size);
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "SSE 벡터화 덧셈 시간: " << duration.count() << "ms\n";
    std::cout << "처음 5개 결과: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << result[i] << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

SIMD Intrinsics를 사용할 때의 주의점:

- 플랫폼별로 다른 명령어가 필요하다. (SSE, AVX, NEON 등)
- 포터빌리티가 떨어진다.
- 코드 유지보수가 어렵다.
- 컴파일러의 자동 벡터화가 대부분의 경우 충분하다.

따라서 특별히 성능 측정을 통해 필요함이 증명되지 않는 한, 자동 벡터화에 의존하는 것이 권장된다.



## 4. 성능 측정과 프로파일링

### 4.1 마이크로 벤치마킹의 함정
성능 측정은 생각보다 어렵다. 많은 함정이 있어서, 부정확한 결과를 얻을 수 있다.

```cpp
#include <iostream>
#include <chrono>
#include <algorithm>
#include <vector>

// 잘못된 벤치마킹 예제
void wrong_benchmark() {
    std::vector<int> data(1000);
    for (size_t i = 0; i < data.size(); ++i) {
        data[i] = i;
    }
    
    // 문제 1: 너무 짧은 시간 측정
    auto start = std::chrono::high_resolution_clock::now();
    std::sort(data.begin(), data.end());  // 1ms 미만
    auto end = std::chrono::high_resolution_clock::now();
    
    // 이 결과는 신뢰할 수 없다. 시스템 노이즈가 크다.
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    std::cout << "시간: " << duration.count() << "ns\n";
}

// 올바른 벤치마킹 예제
void correct_benchmark() {
    std::vector<int> data(10000000);
    for (size_t i = 0; i < data.size(); ++i) {
        data[i] = data.size() - i;  // 역순 정렬
    }
    
    // 여러 번 반복해서 측정한다
    const int iterations = 5;
    long long total_time = 0;
    
    for (int iter = 0; iter < iterations; ++iter) {
        auto copy = data;
        
        auto start = std::chrono::high_resolution_clock::now();
        std::sort(copy.begin(), copy.end());
        auto end = std::chrono::high_resolution_clock::now();
        
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        total_time += duration.count();
        
        std::cout << "반복 " << iter + 1 << ": " << duration.count() << "ms\n";
    }
    
    std::cout << "평균 시간: " << total_time / iterations << "ms\n";
}
```

### 4.2 Google Benchmark 라이브러리를 사용한 전문적인 측정
더 정확한 벤치마킹을 위해 Google Benchmark 라이브러리를 사용할 수 있다. 이 라이브러리는 많은 함정을 자동으로 처리한다.

```cpp
#include <benchmark/benchmark.h>
#include <algorithm>
#include <vector>

// 벤치마크 함수 정의
static void BM_SequentialSort(benchmark::State& state) {
    // 테스트할 데이터 준비
    std::vector<int> data(state.range(0));
    for (size_t i = 0; i < data.size(); ++i) {
        data[i] = data.size() - i;
    }
    
    // 측정 루프
    for (auto _ : state) {
        auto copy = data;
        std::sort(copy.begin(), copy.end());
        benchmark::DoNotOptimize(copy.data());
    }
    
    state.SetComplexityN(state.range(0));
}

static void BM_ParallelSort(benchmark::State& state) {
    std::vector<int> data(state.range(0));
    for (size_t i = 0; i < data.size(); ++i) {
        data[i] = data.size() - i;
    }
    
    for (auto _ : state) {
        auto copy = data;
        std::sort(std::execution::par, copy.begin(), copy.end());
        benchmark::DoNotOptimize(copy.data());
    }
    
    state.SetComplexityN(state.range(0));
}

// 다양한 데이터 크기로 벤치마크 등록
BENCHMARK(BM_SequentialSort)
    ->RangeMultiplier(10)
    ->Range(1000, 10000000)
    ->Complexity(benchmark::oN);

BENCHMARK(BM_ParallelSort)
    ->RangeMultiplier(10)
    ->Range(1000, 10000000)
    ->Complexity(benchmark::oN);

BENCHMARK_MAIN();
```

Google Benchmark의 주요 기능:

- 자동 워밍업: 캐시 예열
- 통계 계산: 중위수, 표준편차 등
- 복잡도 분석: Big-O 추정
- 메모리 측정: 할당된 메모리 추적

### 4.3 Visual Studio의 내장 프로파일러 활용
Visual Studio 2022는 강력한 내장 프로파일러를 제공한다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <execution>

int main() {
    std::vector<int> data(10000000);
    for (size_t i = 0; i < data.size(); ++i) {
        data[i] = data.size() - i;
    }
    
    // Visual Studio 프로파일링:
    // 1. Debug → Performance Profiler 또는 Alt+F2
    // 2. 측정할 애플리케이션 선택
    // 3. 프로파일링 옵션 설정 (CPU Usage, Memory 등)
    // 4. 실행
    
    std::sort(std::execution::par, data.begin(), data.end());
    
    std::cout << "정렬 완료\n";
    
    // 프로파일러가 생성한 리포트:
    // - CPU 사용률
    // - 함수별 실행 시간
    // - 메모리 할당
    // - 캐시 미스
    
    return 0;
}
```

프로파일링 결과를 해석하는 방법:

1. **Hot Path 식별**: 가장 많은 시간을 소비하는 함수들을 찾는다.
2. **병목 분석**: CPU, 메모리, I/O 중 어느 것이 제한 요소인지 파악한다.
3. **최적화 순서**: 가장 큰 이득을 줄 부분부터 최적화한다.

### 4.4 메모리 사용량 최적화
성능은 단순히 속도만을 의미하지 않는다. 메모리 효율성도 중요하다.

```cpp
#include <iostream>
#include <vector>
#include <memory>

// 메모리 비효율적인 코드
class Inefficient {
public:
    std::vector<int> data1;
    std::vector<int> data2;
    std::vector<int> data3;
    
    // 멤버 변수들이 캐시 라인을 낭비할 수 있다
};

// 메모리 효율적인 코드
class Efficient {
public:
    std::vector<int> data;
    
    // 관련된 데이터는 하나의 벡터에 저장
    // 캐시 지역성 향상
};

// 커스텀 메모리 할당자를 통한 최적화
template<typename T>
class CacheAlignedAllocator : public std::allocator<T> {
public:
    static constexpr size_t CACHE_LINE_SIZE = 64;
    
    T* allocate(size_t n) {
        // 캐시 라인 정렬된 메모리 할당
        void* ptr = _aligned_malloc(n * sizeof(T), CACHE_LINE_SIZE);
        if (!ptr) throw std::bad_alloc();
        return static_cast<T*>(ptr);
    }
    
    void deallocate(T* p, size_t) noexcept {
        _aligned_free(p);
    }
};

int main() {
    // 캐시 정렬된 벡터 사용
    std::vector<float, CacheAlignedAllocator<float>> data(1000000);
    
    // 이렇게 할당되면 False Sharing이 줄어든다
    
    return 0;
}
```

메모리 최적화의 핵심 원칙:

- **캐시 지역성**: 가까이 있는 데이터를 함께 접근한다.
- **정렬**: 적절한 경계에 데이터를 정렬한다.
- **False Sharing 회피**: 서로 다른 스레드가 같은 캐시 라인을 공유하지 않도록 한다.

  

## 5. 실전 예제: 대규모 데이터 처리 파이프라인
지금까지 배운 개념들을 실제로 조합해보자. 다음은 이미지 처리 같은 대규모 데이터를 다루는 시나리오다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <execution>
#include <numeric>
#include <chrono>
#include <cmath>

// 이 프로그램의 목적: 대규모 부동소수점 배열에서 통계를 계산하되,
// 병렬 알고리즘과 성능 최적화를 적용한다.

struct Statistics {
    double mean;
    double variance;
    double min_value;
    double max_value;
};

Statistics compute_statistics(const std::vector<double>& data) {
    if (data.empty()) {
        throw std::invalid_argument("빈 벡터입니다");
    }
    
    // 1단계: 최소값과 최대값 병렬로 찾기
    auto [min_it, max_it] = std::minmax_element(std::execution::par,
                                                data.begin(), data.end());
    
    // 2단계: 평균 병렬로 계산
    double sum = std::reduce(std::execution::par,
                             data.begin(), data.end(),
                             0.0,
                             std::plus<>());
    double mean = sum / data.size();
    
    // 3단계: 분산 계산
    // 먼저 각 원소를 (x - mean)^2로 변환한다
    std::vector<double> squared_diffs(data.size());
    std::transform(std::execution::par,
                   data.begin(), data.end(),
                   squared_diffs.begin(),
                   [mean](double x) {
                       double diff = x - mean;
                       return diff * diff;
                   });
    
    // 제곱 차이의 합을 구한다
    double sum_of_squares = std::reduce(std::execution::par,
                                        squared_diffs.begin(),
                                        squared_diffs.end(),
                                        0.0,
                                        std::plus<>());
    double variance = sum_of_squares / data.size();
    
    return Statistics{
        .mean = mean,
        .variance = variance,
        .min_value = *min_it,
        .max_value = *max_it
    };
}

void benchmark_statistics() {
    const size_t data_size = 100000000;
    std::vector<double> data(data_size);
    
    // 테스트 데이터 생성
    std::generate(std::execution::par,
                  data.begin(), data.end(),
                  [i = 0]() mutable {
                      return std::sin(static_cast<double>(i++) / 1000.0);
                  });
    
    // 성능 측정
    auto start = std::chrono::high_resolution_clock::now();
    Statistics stats = compute_statistics(data);
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "처리 시간: " << duration.count() << "ms\n";
    std::cout << "평균: " << stats.mean << "\n";
    std::cout << "분산: " << stats.variance << "\n";
    std::cout << "최소값: " << stats.min_value << "\n";
    std::cout << "최대값: " << stats.max_value << "\n";
}

int main() {
    try {
        benchmark_statistics();
    } catch (const std::exception& e) {
        std::cerr << "오류: " << e.what() << "\n";
        return 1;
    }
    
    return 0;
}
```

이 예제의 설계 원칙:

1. **타입 안전성**: `Statistics` 구조체로 결과를 명확하게 표현한다.
2. **병렬 실행**: 모든 무거운 연산에 `std::execution::par`를 사용한다.
3. **임시 벡터**: `squared_diffs`는 필요한 중간 결과를 저장한다.
4. **예외 처리**: 빈 벡터는 처리 불가능하므로 예외를 던진다.
5. **성능 측정**: 전체 작업 시간을 측정한다.

  

## 6. C++ Core Guidelines와의 일관성
병렬 알고리즘 사용 시 따라야 할 Core Guidelines:

**Par.1: 최대한 표준 라이브러리 병렬 알고리즘을 사용한다.**

```cpp
// 좋은 예
std::sort(std::execution::par, v.begin(), v.end());

// 나쁜 예 (수동으로 스레드 관리)
std::vector<std::thread> threads;
// ... 복잡한 스레드 관리 코드
```

**Par.2: 알고리즘이 병렬화 가능한지 확인한다.**

```cpp
// 병렬화 불가능 (데이터 의존성)
for (int i = 1; i < n; ++i) {
    v[i] = v[i-1] + 1;  // i-1에 의존
}

// 병렬화 가능
std::transform(std::execution::par, v.begin(), v.end(),
               v.begin(),
               [](int x) { return x + 1; });
```

**Per.7: 성능을 측정하고 근거를 기반으로 최적화한다.**

항상 성능 측정을 통해 병렬화가 실제로 성능을 향상시키는지 확인해야 한다. 작은 데이터셋에서는 병렬화 오버헤드가 이득보다 클 수 있다.

  

## 결론
Chapter 14에서 다룬 병렬 알고리즘과 성능 최적화 기법들은 Modern C++의 힘을 보여준다. `std::execution` 정책을 사용하면 매우 간단하게 코드를 병렬화할 수 있으며, 이는 멀티코어 프로세서의 능력을 완전히 활용한다.

SIMD와 벡터화는 CPU 레벨에서의 추가적인 병렬성을 제공한다. 컴파일러의 자동 벡터화는 대부분의 경우 충분하지만, 특수한 경우에는 Intrinsics를 사용해 더 세밀한 제어를 할 수 있다.

성능 측정은 최적화 과정의 핵심이다. 추측에 기반한 최적화는 종종 틀린다. 따라서 항상 측정을 먼저 하고, 개선되는지 확인한 후에 최적화를 진행해야 한다.

이러한 기법들은 C++ Core Guidelines의 정신을 따르면서도 Rust와 같은 수준의 성능을 제공한다. Modern C++은 더 이상 느리거나 비효율적이지 않다. 올바르게 사용하면, C++은 가장 높은 성능 요구사항을 만족할 수 있는 언어다.    