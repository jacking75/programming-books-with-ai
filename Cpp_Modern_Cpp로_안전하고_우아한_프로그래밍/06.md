# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 6: 컨테이너와 알고리즘의 안전한 사용

## 들어가며: STL은 이미 안전하다
"C++은 배열 접근에서 범위 검사를 안 한다"는 말을 자주 듣는다. 맞다. 하지만 이것은 Low-level C의 이야기이고, Modern C++의 STL 컨테이너는 완전히 다르다.

STL 컨테이너와 알고리즘은 다음을 제공한다:

- **메모리 안전성**: 자동 메모리 관리와 범위 검사
- **버그 방지**: 반복자 무효화 감지, 경계 초과 방지
- **이동 의미론**: 불필요한 복사 제거로 성능 향상
- **타입 안전성**: 템플릿을 통한 컴파일 타임 검증
- **범위 기반 반복**: C++20 ranges로 함수형 프로그래밍

놀랍게도, Rust의 벡터와 C++의 `std::vector`는 거의 동일한 성능과 안전성을 제공한다.

---

## 6.1 STL 컨테이너의 메모리 안전 보장

### 6.1.1 vector: 자동 메모리 관리
`std::vector`는 동적 배열을 안전하게 관리하다.

**과거의 위험한 코드:**
```cpp
// ✗ 위험: 고정 크기 배열
void processData() {
    int arr[100];  // 정확히 100개만 가능
    
    // 101개가 필요하면? 스택 오버플로우 또는 버그
    for (int i = 0; i < 101; ++i) {
        arr[i] = i;  // 배열 초과 접근!
    }
}

// ✗ 위험: 수동 메모리 관리
void processData2() {
    int* arr = new int[100];
    
    // 더 많은 데이터가 들어오면?
    // 수동으로 재할당해야 함
    
    delete[] arr;
}
```

**Modern C++의 안전한 코드:**
```cpp
void processData() {
    std::vector<int> vec;
    
    // 동적으로 필요한만큼 커짐
    for (int i = 0; i < 1000; ++i) {
        vec.push_back(i);
    }
    
    // 자동 메모리 관리
}  // 함수 끝에서 자동으로 메모리 해제
```

`std::vector`의 메모리는 어떻게 관리될까?

```cpp
void vectorMemoryBehavior() {
    std::vector<int> vec;
    
    std::cout << "초기 크기: " << vec.size() << "\n";
    std::cout << "초기 용량: " << vec.capacity() << "\n";
    
    for (int i = 0; i < 10; ++i) {
        vec.push_back(i);
        std::cout << "크기: " << vec.size() 
                 << ", 용량: " << vec.capacity() << "\n";
    }
    
    // 일반적인 증가 패턴:
    // 0개 → 1개 → 2개 → 4개 → 8개 → 16개 → ...
    // (컴파일러에 따라 1.5배 또는 2배 증가)
}

// 출력 예상:
// 초기 크기: 0
// 초기 용량: 0
// 크기: 1, 용량: 1
// 크기: 2, 용량: 2
// 크기: 3, 용량: 4
// 크기: 4, 용량: 4
// 크기: 5, 용량: 8
// ...
```

### 6.1.2 범위 검사와 안전한 접근
`std::vector`는 범위를 검사한다:

```cpp
void safeAccess() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // 방법 1: 범위 검사 있음 (권장)
    try {
        int value = vec.at(10);  // 범위를 벗어남
    } catch (const std::out_of_range& e) {
        std::cout << "에러: " << e.what() << "\n";  // 출력: "vector::_M_range_check"
    }
    
    // 방법 2: 범위 검사 없음 (저수준)
    // int value = vec[10];  // 정의되지 않은 동작! 사용 금지
    
    // 방법 3: 안전한 범위 확인
    if (10 < vec.size()) {
        int value = vec[10];  // 안전
    }
}
```

**C++ Core Guidelines:**

```cpp
// ✓ Good: at()로 범위 검사
std::vector<int> vec = {1, 2, 3};
int value = vec.at(0);  // 안전

// ✗ Bad: []로 범위 검사 없음
int unsafe = vec[100];  // 정의되지 않은 동작
```

### 6.1.3 vector와 Rust의 비교
놀랍게도 `std::vector`와 Rust의 `Vec<T>`는 거의 동일하다:

```cpp
// Modern C++
std::vector<int> vec;
vec.push_back(1);
vec.push_back(2);

int first = vec.at(0);  // 범위 검사
int last = vec.back();  // 마지막 요소
```

```rust
// Rust
let mut vec = Vec::new();
vec.push(1);
vec.push(2);

let first = vec[0];  // 범위 검사 (패닉 가능)
let last = vec.last();  // 마지막 요소
```

성능도 거의 동일하다. 두 언어 모두 동적 배열의 기본 구현을 사용한다.

### 6.1.4 다른 컨테이너들

**std::map: 정렬된 연관 배열**
```cpp
void mapExample() {
    std::map<std::string, int> scores;
    
    // 삽입 - 자동 정렬
    scores["Alice"] = 95;
    scores["Bob"] = 87;
    scores["Charlie"] = 92;
    
    // 범위 검사와 함께 접근
    try {
        int score = scores.at("David");  // 없음
    } catch (const std::out_of_range&) {
        std::cout << "David의 점수 없음\n";
    }
    
    // 안전한 접근 - 없으면 0 반환
    int bobScore = scores.count("Bob") ? scores["Bob"] : 0;
}
```

**std::unordered_map: 해시맵**
```cpp
void unorderedMapExample() {
    std::unordered_map<int, std::string> dictionary;
    
    dictionary[1] = "one";
    dictionary[2] = "two";
    dictionary[3] = "three";
    
    // 빠른 조회
    if (dictionary.find(2) != dictionary.end()) {
        std::cout << dictionary[2] << "\n";
    }
}
```

**std::deque: 양방향 큐**
```cpp
void dequeExample() {
    std::deque<int> dq;
    
    dq.push_back(1);
    dq.push_back(2);
    dq.push_front(0);
    
    // 양쪽 끝에서 빠른 접근
    std::cout << dq.front() << " " << dq.back() << "\n";  // 0 2
    
    // 범위 검사
    int value = dq.at(1);  // 안전
}
```

**std::set: 정렬된 유니크 집합**
```cpp
void setExample() {
    std::set<int> uniqueNumbers = {3, 1, 4, 1, 5, 9, 2, 6};
    
    // 자동으로 정렬되고 중복 제거
    for (int num : uniqueNumbers) {
        std::cout << num << " ";  // 1 2 3 4 5 6 9
    }
    std::cout << "\n";
    
    // 존재 확인
    if (uniqueNumbers.count(5)) {
        std::cout << "5는 집합에 있습니다\n";
    }
}
```

### 6.1.5 컨테이너 선택 가이드

```cpp
#include <vector>
#include <map>
#include <set>
#include <deque>
#include <list>

// 선택 기준
struct ContainerGuide {
    // vector: 일반적인 용도 (대부분의 경우)
    // - 장점: 빠른 랜덤 접근, 메모리 효율
    // - 단점: 중간 삽입/삭제 느림
    
    std::vector<int> general_purpose;
    
    // deque: 양쪽에서 자주 추가/제거
    // - 장점: 앞뒤 삽입/삭제 빠름
    // - 단점: 메모리 불연속
    std::deque<int> queue_like;
    
    // list: 중간에 자주 삽입/삭제
    // - 장점: 중간 삽입/삭제 빠름
    // - 단점: 랜덤 접근 느림, 메모리 오버헤드
    std::list<int> frequent_insertion;
    
    // map: 정렬된 키-값 쌍
    // - 장점: 정렬 유지, 범위 검색
    // - 단점: 조회 O(log n)
    std::map<std::string, int> sorted_pairs;
    
    // unordered_map: 해시 기반 키-값 쌍
    // - 장점: 빠른 조회 O(1) 평균
    // - 단점: 정렬 안 됨
    std::unordered_map<std::string, int> hash_pairs;
    
    // set: 정렬된 유니크 요소
    // - 장점: 유니크 유지, 정렬됨
    // - 단점: 삽입/삭제 O(log n)
    std::set<int> unique_sorted;
};
```

---

## 6.2 범위 기반 for문과 안전한 순회

### 6.2.1 범위 기반 for문의 우아함
C++11의 범위 기반 for문은 가장 중요한 개선 중 하나이다:

**과거의 위험한 코드:**
```cpp
// ✗ 위험: 인덱스 기반 루프
{
    std::vector<int> vec = {1, 2, 3, 4, 5};
    for (int i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << "\n";
}

// ✗ 위험: off-by-one 에러
{
    std::vector<int> vec = {1, 2, 3, 4, 5};
    for (int i = 0; i <= vec.size(); ++i) {  // 경계 초과!
        std::cout << vec[i] << " ";
    }
}
```

**Modern C++의 안전한 코드:**
```cpp
// ✓ 안전: 범위 기반 for
{
    std::vector<int> vec = {1, 2, 3, 4, 5};
    for (int value : vec) {  // 더 간단하고 안전
        std::cout << value << " ";
    }
    std::cout << "\n";
}
```

범위 기반 for문의 장점:

1. **오류 방지**: 인덱스 오류 불가능
2. **성능**: 컴파일러가 최적화 가능
3. **가독성**: 코드가 더 읽기 쉬움
4. **유연성**: 모든 컨테이너에 작동

### 6.2.2 값 vs 참조 vs const 참조
범위 기반 for문에서 올바른 선택은 성능에 큰 영향을 미친다:  

```cpp
struct Person {
    std::string name;
    int age;
    std::vector<int> history;  // 큰 데이터
};

void demonstrateRangeLoop() {
    std::vector<Person> people = {
        {"Alice", 30, {1, 2, 3}},
        {"Bob", 25, {4, 5, 6}},
        {"Charlie", 35, {7, 8, 9}}
    };
    
    // ✗ 비효율: 불필요한 복사 (매우 느림!)
    for (auto person : people) {  // Person 객체 전체 복사
        std::cout << person.name << "\n";
    }
    
    // ✓ 권장: const 참조 (읽기만 함)
    for (const auto& person : people) {
        std::cout << person.name << " (" << person.age << ")\n";
    }
    
    // ✓ 선택: 가변 참조 (수정함)
    for (auto& person : people) {
        person.age++;  // 나이 증가
    }
    
    // ✓ 선택: 이동 의미론 (소유권 이전)
    std::vector<std::string> names;
    std::vector<std::string> sourceNames = {"Alice", "Bob", "Charlie"};
    
    for (auto&& name : sourceNames) {  // R-value 참조
        names.push_back(std::move(name));
    }
}
```

**성능 비교:**
```cpp
#include <chrono>

struct LargeData {
    std::vector<int> data;
    std::string text;
    
    LargeData() : data(10000), text("x" * 1000) {}
};

void performanceComparison() {
    std::vector<LargeData> items(1000);
    
    // 비효율: 복사
    auto start1 = std::chrono::high_resolution_clock::now();
    {
        for (auto item : items) {  // 복사!
            volatile int size = item.data.size();
            (void)size;
        }
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // 효율: const 참조
    auto start2 = std::chrono::high_resolution_clock::now();
    {
        for (const auto& item : items) {  // 참조!
            volatile int size = item.data.size();
            (void)size;
        }
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    
    std::cout << "복사: " << duration1.count() << "ms\n";
    std::cout << "참조: " << duration2.count() << "ms\n";
}
```

### 6.2.3 반복자와 반복자 무효화
반복자(iterator)는 "컨테이너의 요소를 가리키는 포인터"이다:

```cpp
void iteratorBasics() {
    std::vector<int> vec = {10, 20, 30, 40, 50};
    
    // 반복자 얻기
    auto it = vec.begin();
    
    // 반복자로 접근
    std::cout << *it << "\n";  // 10
    
    ++it;
    std::cout << *it << "\n";  // 20
    
    // 범위 기반 for는 내부적으로 반복자 사용
    for (int value : vec) {
        std::cout << value << " ";
    }
    std::cout << "\n";
}
```

**반복자 무효화 문제:**
```cpp
void iteratorInvalidation() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // ✗ 위험: 루프 중 요소 추가
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
        vec.push_back(*it * 10);  // 위험! 반복자 무효화 가능
    }
    
    // ✓ 안전: 범위 기반 for로 보호
    // (C++11/14는 완전히 안전하지 않을 수 있음)
    std::vector<int> vec2 = {1, 2, 3, 4, 5};
    std::vector<int> temp;
    
    for (int value : vec2) {
        temp.push_back(value * 10);
    }
    
    // 혹은 이후에 추가
    for (int value : vec2) {
        std::cout << value << " ";
    }
    
    vec2.insert(vec2.end(), temp.begin(), temp.end());
}
```

**C++ Core Guidelines:**
```cpp
// ✓ Good: 범위 기반 for
for (const auto& element : container) {
    process(element);
}

// ✗ Bad: 인덱스 기반 루프 (필요한 경우만)
for (size_t i = 0; i < container.size(); ++i) {
    process(container[i]);
}

// ✗ Bad: 반복자 수동 조작 (필요한 경우만)
for (auto it = container.begin(); it != container.end(); ++it) {
    process(*it);
}
```

---

## 6.3 알고리즘 라이브러리 활용한 버그 방지

### 6.3.1 std::find와 std::find_if
`std::find`를 사용하면 예측 가능한 버그를 방지한다:

```cpp
void findExample() {
    std::vector<int> scores = {85, 92, 78, 95, 88, 91};
    
    // 값 찾기
    auto it = std::find(scores.begin(), scores.end(), 92);
    
    if (it != scores.end()) {
        std::cout << "92를 찾았습니다\n";
        int index = std::distance(scores.begin(), it);
        std::cout << "위치: " << index << "\n";
    } else {
        std::cout << "92를 찾을 수 없습니다\n";
    }
}

void findIfExample() {
    std::vector<int> scores = {85, 92, 78, 95, 88, 91};
    
    // 조건에 맞는 요소 찾기
    auto it = std::find_if(scores.begin(), scores.end(),
        [](int score) { return score >= 90; });
    
    if (it != scores.end()) {
        std::cout << "90점 이상: " << *it << "\n";
    }
    
    // 모든 90점 이상 점수 찾기
    std::vector<int> highScores;
    std::copy_if(scores.begin(), scores.end(),
        std::back_inserter(highScores),
        [](int score) { return score >= 90; });
    
    for (int score : highScores) {
        std::cout << score << " ";
    }
    std::cout << "\n";
}
```

### 6.3.2 std::sort와 std::stable_sort
정렬은 버그가 많은 영역이다. STL 알고리즘을 사용하자:  
  
```cpp
struct Student {
    std::string name;
    int score;
    int enrollmentOrder;
    
    Student(const std::string& n, int s, int eo)
        : name(n), score(s), enrollmentOrder(eo) {}
};

void sortingExample() {
    std::vector<Student> students = {
        {"Alice", 95, 1},
        {"Bob", 95, 2},
        {"Charlie", 88, 3},
        {"David", 92, 4}
    };
    
    // 일반 정렬: 순서 보장 안 함
    std::sort(students.begin(), students.end(),
        [](const Student& a, const Student& b) {
            return a.score > b.score;
        });
    
    std::cout << "일반 정렬:\n";
    for (const auto& s : students) {
        std::cout << s.name << ": " << s.score << "\n";
    }
    
    // 안정 정렬: 같은 점수면 원래 순서 유지
    std::stable_sort(students.begin(), students.end(),
        [](const Student& a, const Student& b) {
            return a.score > b.score;
        });
    
    std::cout << "\n안정 정렬:\n";
    for (const auto& s : students) {
        std::cout << s.name << ": " << s.score 
                 << " (등록순서: " << s.enrollmentOrder << ")\n";
    }
}
```

### 6.3.3 std::transform으로 함수형 프로그래밍
요소를 변환하면서 오류를 방지한다:  
  
```cpp
void transformExample() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    std::vector<int> squared;
    
    // 각 요소를 제곱
    std::transform(numbers.begin(), numbers.end(),
        std::back_inserter(squared),
        [](int x) { return x * x; });
    
    for (int n : squared) {
        std::cout << n << " ";  // 1 4 9 16 25
    }
    std::cout << "\n";
}

void transformStringsExample() {
    std::vector<std::string> names = {"alice", "bob", "charlie"};
    std::vector<std::string> uppercased;
    
    // 대문자 변환
    std::transform(names.begin(), names.end(),
        std::back_inserter(uppercased),
        [](const std::string& name) {
            std::string upper = name;
            std::transform(upper.begin(), upper.end(), 
                          upper.begin(), ::toupper);
            return upper;
        });
    
    for (const auto& name : uppercased) {
        std::cout << name << " ";  // ALICE BOB CHARLIE
    }
    std::cout << "\n";
}
```

### 6.3.4 std::any_of, std::all_of, std::none_of
술어 함수로 컨테이너를 검사한다:  
  
```cpp
void predicateExample() {
    std::vector<int> scores = {85, 92, 78, 95, 88, 91};
    
    // 적어도 하나가 90점 이상인가?
    if (std::any_of(scores.begin(), scores.end(),
                    [](int s) { return s >= 90; })) {
        std::cout << "90점 이상인 학생이 있습니다\n";
    }
    
    // 모두 60점 이상인가?
    if (std::all_of(scores.begin(), scores.end(),
                    [](int s) { return s >= 60; })) {
        std::cout << "모든 학생이 60점 이상입니다\n";
    }
    
    // 모두 100점 미만인가?
    if (std::none_of(scores.begin(), scores.end(),
                     [](int s) { return s >= 100; })) {
        std::cout << "100점인 학생은 없습니다\n";
    }
}
```

### 6.3.5 std::accumulate와 std::reduce
합계 계산을 안전하게 한다:

```cpp
#include <numeric>

void accumulateExample() {
    std::vector<int> scores = {85, 92, 78, 95, 88, 91};
    
    // 합계 계산
    int total = std::accumulate(scores.begin(), scores.end(), 0);
    std::cout << "합계: " << total << "\n";
    
    // 평균 계산
    double average = static_cast<double>(total) / scores.size();
    std::cout << "평균: " << average << "\n";
    
    // 최댓값 찾기 (accumulate 사용)
    int maxScore = std::accumulate(scores.begin(), scores.end(), 
        scores[0],
        [](int max_so_far, int current) {
            return std::max(max_so_far, current);
        });
    std::cout << "최댓값: " << maxScore << "\n";
    
    // 또는 더 간단하게
    auto [minScore, maxScore2] = std::minmax_element(
        scores.begin(), scores.end());
    std::cout << "최솟값: " << *minScore << ", 최댓값: " << *maxScore2 << "\n";
}
```

### 6.3.6 알고리즘 라이브러리 선택 가이드

```cpp
#include <algorithm>
#include <numeric>

void algorithmGuide() {
    std::vector<int> data = {3, 1, 4, 1, 5, 9, 2, 6};
    
    // 검색
    auto it = std::find(data.begin(), data.end(), 5);  // 값 찾기
    auto it2 = std::find_if(data.begin(), data.end(), 
                           [](int x) { return x > 5; });  // 조건 찾기
    
    // 변환
    std::vector<int> doubled;
    std::transform(data.begin(), data.end(),
                  std::back_inserter(doubled),
                  [](int x) { return x * 2; });
    
    // 필터링
    std::vector<int> evens;
    std::copy_if(data.begin(), data.end(),
                std::back_inserter(evens),
                [](int x) { return x % 2 == 0; });
    
    // 정렬
    std::sort(data.begin(), data.end());
    std::stable_sort(data.begin(), data.end());
    
    // 제거
    auto newEnd = std::remove_if(data.begin(), data.end(),
                                [](int x) { return x < 3; });
    data.erase(newEnd, data.end());
    
    // 계산
    int sum = std::accumulate(data.begin(), data.end(), 0);
    double product = std::accumulate(data.begin(), data.end(), 1.0,
                                    [](double a, int b) {
                                        return a * b;
                                    });
    
    // 술어
    bool hasLarge = std::any_of(data.begin(), data.end(),
                               [](int x) { return x > 5; });
    bool allPositive = std::all_of(data.begin(), data.end(),
                                  [](int x) { return x > 0; });
}
```

---

## 6.4 C++20 ranges로 더욱 안전한 데이터 처리

### 6.4.1 ranges: 차세대 알고리즘 라이브러리
C++20의 ranges 라이브러리는 STL 알고리즘을 더 안전하고 간결하게 만든다:

```cpp
#include <ranges>
#include <algorithm>
#include <iostream>

void rangesBasics() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 과거: 번거로운 begin(), end()
    std::vector<int> result1;
    std::copy_if(numbers.begin(), numbers.end(),
                std::back_inserter(result1),
                [](int x) { return x % 2 == 0; });
    
    // C++20: ranges로 간결함
    auto result2 = numbers
        | std::views::filter([](int x) { return x % 2 == 0; })
        | std::views::transform([](int x) { return x * 2; });
    
    for (int n : result2) {
        std::cout << n << " ";  // 4 8 12 16 20
    }
    std::cout << "\n";
}

void rangesAdvanced() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 파이프라인 스타일 처리
    auto result = numbers
        | std::views::filter([](int x) { return x > 2; })        // 3부터 10까지
        | std::views::transform([](int x) { return x * x; })      // 제곱
        | std::views::take(3);                                     // 처음 3개
    
    for (int n : result) {
        std::cout << n << " ";  // 9 16 25
    }
    std::cout << "\n";
}
```

### 6.4.2 ranges::sort와 안전한 정렬

```cpp
#include <ranges>
#include <algorithm>

struct Person {
    std::string name;
    int age;
};

void rangesSortExample() {
    std::vector<Person> people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35}
    };
    
    // C++20: 더 간결한 sort
    std::ranges::sort(people,
        [](const Person& a, const Person& b) {
            return a.age < b.age;
        });
    
    for (const auto& p : people) {
        std::cout << p.name << ": " << p.age << "\n";
    }
    
    // 멤버로 정렬
    std::ranges::sort(people, {}, &Person::age);
}
```

### 6.4.3 ranges::find와 ranges::find_if

```cpp
#include <ranges>
#include <algorithm>

void rangesFindExample() {
    std::vector<int> scores = {85, 92, 78, 95, 88, 91};
    
    // C++20: begin(), end() 불필요
    auto it = std::ranges::find(scores, 92);
    
    if (it != scores.end()) {
        std::cout << "92를 찾았습니다\n";
    }
    
    // 조건으로 찾기
    auto it2 = std::ranges::find_if(scores,
        [](int s) { return s >= 90; });
    
    if (it2 != scores.end()) {
        std::cout << "90 이상: " << *it2 << "\n";
    }
}
```

### 6.4.4 views::iota로 범위 생성

```cpp
#include <ranges>
#include <iostream>

void iotaExample() {
    // 0부터 9까지
    for (int i : std::views::iota(0, 10)) {
        std::cout << i << " ";  // 0 1 2 3 4 5 6 7 8 9
    }
    std::cout << "\n";
    
    // 무한 범위 (take로 제한)
    for (int i : std::views::iota(0) | std::views::take(5)) {
        std::cout << i << " ";  // 0 1 2 3 4
    }
    std::cout << "\n";
}
```

### 6.4.5 views::chunk로 청크 처리

```cpp
#include <ranges>
#include <iostream>

void chunkExample() {
    std::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // 3개씩 묶어서 처리
    for (auto chunk : data | std::views::chunk(3)) {
        std::cout << "청크: ";
        for (int n : chunk) {
            std::cout << n << " ";
        }
        std::cout << "\n";
    }
    
    // 출력:
    // 청크: 1 2 3
    // 청크: 4 5 6
    // 청크: 7 8 9
}
```

### 6.4.6 범위 조합: 복잡한 쿼리

```cpp
#include <ranges>
#include <vector>
#include <iostream>

struct Transaction {
    std::string category;
    int amount;
    int day;
};

void complexRangeExample() {
    std::vector<Transaction> transactions = {
        {"Food", 50, 1},
        {"Transport", 30, 1},
        {"Food", 80, 2},
        {"Entertainment", 100, 2},
        {"Food", 45, 3},
        {"Transport", 25, 3}
    };
    
    // 식비 중 50 이상인 것들의 합계
    int foodTotal = 0;
    for (auto& t : transactions
        | std::views::filter([](const Transaction& t) {
            return t.category == "Food" && t.amount >= 50;
        })) {
        foodTotal += t.amount;
    }
    
    std::cout << "50 이상의 식비 합계: " << foodTotal << "\n";
    
    // 각 카테고리별로 출력
    for (auto& t : transactions
        | std::views::filter([](const Transaction& t) {
            return t.amount >= 30;
        })
        | std::views::transform([](const Transaction& t) {
            return t.category;
        })) {
        std::cout << t << "\n";
    }
}
```

### 6.4.7 C++20 ranges vs 전통적 알고리즘

```cpp
#include <ranges>
#include <algorithm>
#include <vector>

void comparisonExample() {
    std::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 전통: "4개 이상 20 이하인 짝수" 추출
    std::vector<int> result1;
    std::copy_if(data.begin(), data.end(),
                std::back_inserter(result1),
                [](int x) {
                    return x >= 4 && x <= 20 && x % 2 == 0;
                });
    
    // C++20 ranges: 더 읽기 쉬움
    auto result2 = data
        | std::views::filter([](int x) { return x >= 4; })
        | std::views::filter([](int x) { return x <= 20; })
        | std::views::filter([](int x) { return x % 2 == 0; });
    
    // 또는 한 번에
    auto result3 = data
        | std::views::filter([](int x) {
            return x >= 4 && x <= 20 && x % 2 == 0;
        });
}
```

---

## 6.5 실전 프로젝트: 데이터 처리 파이프라인
이제 배운 모든 내용을 실전 프로젝트에 적용하자:

```cpp
#include <vector>
#include <algorithm>
#include <numeric>
#include <iostream>
#include <iomanip>
#include <ranges>

struct StudentGrade {
    std::string name;
    int korean;
    int english;
    int math;
    
    int getTotal() const {
        return korean + english + math;
    }
    
    double getAverage() const {
        return getTotal() / 3.0;
    }
};

class GradeAnalyzer {
private:
    std::vector<StudentGrade> students;
    
public:
    void addStudent(const StudentGrade& student) {
        students.push_back(student);
    }
    
    // 모든 학생의 총점 정렬
    void displayByTotal() {
        std::vector<StudentGrade> sorted = students;
        
        // 범위 기반 for로 안전하게 정렬
        std::sort(sorted.begin(), sorted.end(),
            [](const StudentGrade& a, const StudentGrade& b) {
                return a.getTotal() > b.getTotal();
            });
        
        std::cout << "총점 순서:\n";
        std::cout << std::left << std::setw(15) << "이름"
                 << std::setw(10) << "국어"
                 << std::setw(10) << "영어"
                 << std::setw(10) << "수학"
                 << std::setw(10) << "총점"
                 << std::setw(10) << "평균\n";
        
        for (const auto& student : sorted) {
            std::cout << std::left << std::setw(15) << student.name
                     << std::setw(10) << student.korean
                     << std::setw(10) << student.english
                     << std::setw(10) << student.math
                     << std::setw(10) << student.getTotal()
                     << std::fixed << std::setprecision(2)
                     << student.getAverage() << "\n";
        }
    }
    
    // 평균 80 이상인 학생
    void displayTopStudents() {
        std::cout << "\n평균 80 이상인 학생:\n";
        
        for (const auto& student : students) {
            if (student.getAverage() >= 80) {
                std::cout << student.name << ": "
                         << std::fixed << std::setprecision(2)
                         << student.getAverage() << "\n";
            }
        }
    }
    
    // 각 과목별 통계
    void displayStatistics() {
        std::cout << "\n과목별 통계:\n";
        
        // 국어
        int koreanSum = std::accumulate(students.begin(), 
                                       students.end(), 0,
            [](int sum, const StudentGrade& s) {
                return sum + s.korean;
            });
        double koreanAvg = static_cast<double>(koreanSum) 
                          / students.size();
        
        auto [minKorean, maxKorean] = std::minmax_element(
            students.begin(), students.end(),
            [](const StudentGrade& a, const StudentGrade& b) {
                return a.korean < b.korean;
            });
        
        std::cout << "국어 - 평균: " << std::fixed 
                 << std::setprecision(2) << koreanAvg
                 << ", 최소: " << minKorean->korean
                 << ", 최대: " << maxKorean->korean << "\n";
        
        // 영어
        int englishSum = std::accumulate(students.begin(),
                                        students.end(), 0,
            [](int sum, const StudentGrade& s) {
                return sum + s.english;
            });
        double englishAvg = static_cast<double>(englishSum)
                           / students.size();
        
        auto [minEnglish, maxEnglish] = std::minmax_element(
            students.begin(), students.end(),
            [](const StudentGrade& a, const StudentGrade& b) {
                return a.english < b.english;
            });
        
        std::cout << "영어 - 평균: " << englishAvg
                 << ", 최소: " << minEnglish->english
                 << ", 최대: " << maxEnglish->english << "\n";
        
        // 수학
        int mathSum = std::accumulate(students.begin(),
                                     students.end(), 0,
            [](int sum, const StudentGrade& s) {
                return sum + s.math;
            });
        double mathAvg = static_cast<double>(mathSum)
                        / students.size();
        
        auto [minMath, maxMath] = std::minmax_element(
            students.begin(), students.end(),
            [](const StudentGrade& a, const StudentGrade& b) {
                return a.math < b.math;
            });
        
        std::cout << "수학 - 평균: " << mathAvg
                 << ", 최소: " << minMath->math
                 << ", 최대: " << maxMath->math << "\n";
    }
    
    // 특정 과목이 가장 높은 학생
    void displaySubjectToppers() {
        std::cout << "\n각 과목 최고 점수자:\n";
        
        auto koreanTopper = std::max_element(
            students.begin(), students.end(),
            [](const StudentGrade& a, const StudentGrade& b) {
                return a.korean < b.korean;
            });
        std::cout << "국어: " << koreanTopper->name 
                 << " (" << koreanTopper->korean << ")\n";
        
        auto englishTopper = std::max_element(
            students.begin(), students.end(),
            [](const StudentGrade& a, const StudentGrade& b) {
                return a.english < b.english;
            });
        std::cout << "영어: " << englishTopper->name
                 << " (" << englishTopper->english << ")\n";
        
        auto mathTopper = std::max_element(
            students.begin(), students.end(),
            [](const StudentGrade& a, const StudentGrade& b) {
                return a.math < b.math;
            });
        std::cout << "수학: " << mathTopper->name
                 << " (" << mathTopper->math << ")\n";
    }
    
    // C++20 ranges 활용
    void displayWithRanges() {
        std::cout << "\n[C++20 ranges 활용]\n";
        std::cout << "평균 75 이상인 학생들의 이름:\n";
        
        // C++20만 가능
        #if __cplusplus >= 202002L
        for (const auto& name : students
            | std::views::filter([](const StudentGrade& s) {
                return s.getAverage() >= 75;
            })
            | std::views::transform([](const StudentGrade& s) {
                return s.name;
            })) {
            std::cout << name << "\n";
        }
        #else
        std::cout << "(C++20 이상 필요)\n";
        #endif
    }
};

int main() {
    GradeAnalyzer analyzer;
    
    // 학생 데이터 추가
    analyzer.addStudent({"Alice", 95, 87, 92});
    analyzer.addStudent({"Bob", 82, 88, 79});
    analyzer.addStudent({"Charlie", 90, 92, 88});
    analyzer.addStudent({"David", 78, 85, 91});
    analyzer.addStudent({"Eve", 88, 90, 85});
    
    // 다양한 분석 출력
    analyzer.displayByTotal();
    analyzer.displayTopStudents();
    analyzer.displayStatistics();
    analyzer.displaySubjectToppers();
    analyzer.displayWithRanges();
    
    return 0;
}
```

**실행 결과:**
```
총점 순서:
이름           국어      영어      수학      총점      평균
Charlie        90        92        88        270       90.00
Alice          95        87        92        274       91.33
Eve            88        90        85        263       87.67
Bob            82        88        79        249       83.00
David          78        85        91        254       84.67

평균 80 이상인 학생:
Charlie: 90.00
Alice: 91.33
Eve: 87.67
Bob: 83.00
David: 84.67

과목별 통계:
국어 - 평균: 86.60, 최소: 78, 최대: 95
영어 - 평균: 88.40, 최소: 85, 최대: 92
수학 - 평균: 87.00, 최소: 79, 최대: 92

각 과목 최고 점수자:
국어: Alice (95)
영어: Charlie (92)
수학: David (91)

[C++20 ranges 활용]
평균 75 이상인 학생들의 이름:
Alice
Bob
Charlie
David
Eve
```

---

## 6.6 컨테이너와 알고리즘의 성능

### 6.6.1 컨테이너 성능 특성

```cpp
#include <vector>
#include <list>
#include <deque>
#include <chrono>
#include <iostream>

template<typename Container>
void measureInsertionTime(const std::string& name) {
    auto start = std::chrono::high_resolution_clock::now();
    
    Container c;
    for (int i = 0; i < 100000; ++i) {
        c.push_back(i);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<
        std::chrono::milliseconds>(end - start);
    
    std::cout << name << ": " << duration.count() << "ms\n";
}

void performanceComparison() {
    measureInsertionTime<std::vector<int>>("std::vector");
    measureInsertionTime<std::deque<int>>("std::deque");
    measureInsertionTime<std::list<int>>("std::list");
}
```

| 작업 | vector | deque | list |
|------|--------|-------|------|
| push_back | O(1) amortized | O(1) amortized | O(1) |
| push_front | O(n) | O(1) | O(1) |
| 랜덤 접근 | O(1) | O(1) | O(n) |
| 중간 삽입 | O(n) | O(n) | O(1) |
| 메모리 사용 | 효율적 | 중간 | 낮음 |

### 6.6.2 알고리즘의 시간 복잡도

```cpp
#include <algorithm>
#include <vector>

void algorithmComplexity() {
    std::vector<int> data(1000);
    
    // O(n)
    std::find(data.begin(), data.end(), 500);
    std::count_if(data.begin(), data.end(), 
                 [](int x) { return x > 500; });
    
    // O(n log n)
    std::sort(data.begin(), data.end());
    
    // O(log n) - 정렬된 컨테이너 필수
    std::binary_search(data.begin(), data.end(), 500);
    
    // O(n) 또는 O(n log n) - 구현에 따라 다름
    std::nth_element(data.begin(), data.begin() + 500, data.end());
}
```

---

## 6.7 자주 하는 실수와 해결책

### 실수 1: 루프 중에 컨테이너 수정

```cpp
// ✗ 위험: 범위 기반 for 중 요소 추가
{
    std::vector<int> vec = {1, 2, 3};
    for (auto& item : vec) {
        vec.push_back(item * 2);  // 위험!
    }
}

// ✓ 안전: 별도 컨테이너에 저장
{
    std::vector<int> vec = {1, 2, 3};
    std::vector<int> temp;
    for (const auto& item : vec) {
        temp.push_back(item * 2);
    }
    vec.insert(vec.end(), temp.begin(), temp.end());
}
```

### 실수 2: 범위 기반 for에서 불필요한 복사

```cpp
// ✗ 비효율: 매번 복사
std::vector<std::string> names = {"Alice", "Bob", "Charlie"};
for (auto name : names) {  // 매번 복사!
    std::cout << name << "\n";
}

// ✓ 효율: const 참조
for (const auto& name : names) {
    std::cout << name << "\n";
}
```

### 실수 3: at() 대신 [] 사용

```cpp
// ✗ 범위 검사 없음
std::vector<int> vec = {1, 2, 3};
int value = vec[100];  // 정의되지 않은 동작

// ✓ 범위 검사
try {
    int value = vec.at(100);
} catch (const std::out_of_range&) {
    std::cout << "범위 벗어남\n";
}
```

### 실수 4: find() 반환값 확인 안 함

```cpp
// ✗ 위험: 반환값 확인 안 함
std::vector<int> vec = {1, 2, 3};
auto it = std::find(vec.begin(), vec.end(), 99);
std::cout << *it << "\n";  // 크래시!

// ✓ 안전: 반환값 확인
auto it = std::find(vec.begin(), vec.end(), 99);
if (it != vec.end()) {
    std::cout << *it << "\n";
}
```

---

## 6.8 Modern C++ vs Rust: 컨테이너와 알고리즘 비교

| 기능 | Modern C++ | Rust |
|------|-----------|------|
| 동적 배열 | `std::vector` | `Vec<T>` |
| 정렬된 맵 | `std::map` | `BTreeMap` |
| 해시맵 | `std::unordered_map` | `HashMap` |
| 정렬 | `std::sort` | `.sort()` |
| 필터링 | `std::copy_if` 또는 `views::filter` | `.iter().filter()` |
| 변환 | `std::transform` 또는 `views::transform` | `.iter().map()` |
| 합계 | `std::accumulate` 또는 `std::reduce` | `.iter().sum()` |

**Rust:**
```rust
let numbers = vec![1, 2, 3, 4, 5];

let result: Vec<_> = numbers
    .iter()
    .filter(|x| x % 2 == 0)
    .map(|x| x * 2)
    .collect();
```

**Modern C++:**
```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

auto result = numbers
    | std::views::filter([](int x) { return x % 2 == 0; })
    | std::views::transform([](int x) { return x * 2; });
```

거의 동일합니다!

---

## 6.9 요약: 안전한 데이터 처리
Modern C++의 컨테이너와 알고리즘을 올바르게 사용하면:

1. **메모리 안전성**: 자동 관리, 범위 검사
2. **버그 방지**: 반복자 무효화 감지, off-by-one 에러 제거
3. **코드 간결성**: 범위 기반 for, 알고리즘 라이브러리
4. **성능**: 컴파일 타임 최적화, 이동 의미론
5. **현대성**: C++20 ranges로 함수형 프로그래밍
6. **Rust 수준의 안전성**: 다양한 검사와 보장

C++의 STL은 Rust의 표준 라이브러리와 동등한 안전성과 성능을 제공한다. 중요한 것은 **제대로 사용하는 것**이다.

다음 장에서는 C++의 강력한 타입 시스템이 어떻게 컴파일 타임에 오류를 방지하는지 살펴보겠다.

 