# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 13: 고급 동시성 패턴

## 소개
Modern C++에서 동시성 프로그래밍은 더 이상 어렵고 위험한 작업이 아니다. Chapter 12에서 기초적인 스레드와 동기화 메커니즘을 배웠다면, 이제 실무에서 자주 마주치는 고급 패턴들을 살펴볼 차례다. 이 장에서는 `std::future`와 `std::promise`를 통한 비동기 작업 처리, 효율적인 작업 처리를 위한 스레드 풀 구현, 그리고 C++20의 혁신적인 기능인 코루틴까지 다룬다.

이들 패턴은 C++ Core Guidelines의 철학을 따르면서도 Rust의 안전성과 비슷한 수준의 보장을 제공한다. RAII 원칙에 기반한 리소스 관리와 예외 안전성을 고려한 설계가 핵심이다. 학생들은 이 장을 통해 현대적이고 안전한 동시성 코드를 작성하는 방법을 습득하게 될 것이다.


## 1. std::future와 std::promise 활용

### 1.1 비동기 작업의 새로운 패러다임
전통적인 스레드 기반 프로그래밍에서는 여러 스레드가 공유 자원에 접근하고, 뮤텍스로 보호하며, 조건 변수로 신호를 보내야 했다. 이 방식은 데드락, 레이스 컨디션, 그리고 복잡한 상태 관리의 위험을 안고 있다.

C++11에서 도입된 `std::future`와 `std::promise`는 이러한 문제를 근본적으로 해결한다. 이들은 **값의 전달과 동기화를 안전하게** 처리하는 높은 수준의 추상화를 제공한다. `std::promise`는 값을 설정하는 쪽에서 사용하고, `std::future`는 그 값을 받는 쪽에서 사용한다. 둘 사이의 통신은 프레임워크가 안전하게 관리한다.

### 1.2 std::promise와 std::future의 기본 사용법
다음 예제를 보자.

```cpp
#include <iostream>
#include <thread>
#include <future>

int main() {
    // std::promise는 값을 설정할 책임을 가진다
    std::promise<int> promise;
    
    // std::future는 그 값을 받을 책임을 가진다
    std::future<int> future = promise.get_future();
    
    // 백그라운드 스레드에서 값을 설정한다
    std::thread worker([&promise]() {
        std::cout << "작업 중...\n";
        // 무거운 계산을 수행한다고 가정
        int result = 42;
        promise.set_value(result);
        std::cout << "작업 완료\n";
    });
    
    // 메인 스레드는 값이 준비될 때까지 대기한다
    std::cout << "결과를 기다리는 중...\n";
    int result = future.get();  // 블로킹 호출
    std::cout << "받은 결과: " << result << "\n";
    
    worker.join();
    return 0;
}
```

이 코드의 핵심을 설명하면, `promise`와 `future`는 동일한 공유 상태를 가리킨다. `set_value()`를 호출하면 그 값이 공유 상태에 저장되고, `get()`을 호출하는 `future`는 값이 설정될 때까지 자동으로 대기한다. 뮤텍스나 조건 변수를 명시적으로 사용할 필요가 없다.

### 1.3 std::async를 사용한 더 간단한 방식
대부분의 경우, `std::async`를 사용하는 것이 훨씬 더 편리하다.

```cpp
#include <iostream>
#include <future>
#include <chrono>

int expensive_calculation() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    return 42;
}

int main() {
    // std::async는 작업을 비동기로 실행하고 future를 반환한다
    std::future<int> future = std::async(std::launch::async, 
                                         expensive_calculation);
    
    std::cout << "작업이 진행 중이고, 다른 일을 할 수 있다\n";
    
    // 결과를 기다린다
    int result = future.get();
    std::cout << "결과: " << result << "\n";
    
    return 0;
}
```

`std::async`는 자동으로 스레드를 생성하고 함수를 실행한 후, 그 결과를 `future`로 반환한다. 스레드 관리의 번거로움이 없어진다.

### 1.4 예외 처리와 안전성
비동기 작업에서 예외가 발생할 수 있다. C++의 `future` 메커니즘은 이를 안전하게 처리한다.

```cpp
#include <iostream>
#include <future>
#include <exception>

int dangerous_function() {
    throw std::runtime_error("문제가 발생했습니다!");
}

int main() {
    std::future<int> future = std::async(std::launch::async, 
                                         dangerous_function);
    
    try {
        int result = future.get();
        std::cout << "결과: " << result << "\n";
    } catch (const std::exception& e) {
        std::cout << "예외 발생: " << e.what() << "\n";
    }
    
    return 0;
}
```

스레드에서 발생한 예외는 `future.get()`을 호출할 때 다시 던져진다. 이는 매우 안전한 방식이다. 예외가 어디서 발생했든 호출자가 명확하게 처리할 수 있다.



## 2. 비동기 프로그래밍 패턴

### 2.1 콜백 기반에서 future 기반으로의 전환
전통적인 콜백 기반 비동기 프로그래밍은 "콜백 지옥(callback hell)"을 초래한다. C++의 `future`는 더 명확한 제어 흐름을 제공한다.

```cpp
#include <iostream>
#include <future>
#include <vector>

// 여러 비동기 작업의 결과를 모아서 처리하고 싶을 때
int fetch_data_1() {
    return 10;
}

int fetch_data_2() {
    return 20;
}

int fetch_data_3() {
    return 30;
}

int main() {
    // 여러 작업을 동시에 시작한다
    auto future1 = std::async(std::launch::async, fetch_data_1);
    auto future2 = std::async(std::launch::async, fetch_data_2);
    auto future3 = std::async(std::launch::async, fetch_data_3);
    
    // 모든 결과를 기다렸다가 처리한다
    int result = future1.get() + future2.get() + future3.get();
    
    std::cout << "합계: " << result << "\n";
    
    return 0;
}
```

이 패턴은 간단하고 명확하다. 필요한 모든 작업을 시작하고, 그 결과들을 순차적으로 수집한다. 각 `get()` 호출 이전의 작업들은 이미 병렬로 진행 중이다.

### 2.2 std::when_all과 std::when_any 패턴 (C++20 준비)
C++20에는 `std::when_all`, `std::when_any` 같은 기능이 추가될 예정이지만, 현재는 수동으로 구현해야 한다. 다음은 모든 future가 완료될 때까지 기다리는 헬퍼 함수의 예시다.

```cpp
#include <iostream>
#include <future>
#include <vector>

template<typename T>
std::vector<T> wait_all(std::vector<std::future<T>>& futures) {
    std::vector<T> results;
    for (auto& future : futures) {
        results.push_back(future.get());
    }
    return results;
}

int main() {
    std::vector<std::future<int>> futures;
    
    // 여러 작업을 시작한다
    for (int i = 0; i < 5; ++i) {
        futures.push_back(std::async(std::launch::async, [i]() {
            return i * i;
        }));
    }
    
    // 모든 작업의 결과를 수집한다
    auto results = wait_all(futures);
    
    for (int r : results) {
        std::cout << r << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

### 2.3 promise를 이용한 수동 제어
때로는 값을 언제 설정할지 프로그래머가 직접 제어해야 한다. 예를 들어, 여러 조건이 만족될 때 결과를 반환하거나, 특정 이벤트를 기다릴 때다.

```cpp
#include <iostream>
#include <future>
#include <thread>
#include <chrono>

int main() {
    std::promise<std::string> promise;
    std::future<std::string> future = promise.get_future();
    
    // 백그라운드 스레드가 특정 조건을 확인한다
    std::thread checker([&promise]() {
        for (int i = 0; i < 10; ++i) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            if (i == 5) {  // 특정 조건이 만족됨
                promise.set_value("조건이 만족되었습니다");
                return;
            }
        }
    });
    
    std::cout << "메시지: " << future.get() << "\n";
    
    checker.join();
    return 0;
}
```

### 2.4 promise의 예외 설정
작업 중 예외가 발생할 수 있을 때는 `set_exception()`을 사용한다.

```cpp
#include <iostream>
#include <future>
#include <thread>
#include <exception>

int main() {
    std::promise<int> promise;
    std::future<int> future = promise.get_future();
    
    std::thread worker([&promise]() {
        try {
            // 위험한 작업
            throw std::logic_error("오류가 발생했습니다");
        } catch (...) {
            // 현재 예외를 promise에 저장한다
            promise.set_exception(std::current_exception());
        }
    });
    
    try {
        future.get();
    } catch (const std::exception& e) {
        std::cout << "예외 처리: " << e.what() << "\n";
    }
    
    worker.join();
    return 0;
}
```

  

## 3. 스레드 풀과 작업 큐 구현

### 3.1 스레드 풀의 필요성
프로그램이 많은 짧은 작업들을 처리할 때, 각 작업마다 새로운 스레드를 생성하는 것은 오버헤드가 크다. 스레드 생성과 소멸에는 상당한 비용이 든다. **스레드 풀**은 미리 정해진 개수의 작업자 스레드를 생성해두고, 이들에게 작업을 배정하는 방식이다.

### 3.2 기본적인 스레드 풀 구현
다음은 실무에서 사용할 수 있는 기본적인 스레드 풀의 구현이다. 이 코드의 목적은 작업 큐를 안전하게 관리하고, 워커 스레드들이 작업을 가져가서 실행하도록 하는 것이다.

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <vector>
#include <memory>

class ThreadPool {
public:
    explicit ThreadPool(size_t num_threads) 
        : stop_(false) {
        // 지정된 개수만큼 워커 스레드를 생성한다
        for (size_t i = 0; i < num_threads; ++i) {
            workers_.emplace_back([this]() {
                worker_thread();
            });
        }
    }
    
    ~ThreadPool() {
        shutdown();
    }
    
    // 작업을 큐에 추가한다
    template<typename F>
    std::future<typename std::result_of<F()>::type> enqueue(F&& f) {
        using return_type = typename std::result_of<F()>::type;
        
        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::forward<F>(f)
        );
        
        auto future = task->get_future();
        
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (stop_) {
                throw std::runtime_error("ThreadPool이 종료되었습니다");
            }
            tasks_.push([task]() { (*task)(); });
        }
        
        condition_.notify_one();  // 대기 중인 워커를 깨운다
        return future;
    }
    
    void shutdown() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            stop_ = true;
        }
        condition_.notify_all();  // 모든 워커를 깨운다
        
        for (auto& worker : workers_) {
            worker.join();
        }
    }
    
private:
    void worker_thread() {
        while (true) {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            
            // 작업이 있을 때까지 대기한다
            condition_.wait(lock, [this]() {
                return !tasks_.empty() || stop_;
            });
            
            if (stop_ && tasks_.empty()) {
                return;  // 종료 신호를 받고 큐가 비었으면 종료
            }
            
            if (!tasks_.empty()) {
                auto task = std::move(tasks_.front());
                tasks_.pop();
                lock.unlock();  // 작업 실행 중에는 잠금을 풀어준다
                task();
            }
        }
    }
    
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex queue_mutex_;
    std::condition_variable condition_;
    bool stop_;
};

int main() {
    ThreadPool pool(4);  // 4개의 워커 스레드 생성
    
    std::vector<std::future<int>> futures;
    
    // 10개의 작업을 엔큐한다
    for (int i = 0; i < 10; ++i) {
        auto future = pool.enqueue([i]() {
            std::cout << "작업 " << i << " 시작\n";
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::cout << "작업 " << i << " 완료\n";
            return i * i;
        });
        futures.push_back(std::move(future));
    }
    
    // 모든 작업의 결과를 수집한다
    for (size_t i = 0; i < futures.size(); ++i) {
        std::cout << "결과 " << i << ": " << futures[i].get() << "\n";
    }
    
    pool.shutdown();
    return 0;
}
```

이 코드의 의도와 설계를 자세히 설명하면, `ThreadPool` 클래스는 워커 스레드들과 작업 큐를 관리한다. `enqueue()` 메서드는 함수 객체를 받아서 `std::packaged_task`로 감싼다. `packaged_task`는 작업의 실행 결과를 `future`로 제공하는 도구다. 작업을 큐에 넣은 후 조건 변수로 대기 중인 워커를 깨운다. 워커 스레드의 `worker_thread()` 함수는 무한 루프에서 큐에 작업이 들어올 때까지 대기하고, 작업이 들어오면 꺼내서 실행한다. `shutdown()` 함수는 `stop_` 플래그를 설정하고 모든 워커를 깨운 후, 스레드가 모두 종료될 때까지 기다린다. 이 구조는 완벽한 RAII 패턴을 따르므로, 스레드 풀 객체가 소멸할 때 자동으로 모든 리소스가 정리된다.

### 3.3 스레드 풀 사용 시 주의사항
스레드 풀을 사용할 때는 몇 가지 주의할 점이 있다.

```cpp
ThreadPool pool(4);

// 주의: 람다가 지역 변수를 캡처할 때, 그 변수의 생명주기를 확인해야 한다
for (int i = 0; i < 5; ++i) {
    // 잘못된 예: i를 값으로 캡처해야 한다
    auto future = pool.enqueue([&i]() {  // 위험!
        return i * 2;
    });
    
    // 올바른 예:
    auto correct_future = pool.enqueue([i]() {  // 안전
        return i * 2;
    });
}

pool.shutdown();
```

앞의 코드에서 `[&i]`로 캡처하면 위험하다. 루프가 빠르게 진행되어 `i`의 값이 변할 수 있고, 작업이 실행될 때는 `i`가 이미 다른 값을 가질 수 있다. `[i]`로 값으로 캡처해야 안전하다.

### 3.4 현실적인 스레드 풀: 예외 처리 강화
실제 프로덕션 코드에서는 예외 처리가 더 강화되어야 한다.

```cpp
class RobustThreadPool {
public:
    explicit RobustThreadPool(size_t num_threads) 
        : stop_(false), active_tasks_(0) {
        for (size_t i = 0; i < num_threads; ++i) {
            workers_.emplace_back([this]() {
                try {
                    worker_thread();
                } catch (const std::exception& e) {
                    // 예외는 로깅하지만 워커는 계속 실행된다
                    std::cerr << "워커 예외: " << e.what() << "\n";
                }
            });
        }
    }
    
    ~RobustThreadPool() {
        shutdown();
    }
    
    template<typename F>
    std::future<typename std::result_of<F()>::type> enqueue(F&& f) {
        using return_type = typename std::result_of<F()>::type;
        
        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::forward<F>(f)
        );
        
        auto future = task->get_future();
        
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (stop_) {
                throw std::runtime_error("ThreadPool이 종료되었습니다");
            }
            tasks_.push([task]() { (*task)(); });
            ++active_tasks_;
        }
        
        condition_.notify_one();
        return future;
    }
    
    size_t get_queue_size() const {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        return tasks_.size();
    }
    
    void shutdown() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            stop_ = true;
        }
        condition_.notify_all();
        
        for (auto& worker : workers_) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }
    
private:
    void worker_thread() {
        while (true) {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            
            condition_.wait(lock, [this]() {
                return !tasks_.empty() || stop_;
            });
            
            if (stop_ && tasks_.empty()) {
                return;
            }
            
            if (!tasks_.empty()) {
                auto task = std::move(tasks_.front());
                tasks_.pop();
                lock.unlock();
                
                try {
                    task();  // 개별 작업의 예외는 future에 저장된다
                } catch (...) {
                    // 여기서는 예외를 로깅할 수 있다
                }
                
                lock.lock();
                --active_tasks_;
            }
        }
    }
    
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    mutable std::mutex queue_mutex_;
    std::condition_variable condition_;
    size_t active_tasks_;
    bool stop_;
};
```

  

## 4. C++20 coroutines 입문

### 4.1 코루틴이란 무엇인가?
코루틴은 실행을 일시 중단했다가 나중에 재개할 수 있는 함수다. 스레드와 달리 OS 스케줄러의 개입이 없으므로 매우 가볍다. C++20의 코루틴은 완전히 비선점형(non-preemptive)이며, 프로그래머가 명시적으로 제어점을 지정한다.

### 4.2 코루틴의 기본 구조
C++20 코루틴은 복잡해 보이지만, 핵심 개념은 단순하다. 코루틴을 정의하려면 특정 요구사항을 만족해야 한다.

```cpp
#include <iostream>
#include <coroutine>

// 코루틴의 return 타입은 promise_type을 정의해야 한다
class SimpleCoroutine {
public:
    struct promise_type {
        int value_;
        
        // 코루틴이 시작되려고 할 때
        SimpleCoroutine get_return_object() {
            return SimpleCoroutine(std::coroutine_handle<promise_type>::from_promise(*this));
        }
        
        // 코루틴 시작 전
        std::suspend_never initial_suspend() {
            return {};
        }
        
        // 코루틴 종료 후
        std::suspend_never final_suspend() noexcept {
            return {};
        }
        
        // co_yield로 값을 전달할 때
        std::suspend_always yield_value(int value) {
            value_ = value;
            return {};
        }
        
        // 예외 처리
        void unhandled_exception() {}
    };
    
    using handle_type = std::coroutine_handle<promise_type>;
    
    SimpleCoroutine(handle_type h) : handle_(h) {}
    
    // RAII: 코루틴 정리
    ~SimpleCoroutine() {
        if (handle_) {
            handle_.destroy();
        }
    }
    
    // 코루틴 재개
    void resume() {
        if (handle_) {
            handle_.resume();
        }
    }
    
    // 현재 값을 얻는다
    int get_value() const {
        return handle_.promise().value_;
    }
    
private:
    handle_type handle_;
};

// 간단한 코루틴 예제
SimpleCoroutine simple_coro() {
    std::cout << "코루틴 시작\n";
    co_yield 1;  // 값을 반환하고 일시 중단
    std::cout << "코루틴 재개\n";
    co_yield 2;
    std::cout << "코루틴 종료\n";
}

int main() {
    auto coro = simple_coro();
    
    std::cout << "첫 번째 값: " << coro.get_value() << "\n";
    coro.resume();  // 재개
    
    std::cout << "두 번째 값: " << coro.get_value() << "\n";
    coro.resume();
    
    return 0;
}
```

이 코드는 코루틴의 기본 구조를 보여준다. `promise_type`은 코루틴의 동작을 제어하는 인터페이스로, 시작, 일시 중단, 재개, 종료 시점에서 호출된다. `co_yield`는 특정 값을 반환하고 실행을 일시 중단한다.

### 4.3 코루틴을 이용한 생성기(Generator) 패턴
코루틴의 실제적인 활용 사례 중 하나는 생성기다. 이는 값을 하나씩 생성하는 패턴이다.

```cpp
#include <iostream>
#include <coroutine>
#include <exception>

template<typename T>
class Generator {
public:
    struct promise_type {
        T current_value_;
        std::exception_ptr exception_;
        
        Generator get_return_object() {
            return Generator(std::coroutine_handle<promise_type>::from_promise(*this));
        }
        
        std::suspend_never initial_suspend() {
            return {};
        }
        
        std::suspend_always final_suspend() noexcept {
            return {};
        }
        
        std::suspend_always yield_value(T value) {
            current_value_ = value;
            return {};
        }
        
        void return_void() {}
        
        void unhandled_exception() {
            exception_ = std::current_exception();
        }
    };
    
    using handle_type = std::coroutine_handle<promise_type>;
    
    Generator(handle_type h) : handle_(h) {}
    
    ~Generator() {
        if (handle_) {
            handle_.destroy();
        }
    }
    
    // 범위 기반 for 루프를 지원한다
    struct iterator {
        handle_type handle_;
        bool done_;
        
        iterator(handle_type h, bool done) 
            : handle_(h), done_(done) {}
        
        iterator& operator++() {
            handle_.resume();
            done_ = handle_.done();
            return *this;
        }
        
        bool operator==(const iterator& other) const {
            return done_ == other.done_;
        }
        
        bool operator!=(const iterator& other) const {
            return !(*this == other);
        }
        
        T operator*() const {
            return handle_.promise().current_value_;
        }
    };
    
    iterator begin() {
        handle_.resume();
        return iterator(handle_, handle_.done());
    }
    
    iterator end() {
        return iterator(handle_, true);
    }
    
private:
    handle_type handle_;
};

// 피보나치 수열을 생성하는 코루틴
Generator<int> fibonacci(int n) {
    int a = 0, b = 1;
    for (int i = 0; i < n; ++i) {
        co_yield a;
        int temp = a + b;
        a = b;
        b = temp;
    }
}

int main() {
    std::cout << "처음 10개의 피보나치 수: ";
    for (int value : fibonacci(10)) {
        std::cout << value << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

이 `Generator` 클래스는 범위 기반 for 루프를 지원하므로, 코루틴을 매우 자연스럽게 사용할 수 있다. 각 루프 반복에서 `operator++`이 호출되면 `handle_.resume()`으로 코루틴을 재개한다.

### 4.4 코루틴을 이용한 비동기 작업 처리
C++20 코루틴의 진정한 강력함은 비동기 작업을 동기 코드처럼 작성할 수 있다는 데 있다. 다음은 `co_await`를 사용한 예제다.

```cpp
#include <iostream>
#include <coroutine>
#include <chrono>
#include <thread>

// 간단한 비동기 작업을 나타내는 타입
template<typename T>
class Task {
public:
    struct promise_type {
        T result_;
        std::exception_ptr exception_;
        
        Task get_return_object() {
            return Task(std::coroutine_handle<promise_type>::from_promise(*this));
        }
        
        std::suspend_never initial_suspend() {
            return {};
        }
        
        std::suspend_never final_suspend() noexcept {
            return {};
        }
        
        void return_value(T value) {
            result_ = value;
        }
        
        void unhandled_exception() {
            exception_ = std::current_exception();
        }
    };
    
    using handle_type = std::coroutine_handle<promise_type>;
    
    Task(handle_type h) : handle_(h) {}
    
    ~Task() {
        if (handle_) {
            handle_.destroy();
        }
    }
    
    T get() {
        if (handle_.promise().exception_) {
            std::rethrow_exception(handle_.promise().exception_);
        }
        return handle_.promise().result_;
    }
    
private:
    handle_type handle_;
};

// 이 타입은 co_await를 지원한다
struct SimpleAwaiter {
    bool await_ready() const {
        return false;  // 항상 일시 중단
    }
    
    void await_suspend(std::coroutine_handle<>) {
        // 여기서 백그라운드 작업을 시작할 수 있다
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    int await_resume() {
        return 42;  // 재개 시 이 값을 반환
    }
};

Task<int> async_task() {
    std::cout << "작업 시작\n";
    int result = co_await SimpleAwaiter();
    std::cout << "작업 완료, 결과: " << result << "\n";
    co_return result;
}

int main() {
    auto task = async_task();
    std::cout << "최종 결과: " << task.get() << "\n";
    
    return 0;
}
```

이 예제는 코루틴의 고급 기능인 `co_await`를 보여준다. `co_await`는 특정 작업이 완료될 때까지 코루틴을 일시 중단했다가, 작업이 완료되면 자동으로 재개한다. 이를 통해 비동기 코드를 마치 동기 코드처럼 작성할 수 있다.

### 4.5 코루틴 사용 시 주의사항
C++20 코루틴은 매우 강력하지만, 올바르게 사용하지 않으면 위험할 수 있다.

```cpp
// 주의 1: 코루틴이 반환되기 전에 handle을 사용하지 말아야 한다
// 주의 2: co_await, co_yield, co_return 중 하나라도 없으면 코루틴이 아니다
// 주의 3: 코루틴의 생명주기를 명확히 관리해야 한다

// 잘못된 예
void not_a_coroutine() {
    // 이것은 코루틴이 아니다 - 위 세 키워드가 없다
    int x = 42;
}

// 올바른 예
Task<int> proper_coroutine() {
    int x = 42;
    co_return x;  // 이제 진짜 코루틴이다
}
```

C++20 코루틴은 또한 표준 라이브러리에서 완전히 지원되지 않으므로, 프레임워크나 라이브러리(예: Boost.Asio)와 함께 사용할 때 더 효율적이다.

  

## 5. 동시성 패턴 정리 및 선택 기준

### 5.1 언제 어떤 패턴을 사용할까?
여러 동시성 패턴을 배웠으니, 이제 실무에서 올바른 선택을 해야 한다.

- **std::async와 std::future**: 가볍고 간단한 비동기 작업. 결과를 기다려야 할 때 선호한다.

- **std::promise와 std::future**: 작업 완료 시점을 정확히 제어해야 할 때. 여러 스레드가 같은 promise를 업데이트하지 않도록 주의해야 한다.

- **스레드 풀**: 많은 개수의 작은 작업들을 효율적으로 처리해야 할 때. 스레드 생성 오버헤드를 줄인다.

- **코루틴**: C++20을 사용할 수 있고, 비동기 코드를 동기처럼 작성하고 싶을 때. 가장 가볍고 효율적이다.

### 5.2 종합 예제: 웹 스크래퍼
이 예제는 여러 동시성 패턴을 실제로 조합하는 방법을 보여준다.

```cpp
#include <iostream>
#include <future>
#include <vector>
#include <string>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <chrono>

// 간단한 작업 풀
class WorkPool {
public:
    explicit WorkPool(size_t num_threads) : stop_(false) {
        for (size_t i = 0; i < num_threads; ++i) {
            workers_.emplace_back([this]() { worker_loop(); });
        }
    }
    
    ~WorkPool() {
        shutdown();
    }
    
    template<typename F>
    std::future<typename std::result_of<F()>::type> submit(F&& f) {
        using return_type = typename std::result_of<F()>::type;
        
        auto task = std::make_shared<std::packaged_task<return_type()>>(
            std::forward<F>(f)
        );
        
        auto future = task->get_future();
        
        {
            std::unique_lock<std::mutex> lock(mutex_);
            if (stop_) {
                throw std::runtime_error("WorkPool이 종료되었습니다");
            }
            tasks_.push([task]() { (*task)(); });
        }
        
        condition_.notify_one();
        return future;
    }
    
    void shutdown() {
        {
            std::unique_lock<std::mutex> lock(mutex_);
            stop_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            worker.join();
        }
    }
    
private:
    void worker_loop() {
        while (true) {
            std::unique_lock<std::mutex> lock(mutex_);
            condition_.wait(lock, [this]() {
                return !tasks_.empty() || stop_;
            });
            
            if (stop_ && tasks_.empty()) {
                return;
            }
            
            if (!tasks_.empty()) {
                auto task = std::move(tasks_.front());
                tasks_.pop();
                lock.unlock();
                task();
            }
        }
    }
    
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex mutex_;
    std::condition_variable condition_;
    bool stop_;
};

// 웹 페이지를 "가져오는" 시뮬레이션
std::string fetch_url(const std::string& url) {
    // 실제로는 네트워크 요청을 하지만, 여기서는 시뮬레이션
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    return "Content from " + url;
}

int main() {
    WorkPool pool(4);
    
    std::vector<std::string> urls = {
        "http://example.com/1",
        "http://example.com/2",
        "http://example.com/3",
        "http://example.com/4",
        "http://example.com/5",
    };
    
    std::vector<std::future<std::string>> futures;
    
    // 모든 URL을 병렬로 가져온다
    for (const auto& url : urls) {
        futures.push_back(pool.submit([url]() {
            return fetch_url(url);
        }));
    }
    
    // 결과를 수집한다
    for (size_t i = 0; i < futures.size(); ++i) {
        std::cout << "URL " << i << ": " << futures[i].get() << "\n";
    }
    
    pool.shutdown();
    return 0;
}
```

이 예제는 실무와 매우 유사한 패턴이다. 4개의 워커 스레드 풀을 만들고, 5개의 URL을 동시에 가져온다. 워커들이 효율적으로 작업을 분배받아 처리한다.

  

## 6. C++ Core Guidelines와의 관계
Chapter 13에서 다룬 모든 패턴은 C++ Core Guidelines의 동시성 규칙을 따른다.

- **Con.1**: 동시성을 조심해서 사용한다. 이 장의 모든 패턴은 명확하고 안전한 동시성을 제공한다.

- **Con.2**: 저수준 threading 보다는 고수준 추상화를 선호한다. `std::future`, 스레드 풀, 코루틴은 모두 뮤텍스를 숨기는 고수준 추상화다.

- **Con.3**: 데이터 레이스를 피한다. `std::future`와 `std::promise`의 공유 상태는 프레임워크가 동기화한다.

- **Con.4**: 예외 안전성을 고려한다. 모든 패턴에서 RAII를 사용해 리소스를 관리한다.

  

## 결론
Modern C++의 고급 동시성 패턴들은 안전하고 효율적인 병렬 프로그래밍을 가능하게 한다. `std::future`와 `std::promise`는 스레드 간의 안전한 통신을 제공하고, 스레드 풀은 리소스를 효율적으로 관리하며, C++20 코루틴은 비동기 코드를 동기적으로 작성할 수 있게 해준다.

이들 패턴은 뮤텍스와 조건 변수를 노출하지 않으므로 데드락의 위험이 훨씬 낮다. 또한 RAII 원칙을 따르므로 리소스 누수가 거의 없다. 이는 Rust의 안전성 보장과 비교해도 손색이 없다.

학생들은 이 장의 내용을 통해 C++이 현대적인 동시성 프로그래밍에 완벽히 대응할 수 있는 언어임을 이해하게 될 것이다. 복잡한 스레드 관리는 프레임워크에 맡기고, 비즈니스 로직에 집중하는 것이 바로 Modern C++의 철학이다.  