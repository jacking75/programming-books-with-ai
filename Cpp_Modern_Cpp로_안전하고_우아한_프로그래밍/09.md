# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 9: 템플릿 메타프로그래밍과 컴파일 타임 검증
이 장에서는 C++의 가장 강력하면서도 복잡한 기능 중 하나인 템플릿 메타프로그래밍과 컴파일 타임 검증에 대해 함께 학습할 것이다. 

혹시 지금까지 배운 것 중에 "이 코드가 컴파일될 때 에러를 잡아줄 수 있을까?"라고 생각해본 적이 있는가? 여기서 배울 내용이 바로 그것을 가능하게 해준다. C++은 매우 뛰어난 타입 시스템과 템플릿 기능을 통해 많은 오류를 컴파일 타임에 검증할 수 있다. 이는 런타임 오류를 완전히 제거하는 것과 같으므로, 안전성 측면에서 Rust와 비교해도 전혀 뒤지지 않는다.

이 장의 목표는 여러분이 템플릿의 강력한 검증 기능을 이해하고, Modern C++의 최신 기능들을 사용하여 더 안전하고 명확한 코드를 작성하는 것이다. 특히 C++20의 Concepts와 C++23의 consteval 함수는 코드의 의도를 명확하게 표현하고 잘못된 사용을 컴파일 타임에 방지한다.
  

## 9.1 SFINAE를 넘어선 Concepts 활용

### 9.1.1 SFINAE의 한계와 Concepts의 필요성
여러분이 템플릿을 작성할 때 특정 조건을 만족하는 타입에만 함수가 작동하도록 제한하고 싶을 수 있다. 과거에는 SFINAE(Substitution Failure Is Not An Error)라는 기법을 사용했는데, 이 방법은 매우 복잡하고 이해하기 어렵다는 문제가 있었다.

예를 들어, 정수 타입에만 작동하는 함수를 만들고 싶다고 하자. 과거의 SFINAE 방식은 다음과 같았다.

```cpp
#include <type_traits>
#include <iostream>

// SFINAE를 사용한 방식: 복잡하고 읽기 어렵다
template <typename T>
typename std::enable_if<std::is_integral_v<T>, void>::type
processInteger(T value) {
    std::cout << "정수 처리: " << value << std::endl;
}

int main() {
    processInteger(42);        // 작동한다
    // processInteger(3.14);    // 컴파일 오류
    return 0;
}
```

이 코드를 보면 함수의 의도가 명확하지 않다. `typename std::enable_if<std::is_integral_v<T>, void>::type` 이 부분이 정체 무엇인지 처음 배우는 사람은 이해하기 어려울 것이다. 함수가 정수 타입을 받아야 한다는 의도가 숨어있고, 코드도 매우 복잡하다.

이런 문제를 해결하기 위해 C++20에서 Concepts가 도입되었다. Concepts는 템플릿 매개변수에 대한 제약 조건을 명확하고 읽기 쉽게 표현할 수 있는 기능이다.

### 9.1.2 기본 Concepts 정의와 사용
이제 Modern C++의 방식으로 같은 코드를 작성해보자.

```cpp
#include <iostream>
#include <concepts>

// Concept 정의: 정수 타입을 나타내는 개념
template <typename T>
concept Integral = std::integral<T>;

// Concept을 사용한 함수: 의도가 명확하다
void processInteger(Integral auto value) {
    std::cout << "정수 처리: " << value << std::endl;
}

int main() {
    processInteger(42);        // ✓ 작동한다
    processInteger(100LL);     // ✓ long long도 작동한다
    // processInteger(3.14);    // ✗ 컴파일 오류: 더 명확한 메시지
    
    return 0;
}
```

훨씬 읽기 쉽지 않은가? `processInteger` 함수를 보면 "이 함수는 정수 타입만 받는다"는 것이 한눈에 명확하다.

C++ 표준 라이브러리에는 이미 많은 유용한 Concepts가 정의되어 있다. 예를 들어 `std::integral`, `std::floating_point`, `std::copyable`, `std::movable` 등이 있다. 여러분이 자주 사용할 표준 Concepts를 소개하면 다음과 같다.

```cpp
#include <iostream>
#include <concepts>
#include <vector>

// 정수 계산을 수행하는 함수
template <typename T>
requires std::integral<T>
T add(T a, T b) {
    return a + b;
}

// 부동소수점 계산을 수행하는 함수
template <typename T>
requires std::floating_point<T>
T multiply(T a, T b) {
    return a * b;
}

// 복사 가능한 타입에만 작동하는 함수
template <typename T>
requires std::copyable<T>
void makeCopy(const T& original, T& copy) {
    copy = original;
}

// 등호 비교가 가능한 타입에만 작동하는 함수
template <typename T>
requires std::equality_comparable<T>
bool isEqual(const T& a, const T& b) {
    return a == b;
}

int main() {
    // 작동한다
    std::cout << "정수 덧셈: " << add(10, 20) << std::endl;
    std::cout << "부동소수점 곱셈: " << multiply(2.5, 4.0) << std::endl;
    
    int a = 42, b;
    makeCopy(a, b);
    std::cout << "복사 결과: " << b << std::endl;
    
    std::cout << "등호 비교: " << isEqual(42, 42) << std::endl;
    
    // add(3.14, 2.71);  // ✗ 컴파일 오류
    // multiply(10, 20); // ✗ 컴파일 오류
    
    return 0;
}
```

### 9.1.3 복합 Concepts 정의하기
가끔은 여러 조건을 결합하여 더 복잡한 Concept을 정의해야 한다. 예를 들어 "이 타입은 복사 가능하고 동시에 비교 가능해야 한다"는 요구사항이 있을 수 있다. C++에서는 Concepts를 조합하여 이런 요구사항을 표현할 수 있다.

```cpp
#include <iostream>
#include <concepts>
#include <vector>
#include <string>

// 복합 Concept: 복사 가능하고 비교 가능한 타입
template <typename T>
concept CopyableAndComparable = 
    std::copyable<T> && std::equality_comparable<T>;

// 또 다른 복합 Concept: 정수이면서 비교 가능한 타입
template <typename T>
concept IntegralComparable = 
    std::integral<T> && std::totally_ordered<T>;

// 복합 Concept을 사용하는 함수
template <typename T>
requires CopyableAndComparable<T>
void compareAndCopy(const T& original, T& copy) {
    if (original == copy) {
        std::cout << "이미 같습니다." << std::endl;
    }
    copy = original;
}

// 더 구체적인 Concept 활용
template <typename T>
requires IntegralComparable<T>
T findMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    // CopyableAndComparable 사용 예제
    std::string str1 = "Hello";
    std::string str2;
    compareAndCopy(str1, str2);
    
    // IntegralComparable 사용 예제
    std::cout << "최댓값: " << findMax(10, 20) << std::endl;
    std::cout << "최댓값: " << findMax(100LL, 50LL) << std::endl;
    
    // compareAndCopy(3.14, 2.71);  // ✗ 컴파일 오류
    // findMax(3.14, 2.71);         // ✗ 컴파일 오류 (부동소수점은 std::totally_ordered 미충족)
    
    return 0;
}
```

### 9.1.4 Concept에 메서드 요구사항 정의하기
때로는 특정 메서드나 동작을 가져야 하는 타입에 대한 Concept을 정의해야 한다. 이를 "Concept의 Requires 절"이라고 하는데, 이를 통해 타입이 특정 동작을 지원하는지 검증할 수 있다.

```cpp
#include <iostream>
#include <concepts>

// Printable Concept: .print() 메서드를 가져야 함
template <typename T>
concept Printable = requires(T t) {
    { t.print() } -> std::convertible_to<void>;
};

// Addable Concept: operator+를 지원해야 함
template <typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
};

// 복합 Concept: Printable이면서 Addable해야 함
template <typename T>
concept PrintableAddable = Printable<T> && Addable<T>;

// 실제 타입들
class SafeInteger {
private:
    int value;

public:
    SafeInteger(int v = 0) : value(v) {}
    
    void print() const {
        std::cout << "값: " << value << std::endl;
    }
    
    SafeInteger operator+(const SafeInteger& other) const {
        return SafeInteger(value + other.value);
    }
};

class OnlyPrintable {
public:
    void print() const {
        std::cout << "출력만 가능합니다." << std::endl;
    }
};

// Printable Concept을 만족하는 타입 처리
template <typename T>
requires Printable<T>
void printObject(const T& obj) {
    std::cout << "출력 중: ";
    obj.print();
}

// Addable Concept을 만족하는 타입 처리
template <typename T>
requires Addable<T>
T addTwoObjects(const T& a, const T& b) {
    std::cout << "덧셈 수행 중..." << std::endl;
    return a + b;
}

// PrintableAddable을 만족하는 타입에만 작동
template <typename T>
requires PrintableAddable<T>
void printAndAdd(const T& a, const T& b) {
    std::cout << "첫 번째 객체: ";
    a.print();
    
    std::cout << "두 번째 객체: ";
    b.print();
    
    auto result = a + b;
    std::cout << "합산 결과: ";
    result.print();
}

int main() {
    SafeInteger num1(10);
    SafeInteger num2(20);
    
    // ✓ SafeInteger는 모든 요구사항을 만족한다
    printObject(num1);
    addTwoObjects(num1, num2);
    printAndAdd(num1, num2);
    
    OnlyPrintable simple;
    printObject(simple);  // ✓ OnlyPrintable은 Printable 만족
    
    // addTwoObjects(simple, simple);   // ✗ 컴파일 오류
    // printAndAdd(simple, simple);     // ✗ 컴파일 오류
    
    return 0;
}
```

이 예제에서 중요한 점은 각 Concept이 명확하게 타입의 요구사항을 표현한다는 것이다. 이를 통해 코드를 읽는 사람은 "이 함수가 어떤 타입을 기대하는지"를 명확히 알 수 있고, 잘못된 타입을 전달했을 때 컴파일러가 명확한 오류 메시지를 제공할 수 있다.
   

## 9.2 컴파일 타임 타입 검증

### 9.2.1 static_assert와 is_same을 활용한 컴파일 타임 검증
프로그래밍을 하다 보면 "이 함수는 반드시 정수 타입을 받아야 한다"거나 "이 템플릿 인수는 포인터여야 한다"는 제약이 생긴다. 이런 제약을 컴파일 타임에 검증하면, 잘못된 타입을 사용했을 때 프로그램이 실행되기 전에 오류를 발견할 수 있다.

`static_assert`는 컴파일 타임에 조건을 검증하는 기능이다. 조건이 거짓이면 컴파일이 실패하고 지정한 메시지가 표시된다.

```cpp
#include <iostream>
#include <type_traits>

// 컴파일 타임에 타입 검증하는 함수
template <typename T>
void processInteger(T value) {
    // 컴파일 타임에 T가 정수 타입인지 확인한다
    static_assert(std::is_integral_v<T>, 
                  "processInteger는 정수 타입만 받습니다.");
    
    std::cout << "정수 처리: " << value << std::endl;
}

// 포인터 타입만 받는 함수
template <typename T>
void processPointer(T value) {
    static_assert(std::is_pointer_v<T>, 
                  "processPointer는 포인터 타입만 받습니다.");
    
    std::cout << "포인터 값: " << value << std::endl;
}

// 배열 타입만 받는 함수
template <typename T>
void processArray(const T& arr) {
    static_assert(std::is_array_v<T>, 
                  "processArray는 배열 타입만 받습니다.");
    
    std::cout << "배열 처리" << std::endl;
}

int main() {
    processInteger(42);                    // ✓ 작동한다
    processInteger(100LL);                 // ✓ long long도 작동한다
    
    int x = 10;
    processPointer(&x);                    // ✓ 작동한다
    
    int arr[10] = {};
    processArray(arr);                     // ✓ 작동한다
    
    // 다음은 모두 컴파일 오류가 발생한다:
    // processInteger(3.14);               // ✗ 오류: 부동소수점
    // processPointer(x);                  // ✗ 오류: 포인터가 아님
    // processArray(x);                    // ✗ 오류: 배열이 아님
    
    return 0;
}
```

### 9.2.2 타입 특성(Type Traits) 깊이 있게 이해하기
C++ 표준 라이브러리는 `<type_traits>` 헤더에 매우 다양한 타입 특성 도구들을 제공한다. 이들을 조합하면 매우 정교한 타입 검증을 할 수 있다. 자주 사용되는 타입 특성들을 소개하면 다음과 같다.

```cpp
#include <iostream>
#include <type_traits>
#include <vector>
#include <string>

// 타입 특성 활용 예제

// 1. 기본 타입 검사
template <typename T>
void printTypeInfo(T value) {
    std::cout << "=== 타입 검사 ===" << std::endl;
    std::cout << "정수형? " << std::is_integral_v<T> << std::endl;
    std::cout << "부동소수점형? " << std::is_floating_point_v<T> << std::endl;
    std::cout << "포인터? " << std::is_pointer_v<T> << std::endl;
    std::cout << "참조? " << std::is_reference_v<T> << std::endl;
    std::cout << "클래스/구조체? " << std::is_class_v<T> << std::endl;
    std::cout << std::endl;
}

// 2. 타입 변환 가능성 검사
template <typename From, typename To>
void checkConvertibility() {
    std::cout << "=== 변환 가능성 검사 ===" << std::endl;
    std::cout << "From에서 To로 변환 가능? " 
              << std::is_convertible_v<From, To> << std::endl;
    std::cout << std::endl;
}

// 3. 복합 조건 검증
template <typename T>
concept NumericType = std::is_arithmetic_v<T>;  // 정수 또는 부동소수점

template <typename T>
requires NumericType<T>
T safeAdd(T a, T b) {
    return a + b;
}

// 4. 조건부 타입 결정
template <typename T>
using MakeUnsigned = std::make_unsigned_t<T>;

// 5. 제거와 변환
template <typename T>
void demonstrateTypeManipulation() {
    std::cout << "=== 타입 조작 ===" << std::endl;
    
    // const와 volatile 제거
    using NoConst = std::remove_const_t<const T>;
    std::cout << "원본 타입에서 const 제거됨" << std::endl;
    
    // 참조 제거
    using NoRef = std::remove_reference_t<T&>;
    std::cout << "참조 제거됨" << std::endl;
    
    std::cout << std::endl;
}

int main() {
    // 정수 타입 검사
    printTypeInfo(42);
    
    // 부동소수점 검사
    printTypeInfo(3.14);
    
    // 포인터 검사
    int x = 10;
    printTypeInfo(&x);
    
    // 변환 가능성 검사
    checkConvertibility<int, double>();
    checkConvertibility<double, int>();
    
    // NumericType Concept 사용
    std::cout << "덧셈 결과: " << safeAdd(10, 20) << std::endl;
    std::cout << "덧셈 결과: " << safeAdd(3.5, 2.5) << std::endl;
    
    // 타입 조작 시연
    demonstrateTypeManipulation<int>();
    
    return 0;
}
```

### 9.2.3 enable_if 대신 Concepts 사용하여 오버로딩 구분하기
과거에는 `std::enable_if`를 사용하여 함수 오버로딩을 구분했지만, Modern C++에서는 Concepts를 사용하는 것이 훨씬 깔끔하고 명확하다.

```cpp
#include <iostream>
#include <concepts>
#include <string>
#include <vector>

// 정수 타입 전용 함수
template <typename T>
requires std::integral<T>
void process(T value) {
    std::cout << "정수 처리: " << value << std::endl;
}

// 부동소수점 타입 전용 함수
template <typename T>
requires std::floating_point<T>
void process(T value) {
    std::cout << "부동소수점 처리: " << value << std::endl;
}

// 컨테이너 타입 전용 함수
template <typename T>
requires std::ranges::range<T>
void process(const T& value) {
    std::cout << "컨테이너 처리" << std::endl;
}

// 더 구체적인 Concept 정의
template <typename T>
concept LessThanComparable = requires(T a, T b) {
    { a < b } -> std::convertible_to<bool>;
};

// 비교 가능한 타입 전용 함수
template <typename T>
requires LessThanComparable<T>
void compare(T a, T b) {
    if (a < b) {
        std::cout << "첫 번째가 두 번째보다 작습니다." << std::endl;
    } else {
        std::cout << "첫 번째가 두 번째보다 크거나 같습니다." << std::endl;
    }
}

int main() {
    // 정수 버전이 호출된다
    process(42);
    
    // 부동소수점 버전이 호출된다
    process(3.14);
    
    // 컨테이너 버전이 호출된다
    std::vector<int> vec = {1, 2, 3};
    process(vec);
    
    // 비교 함수 사용
    compare(10, 20);
    compare(3.5, 2.5);
    compare(std::string("apple"), std::string("banana"));
    
    return 0;
}
```

이렇게 Concepts를 사용하면 컴파일러가 함수를 선택할 때 Concept의 제약 조건을 확인하고, 가장 구체적으로 일치하는 함수를 선택한다. 이는 매우 명확하고 안전한 오버로딩이다.
  
  
## 9.3 템플릿 특화와 안전성 보장

### 9.3.1 부분 특화(Partial Specialization)를 통한 타입별 처리
C++의 템플릿 특화는 특정 조건의 타입에 대해 다른 구현을 제공하는 기능이다. 이를 잘 활용하면 타입에 따라 최적화된 코드를 제공할 수 있고, 동시에 타입 안전성을 보장할 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <type_traits>

// 기본 템플릿: 일반적인 타입
template <typename T>
class Storage {
public:
    void store(const T& value) {
        std::cout << "일반 저장소: 값 저장" << std::endl;
    }
};

// 부분 특화: 포인터 타입
template <typename T>
class Storage<T*> {
public:
    void store(T* ptr) {
        std::cout << "포인터 저장소: 주소 " << ptr << " 저장" << std::endl;
    }
};

// 부분 특화: std::vector
template <typename T>
class Storage<std::vector<T>> {
public:
    void store(const std::vector<T>& vec) {
        std::cout << "벡터 저장소: " << vec.size() << "개 요소 저장" << std::endl;
    }
};

// 부분 특화: const 타입
template <typename T>
class Storage<const T> {
public:
    void store(const T& value) {
        std::cout << "상수 저장소: const 값 저장" << std::endl;
    }
};

// 부분 특화: 배열
template <typename T, std::size_t N>
class Storage<T[N]> {
public:
    void store(const T (&arr)[N]) {
        std::cout << "배열 저장소: " << N << "개 원소 배열 저장" << std::endl;
    }
};

int main() {
    // 일반 타입
    Storage<int> intStorage;
    intStorage.store(42);
    
    // 포인터 타입
    Storage<int*> ptrStorage;
    int x = 10;
    ptrStorage.store(&x);
    
    // 벡터 타입
    Storage<std::vector<int>> vecStorage;
    std::vector<int> vec = {1, 2, 3};
    vecStorage.store(vec);
    
    // const 타입
    Storage<const int> constStorage;
    constStorage.store(42);
    
    // 배열 타입
    Storage<int[5]> arrayStorage;
    int arr[5] = {1, 2, 3, 4, 5};
    arrayStorage.store(arr);
    
    return 0;
}
```

이 예제에서 각 부분 특화는 특정 타입 패턴에 최적화된 구현을 제공한다. 이를 통해 컴파일러는 올바른 버전의 코드를 자동으로 선택하고, 타입 안전성을 보장한다.

### 9.3.2 특화와 Concepts를 조합한 안전한 설계
이제 부분 특화와 Concepts를 함께 사용하여 더욱 안전하고 표현력 있는 코드를 작성해보자.

```cpp
#include <iostream>
#include <concepts>
#include <vector>
#include <memory>

// 컨테이너인지 검사하는 Concept
template <typename T>
concept Container = requires(T t) {
    { t.begin() } -> std::input_or_output_iterator;
    { t.end() } -> std::input_or_output_iterator;
    { t.size() } -> std::convertible_to<std::size_t>;
};

// 기본 처리기: 일반 타입
template <typename T>
class Processor {
public:
    void process(const T& value) {
        std::cout << "일반 처리기: 단일 값 처리" << std::endl;
    }
};

// 특화 1: 컨테이너 타입
template <Container C>
class Processor<C> {
public:
    void process(const C& container) {
        std::cout << "컨테이너 처리기: " << container.size() << "개 요소 처리" << std::endl;
    }
};

// 특화 2: 포인터 타입
template <typename T>
class Processor<T*> {
public:
    void process(T* ptr) {
        std::cout << "포인터 처리기: 주소 처리" << std::endl;
    }
};

// 특화 3: unique_ptr
template <typename T>
class Processor<std::unique_ptr<T>> {
public:
    void process(const std::unique_ptr<T>& ptr) {
        std::cout << "unique_ptr 처리기: 소유권 관리" << std::endl;
    }
};

// 특화 4: shared_ptr
template <typename T>
class Processor<std::shared_ptr<T>> {
public:
    void process(const std::shared_ptr<T>& ptr) {
        std::cout << "shared_ptr 처리기: 공유 소유권 관리" << std::endl;
    }
};

int main() {
    // 일반 타입
    Processor<int> intProc;
    intProc.process(42);
    
    // 컨테이너 타입
    Processor<std::vector<int>> vecProc;
    std::vector<int> vec = {1, 2, 3, 4, 5};
    vecProc.process(vec);
    
    // 포인터 타입
    Processor<int*> ptrProc;
    int x = 10;
    ptrProc.process(&x);
    
    // unique_ptr
    Processor<std::unique_ptr<int>> uniqueProc;
    auto up = std::make_unique<int>(100);
    uniqueProc.process(up);
    
    // shared_ptr
    Processor<std::shared_ptr<int>> sharedProc;
    auto sp = std::make_shared<int>(200);
    sharedProc.process(sp);
    
    return 0;
}
```

### 9.3.3 타입 특화를 통한 안전한 직렬화 시스템
실무에서 자주 사용되는 패턴으로, 다양한 타입을 안전하게 처리하는 직렬화 시스템을 만들어보자.

```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <concepts>
#include <memory>

// 기본 직렬화기
template <typename T>
class Serializer {
public:
    static std::string serialize(const T& value) {
        std::ostringstream oss;
        oss << value;
        return oss.str();
    }
};

// 특화: std::string
template <>
class Serializer<std::string> {
public:
    static std::string serialize(const std::string& value) {
        // 문자열은 따옴표로 감싼다
        return "\"" + value + "\"";
    }
};

// 특화: bool 타입 (true/false로 출력)
template <>
class Serializer<bool> {
public:
    static std::string serialize(bool value) {
        return value ? "true" : "false";
    }
};

// 특화: 포인터 타입
template <typename T>
class Serializer<T*> {
public:
    static std::string serialize(T* ptr) {
        if (ptr == nullptr) {
            return "null";
        }
        std::ostringstream oss;
        oss << "0x" << std::hex << reinterpret_cast<uintptr_t>(ptr);
        return oss.str();
    }
};

// 특화: std::vector
template <typename T>
class Serializer<std::vector<T>> {
public:
    static std::string serialize(const std::vector<T>& vec) {
        std::string result = "[";
        for (std::size_t i = 0; i < vec.size(); ++i) {
            result += Serializer<T>::serialize(vec[i]);
            if (i < vec.size() - 1) {
                result += ", ";
            }
        }
        result += "]";
        return result;
    }
};

// 특화: std::unique_ptr
template <typename T>
class Serializer<std::unique_ptr<T>> {
public:
    static std::string serialize(const std::unique_ptr<T>& ptr) {
        if (!ptr) {
            return "null";
        }
        return "unique_ptr(" + Serializer<T>::serialize(*ptr) + ")";
    }
};

// 편의 함수
template <typename T>
std::string serialize(const T& value) {
    return Serializer<T>::serialize(value);
}

int main() {
    // 기본 타입들
    std::cout << "정수: " << serialize(42) << std::endl;
    std::cout << "부동소수점: " << serialize(3.14) << std::endl;
    std::cout << "불린: " << serialize(true) << std::endl;
    
    // 문자열
    std::cout << "문자열: " << serialize(std::string("Hello")) << std::endl;
    
    // 포인터
    int x = 100;
    std::cout << "포인터: " << serialize(&x) << std::endl;
    std::cout << "널 포인터: " << serialize(static_cast<int*>(nullptr)) << std::endl;
    
    // 벡터
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::cout << "벡터: " << serialize(vec) << std::endl;
    
    // unique_ptr
    auto up = std::make_unique<int>(777);
    std::cout << "unique_ptr: " << serialize(up) << std::endl;
    
    // 중첩 구조
    std::vector<std::string> strings = {"apple", "banana", "cherry"};
    std::cout << "문자열 벡터: " << serialize(strings) << std::endl;
    
    return 0;
}
```

이 예제는 매우 중요한 패턴을 보여준다. 기본 템플릿 하나를 정의하고, 특정 타입들에 대해 특화된 버전을 제공함으로써, 모든 타입을 안전하게 처리할 수 있다. 각 타입에 가장 적절한 방식으로 직렬화되고, 컴파일 타임에 타입 검증이 이루어진다.
  


## 9.4 consteval과 즉시 함수

### 9.4.1 consteval 함수의 개념과 필요성
C++20에서 도입된 `consteval` 키워드는 "이 함수는 반드시 컴파일 타임에 실행되어야 한다"는 의미다. 이는 함수의 결과가 항상 컴파일 타임 상수여야 함을 보장한다. 이를 통해 런타임에 계산이 발생하지 않으므로 성능이 뛰어나고, 동시에 타입과 값의 안전성을 보장한다.

```cpp
#include <iostream>
#include <array>

// consteval을 사용한 컴파일 타임 함수
consteval int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// consteval을 사용한 배열 크기 계산
consteval std::size_t calculateArraySize(int factor) {
    return factor * 10;
}

// 일반 함수
int regularFibonacci(int n) {
    if (n <= 1) return n;
    return regularFibonacci(n - 1) + regularFibonacci(n - 2);
}

int main() {
    // consteval 함수의 결과는 컴파일 타임에 계산된다
    constexpr int fib10 = fibonacci(10);  // 컴파일 타임에 계산됨
    std::cout << "10번째 피보나치: " << fib10 << std::endl;
    
    // 배열 크기를 consteval로 결정
    constexpr std::size_t size = calculateArraySize(5);
    std::array<int, size> arr{};  // 컴파일 타임에 크기가 결정됨
    std::cout << "배열 크기: " << arr.size() << std::endl;
    
    // 런타임 값으로는 consteval을 호출할 수 없다
    // int n = 10;
    // int result = fibonacci(n);  // ✗ 컴파일 오류: 런타임 값으로 호출 불가
    
    return 0;
}
```

consteval의 가장 큰 장점은 성능이다. fibonacci 함수는 매우 비효율적인 재귀 알고리즘이지만, consteval을 사용하면 컴파일 타임에 계산이 완료되어 런타임에는 이미 계산된 값만 사용된다.

### 9.4.2 consteval로 안전한 컴파일 타임 검증 만들기
consteval을 활용하여 컴파일 타임에 복잡한 검증을 수행할 수 있다. 예를 들어 설정값이 유효한지 확인하거나, 암호화 키를 생성하는 등의 작업을 컴파일 타임에 수행할 수 있다.

```cpp
#include <iostream>
#include <array>
#include <stdexcept>

// consteval을 사용한 안전한 범위 검사
consteval bool isValidPort(int port) {
    if (port < 1 || port > 65535) {
        throw std::out_of_range("포트는 1~65535 범위여야 합니다");
    }
    return true;
}

// consteval을 사용한 설정 값 검증
struct ServerConfig {
    int port;
    int maxConnections;
    int timeout;
    
    // 생성자에서 consteval 함수 호출
    consteval ServerConfig(int p, int max, int t) 
        : port(p), maxConnections(max), timeout(t) {
        // 모든 값이 유효한지 검증한다
        if (p < 1 || p > 65535) {
            throw std::out_of_range("포트가 유효하지 않습니다");
        }
        if (max < 1 || max > 10000) {
            throw std::out_of_range("최대 연결 수가 유효하지 않습니다");
        }
        if (t < 1 || t > 3600) {
            throw std::out_of_range("타임아웃이 유효하지 않습니다");
        }
    }
};

// consteval을 사용한 문자열 검증
consteval bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}

// 안전한 버퍼 크기 (2의 거듭제곱)
template <int Size>
requires (isPowerOfTwo(Size))
class SafeBuffer {
private:
    std::array<char, Size> buffer{};
    
public:
    static constexpr int capacity() { return Size; }
    
    void write(const char* data) {
        std::cout << "크기 " << Size << "의 버퍼에 쓰기" << std::endl;
    }
};

// consteval을 사용한 평면도 유효성 검사
consteval bool isValidFloorplan(int width, int height, int area) {
    return width > 0 && height > 0 && width * height == area;
}

int main() {
    // 유효한 서버 설정 (컴파일 타임에 검증됨)
    constexpr ServerConfig config1(8080, 100, 300);
    std::cout << "서버 포트: " << config1.port << std::endl;
    
    // 다음은 컴파일 오류가 발생한다:
    // constexpr ServerConfig config2(99999, 100, 300);  // ✗ 포트가 유효하지 않음
    // constexpr ServerConfig config3(8080, 0, 300);     // ✗ 최대 연결 수가 유효하지 않음
    
    // 2의 거듭제곱 버퍼만 생성 가능
    SafeBuffer<256> buf1;  // ✓ 256은 2^8
    buf1.write("data");
    
    // SafeBuffer<100> buf2;  // ✗ 컴파일 오류: 100은 2의 거듭제곱이 아님
    
    return 0;
}
```

### 9.4.3 consteval을 사용한 컴파일 타임 문자열 처리
consteval의 또 다른 강력한 활용은 컴파일 타임에 문자열을 처리하는 것이다. C++20부터 `std::string`도 consteval 컨텍스트에서 사용 가능하므로, 복잡한 문자열 조작을 컴파일 타임에 수행할 수 있다.

```cpp
#include <iostream>
#include <string>
#include <array>

// consteval을 사용한 문자열 역순
consteval std::string reverseString(std::string str) {
    std::string result = str;
    std::reverse(result.begin(), result.end());
    return result;
}

// consteval을 사용한 문자열 길이 검증
consteval bool isValidIdentifier(std::string_view identifier) {
    if (identifier.empty() || identifier.length() > 64) {
        return false;
    }
    // 첫 글자가 문자 또는 언더스코어여야 함
    if (!std::isalpha(identifier[0]) && identifier[0] != '_') {
        return false;
    }
    // 나머지는 문자, 숫자, 언더스코어여야 함
    for (char c : identifier) {
        if (!std::isalnum(c) && c != '_') {
            return false;
        }
    }
    return true;
}

// consteval을 사용한 문자열 해싱
consteval unsigned long stringHash(std::string_view str) {
    unsigned long hash = 5381;
    for (char c : str) {
        hash = ((hash << 5) + hash) + c;
    }
    return hash;
}

// 유효한 식별자만 받는 클래스
class ValidatedIdentifier {
private:
    std::string name;
    
public:
    consteval ValidatedIdentifier(std::string_view id) : name(id) {
        if (!isValidIdentifier(id)) {
            throw std::invalid_argument("유효하지 않은 식별자");
        }
    }
    
    const std::string& getName() const { return name; }
};

// 컴파일 타임에 해시값을 생성하는 매크로
template <std::size_t N>
struct HashedString {
    std::array<char, N> value;
    unsigned long hash;
    
    consteval HashedString(const char (&str)[N]) {
        for (std::size_t i = 0; i < N; ++i) {
            value[i] = str[i];
        }
        hash = stringHash(std::string_view(str, N - 1));
    }
};

int main() {
    // 문자열 역순 (컴파일 타임에 수행)
    constexpr auto reversed = reverseString(std::string("Hello"));
    std::cout << "역순 문자열: " << reversed << std::endl;
    
    // 유효한 식별자 검증
    constexpr ValidatedIdentifier id1("myVariable");
    std::cout << "식별자: " << id1.getName() << std::endl;
    
    // 다음은 컴파일 오류:
    // constexpr ValidatedIdentifier id2("123invalid");  // ✗ 숫자로 시작
    // constexpr ValidatedIdentifier id3("");             // ✗ 빈 문자열
    
    // 해시값 컴파일 타임 계산
    constexpr HashedString<12> hashed("HelloWorld");
    std::cout << "해시값: " << hashed.hash << std::endl;
    
    return 0;
}
```

### 9.4.4 consteval과 constexpr의 차이점 이해하기
consteval과 constexpr의 차이점을 명확히 이해하는 것이 중요하다. `constexpr`은 "이 함수는 컴파일 타임에도, 런타임에도 실행될 수 있다"는 의미이고, `consteval`은 "이 함수는 반드시 컴파일 타임에만 실행되어야 한다"는 의미다.

```cpp
#include <iostream>

// constexpr: 컴파일 타임과 런타임 모두 가능
constexpr int add_constexpr(int a, int b) {
    return a + b;
}

// consteval: 컴파일 타임만 가능
consteval int add_consteval(int a, int b) {
    return a + b;
}

int main() {
    // constexpr은 두 가지 방식으로 사용 가능
    constexpr int result1 = add_constexpr(10, 20);  // ✓ 컴파일 타임
    std::cout << "컴파일 타임 결과: " << result1 << std::endl;
    
    int a = 10, b = 20;
    int result2 = add_constexpr(a, b);  // ✓ 런타임
    std::cout << "런타임 결과: " << result2 << std::endl;
    
    // consteval은 컴파일 타임에만 사용 가능
    constexpr int result3 = add_consteval(10, 20);  // ✓ 컴파일 타임
    std::cout << "consteval 결과: " << result3 << std::endl;
    
    // int result4 = add_consteval(a, b);  // ✗ 컴파일 오류: 런타임 값 사용 불가
    
    // 하지만 런타임 값으로 계산한 후 consteval의 결과를 사용할 수 있다
    constexpr int compileTimeResult = add_consteval(5, 5);
    int finalResult = add_constexpr(a, b) + compileTimeResult;
    std::cout << "최종 결과: " << finalResult << std::endl;
    
    return 0;
}
```
  


## 9.5 종합 실습: 타입 안전한 설정 시스템
지금까지 배운 모든 기능을 종합하여 실무에서 사용 가능한 타입 안전한 설정 시스템을 만들어보자. 이 시스템은 설정값을 컴파일 타임에 검증하고, 잘못된 설정은 컴파일되지 않도록 보장한다.

```cpp
#include <iostream>
#include <string>
#include <memory>
#include <concepts>

// ========== 기본 타입 정의 ==========

// 범위를 나타내는 Concept
template <typename T>
concept HasMin = requires(T t) {
    { T::min_value } -> std::convertible_to<int>;
};

template <typename T>
concept HasMax = requires(T t) {
    { T::max_value } -> std::convertible_to<int>;
};

template <typename T>
concept Bounded = HasMin<T> && HasMax<T>;

// ========== 설정 항목 정의 ==========

// 정수 범위 검증
struct IntRange {
    static constexpr int min_value = INT_MIN;
    static constexpr int max_value = INT_MAX;
};

struct PortRange {
    static constexpr int min_value = 1;
    static constexpr int max_value = 65535;
};

struct ThreadCountRange {
    static constexpr int min_value = 1;
    static constexpr int max_value = 1024;
};

struct TimeoutRange {
    static constexpr int min_value = 1;
    static constexpr int max_value = 3600;
};

// ========== 설정 클래스 ==========

// 범위를 가진 정수 설정 항목
template <Bounded Range, int DefaultValue>
requires (DefaultValue >= Range::min_value && DefaultValue <= Range::max_value)
class BoundedIntSetting {
private:
    int value;
    
public:
    consteval BoundedIntSetting(int v = DefaultValue) : value(v) {
        if (v < Range::min_value || v > Range::max_value) {
            throw std::out_of_range("범위를 벗어난 값");
        }
    }
    
    consteval int getValue() const { return value; }
    
    static consteval int getMin() { return Range::min_value; }
    static consteval int getMax() { return Range::max_value; }
    static consteval int getDefault() { return DefaultValue; }
};

// 문자열 설정 항목
class StringSetting {
private:
    std::string value;
    
public:
    consteval StringSetting(std::string_view v) 
        : value(v) {
        if (v.empty() || v.length() > 255) {
            throw std::out_of_range("문자열 길이가 유효하지 않습니다");
        }
    }
    
    const std::string& getValue() const { return value; }
};

// 부울 설정 항목
class BoolSetting {
private:
    bool value;
    
public:
    consteval BoolSetting(bool v = false) : value(v) {}
    
    consteval bool getValue() const { return value; }
};

// ========== 시스템 설정 ==========

class SystemConfiguration {
private:
    BoundedIntSetting<PortRange, 8080> port;
    BoundedIntSetting<ThreadCountRange, 4> threadCount;
    BoundedIntSetting<TimeoutRange, 300> timeout;
    
public:
    consteval SystemConfiguration(
        int p = 8080,
        int tc = 4,
        int t = 300
    ) : port(p), threadCount(tc), timeout(t) {
        // 모든 설정이 consteval에서 검증된다
    }
    
    int getPort() const { return port.getValue(); }
    int getThreadCount() const { return threadCount.getValue(); }
    int getTimeout() const { return timeout.getValue(); }
};

// ========== 사용 예제 ==========

int main() {
    // 유효한 설정 (컴파일 타임에 검증됨)
    constexpr SystemConfiguration config1;
    std::cout << "포트: " << config1.getPort() << std::endl;
    std::cout << "스레드: " << config1.getThreadCount() << std::endl;
    std::cout << "타임아웃: " << config1.getTimeout() << std::endl;
    
    // 커스텀 유효한 설정
    constexpr SystemConfiguration config2(3000, 8, 600);
    std::cout << "\n커스텀 설정:" << std::endl;
    std::cout << "포트: " << config2.getPort() << std::endl;
    std::cout << "스레드: " << config2.getThreadCount() << std::endl;
    std::cout << "타임아웃: " << config2.getTimeout() << std::endl;
    
    // 다음은 모두 컴파일 오류가 발생한다:
    // constexpr SystemConfiguration config3(99999, 4, 300);  // ✗ 포트 범위 초과
    // constexpr SystemConfiguration config4(8080, 0, 300);   // ✗ 스레드 수가 최소값 미만
    // constexpr SystemConfiguration config5(8080, 4, 5000);  // ✗ 타임아웃이 범위 초과
    
    std::cout << "\n포트 범위: " 
              << BoundedIntSetting<PortRange, 8080>::getMin() << "~"
              << BoundedIntSetting<PortRange, 8080>::getMax() << std::endl;
    
    return 0;
}
```

이 종합 실습은 다음과 같은 안전성을 보장한다:

1. **컴파일 타임 검증**: 모든 설정값이 컴파일 타임에 검증된다. 잘못된 값은 컴파일되지 않는다.
2. **타입 안전성**: Concepts를 통해 범위를 가진 정수만 사용 가능하도록 제한한다.
3. **명확한 의도 표현**: 각 설정 항목이 어떤 범위를 가지는지 타입으로 명확하게 드러난다.
4. **런타임 오류 제거**: 컴파일 타임에 모든 검증이 완료되므로 런타임 오류가 발생하지 않는다.
  


## 결론
이 장에서 배운 내용을 정리하면 다음과 같다.

**Concepts**는 SFINAE를 대체하여 템플릿 제약을 명확하고 읽기 쉽게 표현한다. 표준 Concepts와 사용자 정의 Concepts를 조합하여 매우 표현력 있는 코드를 작성할 수 있다.

**컴파일 타임 타입 검증**은 `static_assert`와 타입 특성을 사용하여 타입 안전성을 보장한다. 이를 통해 런타임에 발생할 수 있는 타입 관련 오류를 완전히 제거할 수 있다.

**템플릿 특화**는 특정 타입 패턴에 대해 최적화된 구현을 제공함으로써 성능과 안전성을 동시에 달성한다.

**consteval 함수**는 함수가 반드시 컴파일 타임에 실행되도록 강제하여 런타임 성능을 개선하고 동시에 값의 안전성을 보장한다.

이 모든 기능들은 Modern C++의 철학인 "컴파일 타임에 최대한 많은 검증과 계산을 수행하여 런타임 오류를 완전히 제거하자"를 실현한다. 이것이 바로 C++이 안전한 프로그래밍을 가능하게 하는 방법이고, Rust와 비교했을 때도 전혀 뒤지지 않는 이유다.

다음 장에서는 예외 안전성에 대해 배우며, C++에서 오류를 안전하게 처리하는 방법을 자세히 살펴볼 것이다.  