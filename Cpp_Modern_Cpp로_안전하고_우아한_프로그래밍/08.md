# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 8: 열거형과 상수의 안전한 관리
이번 장에서는 C++에서 상수와 열거형을 안전하게 관리하는 방법을 배워보겠다. 많은 사람들이 간과하는 부분이지만, 이 주제는 실제로 매우 중요하다. 왜냐하면 프로그래밍에서 발생하는 버그의 상당 부분이 바로 "매직 넘버"라고 불리는 의미 불명확한 숫자들과 타입 안전성이 없는 열거형 때문이기 때문이다.

Rust는 이러한 문제를 컴파일러 수준에서 강제한다. 하지만 Modern C++도 C++11 이후로 강력한 도구들을 제공하고 있다. 이번 장을 통해 C++도 얼마나 안전하고 우아하게 이런 문제를 해결할 수 있는지 보여드리겠다.

  

## 8.1 왜 열거형과 상수 관리가 중요한가?

### 매직 넘버의 위험성
먼저 문제점을 명확히 이해해 본다. 여러분이 사용자의 역할을 나타내는 코드를 작성한다고 생각해보자.

```cpp
// ❌ 나쁜 예: 매직 넘버 사용
void setUserRole(int role) {
    if (role == 1) {
        std::cout << "관리자 권한 부여" << std::endl;
    } else if (role == 2) {
        std::cout << "사용자 권한 부여" << std::endl;
    } else if (role == 3) {
        std::cout << "손님 권한 부여" << std::endl;
    }
}

int main() {
    setUserRole(1);  // 1이 무엇을 의미하는가?
    setUserRole(2);  // 코드를 읽는 사람이 함수 정의를 찾아야 함
    setUserRole(5);  // 5는 유효한가? 누가 알겠는가?
    
    return 0;
}
```

이 코드의 문제점들을 생각해보자:
- 1, 2, 3이 정확히 무엇을 의미하는지 코드만으로는 알 수 없다.
- 사용자가 실수로 99를 전달해도 컴파일 오류가 발생하지 않는다.
- 각 역할이 여러 곳에서 중복되면, 하나를 바꿀 때 다른 곳도 함께 바꿔야 한다.
- 코드 유지보수가 어렵다.

이런 문제들이 바로 우리가 해결해야 할 부분이다.  

  
  
## 8.2 enum class: 타입 안전한 열거형

### C++98의 enum의 문제점
C++98의 구식 `enum`을 먼저 살펴본다:

```cpp
// C++98 스타일: enum (구식)
enum UserRole {
    ADMIN = 1,
    USER = 2,
    GUEST = 3
};

enum Color {
    RED = 1,
    GREEN = 2,
    BLUE = 3
};

int main() {
    UserRole role = ADMIN;
    Color color = RED;
    
    // ❌ 문제: 서로 다른 enum을 비교할 수 있다!
    if (role == color) {
        std::cout << "같다" << std::endl;
    }
    
    // ❌ 문제: enum이 int로 암시적 변환된다
    int value = ADMIN;  // 암시적 변환, 타입 안전성 없음
    
    // ❌ 문제: enum 이름이 전역 스코프를 오염시킨다
    // ADMIN, USER, GUEST가 모두 전역 네임스페이스에 있음
    
    return 0;
}
```

이 문제들은 매우 심각한다. 특히 큰 프로젝트에서 전역 스코프의 오염은 이름 충돌을 야기한다.  
  
### enum class: Modern C++의 해결책
C++11에서 도입된 `enum class`는 이 모든 문제를 해결한다:  

```cpp
#include <iostream>

// ✅ 좋은 예: enum class 사용
enum class UserRole {
    Admin = 1,
    User = 2,
    Guest = 3
};

enum class Color {
    Red = 1,
    Green = 2,
    Blue = 3
};

int main() {
    UserRole role = UserRole::Admin;
    Color color = Color::Red;
    
    // ✅ 이제 서로 다른 enum끼리 비교할 수 없다
    // if (role == color) { }  // ❌ 컴파일 오류!
    
    // ✅ 명시적 변환 필요
    // int value = role;  // ❌ 컴파일 오류!
    int value = static_cast<int>(role);  // ✅ 명시적 변환
    
    // ✅ enum 이름이 scope 내에 지정된다
    // 전역 네임스페이스가 깨끗하게 유지된다
    
    return 0;
}
```

enum class의 장점을 정리하면:
- **타입 안전성**: 서로 다른 enum끼리 비교할 수 없다.
- **암시적 변환 방지**: int로 자동 변환되지 않는다.
- **스코프 안정성**: 멤버 이름이 enum 스코프 내에 정의된다.
- **명확한 의도**: 코드를 읽을 때 `UserRole::Admin`이라고 명시되어 의도가 분명하다.

### 실제 사용 예제
이제 더 현실적인 예제를 보자:

```cpp
#include <iostream>
#include <string>

enum class UserRole {
    Admin = 1,
    Editor = 2,
    Viewer = 3
};

enum class Permission {
    Read = 1,
    Write = 2,
    Delete = 4,
    Admin = 8
};

// enum class를 매개변수로 받는 함수
void grantPermission(UserRole role, Permission perm) {
    std::string roleName;
    
    switch (role) {
        case UserRole::Admin:
            roleName = "관리자";
            break;
        case UserRole::Editor:
            roleName = "편집자";
            break;
        case UserRole::Viewer:
            roleName = "열람자";
            break;
    }
    
    std::string permName;
    switch (perm) {
        case Permission::Read:
            permName = "읽기";
            break;
        case Permission::Write:
            permName = "쓰기";
            break;
        case Permission::Delete:
            permName = "삭제";
            break;
        case Permission::Admin:
            permName = "관리";
            break;
    }
    
    std::cout << roleName << "에게 " << permName << " 권한을 부여합니다" << std::endl;
}

int main() {
    grantPermission(UserRole::Admin, Permission::Read);
    grantPermission(UserRole::Editor, Permission::Write);
    grantPermission(UserRole::Viewer, Permission::Read);
    
    // grantPermission(1, 2);  // ❌ 컴파일 오류! int는 enum class가 아님
    // grantPermission(UserRole::Admin, Permission::Admin);  // ✅ 명확함
    
    return 0;
}
```

이 코드의 장점을 생각해보자:
- 함수를 호출할 때 의도가 명확하다.
- 잘못된 타입을 전달하면 컴파일 오류로 즉시 알 수 있다.
- 각 역할과 권한이 명확하게 정의되어 있다.

  

## 8.3 enum class의 기본 타입 지정

### 기본 타입을 명시적으로 지정하기
enum class의 기본 타입은 `int`이지만, 필요에 따라 다른 타입을 지정할 수 있다:

```cpp
#include <iostream>
#include <cstdint>

// 메모리 효율을 위해 unsigned char 사용
enum class Status : unsigned char {
    Idle = 0,
    Running = 1,
    Paused = 2,
    Stopped = 3
};

// 더 큰 범위가 필요하면 int64_t 사용
enum class TimeZone : int {
    UTC = 0,
    KST = 9,
    JST = 9,
    PST = -8,
    EST = -5
};

int main() {
    Status status = Status::Running;
    TimeZone tz = TimeZone::KST;
    
    // 기본 타입을 명시적으로 확인할 수 있다
    std::cout << "Status size: " << sizeof(status) << " bytes" << std::endl;
    std::cout << "TimeZone size: " << sizeof(tz) << " bytes" << std::endl;
    
    return 0;
}
```

기본 타입을 지정하는 이유:
- **메모리 효율**: 작은 값들만 가진다면 `unsigned char`를 사용하여 메모리를 절약한다.
- **성능**: 작은 타입은 캐시 효율이 좋다.
- **명확성**: 코드를 읽을 때 enum의 범위를 명확히 알 수 있다.

### C++ Core Guidelines에 따른 권장사항

**Enum.3: enum class를 사용하세요.**

이것이 바로 권장 사항이다. 항상 `enum class`를 사용하고, 구식의 `enum`은 피해야 한다.

  

## 8.4 constexpr: 컴파일 타임 상수

### constexpr의 매력
이제 상수를 안전하게 관리하는 또 다른 방법인 `constexpr`에 대해 배워본다. `constexpr`은 컴파일 타임에 계산되는 값이다:

```cpp
#include <iostream>

// ❌ 나쁜 예: #define 매크로 사용
#define MAX_USERS 100
#define PI 3.14159

// ✅ 좋은 예: constexpr 사용
constexpr int MAX_USERS_NEW = 100;
constexpr double PI_NEW = 3.14159;

int main() {
    // #define의 문제점:
    // 1. 타입 안전성이 없다
    // 2. 디버거에서 보이지 않는다
    // 3. 스코프가 없다 (전역)
    // 4. 부작용이 있을 수 있다
    
    // constexpr의 장점:
    // 1. 타입이 명시적이다
    // 2. 디버거에서 볼 수 있다
    // 3. 스코프를 가질 수 있다
    // 4. 완전히 안전하다
    
    std::cout << MAX_USERS_NEW << std::endl;
    
    return 0;
}
```

### constexpr의 강력함: 컴파일 타임 계산
constexpr의 진정한 가치는 컴파일 타임에 계산을 수행할 수 있다는 점이다:

```cpp
#include <iostream>

// constexpr 함수는 컴파일 타임에 실행될 수 있다
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

constexpr double square(double x) {
    return x * x;
}

constexpr int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    // 이 모든 값들은 컴파일 타임에 계산된다
    constexpr int fac_5 = factorial(5);      // 120
    constexpr double sq = square(3.5);       // 12.25
    constexpr int fib_10 = fibonacci(10);    // 55
    
    // 배열의 크기로도 사용 가능하다 (C++에서는 배열 크기가 컴파일 타임 상수여야 함)
    int arr[factorial(5)];  // 120 크기의 배열
    
    std::cout << "5! = " << fac_5 << std::endl;
    std::cout << "3.5^2 = " << sq << std::endl;
    std::cout << "fib(10) = " << fib_10 << std::endl;
    std::cout << "Array size: " << sizeof(arr) / sizeof(arr[0]) << std::endl;
    
    return 0;
}
```

이 코드의 놀라운 점을 이해해 보자:
- 코드를 작성할 때는 함수처럼 보인다.
- 하지만 컴파일러는 컴파일 타임에 이 함수들을 실행한다.
- 런타임에는 이미 계산된 값만 남는다.
- 이것은 성능상 매우 중요한 최적화이다.

### constexpr의 제약사항
constexpr 함수가 컴파일 타임에 실행되려면 몇 가지 제약이 있다:

```cpp
#include <iostream>

// ✅ constexpr 함수가 될 수 있는 예들
constexpr int add(int a, int b) {
    return a + b;
}

constexpr bool isEven(int n) {
    return n % 2 == 0;
}

constexpr int arraySum(const int* arr, int size) {
    int sum = 0;
    for (int i = 0; i < size; ++i) {
        sum += arr[i];
    }
    return sum;
}

// ❌ constexpr 함수가 될 수 없는 예들 (C++20 이전)
// - I/O 작업 (std::cout, 파일 읽기 등)
// - 메모리 할당 (new, malloc)
// - 동적 메모리 접근

// 하지만 C++20 이후에는 더 많은 작업이 constexpr에서 가능해졌다
// 예: std::vector도 constexpr에서 사용 가능

int main() {
    constexpr int result = add(5, 3);  // 컴파일 타임에 계산
    
    return 0;
}
```



## 8.5 consteval: 즉시 함수 (C++20)

### consteval의 필요성
C++20에서 도입된 `consteval`은 constexpr보다 더 강력하다. consteval 함수는 반드시 컴파일 타임에 실행되어야 한다:

```cpp
#include <iostream>

// constexpr: 컴파일 타임에 실행되거나 런타임에 실행될 수 있다
constexpr int add_constexpr(int a, int b) {
    return a + b;
}

// consteval: 반드시 컴파일 타임에 실행되어야 한다
consteval int add_consteval(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    
    // ✅ 컴파일 타임 상수는 둘 다 작동한다
    constexpr int r1 = add_constexpr(5, 3);
    constexpr int r2 = add_consteval(5, 3);
    
    // ✅ constexpr는 런타임 값으로도 작동한다
    int r3 = add_constexpr(x, y);
    
    // ❌ consteval는 런타임 값으로는 작동하지 않는다
    // int r4 = add_consteval(x, y);  // 컴파일 오류!
    
    return 0;
}
```

### consteval의 실제 활용
consteval은 어떤 상황에서 유용할까? 바로 컴파일 타임에만 계산되어야 하는 값들이다:

```cpp
#include <iostream>
#include <array>

// 직렬 번호 생성기: 컴파일 타임에만 고유값을 만든다
consteval int generateSerialNumber(int seed) {
    // 이것은 런타임에는 호출될 수 없다
    // 따라서 각 컴파일마다 다른 번호를 만들 수 있다
    return seed * 12345 + 67890;
}

// 컴파일 타임 해시 함수
consteval unsigned int hashString(const char* str) {
    unsigned int hash = 5381;
    while (*str) {
        hash = ((hash << 5) + hash) + (*str++);
    }
    return hash;
}

int main() {
    // 이 값들은 모두 컴파일 타임에 계산된다
    constexpr int serial = generateSerialNumber(1);
    constexpr unsigned int hash = hashString("Hello");
    
    std::cout << "Serial: " << serial << std::endl;
    std::cout << "Hash: " << hash << std::endl;
    
    return 0;
}
```



## 8.6 const와 constexpr의 차이

### 여러분이 헷갈할 수 있는 부분
`const`, `constexpr`, `consteval`은 모두 다르다. 각각의 차이를 명확히 이해해야 한다:

```cpp
#include <iostream>

// 1. const: 런타임에 결정되지만, 이후 변경 불가
const int runtime_const = std::rand();  // 런타임에 결정됨

// 2. constexpr: 컴파일 타임에 결정되어야 함
constexpr int compile_const = 42;  // 컴파일 타임에 결정됨

// 3. const int*: 포인터가 가리키는 값이 const (포인터 자체는 아님)
int value = 10;
const int* ptr1 = &value;  // *ptr1은 변경 불가, ptr1은 변경 가능

// 4. int* const: 포인터 자체가 const (가리키는 값은 아님)
int* const ptr2 = &value;  // ptr2는 변경 불가, *ptr2는 변경 가능

// 5. const int* const: 둘 다 const
const int* const ptr3 = &value;  // 모두 변경 불가

int main() {
    // const는 런타임에 결정되지만 배열 크기로 사용할 수 없다
    // int arr[runtime_const];  // ❌ 오류!
    
    // constexpr는 배열 크기로 사용할 수 있다
    int arr[compile_const];  // ✅ OK
    
    // const 포인터 활용
    std::cout << "ptr1: " << *ptr1 << std::endl;
    // *ptr1 = 20;  // ❌ 오류! const
    ptr1 = nullptr;  // ✅ OK
    
    // const ptr 활용
    std::cout << "ptr2: " << *ptr2 << std::endl;
    // ptr2 = nullptr;  // ❌ 오류! const
    *ptr2 = 20;  // ✅ OK (const가 아니므로)
    
    return 0;
}
```

포인터와 const의 관계는 많이 헷갈려 한다. 기억하자!:
- `const T*`: T는 const, 포인터는 아님
- `T* const`: 포인터는 const, T는 아님
- `const T* const`: 둘 다 const

### C++ Core Guidelines의 조언

**Con.1: 기본적으로 const를 사용하세요.**

이 원칙은 매우 중요하다. 변경될 이유가 없다면 const로 선언하자.

  

## 8.7 타입 안전한 상수 관리 패턴

### 정책 기반 설계 (Policy-Based Design)
이제 우리는 상수를 더 창의적으로 관리할 수 있다:  

```cpp
#include <iostream>
#include <limits>

// 타입 안전한 상수 관리: 강한 타입 래퍼
template<typename T, T Default>
class SafeConstant {
private:
    T value;
public:
    SafeConstant() : value(Default) {}
    explicit SafeConstant(T v) : value(v) {}
    
    T getValue() const { return value; }
    
    // 명시적 변환만 가능
    explicit operator T() const { return value; }
};

// 특정 상수들을 타입으로 정의
using MaxConnections = SafeConstant<int, 100>;
using TimeoutMs = SafeConstant<int, 5000>;
using MaxRetries = SafeConstant<int, 3>;

void configureServer(MaxConnections max_conn, 
                     TimeoutMs timeout, 
                     MaxRetries retries) {
    std::cout << "Max connections: " << max_conn.getValue() << std::endl;
    std::cout << "Timeout: " << timeout.getValue() << "ms" << std::endl;
    std::cout << "Max retries: " << retries.getValue() << std::endl;
}

int main() {
    configureServer(MaxConnections{50}, TimeoutMs{3000}, MaxRetries{5});
    
    // ✅ 이렇게 하면 의도가 명확하다
    // configureServer(50, 3000, 5);  // ❌ 이건 명확하지 않음
    
    return 0;
}
```

이 패턴의 장점:
- 각 상수의 의미가 명확하다.
- 의도하지 않은 값이 전달될 수 없다.
- 기본값이 명시적으로 정의된다.

### 네임스페이스를 활용한 상수 그룹화

```cpp
#include <iostream>

namespace GameConfig {
    // 게임 설정 상수들을 그룹화
    namespace Screen {
        constexpr int WIDTH = 1920;
        constexpr int HEIGHT = 1080;
        constexpr double ASPECT_RATIO = 16.0 / 9.0;
    }
    
    namespace Gameplay {
        constexpr int MAX_PLAYERS = 4;
        constexpr int START_HEALTH = 100;
        constexpr float DAMAGE_MULTIPLIER = 1.5f;
    }
    
    namespace Physics {
        constexpr float GRAVITY = 9.8f;
        constexpr float FRICTION = 0.3f;
    }
}

int main() {
    std::cout << "Screen width: " << GameConfig::Screen::WIDTH << std::endl;
    std::cout << "Max players: " << GameConfig::Gameplay::MAX_PLAYERS << std::endl;
    std::cout << "Gravity: " << GameConfig::Physics::GRAVITY << std::endl;
    
    return 0;
}
```

이 접근법의 장점:
- 관련된 상수들이 함께 그룹화된다.
- 코드의 구조가 명확하다.
- 같은 이름의 상수가 있어도 네임스페이스로 구분된다.



## 8.8 매직 넘버 제거 전략

### 실제 프로젝트 예제
이제 실제 상황에서 어떻게 매직 넘버를 제거하는지 보여주겠다:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cmath>

// ❌ 나쁜 예: 매직 넘버가 가득한 코드
class OldUserManager {
public:
    bool validateAge(int age) {
        return age >= 18;  // 18이 뭔가?
    }
    
    bool validateEmail(const std::string& email) {
        return email.length() > 5 && email.length() < 255;  // 5와 255의 의미가?
    }
    
    double calculateDiscount(int memberDays) {
        if (memberDays > 365) {  // 365는?
            return 0.2;  // 20% 할인? 어디서?
        } else if (memberDays > 30) {  // 30일?
            return 0.1;  // 10% 할인?
        }
        return 0.0;
    }
};

// ✅ 좋은 예: 명확하게 정의된 상수들
namespace UserValidation {
    // 나이 제한
    constexpr int MIN_ADULT_AGE = 18;
    
    // 이메일 검증 범위
    constexpr int MIN_EMAIL_LENGTH = 5;
    constexpr int MAX_EMAIL_LENGTH = 254;  // RFC 5321 표준
    
    // 회원 기간별 할인 설정
    constexpr int GOLD_MEMBER_DAYS = 365;  // 1년 이상
    constexpr int SILVER_MEMBER_DAYS = 30;  // 1개월 이상
    
    constexpr double GOLD_MEMBER_DISCOUNT = 0.20;  // 20%
    constexpr double SILVER_MEMBER_DISCOUNT = 0.10;  // 10%
}

class NewUserManager {
public:
    bool validateAge(int age) {
        return age >= UserValidation::MIN_ADULT_AGE;
    }
    
    bool validateEmail(const std::string& email) {
        return email.length() >= UserValidation::MIN_EMAIL_LENGTH &&
               email.length() <= UserValidation::MAX_EMAIL_LENGTH;
    }
    
    double calculateDiscount(int memberDays) {
        if (memberDays >= UserValidation::GOLD_MEMBER_DAYS) {
            return UserValidation::GOLD_MEMBER_DISCOUNT;
        } else if (memberDays >= UserValidation::SILVER_MEMBER_DAYS) {
            return UserValidation::SILVER_MEMBER_DISCOUNT;
        }
        return 0.0;
    }
};

int main() {
    NewUserManager manager;
    
    std::cout << "Age 20 valid? " << manager.validateAge(20) << std::endl;
    std::cout << "Email valid? " << manager.validateEmail("user@example.com") << std::endl;
    
    // 할인 계산
    int days1 = 400;  // 1년 이상
    int days2 = 60;   // 1개월 이상 1년 미만
    int days3 = 10;   // 1개월 미만
    
    std::cout << "Discount for " << days1 << " days: " 
              << (manager.calculateDiscount(days1) * 100) << "%" << std::endl;
    std::cout << "Discount for " << days2 << " days: " 
              << (manager.calculateDiscount(days2) * 100) << "%" << std::endl;
    std::cout << "Discount for " << days3 << " days: " 
              << (manager.calculateDiscount(days3) * 100) << "%" << std::endl;
    
    return 0;
}
```

이 코드의 변화를 살펴보자:
- 각 상수가 명확한 이름으로 정의되었다.
- 상수들이 `UserValidation` 네임스페이스에서 관리된다.
- 코드를 읽을 때 의도가 즉시 이해된다.
- 만약 할인율을 변경해야 한다면, 한 곳에서만 수정하면 된다.
- 테스트할 때도 상수의 의미를 알 수 있다.



## 8.9 enum class와 switch 문의 완벽한 조합

### 타입 안전한 상태 관리
enum class와 switch 문을 함께 사용하면 매우 강력한 상태 관리 시스템을 만들 수 있다:

```cpp
#include <iostream>
#include <string>

enum class ConnectionState {
    Disconnected,
    Connecting,
    Connected,
    Disconnecting,
    Error
};

enum class ConnectionError {
    NetworkUnreachable,
    Timeout,
    AuthenticationFailed,
    ProtocolError,
    Unknown
};

class Connection {
private:
    ConnectionState state = ConnectionState::Disconnected;
    ConnectionError last_error = ConnectionError::Unknown;
    
public:
    void connect() {
        state = ConnectionState::Connecting;
        // 실제 연결 시도
        state = ConnectionState::Connected;
    }
    
    void disconnect() {
        state = ConnectionState::Disconnecting;
        // 실제 연결 종료
        state = ConnectionState::Disconnected;
    }
    
    void handleError(ConnectionError error) {
        last_error = error;
        state = ConnectionState::Error;
    }
    
    std::string getStatusMessage() const {
        switch (state) {
            case ConnectionState::Disconnected:
                return "연결되지 않음";
            case ConnectionState::Connecting:
                return "연결 중...";
            case ConnectionState::Connected:
                return "연결됨";
            case ConnectionState::Disconnecting:
                return "연결 해제 중...";
            case ConnectionState::Error:
                return getErrorMessage();
        }
        // C++17 이후: switch 문이 모든 경우를 다루지 않으면 경고
        return "알 수 없는 상태";
    }
    
private:
    std::string getErrorMessage() const {
        switch (last_error) {
            case ConnectionError::NetworkUnreachable:
                return "네트워크에 연결할 수 없음";
            case ConnectionError::Timeout:
                return "연결 시간 초과";
            case ConnectionError::AuthenticationFailed:
                return "인증 실패";
            case ConnectionError::ProtocolError:
                return "프로토콜 오류";
            case ConnectionError::Unknown:
                return "알 수 없는 오류";
        }
        return "오류";
    }
};

int main() {
    Connection conn;
    
    std::cout << conn.getStatusMessage() << std::endl;  // "연결되지 않음"
    
    conn.connect();
    std::cout << conn.getStatusMessage() << std::endl;  // "연결됨"
    
    conn.handleError(ConnectionError::Timeout);
    std::cout << conn.getStatusMessage() << std::endl;  // "연결 시간 초과"
    
    return 0;
}
```

이 코드의 강력한 점:
- 컴파일러가 모든 상태를 처리하지 않으면 경고한다.
- 새로운 상태를 추가할 때 모든 switch 문을 업데이트해야 한다 (이것은 장점이다!).
- 상태를 직접 숫자로 비교할 수 없다.
- 코드의 의도가 매우 명확하다.

  

## 8.10 비트 플래그 상태 관리

### enum class와 비트 연산
때로는 여러 상태를 동시에 나타내야 한다. 이 경우 비트 플래그를 사용한다:  
  
```cpp
#include <iostream>
#include <type_traits>

// 권한을 비트 플래그로 정의
enum class Permission : unsigned int {
    None = 0,
    Read = 1 << 0,      // 1 (001)
    Write = 1 << 1,     // 2 (010)
    Delete = 1 << 2,    // 4 (100)
    Admin = 1 << 3      // 8 (1000)
};

// 비트 플래그 연산을 위한 헬퍼 함수들
constexpr Permission operator|(Permission a, Permission b) {
    return static_cast<Permission>(
        static_cast<unsigned int>(a) | static_cast<unsigned int>(b)
    );
}

constexpr Permission operator&(Permission a, Permission b) {
    return static_cast<Permission>(
        static_cast<unsigned int>(a) & static_cast<unsigned int>(b)
    );
}

constexpr bool hasPermission(Permission perms, Permission perm) {
    return (perms & perm) == perm;
}

int main() {
    // 사용자에게 여러 권한을 부여
    Permission userPerms = Permission::Read | Permission::Write;
    
    // 권한 확인
    if (hasPermission(userPerms, Permission::Read)) {
        std::cout << "읽기 가능" << std::endl;
    }
    
    if (hasPermission(userPerms, Permission::Write)) {
        std::cout << "쓰기 가능" << std::endl;
    }
    
    if (hasPermission(userPerms, Permission::Delete)) {
        std::cout << "삭제 가능" << std::endl;
    } else {
        std::cout << "삭제 불가능" << std::endl;
    }
    
    // 관리자 권한 부여
    Permission adminPerms = userPerms | Permission::Admin;
    if (hasPermission(adminPerms, Permission::Admin)) {
        std::cout << "관리자 권한 있음" << std::endl;
    }
    
    return 0;
}
```

비트 플래그의 장점:
- 여러 boolean 값을 하나의 정수로 효율적으로 저장한다.
- 메모리를 절약한다.
- 비트 연산은 매우 빠르다.
- enum class를 사용하여 타입 안전성을 유지한다.

  

## 8.11 constexpr과 static 변수의 조합

### 상수 데이터베이스 구현
constexpr을 사용하면 컴파일 타임에 복잡한 데이터 구조를 만들 수 있다:  

```cpp
#include <iostream>
#include <array>
#include <string_view>

// C++20부터 std::array와 string_view를 constexpr에서 사용 가능
struct CountryInfo {
    std::string_view code;
    std::string_view name;
    int population;
};

constexpr std::array<CountryInfo, 3> COUNTRIES = {{
    {"KR", "South Korea", 51000000},
    {"JP", "Japan", 125000000},
    {"CN", "China", 1400000000}
}};

// 컴파일 타임에 국가 검색
constexpr CountryInfo* findCountry(std::string_view code) {
    for (auto& country : COUNTRIES) {
        if (country.code == code) {
            return const_cast<CountryInfo*>(&country);
        }
    }
    return nullptr;
}

int main() {
    // 이 검색은 컴파일 타임에 실행된다
    constexpr auto korea = findCountry("KR");
    
    if (korea) {
        std::cout << "Country: " << korea->name << std::endl;
        std::cout << "Population: " << korea->population << std::endl;
    }
    
    return 0;
}
```

이것은 매우 강력한 기능이다:
- 데이터가 컴파일 타임에 고정된다.
- 런타임에 데이터 초기화 비용이 없다.
- 컴파일러 최적화가 매우 효율적이다.



## 8.12 Visual Studio 2022에서의 실전 팁

### IntelliSense를 활용한 enum class 자동완성
Visual Studio 2022를 사용할 때, enum class는 다음과 같은 편의성을 제공한다:

```cpp
enum class Status {
    Pending,
    Active,
    Completed,
    Cancelled
};

int main() {
    // Status:: 를 입력하면 모든 값이 자동완성된다
    Status s = Status::  // Pending, Active, Completed, Cancelled 제안
    
    return 0;
}
```

### 컴파일 타임 상수 검증
Visual Studio는 constexpr 함수가 정말로 컴파일 타임에 실행되는지 검증할 수 있다:

```cpp
constexpr int getValue() {
    return 42;
}

int main() {
    constexpr int x = getValue();  // ✅ 컴파일 타임에 실행됨
    
    int y = 10;
    // constexpr int z = getValue() + y;  // ❌ 오류: y는 컴파일 타임 상수가 아님
    
    return 0;
}
```

만약 여러분이 constexpr 함수에 잘못된 코드를 작성하면, Visual Studio는 즉시 오류를 표시한다.



## 8.13 실제 프로젝트에 적용하기

### 게임 엔진 예제
이제 실제로 게임 엔진에서 사용될 법한 코드를 만들어 보자:

```cpp
#include <iostream>
#include <vector>
#include <array>
#include <cassert>

// 게임 엔티티 타입 정의
enum class EntityType : unsigned char {
    None = 0,
    Player = 1,
    Enemy = 2,
    Item = 3,
    Projectile = 4
};

// 엔티티 상태
enum class EntityState : unsigned char {
    Idle = 0,
    Moving = 1,
    Attacking = 2,
    Dead = 3
};

// 게임 설정 상수
namespace GameSettings {
    constexpr int GRID_WIDTH = 100;
    constexpr int GRID_HEIGHT = 100;
    constexpr int MAX_ENTITIES = 1000;
    constexpr float TILE_SIZE = 1.0f;
    
    // 엔티티별 기본 체력
    constexpr std::array<int, 5> DEFAULT_HEALTH = {
        0,      // None
        100,    // Player
        50,     // Enemy
        0,      // Item
        10      // Projectile
    };
    
    // 엔티티별 이동 속도
    constexpr std::array<float, 5> MOVE_SPEED = {
        0.0f,   // None
        5.0f,   // Player
        3.0f,   // Enemy
        0.0f,   // Item
        10.0f   // Projectile
    };
}

class Entity {
private:
    int id;
    EntityType type;
    EntityState state;
    int health;
    float x, y;
    
public:
    Entity(int id, EntityType type, float x, float y)
        : id(id), type(type), state(EntityState::Idle), x(x), y(y) {
        
        // enum을 index로 사용 (안전함)
        int typeIndex = static_cast<int>(type);
        assert(typeIndex >= 0 && typeIndex < GameSettings::DEFAULT_HEALTH.size());
        health = GameSettings::DEFAULT_HEALTH[typeIndex];
    }
    
    void update(float deltaTime) {
        if (state == EntityState::Dead) return;
        
        if (state == EntityState::Moving) {
            int typeIndex = static_cast<int>(type);
            float speed = GameSettings::MOVE_SPEED[typeIndex];
            x += speed * deltaTime;
        }
    }
    
    void takeDamage(int damage) {
        health -= damage;
        if (health <= 0) {
            state = EntityState::Dead;
            health = 0;
        }
    }
    
    EntityType getType() const { return type; }
    EntityState getState() const { return state; }
    int getHealth() const { return health; }
    
    void setState(EntityState newState) {
        state = newState;
    }
};

int main() {
    // 플레이어 생성
    Entity player(1, EntityType::Player, 50.0f, 50.0f);
    
    // 적 생성
    Entity enemy(2, EntityType::Enemy, 60.0f, 50.0f);
    
    std::cout << "Player type: " << static_cast<int>(player.getType()) << std::endl;
    std::cout << "Player health: " << player.getHealth() << std::endl;
    
    // 상태 변경
    player.setState(EntityState::Moving);
    player.update(1.0f);  // 1초 업데이트
    
    // 데미지 입기
    player.takeDamage(10);
    std::cout << "Player health after damage: " << player.getHealth() << std::endl;
    
    return 0;
}
```

이 코드에서 배울 수 있는 점들:
- enum class를 타입으로 사용하여 완전한 타입 안전성을 유지한다.
- constexpr 배열을 사용하여 컴파일 타임에 데이터를 정의한다.
- 게임 설정 상수들이 한곳에 집중되어 관리하기 쉽다.
- 런타임에 배열에 접근할 때도 안전하다.



## 8.14 체크리스트: 안전한 상수 관리 적용하기
이제 여러분이 실제 프로젝트에서 적용할 수 있는 체크리스트이다:

**enum 관련**
- [ ] 모든 enum을 enum class로 변경했는가?
- [ ] enum class의 멤버 이름을 PascalCase 또는 UPPER_CASE로 일관되게 사용하고 있는가?
- [ ] switch 문에서 모든 enum 값을 처리했는가?
- [ ] enum을 배열의 인덱스로 사용할 때 적절한 범위 확인을 하는가?

**상수 관리**
- [ ] 매직 넘버를 모두 제거했는가?
- [ ] 모든 상수에 명확한 이름을 붙였는가?
- [ ] 관련된 상수들을 네임스페이스로 그룹화했는가?
- [ ] #define 대신 constexpr을 사용하고 있는가?

**constexpr 활용**
- [ ] constexpr를 사용할 수 있는 값들을 constexpr로 선언했는가?
- [ ] 배열 크기나 다른 컴파일 타임 상수가 필요한 곳에서 constexpr를 활용했는가?
- [ ] C++20을 사용한다면 consteval을 고려했는가?

**코드 품질**
- [ ] 코드를 읽는 사람이 각 상수의 의미를 명확히 이해할 수 있는가?
- [ ] 유사한 값들의 관계가 코드에 명확히 드러나는가?
- [ ] 상수를 변경해야 할 때 한곳만 수정하면 되는가?

  

## 8.15 Rust와의 비교

### Rust의 enum vs C++의 enum class
Rust와 C++의 열거형을 비교해 보자:

```cpp
// C++ enum class
enum class Status {
    Pending,
    Active,
    Completed
};

Status s = Status::Active;
```

```rust
// Rust enum (참고용)
enum Status {
    Pending,
    Active,
    Completed,
}

let s = Status::Active;
```

문법은 비슷해 보이지만, Modern C++의 enum class는 완전한 타입 안전성을 제공한다.

### Rust의 const fn vs C++의 constexpr

```cpp
// C++ constexpr
constexpr int fibonacci(int n) {
    return n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);
}

constexpr int result = fibonacci(10);  // 컴파일 타임에 계산
```

```rust
// Rust const fn (참고용)
const fn fibonacci(n: usize) -> usize {
    match n {
        0 | 1 => n,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

const RESULT: usize = fibonacci(10);  // 컴파일 타임에 계산
```

Modern C++의 constexpr은 Rust의 const fn과 동일한 수준의 안전성과 성능을 제공한다.
  
  

## 요약
이번 장에서 배운 핵심 내용:

**enum class의 중요성**: 구식의 enum을 사용하지 말고 항상 enum class를 사용하자. enum class는 타입 안전성, 스코프 안정성, 암시적 변환 방지를 모두 제공한다.

**constexpr의 강력함**: #define 대신 constexpr을 사용한다. constexpr은 타입이 명시적이고, 스코프를 가지며, 디버거에서 볼 수 있다.

**컴파일 타임 계산**: constexpr 함수는 컴파일 타임에 실행되어 런타임 성능을 향상시킨다.

**매직 넘버 제거**: 모든 숫자에 명확한 의미를 부여하자. 이것이 코드 유지보수성과 안전성을 크게 향상시킨다.

**타입 안전한 상수**: 강한 타입 래퍼나 네임스페이스를 사용하여 상수를 체계적으로 관리하자.

**consteval의 활용** (C++20): 반드시 컴파일 타임에 실행되어야 하는 함수에는 consteval을 사용하자.  
  
이 모든 기능들을 올바르게 사용하면, C++은 Rust와 마찬가지로 안전하고 명확한 코드를 작성할 수 있다. 동시에 C++은 더 유연한 문법과 성능 최적화 기회를 제공한다.

여러분이 실제 프로젝트에서 이 기법들을 적용할 때 가장 중요한 점은 일관성이다. 프로젝트 전체에서 동일한 패턴을 사용하면, 코드를 읽고 유지보수하는 것이 훨씬 쉬워진다.   