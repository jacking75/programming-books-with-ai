# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 4: RAII와 자동 리소스 관리

## 서론: 리소스의 개념을 다시 생각해보자

**리소스(Resource)**이란 무엇일까?

보통 프로그래머들이 생각하는 리소스은 메모리뿐이다. 하지만 실은 그 이상이다:

- **메모리**: 힙에 할당한 데이터
- **파일 핸들**: 열어둔 파일
- **데이터베이스 커넥션**: 데이터베이스와의 연결
- **스레드**: 실행 중인 스레드
- **뮤텍스 잠금**: 획득한 락
- **네트워크 소켓**: 열어둔 소켓
- **임시 메모리 버퍼**: 임시 할당한 버퍼

이 모든 것들은 한 가지 공통점이 있다: **획득되어야 하고, 반드시 반환되어야 한다**라는 것이다.

C++98 시대에는 개발자가 이 모든 것을 수동으로 관리했다:

```cpp
// C++98 방식: 수동 리소스 관리의 악몽
FILE* file = fopen("data.txt", "r");
if (!file) return;

char buffer[1024];
if (fread(buffer, 1, 1024, file) < 0) {
    fclose(file);  // 오류 경로에서 정리
    return;
}

processData(buffer);

if (someCondition) {
    fclose(file);
    return;  // 여러 종료 지점에서 정리
}

fclose(file);  // 정상 경로에서 정리
```

이 코드는 정상 동작할 수도 있다. 하지만 **개발자가 모든 경로에서 리소스을 정리하는 것을 기억해야 한다**는 것이 문제이다. 한 번의 실수, 한 번의 망각으로 리소스 누수가 발생한다.

**Modern C++은 이 문제를 근본적으로 해결했다.**

이 장에서는 **RAII(Resource Acquisition Is Initialization)**라는 C++의 가장 강력한 패턴을 배운다. 이 패턴이 있으면, 리소스 관리는 **자동**이 되고, **안전**해진다.
  
</br>  
  
## RAII 패턴의 완벽한 이해

### RAII란 무엇인가?
RAII는 C++의 생성자와 소멸자의 특성을 이용한 패턴이다:  

- **리소스 획득(Acquisition)**: 객체의 **생성자**에서 리소스을 획득한다
- **자동 해제(Release)**: 객체의 **소멸자**에서 리소스을 자동으로 반환한다
- **스코프 기반**: 객체의 생명주기가 리소스의 생명주기를 결정한다

### 핵심 원리: 객체의 생명주기 = 리소스의 생명주기

```cpp
class FileWrapper {
public:
    // 리소스 획득(Acquisition)
    explicit FileWrapper(const char* filename) {
        file = fopen(filename, "r");
        if (!file) {
            throw std::runtime_error("Failed to open file");
        }
        std::cout << "File opened: " << filename << std::endl;
    }
    
    // 리소스 해제(Release)
    ~FileWrapper() {
        if (file) {
            fclose(file);
            std::cout << "File closed" << std::endl;
            file = nullptr;
        }
    }
    
    FILE* get() { return file; }

private:
    FILE* file = nullptr;
};

int main() {
    {
        FileWrapper f("data.txt");  // 생성자: 파일 열기
        // 파일 사용
        fprintf(f.get(), "Hello");
    }  // 소멸자: 파일 자동 닫기
    
    return 0;
}

// 출력:
// File opened: data.txt
// File closed
```

이것이 RAII이다. 간단하면서도 강력하다:

1. 객체가 생성될 때 자동으로 리소스을 획득
2. 객체가 소멸될 때 자동으로 리소스을 해제
3. 개발자는 명시적 정리 코드를 작성할 필요가 없음

### RAII의 마법: 예외 안전성
RAII의 진정한 가치는 **예외 상황에서도 작동한다**는 것이다:

```cpp
void processFile() {
    FileWrapper f("data.txt");  // 파일 열기
    
    // 여기서 예외 발생!
    throw std::runtime_error("Something went wrong");
    
    // 도달하지 않는 코드
}

int main() {
    try {
        processFile();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}

// 출력:
// File closed  (예외가 발생했음에도 불구하고!)
// Error: Something went wrong
```

신기하지 않나요? 예외가 발생하면 정상적으로 실행되지 않는 코드가 있을 텐데, 파일이 어떻게 닫혔을까요?

답은 **C++의 스택 언와인딩(Stack Unwinding)** 메커니즘 때문이다. 예외가 발생하면, 현재 스코프의 모든 지역 객체의 소멸자가 역순으로 자동 호출된다. 따라서 FileWrapper의 소멸자가 실행되어 파일이 닫힌다.

**이것이 수동 관리 방식과의 근본적인 차이이다:**

```cpp
// C++98: 수동 관리 (위험)
void processFile() {
    FILE* file = fopen("data.txt", "r");
    
    // 예외 발생!
    throw std::runtime_error("Error");
    
    fclose(file);  // 도달하지 않음! 파일 누수!
}

// Modern C++: RAII (안전)
void processFile() {
    FileWrapper f("data.txt");
    
    // 예외 발생!
    throw std::runtime_error("Error");
    
    // 파일이 자동으로 정리됨
}
```

### RAII의 철학적 의미
RAII는 단순한 기술 패턴이 아니다. 이것은 **C++의 핵심 철학**이다:  

**"객체가 존재한다 = 객체의 불변성(Invariant)이 유지된다"**
 
FileWrapper 객체가 존재한다면, 파일이 제대로 열려 있다는 것이 보장된다. 파일이 닫힌 FileWrapper 객체는 존재할 수 없다.  

이것이 바로 **안전성**이다. 코드를 읽는 사람은 FileWrapper 객체를 보면 "아, 파일이 제대로 관리되고 있겠네"라고 확신할 수 있다.  
  
</br>   

## 생성자/소멸자 기반 리소스 관리

### 기본 패턴: 기본 리소스 관리

#### 예제 1: 동적 메모리 래퍼

```cpp
template<typename T>
class ArrayWrapper {
public:
    // 생성자: 리소스 획득
    explicit ArrayWrapper(size_t size) : size_(size) {
        data_ = new T[size_];
        std::cout << "Memory allocated: " << size << " elements" << std::endl;
    }
    
    // 소멸자: 리소스 해제
    ~ArrayWrapper() {
        delete[] data_;
        std::cout << "Memory deallocated" << std::endl;
    }
    
    // 접근 인터페이스
    T& operator[](size_t index) {
        if (index >= size_) {
            throw std::out_of_range("Index out of range");
        }
        return data_[index];
    }
    
    size_t size() const { return size_; }

private:
    T* data_;
    size_t size_;
};

int main() {
    {
        ArrayWrapper<int> arr(10);
        arr[0] = 42;
        std::cout << arr[0] << std::endl;
    }  // 자동으로 메모리 해제
    
    return 0;
}

// 출력:
// Memory allocated: 10 elements
// 42
// Memory deallocated
```

#### 예제 2: 데이터베이스 커넥션

```cpp
class DatabaseConnection {
public:
    explicit DatabaseConnection(const std::string& host) : host_(host) {
        // 데이터베이스 연결 시뮬레이션
        connected_ = true;
        std::cout << "Connected to " << host << std::endl;
    }
    
    ~DatabaseConnection() {
        if (connected_) {
            // 데이터베이스 연결 종료
            connected_ = false;
            std::cout << "Disconnected from " << host_ << std::endl;
        }
    }
    
    void executeQuery(const std::string& query) {
        if (!connected_) {
            throw std::runtime_error("Not connected to database");
        }
        std::cout << "Executing: " << query << std::endl;
    }
    
    bool isConnected() const { return connected_; }

private:
    std::string host_;
    bool connected_ = false;
};

int main() {
    try {
        DatabaseConnection db("localhost:5432");
        db.executeQuery("SELECT * FROM users");
        
        // 의도적으로 오류 발생
        throw std::runtime_error("Query failed");
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
    }
    
    return 0;
}

// 출력:
// Connected to localhost:5432
// Executing: SELECT * FROM users
// Exception: Query failed
// Disconnected from localhost:5432  (자동!)
```

### 고급 패턴: 복잡한 리소스 관리

#### 패턴 1: 여러 리소스을 관리하는 클래스

```cpp
class GraphicsBuffer {
public:
    explicit GraphicsBuffer(size_t width, size_t height)
        : width_(width), height_(height), pixelBuffer_(nullptr), 
          gpuHandle_(0) {
        
        // 시스템 메모리 할당
        pixelBuffer_ = new uint32_t[width * height];
        if (!pixelBuffer_) {
            throw std::bad_alloc();
        }
        std::cout << "Pixel buffer allocated\n";
        
        try {
            // GPU 메모리 할당
            gpuHandle_ = allocateGPUMemory(width, height);
            std::cout << "GPU memory allocated: handle=" << gpuHandle_ << "\n";
        } catch (...) {
            // GPU 할당 실패 시 이미 할당한 메모리 정리
            delete[] pixelBuffer_;
            pixelBuffer_ = nullptr;
            throw;
        }
    }
    
    ~GraphicsBuffer() {
        // 역순으로 리소스 정리
        if (gpuHandle_ != 0) {
            deallocateGPUMemory(gpuHandle_);
            std::cout << "GPU memory deallocated\n";
        }
        
        if (pixelBuffer_) {
            delete[] pixelBuffer_;
            std::cout << "Pixel buffer deallocated\n";
        }
    }
    
    void setPixel(size_t x, size_t y, uint32_t color) {
        if (x >= width_ || y >= height_) {
            throw std::out_of_range("Pixel out of bounds");
        }
        pixelBuffer_[y * width_ + x] = color;
    }
    
    void syncToGPU() {
        if (gpuHandle_ == 0) {
            throw std::runtime_error("GPU memory not allocated");
        }
        std::cout << "Syncing buffer to GPU...\n";
    }

private:
    uint32_t allocateGPUMemory(size_t w, size_t h) {
        // 실제로는 GPU 할당
        return static_cast<uint32_t>(w * h);
    }
    
    void deallocateGPUMemory(uint32_t handle) {
        std::cout << "GPU memory being freed\n";
    }
    
    size_t width_;
    size_t height_;
    uint32_t* pixelBuffer_;
    uint32_t gpuHandle_;
};

int main() {
    try {
        GraphicsBuffer buffer(1920, 1080);
        buffer.setPixel(100, 100, 0xFF0000);
        buffer.syncToGPU();
        
        // 함수 종료 시 두 리소스 모두 정리됨
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}

// 출력:
// Pixel buffer allocated
// GPU memory allocated: handle=2073600
// Syncing buffer to GPU...
// GPU memory deallocated
// Pixel buffer deallocated
```

#### 패턴 2: 임시 리소스 관리 (RAII Guard)

```cpp
class MutexLock {
public:
    explicit MutexLock(std::mutex& m) : mutex_(m), locked_(false) {
        mutex_.lock();
        locked_ = true;
        std::cout << "Lock acquired\n";
    }
    
    ~MutexLock() {
        if (locked_) {
            mutex_.unlock();
            locked_ = false;
            std::cout << "Lock released\n";
        }
    }
    
    // 복사 금지
    MutexLock(const MutexLock&) = delete;
    MutexLock& operator=(const MutexLock&) = delete;
    
    // 이동만 허용
    MutexLock(MutexLock&& other) noexcept 
        : mutex_(other.mutex_), locked_(other.locked_) {
        other.locked_ = false;
    }

private:
    std::mutex& mutex_;
    bool locked_;
};

int main() {
    std::mutex mtx;
    
    {
        MutexLock lock(mtx);  // 잠금 획득
        std::cout << "Critical section\n";
    }  // 잠금 자동 해제
    
    return 0;
}

// 출력:
// Lock acquired
// Critical section
// Lock released
```

### 완벽한 RAII 구현: 체크리스트
좋은 RAII 클래스를 만들기 위한 체크리스트:

```cpp
class ProperRAII {
public:
    // ✓ 1. 생성자에서 리소스 획득
    explicit ProperRAII(const std::string& resource) {
        acquire(resource);
    }
    
    // ✓ 2. 소멸자에서 리소스 해제 (virtual은 필요시에만)
    ~ProperRAII() {
        release();
    }
    
    // ✓ 3. 예외 안전성 보장
    //   - 생성자에서 예외 발생 시 부분 할당된 리소스 정리
    //   - 소멸자는 noexcept
    
    // ✓ 4. 복사 금지 (또는 깊은 복사 구현)
    ProperRAII(const ProperRAII&) = delete;
    ProperRAII& operator=(const ProperRAII&) = delete;
    
    // ✓ 5. 이동 의미론 구현
    ProperRAII(ProperRAII&& other) noexcept 
        : resource_(other.resource_) {
        other.resource_ = nullptr;
    }
    
    ProperRAII& operator=(ProperRAII&& other) noexcept {
        if (this != &other) {
            release();
            resource_ = other.resource_;
            other.resource_ = nullptr;
        }
        return *this;
    }
    
    // ✓ 6. get() 메서드로 기본 리소스에 접근
    auto* get() { return resource_; }
    auto* get() const { return resource_; }

private:
    void acquire(const std::string& name) {
        // 실제 리소스 획득 로직
    }
    
    void release() noexcept {  // 소멸자에서 호출되므로 noexcept
        // 실제 리소스 해제 로직
    }
    
    void* resource_ = nullptr;
};
```
  
</br>  
  

## 예외 상황에서도 안전한 리소스 해제

### 문제: 예외 발생 시 부분 초기화
리소스가 여러 개일 때, 일부 획득 후 나머지 획득 중에 예외가 발생할 수 있다:  

```cpp
// Bad: 부분 초기화 위험
class BadResource {
public:
    explicit BadResource(bool throwOnGPU = false) {
        // 첫 번째 리소스 획득 성공
        cpuBuffer = new uint32_t[1000];
        std::cout << "CPU buffer allocated\n";
        
        // 두 번째 리소스 획득 실패
        if (throwOnGPU) {
            throw std::runtime_error("GPU allocation failed");
        }
        gpuBuffer = new uint32_t[1000];
        std::cout << "GPU buffer allocated\n";
    }
    
    ~BadResource() {
        // cpuBuffer는 정리되지만, gpuBuffer는?
        delete[] cpuBuffer;
        std::cout << "CPU buffer deallocated\n";
    }
    
private:
    uint32_t* cpuBuffer = nullptr;
    uint32_t* gpuBuffer = nullptr;  // 누수!
};

int main() {
    try {
        BadResource resource(true);  // GPU 할당에서 실패
    } catch (const std::exception& e) {
        std::cout << "Error: " << e.what() << "\n";
    }
    return 0;
}

// 출력:
// CPU buffer allocated
// Error: GPU allocation failed
// (프로그램 종료)
// GPU buffer 정리되지 않음! 메모리 누수!
```

### 해결책 1: 함수 try-catch

```cpp
// Good: 생성자 try-catch
class SafeResource {
public:
    explicit SafeResource(bool throwOnGPU = false)
    try : cpuBuffer(nullptr), gpuBuffer(nullptr) {
        cpuBuffer = new uint32_t[1000];
        std::cout << "CPU buffer allocated\n";
        
        if (throwOnGPU) {
            throw std::runtime_error("GPU allocation failed");
        }
        gpuBuffer = new uint32_t[1000];
        std::cout << "GPU buffer allocated\n";
    }
    catch (...) {
        // 생성자 본문에서 예외 발생 시 호출됨
        std::cout << "Exception in constructor, cleaning up...\n";
        delete[] cpuBuffer;
        cpuBuffer = nullptr;
        delete[] gpuBuffer;
        gpuBuffer = nullptr;
        throw;  // 예외 재전파
    }
    
    ~SafeResource() {
        delete[] cpuBuffer;
        delete[] gpuBuffer;
    }

private:
    uint32_t* cpuBuffer;
    uint32_t* gpuBuffer;
};

int main() {
    try {
        SafeResource resource(true);
    } catch (const std::exception& e) {
        std::cout << "Caught: " << e.what() << "\n";
    }
    return 0;
}

// 출력:
// CPU buffer allocated
// Exception in constructor, cleaning up...
// Caught: GPU allocation failed
// 두 리소스 모두 정리됨!
```

### 해결책 2: RAII로 RAII 구성 (Composition)

```cpp
// Best: 작은 RAII 클래스들을 합성
class CPUBuffer {
public:
    explicit CPUBuffer(size_t size) {
        data = new uint32_t[size];
        std::cout << "CPU buffer allocated\n";
    }
    ~CPUBuffer() {
        delete[] data;
        std::cout << "CPU buffer deallocated\n";
    }
    uint32_t* data;
};

class GPUBuffer {
public:
    explicit GPUBuffer(size_t size, bool shouldThrow = false) {
        if (shouldThrow) {
            throw std::runtime_error("GPU allocation failed");
        }
        data = new uint32_t[size];
        std::cout << "GPU buffer allocated\n";
    }
    ~GPUBuffer() {
        delete[] data;
        std::cout << "GPU buffer deallocated\n";
    }
    uint32_t* data;
};

class ComposedResource {
public:
    explicit ComposedResource(bool throwOnGPU = false)
        : cpu(1000), gpu(1000, throwOnGPU) {
        // CPUBuffer와 GPUBuffer가 자동으로 순서대로 생성됨
        // GPUBuffer 생성 중 예외 발생 시, CPUBuffer의 소멸자가 자동 호출됨
    }
    
    // 소멸자는 멤버 소멸자를 자동 호출 (역순)
    ~ComposedResource() = default;

private:
    CPUBuffer cpu;    // 먼저 생성, 나중에 소멸
    GPUBuffer gpu;    // 나중에 생성, 먼저 소멸
};

int main() {
    try {
        ComposedResource resource(true);
    } catch (const std::exception& e) {
        std::cout << "Error: " << e.what() << "\n";
    }
    return 0;
}

// 출력:
// CPU buffer allocated
// GPU allocation failed
// CPU buffer deallocated  (자동!)
// Error: GPU allocation failed
```

**이것이 가장 우아한 방식이다.** 각 클래스는 단일 책임만 가지고, 예외가 발생하면 자동으로 모든 부분 구성 요소가 정리된다.  

### 예외와 소멸자

**매우 중요한 규칙: 소멸자에서 예외를 발생시키지 말 것**

```cpp
// ❌ Bad: 소멸자에서 예외 발생
class BadDestructor {
    ~BadDestructor() {
        throw std::runtime_error("Error in destructor");
        // 이미 예외 처리 중에 다른 예외가 발생하면
        // std::terminate()가 호출되어 프로그램 강제 종료!
    }
};

// ✓ Good: 소멸자는 noexcept
class GoodDestructor {
    ~GoodDestructor() noexcept {
        try {
            // 리소스 정리
        } catch (...) {
            // 조용히 무시 또는 로깅
            std::cerr << "Error during cleanup\n";
        }
    }
};
```
  
</br>  
  

## Custom Deleter와 특수 리소스 관리

### 문제: 다양한 리소스 해제 방식
다른 리소스들은 다른 방식으로 해제해야 한다:

```cpp
// 다양한 리소스 해제 방식들
int* ptr1 = new int;           // delete로 해제
int* ptr2 = new int[100];      // delete[]로 해제
FILE* file = fopen("f", "r");  // fclose()로 해제
void* mem = malloc(100);       // free()로 해제
```

### 해결책: Custom Deleter 클래스

```cpp
// 파일 핸들용 deleter
struct FileDeleter {
    void operator()(FILE* file) const {
        if (file) {
            fclose(file);
            std::cout << "File closed\n";
        }
    }
};

// 메모리 해제용 deleter
struct MallocDeleter {
    void operator()(void* ptr) const {
        if (ptr) {
            free(ptr);
            std::cout << "Memory freed\n";
        }
    }
};

// 배열 요소 하나하나 정리해야 할 때
struct ArrayElementDeleter {
    void operator()(int* arr) const {
        if (arr) {
            // 각 요소 정리 (예: 파괴자 호출)
            delete[] arr;
            std::cout << "Array deleted\n";
        }
    }
};

int main() {
    // 파일 자동 관리
    {
        std::unique_ptr<FILE, FileDeleter> file(
            fopen("data.txt", "r"));
        if (file) {
            std::cout << "File opened\n";
        }
    }  // 자동으로 fclose() 호출됨
    
    // malloc 메모리 자동 관리
    {
        std::unique_ptr<void, MallocDeleter> mem(malloc(1024));
        if (mem) {
            std::cout << "Memory allocated\n";
        }
    }  // 자동으로 free() 호출됨
    
    return 0;
}

// 출력:
// File opened
// File closed
// Memory allocated
// Memory freed
```

### Deleter 람다 활용
C++11 이후에는 람다를 deleter로 사용할 수 있다:

```cpp
int main() {
    // 람다로 정의한 파일 핸들 관리
    auto fileDeleter = [](FILE* f) {
        if (f) {
            fclose(f);
            std::cout << "File cleaned up\n";
        }
    };
    
    {
        std::unique_ptr<FILE, decltype(fileDeleter)> file(
            fopen("data.txt", "r"),
            fileDeleter);
        
        if (file) {
            std::cout << "Working with file\n";
        }
    }  // 람다 deleter 호출
    
    // 더 간단한 방식: std::function 사용
    {
        std::unique_ptr<int, std::function<void(int*)>> ptr(
            new int(42),
            [](int* p) {
                std::cout << "Deleting: " << *p << "\n";
                delete p;
            });
    }
    
    return 0;
}

// 출력:
// Working with file
// File cleaned up
// Deleting: 42
```

### 실전 예제: 리소스 풀 관리

```cpp
class ConnectionPool {
public:
    explicit ConnectionPool(size_t size) : size_(size), connections_(size) {
        for (size_t i = 0; i < size; ++i) {
            connections_[i] = nullptr;
        }
        std::cout << "Connection pool created with size " << size << "\n";
    }
    
    ~ConnectionPool() {
        for (auto* conn : connections_) {
            if (conn) {
                // custom deleter를 통해 연결 정리
                closeConnection(conn);
            }
        }
        std::cout << "Connection pool destroyed\n";
    }
    
    // Connection을 자동으로 정리하는 방식으로 반환
    std::unique_ptr<Connection, std::function<void(Connection*)>> 
    acquireConnection() {
        for (auto*& conn : connections_) {
            if (conn == nullptr) {
                conn = createConnection();
                
                auto deleter = [this, &conn](Connection* c) {
                    if (c == conn) {
                        conn = nullptr;  // 풀로 반환
                    }
                };
                
                return std::unique_ptr<Connection, 
                    std::function<void(Connection*)>>(conn, deleter);
            }
        }
        throw std::runtime_error("No available connections");
    }

private:
    Connection* createConnection() {
        std::cout << "Creating connection\n";
        return new Connection();
    }
    
    void closeConnection(Connection* conn) {
        std::cout << "Closing connection\n";
        delete conn;
    }
    
    struct Connection {};
    
    size_t size_;
    std::vector<Connection*> connections_;
};

int main() {
    {
        ConnectionPool pool(3);
        
        {
            auto conn1 = pool.acquireConnection();
            auto conn2 = pool.acquireConnection();
            
            std::cout << "Using connections...\n";
        }  // 연결 자동 반환
        
        std::cout << "Pool cleanup...\n";
    }  // 남은 연결 정리
    
    return 0;
}

// 출력:
// Connection pool created with size 3
// Creating connection
// Creating connection
// Using connections...
// Pool cleanup...
// Closing connection
// Closing connection
// Connection pool destroyed
```
  
</br>  
  

## Modern C++에서의 RAII: 정리

### RAII 규칙 요약

| 규칙 | 설명 |
|------|------|
| **Acquire in Constructor** | 생성자에서 리소스 획득 |
| **Release in Destructor** | 소멸자에서 리소스 해제 |
| **Scope-Based Lifetime** | 객체의 스코프가 리소스의 수명 결정 |
| **Exception Safety** | 예외 발생 시에도 정리 보장 |
| **No Manual Cleanup** | 명시적 정리 코드 불필요 |

### RAII의 이점

```cpp
// 1. 자동 정리 (수동 정리 불필요)
void example1() {
    FileWrapper f("data.txt");
    // 자동 정리, 명시적 close() 호출 불필요
}

// 2. 예외 안전성
void example2() {
    FileWrapper f("data.txt");
    throw std::runtime_error("Error");
    // 파일이 정상적으로 닫힘
}

// 3. 리소스 누수 방지
void example3() {
    {
        ArrayWrapper<int> arr(100);
        // 스코프 종료 시 메모리 자동 해제
    }
    // 메모리 누수 없음
}

// 4. 명확한 소유권
void example4() {
    std::unique_ptr<Resource> res = createResource();
    // res가 리소스의 유일한 소유자임이 명확
}
```

### C++ Core Guidelines와 RAII

```cpp
// Rule R.1: 리소스은 자동으로 관리하라
std::unique_ptr<Widget> createWidget();  // Good

// Rule R.2: 생성자에서만 리소스을 획득하고 소멸자에서만 해제하라
class Widget {
public:
    Widget() { acquire(); }      // ✓
    ~Widget() { release(); }     // ✓
    void manual_acquire() {}     // ✗
    void manual_release() {}     // ✗
};

// Rule R.11: new/delete 명시 호출을 피하라
auto ptr = new Widget();         // ✗
auto ptr = std::make_unique<Widget>();  // ✓
```
  
</br>  


## 실제 시나리오: RAII를 활용한 안전한 프로그래밍

### 시나리오: 트랜잭션 관리

```cpp
class Transaction {
public:
    explicit Transaction(Database& db) : db_(db), committed_(false) {
        db_.beginTransaction();
        std::cout << "Transaction started\n";
    }
    
    ~Transaction() {
        if (!committed_) {
            db_.rollback();
            std::cout << "Transaction rolled back\n";
        }
    }
    
    void execute(const std::string& query) {
        db_.execute(query);
    }
    
    void commit() {
        db_.commit();
        committed_ = true;
        std::cout << "Transaction committed\n";
    }
    
    // 복사 금지
    Transaction(const Transaction&) = delete;
    Transaction& operator=(const Transaction&) = delete;

private:
    Database& db_;
    bool committed_;
};

int main() {
    Database db;
    
    try {
        {
            Transaction txn(db);
            txn.execute("INSERT ...");
            txn.execute("UPDATE ...");
            
            // 예외 발생!
            throw std::runtime_error("Error");
            
            txn.commit();  // 도달하지 않음
        }  // 트랜잭션 자동 롤백
    } catch (const std::exception& e) {
        std::cout << "Error: " << e.what() << "\n";
    }
    
    return 0;
}

// 출력:
// Transaction started
// Error: Error
// Transaction rolled back
```
  

## 마무리: RAII는 단순하지만 강력하다
RAII는 C++의 가장 강력한 패턴이다. 단순한 원리:

1. **객체 생성** = 리소스 획득
2. **객체 소멸** = 리소스 해제
3. **스코프** = 리소스 생명주기

이 세 가지 원리만으로도:
- 메모리 누수 제거
- 예외 안전성 보장
- 자동 정리
- 명확한 코드

가 모두 달성된다.  

**Modern C++을 처음 배울 때 가장 어려운 개념이 RAII이다. 하지만 한 번 이해하면, C++의 진정한 아름다움을 느끼게 된다.**

이것이 바로 **Rust가 제공하려는 안전성을 C++도 제공할 수 있는 이유**이다. Rust는 컴파일러가 리소스 관리를 강제하지만, Modern C++은 개발자가 RAII 패턴을 따르도록 권장한다.

다음 장에서는 RAII 위에 구축된 **스마트 포인터**를 살펴본다. 이것이 메모리 안전성의 최종 형태이다.  