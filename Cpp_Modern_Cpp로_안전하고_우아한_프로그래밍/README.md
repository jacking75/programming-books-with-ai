# Modern C++로 안전하고 우아한 프로그래밍  
  
    
# 목차

### 1부: Modern C++의 새로운 패러다임

**Chapter 1: C++의 진화와 안전성의 혁명**
- C++98부터 C++23까지의 발전사
- "C++은 위험하다"는 오해와 진실
- Modern C++이 바꾼 프로그래밍 패러다임
- Rust vs C++: 공정한 비교를 위한 기준점

**Chapter 2: 개발환경 구축과 도구 활용**
- Visual Studio 2022 최적 설정
- C++ Core Guidelines 통합과 정적 분석
- Sanitizer와 디버깅 도구 활용
- 코드 품질 관리 자동화

**Chapter 3: C++ Core Guidelines의 철학과 실천**
- Guidelines의 핵심 원칙 이해
- 자동화된 검증 도구 활용
- 실제 프로젝트 적용 사례
- 팀 개발에서의 Guidelines 도입 전략

### 2부: 메모리 안전성 - 더 이상 메모리 누수를 걱정하지 마세요

**Chapter 4: RAII와 자동 자원 관리**
- RAII 패턴의 완벽한 이해
- 생성자/소멸자 기반 자원 관리
- 예외 상황에서도 안전한 자원 해제
- custom deleter와 특수 자원 관리

**Chapter 5: 스마트 포인터로 완성하는 메모리 안전성**
- unique_ptr의 완벽 활용법
- shared_ptr과 참조 카운팅 전략
- weak_ptr로 순환 참조 해결
- 성능 최적화와 안전성의 균형

**Chapter 6: 컨테이너와 알고리즘의 안전한 사용**
- STL 컨테이너의 메모리 안전 보장
- 범위 기반 for문과 안전한 순회
- 알고리즘 라이브러리 활용한 버그 방지
- C++20 ranges로 더욱 안전한 데이터 처리

### 3부: 타입 안전성 - 컴파일 타임에 잡는 모든 오류

**Chapter 7: 강타입 시스템과 타입 추론**
- auto와 decltype의 현명한 사용
- 타입 추론으로 줄이는 실수
- 명시적 타입 변환 vs 암시적 변환
- concepts로 강화하는 타입 제약

**Chapter 8: 열거형과 상수의 안전한 관리**
- enum class의 완벽 활용
- constexpr과 compile-time 계산
- 타입 안전한 상수 관리 패턴
- 매직 넘버 제거 전략

**Chapter 9: 템플릿 메타프로그래밍과 컴파일 타임 검증**
- SFINAE를 넘어선 concepts 활용
- 컴파일 타임 타입 검증
- 템플릿 특화와 안전성 보장
- consteval과 즉시 함수

### 4부: 예외와 오류 처리 - 견고한 프로그램 만들기

**Chapter 10: 예외 안전성의 3단계**
- Basic, Strong, No-throw 보장 이해
- RAII와 예외의 완벽한 조화
- 예외 중립적 코드 작성법
- std::optional과 오류 처리 패턴

**Chapter 11: Modern C++의 오류 처리 전략**
- std::expected (C++23)와 함수형 오류 처리
- 결과 타입 패턴 구현
- 예외 vs 오류 코드: 적재적소 활용법
- 오류 전파와 변환 패턴

### 5부: 동시성과 병렬성 - 안전한 멀티스레드 프로그래밍

**Chapter 12: Modern C++ 동시성 기초**
- std::thread와 RAII 기반 스레드 관리
- mutex, lock_guard, unique_lock 완벽 활용
- 데드락 방지 전략과 패턴
- atomic 연산과 메모리 모델

**Chapter 13: 고급 동시성 패턴**
- std::future와 std::promise 활용
- 비동기 프로그래밍 패턴
- 스레드 풀과 작업 큐 구현
- C++20 coroutines 입문

**Chapter 14: 병렬 알고리즘과 성능 최적화**
- std::execution 정책 활용
- 병렬 STL 알고리즘 완전 정복
- SIMD와 벡터화 최적화
- 성능 측정과 프로파일링

### 6부: 실전 프로젝트 - 안전하고 효율적인 C++ 애플리케이션

**Chapter 15: 네트워크 프로그래밍 프로젝트**
- asio 라이브러리를 활용한 안전한 네트워크 코드
- 비동기 I/O와 예외 처리
- 리소스 관리와 성능 최적화
- 실제 서버 애플리케이션 구현

**Chapter 16: 게임 엔진 컴포넌트 개발**
- 메모리 풀과 커스텀 할당자
- ECS 패턴 구현
- 실시간 시스템에서의 안전성 보장
- 성능 크리티컬 코드의 최적화

**Chapter 17: 크로스 플랫폼 라이브러리 설계**
- 헤더 온리 라이브러리 설계 패턴
- ABI 안정성과 인터페이스 설계
- 패키지 관리와 의존성 처리
- 테스트 자동화와 CI/CD 통합

### 7부: 벤치마킹과 비교 - C++의 진짜 실력

**Chapter 18: 성능 벤치마킹과 최적화**
- 마이크로 벤치마킹 기법
- 메모리 사용량 최적화
- 컴파일러 최적화 활용법
- 프로파일링 기반 성능 튜닝

**Chapter 19: Rust와의 공정한 비교**
- 동일 문제에 대한 C++/Rust 구현 비교
- 메모리 안전성 보장 방식 비교
- 성능과 안전성의 트레이드오프 분석
- 각 언어의 장단점과 적용 영역

**Chapter 20: 미래의 C++ - 더 안전하고 쉬워지는 C++**
- C++26 이후 로드맵
- 안전성 강화 방향성
- 새로운 라이브러리와 도구들
- C++ 커뮤니티와 생태계 발전

-----  
   