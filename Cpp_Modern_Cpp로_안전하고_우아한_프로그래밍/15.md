# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 15: 네트워크 프로그래밍 프로젝트

## 소개
네트워크 프로그래밍은 전통적으로 C++에서 가장 복잡하고 위험한 영역으로 여겨져왔다. 수동 메모리 관리, 소켓 핸들의 정리, 비동기 I/O의 복잡성, 그리고 에러 처리의 어려움이 모두 얽혀 있었기 때문이다. 그러나 Modern C++과 ASIO 라이브러리를 활용하면, 이 모든 문제를 우아하게 해결할 수 있다.

Chapter 15는 실무에서 실제로 사용할 수 있는 네트워크 프로그래밍을 다룬다. 우리가 지금까지 배운 RAII, 스마트 포인터, 예외 처리, 그리고 동시성 기법들이 모두 조화롭게 어떻게 작동하는지 보게 될 것이다. ASIO 라이브러리는 Boost.Asio이거나 standalone 버전이거나, C++의 철학에 완벽하게 부합하는 도구다.

이 장을 마치면, 학생들은 안전하고 효율적인 네트워크 서버를 구축할 수 있을 것이다. 메모리 누수 없이, 데드락 없이, 그리고 예측 불가능한 크래시 없이.



## 1. ASIO 라이브러리의 기초와 안전한 설정

### 1.1 ASIO란 무엇인가?
ASIO(Asynchronous I/O)는 비동기 입출력을 다루기 위한 C++ 라이브러리다. 원래 Boost.Asio로 시작했으며, 이제는 독립적인 버전도 있다. ASIO의 핵심 특징은:

- **비동기 I/O**: 작업이 완료될 때까지 기다리지 않는다.
- **포로토콜 독립적**: TCP, UDP, 또는 커스텀 프로토콜을 지원한다.
- **타이머와 신호**: 타임아웃과 OS 신호를 안전하게 처리한다.
- **안전한 리소스 관리**: RAII 원칙을 따른다.

### 1.2 ASIO 설치 및 기본 설정
Visual Studio 2022에서 ASIO를 사용하려면:

1. **Vcpkg를 이용한 설치**:
```bash
vcpkg install asio:x64-windows
```

2. **프로젝트 설정**:
   - 프로젝트 속성 → VC++ 디렉토리 → 포함 디렉토리에 ASIO 경로 추가
   - 또는 단일 헤더 버전 사용

3. **기본 헤더 파일**:
```cpp
#include <asio.hpp>  // 또는 <boost/asio.hpp>

// 편의를 위해 별칭 정의
namespace asio = boost::asio;
```

### 1.3 첫 번째 프로그램: 간단한 에코 서버
ASIO를 처음 배울 때 가장 좋은 방법은 간단한 에코 서버를 만드는 것이다.

```cpp
#include <iostream>
#include <asio.hpp>
#include <memory>
#include <string>

namespace asio = boost::asio;

// 이 프로그램의 목적: 클라이언트로부터 데이터를 받아서 그대로 돌려보내는
// 간단한 에코 서버를 구현한다. RAII 원칙을 따르고 안전한 메모리 관리를 한다.

// 각 연결을 나타내는 세션 클래스
class EchoSession : public std::enable_shared_from_this<EchoSession> {
public:
    using socket_type = asio::ip::tcp::socket;
    
    // 팩토리 함수: 새로운 세션을 생성한다
    static std::shared_ptr<EchoSession> create(
        asio::io_context& io_context) {
        return std::shared_ptr<EchoSession>(
            new EchoSession(io_context));
    }
    
    // 소켓을 얻는다
    socket_type::lowest_layer_type& socket() {
        return socket_.lowest_layer();
    }
    
    // 비동기 읽기 작업을 시작한다
    void start() {
        async_read();
    }
    
private:
    EchoSession(asio::io_context& io_context)
        : socket_(io_context) {
    }
    
    // 비동기 읽기 작업
    void async_read() {
        auto self(shared_from_this());
        
        asio::async_read(
            socket_,
            asio::buffer(buffer_),
            [this, self](const asio::error_code& ec, std::size_t length) {
                if (!ec) {
                    // 데이터를 받았으므로, 그대로 돌려보낸다
                    async_write(length);
                } else {
                    std::cerr << "읽기 오류: " << ec.message() << "\n";
                }
            }
        );
    }
    
    // 비동기 쓰기 작업
    void async_write(std::size_t length) {
        auto self(shared_from_this());
        
        asio::async_write(
            socket_,
            asio::buffer(buffer_, length),
            [this, self](const asio::error_code& ec, std::size_t) {
                if (!ec) {
                    // 쓰기가 완료되면, 다시 읽기를 시작한다
                    async_read();
                } else {
                    std::cerr << "쓰기 오류: " << ec.message() << "\n";
                }
            }
        );
    }
    
    asio::ip::tcp::socket socket_;
    std::array<char, 1024> buffer_;
};

// 에코 서버 클래스
class EchoServer {
public:
    EchoServer(asio::io_context& io_context, unsigned short port)
        : acceptor_(io_context,
                    asio::ip::tcp::endpoint(
                        asio::ip::tcp::v4(), port)) {
        start_accept();
    }
    
private:
    void start_accept() {
        auto new_session =
            EchoSession::create(acceptor_.get_executor().context());
        
        acceptor_.async_accept(
            new_session->socket(),
            [this, new_session](const asio::error_code& ec) {
                if (!ec) {
                    std::cout << "새로운 연결 수락\n";
                    new_session->start();
                } else {
                    std::cerr << "수락 오류: " << ec.message() << "\n";
                }
                
                start_accept();
            }
        );
    }
    
    asio::ip::tcp::acceptor acceptor_;
};

int main() {
    try {
        asio::io_context io_context;
        
        // 포트 9999에서 에코 서버를 시작한다
        EchoServer server(io_context, 9999);
        
        std::cout << "에코 서버 시작 (포트 9999)...\n";
        std::cout << "종료하려면 Ctrl+C를 누르세요.\n";
        
        io_context.run();
    } catch (std::exception& e) {
        std::cerr << "예외: " << e.what() << "\n";
    }
    
    return 0;
}
```

이 코드의 설계를 자세히 설명하면:

**EchoSession 클래스의 역할**: 각 클라이언트 연결을 나타낸다. `std::enable_shared_from_this`를 상속받아서, 람다 함수에서 자신을 `shared_ptr`로 참조할 수 있게 한다. 이는 비동기 작업 중에 객체가 소멸하지 않도록 보장한다.

**RAII 원칙의 적용**: `socket_`은 EchoSession이 생성될 때 생성되고, 소멸될 때 자동으로 정리된다. 명시적인 close 호출이 필요 없다.

**비동기 작업 흐름**: `start()` → `async_read()` → 데이터 수신 → `async_write()` → 데이터 송신 → `async_read()` → 반복

**에러 처리**: 모든 비동기 연산에서 `asio::error_code`를 확인한다. 이는 예외보다 비동기 컨텍스트에서 더 적합하다.

### 1.4 안전한 메모리 관리: shared_ptr의 활용
ASIO에서 `shared_ptr`이 중요한 이유를 이해해보자.

```cpp
// 위험한 패턴 (사용하지 말 것)
class UnsafeSession {
private:
    UnsafeSession* self_;  // 위험!
    
public:
    void start() {
        // 람다가 'this'를 캡처했을 때, 세션이 소멸되면
        // 람다 실행 중에 메모리 접근 위반이 발생한다
        asio::async_read(socket_, asio::buffer(buffer_),
            [this](const asio::error_code& ec, std::size_t length) {
                // 여기서 'this'가 유효한가? 보장이 없다!
            }
        );
    }
};

// 안전한 패턴 (올바른 방법)
class SafeSession : public std::enable_shared_from_this<SafeSession> {
public:
    void start() {
        // shared_from_this()는 이 객체를 가리키는 shared_ptr을 반환한다
        auto self = shared_from_this();
        
        asio::async_read(socket_, asio::buffer(buffer_),
            [this, self](const asio::error_code& ec, std::size_t length) {
                // self가 람다를 캡처했으므로, 람다가 실행되는 동안
                // 이 객체는 소멸하지 않는다!
            }
        );
    }
};
```

`std::enable_shared_from_this`를 사용하면:

1. 이 클래스에서 생성한 `shared_ptr`을 추적한다.
2. `shared_from_this()`를 호출하면 현재 객체를 가리키는 `shared_ptr`을 얻을 수 있다.
3. 람다가 이 `shared_ptr`을 캡처하면, 람다가 실행되는 동안 객체가 유지된다.

이는 메모리 안전성을 자동으로 보장한다.

  

## 2. 비동기 I/O와 예외 처리

### 2.1 비동기 작업의 특성과 에러 처리
비동기 I/O는 순차적 I/O와 근본적으로 다르다.

```cpp
#include <iostream>
#include <asio.hpp>
#include <memory>

namespace asio = boost::asio;

// 순차적 I/O의 예
void synchronous_example() {
    try {
        asio::io_context io_context;
        asio::ip::tcp::socket socket(io_context);
        
        asio::ip::tcp::endpoint endpoint(
            asio::ip::address::from_string("127.0.0.1"), 80);
        
        // 이 호출은 연결이 완료될 때까지 블로킹된다
        socket.connect(endpoint);  // 예외를 던질 수 있다
        
        std::cout << "연결 성공\n";
    } catch (const std::exception& e) {
        std::cerr << "오류: " << e.what() << "\n";
    }
}

// 비동기 I/O의 예
void asynchronous_example() {
    try {
        asio::io_context io_context;
        auto socket = std::make_shared<asio::ip::tcp::socket>(io_context);
        
        asio::ip::tcp::endpoint endpoint(
            asio::ip::address::from_string("127.0.0.1"), 80);
        
        // 이 호출은 즉시 반환된다
        socket->async_connect(endpoint,
            [socket](const asio::error_code& ec) {
                // 연결이 완료되면 (성공 또는 실패),
                // 이 람다가 나중에 호출된다
                if (ec) {
                    std::cerr << "연결 오류: " << ec.message() << "\n";
                } else {
                    std::cout << "연결 성공\n";
                }
            }
        );
        
        // 제어가 즉시 여기로 돌아온다
        std::cout << "연결 시도 중...\n";
        
        io_context.run();  // 비동기 작업이 완료될 때까지 실행된다
    } catch (const std::exception& e) {
        std::cerr << "예외: " << e.what() << "\n";
    }
}
```

비동기 I/O에서 주목할 점:

- **예외 vs 에러 코드**: 동기 작업에서는 예외를 던지지만, 비동기 작업에서는 콜백의 `asio::error_code` 파라미터로 에러를 전달한다.
- **순서 보장 없음**: 여러 비동기 작업을 시작하면, 완료되는 순서는 예측 불가능하다.
- **명시적 해제 필요**: 동기 작업처럼 `socket.close()`를 명시적으로 호출할 필요는 없지만, 원한다면 호출할 수 있다.

### 2.2 예외 안전한 비동기 작업 래퍼
비동기 작업을 더 안전하게 만들기 위해 래퍼를 만들 수 있다.

```cpp
#include <asio.hpp>
#include <memory>
#include <functional>
#include <optional>

namespace asio = boost::asio;

// 이 클래스의 목적: 비동기 작업 완료를 기다리는 동기 인터페이스를 제공한다.
// future와 유사하지만, ASIO와 통합된 방식이다.

template<typename Result>
class AsyncResult {
public:
    using callback_type = std::function<void(const asio::error_code&, Result)>;
    
    // 콜백을 등록한다
    void set_callback(callback_type cb) {
        callback_ = cb;
    }
    
    // 비동기 작업에서 호출되는 메서드
    void complete(const asio::error_code& ec, Result result) {
        error_ = ec;
        result_ = result;
        if (callback_) {
            callback_(ec, result);
        }
    }
    
    // 결과를 조회한다
    std::optional<Result> get_result() const {
        if (error_) {
            throw asio::system_error(error_);
        }
        return result_;
    }
    
    bool has_error() const {
        return static_cast<bool>(error_);
    }
    
    const asio::error_code& error() const {
        return error_;
    }
    
private:
    asio::error_code error_;
    Result result_;
    callback_type callback_;
};

// 사용 예제
void async_operation_example() {
    asio::io_context io_context;
    
    auto result = std::make_shared<AsyncResult<std::string>>();
    
    // 비동기 작업 시뮬레이션
    asio::post(io_context, [result]() {
        // 1초 후에 작업 완료
        std::this_thread::sleep_for(std::chrono::seconds(1));
        result->complete(asio::error_code(), "작업 완료");
    });
    
    result->set_callback([](const asio::error_code& ec, const std::string& msg) {
        if (!ec) {
            std::cout << "콜백: " << msg << "\n";
        }
    });
    
    io_context.run();
}
```

### 2.3 타임아웃 처리
네트워크 작업에서 타임아웃은 필수적이다.

```cpp
#include <asio.hpp>
#include <iostream>
#include <memory>

namespace asio = boost::asio;

// 이 프로그램의 목적: 타임아웃을 지정하고 시간 초과 시 작업을 취소한다.

class AsyncConnection {
public:
    AsyncConnection(asio::io_context& io_context)
        : socket_(io_context),
          timer_(io_context),
          operation_in_progress_(false) {
    }
    
    // 타임아웃을 지정하고 연결을 시도한다
    void connect_with_timeout(
        const asio::ip::tcp::endpoint& endpoint,
        std::chrono::milliseconds timeout) {
        
        operation_in_progress_ = true;
        
        // 타이머를 시작한다
        timer_.expires_from_now(timeout);
        timer_.async_wait([this](const asio::error_code& ec) {
            on_timeout(ec);
        });
        
        // 비동기 연결을 시도한다
        socket_.async_connect(endpoint,
            [this](const asio::error_code& ec) {
                on_connect(ec);
            }
        );
    }
    
    bool is_connected() const {
        return socket_.is_open();
    }
    
private:
    void on_timeout(const asio::error_code& ec) {
        if (ec == asio::error::operation_aborted) {
            // 타이머가 정상적으로 취소됨
            return;
        }
        
        if (operation_in_progress_) {
            std::cout << "연결 타임아웃\n";
            socket_.close();  // 연결 시도를 취소한다
            operation_in_progress_ = false;
        }
    }
    
    void on_connect(const asio::error_code& ec) {
        if (operation_in_progress_) {
            timer_.cancel();  // 타이머를 취소한다
            operation_in_progress_ = false;
            
            if (ec) {
                std::cout << "연결 오류: " << ec.message() << "\n";
            } else {
                std::cout << "연결 성공\n";
            }
        }
    }
    
    asio::ip::tcp::socket socket_;
    asio::deadline_timer timer_;
    bool operation_in_progress_;
};

void timeout_example() {
    asio::io_context io_context;
    
    AsyncConnection conn(io_context);
    
    asio::ip::tcp::endpoint endpoint(
        asio::ip::address::from_string("192.0.2.0"),  // 응답 불가능한 주소
        80
    );
    
    conn.connect_with_timeout(endpoint, std::chrono::seconds(3));
    
    io_context.run();
}
```

타임아웃 처리의 핵심:

1. **동시 작업**: 연결 시도와 타이머가 동시에 진행된다.
2. **레이스 조건 처리**: `operation_in_progress_` 플래그로 먼저 완료된 작업을 추적한다.
3. **정리**: 어느 쪽이 먼저 완료되든, 다른 쪽은 취소된다.



## 3. 리소스 관리와 성능 최적화

### 3.1 메모리 풀과 버퍼 재사용
대규모 네트워크 서버에서는 수많은 연결이 존재한다. 각 연결마다 새로운 버퍼를 할당하면 성능이 떨어진다. 메모리 풀을 사용하면 할당/해제 오버헤드를 줄일 수 있다.

```cpp
#include <asio.hpp>
#include <memory>
#include <vector>
#include <queue>
#include <mutex>

namespace asio = boost::asio;

// 이 클래스의 목적: 버퍼를 재사용하여 메모리 할당 오버헤드를 줄인다.

class BufferPool {
public:
    explicit BufferPool(size_t buffer_size, size_t pool_size)
        : buffer_size_(buffer_size) {
        
        // 미리 버퍼를 할당한다
        for (size_t i = 0; i < pool_size; ++i) {
            available_buffers_.push(
                std::make_unique<std::vector<char>>(buffer_size)
            );
        }
    }
    
    // 버퍼를 얻는다
    std::unique_ptr<std::vector<char>> acquire() {
        std::unique_lock<std::mutex> lock(mutex_);
        
        if (available_buffers_.empty()) {
            // 풀이 비었으면 새로 할당한다
            return std::make_unique<std::vector<char>>(buffer_size_);
        }
        
        auto buffer = std::move(available_buffers_.front());
        available_buffers_.pop();
        return buffer;
    }
    
    // 버퍼를 돌려준다
    void release(std::unique_ptr<std::vector<char>> buffer) {
        std::unique_lock<std::mutex> lock(mutex_);
        
        if (available_buffers_.size() < max_pool_size_) {
            buffer->clear();
            available_buffers_.push(std::move(buffer));
        }
        // 그 외에는 버퍼가 자동으로 삭제된다
    }
    
    size_t get_available_count() const {
        std::unique_lock<std::mutex> lock(mutex_);
        return available_buffers_.size();
    }
    
private:
    static constexpr size_t max_pool_size_ = 100;
    
    size_t buffer_size_;
    std::queue<std::unique_ptr<std::vector<char>>> available_buffers_;
    mutable std::mutex mutex_;
};

// 사용 예제
class PooledSession {
public:
    PooledSession(asio::io_context& io_context, 
                  std::shared_ptr<BufferPool> buffer_pool)
        : socket_(io_context),
          buffer_pool_(buffer_pool) {
    }
    
    void start() {
        // 풀에서 버퍼를 얻는다
        buffer_ = buffer_pool_->acquire();
        
        async_read();
    }
    
    asio::ip::tcp::socket& get_socket() {
        return socket_;
    }
    
private:
    void async_read() {
        auto self = shared_from_this();
        
        asio::async_read(socket_, asio::buffer(*buffer_),
            [this, self](const asio::error_code& ec, std::size_t length) {
                if (!ec) {
                    // 데이터 처리
                    process_data(length);
                    async_read();
                } else {
                    // 버퍼를 풀에 반환한다
                    buffer_pool_->release(std::move(buffer_));
                }
            }
        );
    }
    
    void process_data(std::size_t length) {
        // 데이터 처리 로직
    }
    
    asio::ip::tcp::socket socket_;
    std::shared_ptr<BufferPool> buffer_pool_;
    std::unique_ptr<std::vector<char>> buffer_;
};
```

버퍼 풀의 장점:

1. **할당 오버헤드 감소**: 미리 할당된 버퍼를 재사용한다.
2. **캐시 효율성**: 자주 사용되는 버퍼는 CPU 캐시에 유지된다.
3. **메모리 단편화 방지**: 일정 크기의 메모리 블록만 할당한다.

### 3.2 스레드 풀을 이용한 I/O 컨텍스트 관리
많은 연결을 효율적으로 처리하려면 스레드 풀을 사용해야 한다.

```cpp
#include <asio.hpp>
#include <thread>
#include <vector>
#include <memory>

namespace asio = boost::asio;

// 이 클래스의 목적: 여러 스레드에서 I/O 작업을 처리한다.

class IoContextThreadPool {
public:
    explicit IoContextThreadPool(size_t num_threads)
        : io_context_(),
          work_(std::make_unique<asio::io_context::work>(io_context_)) {
        
        // 스레드 풀을 생성한다
        for (size_t i = 0; i < num_threads; ++i) {
            threads_.emplace_back([this]() {
                io_context_.run();
            });
        }
    }
    
    ~IoContextThreadPool() {
        // work_ 객체를 제거하면 io_context.run()이 종료된다
        work_.reset();
        
        // 모든 스레드가 완료될 때까지 기다린다
        for (auto& thread : threads_) {
            if (thread.joinable()) {
                thread.join();
            }
        }
    }
    
    asio::io_context& get_io_context() {
        return io_context_;
    }
    
    size_t get_thread_count() const {
        return threads_.size();
    }
    
private:
    asio::io_context io_context_;
    std::unique_ptr<asio::io_context::work> work_;
    std::vector<std::thread> threads_;
};

// 서버 클래스에서 사용 예제
class ScalableServer {
public:
    explicit ScalableServer(size_t thread_count, unsigned short port)
        : thread_pool_(thread_count),
          acceptor_(thread_pool_.get_io_context(),
                    asio::ip::tcp::endpoint(
                        asio::ip::tcp::v4(), port)) {
        
        start_accept();
    }
    
private:
    void start_accept() {
        // 새 소켓을 만든다
        auto socket = std::make_shared<asio::ip::tcp::socket>(
            thread_pool_.get_io_context());
        
        acceptor_.async_accept(*socket,
            [this, socket](const asio::error_code& ec) {
                if (!ec) {
                    // 여러 스레드 중 하나에서 이 세션을 처리한다
                    handle_session(socket);
                }
                
                start_accept();
            }
        );
    }
    
    void handle_session(std::shared_ptr<asio::ip::tcp::socket> socket) {
        // 세션 처리 로직
        std::cout << "새로운 세션 처리\n";
    }
    
    IoContextThreadPool thread_pool_;
    asio::ip::tcp::acceptor acceptor_;
};
```

스레드 풀 아키텍처의 이점:

1. **확장성**: 여러 스레드가 독립적으로 I/O를 처리한다.
2. **CPU 활용**: 멀티코어 시스템의 모든 코어를 활용한다.
3. **응답성**: 한 스레드가 블로킹되어도 다른 스레드는 계속 처리한다.

### 3.3 연결 수 제한과 우아한 종료
서버의 안정성을 위해 연결 수를 제한해야 한다.

```cpp
#include <asio.hpp>
#include <memory>
#include <atomic>

namespace asio = boost::asio;

// 이 클래스의 목적: 최대 연결 수를 제한하고 우아한 종료를 지원한다.

class LimitedServer {
public:
    LimitedServer(asio::io_context& io_context, 
                  unsigned short port,
                  size_t max_connections)
        : acceptor_(io_context,
                    asio::ip::tcp::endpoint(
                        asio::ip::tcp::v4(), port)),
          max_connections_(max_connections),
          current_connections_(0) {
        
        start_accept();
    }
    
    void shutdown() {
        acceptor_.close();
    }
    
    size_t get_connection_count() const {
        return current_connections_.load();
    }
    
private:
    void start_accept() {
        // 최대 연결 수에 도달했으면 더 이상 수락하지 않는다
        if (current_connections_ >= max_connections_) {
            std::cout << "최대 연결 수 도달. 새 연결을 거부합니다.\n";
            
            // 일정 시간 후 다시 시도한다
            timer_ = std::make_unique<asio::deadline_timer>(
                acceptor_.get_executor().context(),
                boost::posix_time::seconds(1)
            );
            
            timer_->async_wait([this](const asio::error_code& ec) {
                if (!ec) {
                    start_accept();
                }
            });
            
            return;
        }
        
        auto socket = std::make_shared<asio::ip::tcp::socket>(
            acceptor_.get_executor().context());
        
        acceptor_.async_accept(*socket,
            [this, socket](const asio::error_code& ec) {
                if (!ec) {
                    ++current_connections_;
                    std::cout << "연결 수: " << current_connections_ << "\n";
                    
                    // 연결이 종료되면 카운트를 감소시킨다
                    setup_connection_cleanup(socket);
                }
                
                start_accept();
            }
        );
    }
    
    void setup_connection_cleanup(
        std::shared_ptr<asio::ip::tcp::socket> socket) {
        
        // 소켓이 닫힐 때 연결 수를 감소시킨다
        auto cleanup = [this, socket]() {
            --current_connections_;
            std::cout << "연결 종료. 남은 연결: " << current_connections_ << "\n";
        };
        
        // 실제로는 세션 클래스에서 정리하는 것이 더 좋다
    }
    
    asio::ip::tcp::acceptor acceptor_;
    size_t max_connections_;
    std::atomic<size_t> current_connections_;
    std::unique_ptr<asio::deadline_timer> timer_;
};
```

  

## 4. 실제 서버 애플리케이션 구현

### 4.1 HTTP 서버의 기본 구현
이제 지금까지 배운 모든 기법을 조합하여 간단한 HTTP 서버를 만들어보자.

```cpp
#include <asio.hpp>
#include <memory>
#include <string>
#include <iostream>
#include <sstream>

namespace asio = boost::asio;

// 이 프로그램의 목적: 간단한 HTTP 요청을 처리하는 서버를 구현한다.
// GET 요청을 받으면 간단한 HTML 응답을 반환한다.

class HttpSession : public std::enable_shared_from_this<HttpSession> {
public:
    using socket_type = asio::ip::tcp::socket;
    
    static std::shared_ptr<HttpSession> create(
        asio::io_context& io_context) {
        return std::shared_ptr<HttpSession>(
            new HttpSession(io_context));
    }
    
    socket_type::lowest_layer_type& socket() {
        return socket_.lowest_layer();
    }
    
    void start() {
        async_read_request();
    }
    
private:
    HttpSession(asio::io_context& io_context)
        : socket_(io_context) {
    }
    
    void async_read_request() {
        auto self = shared_from_this();
        
        // 첫 줄(요청 라인)을 읽는다
        asio::async_read_until(socket_, buffer_, '\n',
            [this, self](const asio::error_code& ec, std::size_t length) {
                if (!ec) {
                    process_request(length);
                } else {
                    std::cerr << "읽기 오류: " << ec.message() << "\n";
                }
            }
        );
    }
    
    void process_request(std::size_t length) {
        std::istream is(&buffer_);
        std::string method, path, version;
        
        // 요청 라인을 파싱한다
        is >> method >> path >> version;
        
        std::cout << "요청: " << method << " " << path << " " << version << "\n";
        
        // 간단한 응답을 만든다
        std::ostringstream response;
        response << "HTTP/1.1 200 OK\r\n"
                 << "Content-Type: text/html; charset=utf-8\r\n"
                 << "Content-Length: 50\r\n"
                 << "Connection: close\r\n"
                 << "\r\n"
                 << "<html><body>Hello from C++!</body></html>";
        
        async_write_response(response.str());
    }
    
    void async_write_response(const std::string& response) {
        auto self = shared_from_this();
        
        response_ = response;
        
        asio::async_write(socket_, asio::buffer(response_),
            [this, self](const asio::error_code& ec, std::size_t) {
                if (ec) {
                    std::cerr << "쓰기 오류: " << ec.message() << "\n";
                } else {
                    std::cout << "응답 전송 완료\n";
                }
            }
        );
    }
    
    asio::ip::tcp::socket socket_;
    asio::streambuf buffer_;
    std::string response_;
};

class HttpServer {
public:
    HttpServer(asio::io_context& io_context, unsigned short port)
        : acceptor_(io_context,
                    asio::ip::tcp::endpoint(
                        asio::ip::tcp::v4(), port)) {
        start_accept();
    }
    
private:
    void start_accept() {
        auto new_session =
            HttpSession::create(acceptor_.get_executor().context());
        
        acceptor_.async_accept(new_session->socket(),
            [this, new_session](const asio::error_code& ec) {
                if (!ec) {
                    std::cout << "새로운 HTTP 연결 수락\n";
                    new_session->start();
                } else {
                    std::cerr << "수락 오류: " << ec.message() << "\n";
                }
                
                start_accept();
            }
        );
    }
    
    asio::ip::tcp::acceptor acceptor_;
};

int main() {
    try {
        asio::io_context io_context;
        
        HttpServer server(io_context, 8080);
        
        std::cout << "HTTP 서버 시작 (포트 8080)...\n";
        std::cout << "http://localhost:8080 에 접속하세요\n";
        
        io_context.run();
    } catch (std::exception& e) {
        std::cerr << "예외: " << e.what() << "\n";
    }
    
    return 0;
}
```

이 HTTP 서버의 설계:

**HttpSession 클래스**: 각 클라이언트의 HTTP 요청 하나를 처리한다. `asio::streambuf`를 사용하여 개행 문자까지 읽는다.

**요청 처리 흐름**: 
1. `async_read_request()` - 클라이언트 요청을 기다린다
2. `process_request()` - HTTP 요청을 파싱한다
3. `async_write_response()` - 응답을 전송한다

**메모리 안전성**: `shared_ptr`과 `enable_shared_from_this`로 세션 객체의 생명주기를 관리한다.

### 4.2 프로토콜 정의와 메시지 처리
더 복잡한 애플리케이션을 위해 커스텀 프로토콜을 정의할 수 있다.

```cpp
#include <asio.hpp>
#include <memory>
#include <string>
#include <cstring>
#include <iostream>

namespace asio = boost::asio;

// 이 코드의 목적: 헤더 + 바디 형식의 커스텀 프로토콜을 구현한다.
// 메시지 형식: [4바이트 길이][메시지 본문]

struct Message {
    uint32_t length;
    std::string body;
    
    // 메시지를 직렬화한다
    std::vector<uint8_t> serialize() const {
        std::vector<uint8_t> data;
        
        // 네트워크 바이트 순서(Big Endian)로 변환
        uint32_t network_length = htonl(body.size());
        
        const uint8_t* header = 
            reinterpret_cast<const uint8_t*>(&network_length);
        data.insert(data.end(), header, header + 4);
        
        const uint8_t* body_ptr = 
            reinterpret_cast<const uint8_t*>(body.data());
        data.insert(data.end(), body_ptr, body_ptr + body.size());
        
        return data;
    }
};

class ProtocolSession : public std::enable_shared_from_this<ProtocolSession> {
public:
    using socket_type = asio::ip::tcp::socket;
    
    static std::shared_ptr<ProtocolSession> create(
        asio::io_context& io_context) {
        return std::shared_ptr<ProtocolSession>(
            new ProtocolSession(io_context));
    }
    
    socket_type::lowest_layer_type& socket() {
        return socket_.lowest_layer();
    }
    
    void start() {
        read_header();
    }
    
private:
    ProtocolSession(asio::io_context& io_context)
        : socket_(io_context) {
    }
    
    // 메시지 헤더(길이)를 읽는다
    void read_header() {
        auto self = shared_from_this();
        
        asio::async_read(socket_,
            asio::buffer(header_buffer_, 4),
            [this, self](const asio::error_code& ec, std::size_t) {
                if (!ec) {
                    read_body();
                } else {
                    std::cerr << "헤더 읽기 오류: " << ec.message() << "\n";
                }
            }
        );
    }
    
    // 메시지 본문을 읽는다
    void read_body() {
        auto self = shared_from_this();
        
        // 헤더에서 길이를 추출한다
        uint32_t network_length;
        std::memcpy(&network_length, header_buffer_.data(), 4);
        uint32_t body_length = ntohl(network_length);
        
        // 메시지 본문 크기에 한계를 둔다
        if (body_length > 10000) {
            std::cerr << "메시지가 너무 큽니다: " << body_length << "\n";
            return;
        }
        
        body_buffer_.resize(body_length);
        
        asio::async_read(socket_,
            asio::buffer(body_buffer_, body_length),
            [this, self, body_length](const asio::error_code& ec, std::size_t) {
                if (!ec) {
                    process_message(body_length);
                    read_header();  // 다음 메시지를 기다린다
                } else {
                    std::cerr << "본문 읽기 오류: " << ec.message() << "\n";
                }
            }
        );
    }
    
    void process_message(std::size_t length) {
        std::string message(body_buffer_.begin(), 
                          body_buffer_.begin() + length);
        
        std::cout << "메시지 수신: " << message << "\n";
        
        // 메시지를 에코 백한다
        Message response;
        response.body = "Echo: " + message;
        
        send_message(response);
    }
    
    void send_message(const Message& msg) {
        auto self = shared_from_this();
        
        auto data = std::make_shared<std::vector<uint8_t>>(
            msg.serialize());
        
        asio::async_write(socket_, asio::buffer(*data),
            [this, self, data](const asio::error_code& ec, std::size_t) {
                if (ec) {
                    std::cerr << "전송 오류: " << ec.message() << "\n";
                }
            }
        );
    }
    
    asio::ip::tcp::socket socket_;
    std::array<uint8_t, 4> header_buffer_;
    std::vector<uint8_t> body_buffer_;
};
```

프로토콜 구현의 핵심:

1. **구조화된 메시지**: 헤더로 길이를 지정하면 정확하게 메시지를 구분할 수 있다.
2. **바이트 순서 변환**: `htonl()`과 `ntohl()`로 네트워크 바이트 순서를 처리한다.
3. **보안**: 메시지 길이에 상한을 설정하여 과도한 메모리 사용을 방지한다.
4. **연속 읽기**: 한 메시지를 처리한 후 다시 헤더를 읽어 다음 메시지를 기다린다.

### 4.3 통합 서버 예제
모든 개념을 하나의 서버에 통합해보자.

```cpp
#include <asio.hpp>
#include <memory>
#include <string>
#include <iostream>
#include <vector>
#include <thread>

namespace asio = boost::asio;

// 이 프로그램의 목적: 앞서 배운 모든 기법을 통합한 실용적인 서버를 구현한다.
// - RAII를 통한 리소스 관리
// - 비동기 I/O와 에러 처리
// - 버퍼 풀을 통한 메모리 최적화
// - 스레드 풀을 통한 확장성
// - 연결 수 제한

class IntegratedServer {
public:
    IntegratedServer(size_t thread_count, unsigned short port,
                     size_t max_connections)
        : work_(std::make_unique<asio::io_context::work>(io_context_)),
          acceptor_(io_context_,
                    asio::ip::tcp::endpoint(
                        asio::ip::tcp::v4(), port)),
          max_connections_(max_connections),
          current_connections_(0) {
        
        // 스레드 풀 시작
        for (size_t i = 0; i < thread_count; ++i) {
            threads_.emplace_back([this]() {
                io_context_.run();
            });
        }
        
        start_accept();
    }
    
    ~IntegratedServer() {
        shutdown();
    }
    
    void shutdown() {
        std::cout << "\n서버 종료 중...\n";
        
        acceptor_.close();
        work_.reset();
        
        for (auto& thread : threads_) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        
        std::cout << "서버 종료 완료\n";
    }
    
    size_t get_connection_count() const {
        return current_connections_;
    }
    
private:
    void start_accept() {
        if (current_connections_ >= max_connections_) {
            std::cout << "최대 연결 수 도달\n";
            return;
        }
        
        auto socket = std::make_shared<asio::ip::tcp::socket>(io_context_);
        
        acceptor_.async_accept(*socket,
            [this, socket](const asio::error_code& ec) {
                if (!ec) {
                    ++current_connections_;
                    std::cout << "새 연결. 현재 연결 수: " 
                              << current_connections_ << "\n";
                    
                    handle_connection(socket);
                } else if (ec != asio::error::operation_aborted) {
                    std::cerr << "수락 오류: " << ec.message() << "\n";
                }
                
                if (current_connections_ < max_connections_) {
                    start_accept();
                }
            }
        );
    }
    
    void handle_connection(std::shared_ptr<asio::ip::tcp::socket> socket) {
        auto buffer = std::make_shared<std::array<char, 1024>>();
        
        asio::async_read(*socket, asio::buffer(*buffer),
            [this, socket, buffer](const asio::error_code& ec,
                                   std::size_t length) {
                if (!ec) {
                    // 데이터 처리
                    std::string message(buffer->data(), length);
                    std::cout << "수신: " << message;
                    
                    // 에코 백
                    asio::async_write(*socket, asio::buffer(message),
                        [this, socket](const asio::error_code& ec, 
                                      std::size_t) {
                            if (ec) {
                                --current_connections_;
                                std::cout << "연결 종료. 남은 연결 수: "
                                         << current_connections_ << "\n";
                            } else {
                                handle_connection(socket);
                            }
                        }
                    );
                } else {
                    --current_connections_;
                    std::cout << "연결 오류: " << ec.message() << "\n";
                }
            }
        );
    }
    
    asio::io_context io_context_;
    std::unique_ptr<asio::io_context::work> work_;
    asio::ip::tcp::acceptor acceptor_;
    std::vector<std::thread> threads_;
    size_t max_connections_;
    std::atomic<size_t> current_connections_;
};

int main() {
    try {
        std::cout << "통합 서버 시작\n";
        std::cout << "포트: 9999\n";
        std::cout << "스레드 수: 4\n";
        std::cout << "최대 연결 수: 100\n";
        
        IntegratedServer server(4, 9999, 100);
        
        std::cout << "\nEnter를 누르면 서버가 종료됩니다.\n";
        std::cin.get();
        
        server.shutdown();
    } catch (std::exception& e) {
        std::cerr << "예외: " << e.what() << "\n";
    }
    
    return 0;
}
```

이 통합 서버의 특징:

**스레드 안전성**: `std::atomic`을 사용하여 연결 수를 추적한다.

**RAII 원칙**: 모든 리소스는 생성자에서 할당되고 소멸자에서 정리된다.

**우아한 종료**: `work_` 객체를 제거하면 모든 스레드가 정상적으로 종료된다.

**확장성**: 스레드 풀로 많은 동시 연결을 처리할 수 있다.

  

## 5. 테스트와 디버깅

### 5.1 서버 테스트 방법
구현한 서버를 테스트하는 방법들을 알아보자.

```cpp
// 클라이언트 테스트 프로그램
#include <asio.hpp>
#include <iostream>
#include <string>

namespace asio = boost::asio;

void test_echo_server() {
    try {
        asio::io_context io_context;
        asio::ip::tcp::socket socket(io_context);
        
        // 서버에 연결
        asio::ip::tcp::endpoint endpoint(
            asio::ip::address::from_string("127.0.0.1"), 9999);
        socket.connect(endpoint);
        
        std::cout << "서버에 연결됨\n";
        
        // 메시지 전송
        std::string message = "Hello, Server!";
        asio::write(socket, asio::buffer(message));
        
        std::cout << "전송: " << message << "\n";
        
        // 응답 수신
        std::array<char, 1024> buffer;
        std::size_t length = asio::read(socket,
            asio::buffer(buffer), asio::transfer_at_least(1));
        
        std::cout << "수신: " << std::string(buffer.data(), length) << "\n";
        
        socket.close();
    } catch (std::exception& e) {
        std::cerr << "오류: " << e.what() << "\n";
    }
}

int main() {
    test_echo_server();
    return 0;
}
```

### 5.2 성능 측정
서버의 성능을 측정하는 방법:

```cpp
#include <asio.hpp>
#include <chrono>
#include <iostream>
#include <vector>

namespace asio = boost::asio;

void benchmark_server(int num_connections, int messages_per_connection) {
    try {
        asio::io_context io_context;
        
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<asio::ip::tcp::socket> sockets;
        
        // 여러 연결을 시뮬레이션한다
        for (int i = 0; i < num_connections; ++i) {
            asio::ip::tcp::socket socket(io_context);
            asio::ip::tcp::endpoint endpoint(
                asio::ip::address::from_string("127.0.0.1"), 9999);
            
            try {
                socket.connect(endpoint);
                sockets.push_back(std::move(socket));
            } catch (...) {
                std::cout << "연결 실패 (연결 수: " << sockets.size() << ")\n";
                break;
            }
        }
        
        // 메시지 전송
        std::string message = "test";
        std::array<char, 1024> buffer;
        
        for (auto& socket : sockets) {
            for (int i = 0; i < messages_per_connection; ++i) {
                asio::write(socket, asio::buffer(message));
                asio::read(socket, asio::buffer(buffer));
            }
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
            end - start);
        
        std::cout << "연결 수: " << sockets.size() << "\n";
        std::cout << "메시지당 시간: " << duration.count() / 
                     (sockets.size() * messages_per_connection) << "ms\n";
        std::cout << "총 시간: " << duration.count() << "ms\n";
    } catch (std::exception& e) {
        std::cerr << "오류: " << e.what() << "\n";
    }
}

int main() {
    benchmark_server(10, 100);
    return 0;
}
```

  

## 6. C++ Core Guidelines와의 일관성
네트워크 프로그래밍에서 따라야 할 Core Guidelines:

**R.1**: 자원 누수를 피한다. 모든 연결과 버퍼는 RAII로 관리된다.

```cpp
// 좋은 예
std::shared_ptr<asio::ip::tcp::socket> socket = 
    std::make_shared<asio::ip::tcp::socket>(io_context);
// 자동으로 정리된다

// 나쁜 예
auto* socket = new asio::ip::tcp::socket(io_context);
// 수동으로 delete해야 하고, 예외 발생 시 누수된다
```

**E.1**: 예외 안전성을 고려한다.

```cpp
// 좋은 예
try {
    asio::async_read(..., [](const asio::error_code& ec, ...) {
        if (ec) {
            // 에러 처리
        }
    });
} catch (const std::exception& e) {
    // 시스템 수준 에러 처리
}

// 나쁜 예
if (socket.connect(...)) {  // C 스타일 에러 처리
    // ...
}
```

**C.5**: 리소스를 RAII 클래스로 관리한다.

```cpp
class Connection {
private:
    asio::ip::tcp::socket socket_;  // RAII
    std::vector<char> buffer_;      // RAII
    
public:
    // 복사는 불가능하다
    Connection(const Connection&) = delete;
    Connection& operator=(const Connection&) = delete;
};
```

  

## 결론
Chapter 15에서 다룬 네트워크 프로그래밍은 Modern C++의 모든 장점을 보여준다. ASIO 라이브러리와 함께 RAII, 스마트 포인터, 예외 처리를 결합하면, 안전하고 효율적인 네트워크 서버를 구축할 수 있다.

비동기 I/O는 복잡해 보이지만, 에러 코드 기반의 핸들링과 람다 함수를 사용하면 매우 명확하고 유지보수하기 쉬운 코드가 된다. 메모리 풀과 스레드 풀을 활용하면 대규모 동시 연결도 효율적으로 처리할 수 있다.

가장 중요한 점은, 이 모든 기능이 타입 안전성을 유지하면서 제공된다는 것이다. Rust의 비동기 프로그래밍과 비교해도 C++은 더 유연하면서도 동등한 수준의 안전성을 제공한다. Modern C++은 더 이상 네트워크 프로그래밍에 부적합한 언어가 아니다.     