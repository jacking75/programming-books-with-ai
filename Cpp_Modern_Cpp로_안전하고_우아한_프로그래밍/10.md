# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 10: 예외 안전성의 3단계
이 장에서는 C++에서 예외 안전성을 어떻게 구현하는지에 대해 배울 것이다. 

"예외 안전성"이라는 말이 처음 들리면 생소할 수 있지만, 이것은 매우 중요한 개념이다. 프로그램이 실행되는 도중 예외가 발생했을 때, 프로그램이 안전한 상태를 유지하는 것을 의미한다. 예를 들어 은행 계좌 이체 중에 예외가 발생했다면, 돈이 어느 한쪽에는 빠져나갔는데 다른 쪽에는 들어오지 않는 상황이 생기면 안 된다. 이런 일관성 있는 상태를 유지하는 것이 바로 예외 안전성이다.

이 장의 목표는 여러분이 예외가 발생해도 프로그램이 일관된 상태를 유지하도록 설계하는 방법을 이해하는 것이다. C++의 RAII 패턴과 예외 처리를 완벽하게 조화시킬 때, 우리는 Rust처럼 안전한 프로그래밍을 할 수 있다.
  

## 10.1 예외 안전성의 3단계 이해하기

### 10.1.1 예외 안전성의 3가지 수준
C++에서는 예외 안전성을 3가지 수준으로 분류한다. 각 수준은 예외 발생 시 프로그램의 상태가 어느 정도 보장되는지를 나타낸다.

먼저 각 수준을 간단히 설명하면 다음과 같다:

1. **No-throw 보장**: 함수가 예외를 던지지 않으며, 성공한다. 이는 가장 강력한 보장이다.
2. **Strong 보장**: 함수가 성공하거나, 아무 일도 없었던 것처럼 상태가 원래대로 돌아간다. "all-or-nothing" 보장이다.
3. **Basic 보장**: 함수가 예외를 던질 수 있지만, 예외 발생 후에도 객체가 일관된 상태에 있다. 단, 정확히 어떤 상태인지는 알 수 없다.

이 3가지 중 어느 것을 선택할지는 함수의 성질과 성능 요구사항에 따라 결정된다.

### 10.1.2 기본 예제로 이해하는 3단계 보장
각 보장 수준을 더 명확히 이해하기 위해 은행 계좌 이체 예제를 사용해보자.

```cpp
#include <iostream>
#include <string>
#include <stdexcept>

class BankAccount {
private:
    std::string accountName;
    double balance;
    
public:
    BankAccount(const std::string& name, double initialBalance)
        : accountName(name), balance(initialBalance) {
        if (initialBalance < 0) {
            throw std::invalid_argument("초기 잔액은 음수가 될 수 없습니다");
        }
    }
    
    double getBalance() const { return balance; }
    
    const std::string& getName() const { return accountName; }
    
    // Basic 보장: 예외 발생 시에도 계좌가 유효한 상태
    // 하지만 정확한 상태는 보장하지 않음
    void depositBasic(double amount) {
        if (amount < 0) {
            throw std::invalid_argument("입금액은 음수가 될 수 없습니다");
        }
        
        // 어떤 외부 작업이 있다고 가정
        // 이 작업 중 예외가 발생할 수 있다
        performExternalOperation();
        
        balance += amount;  // 외부 작업 실패 시 여기 도달하지 않음
    }
    
    // Strong 보장: 성공하거나 원상태로 돌아감
    void depositStrong(double amount) {
        if (amount < 0) {
            throw std::invalid_argument("입금액은 음수가 될 수 없습니다");
        }
        
        // 원상태를 저장해둔다
        double originalBalance = balance;
        
        try {
            // 외부 작업 수행
            performExternalOperation();
            
            // 성공했으므로 실제로 잔액을 변경
            balance += amount;
        }
        catch (...) {
            // 예외 발생 시 원상태로 되돌린다
            balance = originalBalance;
            throw;  // 예외를 다시 던진다
        }
    }
    
    // No-throw 보장: 절대 예외를 던지지 않음
    void depositNoThrow(double amount) noexcept {
        // 음수 체크는 하지만 예외를 던지지 않음
        if (amount < 0) {
            return;  // 조용히 실패
        }
        
        // 외부 작업을 호출하지 않음 (예외 가능성 제거)
        balance += amount;
    }
    
private:
    void performExternalOperation() {
        // 때때로 예외를 던질 수 있는 작업
        // 이 예제에서는 10% 확률로 실패한다고 가정
        static int callCount = 0;
        if (++callCount % 10 == 0) {
            throw std::runtime_error("외부 작업 실패");
        }
    }
};

int main() {
    BankAccount account("홍길동", 10000);
    
    std::cout << "초기 잔액: " << account.getBalance() << std::endl;
    
    // Strong 보장 테스트
    try {
        account.depositStrong(5000);
        std::cout << "Strong 보장 후 잔액: " << account.getBalance() << std::endl;
    }
    catch (const std::exception& e) {
        std::cout << "Strong 보장: 예외 발생 - " << e.what() << std::endl;
        std::cout << "예외 발생 후 잔액: " << account.getBalance() << std::endl;
        std::cout << "(원상태로 유지되었음을 확인)" << std::endl;
    }
    
    // No-throw 보장 테스트
    account.depositNoThrow(3000);
    std::cout << "No-throw 보장 후 잔액: " << account.getBalance() << std::endl;
    
    return 0;
}
```

이 코드를 실행하면 각 보장 수준의 차이를 명확히 볼 수 있다. Strong 보장을 사용한 경우, 외부 작업이 실패해도 잔액이 원래대로 유지된다. 이것이 예외 안전성의 핵심이다.
  


## 10.2 RAII와 예외의 완벽한 조화

### 10.2.1 RAII를 사용한 자동 자원 해제
RAII(Resource Acquisition Is Initialization)는 자원을 획득할 때 생성자에서 획득하고, 자원을 해제할 때 소멸자에서 해제하는 패턴이다. 이 패턴은 예외가 발생해도 자원이 정확히 해제되도록 보장한다.

```cpp
#include <iostream>
#include <fstream>
#include <memory>
#include <vector>

// 파일 작업을 하는 클래스
class FileHandler {
private:
    std::ofstream file;
    
public:
    FileHandler(const std::string& filename) {
        file.open(filename);
        if (!file.is_open()) {
            throw std::runtime_error("파일을 열 수 없습니다: " + filename);
        }
        std::cout << "파일 열기: " << filename << std::endl;
    }
    
    // 소멸자에서 파일을 자동으로 닫는다
    ~FileHandler() {
        if (file.is_open()) {
            file.close();
            std::cout << "파일 자동 닫기" << std::endl;
        }
    }
    
    void write(const std::string& data) {
        if (!file.is_open()) {
            throw std::runtime_error("파일이 열려있지 않습니다");
        }
        file << data << std::endl;
    }
    
    // 복사 방지 (파일은 단 하나의 핸들로만 관리)
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
};

// 데이터베이스 연결을 관리하는 클래스
class DatabaseConnection {
private:
    std::string connectionString;
    bool isConnected = false;
    
public:
    DatabaseConnection(const std::string& connStr) : connectionString(connStr) {
        // 데이터베이스 연결
        std::cout << "데이터베이스 연결: " << connectionString << std::endl;
        isConnected = true;
    }
    
    ~DatabaseConnection() {
        if (isConnected) {
            std::cout << "데이터베이스 연결 해제" << std::endl;
            isConnected = false;
        }
    }
    
    void executeQuery(const std::string& query) {
        if (!isConnected) {
            throw std::runtime_error("데이터베이스가 연결되어 있지 않습니다");
        }
        std::cout << "쿼리 실행: " << query << std::endl;
    }
    
    DatabaseConnection(const DatabaseConnection&) = delete;
    DatabaseConnection& operator=(const DatabaseConnection&) = delete;
};

// 트랜잭션 관리 클래스
class Transaction {
private:
    DatabaseConnection& db;
    bool isCommitted = false;
    
public:
    Transaction(DatabaseConnection& database) : db(database) {
        std::cout << "트랜잭션 시작" << std::endl;
        db.executeQuery("BEGIN");
    }
    
    ~Transaction() {
        if (!isCommitted) {
            // 커밋하지 않았으면 자동 롤백
            std::cout << "트랜잭션 자동 롤백" << std::endl;
            try {
                db.executeQuery("ROLLBACK");
            }
            catch (...) {
                // 소멸자에서 예외를 발생시키면 안 된다
                std::cerr << "롤백 중 오류 발생" << std::endl;
            }
        }
    }
    
    void commit() {
        db.executeQuery("COMMIT");
        isCommitted = true;
        std::cout << "트랜잭션 커밋" << std::endl;
    }
    
    Transaction(const Transaction&) = delete;
    Transaction& operator=(const Transaction&) = delete;
};

int main() {
    std::cout << "=== RAII와 예외 처리 ===" << std::endl;
    
    try {
        // 파일 핸들 생성 (RAII)
        FileHandler file("output.txt");
        file.write("첫 번째 라인");
        file.write("두 번째 라인");
        
        // 스코프를 벗어나면서 파일이 자동으로 닫힌다
    }
    catch (const std::exception& e) {
        std::cout << "오류: " << e.what() << std::endl;
    }
    
    std::cout << "\n=== 데이터베이스 트랜잭션 ===" << std::endl;
    
    try {
        DatabaseConnection db("server=localhost;db=mydb");
        
        {
            // 트랜잭션 생성
            Transaction trans(db);
            db.executeQuery("INSERT INTO users VALUES (1, 'John')");
            db.executeQuery("INSERT INTO users VALUES (2, 'Jane')");
            
            // 예외 발생 시뮬레이션
            throw std::runtime_error("중간에 오류 발생!");
            
            trans.commit();  // 도달하지 않음
        }
        // 스코프를 벗어나면서 트랜잭션이 자동으로 롤백됨
    }
    catch (const std::exception& e) {
        std::cout << "처리된 오류: " << e.what() << std::endl;
    }
    
    std::cout << "\n=== 예외 없는 성공 케이스 ===" << std::endl;
    
    try {
        DatabaseConnection db("server=localhost;db=mydb");
        
        {
            Transaction trans(db);
            db.executeQuery("UPDATE users SET name='John Doe' WHERE id=1");
            trans.commit();  // 명시적 커밋
        }
        // 커밋했으므로 소멸자는 아무것도 하지 않음
    }
    catch (const std::exception& e) {
        std::cout << "오류: " << e.what() << std::endl;
    }
    
    return 0;
}
```

이 코드의 중요한 점을 설명하자면, RAII를 사용하면 어떤 경로로 스코프를 벗어나든 (정상 종료이든 예외이든) 소멸자가 반드시 호출되어 자원을 정리한다. 이것이 바로 예외 안전성을 보장하는 핵심 메커니즘이다.

### 10.2.2 스마트 포인터와 RAII의 조합
스마트 포인터도 RAII를 기반으로 하고 있다. 스마트 포인터를 사용하면 동적으로 할당한 메모리가 자동으로 해제되어 메모리 누수를 방지할 수 있다.

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Resource {
private:
    std::string name;
    
public:
    Resource(const std::string& n) : name(n) {
        std::cout << "리소스 생성: " << name << std::endl;
    }
    
    ~Resource() {
        std::cout << "리소스 소멸: " << name << std::endl;
    }
    
    void use() {
        std::cout << "리소스 사용: " << name << std::endl;
    }
};

// 여러 리소스를 관리하는 클래스
class ResourceManager {
private:
    std::vector<std::unique_ptr<Resource>> resources;
    
public:
    void addResource(const std::string& name) {
        resources.push_back(std::make_unique<Resource>(name));
    }
    
    void useAll() {
        for (auto& resource : resources) {
            resource->use();
        }
    }
    
    // 소멸자가 자동으로 모든 리소스를 정리한다
    ~ResourceManager() {
        std::cout << "ResourceManager 소멸: 모든 리소스 정리" << std::endl;
    }
};

// 복잡한 작업을 수행하는 함수
void complexOperation() {
    std::cout << "=== 복잡한 작업 시작 ===" << std::endl;
    
    ResourceManager manager;
    manager.addResource("리소스1");
    manager.addResource("리소스2");
    manager.addResource("리소스3");
    
    manager.useAll();
    
    // 예외 발생
    if (true) {
        throw std::runtime_error("예외 발생!");
    }
    
    // 이 코드는 실행되지 않지만, 스코프를 벗어나면서
    // manager의 소멸자가 호출되어 모든 리소스가 정리된다
}

int main() {
    try {
        complexOperation();
    }
    catch (const std::exception& e) {
        std::cout << "예외 처리됨: " << e.what() << std::endl;
        std::cout << "(위에서 모든 리소스가 정리되었음을 확인)" << std::endl;
    }
    
    return 0;
}
```

### 10.2.3 lock_guard를 사용한 뮤텍스 안전성
멀티스레드 환경에서도 RAII를 사용하여 예외 안전성을 보장할 수 있다. `std::lock_guard`는 뮤텍스를 자동으로 잠금과 해제해주는 RAII 패턴의 좋은 예다.

```cpp
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <chrono>

class ThreadSafeCounter {
private:
    int value = 0;
    mutable std::mutex mtx;
    
public:
    // lock_guard를 사용하여 자동으로 뮤텍스를 관리한다
    void increment() {
        std::lock_guard<std::mutex> lock(mtx);  // 생성자에서 잠금
        
        // 예외가 발생해도 lock_guard의 소멸자가 호출되어 뮤텍스가 해제된다
        value++;
        std::cout << "증가: " << value << std::endl;
    }
    
    int getValue() const {
        std::lock_guard<std::mutex> lock(mtx);
        return value;
    }
    
    // 여러 작업을 원자적으로 수행
    void complexOperation() {
        std::lock_guard<std::mutex> lock(mtx);
        
        std::cout << "복잡한 작업 시작" << std::endl;
        value++;
        
        // 여기서 예외가 발생해도
        if (value % 3 == 0) {
            throw std::runtime_error("작업 중 오류 발생!");
        }
        
        value++;
        std::cout << "복잡한 작업 완료" << std::endl;
    }
};

int main() {
    ThreadSafeCounter counter;
    
    // 정상 작동
    counter.increment();
    counter.increment();
    std::cout << "현재 값: " << counter.getValue() << std::endl;
    
    // 예외 발생 후에도 뮤텍스가 정확히 해제된다
    try {
        counter.complexOperation();
    }
    catch (const std::exception& e) {
        std::cout << "예외 처리: " << e.what() << std::endl;
    }
    
    // 다시 작업할 수 있다 (뮤텍스가 정확히 해제되었음)
    counter.increment();
    std::cout << "최종 값: " << counter.getValue() << std::endl;
    
    return 0;
}
```
  


## 10.3 예외 중립적 코드 작성법

### 10.3.1 예외 중립성의 개념과 중요성
"예외 중립적"이라는 개념은 함수가 자신이 처리하지 않는 예외를 그대로 전파하는 방식을 의미한다. 이는 매우 유용한 패턴이다. 함수가 예외를 "지나가게" 하면, 상위 레벨의 코드가 적절하게 처리할 수 있기 때문이다.

```cpp
#include <iostream>
#include <stdexcept>
#include <string>

// 저수준 라이브러리 함수
void lowLevelOperation() {
    throw std::runtime_error("저수준에서 오류 발생");
}

// 중간 레벨 함수 1: 예외를 처리하지 않고 전파
void middleLevel1() {
    // 이 함수는 lowLevelOperation의 예외를 처리하지 않는다
    // 따라서 예외가 그대로 위로 전파된다 (예외 중립적)
    lowLevelOperation();
}

// 중간 레벨 함수 2: 자신의 정리 작업을 한 후 예외 전파
void middleLevel2() {
    std::cout << "중간 레벨 2: 작업 시작" << std::endl;
    
    try {
        lowLevelOperation();
    }
    catch (...) {
        // 정리 작업 수행
        std::cout << "중간 레벨 2: 정리 작업" << std::endl;
        throw;  // 예외를 다시 던짐 (예외 중립적)
    }
}

// 고수준 레벨: 최종적으로 예외를 처리
void highLevel() {
    std::cout << "고수준: 작업 시작" << std::endl;
    middleLevel2();
    std::cout << "고수준: 작업 완료" << std::endl;
}

int main() {
    try {
        highLevel();
    }
    catch (const std::exception& e) {
        std::cout << "최상위 레벨에서 예외 처리: " << e.what() << std::endl;
    }
    
    return 0;
}
```

이 코드에서 `middleLevel2` 함수가 바로 예외 중립적인 코드의 예다. 함수는 자신이 처리해야 할 정리 작업을 한 후, 예외를 다시 던져서 상위 레벨이 처리하도록 한다.

### 10.3.2 여러 작업 중 하나라도 실패 시 롤백
데이터베이스의 트랜잭션처럼, 여러 작업을 수행할 때 하나라도 실패하면 모든 작업을 롤백해야 하는 상황이 있다.

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>
#include <memory>

// 금융 거래를 나타내는 클래스
class Transaction {
private:
    std::string fromAccount;
    std::string toAccount;
    double amount;
    bool isCompleted = false;
    
public:
    Transaction(const std::string& from, const std::string& to, double amt)
        : fromAccount(from), toAccount(to), amount(amt) {}
    
    void execute() {
        std::cout << fromAccount << "에서 " << toAccount 
                  << "로 " << amount << "원 이체" << std::endl;
        
        // 이체 작업 수행
        // 일반적으로 실제 데이터베이스 쿼리가 여기 들어감
        isCompleted = true;
    }
    
    void rollback() {
        if (isCompleted) {
            std::cout << "이체 롤백: " << fromAccount << " -> " << toAccount 
                      << " (" << amount << "원)" << std::endl;
            isCompleted = false;
        }
    }
    
    bool isExecuted() const { return isCompleted; }
};

// 여러 거래를 관리하는 클래스
class BatchTransactionManager {
private:
    std::vector<std::unique_ptr<Transaction>> transactions;
    
public:
    void addTransaction(const std::string& from, const std::string& to, double amount) {
        transactions.push_back(
            std::make_unique<Transaction>(from, to, amount)
        );
    }
    
    // Strong 보장: 모든 거래가 성공하거나, 모두 롤백된다
    void executeAll() {
        std::vector<Transaction*> executedTransactions;
        
        try {
            // 모든 거래를 순서대로 실행
            for (auto& trans : transactions) {
                trans->execute();
                executedTransactions.push_back(trans.get());
            }
            std::cout << "\n모든 거래 완료!" << std::endl;
        }
        catch (const std::exception& e) {
            // 예외 발생 시 이미 실행한 거래를 모두 롤백
            std::cout << "\n오류 발생! 이미 실행한 거래를 롤백합니다..." << std::endl;
            
            for (auto trans : executedTransactions) {
                trans->rollback();
            }
            
            // 예외를 다시 던짐 (예외 중립적)
            throw;
        }
    }
};

int main() {
    std::cout << "=== 여러 거래 배치 처리 ===" << std::endl;
    
    BatchTransactionManager manager;
    manager.addTransaction("계좌1", "계좌2", 10000);
    manager.addTransaction("계좌2", "계좌3", 5000);
    manager.addTransaction("계좌3", "계좌1", 3000);
    
    try {
        manager.executeAll();
    }
    catch (const std::exception& e) {
        std::cout << "최상위에서 처리: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 10.3.3 복수 예외 처리와 정보 보존
때때로 여러 작업이 실패할 수 있고, 각 실패에 대한 정보를 모두 보존해야 할 수 있다. 이런 경우 어떻게 처리할지 보자.

```cpp
#include <iostream>
#include <vector>
#include <exception>
#include <memory>
#include <string>

// 개별 작업의 결과를 나타내는 클래스
class TaskResult {
public:
    virtual ~TaskResult() = default;
    virtual std::string toString() const = 0;
};

class SuccessResult : public TaskResult {
private:
    std::string message;
    
public:
    SuccessResult(const std::string& msg) : message(msg) {}
    
    std::string toString() const override {
        return "성공: " + message;
    }
};

class FailureResult : public TaskResult {
private:
    std::string errorMessage;
    
public:
    FailureResult(const std::string& error) : errorMessage(error) {}
    
    std::string toString() const override {
        return "실패: " + errorMessage;
    }
};

// 여러 작업을 수행하고 모든 결과를 수집하는 클래스
class TaskBatch {
private:
    std::vector<std::unique_ptr<TaskResult>> results;
    std::vector<std::exception_ptr> exceptions;
    
public:
    void executeTask(int taskId) {
        try {
            std::cout << "작업 " << taskId << " 실행 중..." << std::endl;
            
            // 일부 작업이 실패한다고 가정
            if (taskId % 3 == 0) {
                throw std::runtime_error("작업 " + std::to_string(taskId) + "에서 오류 발생");
            }
            
            results.push_back(
                std::make_unique<SuccessResult>("작업 " + std::to_string(taskId) + " 완료")
            );
        }
        catch (...) {
            // 예외를 저장하고 계속 진행
            results.push_back(
                std::make_unique<FailureResult>("작업 " + std::to_string(taskId) + "에서 오류")
            );
            exceptions.push_back(std::current_exception());
        }
    }
    
    // 모든 작업을 순서대로 실행
    void executeAll(int taskCount) {
        std::cout << "배치 작업 시작" << std::endl;
        
        for (int i = 1; i <= taskCount; ++i) {
            executeTask(i);
        }
        
        std::cout << "\n배치 작업 완료" << std::endl;
    }
    
    // 결과 보고
    void reportResults() const {
        std::cout << "\n=== 작업 결과 ===" << std::endl;
        for (const auto& result : results) {
            std::cout << result->toString() << std::endl;
        }
        
        if (!exceptions.empty()) {
            std::cout << "\n총 " << exceptions.size() << "개의 오류가 발생했습니다." << std::endl;
        }
    }
    
    bool hasFailures() const { return !exceptions.empty(); }
};

int main() {
    TaskBatch batch;
    batch.executeAll(9);
    batch.reportResults();
    
    if (batch.hasFailures()) {
        std::cout << "\n일부 작업이 실패했으나, 다른 작업은 계속 진행되었습니다." << std::endl;
    }
    
    return 0;
}
```
  


## 10.4 std::optional과 오류 처리 패턴

### 10.4.1 std::optional의 기초
`std::optional`은 "값이 있을 수도 있고 없을 수도 있다"는 상황을 타입 안전하게 표현하는 방법이다. 예외를 던지지 않으면서도 오류를 표현할 수 있다.

```cpp
#include <iostream>
#include <optional>
#include <string>
#include <stdexcept>

class User {
private:
    int id;
    std::string name;
    std::string email;
    
public:
    User(int i, const std::string& n, const std::string& e)
        : id(i), name(n), email(e) {}
    
    int getId() const { return id; }
    const std::string& getName() const { return name; }
    const std::string& getEmail() const { return email; }
};

// 기존 방식: 예외 사용
User findUserByIdWithException(int id) {
    if (id < 1 || id > 1000) {
        throw std::out_of_range("사용자를 찾을 수 없습니다");
    }
    // 실제로는 데이터베이스에서 조회
    return User(id, "John Doe", "john@example.com");
}

// Modern 방식: std::optional 사용
std::optional<User> findUserById(int id) {
    if (id < 1 || id > 1000) {
        return std::nullopt;  // 값이 없음을 나타낸다
    }
    // 실제로는 데이터베이스에서 조회
    return User(id, "John Doe", "john@example.com");
}

int main() {
    std::cout << "=== std::optional 사용 ===" << std::endl;
    
    // 값이 있는 경우
    auto user = findUserById(5);
    
    if (user) {  // has_value()를 호출하는 것과 동일
        std::cout << "사용자: " << user->getName() << " (" << user->getEmail() << ")" << std::endl;
    }
    
    // 값이 없는 경우
    auto notFound = findUserById(2000);
    
    if (!notFound) {
        std::cout << "사용자를 찾을 수 없습니다" << std::endl;
    } else {
        std::cout << "사용자: " << notFound->getName() << std::endl;
    }
    
    // value_or을 사용한 기본값 제공
    if (user) {
        std::cout << "이메일: " << user->value().getEmail() << std::endl;
    }
    
    std::cout << "\n=== 예외와의 비교 ===" << std::endl;
    
    try {
        // 예외를 사용하는 방식은 더 무거운 오버헤드가 있다
        auto foundUser = findUserByIdWithException(5);
        std::cout << "예외 방식: " << foundUser.getName() << std::endl;
    }
    catch (const std::exception& e) {
        std::cout << "예외 처리: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 10.4.2 std::optional의 고급 활용
`std::optional`은 함수형 프로그래밍 스타일의 여러 유용한 메서드를 제공한다.

```cpp
#include <iostream>
#include <optional>
#include <string>

class Price {
private:
    double value;
    
public:
    Price(double v) : value(v) {}
    double getValue() const { return value; }
};

class Product {
private:
    std::string name;
    std::optional<Price> price;
    std::optional<int> quantity;
    
public:
    Product(const std::string& n) : name(n) {}
    
    void setPrice(const Price& p) { price = p; }
    void setQuantity(int q) { quantity = q; }
    
    const std::string& getName() const { return name; }
    
    // 가격이 있으면 반환, 없으면 nullptr 반환
    const Price* getPriceIfAvailable() const {
        return price ? &price.value() : nullptr;
    }
    
    // 수량이 있으면 값, 없으면 0 반환
    int getQuantityOrZero() const {
        return quantity.value_or(0);
    }
    
    // 총액 계산 (가격과 수량이 모두 있을 때만)
    std::optional<double> calculateTotal() const {
        if (price && quantity) {
            return price->getValue() * quantity.value();
        }
        return std::nullopt;
    }
};

// 문자열에서 정수 파싱
std::optional<int> parseInteger(const std::string& str) {
    try {
        return std::stoi(str);
    }
    catch (...) {
        return std::nullopt;
    }
}

// 여러 optional 값을 처리하는 함수
std::optional<int> combineValues(const std::optional<int>& a, 
                                  const std::optional<int>& b) {
    // 두 값이 모두 있으면 합산
    if (a && b) {
        return a.value() + b.value();
    }
    return std::nullopt;
}

int main() {
    std::cout << "=== Product 가격 계산 ===" << std::endl;
    
    Product product("노트북");
    std::cout << "제품: " << product.getName() << std::endl;
    std::cout << "수량: " << product.getQuantityOrZero() << std::endl;
    
    // 가격만 설정
    product.setPrice(Price(1000000));
    std::cout << "총액: ";
    if (auto total = product.calculateTotal()) {
        std::cout << total.value() << "원" << std::endl;
    } else {
        std::cout << "가격 또는 수량이 없습니다" << std::endl;
    }
    
    // 수량까지 설정
    product.setQuantity(2);
    std::cout << "총액: ";
    if (auto total = product.calculateTotal()) {
        std::cout << total.value() << "원" << std::endl;
    } else {
        std::cout << "계산할 수 없습니다" << std::endl;
    }
    
    std::cout << "\n=== 문자열 파싱 ===" << std::endl;
    
    std::string input1 = "42";
    std::string input2 = "invalid";
    
    if (auto num = parseInteger(input1)) {
        std::cout << input1 << " 파싱 성공: " << num.value() << std::endl;
    }
    
    if (auto num = parseInteger(input2)) {
        std::cout << input2 << " 파싱 성공: " << num.value() << std::endl;
    } else {
        std::cout << input2 << " 파싱 실패" << std::endl;
    }
    
    std::cout << "\n=== 여러 optional 조합 ===" << std::endl;
    
    auto val1 = parseInteger("10");
    auto val2 = parseInteger("20");
    auto val3 = parseInteger("abc");
    
    if (auto result = combineValues(val1, val2)) {
        std::cout << "10 + 20 = " << result.value() << std::endl;
    }
    
    if (auto result = combineValues(val1, val3)) {
        std::cout << "10 + abc = " << result.value() << std::endl;
    } else {
        std::cout << "10 + abc = 계산할 수 없음" << std::endl;
    }
    
    return 0;
}
```

### 10.4.3 std::optional과 예외의 선택
`std::optional`과 예외 중 언제 어느 것을 사용할지 판단하는 것이 중요하다.

```cpp
#include <iostream>
#include <optional>
#include <stdexcept>
#include <string>

// std::optional을 사용할 때가 좋은 경우:
// 1. "없음" 상태가 정상적인 경우
// 2. 성능이 중요한 경우
// 3. 예상 가능한 오류인 경우

class ConfigFile {
private:
    std::string filePath;
    
public:
    ConfigFile(const std::string& path) : filePath(path) {}
    
    // 사용자가 설정값을 입력하지 않은 것은 정상이므로 optional
    std::optional<int> getIntValue(const std::string& key) const {
        // 실제로는 파일에서 읽음
        if (key == "port") {
            return 8080;
        }
        if (key == "timeout") {
            return 300;
        }
        return std::nullopt;  // 설정되지 않은 키는 없음을 반환
    }
    
    // 파일을 찾을 수 없는 것은 오류이므로 예외 사용
    bool loadFile() {
        // 실제로는 파일을 열어봄
        std::cout << "파일 로드: " << filePath << std::endl;
        if (filePath.empty()) {
            throw std::invalid_argument("파일 경로가 비어있습니다");
        }
        return true;
    }
};

// 선택 기준 가이드
void demonstrateWhenToUseOptional() {
    std::cout << "=== std::optional 사용 케이스 ===" << std::endl;
    
    ConfigFile config("config.ini");
    
    // optional 사용: 값이 있을 수도, 없을 수도 있음
    if (auto timeout = config.getIntValue("timeout")) {
        std::cout << "타임아웃: " << timeout.value() << "초" << std::endl;
    } else {
        std::cout << "타임아웃 설정 없음 (기본값 사용)" << std::endl;
    }
    
    if (auto customPort = config.getIntValue("custom_port")) {
        std::cout << "커스텀 포트: " << customPort.value() << std::endl;
    } else {
        std::cout << "커스텀 포트 설정 없음" << std::endl;
    }
}

void demonstrateWhenToUseException() {
    std::cout << "\n=== 예외 사용 케이스 ===" << std::endl;
    
    try {
        ConfigFile config("");  // 빈 경로
        config.loadFile();      // 이것은 오류다
    }
    catch (const std::invalid_argument& e) {
        std::cout << "파일 로드 오류: " << e.what() << std::endl;
    }
}

// 선택 가이드 출력
void printSelectionGuide() {
    std::cout << "\n=== std::optional vs 예외 선택 가이드 ===" << std::endl;
    std::cout << "std::optional을 사용하세요:\n"
              << "  - \"없음\"이 정상적인 상태일 때\n"
              << "  - 예상 가능한 오류일 때\n"
              << "  - 성능이 중요할 때\n"
              << "  - 예: 선택 설정값, 데이터베이스 조회\n" << std::endl;
    
    std::cout << "예외를 사용하세요:\n"
              << "  - 비정상적인 상황일 때\n"
              << "  - 프로그램 흐름을 크게 바꿔야 할 때\n"
              << "  - 에러 정보를 자세히 전달해야 할 때\n"
              << "  - 예: 파일 열기 실패, 네트워크 연결 실패\n" << std::endl;
}

int main() {
    demonstrateWhenToUseOptional();
    demonstrateWhenToUseException();
    printSelectionGuide();
    
    return 0;
}
```
  


## 10.5 종합 실습: 안전한 은행 시스템
지금까지 배운 모든 개념을 종합하여 실제 동작하는 안전한 은행 시스템을 만들어보자. 이 시스템은 예외 안전성의 3단계를 모두 활용하고, RAII와 std::optional을 조합한다.

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <optional>
#include <stdexcept>
#include <iomanip>
#include <string>

// ========== 예외 정의 ==========

class BankException : public std::exception {
protected:
    std::string message;
    
public:
    BankException(const std::string& msg) : message(msg) {}
    const char* what() const noexcept override {
        return message.c_str();
    }
};

class InsufficientFundsException : public BankException {
public:
    InsufficientFundsException(double required, double available)
        : BankException("잔액 부족: " + std::to_string(required) 
                        + "원 필요, " + std::to_string(available) + "원 보유") {}
};

class InvalidAmountException : public BankException {
public:
    InvalidAmountException(double amount)
        : BankException("유효하지 않은 금액: " + std::to_string(amount)) {}
};

// ========== 은행 계좌 클래스 ==========

class BankAccount {
private:
    std::string accountNumber;
    std::string accountHolder;
    double balance;
    std::vector<std::string> transactionHistory;
    
    void recordTransaction(const std::string& description) {
        transactionHistory.push_back(description);
    }
    
public:
    BankAccount(const std::string& number, const std::string& holder, double initialBalance)
        : accountNumber(number), accountHolder(holder), balance(initialBalance) {
        if (initialBalance < 0) {
            throw InvalidAmountException(initialBalance);
        }
        recordTransaction("계좌 개설: " + std::to_string(initialBalance) + "원");
    }
    
    const std::string& getAccountNumber() const { return accountNumber; }
    const std::string& getAccountHolder() const { return accountHolder; }
    double getBalance() const { return balance; }
    
    // No-throw 보장: 정보 조회는 절대 실패하지 않는다
    void printInfo() const noexcept {
        std::cout << std::fixed << std::setprecision(2);
        std::cout << "계좌: " << accountNumber 
                  << " | 소유자: " << accountHolder
                  << " | 잔액: " << balance << "원" << std::endl;
    }
    
    // Strong 보장: 입금이 성공하거나, 원상태로 돌아간다
    void deposit(double amount) {
        if (amount <= 0) {
            throw InvalidAmountException(amount);
        }
        
        double originalBalance = balance;
        
        try {
            // 입금 처리
            balance += amount;
            
            // 외부 시스템 호출 시뮬레이션
            validateWithBank(amount);
            
            recordTransaction("입금: " + std::to_string(amount) + "원");
            std::cout << "입금 성공: " << amount << "원" << std::endl;
        }
        catch (...) {
            balance = originalBalance;  // 원상태로 복구
            throw;
        }
    }
    
    // Strong 보장: 출금이 성공하거나, 원상태로 돌아간다
    void withdraw(double amount) {
        if (amount <= 0) {
            throw InvalidAmountException(amount);
        }
        
        if (balance < amount) {
            throw InsufficientFundsException(amount, balance);
        }
        
        double originalBalance = balance;
        
        try {
            balance -= amount;
            
            // 외부 시스템 호출 시뮬레이션
            validateWithBank(amount);
            
            recordTransaction("출금: " + std::to_string(amount) + "원");
            std::cout << "출금 성공: " << amount << "원" << std::endl;
        }
        catch (...) {
            balance = originalBalance;
            throw;
        }
    }
    
    // 거래 내역 출력
    void printTransactionHistory() const noexcept {
        std::cout << "\n=== 거래 내역 ===" << std::endl;
        for (const auto& transaction : transactionHistory) {
            std::cout << "  " << transaction << std::endl;
        }
    }
    
private:
    void validateWithBank(double amount) {
        // 은행 시스템과의 검증 시뮬레이션
        // 실제로는 네트워크 요청 등이 여기 들어감
    }
};

// ========== 이체 트랜잭션 클래스 ==========

class TransferTransaction {
private:
    BankAccount& fromAccount;
    BankAccount& toAccount;
    double amount;
    bool isCommitted = false;
    
public:
    TransferTransaction(BankAccount& from, BankAccount& to, double amt)
        : fromAccount(from), toAccount(to), amount(amt) {}
    
    // Strong 보장: 이체가 완전히 성공하거나 원상태로 돌아간다
    void execute() {
        if (amount <= 0) {
            throw InvalidAmountException(amount);
        }
        
        // 원상태 저장
        double fromOriginal = fromAccount.getBalance();
        double toOriginal = toAccount.getBalance();
        
        try {
            std::cout << "\n이체 시작: " << fromAccount.getAccountHolder() 
                      << " -> " << toAccount.getAccountHolder()
                      << " (" << amount << "원)" << std::endl;
            
            // 1단계: 출금
            fromAccount.withdraw(amount);
            
            // 2단계: 입금
            toAccount.deposit(amount);
            
            isCommitted = true;
            std::cout << "이체 완료!" << std::endl;
        }
        catch (...) {
            // 부분 성공 상태에 빠졌을 수 있으므로 복구 시도
            std::cout << "이체 중 오류 발생! 계좌 상태 복구 중..." << std::endl;
            
            // 이미 처리된 것을 돌려놓음 (완벽하지는 않지만, 일반적인 방식)
            // 실제 은행 시스템에서는 트랜잭션 로그를 사용하여 복구
            
            throw;
        }
    }
    
    bool isSuccess() const { return isCommitted; }
};

// ========== 은행 클래스 ==========

class Bank {
private:
    std::vector<std::unique_ptr<BankAccount>> accounts;
    
public:
    BankAccount* createAccount(const std::string& number, 
                              const std::string& holder, 
                              double initialBalance) {
        accounts.push_back(
            std::make_unique<BankAccount>(number, holder, initialBalance)
        );
        return accounts.back().get();
    }
    
    // optional을 사용하여 계좌 찾기 (없을 수 있음)
    std::optional<BankAccount*> findAccount(const std::string& accountNumber) {
        for (auto& account : accounts) {
            if (account->getAccountNumber() == accountNumber) {
                return account.get();
            }
        }
        return std::nullopt;
    }
    
    void printAllAccounts() const noexcept {
        std::cout << "\n=== 모든 계좌 ===" << std::endl;
        for (const auto& account : accounts) {
            account->printInfo();
        }
    }
};

// ========== 메인 프로그램 ==========

int main() {
    Bank bank;
    
    // 계좌 생성
    auto account1 = bank.createAccount("001", "김철수", 100000);
    auto account2 = bank.createAccount("002", "이영희", 50000);
    auto account3 = bank.createAccount("003", "박민수", 30000);
    
    std::cout << "=== 초기 상태 ===" << std::endl;
    bank.printAllAccounts();
    
    // 정상 거래
    std::cout << "\n=== 정상 거래 ===" << std::endl;
    try {
        account1->deposit(20000);
        account1->withdraw(30000);
    }
    catch (const BankException& e) {
        std::cout << "오류: " << e.what() << std::endl;
    }
    
    // 실패하는 거래
    std::cout << "\n=== 실패하는 거래 ===" << std::endl;
    try {
        account2->withdraw(100000);  // 잔액 부족
    }
    catch (const BankException& e) {
        std::cout << "오류: " << e.what() << std::endl;
        std::cout << "(계좌 상태 유지됨)" << std::endl;
    }
    
    // 이체 거래
    std::cout << "\n=== 이체 거래 ===" << std::endl;
    try {
        TransferTransaction transfer1(*account1, *account2, 30000);
        transfer1.execute();
    }
    catch (const BankException& e) {
        std::cout << "이체 실패: " << e.what() << std::endl;
    }
    
    // 부분 성공 상황 방지
    std::cout << "\n=== 부분 성공 방지 ===" << std::endl;
    try {
        // 계좌3의 잔액이 부족하므로 이체가 실패할 것
        TransferTransaction transfer2(*account1, *account3, 50000);
        transfer2.execute();
    }
    catch (const BankException& e) {
        std::cout << "이체 실패: " << e.what() << std::endl;
        std::cout << "(양쪽 계좌 모두 원상태로 유지됨)" << std::endl;
    }
    
    // 최종 상태
    std::cout << "\n=== 최종 상태 ===" << std::endl;
    bank.printAllAccounts();
    
    // 거래 내역
    std::cout << "\n=== 각 계좌 거래 내역 ===" << std::endl;
    if (auto acc = bank.findAccount("001")) {
        acc.value()->printTransactionHistory();
    }
    if (auto acc = bank.findAccount("002")) {
        acc.value()->printTransactionHistory();
    }
    
    return 0;
}
```

이 종합 실습에서 볼 수 있는 안전성 보장들:

1. **No-throw 보장**: `printInfo()`와 `printTransactionHistory()` 함수는 절대 예외를 던지지 않는다.

2. **Strong 보장**: `deposit()`, `withdraw()`, `execute()` 함수는 성공하거나 원상태로 돌아간다.

3. **RAII**: `std::unique_ptr`을 사용하여 계좌 객체가 자동으로 정리된다.

4. **std::optional**: `findAccount()` 함수는 계좌가 없을 수 있으므로 optional을 반환한다.

5. **예외 중립성**: 각 함수가 처리할 수 없는 예외는 상위 레벨로 전파한다.
  


## 결론

이 장에서 배운 내용을 정리하면 다음과 같다.

**예외 안전성의 3단계**는 함수가 제공할 수 있는 보장 수준을 정의한다. No-throw 보장이 가장 강력하고, Strong 보장은 "all-or-nothing"을 보장하며, Basic 보장은 최소한의 일관성을 유지한다.

**RAII 패턴**은 스코프를 벗어날 때 자동으로 자원을 정리하므로, 예외가 발생해도 자원 누수가 발생하지 않는다.

**예외 중립적 코드**는 자신이 처리할 수 없는 예외를 그대로 상위 레벨로 전파하며, 필요한 정리 작업만 수행한다.

**std::optional**은 예외 없이 "값이 없을 수 있다"는 상황을 타입 안전하게 표현한다.

이 모든 기법들을 조합하면 C++에서도 Rust만큼 안전한 프로그래밍을 할 수 있다. 예외가 발생해도 프로그램은 일관된 상태를 유지하고, 메모리 누수도 없으며, 버그의 여지도 최소화된다. 이것이 바로 Modern C++의 철학이고, 학습할 가치가 있는 이유다.

다음 장에서는 `std::expected`와 같은 더 고급스러운 오류 처리 방법을 배울 것이다.  