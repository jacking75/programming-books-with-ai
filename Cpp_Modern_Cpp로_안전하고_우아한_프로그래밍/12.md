# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 12: Modern C++ 동시성 기초
이 장에서는 C++의 동시성 기능에 대해 배울 것이다. 여러분이 "동시성"이라는 단어를 들으면 복잡하고 어려울 것이라고 생각할 수 있지만, Modern C++의 동시성 도구들은 생각보다 간단하고 안전하다.

동시성은 현대 프로그래밍에서 매우 중요하다. 스마트폰부터 서버까지 모든 장치가 멀티코어이고, 여러 작업을 동시에 처리해야 하기 때문이다. 하지만 여러 스레드가 같은 데이터에 접근할 때 발생하는 경쟁 조건(race condition)은 매우 위험할 수 있다.

다행히 Modern C++11 이후 표준 라이브러리에 `std::thread`, `std::mutex`, `std::lock_guard` 같은 도구들이 추가되었다. 이 도구들을 올바르게 사용하면 멀티스레드 프로그래밍을 안전하게 할 수 있고, 이는 Rust의 소유권 모델과 비슷한 수준의 안전성을 제공한다.
  


## 12.1 std::thread와 RAII 기반 스레드 관리

### 12.1.1 기본 스레드 생성과 관리
`std::thread`는 새로운 스레드를 생성하고 관리하는 클래스다. RAII 원칙을 따르므로, 스레드 객체의 소멸자가 자동으로 스레드를 정리한다.

```cpp
#include <iostream>
#include <thread>
#include <chrono>

// 스레드에서 실행할 함수
void workerFunction(int threadId) {
    std::cout << "스레드 " << threadId << " 시작" << std::endl;
    
    // 일어나는 작업을 시뮬레이션
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    std::cout << "스레드 " << threadId << " 종료" << std::endl;
}

// 매개변수를 받는 워커 함수
void addNumbers(int a, int b, int& result) {
    result = a + b;
    std::cout << a << " + " << b << " = " << result << std::endl;
}

int main() {
    std::cout << "=== 기본 스레드 생성 ===" << std::endl;
    
    // 스레드 생성 및 실행
    std::thread t1(workerFunction, 1);
    std::thread t2(workerFunction, 2);
    std::thread t3(workerFunction, 3);
    
    std::cout << "메인 스레드: 모든 워커 스레드를 대기중..." << std::endl;
    
    // 스레드 종료 대기 (join)
    t1.join();
    t2.join();
    t3.join();
    
    std::cout << "메인 스레드: 모든 워커 스레드 완료" << std::endl;
    
    // 람다 함수를 사용한 스레드 생성
    std::cout << "\n=== 람다 함수를 사용한 스레드 ===" << std::endl;
    
    int result = 0;
    std::thread t4([&result]() {
        result = 10 + 20;
        std::cout << "람다 함수: 10 + 20 = " << result << std::endl;
    });
    
    t4.join();
    std::cout << "메인 스레드에서 결과 확인: " << result << std::endl;
    
    return 0;
}
```

이 코드에서 중요한 점은 `join()`을 반드시 호출해야 한다는 것이다. `join()`을 호출하지 않으면 프로그램이 종료될 때 예외가 발생한다.

### 12.1.2 RAII를 사용한 안전한 스레드 관리
매번 `join()`을 수동으로 호출하는 것은 위험할 수 있다. RAII 패턴을 사용하여 자동으로 정리되도록 하자.

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <vector>

// RAII 패턴을 따르는 스레드 래퍼
class ThreadGuard {
private:
    std::thread thread;
    
public:
    template <typename Function, typename... Args>
    ThreadGuard(Function&& func, Args&&... args)
        : thread(std::forward<Function>(func), std::forward<Args>(args)...) {}
    
    // 복사 방지
    ThreadGuard(const ThreadGuard&) = delete;
    ThreadGuard& operator=(const ThreadGuard&) = delete;
    
    // 이동 가능
    ThreadGuard(ThreadGuard&& other) noexcept = default;
    ThreadGuard& operator=(ThreadGuard&& other) noexcept = default;
    
    // 소멸자에서 자동으로 join 호출
    ~ThreadGuard() {
        if (thread.joinable()) {
            thread.join();
        }
    }
};

void taskA() {
    std::cout << "작업 A 시작" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(300));
    std::cout << "작업 A 완료" << std::endl;
}

void taskB() {
    std::cout << "작업 B 시작" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    std::cout << "작업 B 완료" << std::endl;
}

void taskC() {
    std::cout << "작업 C 시작" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    std::cout << "작업 C 완료" << std::endl;
}

int main() {
    std::cout << "=== ThreadGuard를 사용한 안전한 스레드 관리 ===" << std::endl;
    
    {
        // 스코프 내에서 스레드 생성
        ThreadGuard t1(taskA);
        ThreadGuard t2(taskB);
        ThreadGuard t3(taskC);
        
        std::cout << "메인: 모든 스레드가 생성되었습니다" << std::endl;
        
        // 스코프를 벗어나면서 모든 스레드가 자동으로 join된다
    }  // 여기서 모든 ThreadGuard의 소멸자가 호출됨
    
    std::cout << "메인: 모든 스레드 완료" << std::endl;
    
    return 0;
}
```

이 구현의 핵심은 소멸자에서 `join()`을 호출한다는 것이다. 이렇게 하면 예외가 발생해도 스레드가 안전하게 정리된다.

### 12.1.3 여러 스레드를 관리하는 풀
실무에서는 여러 스레드를 함께 관리해야 할 경우가 많다. 벡터를 사용하여 여러 스레드를 관리해보자.

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>

// 목적: 여러 스레드를 생성하고 관리하는 방법을 보여준다
// 각 스레드는 독립적인 작업을 수행하고, 메인 스레드는 모든 워커 스레드를 대기한다

void worker(int id, int iterations) {
    for (int i = 0; i < iterations; ++i) {
        std::cout << "워커 " << id << ": 반복 " << i + 1 << "/" << iterations << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    std::cout << "워커 " << id << ": 완료" << std::endl;
}

int main() {
    std::cout << "=== 여러 스레드 풀 관리 ===" << std::endl;
    
    const int numWorkers = 4;
    const int iterationsPerWorker = 3;
    
    // 스레드를 저장할 벡터
    std::vector<std::thread> workers;
    workers.reserve(numWorkers);
    
    // 워커 스레드 생성
    std::cout << "워커 스레드 생성 중..." << std::endl;
    for (int i = 0; i < numWorkers; ++i) {
        workers.emplace_back(worker, i, iterationsPerWorker);
    }
    
    std::cout << "메인: " << numWorkers << "개의 워커 스레드 생성 완료" << std::endl;
    std::cout << "메인: 모든 워커 스레드를 대기 중..." << std::endl;
    
    // 모든 워커 스레드의 종료를 대기
    for (auto& t : workers) {
        if (t.joinable()) {
            t.join();
        }
    }
    
    std::cout << "메인: 모든 워커 스레드 완료" << std::endl;
    
    return 0;
}
```

이 코드의 목적을 설명하면:
1. `workers` 벡터에 `numWorkers`개의 스레드를 생성한다.
2. 각 스레드는 `worker` 함수를 실행하고, 자신의 ID와 반복 횟수를 받는다.
3. 메인 스레드는 모든 워커 스레드의 종료를 대기한다.
4. 이 패턴은 실무에서 작업 풀을 관리할 때 자주 사용된다.
 


## 12.2 mutex, lock_guard, unique_lock 완벽 활용

### 12.2.1 뮤텍스와 보호된 자원
여러 스레드가 같은 데이터에 접근할 때는 `std::mutex`를 사용하여 접근을 동기화해야 한다.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <chrono>

// 목적: 여러 스레드가 같은 자원에 안전하게 접근하는 방법을 보여준다
// mutex를 사용하여 critical section을 보호한다

class BankAccount {
private:
    int balance = 1000;
    mutable std::mutex balanceMutex;
    
public:
    // 뮤텍스로 보호된 출금
    void withdraw(int amount) {
        std::lock_guard<std::mutex> lock(balanceMutex);
        
        if (balance >= amount) {
            // 잔액 확인
            std::cout << "출금 전 잔액: " << balance << "원" << std::endl;
            
            // 출금 처리를 시뮬레이션 (약간의 지연)
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            
            balance -= amount;
            std::cout << "출금 후 잔액: " << balance << "원" << std::endl;
        } else {
            std::cout << "잔액 부족!" << std::endl;
        }
    }
    
    // 뮤텍스로 보호된 입금
    void deposit(int amount) {
        std::lock_guard<std::mutex> lock(balanceMutex);
        
        std::cout << "입금 전 잔액: " << balance << "원" << std::endl;
        
        // 입금 처리를 시뮬레이션
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        
        balance += amount;
        std::cout << "입금 후 잔액: " << balance << "원" << std::endl;
    }
    
    // 뮤텍스로 보호된 잔액 조회
    int getBalance() const {
        std::lock_guard<std::mutex> lock(balanceMutex);
        return balance;
    }
};

void transferThread(BankAccount& account, int amount) {
    for (int i = 0; i < 3; ++i) {
        if (i % 2 == 0) {
            std::cout << "스레드 " << std::this_thread::get_id() 
                      << ": " << amount << "원 입금" << std::endl;
            account.deposit(amount);
        } else {
            std::cout << "스레드 " << std::this_thread::get_id() 
                      << ": " << amount << "원 출금" << std::endl;
            account.withdraw(amount);
        }
    }
}

int main() {
    std::cout << "=== mutex를 사용한 스레드 안전성 ===" << std::endl;
    
    BankAccount account;
    
    // 여러 스레드가 동시에 계좌에 접근
    std::thread t1(transferThread, std::ref(account), 100);
    std::thread t2(transferThread, std::ref(account), 200);
    std::thread t3(transferThread, std::ref(account), 150);
    
    t1.join();
    t2.join();
    t3.join();
    
    std::cout << "\n최종 잔액: " << account.getBalance() << "원" << std::endl;
    
    return 0;
}
```

이 코드에서 중요한 점들:
1. `std::lock_guard<std::mutex>`는 RAII 패턴을 따르므로, 스코프를 벗어나면 자동으로 잠금을 해제한다.
2. 예외가 발생해도 잠금이 정확히 해제되므로 데드락이 발생하지 않는다.
3. `getBalance()`는 `mutable`로 선언된 뮤텍스를 const 함수에서 사용할 수 있다.

### 12.2.2 lock_guard vs unique_lock
`std::lock_guard`는 간단하지만, `std::unique_lock`은 더 유연한 제어를 제공한다.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

// 목적: lock_guard와 unique_lock의 차이점을 보여준다
// unique_lock은 early unlock, try_lock 등의 추가 기능을 제공한다

class Resource {
private:
    std::string data = "초기 데이터";
    mutable std::mutex resourceMutex;
    
public:
    // lock_guard 사용: 간단하고 일반적인 경우
    void readWithLockGuard() const {
        std::lock_guard<std::mutex> lock(resourceMutex);
        std::cout << "lock_guard로 읽음: " << data << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    // unique_lock 사용: 유연한 제어가 필요한 경우
    void updateWithUniqueLock(const std::string& newData) {
        std::unique_lock<std::mutex> lock(resourceMutex);
        
        std::cout << "업데이트 시작: " << data << " -> " << newData << std::endl;
        
        // 임시로 잠금을 해제하고 다른 작업 수행
        lock.unlock();
        std::cout << "잠금 해제 상태에서 다른 작업 수행" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        
        // 다시 잠금
        lock.lock();
        std::cout << "다시 잠금" << std::endl;
        
        data = newData;
        std::cout << "업데이트 완료" << std::endl;
    }
    
    // try_lock 사용: 논블로킹 잠금 시도
    bool tryUpdate(const std::string& newData, int timeoutMs = 100) {
        std::unique_lock<std::mutex> lock(resourceMutex, std::defer_lock);
        
        // try_lock_for를 사용하여 지정된 시간만큼 잠금을 시도
        if (!lock.try_lock_for(std::chrono::milliseconds(timeoutMs))) {
            std::cout << "잠금 시도 실패 (타임아웃)" << std::endl;
            return false;
        }
        
        data = newData;
        std::cout << "tryUpdate 성공" << std::endl;
        return true;
    }
    
    std::string getData() const {
        std::lock_guard<std::mutex> lock(resourceMutex);
        return data;
    }
};

void slowWorker(Resource& resource) {
    for (int i = 0; i < 2; ++i) {
        std::cout << "슬로우 워커: 데이터 읽음" << std::endl;
        resource.readWithLockGuard();
    }
}

void fastWorker(Resource& resource) {
    for (int i = 0; i < 3; ++i) {
        if (resource.tryUpdate("새 데이터 " + std::to_string(i))) {
            std::cout << "패스트 워커: 업데이트 성공" << std::endl;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

int main() {
    std::cout << "=== lock_guard vs unique_lock ===" << std::endl;
    
    Resource resource;
    
    // lock_guard를 사용한 읽기
    std::cout << "\n1. lock_guard를 사용한 읽기:" << std::endl;
    resource.readWithLockGuard();
    
    // unique_lock을 사용한 유연한 업데이트
    std::cout << "\n2. unique_lock을 사용한 유연한 제어:" << std::endl;
    resource.updateWithUniqueLock("업데이트된 데이터");
    
    // try_lock을 사용한 논블로킹 시도
    std::cout << "\n3. try_lock을 사용한 논블로킹 시도:" << std::endl;
    resource.tryUpdate("또 다른 데이터");
    
    // 여러 스레드에서 동시 접근
    std::cout << "\n4. 여러 스레드에서의 동시 접근:" << std::endl;
    std::thread slowReader(slowWorker, std::ref(resource));
    std::thread fastUpdater(fastWorker, std::ref(resource));
    
    slowReader.join();
    fastUpdater.join();
    
    std::cout << "\n최종 데이터: " << resource.getData() << std::endl;
    
    return 0;
}
```

이 코드의 주요 차이점:
1. **lock_guard**: 생성 시점에 자동으로 잠금, 소멸 시점에 자동으로 해제. 간단하지만 중간에 해제 불가.
2. **unique_lock**: `lock()`, `unlock()`, `try_lock()` 등의 메서드를 제공하여 더 유연한 제어 가능.
3. **defer_lock**: 생성 시점에는 잠금하지 않고, 나중에 `lock()`을 호출하여 잠금.

### 12.2.3 shared_mutex를 사용한 읽기-쓰기 분리
많은 읽기와 적은 쓰기가 있는 상황에서는 `std::shared_mutex`를 사용하여 성능을 개선할 수 있다.

```cpp
#include <iostream>
#include <thread>
#include <shared_mutex>
#include <vector>
#include <chrono>

// 목적: shared_mutex를 사용하여 여러 읽기 스레드를 동시에 허용하면서
// 쓰기 스레드는 배타적으로 접근하는 방법을 보여준다

class ReadWriteData {
private:
    std::vector<int> data;
    mutable std::shared_mutex dataMutex;
    
public:
    ReadWriteData() : data({1, 2, 3, 4, 5}) {}
    
    // 읽기: 여러 스레드가 동시에 접근 가능
    void read() const {
        std::shared_lock<std::shared_mutex> lock(dataMutex);
        
        std::cout << "읽기 스레드 " << std::this_thread::get_id() << ": ";
        for (int value : data) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
        
        // 읽기 작업을 시뮬레이션
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    // 쓰기: 오직 한 스레드만 접근 가능
    void write(int newValue) {
        std::unique_lock<std::shared_mutex> lock(dataMutex);
        
        std::cout << "쓰기 스레드 " << std::this_thread::get_id() 
                  << ": " << newValue << " 추가" << std::endl;
        
        data.push_back(newValue);
        
        // 쓰기 작업을 시뮬레이션
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        
        std::cout << "쓰기 스레드 " << std::this_thread::get_id() << ": 완료" << std::endl;
    }
};

void readerWorker(const ReadWriteData& data, int id) {
    for (int i = 0; i < 3; ++i) {
        std::cout << "읽기 워커 " << id << " (반복 " << i + 1 << ")" << std::endl;
        data.read();
    }
}

void writerWorker(ReadWriteData& data, int value) {
    data.write(value);
}

int main() {
    std::cout << "=== shared_mutex를 사용한 읽기-쓰기 분리 ===" << std::endl;
    
    ReadWriteData data;
    
    // 여러 읽기 워커와 쓰기 워커 생성
    std::vector<std::thread> threads;
    
    // 3개의 읽기 워커 생성 (동시에 실행 가능)
    threads.emplace_back(readerWorker, std::cref(data), 1);
    threads.emplace_back(readerWorker, std::cref(data), 2);
    
    // 1개의 쓰기 워커 (다른 스레드와 배타적으로 실행)
    threads.emplace_back(writerWorker, std::ref(data), 10);
    
    // 2개의 읽기 워커 추가
    threads.emplace_back(readerWorker, std::cref(data), 3);
    threads.emplace_back(readerWorker, std::cref(data), 4);
    
    // 1개의 쓰기 워커 추가
    threads.emplace_back(writerWorker, std::ref(data), 20);
    
    // 모든 스레드 대기
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "\n모든 스레드 완료" << std::endl;
    
    return 0;
}
```

이 코드의 핵심:
1. `shared_lock`을 사용한 읽기는 여러 스레드가 동시에 수행 가능.
2. `unique_lock`을 사용한 쓰기는 오직 한 스레드만 실행 가능.
3. 읽기가 많고 쓰기가 적은 상황에서 성능이 크게 향상된다.
  


## 12.3 데드락 방지 전략과 패턴

### 12.3.1 데드락의 원인과 피하는 방법
데드락은 두 개 이상의 스레드가 서로가 해제하기를 기다리면서 무한 대기 상태에 빠지는 것이다. 이를 방지하는 여러 전략이 있다.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

// 목적: 데드락의 원인을 보여주고, 피하는 방법을 설명한다

// ========== 데드락이 발생하는 나쁜 예제 ==========

class BadBankAccount {
public:
    int balance = 1000;
    mutable std::mutex balanceMutex;
};

// 이 함수는 데드락을 유발할 수 있다
void unsafeTransfer(BadBankAccount& from, BadBankAccount& to, int amount) {
    // 스레드1: from 잠금 후 to 잠금
    // 스레드2: to 잠금 후 from 잠금
    // -> 데드락!
    
    std::lock_guard<std::mutex> lock1(from.balanceMutex);
    std::this_thread::sleep_for(std::chrono::milliseconds(100));  // 데드락 유발 가능성
    std::lock_guard<std::mutex> lock2(to.balanceMutex);
    
    from.balance -= amount;
    to.balance += amount;
    std::cout << "이체 완료" << std::endl;
}

// ========== 데드락을 방지하는 좋은 예제 ==========

class SafeBankAccount {
public:
    int id;  // 계좌 ID (정렬 순서 결정)
    int balance = 1000;
    mutable std::mutex balanceMutex;
    
    SafeBankAccount(int accountId) : id(accountId) {}
};

// 항상 ID가 작은 계좌부터 잠금 (순서 보장)
void safeTransfer(SafeBankAccount& from, SafeBankAccount& to, int amount) {
    // 항상 같은 순서로 잠금 -> 데드락 방지
    SafeBankAccount& first = (from.id < to.id) ? from : to;
    SafeBankAccount& second = (from.id < to.id) ? to : from;
    
    std::lock_guard<std::mutex> lock1(first.balanceMutex);
    std::lock_guard<std::mutex> lock2(second.balanceMutex);
    
    from.balance -= amount;
    to.balance += amount;
    std::cout << "안전한 이체 완료" << std::endl;
}

// ========== std::lock을 사용한 데드락 방지 ==========

void safeTransferWithStdLock(SafeBankAccount& from, SafeBankAccount& to, int amount) {
    // std::lock은 여러 뮤텍스를 안전하게 잠금
    std::lock(from.balanceMutex, to.balanceMutex);
    
    std::lock_guard<std::mutex> lock1(from.balanceMutex, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(to.balanceMutex, std::adopt_lock);
    
    from.balance -= amount;
    to.balance += amount;
    std::cout << "std::lock을 사용한 이체 완료" << std::endl;
}

int main() {
    std::cout << "=== 데드락 방지 전략 ===" << std::endl;
    
    // 안전한 이체
    std::cout << "\n1. ID 기반 순서 보장으로 데드락 방지:" << std::endl;
    SafeBankAccount account1(1);  // ID=1
    SafeBankAccount account2(2);  // ID=2
    account1.balance = 1000;
    account2.balance = 500;
    
    std::thread t1(safeTransfer, std::ref(account1), std::ref(account2), 100);
    std::thread t2(safeTransfer, std::ref(account2), std::ref(account1), 50);
    
    t1.join();
    t2.join();
    
    std::cout << "계좌1 잔액: " << account1.balance << std::endl;
    std::cout << "계좌2 잔액: " << account2.balance << std::endl;
    
    // std::lock 사용
    std::cout << "\n2. std::lock을 사용한 데드락 방지:" << std::endl;
    SafeBankAccount account3(3);
    SafeBankAccount account4(4);
    account3.balance = 1000;
    account4.balance = 500;
    
    std::thread t3(safeTransferWithStdLock, std::ref(account3), std::ref(account4), 200);
    std::thread t4(safeTransferWithStdLock, std::ref(account4), std::ref(account3), 100);
    
    t3.join();
    t4.join();
    
    std::cout << "계좌3 잔액: " << account3.balance << std::endl;
    std::cout << "계좌4 잔액: " << account4.balance << std::endl;
    
    return 0;
}
```

이 코드의 핵심 전략:
1. **순서 보장**: 항상 같은 순서로 뮤텍스를 잠금하면 데드락을 방지할 수 있다.
2. **std::lock**: 여러 뮤텍스를 안전하게 동시에 잠금할 수 있다.
3. **adopt_lock**: 이미 잠긴 뮤텍스를 lock_guard에 전달할 때 사용한다.
 
### 12.3.2 스코프 기반 데드락 방지
RAII 패턴을 사용하여 자동으로 데드락을 방지할 수 있다.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

// 목적: 스코프를 활용하여 자동으로 데드락을 방지하는 메커니즘을 보여준다
// 뮤텍스를 미니 스코프에서만 보유하고, 필요 없으면 해제한다

class CriticalResource {
private:
    std::string data;
    mutable std::mutex mutex;
    
public:
    CriticalResource() : data("초기 데이터") {}
    
    // 미니 스코프를 사용하여 잠금 시간을 최소화
    void update(const std::string& newData) {
        std::cout << "업데이트 시작" << std::endl;
        
        // 긴 작업 (잠금 불필요)
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        {
            // 미니 스코프: 최소 시간 동안만 잠금
            std::lock_guard<std::mutex> lock(mutex);
            std::cout << "잠금 획득" << std::endl;
            data = newData;
            std::cout << "데이터 업데이트" << std::endl;
            // 스코프를 벗어나면서 잠금 자동 해제
        }
        
        // 잠금 해제 후 다른 작업
        std::cout << "잠금 해제 후 작업 수행" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        
        std::cout << "업데이트 완료" << std::endl;
    }
    
    std::string read() const {
        std::lock_guard<std::mutex> lock(mutex);
        return data;
    }
};

void worker1(CriticalResource& resource) {
    for (int i = 0; i < 2; ++i) {
        std::cout << "\n워커1: 데이터 읽기" << std::endl;
        std::string data = resource.read();
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

void worker2(CriticalResource& resource) {
    for (int i = 0; i < 2; ++i) {
        std::cout << "\n워커2: 데이터 업데이트 " << i << std::endl;
        resource.update("새 데이터 " + std::to_string(i));
    }
}

int main() {
    std::cout << "=== 스코프 기반 데드락 방지 ===" << std::endl;
    
    CriticalResource resource;
    
    std::thread t1(worker1, std::ref(resource));
    std::thread t2(worker2, std::ref(resource));
    
    t1.join();
    t2.join();
    
    std::cout << "\n최종 데이터: " << resource.read() << std::endl;
    
    return 0;
}
```

이 패턴의 장점:
1. 뮤텍스를 최소 시간 동안만 보유하므로 경합을 줄인다.
2. RAII 패턴으로 자동 해제되어 실수가 적다.
3. 예외 발생 시에도 안전하게 해제된다.
  


## 12.4 atomic 연산과 메모리 모델

### 12.4.1 std::atomic의 기초
`std::atomic`은 락 없이 원자적 연산을 수행한다. 이는 뮤텍스보다 훨씬 빠르고 가벼우므로 카운터나 플래그를 다룰 때 적합하다.

```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <vector>
#include <chrono>

// 목적: atomic을 사용하여 락 없이 안전하게 공유 변수를 다루는 방법을 보여준다

class AtomicCounter {
private:
    std::atomic<int> count{0};
    
public:
    void increment() {
        count++;  // 원자적 연산
    }
    
    void decrement() {
        count--;  // 원자적 연산
    }
    
    int getCount() const {
        return count.load();  // 원자적 읽기
    }
    
    // 교환 연산 (Compare And Swap)
    int getAndReset() {
        return count.exchange(0);
    }
};

class AtomicFlag {
private:
    std::atomic<bool> flag{false};
    
public:
    void setFlag() {
        flag.store(true);
    }
    
    void clearFlag() {
        flag.store(false);
    }
    
    bool getFlag() const {
        return flag.load();
    }
};

void incrementer(AtomicCounter& counter, int iterations) {
    for (int i = 0; i < iterations; ++i) {
        counter.increment();
    }
}

void decrementJob(AtomicCounter& counter) {
    for (int i = 0; i < 10; ++i) {
        counter.decrement();
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

int main() {
    std::cout << "=== std::atomic을 사용한 락 없는 동기화 ===" << std::endl;
    
    // atomic 카운터 테스트
    std::cout << "\n1. Atomic 카운터:" << std::endl;
    AtomicCounter counter;
    
    std::vector<std::thread> threads;
    const int threadsPerType = 4;
    const int increments = 1000;
    
    // 증가 스레드들 생성
    for (int i = 0; i < threadsPerType; ++i) {
        threads.emplace_back(incrementer, std::ref(counter), increments);
    }
    
    // 감소 스레드들 생성
    for (int i = 0; i < threadsPerType / 2; ++i) {
        threads.emplace_back(decrementJob, std::ref(counter));
    }
    
    // 모든 스레드 대기
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "최종 카운트: " << counter.getCount() << std::endl;
    std::cout << "(기대값: " << (threadsPerType * increments - threadsPerType / 2 * 10) << ")" << std::endl;
    
    // atomic 플래그 테스트
    std::cout << "\n2. Atomic 플래그:" << std::endl;
    AtomicFlag flag;
    
    std::thread setter([&flag]() {
        for (int i = 0; i < 3; ++i) {
            std::cout << "플래그 설정" << std::endl;
            flag.setFlag();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::cout << "플래그 해제" << std::endl;
            flag.clearFlag();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    });
    
    std::thread checker([&flag]() {
        for (int i = 0; i < 10; ++i) {
            if (flag.getFlag()) {
                std::cout << "플래그가 설정되어 있습니다" << std::endl;
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    });
    
    setter.join();
    checker.join();
    
    return 0;
}
```

### 12.4.2 메모리 순서 (Memory Ordering)
`std::atomic`의 강력한 기능 중 하나는 메모리 순서를 명시적으로 제어하는 것이다. 이는 성능과 정확성의 균형을 맞추는 데 중요하다.

```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <chrono>

// 목적: 메모리 순서의 중요성과 다양한 메모리 순서 옵션을 보여준다
// relaxed, release-acquire, sequential consistency 등의 차이를 설명한다

class SpinLock {
private:
    std::atomic<bool> locked{false};
    
public:
    // acquire 의미론을 사용한 잠금
    void lock() {
        // compare_exchange_strong을 사용하여 더 강한 동기화 보장
        while (locked.exchange(true, std::memory_order_acquire)) {
            // 잠금이 해제될 때까지 대기
            std::this_thread::sleep_for(std::chrono::microseconds(1));
        }
    }
    
    // release 의미론을 사용한 해제
    void unlock() {
        locked.store(false, std::memory_order_release);
    }
};

class ProducerConsumer {
private:
    std::atomic<int> data{0};
    std::atomic<bool> ready{false};
    
public:
    void produce() {
        data.store(42, std::memory_order_relaxed);
        ready.store(true, std::memory_order_release);  // 다른 스레드에게 신호
    }
    
    void consume() {
        while (!ready.load(std::memory_order_acquire)) {  // 신호 대기
            std::this_thread::sleep_for(std::chrono::microseconds(100));
        }
        int value = data.load(std::memory_order_relaxed);
        std::cout << "받은 데이터: " << value << std::endl;
    }
};

int main() {
    std::cout << "=== 메모리 순서 (Memory Ordering) ===" << std::endl;
    
    // SpinLock 사용
    std::cout << "\n1. SpinLock을 사용한 동기화:" << std::endl;
    SpinLock spinlock;
    int sharedCounter = 0;
    
    std::thread locker1([&]() {
        for (int i = 0; i < 3; ++i) {
            spinlock.lock();
            sharedCounter++;
            std::cout << "스레드1: 카운터 = " << sharedCounter << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            spinlock.unlock();
        }
    });
    
    std::thread locker2([&]() {
        for (int i = 0; i < 3; ++i) {
            spinlock.lock();
            sharedCounter++;
            std::cout << "스레드2: 카운터 = " << sharedCounter << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            spinlock.unlock();
        }
    });
    
    locker1.join();
    locker2.join();
    
    // ProducerConsumer 사용
    std::cout << "\n2. Release-Acquire 의미론을 사용한 동기화:" << std::endl;
    ProducerConsumer pc;
    
    std::thread producer([&pc]() {
        std::cout << "생산자: 데이터 생성 중..." << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        pc.produce();
    });
    
    std::thread consumer([&pc]() {
        std::cout << "소비자: 데이터 대기 중..." << std::endl;
        pc.consume();
    });
    
    producer.join();
    consumer.join();
    
    return 0;
}
```

메모리 순서의 종류와 역할:
1. **memory_order_relaxed**: 가장 빠르지만 동기화 보장 없음. 순수 원자성만 필요할 때.
2. **memory_order_acquire/release**: 경량 동기화. acquire는 이전 writes를 기다리고, release는 이후 reads를 기다리게 함.
3. **memory_order_acq_rel**: acquire와 release를 동시에 적용.
4. **memory_order_seq_cst**: 가장 강한 보장. 모든 동기화를 순차적으로 처리.
  


## 12.5 종합 실습: 스레드 안전한 큐
지금까지 배운 모든 동시성 기법을 종합하여 스레드 안전한 큐를 만들어보자.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <memory>
#include <chrono>
#include <vector>

// 목적: 이 코드는 Thread-Safe Queue를 구현한다.
// 목적:
// 1. 여러 스레드가 동시에 push/pop할 수 있다
// 2. pop할 데이터가 없으면 스레드는 대기한다
// 3. push 시 대기 중인 스레드를 깨운다
// 4. RAII 패턴으로 자동 정리된다

// 스레드 안전한 큐
template <typename T>
class ThreadSafeQueue {
private:
    mutable std::mutex queueMutex;
    std::queue<T> queue;
    std::condition_variable condVar;
    
public:
    ThreadSafeQueue() = default;
    
    // 복사 방지
    ThreadSafeQueue(const ThreadSafeQueue&) = delete;
    ThreadSafeQueue& operator=(const ThreadSafeQueue&) = delete;
    
    // 큐에 항목 추가
    void push(T value) {
        {
            std::lock_guard<std::mutex> lock(queueMutex);
            queue.push(std::move(value));
        }
        // 잠금 해제 후 다른 스레드 깨우기
        condVar.notify_one();
    }
    
    // 큐에서 항목 제거 (대기 가능)
    bool tryPop(T& value, std::chrono::milliseconds timeout = std::chrono::milliseconds(0)) {
        std::unique_lock<std::mutex> lock(queueMutex);
        
        // 큐가 비어있으면 대기
        if (!condVar.wait_for(lock, timeout, [this]() { return !queue.empty(); })) {
            return false;  // 타임아웃
        }
        
        value = std::move(queue.front());
        queue.pop();
        return true;
    }
    
    // 큐의 크기
    size_t size() const {
        std::lock_guard<std::mutex> lock(queueMutex);
        return queue.size();
    }
    
    // 큐가 비었는지 확인
    bool empty() const {
        std::lock_guard<std::mutex> lock(queueMutex);
        return queue.empty();
    }
};

// 생산자 스레드
void producer(ThreadSafeQueue<int>& queue, int producerId, int itemCount) {
    for (int i = 0; i < itemCount; ++i) {
        int value = producerId * 1000 + i;
        std::cout << "생산자 " << producerId << ": " << value << " 추가" << std::endl;
        queue.push(value);
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
    std::cout << "생산자 " << producerId << ": 완료" << std::endl;
}

// 소비자 스레드
void consumer(ThreadSafeQueue<int>& queue, int consumerId, int expectedCount) {
    int consumed = 0;
    
    while (consumed < expectedCount) {
        int value;
        if (queue.tryPop(value, std::chrono::milliseconds(500))) {
            std::cout << "소비자 " << consumerId << ": " << value << " 처리" << std::endl;
            consumed++;
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        } else {
            std::cout << "소비자 " << consumerId << ": 타임아웃 대기" << std::endl;
        }
    }
    std::cout << "소비자 " << consumerId << ": 완료 (총 " << consumed << "개 처리)" << std::endl;
}

int main() {
    std::cout << "=== 스레드 안전한 큐 ===" << std::endl;
    
    ThreadSafeQueue<int> queue;
    
    const int producerCount = 2;
    const int itemsPerProducer = 5;
    const int consumerCount = 3;
    const int totalItems = producerCount * itemsPerProducer;
    
    std::vector<std::thread> threads;
    
    // 생산자 스레드 생성
    std::cout << "\n생산자 스레드 생성:" << std::endl;
    for (int i = 0; i < producerCount; ++i) {
        threads.emplace_back(producer, std::ref(queue), i, itemsPerProducer);
    }
    
    // 소비자 스레드 생성
    std::cout << "\n소비자 스레드 생성:" << std::endl;
    for (int i = 0; i < consumerCount; ++i) {
        threads.emplace_back(consumer, std::ref(queue), i, totalItems / consumerCount);
    }
    
    // 모든 스레드 대기
    std::cout << "\n모든 스레드 대기 중..." << std::endl;
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "\n최종 큐 상태:" << std::endl;
    std::cout << "큐의 크기: " << queue.size() << std::endl;
    std::cout << "큐가 비었는가: " << (queue.empty() ? "예" : "아니오") << std::endl;
    
    return 0;
}
```

이 ThreadSafeQueue의 핵심 기능들:

1. **std::mutex와 std::lock_guard**: 공유 자원 보호
2. **std::condition_variable**: 스레드 간 신호 전달
3. **std::move**: 효율적인 데이터 이동
4. **RAII**: 자동 자원 정리
5. **템플릿**: 다양한 타입 지원
  


## 결론
이 장에서 배운 내용을 정리하면 다음과 같다.

**std::thread**를 사용하면 간단하게 스레드를 생성하고 관리할 수 있다. RAII 패턴을 따르므로 안전하다.

**std::mutex와 std::lock_guard**는 뮤텍스를 안전하게 관리한다. lock_guard는 간단하고, unique_lock은 더 유연한 제어를 제공한다.

**데드락 방지**는 항상 같은 순서로 뮤텍스를 잠금하거나, std::lock을 사용하여 보장할 수 있다.

**std::atomic**은 락 없이 원자적 연산을 수행하므로 카운터나 플래그에 적합하다. 메모리 순서를 명시적으로 제어할 수 있다.

이러한 도구들을 조합하면 C++에서도 Rust만큼 안전한 동시성 프로그래밍을 할 수 있다. Modern C++의 동시성 기능들은 저수준의 세부 사항을 숨기면서도 충분한 제어를 제공한다.

다음 장에서는 std::future, std::promise 그리고 C++20의 coroutines 같은 고급 동시성 패턴을 배울 것이다.  