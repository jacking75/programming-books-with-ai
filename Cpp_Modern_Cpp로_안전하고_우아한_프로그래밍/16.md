# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 16: 게임 엔진 컴포넌트 개발
게임 엔진은 C++의 성능과 안전성이 동시에 요구되는 영역이다. 실시간으로 동작해야 하면서도 메모리 안전성을 보장해야 하고, 수천 개의 게임 오브젝트를 효율적으로 관리해야 한다. 이 장에서는 Modern C++을 활용하여 안전하고 효율적인 게임 엔진 컴포넌트를 어떻게 설계하고 구현하는지 살펴본다.

## 16.1 메모리 풀과 커스텀 할당자
게임 엔진에서는 매 프레임마다 수많은 객체가 생성되고 소멸된다. 일반적인 동적 할당(`new`/`delete`)을 사용하면 할당 해제 오버헤드로 인해 성능이 저하되고, 메모리 단편화도 발생한다. 이러한 문제를 해결하기 위해 메모리 풀 패턴을 사용한다.

메모리 풀은 미리 일정량의 메모리를 할당해두었다가 필요할 때 재사용하는 기법이다. 이렇게 하면 할당 해제 비용을 거의 0에 가깝게 줄일 수 있고, 메모리 접근 패턴도 캐시 친화적이 된다.

먼저 간단한 메모리 풀의 구현을 살펴보자.

```cpp
#include <vector>       // std::vector를 사용하기 위해 포함 (memory_chunks_ 멤버)
#include <cstring>      // (이 코드에서는 실제로 사용되지 않았습니다)
#include <cassert>      // assert() 매크로를 사용하기 위해 포함 (디버깅용 검증)
#include <memory>       // std::unique_ptr, std::make_unique를 사용하기 위해 포함 (자동 메모리 관리)

// 고정된 크기의 메모리 블록을 관리하는 메모리 풀 클래스
class MemoryPool {
private:
    // '사용 가능한' 메모리 블록들을 연결 리스트(linked list)로 관리하기 위한 구조체입니다.
    // 이 구조체는 실제 메모리 블록의 시작 부분에 겹쳐져서 저장됩니다.
    struct Block {
        Block* next; // 다음 '사용 가능한' 블록을 가리키는 포인터
    };

    Block* free_list_; // 현재 사용 가능한 블록(free list)의 시작(헤드) 포인터

    // 시스템으로부터 할당받은 큰 메모리 덩어리('청크')들을 저장하는 벡터입니다.
    // unique_ptr<char[]>를 사용하여 MemoryPool 객체가 소멸될 때
    // 자동으로 모든 청크 메모리가 해제되도록 합니다.
    std::vector<std::unique_ptr<char[]>> memory_chunks_;

    size_t block_size_;       // 풀에서 관리할 개별 메모리 블록의 크기 (bytes)
    size_t blocks_per_chunk_; // 한 번에 시스템에서 할당받을 '청크'에 포함될 블록의 개수

public:
    // 생성자
    MemoryPool(size_t block_size, size_t blocks_per_chunk)
        : free_list_(nullptr), // 처음에는 사용 가능한 블록이 없으므로 nullptr로 초기화
          block_size_(block_size),
          blocks_per_chunk_(blocks_per_chunk) {
        
        // block_size는 최소한 Block 구조체(포인터 1개)의 크기보다는 커야 합니다.
        // 왜냐하면 반납된 메모리 블록에 'next' 포인터를 저장해야 하기 때문입니다.
        assert(block_size >= sizeof(Block));

        // 풀이 생성될 때 초기 메모리 청크를 하나 할당합니다.
        allocate_chunk();
    }

    // 풀에서 메모리 블록 하나를 할당받습니다. (new와 유사)
    void* allocate() {
        // 만약 사용 가능한 블록이 없다면 (free list가 비어있다면)
        if (free_list_ == nullptr) {
            // 새로운 청크를 할당하여 free list를 채웁니다.
            allocate_chunk();
        }

        // free list의 맨 앞에 있는 블록을 가져옵니다.
        Block* block = free_list_;

        // free list의 헤드를 다음 블록으로 이동시킵니다.
        free_list_ = block->next;

        // 할당된 블록의 주소를 void* 타입으로 반환합니다.
        return block;
    }

    // 사용했던 메모리 블록을 풀에 반환합니다. (delete와 유사)
    void deallocate(void* ptr) {
        // 반환된 포인터(void*)를 다시 Block* 타입으로 변환합니다.
        Block* block = static_cast<Block*>(ptr);

        // 이 블록을 free list의 맨 앞에 다시 추가합니다.
        block->next = free_list_;
        free_list_ = block;
    }

private:
    // 시스템으로부터 큰 메모리 청크를 할당받고,
    // 이를 'block_size_' 크기의 블록들로 쪼개어 free list에 추가하는 함수입니다.
    void allocate_chunk() {
        // (블록 크기 * 청크당 블록 수) 만큼의 큰 메모리 덩어리를 힙(heap)에 할당합니다.
        // std::make_unique<char[]>를 사용하여 예외 안전성 및 자동 해제를 보장합니다.
        auto chunk = std::make_unique<char[]>(block_size_ * blocks_per_chunk_);

        // 할당된 큰 청크를 block_size_ 단위로 쪼개서 free list에 연결합니다.
        // (루프를 거꾸로 돌면서 리스트의 맨 앞에 추가하는 방식)
        for (size_t i = 0; i < blocks_per_chunk_; ++i) {
            // 청크의 시작 주소에서 (i * block_size_) 만큼 떨어진 위치를 Block*로 재해석합니다.
            Block* block = reinterpret_cast<Block*>(chunk.get() + i * block_size_);

            // 이 새로운 블록을 free list의 맨 앞에 추가합니다.
            block->next = free_list_;
            free_list_ = block;
        }

        // 할당된 청크(chunk)의 소유권을 memory_chunks_ 벡터로 이동시킵니다.
        // 이렇게 해야 나중에 MemoryPool이 소멸될 때 이 청크 메모리 전체가 해제됩니다.
        memory_chunks_.push_back(std::move(chunk));
    }
};
```

이 코드는 메모리 풀의 기본 동작 원리를 보여준다. 설명하자면 먼저 `Block` 구조체는 프리 리스트를 구성하기 위한 최소한의 정보를 담는다. 메모리가 해제될 때는 그 메모리 공간을 다음 노드 포인터로 사용하는 영리한 기법이다.

`allocate()` 메서드는 프리 리스트에서 첫 번째 블록을 꺼내서 반환한다. 만약 사용 가능한 블록이 없으면 새로운 청크를 할당한다. `deallocate()` 메서드는 반환된 메모리를 프리 리스트의 앞에 다시 추가한다.

이제 이 메모리 풀을 STL 할당자 인터페이스로 감싸서 STL 컨테이너와도 함께 사용할 수 있게 만들어보자.

```cpp
#include <memory>   // std::allocator_traits 등 할당자 관련 표준 기능
#include <limits>   // (이 코드에서는 직접 사용되지는 않았습니다)
#include <stdexcept> // std::bad_alloc (원래는 <new>에 있지만 <memory> 등을 통해 포함될 수 있음)

// (이전에 정의된 MemoryPool 클래스가 있다고 가정합니다)
// class MemoryPool { ... }; 

// STL 호환 커스텀 할당자 (Allocator)
// 이 클래스는 C++ 표준이 요구하는 할당자 인터페이스를 구현합니다.
template<typename T>
class PoolAllocator {
public:
    // --- STL 할당자가 반드시 정의해야 하는 타입 별칭들 (Type Aliases) ---
    using value_type = T;                     // 할당할 객체의 타입
    using pointer = T*;                       // 객체의 포인터
    using const_pointer = const T*;           // const 객체의 포인터
    using reference = T&;                     // 객체의 참조
    using const_reference = const T&;         // const 객체의 참조
    using size_type = std::size_t;            // 크기 타입 (unsigned)
    using difference_type = std::ptrdiff_t;   // 포인터 간의 차이 (signed)

    // --- rebind (STL 할당자 요구사항) ---
    // 컨테이너가 T 타입이 아닌 다른 타입(U) (e.g., 내부 노드)을 할당해야 할 때 사용됩니다.
    // PoolAllocator<T>를 PoolAllocator<U>로 변환할 수 있게 해줍니다.
    template<typename U>
    struct rebind {
        using other = PoolAllocator<U>;
    };

    // 생성자: 사용할 MemoryPool을 포인터로 받습니다.
    explicit PoolAllocator(MemoryPool* pool) : pool_(pool) {}

    // 템플릿 복사 생성자 (rebind와 함께 사용됨)
    // e.g., PoolAllocator<T>가 PoolAllocator<Node>를 생성할 때 호출됩니다.
    // 이때 두 할당자는 동일한 MemoryPool을 공유해야 합니다.
    template<typename U>
    PoolAllocator(const PoolAllocator<U>& other) noexcept
        : pool_(other.pool_) {} // 다른 타입의 할당자로부터 pool 포인터를 복사

    // --- 핵심 기능: 메모리 할당 ---
    // n개의 T 객체를 저장할 수 있는 메모리 블록을 할당합니다.
    T* allocate(size_type n) {
        // 요청된 총 크기 (n * 객체 크기)가 풀이 제공하는 단일 블록 크기보다 큰지 확인합니다.
        // 이 할당자는 단일 블록 크기를 초과하는 큰 메모리 청크 요청은 처리할 수 없습니다.
        if (n * sizeof(T) > pool_block_size) {
            // (참고: 실제 STL 컨테이너들은 n=1인 경우가 많습니다. 
            //  e.g., list/map의 노드 할당. vector의 재할당은 n이 클 수 있습니다.)
            throw std::bad_alloc(); // 할당할 수 없으면 표준 예외 발생
        }
        
        // 실제 할당은 MemoryPool 객체에 위임합니다.
        // MemoryPool은 void*를 반환하므로 T*로 캐스팅합니다.
        return static_cast<T*>(pool_->allocate());
    }

    // --- 핵심 기능: 메모리 반환 ---
    // 할당받았던 메모리(포인터 p)를 풀에 반환합니다.
    // 두 번째 인자(n, 할당했던 크기)는 우리 풀에서는 필요 없습니다.
    // 왜냐하면 우리 풀은 항상 'pool_block_size'라는 고정 크기 블록만 다루기 때문입니다.
    void deallocate(T* p, size_type /* n */) noexcept {
        pool_->deallocate(p); // 실제 반환은 MemoryPool 객체에 위임
    }

    // --- 할당자 비교 (STL 요구사항) ---
    // 두 할당자가 동일한 메모리 풀을 공유하는지 확인합니다.
    // (e.g., 한 할당자(A)가 할당한 메모리를 다른 할당자(B)가 해제할 수 있는지 결정)
    bool operator==(const PoolAllocator& other) const noexcept {
        return pool_ == other.pool_;
    }

    bool operator!=(const PoolAllocator& other) const noexcept {
        return pool_ != other.pool_;
    }

    // 템플릿 복사 생성자(PoolAllocator<U>& other)가 
    // private 멤버인 'other.pool_'에 접근할 수 있도록 친구 선언
    template<typename U>
    friend class PoolAllocator;

private:
    MemoryPool* pool_; // 실제 메모리 관리를 수행할 풀에 대한 포인터

    // 이 할당자가 가정하는 MemoryPool의 *단일 블록 크기*입니다.
    // *중요*: 이 PoolAllocator를 사용하려면, 생성자에 전달하는 MemoryPool 객체가
    //         반드시 '256'바이트 크기의 블록을 갖도록 생성되었어야 합니다.
    static constexpr size_type pool_block_size = 256; 
};
```  
이 PoolAllocator를 사용하면 std::list<MyObject, PoolAllocator<MyObject>>와 같이 선언하여 std::list가 노드를 생성하고 삭제할 때 new/delete 대신 우리가 만든 MemoryPool을 사용하도록 강제할 수 있다.
  

커스텀 할당자를 만들 때 중요한 점은 STL에서 요구하는 모든 타입 정의와 메서드를 제공해야 한다는 것이다. `rebind` 템플릿은 할당자가 다른 타입으로 재사용될 때 필요하고, `allocate()`와 `deallocate()` 메서드는 실제 메모리 관리를 담당한다.

이제 게임 엔진에서 실제로 어떻게 메모리 풀을 사용하는지 보자.

```cpp
// 게임 엔진에서의 메모리 풀 사용
class GameEngine {
private:
    MemoryPool particle_pool_;
    MemoryPool entity_pool_;

public:
    GameEngine()
        : particle_pool_(sizeof(Particle), 10000),
          entity_pool_(sizeof(Entity), 1000) {}

    // 파티클 생성
    Particle* create_particle(const Vector3& pos, const Vector3& velocity) {
        void* memory = particle_pool_.allocate();
        return new (memory) Particle(pos, velocity);
    }

    // 파티클 소멸
    void destroy_particle(Particle* particle) {
        particle->~Particle();
        particle_pool_.deallocate(particle);
    }

    // 매 프레임 업데이트
    void update(float delta_time) {
        for (auto& particle : active_particles_) {
            particle->update(delta_time);
        }
    }
};
```

여기서 핵심은 배치 할당(placement new)을 사용한다는 것이다. `new (memory) Particle(...)`은 이미 할당된 메모리 공간에 객체를 생성한다. 소멸할 때도 명시적으로 소멸자를 호출한 후 메모리를 풀에 반환한다.

메모리 풀의 장점은 다음과 같다. 첫째, 할당 해제가 O(1) 연산이 된다. 둘째, 메모리 단편화가 거의 발생하지 않는다. 셋째, 실시간 성능이 일관된다. 넷째, 캐시 지역성(cache locality)이 좋다.
  
  
  
## 16.2 ECS 패턴 구현
ECS(Entity-Component-System)는 현대 게임 엔진의 표준 아키텍처다. 객체지향 상속 계층 대신 조합(composition)을 사용하여 유연성과 성능을 동시에 얻는다.

ECS의 세 가지 개념을 먼저 이해해야 한다. 엔티티(Entity)는 게임 월드의 모든 객체를 나타내는 고유한 ID다. 컴포넌트(Component)는 엔티티가 가진 데이터를 저장한다. 시스템(System)은 특정 컴포넌트를 가진 엔티티들을 찾아서 처리하는 로직을 담당한다.

먼저 기본 구조를 정의하자.

```cpp
#include <cstdint>
#include <typeinfo>
#include <typeindex>
#include <unordered_map>
#include <vector>
#include <memory>
#include <algorithm>

// 엔티티를 나타내는 핸들
using EntityId = std::uint32_t;

// 컴포넌트의 기본 클래스
class Component {
public:
    virtual ~Component() = default;
};

// 위치를 나타내는 컴포넌트
struct TransformComponent : public Component {
    float x, y, z;
    float rotation;
    
    TransformComponent(float x = 0, float y = 0, float z = 0, float rotation = 0)
        : x(x), y(y), z(z), rotation(rotation) {}
};

// 속도를 나타내는 컴포넌트
struct VelocityComponent : public Component {
    float vx, vy, vz;
    
    VelocityComponent(float vx = 0, float vy = 0, float vz = 0)
        : vx(vx), vy(vy), vz(vz) {}
};

// 생명 상태를 나타내는 컴포넌트
struct HealthComponent : public Component {
    int health;
    int max_health;
    
    HealthComponent(int max_health = 100)
        : health(max_health), max_health(max_health) {}
};
```

컴포넌트들은 순수 데이터 저장소다. 이렇게 함으로써 데이터와 로직을 완전히 분리할 수 있다.

이제 엔티티 매니저를 구현해보자. 엔티티 매니저는 엔티티 생성, 소멸, 컴포넌트 추가/제거를 담당한다.

```cpp
#include <sparse_hash_map> // 또는 std::unordered_map 사용
#include <memory>

class EntityManager {
private:
    struct EntityData {
        std::unordered_map<std::type_index, std::unique_ptr<Component>> components;
        bool active;
    };

    std::unordered_map<EntityId, EntityData> entities_;
    EntityId next_entity_id_;
    std::vector<EntityId> free_ids_;

public:
    EntityManager() : next_entity_id_(1) {}

    // 새 엔티티를 생성한다
    EntityId create_entity() {
        EntityId id;
        
        if (!free_ids_.empty()) {
            id = free_ids_.back();
            free_ids_.pop_back();
        } else {
            id = next_entity_id_++;
        }
        
        entities_[id].active = true;
        return id;
    }

    // 엔티티를 소멸시킨다
    void destroy_entity(EntityId id) {
        auto it = entities_.find(id);
        if (it != entities_.end()) {
            it->second.components.clear();
            it->second.active = false;
            free_ids_.push_back(id);
        }
    }

    // 엔티티에 컴포넌트를 추가한다
    template<typename T, typename... Args>
    T* add_component(EntityId id, Args&&... args) {
        auto it = entities_.find(id);
        if (it == entities_.end()) return nullptr;
        
        auto component = std::make_unique<T>(std::forward<Args>(args)...);
        T* ptr = component.get();
        it->second.components[std::type_index(typeid(T))] = std::move(component);
        return ptr;
    }

    // 엔티티에서 컴포넌트를 가져온다
    template<typename T>
    T* get_component(EntityId id) {
        auto it = entities_.find(id);
        if (it == entities_.end()) return nullptr;
        
        auto comp_it = it->second.components.find(std::type_index(typeid(T)));
        if (comp_it == it->second.components.end()) return nullptr;
        
        return dynamic_cast<T*>(comp_it->second.get());
    }

    // 엔티티가 특정 컴포넌트를 가지는지 확인한다
    template<typename T>
    bool has_component(EntityId id) const {
        auto it = entities_.find(id);
        if (it == entities_.end()) return false;
        
        return it->second.components.find(std::type_index(typeid(T)))
            != it->second.components.end();
    }

    // 특정 컴포넌트를 가진 모든 엔티티를 가져온다
    template<typename T>
    std::vector<EntityId> get_entities_with_component() {
        std::vector<EntityId> result;
        
        for (auto& [id, data] : entities_) {
            if (data.active && 
                data.components.find(std::type_index(typeid(T))) 
                != data.components.end()) {
                result.push_back(id);
            }
        }
        
        return result;
    }

    // 활성 엔티티 개수를 반환한다
    size_t active_entity_count() const {
        return std::count_if(
            entities_.begin(), entities_.end(),
            [](const auto& pair) { return pair.second.active; }
        );
    }
};
```

이 코드의 핵심은 `std::type_index`를 사용하여 런타임에 타입을 인덱싱한다는 것이다. 각 엔티티는 `type_index`를 키로 하는 맵에 컴포넌트를 저장한다. 이렇게 하면 엔티티가 임의의 타입의 컴포넌트를 가질 수 있다.

이제 시스템을 구현해보자. 시스템은 특정 컴포넌트 조합을 가진 엔티티들을 처리한다.

```cpp
// 시스템의 기본 인터페이스
class System {
public:
    virtual ~System() = default;
    virtual void update(float delta_time, EntityManager& entity_mgr) = 0;
};

// 물리 시스템: TransformComponent와 VelocityComponent를 가진 엔티티를 처리한다
class PhysicsSystem : public System {
public:
    void update(float delta_time, EntityManager& entity_mgr) override {
        // TransformComponent와 VelocityComponent를 모두 가진 엔티티들을 찾는다
        auto entities = entity_mgr.get_entities_with_component<VelocityComponent>();
        
        for (EntityId id : entities) {
            // VelocityComponent가 있으면 TransformComponent도 있다고 가정한다
            if (!entity_mgr.has_component<TransformComponent>(id)) {
                continue;
            }
            
            auto* transform = entity_mgr.get_component<TransformComponent>(id);
            auto* velocity = entity_mgr.get_component<VelocityComponent>(id);
            
            // 위치를 업데이트한다
            transform->x += velocity->vx * delta_time;
            transform->y += velocity->vy * delta_time;
            transform->z += velocity->vz * delta_time;
        }
    }
};

// 건강 관리 시스템: HealthComponent를 가진 엔티티를 처리한다
class HealthSystem : public System {
public:
    void update(float delta_time, EntityManager& entity_mgr) override {
        auto entities = entity_mgr.get_entities_with_component<HealthComponent>();
        
        for (EntityId id : entities) {
            auto* health = entity_mgr.get_component<HealthComponent>(id);
            
            // 건강이 0 이하이면 엔티티를 제거한다
            if (health->health <= 0) {
                entity_mgr.destroy_entity(id);
            }
        }
    }
};

// 렌더링 시스템: TransformComponent를 가진 엔티티를 렌더링한다
class RenderSystem : public System {
public:
    void update(float delta_time, EntityManager& entity_mgr) override {
        auto entities = entity_mgr.get_entities_with_component<TransformComponent>();
        
        for (EntityId id : entities) {
            auto* transform = entity_mgr.get_component<TransformComponent>(id);
            // 실제 렌더링 코드
            // draw_entity(transform->x, transform->y, transform->z, transform->rotation);
        }
    }
};
```

이제 전체 게임 엔진을 조합해보자.

```cpp
#include <vector>

class GameWorld {
private:
    EntityManager entity_manager_;
    std::vector<std::unique_ptr<System>> systems_;

public:
    GameWorld() {
        // 시스템들을 생성한다
        systems_.push_back(std::make_unique<PhysicsSystem>());
        systems_.push_back(std::make_unique<HealthSystem>());
        systems_.push_back(std::make_unique<RenderSystem>());
    }

    // 엔티티 생성 헬퍼 메서드
    EntityId spawn_player(float x, float y, float z) {
        EntityId id = entity_manager_.create_entity();
        entity_manager_.add_component<TransformComponent>(id, x, y, z);
        entity_manager_.add_component<VelocityComponent>(id, 0, 0, 0);
        entity_manager_.add_component<HealthComponent>(id, 100);
        return id;
    }

    EntityId spawn_projectile(float x, float y, float z, float vx, float vy, float vz) {
        EntityId id = entity_manager_.create_entity();
        entity_manager_.add_component<TransformComponent>(id, x, y, z);
        entity_manager_.add_component<VelocityComponent>(id, vx, vy, vz);
        return id;
    }

    // 매 프레임 업데이트
    void update(float delta_time) {
        for (auto& system : systems_) {
            system->update(delta_time, entity_manager_);
        }
    }

    // 엔티티 접근
    EntityManager& get_entity_manager() {
        return entity_manager_;
    }
};
```

ECS 패턴의 장점을 정리하면, 첫째 엔티티는 순수한 ID에 불과하므로 메모리 효율적이다. 둘째 컴포넌트를 추가/제거하기만 하면 엔티티의 기능이 동적으로 변한다. 셋째 시스템은 특정 컴포넌트 조합만을 처리하므로 캐시 효율이 좋다. 넷째 상속 계층이 평탄하므로 복잡도가 낮다.
  


## 16.3 실시간 시스템에서의 안전성 보장
게임 엔진은 프레임마다 매우 짧은 시간 안에 모든 연산을 완료해야 한다. 이 시간 제약을 지키면서도 메모리 안전성과 스레드 안전성을 보장해야 한다.

먼저 메모리 안전성을 확보하기 위해 스마트 포인터를 적극 활용한다.

```cpp
#include <memory>
#include <gsl/gsl> // GSL (Guidelines Support Library)

// RAII를 따르는 리소스 관리
class Texture {
private:
    GLuint texture_id_;
    int width_, height_;

public:
    Texture(const std::string& path) : width_(0), height_(0) {
        // 텍스처 로드
        texture_id_ = load_texture(path, width_, height_);
    }

    ~Texture() {
        // 리소스 해제
        if (texture_id_ != 0) {
            glDeleteTextures(1, &texture_id_);
        }
    }

    GLuint get_id() const { return texture_id_; }
    int get_width() const { return width_; }
    int get_height() const { return height_; }

    // 복사 불가
    Texture(const Texture&) = delete;
    Texture& operator=(const Texture&) = delete;

    // 이동 가능
    Texture(Texture&& other) noexcept
        : texture_id_(other.texture_id_), width_(other.width_), height_(other.height_) {
        other.texture_id_ = 0;
    }

    Texture& operator=(Texture&& other) noexcept {
        if (this != &other) {
            // 기존 리소스 정리
            if (texture_id_ != 0) {
                glDeleteTextures(1, &texture_id_);
            }

            texture_id_ = other.texture_id_;
            width_ = other.width_;
            height_ = other.height_;
            other.texture_id_ = 0;
        }
        return *this;
    }
};

// 텍스처 매니저
class TextureManager {
private:
    std::unordered_map<std::string, std::shared_ptr<Texture>> textures_;

public:
    std::shared_ptr<Texture> load_texture(const std::string& path) {
        auto it = textures_.find(path);
        
        if (it != textures_.end()) {
            return it->second;
        }

        // 중복을 피하기 위해 한 번만 로드한다
        auto texture = std::make_shared<Texture>(path);
        textures_[path] = texture;
        return texture;
    }

    // 텍스처를 언로드한다
    void unload_texture(const std::string& path) {
        textures_.erase(path);
    }

    // 모든 텍스처를 언로드한다
    void clear() {
        textures_.clear();
    }

    size_t get_loaded_count() const {
        return textures_.size();
    }
};
```

이 코드에서 핵심은 `shared_ptr`을 사용하여 리소스의 생명주기를 자동으로 관리한다는 것이다. 마지막 참조가 소멸되면 자동으로 리소스가 정리된다.

이제 멀티스레드 게임 엔진에서의 안전성을 살펴보자. 게임 엔진은 보통 메인 스레드, 렌더링 스레드, 로딩 스레드 등 여러 스레드를 사용한다.

```cpp
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

// 스레드 안전한 커맨드 큐
template<typename Command>
class CommandQueue {
private:
    std::queue<Command> queue_;
    mutable std::mutex mutex_;
    std::condition_variable cv_;

public:
    // 커맨드를 큐에 추가한다
    void enqueue(Command cmd) {
        {
            std::unique_lock<std::mutex> lock(mutex_);
            queue_.push(cmd);
        }
        cv_.notify_one();
    }

    // 큐에서 커맨드를 꺼낸다 (타임아웃 있음)
    bool try_dequeue(Command& cmd, std::chrono::milliseconds timeout) {
        std::unique_lock<std::mutex> lock(mutex_);
        
        if (!cv_.wait_for(lock, timeout, [this] { return !queue_.empty(); })) {
            return false;
        }

        if (queue_.empty()) {
            return false;
        }

        cmd = std::move(queue_.front());
        queue_.pop();
        return true;
    }

    // 큐를 비운다
    void clear() {
        std::unique_lock<std::mutex> lock(mutex_);
        while (!queue_.empty()) {
            queue_.pop();
        }
    }

    // 큐의 크기를 반환한다
    size_t size() const {
        std::unique_lock<std::mutex> lock(mutex_);
        return queue_.size();
    }
};

// 리소스 로딩 커맨드
struct LoadResourceCommand {
    std::string path;
    std::string resource_type;
    std::function<void(bool)> callback;
};

// 리소스 로더 (별도 스레드에서 실행)
class ResourceLoader {
private:
    CommandQueue<LoadResourceCommand> load_queue_;
    std::thread loader_thread_;
    std::atomic<bool> running_{false};

public:
    ResourceLoader() {
        running_ = true;
        loader_thread_ = std::thread([this] { run(); });
    }

    ~ResourceLoader() {
        running_ = false;
        if (loader_thread_.joinable()) {
            loader_thread_.join();
        }
    }

    // 리소스 로딩을 요청한다
    void request_load(const std::string& path, const std::string& type,
                     std::function<void(bool)> callback) {
        load_queue_.enqueue({path, type, callback});
    }

private:
    void run() {
        while (running_) {
            LoadResourceCommand cmd;
            
            // 100ms 타임아웃으로 커맨드를 대기한다
            if (load_queue_.try_dequeue(cmd, std::chrono::milliseconds(100))) {
                // 실제 로딩 수행
                bool success = load_resource(cmd.path, cmd.resource_type);
                
                // 콜백을 호출한다
                if (cmd.callback) {
                    cmd.callback(success);
                }
            }
        }
    }

    bool load_resource(const std::string& path, const std::string& type) {
        // 실제 리소스 로딩 로직
        // 이것은 시간이 걸릴 수 있는 작업이다
        return true;
    }
};
```

게임 엔진에서 안전성을 보장하기 위한 또 다른 중요한 기법은 경계 검사(bounds checking)다.

```cpp
#include <gsl/gsl> // Guidelines Support Library

// GSL의 span을 사용한 안전한 배열 접근
class Mesh {
private:
    std::vector<float> vertices_;
    std::vector<uint32_t> indices_;

public:
    Mesh(gsl::span<const float> verts, gsl::span<const uint32_t> idxs) {
        vertices_.assign(verts.begin(), verts.end());
        indices_.assign(idxs.begin(), idxs.end());
    }

    // 범위 내인지 확인하고 접근한다
    float get_vertex_component(size_t vertex_idx, size_t component_idx) const {
        gsl::span<const float> vertices_span(vertices_);
        
        // 범위 체크
        Expects(vertex_idx < vertices_span.size() / 3);
        Expects(component_idx < 3);

        return vertices_span[vertex_idx * 3 + component_idx];
    }

    // 범위 안전한 반복
    void apply_transform(const std::function<void(gsl::span<float>)>& transform) {
        // 정점마다 3개 컴포넌트씩 처리한다
        for (size_t i = 0; i < vertices_.size(); i += 3) {
            gsl::span<float> vertex(vertices_.data() + i, 3);
            Expects(vertex.size() == 3);
            transform(vertex);
        }
    }

    size_t get_vertex_count() const {
        return vertices_.size() / 3;
    }

    size_t get_index_count() const {
        return indices_.size();
    }
};
```

`gsl::span`은 포인터와 크기 정보를 함께 가지므로 범위를 초과하는 접근을 방지할 수 있다. `Expects` 매크로는 계약적 프로그래밍(design by contract)을 구현한 것이다.

실시간 시스템에서는 또 다른 중요한 안전성 고려사항이 있다. 프레임 시간 초과(frame budget exceeded)를 방지해야 한다.

```cpp
#include <chrono>

// 프레임 타이머
class FrameTimer {
private:
    using clock = std::chrono::high_resolution_clock;
    using duration = std::chrono::duration<float, std::milli>;

    clock::time_point frame_start_;
    float target_frame_time_ms_;

public:
    explicit FrameTimer(float target_fps = 60.0f)
        : target_frame_time_ms_(1000.0f / target_fps) {}

    void begin_frame() {
        frame_start_ = clock::now();
    }

    float get_elapsed_ms() const {
        auto elapsed = clock::now() - frame_start_;
        return std::chrono::duration_cast<duration>(elapsed).count();
    }

    // 프레임 예산을 초과했는지 확인한다
    bool is_frame_budget_exceeded() const {
        return get_elapsed_ms() > target_frame_time_ms_;
    }

    // 남은 시간을 반환한다 (음수면 초과)
    float get_remaining_ms() const {
        return target_frame_time_ms_ - get_elapsed_ms();
    }

    // 프레임 예산이 부족하면 true를 반환한다
    bool should_skip_work() const {
        return get_remaining_ms() < 0.0f;
    }
};

// 프레임 예산을 고려한 작업 큐
class BudgetedWorkQueue {
private:
    std::vector<std::function<void()>> pending_work_;
    FrameTimer timer_;

public:
    explicit BudgetedWorkQueue(float target_fps = 60.0f) : timer_(target_fps) {}

    // 일감을 추가한다
    void enqueue_work(std::function<void()> work) {
        pending_work_.push_back(work);
    }

    // 프레임 예산 범위 내에서 작업을 처리한다
    void process_work() {
        timer_.begin_frame();

        auto it = pending_work_.begin();
        while (it != pending_work_.end() && !timer_.should_skip_work()) {
            (*it)();
            ++it;
        }

        // 처리된 작업들을 제거한다
        pending_work_.erase(pending_work_.begin(), it);
    }

    size_t get_pending_work_count() const {
        return pending_work_.size();
    }

    float get_frame_time_usage_percent() const {
        return (timer_.get_elapsed_ms() / timer_.target_frame_time_ms()) * 100.0f;
    }
};
```

이 코드는 프레임이 정해진 시간 내에 완료되도록 보장한다. `should_skip_work()`가 true이면 남은 작업은 다음 프레임으로 미룬다.
  
   

## 16.4 성능 크리티컬 코드의 최적화
게임 엔진의 성능 병목 지점은 보통 매우 명확하다. 물리 계산, 충돌 감지, 렌더링 준비 등이 주요 후보다. 이 섹션에서는 성능 크리티컬 코드를 최적화하는 방법을 살펴본다.

먼저 SIMD(Single Instruction Multiple Data)를 활용한 벡터 연산을 보자.

```cpp
#include <immintrin.h> // SIMD 헤더

// SSE를 사용한 벡터 연산
struct Vector4_SIMD {
    __m128 data;  // 4개의 float을 동시에 처리

    Vector4_SIMD() : data(_mm_setzero_ps()) {}
    
    explicit Vector4_SIMD(float x, float y, float z, float w)
        : data(_mm_setr_ps(x, y, z, w)) {}

    Vector4_SIMD operator+(const Vector4_SIMD& other) const {
        Vector4_SIMD result;
        result.data = _mm_add_ps(data, other.data);
        return result;
    }

    Vector4_SIMD operator*(float scalar) const {
        Vector4_SIMD result;
        result.data = _mm_mul_ps(data, _mm_set1_ps(scalar));
        return result;
    }

    float dot(const Vector4_SIMD& other) const {
        __m128 mul = _mm_mul_ps(data, other.data);
        __m128 shuf = _mm_shuffle_ps(mul, mul, _MM_SHUFFLE(2, 3, 0, 1));
        __m128 sum = _mm_add_ps(mul, shuf);
        shuf = _mm_shuffle_ps(sum, sum, _MM_SHUFFLE(1, 0, 3, 2));
        sum = _mm_add_ps(sum, shuf);
        
        float result;
        _mm_store_ss(&result, sum);
        return result;
    }
};

// 스칼라 버전과 성능 비교용
struct Vector4_Scalar {
    float x, y, z, w;

    Vector4_Scalar() : x(0), y(0), z(0), w(0) {}
    
    Vector4_Scalar(float x, float y, float z, float w)
        : x(x), y(y), z(z), w(w) {}

    Vector4_Scalar operator+(const Vector4_Scalar& other) const {
        return Vector4_Scalar(x + other.x, y + other.y, z + other.z, w + other.w);
    }

    Vector4_Scalar operator*(float scalar) const {
        return Vector4_Scalar(x * scalar, y * scalar, z * scalar, w * scalar);
    }

    float dot(const Vector4_Scalar& other) const {
        return x * other.x + y * other.y + z * other.z + w * other.w;
    }
};
```

SIMD를 사용하면 벡터 연산을 병렬로 처리할 수 있어 성능이 크게 향상된다. 하지만 코드 복잡도도 증가하므로 병목 지점에만 적용해야 한다.

다음으로 캐시 효율성을 고려한 데이터 레이아웃 최적화를 보자.

```cpp
#include <vector>
#include <memory>

// 구조의 배열 (Array of Structs) - 캐시 비효율
struct AOS_Particle {
    float x, y, z;      // 위치
    float vx, vy, vz;   // 속도
    float lifetime;     // 생명 시간
    int type;          // 파티클 종류
};

// 배열의 구조 (Structure of Arrays) - 캐시 효율적
struct SoA_ParticleBuffer {
    std::vector<float> x, y, z;
    std::vector<float> vx, vy, vz;
    std::vector<float> lifetime;
    std::vector<int> type;

    size_t size() const { return x.size(); }

    void add_particle(float px, float py, float pz,
                     float pvx, float pvy, float pvz,
                     float plifetime, int ptype) {
        x.push_back(px);
        y.push_back(py);
        z.push_back(pz);
        vx.push_back(pvx);
        vy.push_back(pvy);
        vz.push_back(pvz);
        lifetime.push_back(plifetime);
        type.push_back(ptype);
    }
};

// SoA를 사용한 최적화된 파티클 업데이트
void update_particles_SoA(SoA_ParticleBuffer& particles, float delta_time) {
    size_t count = particles.size();

    // 접근 패턴이 매우 규칙적이어서 캐시 효율이 좋다
    for (size_t i = 0; i < count; ++i) {
        particles.x[i] += particles.vx[i] * delta_time;
        particles.y[i] += particles.vy[i] * delta_time;
        particles.z[i] += particles.vz[i] * delta_time;
        particles.lifetime[i] -= delta_time;
    }
}

// 비교용: AOS를 사용한 업데이트
void update_particles_AOS(std::vector<AOS_Particle>& particles, float delta_time) {
    for (auto& particle : particles) {
        particle.x += particle.vx * delta_time;
        particle.y += particle.vy * delta_time;
        particle.z += particle.vz * delta_time;
        particle.lifetime -= delta_time;
    }
}
```

SoA(Structure of Arrays) 레이아웃은 AOS(Array of Structs)보다 캐시 효율이 훨씬 좋다. 모든 `x` 좌표가 연속 메모리에 위치하므로 캐시 라인을 더 효과적으로 활용할 수 있다.

동적 할당 최소화도 중요한 최적화 기법이다.

```cpp
#include <memory>
#include <array>

// 고정 크기 메모리를 사용한 파티클 시스템
class OptimizedParticleSystem {
private:
    static constexpr size_t MAX_PARTICLES = 10000;

    std::array<float, MAX_PARTICLES> x_, y_, z_;
    std::array<float, MAX_PARTICLES> vx_, vy_, vz_;
    std::array<float, MAX_PARTICLES> lifetime_;
    std::array<int, MAX_PARTICLES> type_;
    size_t particle_count_;

public:
    OptimizedParticleSystem() : particle_count_(0) {}

    // 파티클을 추가한다 (동적 할당 없음)
    bool add_particle(float px, float py, float pz,
                     float pvx, float pvy, float pvz,
                     float plifetime, int ptype) {
        if (particle_count_ >= MAX_PARTICLES) {
            return false;  // 용량 초과
        }

        size_t idx = particle_count_++;
        x_[idx] = px;
        y_[idx] = py;
        z_[idx] = pz;
        vx_[idx] = pvx;
        vy_[idx] = pvy;
        vz_[idx] = pvz;
        lifetime_[idx] = plifetime;
        type_[idx] = ptype;

        return true;
    }

    // 파티클들을 업데이트한다
    void update(float delta_time) {
        size_t write_idx = 0;

        // 유효한 파티클만 유지한다 (compact 연산)
        for (size_t i = 0; i < particle_count_; ++i) {
            lifetime_[i] -= delta_time;

            if (lifetime_[i] > 0.0f) {
                // 위치 업데이트
                x_[write_idx] = x_[i] + vx_[i] * delta_time;
                y_[write_idx] = y_[i] + vy_[i] * delta_time;
                z_[write_idx] = z_[i] + vz_[i] * delta_time;

                vx_[write_idx] = vx_[i];
                vy_[write_idx] = vy_[i];
                vz_[write_idx] = vz_[i];
                lifetime_[write_idx] = lifetime_[i];
                type_[write_idx] = type_[i];

                ++write_idx;
            }
        }

        particle_count_ = write_idx;
    }

    size_t get_particle_count() const { return particle_count_; }
};
```

이 구현은 고정 크기 배열을 사용하므로 동적 메모리 할당이 없다. 또한 생명 시간이 끝난 파티클을 제거할 때 배열의 끝에서 앞으로 옮기는 방식(swap and pop)을 사용하므로 매우 빠르다.

컴파일러 최적화도 성능에 큰 영향을 미친다.

```cpp
// 릴리스 빌드에서는 다음과 같은 최적화 플래그를 사용해야 한다
// MSVC: /O2 /Ot /Oy
// GCC/Clang: -O3 -march=native -flto

// 핫스팟 함수를 명시적으로 인라인하도록 지정
class FORCEINLINE_Physics {
public:
    // 매우 자주 호출되는 함수는 인라인 플래그를 사용한다
    FORCEINLINE void integrate_position(float& x, float vx, float dt) {
        x += vx * dt;
    }

    // 루프 불변식 제거를 도와주는 __assume
    FORCEINLINE void process_batch(int* values, int count, int multiplier) {
        // count가 변하지 않음을 컴파일러에 알린다
        for (int i = 0; i < count; ++i) {
            values[i] *= multiplier;
        }
    }
};

// restrict 포인터를 사용한 별칭 제거
void transform_vertices_optimized(float* restrict dest, 
                                 const float* restrict src,
                                 int count) {
    // 컴파일러가 dest와 src가 겹치지 않음을 알 수 있으므로 더 공격적으로 최적화한다
    for (int i = 0; i < count; ++i) {
        dest[i] = src[i] * 2.0f;
    }
}
```

마지막으로 프로파일링 기반 최적화를 보자.

```cpp
#include <chrono>
#include <iostream>
#include <iomanip>

// 간단한 성능 프로파일러
class SimpleProfiler {
private:
    struct SampleData {
        std::chrono::nanoseconds total_time{0};
        int call_count = 0;
    };

    std::unordered_map<std::string, SampleData> samples_;
    std::string current_sample_;
    std::chrono::high_resolution_clock::time_point sample_start_;

public:
    // 샘플 시작
    void begin_sample(const std::string& name) {
        current_sample_ = name;
        sample_start_ = std::chrono::high_resolution_clock::now();
    }

    // 샘플 종료
    void end_sample() {
        auto end = std::chrono::high_resolution_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(
            end - sample_start_);

        samples_[current_sample_].total_time += elapsed;
        samples_[current_sample_].call_count++;
    }

    // 결과 출력
    void print_results() {
        std::cout << "\n=== Profiling Results ===\n";
        std::cout << std::left << std::setw(30) << "Function"
                 << std::right << std::setw(15) << "Calls"
                 << std::setw(15) << "Total (ms)"
                 << std::setw(15) << "Avg (us)" << "\n";
        std::cout << std::string(75, '-') << "\n";

        for (const auto& [name, data] : samples_) {
            double total_ms = data.total_time.count() / 1e6;
            double avg_us = data.total_time.count() / 1e3 / data.call_count;

            std::cout << std::left << std::setw(30) << name
                     << std::right << std::setw(15) << data.call_count
                     << std::setw(15) << std::fixed << std::setprecision(3) << total_ms
                     << std::setw(15) << avg_us << "\n";
        }
    }

    void reset() {
        samples_.clear();
    }
};

// 사용 예시
class ScopedProfile {
private:
    SimpleProfiler& profiler_;

public:
    ScopedProfile(SimpleProfiler& prof, const std::string& name)
        : profiler_(prof) {
        profiler_.begin_sample(name);
    }

    ~ScopedProfile() {
        profiler_.end_sample();
    }
};

// 프로파일링 매크로
#define PROFILE(profiler, name) ScopedProfile PROFILE_##__COUNTER__(profiler, name)
```

이 장에서 다룬 게임 엔진 컴포넌트 개발 기법들을 정리하면 다음과 같다. 메모리 풀과 커스텀 할당자를 사용하면 동적 할당의 오버헤드를 제거할 수 있다. ECS 패턴은 엔티티를 유연하게 관리할 수 있게 해준다. 스마트 포인터, 범위 검사, 프레임 타이밍 등을 통해 실시간 환경에서도 메모리 안전성을 보장할 수 있다. 마지막으로 SoA 레이아웃, SIMD, 프로파일링 등의 최적화 기법으로 성능을 극대화할 수 있다.

Modern C++의 도구들을 제대로 활용하면 C++은 Rust 수준의 안전성을 제공하면서도 성능은 더 우수할 수 있다. 게임 같은 실시간 시스템에서 이것이 얼마나 중요한지는 아무리 강조해도 부족하지 않다.  