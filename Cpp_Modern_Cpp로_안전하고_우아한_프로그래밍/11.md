# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 11: Modern C++의 오류 처리 전략
이 장에서는 C++에서 오류를 어떻게 처리할지에 대한 실전적인 전략을 배울 것이다.

지난 장에서 예외 안전성에 대해 배웠다면, 이 장에서는 "어떤 상황에 어떤 방법으로 오류를 처리할 것인가"에 대해 배운다. C++11 이후 도입된 다양한 오류 처리 방식들이 있는데, 여러분은 각 상황에 맞는 최적의 방법을 선택할 수 있어야 한다.

특히 C++23에서 도입된 `std::expected`는 Rust의 `Result` 타입과 매우 유사하며, 오류 처리의 새로운 표준이 되고 있다. 이를 통해 C++도 Rust 못지않은 안전하고 명확한 오류 처리를 할 수 있다는 것을 보여줄 것이다.
  


## 11.1 std::expected와 함수형 오류 처리

### 11.1.1 std::expected의 기초
`std::expected`는 "값이 있을 수도, 오류가 있을 수도 있다"는 상황을 타입 안전하게 표현하는 클래스다. 이는 `std::optional`을 확장한 형태로, 단순히 "없음"뿐만 아니라 "왜 없는지"를 함께 표현할 수 있다.

```cpp
#include <iostream>
#include <expected>  // C++23
#include <string>
#include <stdexcept>

// 오류 타입 정의
struct ParseError {
    std::string message;
    int errorCode;
    
    ParseError(const std::string& msg, int code = -1) 
        : message(msg), errorCode(code) {}
};

// 과거 방식: 예외 사용
int parseIntegerWithException(const std::string& str) {
    try {
        return std::stoi(str);
    }
    catch (const std::invalid_argument&) {
        throw ParseError("숫자가 아닙니다");
    }
    catch (const std::out_of_range&) {
        throw ParseError("범위를 벗어난 숫자입니다");
    }
}

// Modern 방식: std::expected 사용
std::expected<int, ParseError> parseInteger(const std::string& str) {
    if (str.empty()) {
        return std::unexpected(ParseError("빈 문자열입니다", 1));
    }
    
    try {
        return std::stoi(str);
    }
    catch (const std::invalid_argument&) {
        return std::unexpected(ParseError("유효한 숫자가 아닙니다", 2));
    }
    catch (const std::out_of_range&) {
        return std::unexpected(ParseError("범위를 벗어난 숫자입니다", 3));
    }
}

int main() {
    std::cout << "=== std::expected 기초 ===" << std::endl;
    
    // 성공 케이스
    auto result1 = parseInteger("42");
    if (result1) {
        std::cout << "파싱 성공: " << result1.value() << std::endl;
    }
    
    // 실패 케이스
    auto result2 = parseInteger("abc");
    if (!result2) {
        const auto& error = result2.error();
        std::cout << "파싱 실패: " << error.message 
                  << " (코드: " << error.errorCode << ")" << std::endl;
    }
    
    // value_or을 사용한 기본값 제공
    int value = parseInteger("xyz").value_or(0);
    std::cout << "기본값 사용: " << value << std::endl;
    
    return 0;
}
```

`std::expected`의 가장 큰 장점은 오류 정보를 값으로 취급한다는 것이다. 예외처럼 스택을 풀어서 오버헤드를 발생시키지 않으면서도, 오류를 명시적으로 처리하도록 강제한다.
  

### 11.1.2 and_then으로 체이닝하기
`std::expected`는 함수형 프로그래밍 스타일의 체이닝을 지원한다. `and_then` 메서드를 사용하면 여러 작업을 순차적으로 처리하면서 중간에 오류가 발생하면 바로 중단할 수 있다.

```cpp
#include <iostream>
#include <expected>
#include <string>

struct ConfigError {
    std::string message;
};

struct Config {
    int port;
    std::string host;
    int timeout;
};

// 포트 번호를 파싱하는 함수
std::expected<int, ConfigError> parsePort(const std::string& portStr) {
    try {
        int port = std::stoi(portStr);
        if (port < 1 || port > 65535) {
            return std::unexpected(ConfigError{"포트 범위: 1~65535"});
        }
        return port;
    }
    catch (...) {
        return std::unexpected(ConfigError{"포트 파싱 오류"});
    }
}

// 호스트를 검증하는 함수
std::expected<std::string, ConfigError> validateHost(const std::string& host) {
    if (host.empty()) {
        return std::unexpected(ConfigError{"호스트가 비어있습니다"});
    }
    if (host.length() > 255) {
        return std::unexpected(ConfigError{"호스트명이 너무 깁니다"});
    }
    return host;
}

// 타임아웃을 파싱하는 함수
std::expected<int, ConfigError> parseTimeout(const std::string& timeoutStr) {
    try {
        int timeout = std::stoi(timeoutStr);
        if (timeout < 1 || timeout > 3600) {
            return std::unexpected(ConfigError{"타임아웃 범위: 1~3600초"});
        }
        return timeout;
    }
    catch (...) {
        return std::unexpected(ConfigError{"타임아웃 파싱 오류"});
    }
}

// 전체 설정을 파싱하는 함수 - and_then을 사용한 체이닝
std::expected<Config, ConfigError> parseConfig(
    const std::string& portStr,
    const std::string& hostStr,
    const std::string& timeoutStr) {
    
    // and_then을 사용하여 체이닝
    return parsePort(portStr)
        .and_then([&hostStr](int port) -> std::expected<Config, ConfigError> {
            // 포트가 성공하면 호스트 검증
            return validateHost(hostStr)
                .and_then([port, &timeoutStr](const std::string& host) 
                          -> std::expected<Config, ConfigError> {
                    // 호스트도 성공하면 타임아웃 파싱
                    return parseTimeout(timeoutStr)
                        .map([port, &host](int timeout) {
                            // 모두 성공했으므로 Config 구성
                            return Config{port, host, timeout};
                        });
                });
        });
}

int main() {
    std::cout << "=== and_then을 사용한 체이닝 ===" << std::endl;
    
    // 성공 케이스
    auto config1 = parseConfig("8080", "localhost", "300");
    if (config1) {
        std::cout << "설정 파싱 성공:" << std::endl;
        std::cout << "  포트: " << config1->port << std::endl;
        std::cout << "  호스트: " << config1->host << std::endl;
        std::cout << "  타임아웃: " << config1->timeout << "초" << std::endl;
    }
    
    // 포트 오류
    auto config2 = parseConfig("99999", "localhost", "300");
    if (!config2) {
        std::cout << "\n설정 파싱 실패: " << config2.error().message << std::endl;
    }
    
    // 호스트 오류
    auto config3 = parseConfig("8080", "", "300");
    if (!config3) {
        std::cout << "설정 파싱 실패: " << config3.error().message << std::endl;
    }
    
    // 타임아웃 오류
    auto config4 = parseConfig("8080", "localhost", "5000");
    if (!config4) {
        std::cout << "설정 파싱 실패: " << config4.error().message << std::endl;
    }
    
    return 0;
}
```

이 코드의 핵심은 `and_then`으로 여러 단계의 검증을 연결하는 것이다. 첫 번째 작업이 실패하면 나머지 작업은 실행되지 않고, 오류가 즉시 반환된다. 이는 Rust의 `?` 연산자와 매우 유사한 동작이다.

### 11.1.3 map과 transform을 사용한 값 변환
`std::expected`는 `map` 메서드를 통해 성공한 값을 변환할 수 있다. 실패한 경우는 오류가 그대로 유지된다.

```cpp
#include <iostream>
#include <expected>
#include <string>
#include <vector>

struct ValidationError {
    std::string message;
};

// 문자열을 대문자로 변환
std::expected<std::string, ValidationError> toUpperCase(const std::string& str) {
    if (str.empty()) {
        return std::unexpected(ValidationError{"빈 문자열"});
    }
    
    std::string result = str;
    for (char& c : result) {
        c = std::toupper(static_cast<unsigned char>(c));
    }
    return result;
}

// 문자열을 정수로 변환
std::expected<int, ValidationError> toInteger(const std::string& str) {
    if (str.empty()) {
        return std::unexpected(ValidationError{"빈 문자열"});
    }
    
    try {
        return std::stoi(str);
    }
    catch (...) {
        return std::unexpected(ValidationError{"정수 변환 실패"});
    }
}

int main() {
    std::cout << "=== map을 사용한 값 변환 ===" << std::endl;
    
    // 문자열을 대문자로 변환한 후 길이를 구하기
    auto result1 = toUpperCase("hello")
        .map([](const std::string& s) { return s.length(); });
    
    if (result1) {
        std::cout << "변환된 문자열의 길이: " << result1.value() << std::endl;
    }
    
    // 정수에 10을 곱하기
    auto result2 = toInteger("5")
        .map([](int num) { return num * 10; });
    
    if (result2) {
        std::cout << "5 * 10 = " << result2.value() << std::endl;
    }
    
    // 실패 케이스 - 오류는 유지된다
    auto result3 = toInteger("abc")
        .map([](int num) { return num * 10; });
    
    if (!result3) {
        std::cout << "변환 실패: " << result3.error().message << std::endl;
    }
    
    // 여러 map을 체이닝
    auto result4 = toInteger("3")
        .map([](int n) { return n + 1; })      // 4
        .map([](int n) { return n * 2; })      // 8
        .map([](int n) { return n + 2; });     // 10
    
    if (result4) {
        std::cout << "체이닝 결과: ((3+1)*2)+2 = " << result4.value() << std::endl;
    }
    
    return 0;
}
```
 
### 11.1.4 or_else와 recover_from을 사용한 오류 처리
오류가 발생했을 때 다른 방법으로 복구할 수 있다. `or_else` 메서드를 사용하면 실패한 경우에 대체 처리를 할 수 있다.

```cpp
#include <iostream>
#include <expected>
#include <string>
#include <fstream>

struct ReadError {
    std::string message;
};

// 파일에서 설정을 읽으려고 시도
std::expected<std::string, ReadError> readConfigFromFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return std::unexpected(ReadError{"파일을 열 수 없습니다: " + filename});
    }
    
    std::string content;
    std::getline(file, content);
    return content;
}

// 기본 설정을 제공
std::expected<std::string, ReadError> getDefaultConfig() {
    return "host=localhost;port=8080;timeout=300";
}

// 환경 변수에서 읽기
std::expected<std::string, ReadError> readFromEnvironment() {
    const char* config = std::getenv("APP_CONFIG");
    if (config != nullptr) {
        return std::string(config);
    }
    return std::unexpected(ReadError{"환경 변수가 설정되지 않았습니다"});
}

int main() {
    std::cout << "=== or_else를 사용한 오류 처리 ===" << std::endl;
    
    // 파일에서 읽기를 시도, 실패하면 환경 변수 시도, 그것도 실패하면 기본값
    auto config = readConfigFromFile("config.ini")
        .or_else([](const ReadError&) {
            std::cout << "설정 파일을 찾을 수 없습니다. 환경 변수를 확인합니다..." << std::endl;
            return readFromEnvironment();
        })
        .or_else([](const ReadError&) {
            std::cout << "환경 변수도 설정되지 않았습니다. 기본값을 사용합니다." << std::endl;
            return getDefaultConfig();
        });
    
    if (config) {
        std::cout << "최종 설정: " << config.value() << std::endl;
    } else {
        std::cout << "모든 설정 방법이 실패했습니다" << std::endl;
    }
    
    return 0;
}
```
  


## 11.2 결과 타입 패턴 구현

### 11.2.1 Result 타입의 설계
실무에서는 `std::expected`를 기반으로 자신의 프로젝트에 맞는 `Result` 타입을 정의하는 것이 좋다. 이렇게 하면 일관된 오류 처리를 할 수 있다.

```cpp
#include <iostream>
#include <expected>
#include <string>
#include <variant>
#include <vector>

// ========== 오류 타입 정의 ==========

class Error {
public:
    enum class Code {
        None = 0,
        InvalidInput = 1,
        IOError = 2,
        NetworkError = 3,
        ValidationError = 4,
        UnknownError = 999
    };
    
private:
    Code code;
    std::string message;
    std::string context;  // 추가 컨텍스트 정보
    
public:
    Error(Code c = Code::UnknownError, 
          const std::string& msg = "", 
          const std::string& ctx = "")
        : code(c), message(msg), context(ctx) {}
    
    Code getCode() const { return code; }
    const std::string& getMessage() const { return message; }
    const std::string& getContext() const { return context; }
    
    std::string toString() const {
        std::string result = "[Error " + std::to_string(static_cast<int>(code)) + "] ";
        result += message;
        if (!context.empty()) {
            result += " (Context: " + context + ")";
        }
        return result;
    }
    
    // 오류 종류별 생성 함수
    static Error invalidInput(const std::string& msg) {
        return Error(Code::InvalidInput, msg);
    }
    
    static Error ioError(const std::string& msg) {
        return Error(Code::IOError, msg);
    }
    
    static Error networkError(const std::string& msg) {
        return Error(Code::NetworkError, msg);
    }
    
    static Error validationError(const std::string& msg) {
        return Error(Code::ValidationError, msg);
    }
};

// ========== Result 타입 정의 ==========

template <typename T>
using Result = std::expected<T, Error>;

// ========== 비즈니스 로직 함수들 ==========

struct User {
    int id;
    std::string name;
    std::string email;
};

// 사용자 ID 검증
Result<int> validateUserId(int id) {
    if (id < 1) {
        return std::unexpected(Error::validationError("사용자 ID는 1 이상이어야 합니다"));
    }
    if (id > 1000000) {
        return std::unexpected(Error::validationError("사용자 ID가 너무 깁니다"));
    }
    return id;
}

// 이메일 검증
Result<std::string> validateEmail(const std::string& email) {
    if (email.empty()) {
        return std::unexpected(Error::invalidInput("이메일이 비어있습니다"));
    }
    
    size_t atPos = email.find('@');
    if (atPos == std::string::npos) {
        return std::unexpected(Error::validationError("유효한 이메일 형식이 아닙니다"));
    }
    
    return email;
}

// 사용자명 검증
Result<std::string> validateName(const std::string& name) {
    if (name.empty()) {
        return std::unexpected(Error::invalidInput("사용자명이 비어있습니다"));
    }
    if (name.length() > 100) {
        return std::unexpected(Error::validationError("사용자명이 너무 깁니다"));
    }
    return name;
}

// 사용자 생성 (모든 검증을 통합)
Result<User> createUser(int id, const std::string& name, const std::string& email) {
    return validateUserId(id)
        .and_then([&name, &email](int validId) -> Result<User> {
            return validateName(name)
                .and_then([validId, &email](const std::string& validName) -> Result<User> {
                    return validateEmail(email)
                        .map([validId, &validName](const std::string& validEmail) {
                            return User{validId, validName, validEmail};
                        });
                });
        });
}

int main() {
    std::cout << "=== Result 타입 패턴 ===" << std::endl;
    
    // 성공 케이스
    auto user1 = createUser(1, "John Doe", "john@example.com");
    if (user1) {
        std::cout << "사용자 생성 성공:" << std::endl;
        std::cout << "  ID: " << user1->id << std::endl;
        std::cout << "  이름: " << user1->name << std::endl;
        std::cout << "  이메일: " << user1->email << std::endl;
    }
    
    // 실패 케이스들
    std::cout << "\n=== 실패 케이스들 ===" << std::endl;
    
    auto user2 = createUser(-1, "Jane Doe", "jane@example.com");
    if (!user2) {
        std::cout << user2.error().toString() << std::endl;
    }
    
    auto user3 = createUser(2, "", "bob@example.com");
    if (!user3) {
        std::cout << user3.error().toString() << std::endl;
    }
    
    auto user4 = createUser(3, "Alice", "invalid-email");
    if (!user4) {
        std::cout << user4.error().toString() << std::endl;
    }
    
    return 0;
}
```

### 11.2.2 Result 타입과 컬렉션 처리
`Result` 타입을 사용하면서 여러 항목을 처리할 때는 특별한 주의가 필요하다. 하나라도 실패하면 전체 작업이 실패해야 하는 경우가 있기 때문이다.

```cpp
#include <iostream>
#include <expected>
#include <vector>
#include <string>
#include <algorithm>

class ParseError {
public:
    std::string message;
};

template <typename T>
using Result = std::expected<T, ParseError>;

// 정수 파싱
Result<int> parseInt(const std::string& str) {
    if (str.empty()) {
        return std::unexpected(ParseError{"빈 문자열"});
    }
    try {
        return std::stoi(str);
    }
    catch (...) {
        return std::unexpected(ParseError{"'" + str + "'는 정수가 아닙니다"});
    }
}

// 여러 문자열을 정수로 변환 - 하나라도 실패하면 전체 실패
Result<std::vector<int>> parseIntegers(const std::vector<std::string>& strings) {
    std::vector<int> results;
    
    for (const auto& str : strings) {
        auto result = parseInt(str);
        if (!result) {
            return std::unexpected(result.error());
        }
        results.push_back(result.value());
    }
    
    return results;
}

// 더 간결한 버전: 함수형 스타일
Result<std::vector<int>> parseIntegersCollect(const std::vector<std::string>& strings) {
    std::vector<int> results;
    results.reserve(strings.size());
    
    for (const auto& str : strings) {
        // 각 파싱이 실패하면 바로 반환
        auto value = parseInt(str)?;  // C++23의 문법
        results.push_back(value);
    }
    
    return results;
}

int main() {
    std::cout << "=== Result와 컬렉션 처리 ===" << std::endl;
    
    // 성공 케이스
    std::vector<std::string> validStrings = {"10", "20", "30"};
    auto result1 = parseIntegers(validStrings);
    
    if (result1) {
        std::cout << "파싱 성공: ";
        for (int num : result1.value()) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    }
    
    // 실패 케이스
    std::vector<std::string> invalidStrings = {"10", "abc", "30"};
    auto result2 = parseIntegers(invalidStrings);
    
    if (!result2) {
        std::cout << "파싱 실패: " << result2.error().message << std::endl;
    }
    
    return 0;
}
```
  


## 11.3 예외 vs 오류 코드: 적재적소 활용법

### 11.3.1 각 방식의 장단점 이해
C++에서는 여러 오류 처리 방식이 있다. 각각의 장단점을 이해하고 상황에 맞게 사용해야 한다.

```cpp
#include <iostream>
#include <string>
#include <expected>
#include <variant>

// ========== 오류 코드 방식 ==========
class ErrorCode {
public:
    enum class Value {
        Success = 0,
        FileNotFound = 1,
        PermissionDenied = 2,
        InvalidFormat = 3
    };
    
    Value code;
    std::string message;
    
    ErrorCode(Value c = Value::Success, const std::string& msg = "")
        : code(c), message(msg) {}
    
    bool isSuccess() const { return code == Value::Success; }
    bool isFailed() const { return code != Value::Success; }
};

// 오류 코드를 반환하는 함수
ErrorCode readFileWithCode(const std::string& filename, std::string& content) {
    if (filename.empty()) {
        return ErrorCode(ErrorCode::Value::InvalidFormat, "파일명이 비어있습니다");
    }
    // 실제 파일 읽기 시뮬레이션
    if (filename == "restricted.txt") {
        return ErrorCode(ErrorCode::Value::PermissionDenied, "권한이 없습니다");
    }
    if (filename == "nonexistent.txt") {
        return ErrorCode(ErrorCode::Value::FileNotFound, "파일을 찾을 수 없습니다");
    }
    content = "파일 내용";
    return ErrorCode(ErrorCode::Value::Success);
}

// ========== 예외 방식 ==========
class FileException : public std::exception {
private:
    std::string message;
    
public:
    FileException(const std::string& msg) : message(msg) {}
    const char* what() const noexcept override { return message.c_str(); }
};

void readFileWithException(const std::string& filename, std::string& content) {
    if (filename.empty()) {
        throw FileException("파일명이 비어있습니다");
    }
    if (filename == "restricted.txt") {
        throw FileException("권한이 없습니다");
    }
    if (filename == "nonexistent.txt") {
        throw FileException("파일을 찾을 수 없습니다");
    }
    content = "파일 내용";
}

// ========== std::expected 방식 ==========
struct FileError {
    std::string message;
};

std::expected<std::string, FileError> readFileWithExpected(const std::string& filename) {
    if (filename.empty()) {
        return std::unexpected(FileError{"파일명이 비어있습니다"});
    }
    if (filename == "restricted.txt") {
        return std::unexpected(FileError{"권한이 없습니다"});
    }
    if (filename == "nonexistent.txt") {
        return std::unexpected(FileError{"파일을 찾을 수 없습니다"});
    }
    return std::string("파일 내용");
}

int main() {
    std::cout << "=== 오류 처리 방식 비교 ===" << std::endl;
    
    // 오류 코드 방식
    std::cout << "\n1. 오류 코드 방식:" << std::endl;
    std::string content;
    ErrorCode result = readFileWithCode("test.txt", content);
    if (result.isSuccess()) {
        std::cout << "성공: " << content << std::endl;
    } else {
        std::cout << "실패: " << result.message << std::endl;
    }
    
    // 예외 방식
    std::cout << "\n2. 예외 방식:" << std::endl;
    try {
        std::string content2;
        readFileWithException("test.txt", content2);
        std::cout << "성공: " << content2 << std::endl;
    }
    catch (const FileException& e) {
        std::cout << "실패: " << e.what() << std::endl;
    }
    
    // std::expected 방식
    std::cout << "\n3. std::expected 방식:" << std::endl;
    auto result3 = readFileWithExpected("test.txt");
    if (result3) {
        std::cout << "성공: " << result3.value() << std::endl;
    } else {
        std::cout << "실패: " << result3.error().message << std::endl;
    }
    
    return 0;
}
```

### 11.3.2 방식별 선택 기준
각 오류 처리 방식을 언제 사용할지에 대한 명확한 가이드를 제시하자.

```cpp
#include <iostream>
#include <string>
#include <expected>
#include <vector>

// 선택 기준 설명서

void demonstrateExceptionUsage() {
    std::cout << "=== 예외를 사용해야 할 때 ===" << std::endl;
    std::cout << "1. 비정상적인 상황 (프로그래머 오류, 런타임 오류)" << std::endl;
    std::cout << "2. 여러 레벨의 함수에서 오류가 전파되어야 할 때" << std::endl;
    std::cout << "3. 오류 발생 시 복잡한 정리 작업이 필요할 때" << std::endl;
    std::cout << "4. RAII와 함께 사용하여 자원을 안전하게 정리할 때" << std::endl;
}

void demonstrateResultUsage() {
    std::cout << "\n=== std::expected를 사용해야 할 때 ===" << std::endl;
    std::cout << "1. 예상 가능한 오류 (입력 검증, 파일 찾기)" << std::endl;
    std::cout << "2. 성능이 중요한 경우 (예외의 오버헤드 회피)" << std::endl;
    std::cout << "3. 함수형 프로그래밍 스타일을 사용할 때" << std::endl;
    std::cout << "4. 오류를 명시적으로 처리하도록 강제하고 싶을 때" << std::endl;
}

void demonstrateErrorCodeUsage() {
    std::cout << "\n=== 오류 코드를 사용해야 할 때 ===" << std::endl;
    std::cout << "1. C 라이브러리와의 인터페이스" << std::endl;
    std::cout << "2. 레거시 코드와의 호환성이 필요할 때" << std::endl;
    std::cout << "3. 임베디드 시스템 같이 예외 사용이 제약될 때" << std::endl;
}

// 실제 사용 예제
struct ValidationError {
    std::string message;
};

template <typename T>
using Result = std::expected<T, ValidationError>;

// 예외를 사용하는 경우: 프로그래머 오류
void assertPrecondition(bool condition, const std::string& message) {
    if (!condition) {
        throw std::logic_error("전제 조건 위반: " + message);
    }
}

// std::expected를 사용하는 경우: 예상 가능한 오류
Result<int> parseIntWithValidation(const std::string& str) {
    if (str.empty()) {
        return std::unexpected(ValidationError{"빈 문자열"});
    }
    try {
        return std::stoi(str);
    }
    catch (...) {
        return std::unexpected(ValidationError{"정수 변환 실패"});
    }
}

int main() {
    demonstrateExceptionUsage();
    demonstrateResultUsage();
    demonstrateErrorCodeUsage();
    
    std::cout << "\n=== 실제 사용 예제 ===" << std::endl;
    
    // 프로그래머 오류 - 예외
    try {
        assertPrecondition(1 + 1 == 2, "기본 수학");
        std::cout << "전제 조건 확인: 통과" << std::endl;
    }
    catch (const std::logic_error& e) {
        std::cout << "전제 조건 확인: 실패 - " << e.what() << std::endl;
    }
    
    // 예상 가능한 오류 - std::expected
    auto result = parseIntWithValidation("123");
    if (result) {
        std::cout << "파싱 성공: " << result.value() << std::endl;
    } else {
        std::cout << "파싱 실패: " << result.error().message << std::endl;
    }
    
    return 0;
}
```
 


## 11.4 오류 전파와 변환 패턴

### 11.4.1 오류 전파하기
오류가 발생했을 때, 그 오류 정보를 상위 레벨로 전파하면서 추가 정보를 붙이는 것이 중요하다.

```cpp
#include <iostream>
#include <expected>
#include <string>
#include <optional>

// ========== 다층 오류 정보 ==========

class ErrorContext {
public:
    enum class Level {
        Network,
        Protocol,
        Application
    };
    
private:
    Level level;
    std::string message;
    std::string context;
    
public:
    ErrorContext(Level l, const std::string& msg)
        : level(l), message(msg) {}
    
    void addContext(const std::string& ctx) {
        context = ctx;
    }
    
    std::string toString() const {
        std::string result;
        result += "[" + levelToString() + "] " + message;
        if (!context.empty()) {
            result += " (" + context + ")";
        }
        return result;
    }
    
private:
    std::string levelToString() const {
        switch (level) {
            case Level::Network: return "Network";
            case Level::Protocol: return "Protocol";
            case Level::Application: return "Application";
            default: return "Unknown";
        }
    }
};

template <typename T>
using Result = std::expected<T, ErrorContext>;

// ========== 다층 처리 함수들 ==========

// 네트워크 계층
Result<std::string> sendPacket(const std::string& data) {
    if (data.empty()) {
        return std::unexpected(ErrorContext(ErrorContext::Level::Network, "데이터가 비어있습니다"));
    }
    return "packet_sent";
}

// 프로토콜 계층
Result<std::string> encodeMessage(const std::string& message) {
    return sendPacket(message)
        .map_error([&message](auto error) {
            error.addContext("메시지 인코딩 중: '" + message + "'");
            return error;
        });
}

// 애플리케이션 계층
Result<std::string> processRequest(const std::string& request) {
    return encodeMessage(request)
        .map_error([&request](auto error) {
            error.addContext("요청 처리 중: '" + request + "'");
            return error;
        });
}

int main() {
    std::cout << "=== 오류 전파와 컨텍스트 추가 ===" << std::endl;
    
    auto result = processRequest("Hello Server");
    
    if (!result) {
        std::cout << "오류: " << result.error().toString() << std::endl;
    } else {
        std::cout << "성공: " << result.value() << std::endl;
    }
    
    // 빈 메시지로 시도
    auto failedResult = processRequest("");
    if (!failedResult) {
        std::cout << "\n빈 메시지 처리:" << std::endl;
        std::cout << failedResult.error().toString() << std::endl;
    }
    
    return 0;
}
```

### 11.4.2 오류 변환과 재시도
때때로 오류를 다른 타입으로 변환하거나, 실패한 작업을 재시도해야 할 수 있다.

```cpp
#include <iostream>
#include <expected>
#include <string>
#include <iostream>

// ========== 다양한 오류 타입 ==========

class NetworkError {
public:
    std::string message;
    int errorCode;
    
    NetworkError(const std::string& msg, int code = 0)
        : message(msg), errorCode(code) {}
};

class ApplicationError {
public:
    std::string message;
    
    ApplicationError(const std::string& msg) : message(msg) {}
};

// 오류 변환
ApplicationError convertError(const NetworkError& netError) {
    return ApplicationError("네트워크 오류: " + netError.message + 
                          " (코드: " + std::to_string(netError.errorCode) + ")");
}

// ========== 재시도 로직 ==========

template <typename T>
using NetResult = std::expected<T, NetworkError>;

template <typename T>
using AppResult = std::expected<T, ApplicationError>;

// 네트워크 작업을 시뮬레이션
int attemptCount = 0;

NetResult<std::string> fetchDataFromNetwork() {
    attemptCount++;
    std::cout << "네트워크 시도 #" << attemptCount << std::endl;
    
    if (attemptCount < 3) {
        // 처음 2번은 실패
        return std::unexpected(
            NetworkError("연결 타임아웃", 408)
        );
    }
    
    // 3번째 시도에서 성공
    return std::string("데이터: 성공");
}

// 재시도 로직이 포함된 함수
AppResult<std::string> fetchDataWithRetry(int maxRetries = 3) {
    for (int i = 0; i < maxRetries; ++i) {
        auto result = fetchDataFromNetwork();
        
        if (result) {
            return result.value();
        }
        
        const auto& error = result.error();
        std::cout << "  실패: " << error.message << std::endl;
        
        if (i < maxRetries - 1) {
            std::cout << "  재시도 중..." << std::endl;
        }
    }
    
    // 모든 재시도가 실패
    auto lastError = fetchDataFromNetwork().error();
    return std::unexpected(convertError(lastError));
}

// 오류 변환 함수
AppResult<std::string> processNetworkResult(
    const NetResult<std::string>& netResult) {
    
    if (netResult) {
        return netResult.value();
    }
    
    // 오류를 변환
    return std::unexpected(convertError(netResult.error()));
}

int main() {
    std::cout << "=== 오류 변환과 재시도 ===" << std::endl;
    
    // 재시도 로직 사용
    std::cout << "\n재시도 로직:" << std::endl;
    auto result = fetchDataWithRetry();
    
    if (result) {
        std::cout << "최종 결과: " << result.value() << std::endl;
    } else {
        std::cout << "모든 시도 실패: " << result.error().message << std::endl;
    }
    
    return 0;
}
```
  


## 11.5 종합 실습: 안전한 JSON 파서
지금까지 배운 모든 오류 처리 기법을 종합하여 안전한 JSON 파서를 만들어보자.

```cpp
#include <iostream>
#include <expected>
#include <string>
#include <vector>
#include <map>
#include <variant>
#include <memory>

// ========== 오류 정의 ==========

class JsonError {
public:
    enum class Code {
        SyntaxError,
        UnexpectedToken,
        InvalidValue,
        MissingKey,
        TypeMismatch,
        ParseError
    };
    
private:
    Code code;
    std::string message;
    size_t position;
    
public:
    JsonError(Code c, const std::string& msg, size_t pos = 0)
        : code(c), message(msg), position(pos) {}
    
    std::string toString() const {
        return "JSON Error at position " + std::to_string(position) + 
               ": " + message;
    }
    
    Code getCode() const { return code; }
    size_t getPosition() const { return position; }
};

template <typename T>
using JsonResult = std::expected<T, JsonError>;

// ========== JSON 값 정의 ==========

using JsonValue = std::variant<
    std::nullptr_t,
    bool,
    double,
    std::string,
    std::vector<std::variant<std::nullptr_t, bool, double, std::string>>,
    std::map<std::string, std::string>
>;

// ========== JSON 파서 ==========

class JsonParser {
private:
    std::string input;
    size_t pos = 0;
    
    // 현재 문자를 반환
    std::optional<char> current() const {
        if (pos >= input.length()) {
            return std::nullopt;
        }
        return input[pos];
    }
    
    // 다음 문자로 이동
    void advance() {
        if (pos < input.length()) {
            pos++;
        }
    }
    
    // 공백 건너뛰기
    void skipWhitespace() {
        while (current() && std::isspace(current().value())) {
            advance();
        }
    }
    
public:
    JsonParser(const std::string& json) : input(json) {}
    
    // 문자열 파싱
    JsonResult<std::string> parseString() {
        skipWhitespace();
        
        if (current() != '"') {
            return std::unexpected(
                JsonError(JsonError::Code::UnexpectedToken, 
                         "Expected '\"'", pos)
            );
        }
        
        advance();  // '"' 건너뛰기
        std::string result;
        
        while (current() && current() != '"') {
            result += current().value();
            advance();
        }
        
        if (!current()) {
            return std::unexpected(
                JsonError(JsonError::Code::SyntaxError, 
                         "Unterminated string", pos)
            );
        }
        
        advance();  // 마지막 '"' 건너뛰기
        return result;
    }
    
    // 숫자 파싱
    JsonResult<double> parseNumber() {
        skipWhitespace();
        
        size_t start = pos;
        
        // 선택적 마이너스 기호
        if (current() == '-') {
            advance();
        }
        
        // 숫자 부분
        while (current() && std::isdigit(current().value())) {
            advance();
        }
        
        // 소수점 부분
        if (current() == '.') {
            advance();
            while (current() && std::isdigit(current().value())) {
                advance();
            }
        }
        
        if (pos == start) {
            return std::unexpected(
                JsonError(JsonError::Code::InvalidValue, 
                         "Invalid number", start)
            );
        }
        
        try {
            return std::stod(input.substr(start, pos - start));
        }
        catch (...) {
            return std::unexpected(
                JsonError(JsonError::Code::ParseError, 
                         "Number parsing failed", start)
            );
        }
    }
    
    // 불린 파싱
    JsonResult<bool> parseBoolean() {
        skipWhitespace();
        
        if (input.substr(pos, 4) == "true") {
            pos += 4;
            return true;
        }
        
        if (input.substr(pos, 5) == "false") {
            pos += 5;
            return false;
        }
        
        return std::unexpected(
            JsonError(JsonError::Code::UnexpectedToken, 
                     "Expected 'true' or 'false'", pos)
        );
    }
    
    // null 파싱
    JsonResult<std::nullptr_t> parseNull() {
        skipWhitespace();
        
        if (input.substr(pos, 4) == "null") {
            pos += 4;
            return nullptr;
        }
        
        return std::unexpected(
            JsonError(JsonError::Code::UnexpectedToken, 
                     "Expected 'null'", pos)
        );
    }
    
    // 값 파싱
    JsonResult<std::string> parseValue() {
        skipWhitespace();
        
        auto ch = current();
        if (!ch) {
            return std::unexpected(
                JsonError(JsonError::Code::UnexpectedToken, 
                         "Unexpected end of input", pos)
            );
        }
        
        // 타입에 따라 적절한 파서 호출
        if (ch == '"') {
            return parseString();
        }
        else if (ch == '-' || std::isdigit(ch.value())) {
            return parseNumber()
                .map([](double num) { return std::to_string(num); });
        }
        else if (ch == 't' || ch == 'f') {
            return parseBoolean()
                .map([](bool b) { return b ? "true" : "false"; });
        }
        else if (ch == 'n') {
            return parseNull()
                .map([](std::nullptr_t) { return "null"; });
        }
        
        return std::unexpected(
            JsonError(JsonError::Code::UnexpectedToken, 
                     "Unexpected character", pos)
        );
    }
};

// ========== 메인 프로그램 ==========

int main() {
    std::cout << "=== 안전한 JSON 파서 ===" << std::endl;
    
    // 테스트 케이스들
    std::vector<std::string> testCases = {
        "\"hello world\"",
        "42",
        "3.14",
        "true",
        "false",
        "null",
        "invalid",
        "\"unterminated"
    };
    
    for (const auto& testCase : testCases) {
        std::cout << "\n파싱: " << testCase << std::endl;
        
        JsonParser parser(testCase);
        auto result = parser.parseValue();
        
        if (result) {
            std::cout << "성공: " << result.value() << std::endl;
        } else {
            std::cout << "실패: " << result.error().toString() << std::endl;
        }
    }
    
    return 0;
}
```

이 JSON 파서는 다음의 안전성 기법들을 종합적으로 사용한다:

1. **std::expected**: 파싱 결과를 명시적으로 표현
2. **오류 컨텍스트**: 오류 위치와 메시지를 함께 제공
3. **체이닝**: `and_then`과 `map`을 사용한 함수형 처리
4. **타입 안전성**: 각 함수가 명시적인 타입을 반환
  


## 결론
이 장에서 배운 내용을 정리하면 다음과 같다.

**std::expected**는 오류를 타입 안전하게 표현하며, 함수형 프로그래밍 스타일의 체이닝을 지원한다. 이는 예외의 오버헤드 없이 안전한 오류 처리를 가능하게 한다.

**Result 타입 패턴**을 사용하면 프로젝트 전체에서 일관된 오류 처리를 할 수 있다. 이는 코드의 가독성과 유지보수성을 크게 향상시킨다.

**예외, 오류 코드, std::expected의 선택**은 상황에 맞게 해야 한다. 예외는 비정상적인 상황에, std::expected는 예상 가능한 오류에, 오류 코드는 레거시 코드와의 호환성이 필요할 때 사용한다.

**오류 전파와 변환**은 여러 레벨의 함수를 통해 오류 정보를 전달하면서 각 레벨에서 필요한 정보를 추가하는 것을 의미한다.

이 모든 기법들을 조합하면 C++에서도 Rust처럼 안전하고 명확한 오류 처리를 할 수 있다. Modern C++의 이러한 기능들은 프로그래밍을 더욱 안전하고 우아하게 만든다.

다음 장에서는 C++의 동시성 기능에 대해 배울 것이다. 멀티스레드 환경에서도 여기서 배운 오류 처리 기법을 어떻게 적용하는지 살펴볼 것이다.  