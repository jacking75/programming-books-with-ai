# Modern C++로 안전하고 우아한 프로그래밍  

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 17: 크로스 플랫폼 라이브러리 설계
우리가 작성한 C++ 코드를 다른 개발자들이 사용할 수 있는 라이브러리로 만드는 것은 매우 중요한 기술이다. 특히 Windows, Linux, macOS 등 여러 플랫폼에서 동작하는 라이브러리를 설계하려면 신중한 계획이 필요하다. 이 장에서는 안전하고 유지보수하기 쉬운 크로스 플랫폼 라이브러리를 설계하는 방법을 배운다.

## 17.1 헤더 온리 라이브러리 설계 패턴
헤더 온리(Header-Only) 라이브러리는 모든 구현이 헤더 파일에 들어있는 라이브러리다. 이 방식은 사용자가 별도로 컴파일된 라이브러리 파일을 링크할 필요가 없으므로 배포가 매우 간단하다.

먼저 헤더 온리 라이브러리의 구조를 살펴보자.

```
math_lib/
├── include/
│   └── math_lib/
│       ├── vector.hpp
│       ├── matrix.hpp
│       ├── quaternion.hpp
│       └── math_lib.hpp (main header)
├── tests/
│   └── test_vector.cpp
├── examples/
│   └── example_usage.cpp
├── CMakeLists.txt
└── README.md
```

헤더 온리 라이브러리는 `inline` 함수와 템플릿을 주로 사용한다. 이렇게 하면 컴파일러가 사용자의 코드로 직접 함수를 전개(inline)할 수 있다.

다음은 헤더 온리 라이브러리의 예제다.

```cpp
// include/math_lib/vector.hpp
#ifndef MATH_LIB_VECTOR_HPP
#define MATH_LIB_VECTOR_HPP

#include <cmath>
#include <array>
#include <algorithm>
#include <stdexcept>

namespace math_lib {
    // 3D 벡터 클래스
    class Vector3 {
    private:
        std::array<float, 3> data_;

    public:
        // 기본 생성자
        constexpr Vector3() : data_{0.0f, 0.0f, 0.0f} {}

        // 초기화 생성자
        constexpr Vector3(float x, float y, float z)
            : data_{x, y, z} {}

        // 원소 접근 (안전한 범위 검사)
        float& operator[](size_t idx) {
            if (idx >= 3) {
                throw std::out_of_range("Vector3 index out of range");
            }
            return data_[idx];
        }

        float operator[](size_t idx) const {
            if (idx >= 3) {
                throw std::out_of_range("Vector3 index out of range");
            }
            return data_[idx];
        }

        // 개명 접근자
        float x() const { return data_[0]; }
        float y() const { return data_[1]; }
        float z() const { return data_[2]; }

        // 벡터 덧셈
        Vector3& operator+=(const Vector3& other) {
            data_[0] += other.data_[0];
            data_[1] += other.data_[1];
            data_[2] += other.data_[2];
            return *this;
        }

        Vector3 operator+(const Vector3& other) const {
            Vector3 result = *this;
            result += other;
            return result;
        }

        // 벡터 뺄셈
        Vector3 operator-(const Vector3& other) const {
            return Vector3(
                data_[0] - other.data_[0],
                data_[1] - other.data_[1],
                data_[2] - other.data_[2]
            );
        }

        // 스칼라 곱셈
        Vector3 operator*(float scalar) const {
            return Vector3(
                data_[0] * scalar,
                data_[1] * scalar,
                data_[2] * scalar
            );
        }

        // 내적
        float dot(const Vector3& other) const {
            return data_[0] * other.data_[0] +
                   data_[1] * other.data_[1] +
                   data_[2] * other.data_[2];
        }

        // 외적
        Vector3 cross(const Vector3& other) const {
            return Vector3(
                data_[1] * other.data_[2] - data_[2] * other.data_[1],
                data_[2] * other.data_[0] - data_[0] * other.data_[2],
                data_[0] * other.data_[1] - data_[1] * other.data_[0]
            );
        }

        // 크기 계산
        float magnitude() const {
            return std::sqrt(data_[0] * data_[0] +
                           data_[1] * data_[1] +
                           data_[2] * data_[2]);
        }

        // 정규화
        Vector3 normalized() const {
            float mag = magnitude();
            if (mag < 1e-6f) {
                throw std::runtime_error("Cannot normalize zero vector");
            }
            return Vector3(
                data_[0] / mag,
                data_[1] / mag,
                data_[2] / mag
            );
        }

        // 비교 연산자
        bool operator==(const Vector3& other) const {
            const float epsilon = 1e-6f;
            return std::abs(data_[0] - other.data_[0]) < epsilon &&
                   std::abs(data_[1] - other.data_[1]) < epsilon &&
                   std::abs(data_[2] - other.data_[2]) < epsilon;
        }

        bool operator!=(const Vector3& other) const {
            return !(*this == other);
        }
    };

    // 전역 연산자: 스칼라 * 벡터
    inline Vector3 operator*(float scalar, const Vector3& v) {
        return v * scalar;
    }
}

#endif // MATH_LIB_VECTOR_HPP
```

이 코드는 헤더 온리 라이브러리의 표준 형식을 보여준다. 설명하자면 먼저 `#ifndef` 가드를 사용하여 중복 포함을 방지한다. 모든 함수는 `inline`이거나 템플릿이므로 여러 번역 단위에서 포함되어도 링크 에러가 발생하지 않는다.

이제 좀 더 복잡한 템플릿 기반 예제를 살펴보자. 제네릭 프로그래밍을 사용하면 다양한 타입을 지원하는 라이브러리를 만들 수 있다.

```cpp
// include/math_lib/matrix.hpp
#ifndef MATH_LIB_MATRIX_HPP
#define MATH_LIB_MATRIX_HPP

#include <array>
#include <algorithm>
#include <numeric>
#include <stdexcept>

namespace math_lib {
    // M×N 크기의 제네릭 행렬 클래스
    template<typename T, size_t Rows, size_t Cols>
    class Matrix {
    private:
        std::array<std::array<T, Cols>, Rows> data_;

    public:
        // 기본 생성자: 모든 원소를 0으로 초기화
        Matrix() {
            for (auto& row : data_) {
                row.fill(T(0));
            }
        }

        // 단일 값으로 초기화
        explicit Matrix(T value) {
            for (auto& row : data_) {
                row.fill(value);
            }
        }

        // 원소 접근
        T& at(size_t row, size_t col) {
            if (row >= Rows || col >= Cols) {
                throw std::out_of_range("Matrix index out of range");
            }
            return data_[row][col];
        }

        T at(size_t row, size_t col) const {
            if (row >= Rows || col >= Cols) {
                throw std::out_of_range("Matrix index out of range");
            }
            return data_[row][col];
        }

        // 크기 정보
        static constexpr size_t rows() { return Rows; }
        static constexpr size_t cols() { return Cols; }

        // 단위 행렬 생성 (정방 행렬만 가능)
        static Matrix identity() {
            static_assert(Rows == Cols, "Identity matrix requires square matrix");
            Matrix result;
            for (size_t i = 0; i < Rows; ++i) {
                result.data_[i][i] = T(1);
            }
            return result;
        }

        // 행렬 덧셈
        Matrix operator+(const Matrix& other) const {
            Matrix result;
            for (size_t i = 0; i < Rows; ++i) {
                for (size_t j = 0; j < Cols; ++j) {
                    result.data_[i][j] = data_[i][j] + other.data_[i][j];
                }
            }
            return result;
        }

        // 행렬 뺄셈
        Matrix operator-(const Matrix& other) const {
            Matrix result;
            for (size_t i = 0; i < Rows; ++i) {
                for (size_t j = 0; j < Cols; ++j) {
                    result.data_[i][j] = data_[i][j] - other.data_[i][j];
                }
            }
            return result;
        }

        // 스칼라 곱셈
        Matrix operator*(T scalar) const {
            Matrix result;
            for (size_t i = 0; i < Rows; ++i) {
                for (size_t j = 0; j < Cols; ++j) {
                    result.data_[i][j] = data_[i][j] * scalar;
                }
            }
            return result;
        }

        // 행렬 곱셈 (다른 차원의 행렬과 곱셈 가능)
        template<size_t OtherCols>
        Matrix<T, Rows, OtherCols> operator*(const Matrix<T, Cols, OtherCols>& other) const {
            Matrix<T, Rows, OtherCols> result;
            for (size_t i = 0; i < Rows; ++i) {
                for (size_t j = 0; j < OtherCols; ++j) {
                    T sum = T(0);
                    for (size_t k = 0; k < Cols; ++k) {
                        sum += data_[i][k] * other.at(k, j);
                    }
                    result.at(i, j) = sum;
                }
            }
            return result;
        }

        // 전치 행렬
        Matrix<T, Cols, Rows> transpose() const {
            Matrix<T, Cols, Rows> result;
            for (size_t i = 0; i < Rows; ++i) {
                for (size_t j = 0; j < Cols; ++j) {
                    result.at(j, i) = data_[i][j];
                }
            }
            return result;
        }

        // 행렬식 (정방 행렬만)
        T determinant() const {
            static_assert(Rows == Cols, "Determinant requires square matrix");
            
            if constexpr (Rows == 2) {
                return data_[0][0] * data_[1][1] - data_[0][1] * data_[1][0];
            } else {
                static_assert(Rows <= 3, "Determinant only implemented for 2x2 and 3x3");
            }
        }
    };

    // 사용 편의를 위한 타입 별칭
    template<typename T>
    using Matrix2 = Matrix<T, 2, 2>;
    template<typename T>
    using Matrix3 = Matrix<T, 3, 3>;
    template<typename T>
    using Matrix4 = Matrix<T, 4, 4>;
}

#endif // MATH_LIB_MATRIX_HPP
```

이 행렬 클래스의 핵심은 템플릿 메타프로그래밍을 사용한다는 것이다. 행렬의 크기가 템플릿 인자로 주어지므로 컴파일 타임에 확정된다. 따라서 `identity()` 메서드에서 `static_assert`를 사용하여 정방 행렬임을 강제할 수 있다.

이제 메인 헤더 파일을 만들어서 모든 기능을 쉽게 사용하도록 한다.

```cpp
// include/math_lib/math_lib.hpp
#ifndef MATH_LIB_HPP
#define MATH_LIB_HPP

// 모든 구성 요소를 포함한다
#include "vector.hpp"
#include "matrix.hpp"

namespace math_lib {
    // 라이브러리 버전 정보
    inline constexpr int VERSION_MAJOR = 1;
    inline constexpr int VERSION_MINOR = 0;
    inline constexpr int VERSION_PATCH = 0;

    // 라이브러리 정보를 문자열로 반환
    inline std::string get_version() {
        return std::to_string(VERSION_MAJOR) + "." +
               std::to_string(VERSION_MINOR) + "." +
               std::to_string(VERSION_PATCH);
    }
}

#endif // MATH_LIB_HPP
```

헤더 온리 라이브러리의 장점은 사용자가 단순히 헤더 파일을 포함하기만 하면 된다는 것이다. 하지만 단점도 있다. 컴파일 시간이 증가할 수 있고, 구현이 노출되어 지적 재산권 보호가 어려울 수 있다.

헤더 온리 라이브러리를 사용할 때는 인클루드 경로를 올바르게 설정해야 한다.

```cpp
// example.cpp
// 라이브러리 사용 예제
#include "math_lib/math_lib.hpp"
#include <iostream>

int main() {
    using namespace math_lib;

    // 벡터 생성
    Vector3 v1(1.0f, 2.0f, 3.0f);
    Vector3 v2(4.0f, 5.0f, 6.0f);

    // 벡터 연산
    Vector3 sum = v1 + v2;
    std::cout << "Sum: (" << sum.x() << ", " << sum.y() << ", " << sum.z() << ")\n";

    // 내적 계산
    float dot_product = v1.dot(v2);
    std::cout << "Dot product: " << dot_product << "\n";

    // 행렬 생성
    Matrix<float, 3, 3> mat1;
    mat1.at(0, 0) = 1.0f;
    mat1.at(1, 1) = 2.0f;
    mat1.at(2, 2) = 3.0f;

    // 단위 행렬
    auto identity = Matrix<float, 3, 3>::identity();

    return 0;
}
```
  


## 17.2 ABI 안정성과 인터페이스 설계
ABI(Application Binary Interface)는 컴파일된 라이브러리와 사용자 코드 사이의 계약이다. ABI가 깨지면 사용자가 라이브러리를 다시 컴파일해야 한다. 안정적인 인터페이스 설계는 라이브러리의 진화를 가능하게 한다.

첫 번째 원칙은 공개 인터페이스를 최소화하는 것이다.

```cpp
// include/string_lib/string_utils.hpp
#ifndef STRING_LIB_HPP
#define STRING_LIB_HPP

#include <string>
#include <vector>
#include <memory>

namespace string_lib {
    // Pimpl(Pointer to Implementation) 패턴을 사용한 ABI 안정성
    class StringSplitter {
    private:
        // 구현 세부사항을 숨긴다
        class Impl;
        std::unique_ptr<Impl> pimpl_;

    public:
        StringSplitter();
        ~StringSplitter();

        // 복사 가능
        StringSplitter(const StringSplitter& other);
        StringSplitter& operator=(const StringSplitter& other);

        // 이동 가능
        StringSplitter(StringSplitter&&) noexcept;
        StringSplitter& operator=(StringSplitter&&) noexcept;

        // 공개 인터페이스
        std::vector<std::string> split(const std::string& text,
                                       const std::string& delimiter);

        void set_trim_whitespace(bool trim);
        bool get_trim_whitespace() const;
    };
}

#endif
```

이제 구현 파일에서 세부사항을 숨긴다.

```cpp
// src/string_utils.cpp
#include "string_lib/string_utils.hpp"
#include <algorithm>
#include <sstream>

namespace string_lib {
    // 구현 클래스 (헤더에 노출되지 않음)
    class StringSplitter::Impl {
    public:
        bool trim_whitespace = true;

        std::vector<std::string> split(const std::string& text,
                                      const std::string& delimiter) {
            std::vector<std::string> result;
            
            if (text.empty() || delimiter.empty()) {
                result.push_back(text);
                return result;
            }

            size_t start = 0;
            size_t end = text.find(delimiter);

            while (end != std::string::npos) {
                std::string token = text.substr(start, end - start);
                
                if (trim_whitespace) {
                    token = trim(token);
                }
                
                if (!token.empty() || !trim_whitespace) {
                    result.push_back(token);
                }

                start = end + delimiter.length();
                end = text.find(delimiter, start);
            }

            std::string token = text.substr(start);
            if (trim_whitespace) {
                token = trim(token);
            }
            
            if (!token.empty() || !trim_whitespace) {
                result.push_back(token);
            }

            return result;
        }

    private:
        static std::string trim(const std::string& str) {
            auto start = str.begin();
            while (start != str.end() && std::isspace(*start)) {
                ++start;
            }

            auto end = str.end();
            do {
                --end;
            } while (std::distance(start, end) > 0 && std::isspace(*end));

            return std::string(start, end + 1);
        }
    };

    // Pimpl 생성자
    StringSplitter::StringSplitter() : pimpl_(std::make_unique<Impl>()) {}

    // 소멸자
    StringSplitter::~StringSplitter() = default;

    // 복사 생성자
    StringSplitter::StringSplitter(const StringSplitter& other)
        : pimpl_(std::make_unique<Impl>(*other.pimpl_)) {}

    // 복사 할당
    StringSplitter& StringSplitter::operator=(const StringSplitter& other) {
        if (this != &other) {
            pimpl_ = std::make_unique<Impl>(*other.pimpl_);
        }
        return *this;
    }

    // 이동 생성자
    StringSplitter::StringSplitter(StringSplitter&&) noexcept = default;

    // 이동 할당
    StringSplitter& StringSplitter::operator=(StringSplitter&&) noexcept = default;

    // 공개 메서드 구현
    std::vector<std::string> StringSplitter::split(const std::string& text,
                                                    const std::string& delimiter) {
        return pimpl_->split(text, delimiter);
    }

    void StringSplitter::set_trim_whitespace(bool trim) {
        pimpl_->trim_whitespace = trim;
    }

    bool StringSplitter::get_trim_whitespace() const {
        return pimpl_->trim_whitespace;
    }
}
```

Pimpl 패턴의 강점을 설명하자면, 먼저 구현이 헤더에 노출되지 않으므로 내부적으로 자유롭게 변경할 수 있다. 두 번째로 ABI가 안정적이므로 라이브러리를 업그레이드해도 사용자는 다시 컴파일하지 않아도 된다. 세 번째로 컴파일 타임이 단축된다.

다음은 인터페이스 버전 관리의 예제다.

```cpp
// include/versioned_lib/interface.hpp
#ifndef VERSIONED_LIB_INTERFACE_HPP
#define VERSIONED_LIB_INTERFACE_HPP

#include <cstdint>

namespace versioned_lib {
    // 라이브러리 버전
    inline constexpr uint32_t LIBRARY_VERSION = 0x010002;  // 1.0.2

    // 인터페이스 버전 확인
    uint32_t get_interface_version();

    // 버전 호환성 확인
    bool is_compatible(uint32_t required_version);

    // 기본 계산 인터페이스 (버전 1)
    class Calculator {
    public:
        virtual ~Calculator() = default;

        virtual int add(int a, int b) const = 0;
        virtual int subtract(int a, int b) const = 0;

        // 버전 정보
        virtual uint32_t get_version() const {
            return 1;
        }
    };

    // 확장된 계산 인터페이스 (버전 2)
    class AdvancedCalculator : public Calculator {
    public:
        virtual ~AdvancedCalculator() = default;

        virtual int multiply(int a, int b) const = 0;
        virtual int divide(int a, int b) const = 0;

        uint32_t get_version() const override {
            return 2;
        }
    };

    // 팩토리 함수 (인터페이스 생성)
    Calculator* create_calculator(uint32_t version);
    void destroy_calculator(Calculator* calc);
}

#endif
```

이제 구현을 살펴보자.

```cpp
// src/interface.cpp
#include "versioned_lib/interface.hpp"
#include <stdexcept>
#include <memory>

namespace versioned_lib {
    // 기본 계산기 구현
    class BasicCalculator : public Calculator {
    public:
        int add(int a, int b) const override {
            return a + b;
        }

        int subtract(int a, int b) const override {
            return a - b;
        }
    };

    // 확장된 계산기 구현
    class AdvancedCalculatorImpl : public AdvancedCalculator {
    public:
        int add(int a, int b) const override {
            return a + b;
        }

        int subtract(int a, int b) const override {
            return a - b;
        }

        int multiply(int a, int b) const override {
            return a * b;
        }

        int divide(int a, int b) const override {
            if (b == 0) {
                throw std::invalid_argument("Division by zero");
            }
            return a / b;
        }
    };

    // 버전 조회
    uint32_t get_interface_version() {
        return LIBRARY_VERSION;
    }

    // 호환성 확인
    bool is_compatible(uint32_t required_version) {
        // 메이저 버전이 같으면 호환 (1.x.x)
        uint32_t required_major = (required_version >> 16) & 0xFF;
        uint32_t current_major = (LIBRARY_VERSION >> 16) & 0xFF;
        return required_major == current_major;
    }

    // 팩토리 함수 (버전에 맞는 구현 생성)
    Calculator* create_calculator(uint32_t version) {
        if (version == 1) {
            return new BasicCalculator();
        } else if (version == 2) {
            return new AdvancedCalculatorImpl();
        } else {
            throw std::invalid_argument("Unsupported calculator version");
        }
    }

    void destroy_calculator(Calculator* calc) {
        delete calc;
    }
}
```

사용자 코드는 이렇게 작성한다.

```cpp
// example_interface.cpp
#include "versioned_lib/interface.hpp"
#include <iostream>
#include <memory>

int main() {
    using namespace versioned_lib;

    // 버전 확인
    std::cout << "Interface version: " << std::hex << get_interface_version() << "\n";

    // 호환성 확인
    if (is_compatible(0x010000)) {
        std::cout << "Version 1.0.0 is compatible\n";
    }

    // 기본 계산기 생성
    std::unique_ptr<Calculator, decltype([](Calculator* p) { destroy_calculator(p); })>
        calc1(create_calculator(1));

    std::cout << "10 + 5 = " << calc1->add(10, 5) << "\n";
    std::cout << "10 - 3 = " << calc1->subtract(10, 3) << "\n";

    // 고급 계산기 생성
    auto calc2 = dynamic_cast<AdvancedCalculator*>(create_calculator(2));
    if (calc2) {
        std::cout << "10 * 5 = " << calc2->multiply(10, 5) << "\n";
        std::cout << "10 / 2 = " << calc2->divide(10, 2) << "\n";
        destroy_calculator(calc2);
    }

    return 0;
}
```
  


## 17.3 패키지 관리와 의존성 처리
라이브러리가 복잡해지면 다른 라이브러리에 의존하게 된다. 이러한 의존성을 체계적으로 관리해야 한다. C++에서는 CMake와 conan 같은 도구를 사용한다.

먼저 CMakeLists.txt를 작성해보자.

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.20)
project(MathLib
    VERSION 1.0.0
    DESCRIPTION "A cross-platform math library"
    LANGUAGES CXX
)

# C++ 표준 설정
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 헤더 온리 라이브러리 정의
add_library(math_lib INTERFACE)

# 인클루드 디렉토리 설정
target_include_directories(math_lib
    INTERFACE
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)

# 컴파일 특성 설정
target_compile_features(math_lib
    INTERFACE
    cxx_std_20
)

# 경고 레벨 설정
if(MSVC)
    target_compile_options(math_lib INTERFACE /W4)
else()
    target_compile_options(math_lib INTERFACE -Wall -Wextra -Wpedantic)
endif()

# 테스트 활성화
enable_testing()

# 테스트 추가
add_subdirectory(tests)

# 설치 규칙
install(DIRECTORY include/math_lib
    DESTINATION include
)

install(TARGETS math_lib
    EXPORT MathLibTargets
)

install(EXPORT MathLibTargets
    FILE MathLibTargets.cmake
    NAMESPACE MathLib::
    DESTINATION lib/cmake/MathLib
)

# 버전 파일 생성
include(CMakePackageConfigHelpers)

configure_package_config_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/MathLibConfig.cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/MathLibConfig.cmake"
    INSTALL_DESTINATION lib/cmake/MathLib
)

write_basic_package_version_file(
    "${CMAKE_CURRENT_BINARY_DIR}/MathLibConfigVersion.cmake"
    VERSION 1.0.0
    COMPATIBILITY SameMajorVersion
)

install(FILES
    "${CMAKE_CURRENT_BINARY_DIR}/MathLibConfig.cmake"
    "${CMAKE_CURRENT_BINARY_DIR}/MathLibConfigVersion.cmake"
    DESTINATION lib/cmake/MathLib
)
```

이제 conanfile.py를 사용한 의존성 관리를 보자.

```python
# conanfile.py
from conan import ConanFile
from conan.tools.cmake import cmake_layout, CMakeToolchain, CMake

class MathLibConan(ConanFile):
    name = "math_lib"
    version = "1.0.0"
    description = "A cross-platform math library"
    author = "Your Name"
    license = "MIT"
    homepage = "https://github.com/yourname/math_lib"

    settings = "os", "compiler", "build_type", "arch"
    exports_sources = "include/*", "src/*", "CMakeLists.txt"

    # 라이브러리가 의존하는 것들
    requires = ()

    # 개발 의존성
    build_requires = "cmake/3.22"

    # 옵션
    options = {
        "with_tests": [True, False],
        "shared": [True, False],
    }

    default_options = {
        "with_tests": True,
        "shared": False,
    }

    def layout(self):
        cmake_layout(self)

    def generate(self):
        tc = CMakeToolchain(self)
        tc.generate()

    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()

    def package(self):
        cmake = CMake(self)
        cmake.install()

    def package_info(self):
        self.cpp_info.includedirs = ["include"]
        
        # 헤더 온리 라이브러리이므로 libs는 비어있다
        self.cpp_info.libs = []

        # C++ 표준 요구사항
        self.cpp_info.cxxflags = ["-std=c++20"]
```

conanfile.py를 사용하면 다음과 같이 패키지를 생성하고 배포할 수 있다.

```bash
# 라이브러리 생성
conan create . --build=missing

# 다른 프로젝트에서 사용
# conanfile.txt에 추가
[requires]
math_lib/1.0.0

[options]

[generators]
CMakeDeps
CMakeToolchain
```

이제 클라이언트 프로젝트에서 의존성을 처리하는 방법을 보자.

```cpp
// client/main.cpp
// 라이브러리 사용자 코드
#include "math_lib/math_lib.hpp"
#include <iostream>

int main() {
    using namespace math_lib;

    // 벡터 계산
    Vector3 position(10.0f, 20.0f, 30.0f);
    Vector3 velocity(1.0f, 2.0f, 3.0f);

    position = position + velocity;

    std::cout << "New position: ("
              << position.x() << ", "
              << position.y() << ", "
              << position.z() << ")\n";

    return 0;
}
```

클라이언트의 CMakeLists.txt도 설정한다.

```cmake
# client/CMakeLists.txt
cmake_minimum_required(VERSION 3.20)
project(MathLibClient)

set(CMAKE_CXX_STANDARD 20)

# 의존성 찾기
find_package(MathLib REQUIRED)

# 실행 파일 생성
add_executable(client main.cpp)

# 라이브러리 링크
target_link_libraries(client PRIVATE MathLib::math_lib)
```
  


## 17.4 테스트 자동화와 CI/CD 통합
라이브러리의 품질을 보장하려면 체계적인 테스트가 필요하다. Google Test를 사용한 테스트 작성과 CI/CD 통합을 살펴보자.

먼저 테스트 코드를 작성한다.

```cpp
// tests/test_vector.cpp
#include <gtest/gtest.h>
#include "math_lib/vector.hpp"

using namespace math_lib;

// 벡터 생성 테스트
TEST(Vector3Test, Construction) {
    Vector3 v(1.0f, 2.0f, 3.0f);
    EXPECT_FLOAT_EQ(v.x(), 1.0f);
    EXPECT_FLOAT_EQ(v.y(), 2.0f);
    EXPECT_FLOAT_EQ(v.z(), 3.0f);
}

// 벡터 덧셈 테스트
TEST(Vector3Test, Addition) {
    Vector3 v1(1.0f, 2.0f, 3.0f);
    Vector3 v2(4.0f, 5.0f, 6.0f);
    Vector3 result = v1 + v2;

    EXPECT_FLOAT_EQ(result.x(), 5.0f);
    EXPECT_FLOAT_EQ(result.y(), 7.0f);
    EXPECT_FLOAT_EQ(result.z(), 9.0f);
}

// 벡터 뺄셈 테스트
TEST(Vector3Test, Subtraction) {
    Vector3 v1(5.0f, 7.0f, 9.0f);
    Vector3 v2(1.0f, 2.0f, 3.0f);
    Vector3 result = v1 - v2;

    EXPECT_FLOAT_EQ(result.x(), 4.0f);
    EXPECT_FLOAT_EQ(result.y(), 5.0f);
    EXPECT_FLOAT_EQ(result.z(), 6.0f);
}

// 스칼라 곱셈 테스트
TEST(Vector3Test, ScalarMultiplication) {
    Vector3 v(2.0f, 3.0f, 4.0f);
    Vector3 result = v * 2.0f;

    EXPECT_FLOAT_EQ(result.x(), 4.0f);
    EXPECT_FLOAT_EQ(result.y(), 6.0f);
    EXPECT_FLOAT_EQ(result.z(), 8.0f);
}

// 내적 테스트
TEST(Vector3Test, DotProduct) {
    Vector3 v1(1.0f, 2.0f, 3.0f);
    Vector3 v2(4.0f, 5.0f, 6.0f);
    float result = v1.dot(v2);

    // (1*4) + (2*5) + (3*6) = 4 + 10 + 18 = 32
    EXPECT_FLOAT_EQ(result, 32.0f);
}

// 외적 테스트
TEST(Vector3Test, CrossProduct) {
    Vector3 v1(1.0f, 0.0f, 0.0f);
    Vector3 v2(0.0f, 1.0f, 0.0f);
    Vector3 result = v1.cross(v2);

    EXPECT_FLOAT_EQ(result.x(), 0.0f);
    EXPECT_FLOAT_EQ(result.y(), 0.0f);
    EXPECT_FLOAT_EQ(result.z(), 1.0f);
}

// 크기 테스트
TEST(Vector3Test, Magnitude) {
    Vector3 v(3.0f, 4.0f, 0.0f);
    float magnitude = v.magnitude();

    // sqrt(9 + 16) = sqrt(25) = 5
    EXPECT_FLOAT_EQ(magnitude, 5.0f);
}

// 정규화 테스트
TEST(Vector3Test, Normalization) {
    Vector3 v(3.0f, 4.0f, 0.0f);
    Vector3 normalized = v.normalized();

    EXPECT_FLOAT_EQ(normalized.x(), 0.6f);
    EXPECT_FLOAT_EQ(normalized.y(), 0.8f);
    EXPECT_FLOAT_EQ(normalized.z(), 0.0f);
}

// 영 벡터 정규화 테스트 (예외 처리)
TEST(Vector3Test, ZeroVectorNormalizationThrows) {
    Vector3 v(0.0f, 0.0f, 0.0f);
    EXPECT_THROW(v.normalized(), std::runtime_error);
}

// 범위 초과 접근 테스트
TEST(Vector3Test, OutOfRangeAccess) {
    Vector3 v(1.0f, 2.0f, 3.0f);
    EXPECT_THROW(v[5], std::out_of_range);
}

// 벡터 같음 비교
TEST(Vector3Test, Equality) {
    Vector3 v1(1.0f, 2.0f, 3.0f);
    Vector3 v2(1.0f, 2.0f, 3.0f);
    Vector3 v3(1.0f, 2.0f, 4.0f);

    EXPECT_EQ(v1, v2);
    EXPECT_NE(v1, v3);
}
```

테스트를 CMake에 추가한다.

```cmake
# tests/CMakeLists.txt
include(FetchContent)

FetchContent_Declare(
    googletest
    GIT_REPOSITORY https://github.com/google/googletest.git
    GIT_TAG release-1.12.1
)

FetchContent_MakeAvailable(googletest)

# 테스트 실행 파일
add_executable(test_math_lib
    test_vector.cpp
)

target_link_libraries(test_math_lib
    PRIVATE
    math_lib
    gtest_main
)

# 테스트 등록
gtest_discover_tests(test_math_lib)
```

이제 GitHub Actions를 사용한 CI/CD를 설정한다.

```yaml
# .github/workflows/build.yml
name: Build and Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ${{ matrix.os }}
    
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        cpp_standard: [17, 20]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up CMake
      uses: jwlawson/actions-setup-cmake@v1
      with:
        cmake-version: '3.22.x'
    
    - name: Configure CMake
      run: cmake -B ${{github.workspace}}/build
           -DCMAKE_CXX_STANDARD=${{ matrix.cpp_standard }}
           -DCMAKE_BUILD_TYPE=Release
    
    - name: Build
      run: cmake --build ${{github.workspace}}/build --config Release
    
    - name: Run tests
      working-directory: ${{github.workspace}}/build
      run: ctest --output-on-failure
    
    - name: Generate coverage
      if: matrix.os == 'ubuntu-latest' && matrix.cpp_standard == '20'
      run: |
        sudo apt-get install -y gcovr
        cmake -B build-coverage -DCMAKE_CXX_FLAGS="--coverage"
        cmake --build build-coverage
        gcovr --filter "include/.*" --filter "src/.*" build-coverage/
    
    - name: Upload coverage
      if: matrix.os == 'ubuntu-latest' && matrix.cpp_standard == '20'
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage.xml
```

마지막으로 CMakeLists.txt에 테스트 설정을 추가한다.

```cmake
# 최상위 CMakeLists.txt에 테스트 설정 추가
enable_testing()

# 테스트 서브디렉토리 추가
if(BUILD_TESTING)
    add_subdirectory(tests)
endif()

# 커버리지 설정 (선택사항)
if(ENABLE_COVERAGE)
    target_compile_options(math_lib INTERFACE --coverage)
    target_link_libraries(math_lib INTERFACE --coverage)
endif()
```
  

이 장에서 다룬 크로스 플랫폼 라이브러리 설계의 핵심을 정리하면 다음과 같다. 헤더 온리 라이브러리는 배포가 간단하고 사용자가 별도의 컴파일을 필요로 하지 않는다. Pimpl 패턴은 ABI 안정성을 보장하여 라이브러리의 지속적인 진화를 가능하게 한다. CMake와 conan을 사용한 의존성 관리는 복잡한 프로젝트를 체계적으로 구성할 수 있게 한다. Google Test와 CI/CD를 통한 자동화된 테스트는 라이브러리의 품질을 보장한다.

Modern C++의 스마트 포인터, 템플릿, 그리고 표준 라이브러리는 이러한 모든 작업을 안전하고 효율적으로 수행하는 데 필수적이다. 이전의 C++에서는 수동 메모리 관리와 복잡한 포인터 조작으로 인해 라이브러리 설계가 매우 어려웠지만, Modern C++에서는 이러한 번거로움이 크게 줄어들었다. 따라서 C++은 복잡한 크로스 플랫폼 라이브러리를 설계하고 배포할 때도 안전하고 생산성 높은 언어다.  