# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 6: 제어문 - 조건문
프로그램이 상황에 따라 다른 동작을 수행하려면 조건문이 필요하다. 조건문은 특정 조건이 참인지 거짓인지에 따라 실행할 코드를 선택한다. 이번 챕터에서는 C++의 다양한 조건문을 학습하고, 복잡한 조건을 효과적으로 표현하는 방법을 배운다.

## 6.1 if, else if, else 문
`if` 문은 가장 기본적인 조건문으로, 조건이 참일 때만 특정 코드를 실행한다.

### 기본 if 문

```cpp
#include <print>

int main()
{
    int age = 20;

    if (age >= 18)
    {
        std::println("성인입니다");
    }

    std::println("프로그램 종료");
}
```

**출력:**
```
성인입니다
프로그램 종료
```

조건식 `age >= 18`이 참이므로 중괄호 `{}` 안의 코드가 실행된다. 조건이 거짓이면 중괄호 안의 코드를 건너뛴다.

### if-else 문
조건이 거짓일 때 실행할 코드를 지정하려면 `else`를 사용한다.

```cpp
#include <print>

int main()
{
    int score = 55;

    if (score >= 60)
    {
        std::println("합격입니다");
    }
    else
    {
        std::println("불합격입니다");
    }

    std::println("점수: {}", score);
}
```

**출력:**
```
불합격입니다
점수: 55
```

### if-else if-else 문
여러 조건을 순차적으로 검사하려면 `else if`를 사용한다.

```cpp
#include <print>

int main()
{
    int score = 85;

    if (score >= 90)
    {
        std::println("학점: A");
    }
    else if (score >= 80)
    {
        std::println("학점: B");
    }
    else if (score >= 70)
    {
        std::println("학점: C");
    }
    else if (score >= 60)
    {
        std::println("학점: D");
    }
    else
    {
        std::println("학점: F");
    }
}
```

**출력:**
```
학점: B
```

조건은 위에서 아래로 순차적으로 검사되며, 처음으로 참인 조건의 코드 블록만 실행된다. `score`가 85이므로 `score >= 80`이 참이 되어 "학점: B"가 출력되고, 나머지 조건은 검사하지 않는다.

### 중괄호 생략
코드 블록이 한 줄일 때는 중괄호를 생략할 수 있지만, Modern C++에서는 가독성과 유지보수를 위해 항상 중괄호를 사용하는 것을 권장한다.

```cpp
#include <print>

int main()
{
    int number = 10;

    // 중괄호 생략 (권장하지 않음)
    if (number > 0)
        std::println("양수입니다");

    // 중괄호 사용 (권장)
    if (number > 0)
    {
        std::println("양수입니다");
    }

    // 중괄호가 없으면 실수하기 쉽다
    if (number > 0)
        std::println("이 줄은 조건문의 일부");
        std::println("이 줄은 항상 실행됨!");  // 들여쓰기와 무관하게 항상 실행

    // 중괄호를 사용하면 명확하다
    if (number > 0)
    {
        std::println("이 줄은 조건문의 일부");
        std::println("이 줄도 조건문의 일부");
    }
}
```

### 중첩된 if 문
`if` 문 안에 또 다른 `if` 문을 넣을 수 있다.

```cpp
#include <print>

int main()
{
    int age = 25;
    bool has_license = true;

    if (age >= 18)
    {
        std::println("성인입니다");
        
        if (has_license)
        {
            std::println("운전이 가능합니다");
        }
        else
        {
            std::println("면허가 필요합니다");
        }
    }
    else
    {
        std::println("미성년자입니다");
        std::println("운전이 불가능합니다");
    }
}
```

**출력:**
```
성인입니다
운전이 가능합니다
```

중첩이 깊어지면 코드가 복잡해지므로, 가능한 한 논리 연산자로 조건을 결합하거나 함수로 분리하는 것이 좋다.

### 실용적인 예제: 로그인 시스템

```cpp
#include <print>
#include <string>

int main()
{
    std::string username = "admin";
    std::string password = "1234";

    std::string input_username = "admin";
    std::string input_password = "1234";

    if (input_username == username)
    {
        if (input_password == password)
        {
            std::println("로그인 성공!");
            std::println("환영합니다, {}님", username);
        }
        else
        {
            std::println("비밀번호가 틀렸습니다");
        }
    }
    else
    {
        std::println("존재하지 않는 사용자입니다");
    }
}
```
   

</br>  
  
  
## 6.2 조건식과 불린 표현식
조건문의 조건식은 `bool` 타입의 값으로 평가되어야 한다. C++은 다양한 타입을 불린 값으로 변환할 수 있다.

### 비교 연산자를 사용한 조건

```cpp
#include <print>

int main()
{
    int a = 10;
    int b = 20;

    if (a < b)
    {
        std::println("{} < {}", a, b);
    }

    if (a != b)
    {
        std::println("{} != {}", a, b);
    }

    if (a == 10)
    {
        std::println("a는 10이다");
    }
}
```

**출력:**
```
10 < 20
10 != 20
a는 10이다
```

### 논리 연산자를 사용한 복합 조건

```cpp
#include <print>

int main()
{
    int age = 25;
    bool has_ticket = true;
    bool has_id = true;

    // AND 연산자
    if (age >= 18 && has_ticket)
    {
        std::println("입장이 가능합니다");
    }

    // OR 연산자
    if (age < 18 || !has_id)
    {
        std::println("보호자 동반이 필요합니다");
    }
    else
    {
        std::println("혼자 입장 가능합니다");
    }

    // 복잡한 조건
    if ((age >= 18 && has_ticket && has_id) || age < 12)
    {
        std::println("특별 조건 만족");
    }
}
```

**출력:**
```
입장이 가능합니다
혼자 입장 가능합니다
특별 조건 만족
```

### 암시적 불린 변환
C++은 특정 타입을 자동으로 `bool`로 변환한다.

```cpp
#include <print>
#include <string>

int main()
{
    // 정수: 0은 false, 그 외는 true
    int number = 5;
    if (number)
    {
        std::println("number는 0이 아니다");
    }

    int zero = 0;
    if (!zero)
    {
        std::println("zero는 0이다");
    }

    // 포인터: nullptr은 false, 그 외는 true
    int* ptr = nullptr;
    if (!ptr)
    {
        std::println("ptr은 nullptr이다");
    }

    int value = 10;
    ptr = &value;
    if (ptr)
    {
        std::println("ptr은 유효한 주소를 가리킨다");
    }

    // 문자열: 비어있으면 false처럼 동작 (empty() 사용 권장)
    std::string text = "";
    if (text.empty())
    {
        std::println("text는 비어있다");
    }

    text = "Hello";
    if (!text.empty())
    {
        std::println("text는 비어있지 않다");
    }
}
```

Modern C++에서는 명시적인 비교를 권장한다. 암시적 변환은 의도를 불명확하게 만들 수 있다.

```cpp
#include <print>

int main()
{
    int count = 5;

    // 암시적 변환 (권장하지 않음)
    if (count)
    {
        std::println("count가 0이 아니다");
    }

    // 명시적 비교 (권장)
    if (count != 0)
    {
        std::println("count가 0이 아니다");
    }

    // 포인터 검사
    int* ptr = nullptr;
    
    // 명시적 비교 (권장)
    if (ptr != nullptr)
    {
        std::println("ptr이 유효하다");
    }
}
```

### 조건부 초기화 (C++17)
C++17부터는 `if` 문 안에서 변수를 초기화할 수 있다.

```cpp
#include <print>
#include <map>
#include <string>

int main()
{
    std::map<std::string, int> scores = {
        {"Alice", 85},
        {"Bob", 92},
        {"Charlie", 78}
    };

    // 조건부 초기화
    if (auto it = scores.find("Bob"); it != scores.end())
    {
        std::println("Bob의 점수: {}", it->second);
    }
    else
    {
        std::println("Bob을 찾을 수 없다");
    }

    // it는 if 블록 밖에서 사용할 수 없다

    // 일반적인 방식과 비교
    auto it = scores.find("Alice");
    if (it != scores.end())
    {
        std::println("Alice의 점수: {}", it->second);
    }
    // it는 여기서도 사용 가능 (스코프가 더 넓음)
}
```

**출력:**
```
Bob의 점수: 92
Alice의 점수: 85
```

조건부 초기화는 변수의 스코프를 제한하여 코드를 더 안전하게 만든다.

### constexpr if (C++17)
컴파일 타임에 조건을 평가하는 `constexpr if`는 템플릿 프로그래밍에서 유용하다.

```cpp
#include <print>
#include <type_traits>

template<typename T>
void print_type_info(T value)
{
    if constexpr (std::is_integral_v<T>)
    {
        std::println("{}: 정수 타입", value);
    }
    else if constexpr (std::is_floating_point_v<T>)
    {
        std::println("{}: 실수 타입", value);
    }
    else
    {
        std::println("기타 타입");
    }
}

int main()
{
    print_type_info(42);      // 정수
    print_type_info(3.14);    // 실수
    print_type_info("Hello"); // 기타
}
```

**출력:**
```
42: 정수 타입
3.14: 실수 타입
기타 타입
```
  

</br>  
</br>  
  

## 6.3 switch 문과 case 레이블
`switch` 문은 하나의 변수나 표현식의 값에 따라 여러 경로 중 하나를 선택한다. 여러 `if-else if` 문을 대체하여 코드를 더 읽기 쉽게 만든다.

### 기본 switch 문

```cpp
#include <print>

int main()
{
    int day = 3;

    switch (day)
    {
        case 1:
            std::println("월요일");
            break;
        case 2:
            std::println("화요일");
            break;
        case 3:
            std::println("수요일");
            break;
        case 4:
            std::println("목요일");
            break;
        case 5:
            std::println("금요일");
            break;
        case 6:
            std::println("토요일");
            break;
        case 7:
            std::println("일요일");
            break;
        default:
            std::println("잘못된 요일");
            break;
    }
}
```

**출력:**
```
수요일
```

`break` 문은 `switch` 블록을 빠져나가게 한다. `break`가 없으면 다음 `case`로 계속 실행된다(fall-through).

### fall-through 동작

```cpp
#include <print>

int main()
{
    int month = 2;

    switch (month)
    {
        case 12:
        case 1:
        case 2:
            std::println("겨울");
            break;
        case 3:
        case 4:
        case 5:
            std::println("봄");
            break;
        case 6:
        case 7:
        case 8:
            std::println("여름");
            break;
        case 9:
        case 10:
        case 11:
            std::println("가을");
            break;
        default:
            std::println("잘못된 월");
            break;
    }
}
```

**출력:**
```
겨울
```

여러 `case`를 묶어서 같은 코드를 실행할 수 있다. 이는 의도적인 fall-through다.

### C++17의 [[fallthrough]] 속성
의도적인 fall-through를 명시적으로 표시하려면 `[[fallthrough]]` 속성을 사용한다.

```cpp
#include <print>

int main()
{
    int grade = 85;
    int category = grade / 10;

    switch (category)
    {
        case 10:
            [[fallthrough]];
        case 9:
            std::println("A 학점");
            break;
        case 8:
            std::println("B 학점");
            break;
        case 7:
            std::println("C 학점");
            break;
        case 6:
            std::println("D 학점");
            break;
        default:
            std::println("F 학점");
            break;
    }
}
```

**출력:**
```
B 학점
```

`[[fallthrough]]`는 컴파일러에게 의도적인 fall-through임을 알려 경고를 방지한다.

### switch 문에서의 변수 선언
`case` 레이블 내에서 변수를 선언할 때는 중괄호로 스코프를 만들어야 한다.

```cpp
#include <print>

int main()
{
    int choice = 1;

    switch (choice)
    {
        case 1:
        {
            int result = 100;
            std::println("선택 1: {}", result);
            break;
        }
        case 2:
        {
            int result = 200;  // case 1의 result와 다른 변수
            std::println("선택 2: {}", result);
            break;
        }
        default:
        {
            std::println("기타 선택");
            break;
        }
    }
}
```

### switch 문의 초기화 (C++17)
`if` 문처럼 `switch` 문도 초기화 구문을 가질 수 있다.

```cpp
#include <print>

int main()
{
    // switch 문에서 초기화
    switch (int value = 42; value % 3)
    {
        case 0:
            std::println("3의 배수");
            break;
        case 1:
            std::println("3으로 나눈 나머지가 1");
            break;
        case 2:
            std::println("3으로 나눈 나머지가 2");
            break;
    }
}
```

**출력:**
```
3의 배수
```

### enum class와 switch
`enum class`는 `switch` 문과 함께 사용하면 타입 안전성을 높일 수 있다.

```cpp
#include <print>

enum class Color
{
    Red,
    Green,
    Blue,
    Yellow
};

int main()
{
    Color favorite = Color::Blue;

    switch (favorite)
    {
        case Color::Red:
            std::println("빨강을 선택했다");
            break;
        case Color::Green:
            std::println("초록을 선택했다");
            break;
        case Color::Blue:
            std::println("파랑을 선택했다");
            break;
        case Color::Yellow:
            std::println("노랑을 선택했다");
            break;
    }
}
```

**출력:**
```
파랑을 선택했다
```

Modern C++에서는 모든 `enum` 값을 처리하지 않으면 컴파일러가 경고를 발생시킬 수 있다. 이는 버그를 조기에 발견하는 데 도움이 된다.

### 실용적인 예제: 계산기

```cpp
#include <print>
#include <iostream>

int main()
{
    double num1, num2;
    char operation;

    std::cout << "첫 번째 숫자: ";
    std::cin >> num1;

    std::cout << "연산자 (+, -, *, /): ";
    std::cin >> operation;

    std::cout << "두 번째 숫자: ";
    std::cin >> num2;

    double result = 0.0;
    bool valid = true;

    switch (operation)
    {
        case '+':
            result = num1 + num2;
            break;
        case '-':
            result = num1 - num2;
            break;
        case '*':
            result = num1 * num2;
            break;
        case '/':
        {
            if (num2 != 0.0)
            {
                result = num1 / num2;
            }
            else
            {
                std::println("오류: 0으로 나눌 수 없다");
                valid = false;
            }
            break;
        }
        default:
            std::println("오류: 지원하지 않는 연산자");
            valid = false;
            break;
    }

    if (valid)
    {
        std::println("결과: {} {} {} = {}", num1, operation, num2, result);
    }
}
```

### switch 문 vs if-else 선택 기준
`switch` 문을 사용하는 것이 좋은 경우:
- 하나의 변수를 여러 상수 값과 비교할 때
- `enum` 타입을 검사할 때
- 정수나 문자 값을 기반으로 분기할 때

`if-else` 문을 사용하는 것이 좋은 경우:
- 범위 비교가 필요할 때 (`x > 10 && x < 20`)
- 불린 표현식이 복잡할 때
- 여러 변수를 동시에 검사해야 할 때

```cpp
#include <print>

int main()
{
    int score = 85;

    // switch는 부적합 (범위 비교 불가)
    // if-else가 적합
    if (score >= 90)
    {
        std::println("A");
    }
    else if (score >= 80)
    {
        std::println("B");
    }
    else if (score >= 70)
    {
        std::println("C");
    }

    // switch가 적합 (특정 값 비교)
    int choice = 2;
    switch (choice)
    {
        case 1:
            std::println("옵션 1");
            break;
        case 2:
            std::println("옵션 2");
            break;
        case 3:
            std::println("옵션 3");
            break;
    }
}
```
  

</br>  
</br>  
  
  
## 6.4 삼항 연산자 (? :)
삼항 연산자는 간단한 조건식을 한 줄로 표현하는 축약형 조건문이다.

### 기본 사용법

```cpp
#include <print>

int main()
{
    int age = 20;

    // if-else 문
    std::string status1;
    if (age >= 18)
    {
        status1 = "성인";
    }
    else
    {
        status1 = "미성년자";
    }

    // 삼항 연산자
    std::string status2 = (age >= 18) ? "성인" : "미성년자";

    std::println("상태: {}", status2);
}
```

**출력:**
```
상태: 성인
```

삼항 연산자의 형식: `조건 ? 참일_때_값 : 거짓일_때_값`

### 값 선택
삼항 연산자는 두 값 중 하나를 선택할 때 유용하다.

```cpp
#include <print>

int main()
{
    int a = 10;
    int b = 20;

    // 최댓값 선택
    int max = (a > b) ? a : b;
    std::println("최댓값: {}", max);

    // 최솟값 선택
    int min = (a < b) ? a : b;
    std::println("최솟값: {}", min);

    // 절댓값 계산
    int number = -5;
    int absolute = (number >= 0) ? number : -number;
    std::println("절댓값: {}", absolute);
}
```

**출력:**
```
최댓값: 20
최솟값: 10
절댓값: 5
```

### 중첩된 삼항 연산자
삼항 연산자를 중첩할 수 있지만, 가독성이 크게 떨어진다.

```cpp
#include <print>

int main()
{
    int score = 85;

    // 중첩된 삼항 연산자 (권장하지 않음)
    std::string grade = (score >= 90) ? "A" :
                       (score >= 80) ? "B" :
                       (score >= 70) ? "C" :
                       (score >= 60) ? "D" : "F";

    std::println("학점: {}", grade);

    // if-else가 더 읽기 쉽다 (권장)
    std::string grade2;
    if (score >= 90)
    {
        grade2 = "A";
    }
    else if (score >= 80)
    {
        grade2 = "B";
    }
    else if (score >= 70)
    {
        grade2 = "C";
    }
    else if (score >= 60)
    {
        grade2 = "D";
    }
    else
    {
        grade2 = "F";
    }

    std::println("학점: {}", grade2);
}
```

Modern C++에서는 복잡한 로직은 `if-else` 문이나 함수로 분리하는 것을 권장한다.

### 삼항 연산자 활용 예제

```cpp
#include <print>
#include <string>

int main()
{
    // 짝수/홀수 판별
    int number = 7;
    std::string parity = (number % 2 == 0) ? "짝수" : "홀수";
    std::println("{}: {}", number, parity);

    // 부호 표시
    int value = -10;
    std::string sign = (value >= 0) ? "+" : "";
    std::println("{}{}", sign, value);

    // 복수형 처리
    int count = 1;
    std::println("{}개의 아이템{}", count, (count == 1) ? "" : "들");

    count = 3;
    std::println("{}개의 아이템{}", count, (count == 1) ? "" : "들");

    // 할인 적용
    double price = 10000;
    bool is_member = true;
    double final_price = price * (is_member ? 0.9 : 1.0);
    std::println("최종 가격: {:.0f}원", final_price);
}
```

**출력:**
```
7: 홀수
-10
1개의 아이템
3개의 아이템들
최종 가격: 9000원
```

### std::format과 함께 사용

```cpp
#include <print>

int main()
{
    int temperature = 28;
    
    std::println("온도: {}°C ({})", 
                 temperature,
                 (temperature >= 30) ? "더움" :
                 (temperature >= 20) ? "적당" : "추움");

    bool is_raining = false;
    std::println("날씨: {}", is_raining ? "비 옴" : "맑음");

    int battery = 15;
    std::println("배터리: {}% ({})",
                 battery,
                 (battery <= 20) ? "충전 필요" : "정상");
}
```

**출력:**
```
온도: 28°C (적당)
날씨: 맑음
배터리: 15% (충전 필요)
```

### 주의사항
삼항 연산자는 간단한 조건에만 사용해야 한다. 다음과 같은 경우는 피해야 한다.

```cpp
#include <print>

int main()
{
    int x = 10, y = 20, z = 30;

    // 나쁜 예: 너무 복잡함
    int result = (x > y) ? (x > z ? x : z) : (y > z ? y : z);

    // 좋은 예: 명확한 if-else 사용
    int max_value;
    if (x > y && x > z)
    {
        max_value = x;
    }
    else if (y > z)
    {
        max_value = y;
    }
    else
    {
        max_value = z;
    }

    std::println("최댓값: {}", max_value);
}
```
  

</br>  
</br>  
  
  
## 6.5 실습 예제: 간단한 게임 메뉴
조건문을 활용하여 게임 메뉴 시스템을 만들어보자.

```cpp
#include <print>
#include <iostream>
#include <string>
#include <limits>

void show_menu()
{
    std::println("\n=== 게임 메뉴 ===");
    std::println("1. 새 게임");
    std::println("2. 이어하기");
    std::println("3. 설정");
    std::println("4. 크레딧");
    std::println("5. 종료");
    std::print("선택: ");
}

void show_settings_menu()
{
    std::println("\n=== 설정 ===");
    std::println("1. 화면 설정");
    std::println("2. 사운드 설정");
    std::println("3. 키 설정");
    std::println("4. 뒤로");
    std::print("선택: ");
}

int get_valid_input(int min, int max)
{
    int choice;
    while (true)
    {
        std::cin >> choice;

        if (std::cin.fail())
        {
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            std::println("오류: 숫자를 입력해야 한다");
            std::print("다시 선택: ");
        }
        else if (choice < min || choice > max)
        {
            std::println("오류: {} ~ {} 사이의 숫자를 입력해야 한다", min, max);
            std::print("다시 선택: ");
        }
        else
        {
            return choice;
        }
    }
}

int main()
{
    bool game_running = true;
    bool has_save_data = false;  // 저장 데이터 유무

    while (game_running)
    {
        show_menu();
        int choice = get_valid_input(1, 5);

        switch (choice)
        {
            case 1:
            {
                std::println("\n새 게임을 시작한다");
                
                if (has_save_data)
                {
                    std::print("기존 저장 데이터가 있다. 덮어쓸까? (y/n): ");
                    char confirm;
                    std::cin >> confirm;
                    
                    if (confirm == 'y' || confirm == 'Y')
                    {
                        std::println("새 게임으로 시작한다");
                        has_save_data = true;
                    }
                    else
                    {
                        std::println("취소되었다");
                    }
                }
                else
                {
                    std::println("새 게임으로 시작한다");
                    has_save_data = true;
                }
                break;
            }
            case 2:
            {
                if (has_save_data)
                {
                    std::println("\n저장된 게임을 불러온다");
                }
                else
                {
                    std::println("\n저장된 게임이 없다");
                }
                break;
            }
            case 3:
            {
                bool in_settings = true;
                while (in_settings)
                {
                    show_settings_menu();
                    int setting_choice = get_valid_input(1, 4);

                    switch (setting_choice)
                    {
                        case 1:
                            std::println("\n=== 화면 설정 ===");
                            std::println("1. 전체화면");
                            std::println("2. 창 모드");
                            std::print("선택: ");
                            {
                                int display = get_valid_input(1, 2);
                                std::println(display == 1 ? "전체화면으로 설정" : "창 모드로 설정");
                            }
                            break;
                        case 2:
                            std::println("\n=== 사운드 설정 ===");
                            std::print("배경음악 볼륨 (0-100): ");
                            {
                                int volume = get_valid_input(0, 100);
                                std::println("볼륨을 {}%로 설정", volume);
                            }
                            break;
                        case 3:
                            std::println("\n키 설정 메뉴 (구현 예정)");
                            break;
                        case 4:
                            in_settings = false;
                            break;
                    }
                }
                break;
            }
            case 4:
            {
                std::println("\n=== 크레딧 ===");
                std::println("개발: C++ 학습자");
                std::println("버전: 1.0.0");
                std::println("제작 연도: 2025");
                break;
            }
            case 5:
            {
                std::println("\n게임을 종료한다");
                game_running = false;
                break;
            }
        }
    }

    std::println("프로그램을 종료한다");
}
```
  

</br>  
</br>  
  

## 6.6 실습 문제

### 문제 1: 성적 판정 프로그램
세 과목의 점수를 입력받아 평균을 계산하고, 학점을 출력하는 프로그램을 작성하라.
- 90점 이상: A
- 80점 이상: B
- 70점 이상: C
- 60점 이상: D
- 60점 미만: F

```cpp
#include <print>
#include <iostream>

int main()
{
    int korean, english, math;

    std::cout << "국어 점수: ";
    std::cin >> korean;
    std::cout << "영어 점수: ";
    std::cin >> english;
    std::cout << "수학 점수: ";
    std::cin >> math;

    // 여기에 코드를 작성하라
    
    return 0;
}
```

### 문제 2: 계절 판정
월(1-12)을 입력받아 해당하는 계절을 출력하라.
- 3, 4, 5월: 봄
- 6, 7, 8월: 여름
- 9, 10, 11월: 가을
- 12, 1, 2월: 겨울

`switch` 문을 사용하라.

```cpp
#include <print>
#include <iostream>

int main()
{
    int month;
    std::cout << "월 (1-12): ";
    std::cin >> month;

    // 여기에 코드를 작성하라
    
    return 0;
}
```

### 문제 3: 윤년 판정기
연도를 입력받아 윤년인지 판정하라.
- 4로 나누어떨어지면 윤년
- 단, 100으로 나누어떨어지면 평년
- 단, 400으로 나누어떨어지면 윤년

```cpp
#include <print>
#include <iostream>

int main()
{
    int year;
    std::cout << "연도: ";
    std::cin >> year;

    // 여기에 윤년 판정 로직을 작성하라
    
    return 0;
}
```

**힌트**: 중첩된 `if` 문이나 논리 연산자를 사용하라.

### 문제 4: 자판기 프로그램
음료 자판기를 시뮬레이션하는 프로그램을 작성하라.
- 사용자가 투입한 금액과 선택한 음료에 따라 거스름돈을 계산
- 잔액이 부족하면 경고 메시지 출력

```cpp
#include <print>
#include <iostream>

int main()
{
    int balance;
    std::cout << "투입 금액: ";
    std::cin >> balance;

    std::println("\n=== 음료 선택 ===");
    std::println("1. 콜라 (1000원)");
    std::println("2. 사이다 (1000원)");
    std::println("3. 커피 (1500원)");
    std::println("4. 주스 (1200원)");
    std::print("선택: ");

    int choice;
    std::cin >> choice;

    // 여기에 코드를 작성하라
    
    return 0;
}
```
   

</br>  
</br>  
  

## 6.7 심화 내용

### 조건 연산자 체이닝
여러 조건을 연결하여 복잡한 논리를 표현할 수 있다.

```cpp
#include <print>

int main()
{
    int hour = 14;
    bool is_weekend = false;
    bool has_meeting = true;

    // 복잡한 조건 체인
    if (hour >= 9 && hour < 18)
    {
        if (!is_weekend)
        {
            if (has_meeting)
            {
                std::println("회의 중");
            }
            else
            {
                std::println("근무 중");
            }
        }
        else
        {
            std::println("주말");
        }
    }
    else
    {
        std::println("근무 시간 외");
    }

    // 논리 연산자로 개선
    if (hour >= 9 && hour < 18 && !is_weekend && has_meeting)
    {
        std::println("회의 중");
    }
    else if (hour >= 9 && hour < 18 && !is_weekend)
    {
        std::println("근무 중");
    }
    else if (is_weekend)
    {
        std::println("주말");
    }
    else
    {
        std::println("근무 시간 외");
    }
}
```

### Early Return 패턴
함수 내에서 조건을 만족하지 않으면 즉시 반환하는 패턴이다. 중첩을 줄여 가독성을 높인다.

```cpp
#include <print>
#include <string>

bool is_valid_password(const std::string& password)
{
    // 길이 검사
    if (password.length() < 8)
    {
        std::println("오류: 비밀번호는 8자 이상이어야 한다");
        return false;
    }

    // 숫자 포함 검사
    bool has_digit = false;
    for (char c : password)
    {
        if (c >= '0' && c <= '9')
        {
            has_digit = true;
            break;
        }
    }

    if (!has_digit)
    {
        std::println("오류: 비밀번호는 숫자를 포함해야 한다");
        return false;
    }

    // 모든 검사 통과
    return true;
}

int main()
{
    std::string pwd1 = "abc";
    std::string pwd2 = "abcdefgh";
    std::string pwd3 = "abcd1234";

    if (is_valid_password(pwd1))
    {
        std::println("유효한 비밀번호");
    }

    if (is_valid_password(pwd2))
    {
        std::println("유효한 비밀번호");
    }

    if (is_valid_password(pwd3))
    {
        std::println("유효한 비밀번호");
    }
}
```

**출력:**
```
오류: 비밀번호는 8자 이상이어야 한다
오류: 비밀번호는 숫자를 포함해야 한다
유효한 비밀번호
```

### std::optional을 사용한 조건부 값 (C++17)
값이 존재하지 않을 수 있는 경우 `std::optional`을 사용한다.

```cpp
#include <print>
#include <optional>
#include <string>
#include <map>

std::optional<int> find_score(const std::map<std::string, int>& scores, 
                               const std::string& name)
{
    auto it = scores.find(name);
    if (it != scores.end())
    {
        return it->second;
    }
    return std::nullopt;  // 값이 없음
}

int main()
{
    std::map<std::string, int> student_scores = {
        {"Alice", 85},
        {"Bob", 92},
        {"Charlie", 78}
    };

    // optional 값 확인
    if (auto score = find_score(student_scores, "Bob"))
    {
        std::println("Bob의 점수: {}", *score);
    }
    else
    {
        std::println("Bob을 찾을 수 없다");
    }

    if (auto score = find_score(student_scores, "David"))
    {
        std::println("David의 점수: {}", *score);
    }
    else
    {
        std::println("David를 찾을 수 없다");
    }

    // value_or를 사용한 기본값 제공
    int alice_score = find_score(student_scores, "Alice").value_or(0);
    int unknown_score = find_score(student_scores, "Unknown").value_or(0);
    
    std::println("Alice: {}, Unknown: {}", alice_score, unknown_score);
}
```

**출력:**
```
Bob의 점수: 92
David를 찾을 수 없다
Alice: 85, Unknown: 0
```

### 구조적 바인딩과 조건문 (C++17)

```cpp
#include <print>
#include <tuple>
#include <string>

std::tuple<bool, int, std::string> validate_input(int value)
{
    if (value < 0)
    {
        return {false, value, "음수는 허용되지 않는다"};
    }
    else if (value > 100)
    {
        return {false, value, "값이 너무 크다"};
    }
    else
    {
        return {true, value, "정상"};
    }
}

int main()
{
    int input = 150;

    // 구조적 바인딩
    auto [is_valid, val, message] = validate_input(input);

    if (is_valid)
    {
        std::println("유효한 값: {}", val);
    }
    else
    {
        std::println("오류: {} (입력값: {})", message, val);
    }
}
```

**출력:**
```
오류: 값이 너무 크다 (입력값: 150)
```

### 컴파일 타임 조건 분기
`if constexpr`를 사용하면 컴파일 타임에 조건을 평가할 수 있다.

```cpp
#include <print>
#include <type_traits>

template<typename T>
void process_value(T value)
{
    if constexpr (std::is_integral_v<T>)
    {
        std::println("정수 처리: {}", value);
    }
    else if constexpr (std::is_floating_point_v<T>)
    {
        std::println("실수 처리: {:.2f}", value);
    }
    else if constexpr (std::is_same_v<T, std::string>)
    {
        std::println("문자열 처리: {}", value);
    }
    else
    {
        std::println("기타 타입 처리");
    }
}

int main()
{
    process_value(42);
    process_value(3.14);
    process_value(std::string("Hello"));
}
```

**출력:**
```
정수 처리: 42
실수 처리: 3.14
문자열 처리: Hello
```
  

</br>  
</br>  
  
  
## 정리
이번 챕터에서는 C++의 조건문을 종합적으로 학습했다. `if-else` 문으로 조건에 따라 코드를 분기하고, `switch` 문으로 여러 경우를 명확하게 처리하며, 삼항 연산자로 간단한 조건을 축약하는 방법을 배웠다.

Modern C++에서 조건문 작성의 핵심은 명확성과 안전성이다. 중괄호를 항상 사용하고, 복잡한 조건은 함수로 분리하며, `enum class`와 `switch`를 함께 사용하여 타입 안전성을 높이는 것이 좋다. C++17의 조건부 초기화와 `std::optional`, C++23의 `std::expected` 같은 Modern 기능을 활용하면 더욱 안전하고 표현력 있는 코드를 작성할 수 있다.

다음 챕터에서는 반복문을 학습하여 같은 작업을 여러 번 수행하는 방법을 배운다. 조건문과 반복문을 결합하면 복잡한 로직을 구현할 수 있게 된다.

