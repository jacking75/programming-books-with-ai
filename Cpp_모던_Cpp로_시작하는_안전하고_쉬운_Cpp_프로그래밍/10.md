# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 10: 람다 표현식과 함수 객체

## 10.1 람다 표현식이란?
함수를 작성하다 보면 간단한 작업을 위해 별도의 함수를 정의해야 하는 경우가 많다. 예를 들어 컨테이너의 원소를 정렬할 때 정렬 기준을 제공하거나, 버튼 클릭 시 실행할 동작을 전달해야 할 때가 그렇다. 이런 상황에서 매번 별도의 함수를 정의하면 코드가 분산되고 가독성이 떨어진다.

람다 표현식(lambda expression)은 이름 없는 함수를 즉석에서 정의할 수 있는 Modern C++의 핵심 기능이다. C++11에서 처음 도입된 이후 C++14, C++17, C++20, C++23을 거치며 지속적으로 개선되어 왔다. 람다 표현식을 사용하면 코드를 사용하는 위치에서 바로 함수를 정의할 수 있어 코드의 응집도가 높아지고 가독성이 향상된다.

### 10.1.1 람다 표현식의 기본 문법
람다 표현식의 가장 기본적인 형태는 다음과 같다.

```cpp
[캡처리스트](매개변수) -> 반환타입 { 함수본문 }
```

각 부분의 의미를 살펴보자.

- **캡처리스트 `[]`**: 람다 표현식이 외부 변수를 어떻게 사용할지 지정한다.
- **매개변수 `()`**: 일반 함수처럼 매개변수를 받을 수 있다.
- **반환타입 `-> 타입`**: 반환 타입을 명시한다. 생략 가능하며, 생략 시 컴파일러가 자동으로 추론한다.
- **함수본문 `{}`**: 실행할 코드를 작성한다.

가장 간단한 람다 표현식부터 시작해보자.

```cpp
#include <iostream>

int main() {
    // 가장 단순한 람다 표현식
    auto hello = []() {
        std::cout << "안녕하세요!\n";
    };
    
    hello();  // 출력: 안녕하세요!
    
    // 매개변수가 있는 람다
    auto greet = [](const std::string& name) {
        std::cout << "안녕하세요, " << name << "님!\n";
    };
    
    greet("철수");  // 출력: 안녕하세요, 철수님!
    
    // 반환값이 있는 람다
    auto add = [](int a, int b) {
        return a + b;
    };
    
    std::cout << "3 + 4 = " << add(3, 4) << "\n";  // 출력: 3 + 4 = 7
    
    // 반환 타입을 명시적으로 지정
    auto divide = [](double a, double b) -> double {
        if (b == 0.0) return 0.0;
        return a / b;
    };
    
    std::cout << "10 / 3 = " << divide(10.0, 3.0) << "\n";
    
    return 0;
}
```

위 코드에서 `auto` 키워드를 사용해 람다 표현식을 변수에 저장했다. 람다 표현식은 컴파일러가 자동으로 생성하는 고유한 타입을 가지므로 `auto`를 사용하는 것이 일반적이다.

### 10.1.2 람다 표현식의 실용적 활용
람다 표현식은 STL 알고리즘과 함께 사용할 때 진가를 발휘한다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3, 7};
    
    // 오름차순 정렬 (기본)
    std::sort(numbers.begin(), numbers.end());
    
    std::cout << "오름차순: ";
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 내림차순 정렬 (람다 사용)
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a > b;
    });
    
    std::cout << "내림차순: ";
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 조건을 만족하는 원소 개수 세기
    int count = std::count_if(numbers.begin(), numbers.end(), [](int n) {
        return n > 5;
    });
    
    std::cout << "5보다 큰 수의 개수: " << count << "\n";
    
    // 복잡한 정렬 기준
    struct Person {
        std::string name;
        int age;
    };
    
    std::vector<Person> people = {
        {"김철수", 25},
        {"이영희", 30},
        {"박민수", 25},
        {"정수진", 28}
    };
    
    // 나이순 정렬, 같으면 이름순
    std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
        if (a.age != b.age) {
            return a.age < b.age;
        }
        return a.name < b.name;
    });
    
    std::cout << "\n정렬된 사람 목록:\n";
    for (const auto& p : people) {
        std::cout << p.name << " (" << p.age << "세)\n";
    }
    
    return 0;
}
```
  
  
</br>   
</br>   
  

## 10.2 캡처 리스트 이해하기
람다 표현식의 가장 강력한 기능 중 하나는 외부 변수를 캡처할 수 있다는 점이다. 캡처 리스트 `[]`를 통해 람다 표현식이 정의된 범위의 변수들을 어떻게 사용할지 결정할 수 있다.

### 10.2.1 빈 캡처 리스트 `[]`
빈 캡처 리스트는 외부 변수를 전혀 사용하지 않겠다는 의미다.

```cpp
#include <iostream>

int main() {
    int x = 10;
    
    auto lambda1 = []() {
        // x를 사용할 수 없음
        std::cout << "외부 변수를 사용하지 않습니다.\n";
    };
    
    lambda1();
    
    // 아래 코드는 컴파일 에러
    // auto lambda2 = []() {
    //     std::cout << x << "\n";  // 오류: x를 캡처하지 않았음
    // };
    
    return 0;
}
```

### 10.2.2 값 캡처 `[=]`
`[=]`는 외부 변수를 값으로 복사해서 캡처한다. 람다 내부에서 변수를 수정해도 원본에는 영향을 주지 않는다.

```cpp
#include <iostream>

int main() {
    int x = 10;
    int y = 20;
    
    auto lambda = [=]() {
        std::cout << "x = " << x << ", y = " << y << "\n";
        // x = 100;  // 오류: 기본적으로 const 복사본이므로 수정 불가
    };
    
    lambda();  // 출력: x = 10, y = 20
    
    x = 100;
    y = 200;
    
    lambda();  // 출력: x = 10, y = 20 (캡처 시점의 값 유지)
    
    // mutable 키워드를 사용하면 복사본 수정 가능
    auto mutable_lambda = [=]() mutable {
        x = 999;
        std::cout << "람다 내부 x = " << x << "\n";
    };
    
    mutable_lambda();  // 출력: 람다 내부 x = 999
    std::cout << "실제 x = " << x << "\n";  // 출력: 실제 x = 100 (원본은 그대로)
    
    return 0;
}
```

### 10.2.3 참조 캡처 `[&]`
`[&]`는 외부 변수를 참조로 캡처한다. 람다 내부에서 변수를 수정하면 원본도 변경된다.

```cpp
#include <iostream>

int main() {
    int x = 10;
    int y = 20;
    
    auto lambda = [&]() {
        x = 100;
        y = 200;
        std::cout << "람다 내부: x = " << x << ", y = " << y << "\n";
    };
    
    lambda();  // 출력: 람다 내부: x = 100, y = 200
    std::cout << "외부: x = " << x << ", y = " << y << "\n";  // 출력: 외부: x = 100, y = 200
    
    return 0;
}
```

### 10.2.4 선택적 캡처
특정 변수만 선택해서 캡처할 수도 있다.

```cpp
#include <iostream>

int main() {
    int a = 1, b = 2, c = 3, d = 4;
    
    // a는 값으로, b는 참조로 캡처
    auto lambda1 = [a, &b]() {
        std::cout << "a = " << a << ", b = " << b << "\n";
        // a = 10;  // 오류: 값 캡처는 기본적으로 const
        b = 20;     // 가능: 참조 캡처
    };
    
    lambda1();
    std::cout << "b = " << b << "\n";  // 출력: b = 20
    
    // c를 제외한 모든 변수를 참조로 캡처, c만 값으로 캡처
    auto lambda2 = [&, c]() {
        std::cout << "a = " << a << ", b = " << b << ", c = " << c << ", d = " << d << "\n";
        // c = 30;  // 오류: c는 값 캡처
        d = 40;     // 가능: d는 참조 캡처
    };
    
    lambda2();
    std::cout << "d = " << d << "\n";  // 출력: d = 40
    
    // a를 제외한 모든 변수를 값으로 캡처, a만 참조로 캡처
    auto lambda3 = [=, &a]() mutable {
        a = 100;
        b = 200;  // 복사본 수정
        c = 300;  // 복사본 수정
    };
    
    lambda3();
    std::cout << "a = " << a << "\n";  // 출력: a = 100 (참조 캡처)
    std::cout << "b = " << b << "\n";  // 출력: b = 20 (값 캡처, 원본 불변)
    
    return 0;
}
```

### 10.2.5 this 포인터 캡처
클래스의 멤버 함수 내에서 람다를 사용할 때는 `this` 포인터를 캡처할 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class DataProcessor {
private:
    int threshold;
    std::vector<int> data;

public:
    DataProcessor(int t) : threshold(t) {
        data = {1, 5, 3, 8, 2, 9, 4, 7, 6};
    }
    
    void processWithValueCapture() {
        // [=]로 this를 값으로 캡처 (C++20 이전 방식)
        auto count = std::count_if(data.begin(), data.end(), [=](int value) {
            return value > threshold;
        });
        
        std::cout << threshold << "보다 큰 값의 개수: " << count << "\n";
    }
    
    void processWithThisCapture() {
        // [this]로 명시적으로 this 포인터 캡처
        auto count = std::count_if(data.begin(), data.end(), [this](int value) {
            return value > this->threshold;
        });
        
        std::cout << threshold << "보다 큰 값의 개수: " << count << "\n";
    }
    
    void processWithCopyCapture() {
        // [*this]로 객체를 복사해서 캡처 (C++17부터)
        auto count = std::count_if(data.begin(), data.end(), [*this](int value) {
            return value > threshold;
        });
        
        std::cout << threshold << "보다 큰 값의 개수: " << count << "\n";
    }
    
    void modifyData() {
        // 멤버 변수 직접 수정
        std::for_each(data.begin(), data.end(), [this](int& value) {
            if (value < threshold) {
                value = threshold;
            }
        });
        
        std::cout << "수정된 데이터: ";
        for (int v : data) {
            std::cout << v << " ";
        }
        std::cout << "\n";
    }
};

int main() {
    DataProcessor processor(5);
    
    processor.processWithValueCapture();
    processor.processWithThisCapture();
    processor.processWithCopyCapture();
    processor.modifyData();
    
    return 0;
}
```

### 10.2.6 캡처 초기화 (C++14)
C++14부터는 캡처 리스트에서 새로운 변수를 초기화할 수 있다. 이를 일반화된 람다 캡처(generalized lambda capture)라고 한다.

```cpp
#include <iostream>
#include <memory>
#include <string>

int main() {
    int x = 10;
    
    // 새로운 변수를 캡처 리스트에서 초기화
    auto lambda1 = [y = x + 5]() {
        std::cout << "y = " << y << "\n";
    };
    
    lambda1();  // 출력: y = 15
    
    // 이동 캡처 (unique_ptr 같은 이동 전용 타입에 유용)
    auto ptr = std::make_unique<std::string>("Hello");
    
    auto lambda2 = [p = std::move(ptr)]() {
        std::cout << "문자열: " << *p << "\n";
    };
    
    lambda2();  // 출력: 문자열: Hello
    // std::cout << *ptr << "\n";  // 오류: ptr은 이미 이동됨
    
    // 복잡한 초기화
    auto lambda3 = [
        value = x * 2,
        name = std::string("계산결과"),
        vec = std::vector<int>{1, 2, 3}
    ]() {
        std::cout << name << ": " << value << "\n";
        std::cout << "벡터 크기: " << vec.size() << "\n";
    };
    
    lambda3();
    
    return 0;
}
```
   

</br>   
</br>   
  

## 10.3 std::function과 함수 포인터
람다 표현식을 변수에 저장하거나 함수의 매개변수로 전달할 때는 여러 가지 방법이 있다.

### 10.3.1 auto를 사용한 저장
가장 간단한 방법은 `auto` 키워드를 사용하는 것이다.

```cpp
#include <iostream>

int main() {
    auto add = [](int a, int b) {
        return a + b;
    };
    
    std::cout << add(3, 4) << "\n";  // 출력: 7
    
    return 0;
}
```

하지만 `auto`는 타입이 명확하지 않고, 함수 매개변수로는 사용할 수 없다는 단점이 있다.

### 10.3.2 std::function 사용하기
`std::function`은 모든 호출 가능한 객체(람다, 함수 포인터, 함수 객체 등)를 담을 수 있는 범용 함수 래퍼다.

```cpp
#include <iostream>
#include <functional>
#include <vector>

// std::function을 매개변수로 받는 함수
void executeOperation(std::function<int(int, int)> op, int a, int b) {
    std::cout << "결과: " << op(a, b) << "\n";
}

int main() {
    // 람다를 std::function에 저장
    std::function<int(int, int)> add = [](int a, int b) {
        return a + b;
    };
    
    std::function<int(int, int)> multiply = [](int a, int b) {
        return a * b;
    };
    
    executeOperation(add, 10, 5);       // 출력: 결과: 15
    executeOperation(multiply, 10, 5);  // 출력: 결과: 50
    
    // 람다를 직접 전달
    executeOperation([](int a, int b) { return a - b; }, 10, 5);  // 출력: 결과: 5
    
    // 함수들을 컨테이너에 저장
    std::vector<std::function<void()>> tasks;
    
    tasks.push_back([]() { std::cout << "작업 1 실행\n"; });
    tasks.push_back([]() { std::cout << "작업 2 실행\n"; });
    tasks.push_back([]() { std::cout << "작업 3 실행\n"; });
    
    std::cout << "\n모든 작업 실행:\n";
    for (const auto& task : tasks) {
        task();
    }
    
    return 0;
}
```

`std::function`의 템플릿 매개변수는 `반환타입(매개변수타입들)` 형식으로 지정한다. 예를 들어 `std::function<int(int, int)>`는 두 개의 `int`를 받아 `int`를 반환하는 함수를 저장할 수 있다.

### 10.3.3 함수 포인터
캡처를 사용하지 않는 람다는 함수 포인터로 변환될 수 있다.

```cpp
#include <iostream>

// 함수 포인터를 매개변수로 받는 함수
void callFunction(int (*func)(int, int), int a, int b) {
    std::cout << "결과: " << func(a, b) << "\n";
}

int main() {
    // 캡처가 없는 람다는 함수 포인터로 변환 가능
    int (*add_ptr)(int, int) = [](int a, int b) {
        return a + b;
    };
    
    std::cout << add_ptr(3, 4) << "\n";  // 출력: 7
    
    callFunction([](int a, int b) { return a * b; }, 3, 4);  // 출력: 결과: 12
    
    // 캡처가 있는 람다는 함수 포인터로 변환 불가
    int x = 10;
    // int (*bad_ptr)(int) = [x](int a) { return a + x; };  // 오류!
    
    // 하지만 std::function은 가능
    std::function<int(int)> good_func = [x](int a) { return a + x; };
    std::cout << good_func(5) << "\n";  // 출력: 15
    
    return 0;
}
```

### 10.3.4 성능 고려사항
`auto`와 `std::function`의 성능 차이를 이해하는 것이 중요하다.

```cpp
#include <iostream>
#include <functional>
#include <chrono>

int main() {
    const int iterations = 100'000'000;
    
    // auto 사용 (인라인 최적화 가능)
    auto lambda_auto = [](int x) { return x * 2; };
    
    auto start1 = std::chrono::high_resolution_clock::now();
    long long sum1 = 0;
    for (int i = 0; i < iterations; ++i) {
        sum1 += lambda_auto(i);
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // std::function 사용 (간접 호출, 오버헤드 있음)
    std::function<int(int)> lambda_func = [](int x) { return x * 2; };
    
    auto start2 = std::chrono::high_resolution_clock::now();
    long long sum2 = 0;
    for (int i = 0; i < iterations; ++i) {
        sum2 += lambda_func(i);
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    
    std::cout << "auto 사용 시간: " << duration1.count() << "ms\n";
    std::cout << "std::function 사용 시간: " << duration2.count() << "ms\n";
    
    return 0;
}
```

일반적으로 `auto`가 더 빠르지만, `std::function`은 타입 소거(type erasure)를 통해 다양한 호출 가능 객체를 동일한 타입으로 다룰 수 있다는 장점이 있다. 성능이 중요한 경우 `auto`나 템플릿을 사용하고, 유연성이 필요한 경우 `std::function`을 사용하면 된다.
  

</br>   
</br>   
  

## 10.4 콜백 함수와 이벤트 처리
람다 표현식의 가장 실용적인 활용 사례 중 하나는 콜백 함수와 이벤트 처리다.

### 10.4.1 콜백 함수의 기본 개념
콜백 함수는 다른 함수에 인자로 전달되어 특정 시점에 호출되는 함수를 말한다. 람다 표현식을 사용하면 콜백 함수를 간결하게 작성할 수 있다.

```cpp
#include <iostream>
#include <functional>
#include <vector>
#include <string>

class Button {
private:
    std::string label;
    std::function<void()> onClick;

public:
    Button(const std::string& lbl) : label(lbl) {}
    
    void setOnClick(std::function<void()> callback) {
        onClick = callback;
    }
    
    void click() {
        std::cout << "[" << label << "] 버튼 클릭!\n";
        if (onClick) {
            onClick();
        }
    }
};

int main() {
    Button saveButton("저장");
    Button loadButton("불러오기");
    Button exitButton("종료");
    
    // 각 버튼에 람다로 콜백 등록
    saveButton.setOnClick([]() {
        std::cout << "  → 파일을 저장합니다.\n";
    });
    
    loadButton.setOnClick([]() {
        std::cout << "  → 파일을 불러옵니다.\n";
    });
    
    int clickCount = 0;
    exitButton.setOnClick([&clickCount]() {
        clickCount++;
        std::cout << "  → 프로그램을 종료합니다. (클릭 " << clickCount << "회)\n";
    });
    
    // 버튼 클릭 시뮬레이션
    saveButton.click();
    loadButton.click();
    exitButton.click();
    exitButton.click();
    
    return 0;
}
```

### 10.4.2 다중 이벤트 핸들러
실제 애플리케이션에서는 하나의 이벤트에 여러 핸들러를 등록해야 할 때가 많다.

```cpp
#include <iostream>
#include <functional>
#include <vector>
#include <string>

class EventEmitter {
private:
    std::vector<std::function<void(const std::string&)>> listeners;

public:
    void addEventListener(std::function<void(const std::string&)> listener) {
        listeners.push_back(listener);
    }
    
    void emit(const std::string& message) {
        for (const auto& listener : listeners) {
            listener(message);
        }
    }
};

int main() {
    EventEmitter emitter;
    
    // 여러 리스너 등록
    emitter.addEventListener([](const std::string& msg) {
        std::cout << "[로그] " << msg << "\n";
    });
    
    emitter.addEventListener([](const std::string& msg) {
        std::cout << "[알림] 새 메시지: " << msg << "\n";
    });
    
    int messageCount = 0;
    emitter.addEventListener([&messageCount](const std::string& msg) {
        messageCount++;
        std::cout << "[카운터] 총 " << messageCount << "개의 메시지 수신\n";
    });
    
    // 이벤트 발생
    std::cout << "=== 첫 번째 이벤트 ===\n";
    emitter.emit("안녕하세요");
    
    std::cout << "\n=== 두 번째 이벤트 ===\n";
    emitter.emit("반갑습니다");
    
    return 0;
}
```

### 10.4.3 조건부 콜백
특정 조건에서만 실행되는 콜백을 구현할 수 있다.

```cpp
#include <iostream>
#include <functional>
#include <vector>

template<typename T>
class Observable {
private:
    T value;
    std::vector<std::function<void(const T&, const T&)>> observers;

public:
    Observable(const T& initial) : value(initial) {}
    
    void onChange(std::function<void(const T&, const T&)> callback) {
        observers.push_back(callback);
    }
    
    void setValue(const T& newValue) {
        if (newValue != value) {
            T oldValue = value;
            value = newValue;
            
            // 모든 옵저버에게 알림
            for (const auto& observer : observers) {
                observer(oldValue, newValue);
            }
        }
    }
    
    const T& getValue() const {
        return value;
    }
};

int main() {
    Observable<int> score(0);
    
    // 점수가 변경될 때마다 로그 출력
    score.onChange([](int oldVal, int newVal) {
        std::cout << "점수 변경: " << oldVal << " → " << newVal << "\n";
    });
    
    // 점수가 100 이상이 되면 축하 메시지
    score.onChange([](int oldVal, int newVal) {
        if (newVal >= 100 && oldVal < 100) {
            std::cout << "🎉 축하합니다! 100점 달성!\n";
        }
    });
    
    // 점수가 감소하면 경고
    score.onChange([](int oldVal, int newVal) {
        if (newVal < oldVal) {
            std::cout << "⚠️  점수가 감소했습니다.\n";
        }
    });
    
    // 점수 변경 시뮬레이션
    score.setValue(50);
    score.setValue(80);
    score.setValue(100);
    score.setValue(120);
    score.setValue(90);
    
    return 0;
}
```
  

</br>   
</br>   
  

## 10.5 함수 객체 (Functor)
람다 표현식이 등장하기 전에는 함수 객체를 사용했다. 함수 객체는 `operator()`를 오버로딩한 클래스의 객체다. 람다 표현식은 사실 컴파일러가 자동으로 생성하는 함수 객체의 문법적 설탕(syntactic sugar)이다.

### 10.5.1 함수 객체의 기본

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 함수 객체 클래스
class Multiplier {
private:
    int factor;

public:
    Multiplier(int f) : factor(f) {}
    
    int operator()(int x) const {
        return x * factor;
    }
};

// 비교 함수 객체
class DescendingOrder {
public:
    bool operator()(int a, int b) const {
        return a > b;
    }
};

int main() {
    // 함수 객체 사용
    Multiplier multiplyBy3(3);
    std::cout << multiplyBy3(10) << "\n";  // 출력: 30
    std::cout << multiplyBy3(5) << "\n";   // 출력: 15
    
    // STL 알고리즘과 함께 사용
    std::vector<int> numbers = {5, 2, 8, 1, 9};
    std::sort(numbers.begin(), numbers.end(), DescendingOrder());
    
    std::cout << "내림차순: ";
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 람다로 동일한 작업 수행 (훨씬 간결)
    int factor = 3;
    auto lambda_multiply = [factor](int x) { return x * factor; };
    std::cout << lambda_multiply(10) << "\n";  // 출력: 30
    
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a > b;
    });
    
    return 0;
}
```

### 10.5.2 상태를 가진 함수 객체
함수 객체의 장점은 내부 상태를 유지할 수 있다는 점이다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Counter {
private:
    int count;

public:
    Counter() : count(0) {}
    
    void operator()(int x) {
        count++;
        std::cout << count << "번째 호출: " << x << "\n";
    }
    
    int getCount() const {
        return count;
    }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    Counter counter;
    counter = std::for_each(numbers.begin(), numbers.end(), counter);
    
    std::cout << "총 호출 횟수: " << counter.getCount() << "\n";
    
    // 람다로 동일한 작업 (mutable 사용)
    int lambda_count = 0;
    std::for_each(numbers.begin(), numbers.end(), [&lambda_count](int x) {
        lambda_count++;
        std::cout << lambda_count << "번째 호출: " << x << "\n";
    });
    
    std::cout << "총 호출 횟수: " << lambda_count << "\n";
    
    return 0;
}
```

### 10.5.3 람다 vs 함수 객체
람다 표현식과 함수 객체는 언제 사용해야 할까?

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

// 복잡한 로직을 가진 함수 객체 - 재사용성과 가독성이 좋음
class RangeValidator {
private:
    int min;
    int max;
    int invalidCount;

public:
    RangeValidator(int minVal, int maxVal) 
        : min(minVal), max(maxVal), invalidCount(0) {}
    
    bool operator()(int value) {
        if (value < min || value > max) {
            invalidCount++;
            std::cout << "범위 벗어남: " << value << "\n";
            return false;
        }
        return true;
    }
    
    int getInvalidCount() const {
        return invalidCount;
    }
};

int main() {
    std::vector<int> data = {5, 15, 25, 35, 45, 55};
    
    // 함수 객체 사용 - 복잡한 상태 관리에 적합
    RangeValidator validator(10, 40);
    std::vector<int> validData;
    std::copy_if(data.begin(), data.end(), 
                 std::back_inserter(validData), 
                 std::ref(validator));
    
    std::cout << "유효하지 않은 값의 개수: " << validator.getInvalidCount() << "\n";
    
    // 람다 사용 - 간단한 일회성 작업에 적합
    std::vector<int> evenNumbers;
    std::copy_if(data.begin(), data.end(),
                 std::back_inserter(evenNumbers),
                 [](int x) { return x % 2 == 0; });
    
    std::cout << "짝수 개수: " << evenNumbers.size() << "\n";
    
    return 0;
}
```

**사용 가이드라인:**

- **람다 사용이 적합한 경우**: 간단한 로직, 한 곳에서만 사용, 짧은 코드
- **함수 객체 사용이 적합한 경우**: 복잡한 로직, 여러 곳에서 재사용, 많은 상태 관리, 명확한 이름 필요
  

</br>   
</br>   
  

## 10.6 실습 문제

### 실습 10-1: 데이터 필터링
다음 요구사항을 만족하는 프로그램을 작성하라.

1. 정수 벡터를 입력받는다.
2. 짝수만 필터링하는 함수를 람다로 작성한다.
3. 홀수만 필터링하는 함수를 람다로 작성한다.
4. 특정 값보다 큰 수만 필터링하는 함수를 람다로 작성한다.
5. 각 필터링 결과를 출력한다.

**예상 출력:**

```
원본 데이터: 1 2 3 4 5 6 7 8 9 10
짝수: 2 4 6 8 10
홀수: 1 3 5 7 9
5보다 큰 수: 6 7 8 9 10
```

### 실습 10-2: 간단한 계산기
람다 표현식과 `std::function`을 사용하여 간단한 계산기를 만들어라.

1. 덧셈, 뺄셈, 곱셈, 나눗셈 연산을 람다로 정의한다.
2. 연산자 문자(+, -, *, /)를 입력받아 해당하는 람다를 실행한다.
3. 나눗셈의 경우 0으로 나누는 경우를 처리한다.

**예상 실행:**

```
첫 번째 숫자: 10
연산자 (+, -, *, /): *
두 번째 숫자: 5
결과: 50
```

### 실습 10-3: 이벤트 시스템
다음 기능을 가진 간단한 이벤트 시스템을 구현하라.

1. 이벤트를 등록할 수 있다.
2. 여러 개의 리스너를 추가할 수 있다.
3. 이벤트를 발생시키면 모든 리스너가 호출된다.
4. 특정 조건을 만족할 때만 실행되는 조건부 리스너를 추가할 수 있다.

```cpp
// 사용 예시
EventSystem events;
events.on("message", [](const std::string& data) {
    std::cout << "메시지 수신: " << data << "\n";
});
events.emit("message", "안녕하세요");
```
   

</br>   
</br>   
  
  
## 10.7 심화 내용

### 10.7.1 제네릭 람다 (C++14)
C++14부터는 람다의 매개변수에 `auto`를 사용할 수 있다.

```cpp
#include <iostream>
#include <string>
#include <vector>

int main() {
    // 제네릭 람다 - 어떤 타입이든 받을 수 있음
    auto print = [](const auto& value) {
        std::cout << value << "\n";
    };
    
    print(42);              // int
    print(3.14);            // double
    print("Hello");         // const char*
    print(std::string("World"));  // std::string
    
    // 여러 타입의 매개변수
    auto add = [](const auto& a, const auto& b) {
        return a + b;
    };
    
    std::cout << add(3, 4) << "\n";           // 7
    std::cout << add(3.5, 2.5) << "\n";       // 6.0
    std::cout << add(std::string("Hello"), std::string(" World")) << "\n";  // Hello World
    
    // 컨테이너의 원소 타입에 관계없이 사용
    auto printAll = [](const auto& container) {
        for (const auto& item : container) {
            std::cout << item << " ";
        }
        std::cout << "\n";
    };
    
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    std::vector<std::string> words = {"C++", "is", "awesome"};
    
    printAll(numbers);
    printAll(words);
    
    return 0;
}
```

### 10.7.2 템플릿 람다 (C++20)
C++20에서는 람다에 명시적인 템플릿 매개변수를 지정할 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <concepts>

int main() {
    // 템플릿 람다
    auto print = []<typename T>(const T& value) {
        std::cout << "타입: " << typeid(T).name() << ", 값: " << value << "\n";
    };
    
    print(42);
    print(3.14);
    print("Hello");
    
    // 템플릿 매개변수 팩 사용
    auto sum = []<typename... Args>(Args... args) {
        return (args + ...);
    };
    
    std::cout << "합계: " << sum(1, 2, 3, 4, 5) << "\n";  // 15
    
    // Concepts 사용
    auto printIntegral = []<std::integral T>(T value) {
        std::cout << "정수형 값: " << value << "\n";
    };
    
    printIntegral(42);
    // printIntegral(3.14);  // 오류: double은 integral이 아님
    
    return 0;
}
```

### 10.7.3 즉시 실행 람다 (IIFE - Immediately Invoked Function Expression)
람다를 정의하자마자 바로 실행할 수 있다.

```cpp
#include <iostream>
#include <vector>

int main() {
    // const 변수를 조건부로 초기화
    const int value = [](int x) {
        if (x > 0) return x * 2;
        else if (x < 0) return -x;
        else return 1;
    }(-5);
    
    std::cout << "value = " << value << "\n";  // 5
    
    // 복잡한 초기화 로직
    const auto data = []() {
        std::vector<int> result;
        for (int i = 0; i < 10; ++i) {
            if (i % 2 == 0) {
                result.push_back(i * i);
            }
        }
        return result;
    }();
    
    std::cout << "data: ";
    for (int n : data) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 조건부 실행
    int mode = 2;
    [mode]() {
        switch (mode) {
            case 1: std::cout << "모드 1 실행\n"; break;
            case 2: std::cout << "모드 2 실행\n"; break;
            default: std::cout << "기본 모드 실행\n"; break;
        }
    }();
    
    return 0;
}
```

### 10.7.4 재귀 람다
람다 안에서 자기 자신을 호출하려면 `std::function`이나 `auto`를 활용해야 한다.

```cpp
#include <iostream>
#include <functional>

int main() {
    // std::function을 사용한 재귀 람다
    std::function<int(int)> factorial = [&factorial](int n) -> int {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    };
    
    std::cout << "5! = " << factorial(5) << "\n";  // 120
    
    // C++23의 명시적 this를 사용한 재귀 (더 간결)
    // auto fibonacci = [](this auto self, int n) -> int {
    //     if (n <= 1) return n;
    //     return self(n - 1) + self(n - 2);
    // };
    
    // Y-Combinator를 사용한 재귀 (고급 기법)
    auto Y = [](auto f) {
        return [f](auto... args) {
            return f(f, args...);
        };
    };
    
    auto fib = Y([](auto self, int n) -> int {
        if (n <= 1) return n;
        return self(self, n - 1) + self(self, n - 2);
    });
    
    std::cout << "피보나치 수열: ";
    for (int i = 0; i < 10; ++i) {
        std::cout << fib(i) << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

### 10.7.5 실전 활용: 체이닝 가능한 API
람다를 활용하여 유창한 인터페이스(fluent interface)를 구현할 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <functional>
#include <algorithm>

template<typename T>
class Pipeline {
private:
    std::vector<T> data;

public:
    Pipeline(std::vector<T> d) : data(std::move(d)) {}
    
    Pipeline& filter(std::function<bool(const T&)> predicate) {
        std::vector<T> filtered;
        std::copy_if(data.begin(), data.end(), 
                     std::back_inserter(filtered), predicate);
        data = std::move(filtered);
        return *this;
    }
    
    Pipeline& transform(std::function<T(const T&)> mapper) {
        std::transform(data.begin(), data.end(), data.begin(), mapper);
        return *this;
    }
    
    void forEach(std::function<void(const T&)> action) {
        std::for_each(data.begin(), data.end(), action);
    }
    
    std::vector<T> collect() {
        return data;
    }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    auto result = Pipeline(numbers)
        .filter([](int x) { return x % 2 == 0; })     // 짝수만
        .transform([](int x) { return x * x; })       // 제곱
        .filter([](int x) { return x > 20; })         // 20보다 큰 것만
        .collect();
    
    std::cout << "결과: ";
    for (int n : result) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 출력 체이닝
    Pipeline(std::vector<std::string>{"hello", "world", "c++", "lambda"})
        .filter([](const auto& s) { return s.length() > 3; })
        .transform([](const auto& s) { 
            std::string upper = s;
            for (char& c : upper) c = std::toupper(c);
            return upper;
        })
        .forEach([](const auto& s) { std::cout << s << "\n"; });
    
    return 0;
}
```

이 장에서는 람다 표현식의 기본부터 고급 활용까지 살펴보았다. 람다 표현식은 Modern C++에서 가장 강력하고 자주 사용되는 기능 중 하나다. 캡처 리스트를 통해 외부 변수를 유연하게 다룰 수 있고, `std::function`과 함께 사용하면 콜백과 이벤트 처리를 깔끔하게 구현할 수 있다. 다음 장에서는 스마트 포인터를 통해 안전한 메모리 관리 방법을 배울 것이다.   