# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 16: 템플릿 기초
템플릿은 C++의 가장 강력한 기능 중 하나다. 같은 로직을 여러 타입에 대해 반복해서 작성하는 대신, 템플릿을 사용하면 타입에 독립적인 코드를 작성할 수 있다. Modern C++에서는 C++20의 Concepts를 통해 템플릿을 더욱 안전하고 명확하게 사용할 수 있게 되었다.

## 16.1 함수 템플릿의 기본
함수 템플릿은 타입을 매개변수로 받는 함수를 정의하는 방법이다. 컴파일러는 함수 호출 시 전달된 인자의 타입을 보고 자동으로 적절한 함수를 생성한다.

### 16.1.1 템플릿이 필요한 이유
템플릿 없이 여러 타입에 대해 최댓값을 구하는 함수를 작성한다면 다음과 같이 오버로딩을 사용해야 한다.

```cpp
#include <iostream>

int max(int a, int b) {
    return (a > b) ? a : b;
}

double max(double a, double b) {
    return (a > b) ? a : b;
}

std::string max(const std::string& a, const std::string& b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << max(10, 20) << '\n';           // int 버전 호출
    std::cout << max(3.14, 2.71) << '\n';       // double 버전 호출
    std::cout << max("apple", "banana") << '\n'; // string 버전 호출
}
```

이 코드는 동작하지만, 같은 로직을 타입별로 반복해서 작성해야 한다는 문제가 있다. 새로운 타입에 대해 max 함수가 필요할 때마다 오버로딩을 추가해야 한다.

### 16.1.2 기본 함수 템플릿
함수 템플릿을 사용하면 하나의 정의로 모든 타입에 대응할 수 있다.

```cpp
#include <iostream>
#include <string>

// 함수 템플릿 정의
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << max(10, 20) << '\n';              // T = int
    std::cout << max(3.14, 2.71) << '\n';          // T = double
    std::cout << max<std::string>("apple", "banana") << '\n'; // T = std::string (명시적 지정)
    
    // 타입 추론이 자동으로 이루어진다
    auto result1 = max(100, 200);        // int
    auto result2 = max(1.5, 2.5);        // double
}
```

`template <typename T>`는 T가 타입 매개변수임을 선언한다. 함수가 호출될 때 컴파일러는 인자의 타입을 보고 T를 자동으로 결정한다.

### 16.1.3 여러 타입 매개변수 사용
템플릿은 여러 개의 타입 매개변수를 가질 수 있다.

```cpp
#include <iostream>
#include <string>

template <typename T1, typename T2>
void print_pair(T1 first, T2 second) {
    std::cout << "첫 번째: " << first << ", 두 번째: " << second << '\n';
}

template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    print_pair(42, "안녕하세요");          // T1=int, T2=const char*
    print_pair(3.14, std::string("Pi"));   // T1=double, T2=std::string
    
    auto result1 = add(10, 20.5);          // int + double = double
    auto result2 = add(5.5, 3);            // double + int = double
    
    std::cout << "10 + 20.5 = " << result1 << '\n';
    std::cout << "5.5 + 3 = " << result2 << '\n';
}
```

`decltype(a + b)`는 a + b 표현식의 타입을 반환 타입으로 사용한다. C++14부터는 `auto` 반환 타입 추론을 사용하면 더 간단하게 작성할 수 있다.

```cpp
template <typename T, typename U>
auto add(T a, U b) {
    return a + b;  // 반환 타입이 자동으로 추론된다
}
```

### 16.1.4 템플릿 특수화 미리보기
때로는 특정 타입에 대해서만 다른 동작을 하도록 만들고 싶을 때가 있다. 이는 뒤에서 다룰 템플릿 특수화로 해결할 수 있다.
  

</br>  
</br>  


## 16.2 클래스 템플릿 활용
클래스 템플릿은 타입에 독립적인 클래스를 정의하는 방법이다. 표준 라이브러리의 `std::vector`, `std::array`, `std::optional` 등이 모두 클래스 템플릿이다.

### 16.2.1 기본 클래스 템플릿
간단한 박스 클래스를 템플릿으로 만들어보자.

```cpp
#include <iostream>
#include <string>

template <typename T>
class Box {
private:
    T value;

public:
    Box(T val) : value(val) {}
    
    T get() const {
        return value;
    }
    
    void set(T val) {
        value = val;
    }
    
    void print() const {
        std::cout << "Box contains: " << value << '\n';
    }
};

int main() {
    Box<int> intBox(42);
    intBox.print();
    
    Box<std::string> strBox("Hello");
    strBox.print();
    
    Box<double> doubleBox(3.14);
    doubleBox.print();
    
    // 값 변경
    intBox.set(100);
    std::cout << "New value: " << intBox.get() << '\n';
}
```

클래스 템플릿을 사용할 때는 `Box<int>`, `Box<std::string>`처럼 타입을 명시적으로 지정해야 한다. 함수 템플릿과 달리 클래스 템플릿은 타입 추론이 제한적이다(C++17부터 생성자 인자를 통한 추론이 가능하다).

### 16.2.2 C++17 클래스 템플릿 인자 추론 (CTAD)
C++17부터는 생성자 인자를 통해 클래스 템플릿의 타입을 추론할 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <string>

template <typename T>
class Container {
private:
    T data;

public:
    Container(T val) : data(val) {}
    
    T get() const { return data; }
};

int main() {
    // C++17 이전: 타입을 명시해야 함
    Container<int> c1(42);
    
    // C++17 이후: 타입 추론 가능
    Container c2(42);           // Container<int>로 추론
    Container c3(3.14);         // Container<double>로 추론
    Container c4("Hello");      // Container<const char*>로 추론
    
    // 표준 라이브러리에서도 활용
    std::vector v1{1, 2, 3};              // std::vector<int>
    std::vector v2{1.0, 2.0, 3.0};        // std::vector<double>
    std::pair p1{42, "answer"};           // std::pair<int, const char*>
}
```

### 16.2.3 여러 매개변수를 가진 클래스 템플릿
클래스 템플릿도 여러 타입 매개변수를 가질 수 있다.

```cpp
#include <iostream>
#include <string>

template <typename Key, typename Value>
class KeyValuePair {
private:
    Key key;
    Value value;

public:
    KeyValuePair(Key k, Value v) : key(k), value(v) {}
    
    Key getKey() const { return key; }
    Value getValue() const { return value; }
    
    void print() const {
        std::cout << key << " : " << value << '\n';
    }
};

int main() {
    KeyValuePair<std::string, int> age("Alice", 25);
    age.print();
    
    KeyValuePair<int, double> temperature(20, 36.5);
    temperature.print();
    
    // C++17 CTAD 사용
    KeyValuePair score("Math", 95);  // KeyValuePair<const char*, int>
    score.print();
}
```

### 16.2.4 템플릿 멤버 함수
클래스 템플릿의 멤버 함수를 클래스 외부에서 정의할 때는 템플릿 선언을 반복해야 한다.

```cpp
#include <iostream>

template <typename T>
class Calculator {
private:
    T result;

public:
    Calculator() : result(T{}) {}
    
    void add(T value);
    void subtract(T value);
    T getResult() const;
    void reset();
};

// 멤버 함수를 클래스 외부에서 정의
template <typename T>
void Calculator<T>::add(T value) {
    result += value;
}

template <typename T>
void Calculator<T>::subtract(T value) {
    result -= value;
}

template <typename T>
T Calculator<T>::getResult() const {
    return result;
}

template <typename T>
void Calculator<T>::reset() {
    result = T{};  // 기본값으로 초기화
}

int main() {
    Calculator<int> intCalc;
    intCalc.add(10);
    intCalc.add(20);
    intCalc.subtract(5);
    std::cout << "결과: " << intCalc.getResult() << '\n';
    
    Calculator<double> doubleCalc;
    doubleCalc.add(3.14);
    doubleCalc.add(2.71);
    std::cout << "결과: " << doubleCalc.getResult() << '\n';
}
```
  

</br>  
  
  
## 16.3 템플릿 특수화
템플릿 특수화는 특정 타입에 대해 템플릿의 동작을 다르게 정의하는 기법이다.

### 16.3.1 함수 템플릿 특수화
특정 타입에 대해 다른 구현을 제공하고 싶을 때 특수화를 사용한다.

```cpp
#include <iostream>
#include <string>
#include <cstring>

// 일반 템플릿
template <typename T>
bool isEqual(T a, T b) {
    return a == b;
}

// const char*에 대한 특수화
template <>
bool isEqual<const char*>(const char* a, const char* b) {
    return std::strcmp(a, b) == 0;
}

int main() {
    std::cout << std::boolalpha;
    
    // 일반 템플릿 사용
    std::cout << isEqual(10, 10) << '\n';           // true
    std::cout << isEqual(3.14, 2.71) << '\n';       // false
    
    // 특수화된 버전 사용
    const char* str1 = "hello";
    const char* str2 = "hello";
    const char* str3 = str1;
    
    std::cout << isEqual(str1, str2) << '\n';       // true (내용 비교)
    std::cout << isEqual(str1, str3) << '\n';       // true
}
```

특수화를 사용하지 않으면 `const char*`를 비교할 때 포인터 주소를 비교하게 되어 같은 문자열이어도 false가 나올 수 있다.

### 16.3.2 클래스 템플릿 완전 특수화
클래스 템플릿도 특정 타입에 대해 완전히 다른 구현을 제공할 수 있다.

```cpp
#include <iostream>
#include <vector>

// 일반 템플릿
template <typename T>
class Storage {
private:
    T data;

public:
    Storage(T val) : data(val) {}
    
    void print() const {
        std::cout << "Value: " << data << '\n';
    }
    
    T get() const { return data; }
};

// bool에 대한 완전 특수화
template <>
class Storage<bool> {
private:
    bool data;

public:
    Storage(bool val) : data(val) {}
    
    void print() const {
        std::cout << "Boolean value: " << (data ? "true" : "false") << '\n';
    }
    
    bool get() const { return data; }
    
    // bool 전용 메서드
    void toggle() {
        data = !data;
    }
};

int main() {
    Storage<int> intStorage(42);
    intStorage.print();
    
    Storage<bool> boolStorage(true);
    boolStorage.print();
    boolStorage.toggle();
    boolStorage.print();
}
```

### 16.3.3 클래스 템플릿 부분 특수화
여러 타입 매개변수 중 일부만 특수화할 수도 있다.

```cpp
#include <iostream>

// 일반 템플릿
template <typename T, typename U>
class Pair {
public:
    T first;
    U second;
    
    Pair(T f, U s) : first(f), second(s) {}
    
    void print() const {
        std::cout << "General: " << first << ", " << second << '\n';
    }
};

// T가 int인 경우에 대한 부분 특수화
template <typename U>
class Pair<int, U> {
public:
    int first;
    U second;
    
    Pair(int f, U s) : first(f), second(s) {}
    
    void print() const {
        std::cout << "First is int: " << first << ", " << second << '\n';
    }
};

// 두 타입이 같은 경우에 대한 부분 특수화
template <typename T>
class Pair<T, T> {
public:
    T first;
    T second;
    
    Pair(T f, T s) : first(f), second(s) {}
    
    void print() const {
        std::cout << "Same type: " << first << ", " << second << '\n';
    }
    
    bool isEqual() const {
        return first == second;
    }
};

int main() {
    Pair<double, std::string> p1(3.14, "pi");
    p1.print();
    
    Pair<int, std::string> p2(42, "answer");
    p2.print();
    
    Pair<int, int> p3(10, 20);
    p3.print();
    std::cout << "Equal? " << std::boolalpha << p3.isEqual() << '\n';
}
```
   

</br>  
  
  
## 16.4 typename과 class 키워드
템플릿을 작성할 때 `typename`과 `class` 키워드를 사용할 수 있다. 대부분의 경우 둘은 동일하게 사용된다.

### 16.4.1 기본 사용법

```cpp
#include <iostream>

// 두 선언은 완전히 동일하다
template <typename T>
void function1(T value) {
    std::cout << value << '\n';
}

template <class T>
void function2(T value) {
    std::cout << value << '\n';
}

int main() {
    function1(42);
    function2(42);
}
```

현대적인 C++ 코드에서는 `typename`을 선호하는 경향이 있다. `class` 키워드는 클래스 타입만 받을 수 있다는 오해를 불러일으킬 수 있기 때문이다.

### 16.4.2 typename이 필수인 경우
템플릿 내부에서 의존적 타입을 사용할 때는 반드시 `typename` 키워드를 사용해야 한다.

```cpp
#include <iostream>
#include <vector>

template <typename Container>
void printFirst(const Container& container) {
    // Container::value_type이 타입임을 명시
    typename Container::value_type firstElement = container[0];
    std::cout << "First element: " << firstElement << '\n';
}

template <typename T>
class MyContainer {
public:
    using value_type = T;  // 중첩 타입 정의
    using iterator = T*;
    
    // ...
};

int main() {
    std::vector<int> numbers{1, 2, 3, 4, 5};
    printFirst(numbers);
    
    std::vector<std::string> words{"hello", "world"};
    printFirst(words);
}
```

`Container::value_type`은 템플릿 매개변수 Container에 의존하는 타입이다. 컴파일러는 이것이 타입인지 값인지 알 수 없으므로 `typename` 키워드로 명시해야 한다.

### 16.4.3 타입 별칭과 템플릿
C++11의 `using`을 사용하면 템플릿 타입 별칭을 만들 수 있다.

```cpp
#include <vector>
#include <string>
#include <map>

// 타입 별칭 템플릿
template <typename T>
using Vec = std::vector<T>;

template <typename Key, typename Value>
using Map = std::map<Key, Value>;

int main() {
    Vec<int> numbers{1, 2, 3};
    Vec<std::string> words{"hello", "world"};
    
    Map<std::string, int> ages;
    ages["Alice"] = 25;
    ages["Bob"] = 30;
}
```
   

</br>  
  

## 16.5 Concepts 기초 (C++20)
Concepts는 C++20에서 도입된 기능으로, 템플릿 매개변수에 대한 제약 조건을 명확하게 표현할 수 있다. 이를 통해 템플릿 코드를 더 안전하고 이해하기 쉽게 만들 수 있다.

### 16.5.1 Concepts가 필요한 이유
템플릿은 강력하지만 오류 메시지가 복잡하고 이해하기 어렵다는 단점이 있다.

```cpp
#include <iostream>

template <typename T>
T add(T a, T b) {
    return a + b;
}

class MyClass {
public:
    int value;
};

int main() {
    std::cout << add(10, 20) << '\n';
    
    // MyClass는 + 연산자를 지원하지 않으므로 컴파일 오류 발생
    // 오류 메시지가 매우 길고 복잡하다
    // MyClass obj1, obj2;
    // add(obj1, obj2);
}
```

Concepts를 사용하면 이런 문제를 명확한 오류 메시지로 개선할 수 있다.

### 16.5.2 표준 Concepts 사용하기
C++20 표준 라이브러리는 많은 유용한 concepts를 제공한다.

```cpp
#include <iostream>
#include <concepts>
#include <string>

// std::integral concept 사용
template <std::integral T>
T multiply(T a, T b) {
    return a * b;
}

// std::floating_point concept 사용
template <std::floating_point T>
T divide(T a, T b) {
    return a / b;
}

// requires 절을 사용한 제약
template <typename T>
    requires std::is_arithmetic_v<T>
T square(T value) {
    return value * value;
}

int main() {
    std::cout << multiply(10, 20) << '\n';          // OK: int는 integral
    std::cout << divide(10.0, 3.0) << '\n';         // OK: double는 floating_point
    
    // multiply(10.5, 20.5);  // 오류: double은 integral이 아님
    // divide(10, 3);         // 오류: int는 floating_point가 아님
    
    std::cout << square(5) << '\n';                 // OK
    std::cout << square(3.14) << '\n';              // OK
}
```

### 16.5.3 자체 Concepts 정의하기
직접 concepts를 정의하여 더 명확한 의미를 전달할 수 있다.

```cpp
#include <iostream>
#include <concepts>
#include <string>

// Printable concept 정의: << 연산자를 지원하는 타입
template <typename T>
concept Printable = requires(T value, std::ostream& os) {
    { os << value } -> std::convertible_to<std::ostream&>;
};

// Addable concept 정의: + 연산자를 지원하는 타입
template <typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
};

// Comparable concept 정의: 비교 연산자를 지원하는 타입
template <typename T>
concept Comparable = requires(T a, T b) {
    { a < b } -> std::convertible_to<bool>;
    { a > b } -> std::convertible_to<bool>;
    { a == b } -> std::convertible_to<bool>;
};

// Concepts를 사용한 함수
template <Printable T>
void print(const T& value) {
    std::cout << value << '\n';
}

template <Addable T>
T add(T a, T b) {
    return a + b;
}

template <Comparable T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    print(42);
    print(3.14);
    print("Hello");
    print(std::string("World"));
    
    std::cout << add(10, 20) << '\n';
    std::cout << add(1.5, 2.5) << '\n';
    
    std::cout << max(10, 20) << '\n';
    std::cout << max(3.14, 2.71) << '\n';
}
```

### 16.5.4 requires 표현식의 다양한 사용법

```cpp
#include <iostream>
#include <vector>
#include <concepts>

// 단순 요구사항
template <typename T>
concept HasSize = requires(T container) {
    container.size();  // size() 메서드가 있어야 함
};

// 타입 요구사항
template <typename T>
concept Container = requires {
    typename T::value_type;    // value_type이 정의되어 있어야 함
    typename T::iterator;      // iterator가 정의되어 있어야 함
};

// 복합 요구사항
template <typename T>
concept Numeric = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
    { a - b } -> std::convertible_to<T>;
    { a * b } -> std::convertible_to<T>;
    { a / b } -> std::convertible_to<T>;
};

// 중첩 요구사항
template <typename T>
concept SignedNumeric = Numeric<T> && std::is_signed_v<T>;

template <HasSize T>
void printSize(const T& container) {
    std::cout << "Size: " << container.size() << '\n';
}

template <Numeric T>
T average(T a, T b) {
    return (a + b) / T{2};
}

int main() {
    std::vector<int> numbers{1, 2, 3, 4, 5};
    printSize(numbers);
    
    std::cout << "Average: " << average(10, 20) << '\n';
    std::cout << "Average: " << average(3.5, 4.5) << '\n';
}
```

### 16.5.5 축약 함수 템플릿 (C++20)
C++20에서는 `auto` 매개변수와 concepts를 결합하여 간결한 문법을 사용할 수 있다.

```cpp
#include <iostream>
#include <concepts>

// 전통적인 방식
template <std::integral T>
T add_traditional(T a, T b) {
    return a + b;
}

// 축약된 방식
auto add_abbreviated(std::integral auto a, std::integral auto b) {
    return a + b;
}

// 같은 타입을 요구하는 경우
auto add_same_type(std::integral auto a, decltype(a) b) {
    return a + b;
}

// 여러 concepts 결합
auto process(std::integral auto count, std::floating_point auto rate) {
    return count * rate;
}

int main() {
    std::cout << add_traditional(10, 20) << '\n';
    std::cout << add_abbreviated(30, 40) << '\n';
    std::cout << add_same_type(5, 10) << '\n';
    std::cout << process(100, 1.5) << '\n';
}
```
  

</br>  
  

## 16.6 실습 예제: 제네릭 컨테이너 만들기
배운 내용을 종합하여 간단한 제네릭 스택 컨테이너를 만들어보자.

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>
#include <concepts>

// 복사 가능한 타입인지 확인하는 concept
template <typename T>
concept Copyable = std::copyable<T>;

template <Copyable T>
class Stack {
private:
    std::vector<T> elements;

public:
    // 요소 추가
    void push(const T& element) {
        elements.push_back(element);
    }
    
    void push(T&& element) {
        elements.push_back(std::move(element));
    }
    
    // 요소 제거 및 반환
    T pop() {
        if (elements.empty()) {
            throw std::runtime_error("Stack is empty");
        }
        T top = std::move(elements.back());
        elements.pop_back();
        return top;
    }
    
    // 최상위 요소 확인 (제거하지 않음)
    const T& top() const {
        if (elements.empty()) {
            throw std::runtime_error("Stack is empty");
        }
        return elements.back();
    }
    
    // 비어있는지 확인
    bool empty() const {
        return elements.empty();
    }
    
    // 크기 반환
    size_t size() const {
        return elements.size();
    }
    
    // 모든 요소 출력 (Printable 타입인 경우만)
    void print() const requires requires(T t) {
        std::cout << t;
    } {
        std::cout << "Stack (top to bottom): ";
        for (auto it = elements.rbegin(); it != elements.rend(); ++it) {
            std::cout << *it << " ";
        }
        std::cout << '\n';
    }
};

int main() {
    // 정수 스택
    Stack<int> intStack;
    intStack.push(10);
    intStack.push(20);
    intStack.push(30);
    
    std::cout << "Integer Stack:\n";
    intStack.print();
    std::cout << "Size: " << intStack.size() << '\n';
    std::cout << "Top: " << intStack.top() << '\n';
    std::cout << "Pop: " << intStack.pop() << '\n';
    intStack.print();
    
    // 문자열 스택
    Stack<std::string> strStack;
    strStack.push("Hello");
    strStack.push("World");
    strStack.push("!");
    
    std::cout << "\nString Stack:\n";
    strStack.print();
    
    while (!strStack.empty()) {
        std::cout << "Pop: " << strStack.pop() << '\n';
    }
    
    // 빈 스택에서 pop 시도 (예외 발생)
    try {
        strStack.pop();
    } catch (const std::runtime_error& e) {
        std::cout << "Exception: " << e.what() << '\n';
    }
}
```
  

</br>  
  
  
## 16.7 실습 문제

### 문제 1: 제네릭 최소값/최대값 찾기
여러 개의 값 중에서 최소값과 최대값을 동시에 찾는 함수 템플릿을 작성하라. 함수는 `std::pair`를 반환해야 하며, 가변 인자 템플릿을 사용하라.

```cpp
// 예상 사용법:
auto [min_val, max_val] = find_min_max(5, 2, 8, 1, 9);
// min_val = 1, max_val = 9
```

### 문제 2: 제네릭 배열 클래스
고정 크기 배열을 위한 템플릿 클래스 `Array<T, N>`을 작성하라. 이 클래스는 다음 기능을 제공해야 한다:
- 인덱스 접근 연산자 `[]`
- `at()` 메서드 (범위 검사 포함)
- `size()` 메서드
- `fill()` 메서드 (모든 요소를 특정 값으로 채우기)
- 반복자 지원 (begin, end)

### 문제 3: 조건부 컨테이너
정수 타입에 대해서는 합계를 계산하는 `sum()` 메서드를 제공하고, 문자열 타입에 대해서는 연결된 문자열을 반환하는 `concatenate()` 메서드를 제공하는 제네릭 컨테이너를 만들어라. Concepts와 `if constexpr`를 활용하라.
  

</br>  


## 16.8 심화 내용

### 16.8.1 가변 인자 템플릿 (Variadic Templates)
가변 인자 템플릿을 사용하면 임의 개수의 인자를 받는 템플릿을 작성할 수 있다.

```cpp
#include <iostream>

// 재귀의 종료 조건
void print() {
    std::cout << '\n';
}

// 가변 인자 템플릿
template <typename T, typename... Args>
void print(T first, Args... args) {
    std::cout << first << " ";
    print(args...);  // 재귀 호출
}

// Fold Expression을 사용한 간결한 버전 (C++17)
template <typename... Args>
void print_fold(Args... args) {
    (std::cout << ... << args) << '\n';
}

// 가변 인자 템플릿을 사용한 sum 함수
template <typename... Args>
auto sum(Args... args) {
    return (... + args);  // Fold expression
}

int main() {
    print(1, 2.5, "hello", 'c');
    print_fold("One", " Two", " Three");
    
    std::cout << "Sum: " << sum(1, 2, 3, 4, 5) << '\n';
    std::cout << "Sum: " << sum(1.1, 2.2, 3.3) << '\n';
}
```

### 16.8.2 SFINAE와 std::enable_if
SFINAE(Substitution Failure Is Not An Error)는 템플릿 대체 실패가 오류가 아니라는 원칙이다. 이를 활용하여 조건부 템플릿 활성화를 구현할 수 있다.

```cpp
#include <iostream>
#include <type_traits>

// 정수 타입에 대해서만 활성화
template <typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
process(T value) {
    std::cout << "Processing integer: " << value << '\n';
    return value * 2;
}

// 부동소수점 타입에 대해서만 활성화
template <typename T>
typename std::enable_if<std::is_floating_point<T>::value, T>::type
process(T value) {
    std::cout << "Processing float: " << value << '\n';
    return value * 1.5;
}

// C++20 Concepts를 사용한 더 명확한 버전
template <std::integral T>
T process_modern(T value) {
    std::cout << "Processing integer: " << value << '\n';
    return value * 2;
}

template <std::floating_point T>
T process_modern(T value) {
    std::cout << "Processing float: " << value << '\n';
    return value * 1.5;
}

int main() {
    std::cout << process(10) << '\n';
    std::cout << process(3.14) << '\n';
    
    std::cout << process_modern(20) << '\n';
    std::cout << process_modern(2.71) << '\n';
}
```

### 16.8.3 템플릿 메타프로그래밍 맛보기
템플릿을 사용하여 컴파일 타임에 계산을 수행할 수 있다.

```cpp
#include <iostream>

// 컴파일 타임 팩토리얼 계산
template <int N>
struct Factorial {
    static constexpr int value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> {
    static constexpr int value = 1;
};

// C++14 이후: constexpr 함수 사용
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

// 컴파일 타임 피보나치 수열
template <int N>
struct Fibonacci {
    static constexpr int value = Fibonacci<N - 1>::value + Fibonacci<N - 2>::value;
};

template <>
struct Fibonacci<0> {
    static constexpr int value = 0;
};

template <>
struct Fibonacci<1> {
    static constexpr int value = 1;
};

int main() {
    // 컴파일 타임에 계산됨
    std::cout << "5! = " << Factorial<5>::value << '\n';
    std::cout << "10! = " << factorial(10) << '\n';
    
    std::cout << "Fibonacci(10) = " << Fibonacci<10>::value << '\n';
}
```

### 16.8.4 타입 특성 (Type Traits)
`<type_traits>` 헤더는 타입에 대한 정보를 컴파일 타임에 얻을 수 있는 도구를 제공한다.

```cpp
#include <iostream>
#include <type_traits>
#include <string>

template <typename T>
void analyze_type() {
    std::cout << "Type analysis:\n";
    std::cout << "  Is integral: " << std::is_integral_v<T> << '\n';
    std::cout << "  Is floating point: " << std::is_floating_point_v<T> << '\n';
    std::cout << "  Is pointer: " << std::is_pointer_v<T> << '\n';
    std::cout << "  Is const: " << std::is_const_v<T> << '\n';
    std::cout << "  Is class: " << std::is_class_v<T> << '\n';
    std::cout << "  Size: " << sizeof(T) << " bytes\n\n";
}

// 타입에 따라 다른 처리
template <typename T>
void smart_print(const T& value) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Integer value: " << value << '\n';
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "Floating point value: " << value << '\n';
    } else if constexpr (std::is_same_v<T, std::string>) {
        std::cout << "String value: " << value << '\n';
    } else {
        std::cout << "Unknown type\n";
    }
}

int main() {
    analyze_type<int>();
    analyze_type<double>();
    analyze_type<std::string>();
    analyze_type<int*>();
    analyze_type<const int>();
    
    smart_print(42);
    smart_print(3.14);
    smart_print(std::string("Hello"));
}
```
   

</br>  
  
  
## 16.9 정리
이 장에서는 C++ 템플릿의 기초를 배웠다. 함수 템플릿과 클래스 템플릿을 사용하여 타입에 독립적인 코드를 작성할 수 있으며, 템플릿 특수화를 통해 특정 타입에 대한 동작을 커스터마이징할 수 있다. C++20의 Concepts는 템플릿 코드를 더욱 안전하고 명확하게 만들어준다.

템플릿은 처음에는 복잡해 보일 수 있지만, Modern C++의 핵심 기능 중 하나다. 표준 라이브러리의 대부분이 템플릿으로 구현되어 있으며, 제네릭 프로그래밍은 재사용 가능한 코드를 작성하는 강력한 도구다.

다음 장에서는 예외 처리와 오류 관리에 대해 배우면서, 안전하고 견고한 프로그램을 작성하는 방법을 알아본다.  