# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 8: 배열과 문자열의 Modern 접근
프로그래밍에서 여러 개의 데이터를 다루는 것은 매우 흔한 일이다. 학생들의 점수를 저장하거나, 게임에서 적들의 위치를 관리하거나, 사용자의 이름을 저장하는 등 다양한 상황에서 여러 데이터를 효율적으로 다뤄야 한다. 이런 경우 배열과 문자열을 사용한다.

C++은 오랜 역사를 가진 언어로, C 언어에서 물려받은 배열과 문자열 처리 방식이 있다. 하지만 이러한 전통적인 방식은 안전하지 않고 사용하기 어렵다는 문제가 있다. Modern C++에서는 이러한 문제를 해결하기 위해 `std::array`, `std::vector`, `std::string` 같은 안전하고 사용하기 쉬운 대안을 제공한다.

이번 장에서는 전통적인 C 스타일 배열의 한계를 이해하고, Modern C++이 제공하는 안전하고 강력한 도구들을 배운다. 특히 범위 기반 `for` 문과 함께 사용하면 코드가 얼마나 간결하고 안전해지는지 직접 확인할 수 있다.

## 8.1 C 스타일 배열의 한계
C++은 C 언어와의 호환성을 위해 C 스타일 배열을 지원한다. 하지만 이 방식에는 여러 가지 문제점이 있다.

### 8.1.1 C 스타일 배열의 기본
C 스타일 배열은 다음과 같이 선언한다.

```cpp
#include <iostream>

int main() {
    int numbers[5];  // 정수 5개를 저장할 배열
    
    // 값 할당
    numbers[0] = 10;
    numbers[1] = 20;
    numbers[2] = 30;
    numbers[3] = 40;
    numbers[4] = 50;
    
    // 출력
    for (int i = 0; i < 5; ++i) {
        std::cout << numbers[i] << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
10 20 30 40 50
```

배열은 0부터 시작하는 인덱스로 접근한다. 크기가 5인 배열은 인덱스 0부터 4까지 사용할 수 있다.

초기화는 중괄호를 사용할 수도 있다.

```cpp
#include <iostream>

int main() {
    int scores[5] = {85, 90, 78, 92, 88};
    
    for (int i = 0; i < 5; ++i) {
        std::cout << "점수 " << i + 1 << ": " << scores[i] << "\n";
    }
    
    return 0;
}
```

### 8.1.2 C 스타일 배열의 문제점
**문제 1: 경계 검사 없음**

C 스타일 배열의 가장 큰 문제는 배열의 범위를 벗어나는 접근을 막지 못한다는 것이다.

```cpp
#include <iostream>

int main() {
    int numbers[5] = {1, 2, 3, 4, 5};
    
    // 위험: 범위를 벗어난 접근
    std::cout << numbers[10] << "\n";  // 정의되지 않은 동작!
    numbers[10] = 100;  // 메모리 손상 가능!
    
    return 0;
}
```

이 코드는 컴파일 오류를 발생시키지 않지만, 실행 시 예측할 수 없는 동작을 한다. 프로그램이 충돌하거나, 다른 메모리 영역을 덮어쓰거나, 보안 취약점이 될 수 있다. 이런 종류의 버그는 찾기도 매우 어렵다.

**문제 2: 크기 정보 손실**

배열을 함수에 전달하면 크기 정보가 사라진다.

```cpp
#include <iostream>

void print_array(int arr[]) {  // 배열이 포인터로 변환됨
    // sizeof(arr)는 배열의 크기가 아니라 포인터의 크기를 반환
    std::cout << "함수 내부 sizeof: " << sizeof(arr) << "\n";
}

int main() {
    int numbers[5] = {1, 2, 3, 4, 5};
    
    std::cout << "main sizeof: " << sizeof(numbers) << "\n";
    print_array(numbers);
    
    return 0;
}
```

**출력 결과 (64비트 시스템):**
```
main sizeof: 20
함수 내부 sizeof: 8
```

`main`에서 `sizeof(numbers)`는 20바이트(정수 5개 × 4바이트)를 반환하지만, 함수 내부에서는 포인터의 크기인 8바이트를 반환한다. 따라서 배열의 실제 크기를 알 수 없다.

**문제 3: 복사와 대입 불가**

배열을 다른 배열에 직접 복사하거나 대입할 수 없다.

```cpp
int main() {
    int arr1[5] = {1, 2, 3, 4, 5};
    int arr2[5];
    
    // arr2 = arr1;  // 컴파일 오류!
    
    // 수동으로 복사해야 함
    for (int i = 0; i < 5; ++i) {
        arr2[i] = arr1[i];
    }
    
    return 0;
}
```

**문제 4: 동적 크기 조정 불가**

배열의 크기는 컴파일 타임에 결정되어야 하며, 실행 중에 변경할 수 없다.

```cpp
int main() {
    int size;
    std::cin >> size;
    
    // int arr[size];  // C++에서는 표준이 아님 (일부 컴파일러는 확장으로 지원)
    
    return 0;
}
```

이러한 이유로 Modern C++에서는 C 스타일 배열 대신 `std::array`와 `std::vector`를 사용할 것을 강력히 권장한다.
   

</br>  
</br>  
  

## 8.2 `std::array`로 안전한 고정 배열
`std::array`는 C++11에서 도입된 고정 크기 배열 컨테이너다. C 스타일 배열의 성능은 유지하면서도 안전성과 편의성을 크게 향상시켰다.

### 8.2.1 `std::array`의 기본 사용법
`std::array`를 사용하려면 `<array>` 헤더를 포함해야 한다.

```cpp
#include <iostream>
#include <array>

int main() {
    // std::array<타입, 크기> 이름;
    std::array<int, 5> numbers = {10, 20, 30, 40, 50};
    
    // 인덱스로 접근
    std::cout << "첫 번째 요소: " << numbers[0] << "\n";
    std::cout << "세 번째 요소: " << numbers[2] << "\n";
    
    // at() 함수로 안전한 접근
    std::cout << "다섯 번째 요소: " << numbers.at(4) << "\n";
    
    // 크기 확인
    std::cout << "배열 크기: " << numbers.size() << "\n";
    
    return 0;
}
```

**출력 결과:**
```
첫 번째 요소: 10
세 번째 요소: 30
다섯 번째 요소: 50
배열 크기: 5
```

### 8.2.2 안전한 접근: `at()` vs `[]`
`std::array`는 두 가지 접근 방법을 제공한다.

- **`[]` 연산자**: C 스타일 배열처럼 빠르지만 경계 검사를 하지 않는다.
- **`at()` 함수**: 경계 검사를 수행하며, 범위를 벗어나면 예외를 던진다.

```cpp
#include <iostream>
#include <array>

int main() {
    std::array<int, 5> numbers = {1, 2, 3, 4, 5};
    
    try {
        // 안전한 접근
        std::cout << numbers.at(2) << "\n";  // OK: 3 출력
        
        // 범위를 벗어난 접근
        std::cout << numbers.at(10) << "\n";  // 예외 발생!
    }
    catch (const std::out_of_range& e) {
        std::cout << "오류: " << e.what() << "\n";
    }
    
    return 0;
}
```

**출력 결과:**
```
3
오류: invalid array<T, N> subscript
```

개발 단계에서는 `at()`을 사용하여 버그를 조기에 발견하고, 성능이 중요한 부분에서는 `[]`를 사용하는 것이 좋다.

### 8.2.3 `std::array`의 유용한 기능
**모든 요소 초기화**

```cpp
#include <array>

int main() {
    std::array<int, 5> zeros = {};  // 모두 0으로 초기화
    std::array<int, 5> filled;
    filled.fill(42);  // 모두 42로 채우기
    
    return 0;
}
```

**첫 번째와 마지막 요소 접근**

```cpp
#include <iostream>
#include <array>

int main() {
    std::array<int, 5> numbers = {10, 20, 30, 40, 50};
    
    std::cout << "첫 요소: " << numbers.front() << "\n";
    std::cout << "마지막 요소: " << numbers.back() << "\n";
    
    return 0;
}
```

**출력 결과:**
```
첫 요소: 10
마지막 요소: 50
```

**배열이 비어있는지 확인**

```cpp
#include <array>

int main() {
    std::array<int, 5> arr;
    
    if (arr.empty()) {  // std::array는 항상 false
        // 크기가 0이 아닌 한 절대 실행되지 않음
    }
    
    return 0;
}
```

`std::array`는 컴파일 타임에 크기가 고정되므로 `empty()`는 크기가 0일 때만 `true`를 반환한다.

### 8.2.4 범위 기반 `for` 문과 함께 사용
`std::array`는 범위 기반 `for` 문과 완벽하게 작동한다.

```cpp
#include <iostream>
#include <array>

int main() {
    std::array<int, 5> scores = {85, 90, 78, 92, 88};
    
    // 읽기 전용 순회
    std::cout << "점수 목록: ";
    for (const auto& score : scores) {
        std::cout << score << " ";
    }
    std::cout << "\n";
    
    // 값 수정
    for (auto& score : scores) {
        score += 5;  // 모든 점수에 5점 추가
    }
    
    // 합계 계산
    int total = 0;
    for (const auto& score : scores) {
        total += score;
    }
    
    std::cout << "총점: " << total << "\n";
    std::cout << "평균: " << total / static_cast<double>(scores.size()) << "\n";
    
    return 0;
}
```

**출력 결과:**
```
점수 목록: 85 90 78 92 88
총점: 458
평균: 91.6
```

### 8.2.5 다차원 배열
`std::array`를 중첩하여 다차원 배열을 만들 수 있다.

```cpp
#include <iostream>
#include <array>

int main() {
    // 3x3 배열 (틱택토 보드)
    std::array<std::array<char, 3>, 3> board = {{
        {'X', 'O', 'X'},
        {'O', 'X', 'O'},
        {'O', 'X', 'X'}
    }};
    
    // 출력
    for (const auto& row : board) {
        for (const auto& cell : row) {
            std::cout << cell << " ";
        }
        std::cout << "\n";
    }
    
    return 0;
}
```

**출력 결과:**
```
X O X
O X O
O X X
```

### 8.2.6 `std::array` vs C 스타일 배열 비교
| 특성 | C 스타일 배열 | `std::array` |
|------|---------------|--------------|
| 경계 검사 | 없음 | `at()`으로 가능 |
| 크기 정보 | 함수 전달 시 손실 | 항상 유지 (`size()`) |
| 복사/대입 | 불가능 | 가능 |
| 범위 기반 `for` | 제한적 | 완벽 지원 |
| STL 알고리즘 | 제한적 | 완벽 지원 |
| 성능 | 빠름 | 동일 (최적화 시) |
  


</br>  
</br>  
  

## 8.3 `std::vector`로 동적 배열 관리
`std::array`는 크기가 고정되어 있어 컴파일 타임에 크기를 알아야 한다. 하지만 실행 중에 크기가 결정되거나 변경되어야 하는 경우가 많다. 이럴 때 `std::vector`를 사용한다.

`std::vector`는 C++ 표준 라이브러리에서 가장 많이 사용되는 컨테이너다. 동적으로 크기를 조정할 수 있으면서도 배열처럼 빠른 임의 접근이 가능하다.

### 8.3.1 `std::vector`의 기본 사용법

```cpp
#include <iostream>
#include <vector>

int main() {
    // 빈 벡터 생성
    std::vector<int> numbers;
    
    // 요소 추가
    numbers.push_back(10);
    numbers.push_back(20);
    numbers.push_back(30);
    
    std::cout << "크기: " << numbers.size() << "\n";
    std::cout << "용량: " << numbers.capacity() << "\n";
    
    // 요소 접근
    for (size_t i = 0; i < numbers.size(); ++i) {
        std::cout << numbers[i] << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
크기: 3
용량: 4
10 20 30
```

`size()`는 현재 저장된 요소의 개수를 반환하고, `capacity()`는 메모리 재할당 없이 저장할 수 있는 최대 요소 개수를 반환한다.

### 8.3.2 다양한 생성 방법

```cpp
#include <vector>

int main() {
    // 빈 벡터
    std::vector<int> v1;
    
    // 크기를 지정하고 기본값으로 초기화
    std::vector<int> v2(5);  // {0, 0, 0, 0, 0}
    
    // 크기와 초기값 지정
    std::vector<int> v3(5, 100);  // {100, 100, 100, 100, 100}
    
    // 초기화 리스트 사용
    std::vector<int> v4 = {1, 2, 3, 4, 5};
    
    // 다른 벡터로부터 복사
    std::vector<int> v5 = v4;
    
    return 0;
}
```

### 8.3.3 요소 추가와 삭제

**뒤에 추가/삭제**

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3};
    
    // 뒤에 추가
    numbers.push_back(4);
    numbers.push_back(5);
    
    // 출력
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    // 마지막 요소 삭제
    numbers.pop_back();
    
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 4 5
1 2 3 4
```

**중간에 삽입/삭제**

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 4, 5};
    
    // 3번째 위치(인덱스 2)에 3 삽입
    numbers.insert(numbers.begin() + 2, 3);
    
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    // 2번째 요소(인덱스 1) 삭제
    numbers.erase(numbers.begin() + 1);
    
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 4 5
1 3 4 5
```

**모든 요소 삭제**

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    std::cout << "삭제 전 크기: " << numbers.size() << "\n";
    
    numbers.clear();
    
    std::cout << "삭제 후 크기: " << numbers.size() << "\n";
    std::cout << "비어있나요? " << (numbers.empty() ? "예" : "아니오") << "\n";
    
    return 0;
}
```

**출력 결과:**
```
삭제 전 크기: 5
삭제 후 크기: 0
비어있나요? 예
```

### 8.3.4 벡터의 크기와 용량 관리
벡터는 자동으로 메모리를 관리하지만, 성능을 위해 크기와 용량을 이해하는 것이 중요하다.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers;
    
    std::cout << "초기 - 크기: " << numbers.size() 
              << ", 용량: " << numbers.capacity() << "\n";
    
    // 요소 추가하면서 용량 변화 관찰
    for (int i = 1; i <= 10; ++i) {
        numbers.push_back(i);
        std::cout << "요소 " << i << " 추가 - 크기: " << numbers.size() 
                  << ", 용량: " << numbers.capacity() << "\n";
    }
    
    return 0;
}
```

**출력 결과 (구현에 따라 다를 수 있음):**
```
초기 - 크기: 0, 용량: 0
요소 1 추가 - 크기: 1, 용량: 1
요소 2 추가 - 크기: 2, 용량: 2
요소 3 추가 - 크기: 3, 용량: 4
요소 4 추가 - 크기: 4, 용량: 4
요소 5 추가 - 크기: 5, 용량: 8
...
```

용량이 부족하면 벡터는 자동으로 더 큰 메모리를 할당하고 기존 요소들을 복사한다. 이 과정은 비용이 크므로, 예상되는 크기를 미리 알고 있다면 `reserve()`를 사용하여 메모리를 예약하는 것이 좋다.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers;
    
    // 1000개의 요소를 위한 메모리 미리 할당
    numbers.reserve(1000);
    
    std::cout << "예약 후 용량: " << numbers.capacity() << "\n";
    
    // 이제 1000개까지는 재할당 없이 추가 가능
    for (int i = 0; i < 1000; ++i) {
        numbers.push_back(i);
    }
    
    std::cout << "1000개 추가 후 용량: " << numbers.capacity() << "\n";
    
    return 0;
}
```

**크기 조정**

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3};
    
    // 크기를 5로 늘리기 (새 요소는 0으로 초기화)
    numbers.resize(5);
    
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    // 크기를 2로 줄이기
    numbers.resize(2);
    
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 0 0
1 2
```

### 8.3.5 실용적인 예제

**성적 관리 프로그램**

```cpp
#include <iostream>
#include <vector>
#include <numeric>  // std::accumulate
#include <algorithm>  // std::sort

int main() {
    std::vector<int> scores;
    int score;
    
    std::cout << "성적을 입력하세요 (음수 입력 시 종료):\n";
    
    // 성적 입력
    while (true) {
        std::cout << "점수: ";
        std::cin >> score;
        
        if (score < 0) {
            break;
        }
        
        scores.push_back(score);
    }
    
    if (scores.empty()) {
        std::cout << "입력된 성적이 없습니다.\n";
        return 0;
    }
    
    // 통계 계산
    int total = std::accumulate(scores.begin(), scores.end(), 0);
    double average = total / static_cast<double>(scores.size());
    
    std::sort(scores.begin(), scores.end());
    int lowest = scores.front();
    int highest = scores.back();
    
    // 결과 출력
    std::cout << "\n=== 성적 통계 ===\n";
    std::cout << "학생 수: " << scores.size() << "\n";
    std::cout << "총점: " << total << "\n";
    std::cout << "평균: " << average << "\n";
    std::cout << "최저점: " << lowest << "\n";
    std::cout << "최고점: " << highest << "\n";
    
    std::cout << "\n정렬된 성적: ";
    for (int s : scores) {
        std::cout << s << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**실행 예:**
```
성적을 입력하세요 (음수 입력 시 종료):
점수: 85
점수: 90
점수: 78
점수: 92
점수: 88
점수: -1

=== 성적 통계 ===
학생 수: 5
총점: 433
평균: 86.6
최저점: 78
최고점: 92

정렬된 성적: 78 85 88 90 92
```

### 8.3.6 2차원 벡터
벡터를 중첩하여 2차원 데이터를 표현할 수 있다.

```cpp
#include <iostream>
#include <vector>

int main() {
    // 3x4 행렬
    std::vector<std::vector<int>> matrix = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    // 출력
    for (const auto& row : matrix) {
        for (const auto& value : row) {
            std::cout << value << "\t";
        }
        std::cout << "\n";
    }
    
    // 특정 요소 접근
    std::cout << "\nmatrix[1][2] = " << matrix[1][2] << "\n";
    
    return 0;
}
```

**출력 결과:**
```
1    2    3    4
5    6    7    8
9    10   11   12

matrix[1][2] = 7
```

**동적 크기의 2차원 벡터**

```cpp
#include <iostream>
#include <vector>

int main() {
    int rows, cols;
    
    std::cout << "행 수: ";
    std::cin >> rows;
    std::cout << "열 수: ";
    std::cin >> cols;
    
    // rows x cols 크기의 벡터 생성 (모두 0으로 초기화)
    std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols, 0));
    
    // 값 설정
    int value = 1;
    for (auto& row : matrix) {
        for (auto& cell : row) {
            cell = value++;
        }
    }
    
    // 출력
    for (const auto& row : matrix) {
        for (const auto& cell : row) {
            std::cout << cell << "\t";
        }
        std::cout << "\n";
    }
    
    return 0;
}
```
   
   
</br>  
</br>  
  
  
## 8.4 `std::string`과 문자열 처리
문자열은 프로그래밍에서 매우 자주 사용된다. C 언어는 문자 배열로 문자열을 표현했지만, 이 방식은 안전하지 않고 사용하기 불편하다. Modern C++의 `std::string`은 안전하고 강력한 문자열 처리 기능을 제공한다.

### 8.4.1 C 스타일 문자열의 문제
C 스타일 문자열은 널 종료 문자(`'\0'`)로 끝나는 `char` 배열이다.

```cpp
#include <iostream>
#include <cstring>  // strlen, strcpy 등

int main() {
    char name[20] = "Alice";
    
    std::cout << "이름: " << name << "\n";
    std::cout << "길이: " << strlen(name) << "\n";
    
    // 문자열 복사 - 위험!
    char copy[20];
    strcpy(copy, name);  // 버퍼 오버플로우 위험
    
    return 0;
}
```

이 방식의 문제점은 다음과 같다.

- 버퍼 오버플로우 위험
- 수동 메모리 관리 필요
- 문자열 연산이 복잡하고 오류 발생 가능
- 길이 정보를 별도로 관리해야 함

### 8.4.2 `std::string`의 기본 사용법
`std::string`을 사용하려면 `<string>` 헤더를 포함한다.

```cpp
#include <iostream>
#include <string>

int main() {
    // 문자열 생성
    std::string name = "Alice";
    std::string greeting = "Hello, ";
    
    // 문자열 연결
    std::string message = greeting + name;
    std::cout << message << "\n";
    
    // 길이 확인
    std::cout << "메시지 길이: " << message.length() << "\n";
    std::cout << "메시지 길이: " << message.size() << "\n";  // length()와 동일
    
    // 비어있는지 확인
    std::cout << "비어있나요? " << (message.empty() ? "예" : "아니오") << "\n";
    
    return 0;
}
```

**출력 결과:**
```
Hello, Alice
메시지 길이: 12
메시지 길이: 12
비어있나요? 아니오
```

### 8.4.3 문자열 입력
**공백 포함 입력**

`std::cin`은 공백까지만 읽으므로, 공백을 포함한 문자열을 읽으려면 `std::getline()`을 사용한다.

```cpp
#include <iostream>
#include <string>

int main() {
    std::string name;
    std::string address;
    
    std::cout << "이름: ";
    std::cin >> name;  // 공백 전까지만 읽음
    
    std::cin.ignore();  // 입력 버퍼의 개행 문자 제거
    
    std::cout << "주소: ";
    std::getline(std::cin, address);  // 한 줄 전체 읽기
    
    std::cout << "\n입력 정보:\n";
    std::cout << "이름: " << name << "\n";
    std::cout << "주소: " << address << "\n";
    
    return 0;
}
```

**실행 예:**
```
이름: Alice
주소: 123 Main Street
입력 정보:
이름: Alice
주소: 123 Main Street
```

### 8.4.4 문자열 연산

**연결**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string first = "Hello";
    std::string second = "World";
    
    // + 연산자
    std::string result1 = first + " " + second;
    std::cout << result1 << "\n";
    
    // += 연산자
    std::string result2 = first;
    result2 += " ";
    result2 += second;
    std::cout << result2 << "\n";
    
    // append() 함수
    std::string result3 = first;
    result3.append(" ").append(second);
    std::cout << result3 << "\n";
    
    return 0;
}
```

**출력 결과:**
```
Hello World
Hello World
Hello World
```

**비교**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str1 = "apple";
    std::string str2 = "banana";
    std::string str3 = "apple";
    
    // == 연산자
    std::cout << (str1 == str3 ? "같음" : "다름") << "\n";
    std::cout << (str1 == str2 ? "같음" : "다름") << "\n";
    
    // 사전순 비교
    if (str1 < str2) {
        std::cout << str1 << "이(가) " << str2 << "보다 앞에 있음\n";
    }
    
    return 0;
}
```

**출력 결과:**
```
같음
다름
apple이(가) banana보다 앞에 있음
```

### 8.4.5 문자열 검색

**부분 문자열 찾기**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "The quick brown fox jumps over the lazy dog";
    
    // "fox" 찾기
    size_t pos = text.find("fox");
    
    if (pos != std::string::npos) {
        std::cout << "'fox'를 위치 " << pos << "에서 발견\n";
    } else {
        std::cout << "'fox'를 찾을 수 없음\n";
    }
    
    // 'o' 문자 찾기
    pos = text.find('o');
    std::cout << "첫 번째 'o'의 위치: " << pos << "\n";
    
    // 마지막 'o' 찾기
    pos = text.rfind('o');
    std::cout << "마지막 'o'의 위치: " << pos << "\n";
    
    return 0;
}
```

**출력 결과:**
```
'fox'를 위치 16에서 발견
첫 번째 'o'의 위치: 12
마지막 'o'의 위치: 41
```

`std::string::npos`는 찾지 못했을 때 반환되는 특수한 값이다.

**특정 문자 포함 여부 확인**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string email = "user@example.com";
    
    if (email.find('@') != std::string::npos) {
        std::cout << "유효한 이메일 형식일 수 있음\n";
    } else {
        std::cout << "@ 기호가 없음\n";
    }
    
    return 0;
}
```

### 8.4.6 부분 문자열 추출

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "Hello, World!";
    
    // 처음 5개 문자
    std::string sub1 = text.substr(0, 5);
    std::cout << sub1 << "\n";
    
    // 7번째 위치부터 끝까지
    std::string sub2 = text.substr(7);
    std::cout << sub2 << "\n";
    
    // 7번째 위치부터 5개 문자
    std::string sub3 = text.substr(7, 5);
    std::cout << sub3 << "\n";
    
    return 0;
}
```

**출력 결과:**
```
Hello
World!
World
```

### 8.4.7 문자열 수정

**특정 위치의 문자 변경**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "Hello";
    
    // 인덱스로 접근
    text[0] = 'h';  // 'H' -> 'h'
    std::cout << text << "\n";
    
    // at() 함수 사용 (범위 검사)
    text.at(4) = '!';  // 'o' -> '!'
    std::cout << text << "\n";
    
    return 0;
}
```

**출력 결과:**
```
hello
hell!
```

**삽입과 삭제**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "Hello World";
    
    // 6번째 위치에 "Beautiful " 삽입
    text.insert(6, "Beautiful ");
    std::cout << text << "\n";
    
    // 6번째 위치부터 10개 문자 삭제
    text.erase(6, 10);
    std::cout << text << "\n";
    
    return 0;
}
```

**출력 결과:**
```
Hello Beautiful World
Hello World
```

**치환**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "I like cats";
    
    // "cats"를 "dogs"로 변경
    size_t pos = text.find("cats");
    if (pos != std::string::npos) {
        text.replace(pos, 4, "dogs");
    }
    
    std::cout << text << "\n";
    
    return 0;
}
```

**출력 결과:**
```
I like dogs
```

### 8.4.8 문자열과 숫자 변환

**문자열 → 숫자**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string num_str1 = "42";
    std::string num_str2 = "3.14159";
    
    // 문자열을 정수로
    int num1 = std::stoi(num_str1);
    std::cout << "정수: " << num1 << "\n";
    
    // 문자열을 실수로
    double num2 = std::stod(num_str2);
    std::cout << "실수: " << num2 << "\n";
    
    // 계산에 사용
    std::cout << "합: " << num1 + num2 << "\n";
    
    return 0;
}
```

**출력 결과:**
```
정수: 42
실수: 3.14159
합: 45.1416
```

주요 변환 함수는 다음과 같다.

- `std::stoi()`: 문자열 → int
- `std::stol()`: 문자열 → long
- `std::stoll()`: 문자열 → long long
- `std::stof()`: 문자열 → float
- `std::stod()`: 문자열 → double

**숫자 → 문자열**

```cpp
#include <iostream>
#include <string>

int main() {
    int num1 = 42;
    double num2 = 3.14159;
    
    // 숫자를 문자열로
    std::string str1 = std::to_string(num1);
    std::string str2 = std::to_string(num2);
    
    std::cout << "정수 문자열: " << str1 << "\n";
    std::cout << "실수 문자열: " << str2 << "\n";
    
    // 문자열 연결
    std::string result = "값: " + str1 + ", " + str2;
    std::cout << result << "\n";
    
    return 0;
}
```

**출력 결과:**
```
정수 문자열: 42
실수 문자열: 3.141590
값: 42, 3.141590
```

### 8.4.9 문자열 실용 예제

**단어 개수 세기**

```cpp
#include <iostream>
#include <string>
#include <sstream>

int main() {
    std::string text;
    
    std::cout << "문장을 입력하세요: ";
    std::getline(std::cin, text);
    
    std::istringstream iss(text);
    std::string word;
    int count = 0;
    
    while (iss >> word) {
        ++count;
    }
    
    std::cout << "단어 개수: " << count << "\n";
    
    return 0;
}
```

**실행 예:**
```
문장을 입력하세요: The quick brown fox
단어 개수: 4
```

**특정 문자 모두 제거**

```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string text = "H-e-l-l-o W-o-r-l-d";
    
    std::cout << "원본: " << text << "\n";
    
    // '-' 문자 모두 제거
    text.erase(std::remove(text.begin(), text.end(), '-'), text.end());
    
    std::cout << "결과: " << text << "\n";
    
    return 0;
}
```

**출력 결과:**
```
원본: H-e-l-l-o W-o-r-l-d
결과: Hello World
```

**대소문자 변환**

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

int main() {
    std::string text = "Hello World";
    
    // 대문자로 변환
    std::string upper = text;
    std::transform(upper.begin(), upper.end(), upper.begin(), 
                   [](unsigned char c) { return std::toupper(c); });
    std::cout << "대문자: " << upper << "\n";
    
    // 소문자로 변환
    std::string lower = text;
    std::transform(lower.begin(), lower.end(), lower.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    std::cout << "소문자: " << lower << "\n";
    
    return 0;
}
```

**출력 결과:**
```
대문자: HELLO WORLD
소문자: hello world
```
   

</br>  
</br>  
  

## 8.5 Range-based for loop 활용
범위 기반 `for` 문은 Modern C++의 핵심 기능 중 하나다. 배열, 벡터, 문자열 등 모든 컨테이너를 일관된 방식으로 순회할 수 있다.

### 8.5.1 기본 문법 복습

```cpp
for (요소_타입 변수명 : 컨테이너) {
    // 변수 사용
}
```

실제 사용 예는 다음과 같다.

```cpp
#include <iostream>
#include <vector>
#include <string>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 값 복사 (읽기 전용, 원본 변경 안됨)
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    // 참조 (원본 수정 가능)
    for (int& num : numbers) {
        num *= 2;
    }
    
    // const 참조 (읽기 전용, 복사 없음)
    for (const int& num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 4 5
2 4 6 8 10
```

### 8.5.2 `auto` 키워드와 함께 사용
`auto` 키워드를 사용하면 타입을 자동으로 추론하므로 코드가 더 간결해진다.

```cpp
#include <iostream>
#include <vector>
#include <string>

int main() {
    std::vector<std::string> fruits = {"사과", "바나나", "오렌지"};
    
    // auto로 타입 자동 추론
    for (const auto& fruit : fruits) {
        std::cout << fruit << "\n";
    }
    
    return 0;
}
```

권장 사용 패턴은 다음과 같다.

- **읽기만 할 때**: `for (const auto& item : container)`
- **수정이 필요할 때**: `for (auto& item : container)`
- **복사가 저렴한 타입** (int, char 등): `for (auto item : container)`

### 8.5.3 문자열 순회
문자열의 각 문자를 순회할 수 있다.

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "Hello";
    
    // 각 문자 출력
    for (char ch : text) {
        std::cout << ch << " ";
    }
    std::cout << "\n";
    
    // 대문자로 변환
    for (char& ch : text) {
        if (ch >= 'a' && ch <= 'z') {
            ch = ch - 'a' + 'A';
        }
    }
    
    std::cout << text << "\n";
    
    return 0;
}
```

**출력 결과:**
```
H e l l o
HELLO
```

### 8.5.4 중첩 범위 기반 `for` 문
2차원 컨테이너도 깔끔하게 순회할 수 있다.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<std::vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    // 모든 요소 출력
    for (const auto& row : matrix) {
        for (const auto& value : row) {
            std::cout << value << " ";
        }
        std::cout << "\n";
    }
    
    // 모든 요소를 2배로
    for (auto& row : matrix) {
        for (auto& value : row) {
            value *= 2;
        }
    }
    
    std::cout << "\n2배 후:\n";
    for (const auto& row : matrix) {
        for (const auto& value : row) {
            std::cout << value << " ";
        }
        std::cout << "\n";
    }
    
    return 0;
}
```

**출력 결과:**
```
1 2 3
4 5 6
7 8 9

2배 후:
2 4 6
8 10 12
14 16 18
```

### 8.5.5 인덱스가 필요한 경우
범위 기반 `for` 문에서는 인덱스를 직접 얻을 수 없다. 인덱스가 필요하다면 전통적인 `for` 문을 사용하거나, 별도로 카운터를 유지한다.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<std::string> names = {"Alice", "Bob", "Charlie"};
    
    // 방법 1: 전통적인 for 문
    for (size_t i = 0; i < names.size(); ++i) {
        std::cout << i << ": " << names[i] << "\n";
    }
    
    std::cout << "\n";
    
    // 방법 2: 수동 카운터
    size_t index = 0;
    for (const auto& name : names) {
        std::cout << index++ << ": " << name << "\n";
    }
    
    return 0;
}
```

**출력 결과:**
```
0: Alice
1: Bob
2: Charlie

0: Alice
1: Bob
2: Charlie
```

C++20부터는 `std::views::enumerate`를 사용할 수 있다 (심화 내용에서 다룸).
   

</br>  
</br>  
  
  
## 8.6 실습 문제

### 문제 1: 배열 통계
`std::array<int, 10>`에 사용자로부터 10개의 정수를 입력받아 다음을 출력하는 프로그램을 작성하라.

- 최댓값
- 최솟값
- 평균
- 중앙값 (정렬 후 가운데 값)

**요구사항:**
- 범위 기반 `for` 문 사용
- `std::sort` 사용 가능

### 문제 2: 동적 쇼핑 목록
`std::vector<std::string>`을 사용하여 쇼핑 목록 관리 프로그램을 작성하라.

**기능:**
1. 항목 추가
2. 항목 삭제 (이름으로)
3. 전체 목록 출력
4. 종료

**요구사항:**
- 메뉴 기반 인터페이스
- `do-while` 문 사용
- 범위 기반 `for` 문으로 목록 출력

### 문제 3: 회문 검사
사용자로부터 문자열을 입력받아 회문(앞뒤가 같은 문자열, 예: "level", "noon")인지 판별하는 프로그램을 작성하라.

**요구사항:**
- 대소문자 구분하지 않음
- 공백 무시
- `std::string` 사용

**예상 출력:**
```
문자열 입력: A man a plan a canal Panama
회문입니다!

문자열 입력: Hello
회문이 아닙니다.
```

### 문제 4: 단어 빈도수
사용자로부터 여러 줄의 텍스트를 입력받아 (빈 줄 입력 시 종료), 각 단어가 몇 번 나타났는지 세는 프로그램을 작성하라.

**힌트:**
- `std::vector<std::string>`에 단어 저장
- 중복 확인하여 카운트
- Chapter 12에서 배울 `std::map`을 사용하면 더 쉽지만, 지금은 벡터만 사용

**예상 출력:**
```
텍스트 입력 (빈 줄로 종료):
the quick brown fox
jumps over the lazy dog

=== 단어 빈도 ===
the: 2
quick: 1
brown: 1
fox: 1
jumps: 1
over: 1
lazy: 1
dog: 1
```

### 문제 5: 성적 등급 분류
`std::vector<int>`에 학생들의 점수를 저장하고, 각 등급(A, B, C, D, F)별로 몇 명인지 세는 프로그램을 작성하라.

**등급 기준:**
- A: 90 이상
- B: 80-89
- C: 70-79
- D: 60-69
- F: 60 미만

**요구사항:**
- 점수는 사용자 입력 (음수 입력 시 종료)
- `std::array<int, 5>`에 각 등급별 인원 저장
  

</br>  
</br>   


## 8.7 심화 내용

### 8.7.1 벡터의 메모리 관리 최적화
벡터는 동적으로 메모리를 할당하므로, 메모리 관리를 이해하면 성능을 최적화할 수 있다.

**emplace_back vs push_back**

`emplace_back()`은 객체를 직접 생성하므로 불필요한 복사를 피할 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <string>

struct Person {
    std::string name;
    int age;
    
    Person(std::string n, int a) : name(n), age(a) {
        std::cout << "Person 생성: " << name << "\n";
    }
    
    Person(const Person& other) : name(other.name), age(other.age) {
        std::cout << "Person 복사: " << name << "\n";
    }
};

int main() {
    std::vector<Person> people;
    
    std::cout << "=== push_back 사용 ===\n";
    people.push_back(Person("Alice", 25));
    
    std::cout << "\n=== emplace_back 사용 ===\n";
    people.emplace_back("Bob", 30);
    
    return 0;
}
```

**출력 결과:**
```
=== push_back 사용 ===
Person 생성: Alice
Person 복사: Alice

=== emplace_back 사용 ===
Person 생성: Bob
```

`emplace_back()`을 사용하면 복사가 발생하지 않는다.

**shrink_to_fit으로 메모리 최적화**

벡터에서 많은 요소를 삭제한 후 불필요한 용량을 해제할 수 있다.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers;
    
    // 1000개 요소 추가
    for (int i = 0; i < 1000; ++i) {
        numbers.push_back(i);
    }
    
    std::cout << "추가 후 - 크기: " << numbers.size() 
              << ", 용량: " << numbers.capacity() << "\n";
    
    // 대부분 삭제
    numbers.resize(10);
    
    std::cout << "삭제 후 - 크기: " << numbers.size() 
              << ", 용량: " << numbers.capacity() << "\n";
    
    // 불필요한 용량 해제
    numbers.shrink_to_fit();
    
    std::cout << "최적화 후 - 크기: " << numbers.size() 
              << ", 용량: " << numbers.capacity() << "\n";
    
    return 0;
}
```

**출력 결과 (구현에 따라 다를 수 있음):**
```
추가 후 - 크기: 1000, 용량: 1024
삭제 후 - 크기: 10, 용량: 1024
최적화 후 - 크기: 10, 용량: 10
```

### 8.7.2 C++20/23의 새로운 문자열 기능
**starts_with와 ends_with (C++20)**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string filename = "document.txt";
    
    if (filename.ends_with(".txt")) {
        std::cout << "텍스트 파일입니다.\n";
    }
    
    if (filename.starts_with("doc")) {
        std::cout << "문서 파일입니다.\n";
    }
    
    return 0;
}
```

**contains (C++23)**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "The quick brown fox";
    
    if (text.contains("quick")) {
        std::cout << "'quick'을 포함합니다.\n";
    }
    
    return 0;
}
```

### 8.7.3 std::string_view (C++17)
`std::string_view`는 문자열의 복사 없이 읽기 전용 뷰를 제공한다. 성능이 중요한 경우 유용하다.

```cpp
#include <iostream>
#include <string>
#include <string_view>

void print_first_word(std::string_view text) {
    size_t pos = text.find(' ');
    
    if (pos != std::string_view::npos) {
        std::cout << text.substr(0, pos) << "\n";
    } else {
        std::cout << text << "\n";
    }
}

int main() {
    std::string long_text = "Hello World from C++";
    
    // 복사 없이 문자열 전달
    print_first_word(long_text);
    
    // 문자열 리터럴도 직접 전달 가능
    print_first_word("Quick brown fox");
    
    return 0;
}
```

**출력 결과:**
```
Hello
Quick
```

`std::string_view`는 소유권이 없으므로 원본 문자열의 수명에 주의해야 한다.

### 8.7.4 C++20 Ranges와 Views
Ranges 라이브러리를 사용하면 더 선언적으로 컨테이너를 다룰 수 있다.

**enumerate로 인덱스와 값 함께 순회**

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<std::string> names = {"Alice", "Bob", "Charlie"};
    
    // C++23
    for (auto [index, name] : std::views::enumerate(names)) {
        std::cout << index << ": " << name << "\n";
    }
    
    return 0;
}
```

**filter와 transform**

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 짝수만 필터링하고 제곱
    auto result = numbers
        | std::views::filter([](int n) { return n % 2 == 0; })
        | std::views::transform([](int n) { return n * n; });
    
    for (int value : result) {
        std::cout << value << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
4 16 36 64 100
```

### 8.7.5 문자열 포맷팅 (C++20)
`std::format`은 타입 안전한 문자열 포맷팅을 제공한다.

```cpp
#include <iostream>
#include <format>
#include <string>

int main() {
    std::string name = "Alice";
    int age = 25;
    double height = 165.5;
    
    // 포맷팅된 문자열 생성
    std::string message = std::format("이름: {}, 나이: {}, 키: {:.1f}cm", 
                                       name, age, height);
    std::cout << message << "\n";
    
    // 직접 출력 (C++23)
    std::println("점수: {0}, 등급: {1}", 95, 'A');
    
    return 0;
}
```

**출력 결과:**
```
이름: Alice, 나이: 25, 키: 165.5cm
점수: 95, 등급: A
```

## 정리
이번 장에서는 Modern C++의 안전하고 강력한 컨테이너들을 배웠다.

- **C 스타일 배열**은 빠르지만 안전하지 않다. 경계 검사가 없고 크기 정보가 손실되며 사용하기 불편하다.

- **`std::array`**는 고정 크기 배열을 안전하게 다룰 수 있다. 크기 정보를 유지하고, 복사와 비교가 가능하며, STL 알고리즘과 잘 작동한다.

- **`std::vector`**는 동적 배열로 가장 많이 사용되는 컨테이너다. 실행 중 크기를 자유롭게 조정할 수 있으며, 자동 메모리 관리를 제공한다.

- **`std::string`**은 안전한 문자열 처리를 가능하게 한다. 다양한 연산과 검색, 변환 기능을 제공하며, C 스타일 문자열의 모든 문제를 해결한다.

- **범위 기반 `for` 문**은 컨테이너 순회를 간결하고 안전하게 만든다. `auto` 키워드와 함께 사용하면 타입에 구애받지 않는 깔끔한 코드를 작성할 수 있다.

Modern C++을 사용하면 배열과 문자열을 다룰 때 안전성, 편의성, 성능을 모두 얻을 수 있다. C 스타일의 위험한 방식 대신 `std::array`, `std::vector`, `std::string`을 사용하는 습관을 들이는 것이 중요하다.

다음 장에서는 코드를 재사용 가능한 블록으로 나누는 방법인 함수를 배운다. 특히 Modern C++의 매개변수 전달 방식과 `auto` 반환 타입 등을 살펴본다.

 