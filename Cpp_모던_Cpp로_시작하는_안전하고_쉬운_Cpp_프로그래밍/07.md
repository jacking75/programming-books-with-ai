# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 7: 제어문 - 반복문
프로그래밍에서 같은 작업을 여러 번 반복해야 하는 경우가 매우 많다. 예를 들어 1부터 100까지의 숫자를 모두 더하거나, 사용자가 올바른 입력을 할 때까지 계속 입력을 받거나, 게임에서 모든 적 캐릭터를 화면에 그려야 하는 상황 등이 있다. 이럴 때 반복문(loop)을 사용하면 코드를 간결하게 작성할 수 있다.

이번 장에서는 C++의 세 가지 주요 반복문인 `for`, `while`, `do-while`을 배우고, 반복문을 효과적으로 제어하는 방법을 익힌다. Modern C++의 관점에서 안전하고 읽기 쉬운 반복문 작성법도 함께 살펴본다.

## 7.1 `for` 문의 기본 형태
`for` 문은 반복 횟수가 정해져 있을 때 가장 많이 사용하는 반복문이다. 초기화, 조건 검사, 증감식을 한 줄에 모두 표현할 수 있어 코드의 의도를 명확하게 전달한다.

### 7.1.1 기본 구조

`for` 문의 기본 구조는 다음과 같다.

```cpp
for (초기화; 조건식; 증감식) {
    // 반복할 코드
}
```

각 부분의 역할은 다음과 같다.

- **초기화**: 반복문이 시작될 때 한 번만 실행된다. 보통 카운터 변수를 선언하고 초기값을 설정한다.
- **조건식**: 매 반복마다 확인하는 조건이다. 이 조건이 `true`인 동안 반복이 계속된다.
- **증감식**: 매 반복이 끝날 때마다 실행된다. 보통 카운터 변수를 증가시키거나 감소시킨다.

실행 순서는 다음과 같다.

1. 초기화 실행 (최초 1회)
2. 조건식 확인
3. 조건이 `true`면 반복문 본문 실행
4. 증감식 실행
5. 2번으로 돌아가서 반복

### 7.1.2 간단한 예제

1부터 10까지 출력하는 예제를 살펴보자.

```cpp
#include <iostream>

int main() {
    for (int i = 1; i <= 10; ++i) {
        std::cout << i << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 4 5 6 7 8 9 10
```

이 코드에서 `int i = 1`은 초기화 부분으로, `i`라는 변수를 1로 초기화한다. `i <= 10`은 조건식으로, `i`가 10 이하일 때만 반복한다. `++i`는 증감식으로, 매 반복마다 `i`를 1씩 증가시킨다.

**중요:** Modern C++에서는 증감 연산자를 사용할 때 `++i`(전위 증가)를 `i++`(후위 증가)보다 선호한다. 기본 타입에서는 성능 차이가 거의 없지만, 객체 타입에서는 전위 증가가 더 효율적이기 때문이다. 일관성 있는 코딩 스타일을 위해 `++i`를 습관화하는 것이 좋다.

### 7.1.3 다양한 `for` 문 활용
**역순으로 반복하기**

```cpp
#include <iostream>

int main() {
    for (int i = 10; i >= 1; --i) {
        std::cout << i << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
10 9 8 7 6 5 4 3 2 1
```

**2씩 증가하며 반복하기**

```cpp
#include <iostream>

int main() {
    for (int i = 0; i <= 20; i += 2) {
        std::cout << i << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
0 2 4 6 8 10 12 14 16 18 20
```

**여러 변수를 사용하는 `for` 문**

```cpp
#include <iostream>

int main() {
    for (int i = 0, j = 10; i < j; ++i, --j) {
        std::cout << "i=" << i << ", j=" << j << "\n";
    }
    
    return 0;
}
```

**출력 결과:**
```
i=0, j=10
i=1, j=9
i=2, j=8
i=3, j=7
i=4, j=6
```

### 7.1.4 중첩 `for` 문
`for` 문 안에 또 다른 `for` 문을 넣을 수 있다. 이를 중첩 반복문이라고 한다. 2차원 데이터를 처리하거나 구구단 같은 표를 만들 때 유용하다.

```cpp
#include <iostream>

int main() {
    // 구구단 2단부터 9단까지 출력
    for (int dan = 2; dan <= 9; ++dan) {
        std::cout << "=== " << dan << "단 ===\n";
        for (int num = 1; num <= 9; ++num) {
            std::cout << dan << " × " << num << " = " << dan * num << "\n";
        }
        std::cout << "\n";
    }
    
    return 0;
}
```

**출력 결과 (일부):**
```
=== 2단 ===
2 × 1 = 2
2 × 2 = 4
2 × 3 = 6
...
=== 3단 ===
3 × 1 = 3
3 × 2 = 6
...
```

중첩 반복문을 사용할 때는 안쪽 반복문이 바깥쪽 반복문의 한 번의 반복마다 완전히 실행된다는 점을 이해해야 한다. 위 예제에서 `dan`이 2일 때, `num`은 1부터 9까지 모두 반복한다.

### 7.1.5 범위 기반 `for` 문 (Range-based for loop)
C++11부터 도입된 범위 기반 `for` 문은 컨테이너나 배열의 모든 요소를 순회할 때 매우 편리하다. Modern C++에서 권장하는 방식이다.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {10, 20, 30, 40, 50};
    
    // 범위 기반 for 문
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
10 20 30 40 50
```

범위 기반 `for` 문은 인덱스를 직접 관리할 필요가 없어 코드가 간결하고 오류 가능성이 줄어든다. `auto` 키워드와 함께 사용하면 더욱 편리하다.

```cpp
#include <iostream>
#include <vector>
#include <string>

int main() {
    std::vector<std::string> fruits = {"사과", "바나나", "오렌지"};
    
    // auto 키워드 사용
    for (auto fruit : fruits) {
        std::cout << fruit << "\n";
    }
    
    return 0;
}
```

값을 수정해야 할 때는 참조(`&`)를 사용한다.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 각 요소를 2배로 만들기
    for (auto& num : numbers) {
        num *= 2;
    }
    
    // 결과 출력
    for (auto num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
2 4 6 8 10
```

읽기 전용으로 순회할 때는 `const auto&`를 사용하면 불필요한 복사를 피하면서 안전하게 값을 읽을 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <string>

int main() {
    std::vector<std::string> cities = {"서울", "부산", "대구", "인천"};
    
    // const 참조로 읽기만 하기
    for (const auto& city : cities) {
        std::cout << city << "\n";
    }
    
    return 0;
}
```
  

</br>  
</br>  
  

## 7.2 `while`과 `do-while` 문
`for` 문이 반복 횟수가 정해져 있을 때 적합하다면, `while` 문은 특정 조건이 만족되는 동안 계속 반복해야 할 때 유용하다. 예를 들어 사용자가 올바른 입력을 할 때까지 반복하거나, 파일의 끝에 도달할 때까지 읽는 경우에 사용한다.

### 7.2.1 `while` 문의 기본 구조
`while` 문의 구조는 `for` 문보다 단순하다.

```cpp
while (조건식) {
    // 반복할 코드
}
```

조건식이 `true`인 동안 반복문 본문을 계속 실행한다. 조건식은 반복문에 진입하기 전과 매 반복이 끝날 때마다 확인된다.

**간단한 예제:**

```cpp
#include <iostream>

int main() {
    int count = 1;
    
    while (count <= 5) {
        std::cout << "반복 " << count << "회\n";
        ++count;
    }
    
    return 0;
}
```

**출력 결과:**
```
반복 1회
반복 2회
반복 3회
반복 4회
반복 5회
```

`while` 문에서는 초기화와 증감을 별도로 처리해야 한다. `count` 변수를 `while` 문 전에 초기화하고, 반복문 내부에서 증가시킨다.

### 7.2.2 `while` 문의 실용적 예제
**사용자 입력 검증**

```cpp
#include <iostream>

int main() {
    int age = 0;
    
    std::cout << "나이를 입력하세요 (1-120): ";
    std::cin >> age;
    
    while (age < 1 || age > 120) {
        std::cout << "올바른 나이를 입력하세요 (1-120): ";
        std::cin >> age;
    }
    
    std::cout << "입력된 나이: " << age << "\n";
    
    return 0;
}
```

이 예제는 사용자가 올바른 범위의 나이를 입력할 때까지 반복해서 입력을 요청한다. 이런 패턴은 사용자 인터페이스에서 매우 자주 사용된다.

**숫자 맞추기 게임**

```cpp
#include <iostream>

int main() {
    int secret = 42;
    int guess = 0;
    
    std::cout << "1부터 100 사이의 숫자를 맞춰보세요!\n";
    
    while (guess != secret) {
        std::cout << "숫자를 입력하세요: ";
        std::cin >> guess;
        
        if (guess < secret) {
            std::cout << "더 큰 숫자입니다.\n";
        } else if (guess > secret) {
            std::cout << "더 작은 숫자입니다.\n";
        } else {
            std::cout << "정답입니다!\n";
        }
    }
    
    return 0;
}
```

### 7.2.3 `do-while` 문
`do-while` 문은 `while` 문과 비슷하지만, 조건 검사를 반복문 끝에서 한다는 차이가 있다. 따라서 최소한 한 번은 반드시 실행된다.

**구조:**

```cpp
do {
    // 반복할 코드
} while (조건식);
```

**예제:**

```cpp
#include <iostream>

int main() {
    int number = 0;
    
    do {
        std::cout << "양수를 입력하세요: ";
        std::cin >> number;
    } while (number <= 0);
    
    std::cout << "입력된 값: " << number << "\n";
    
    return 0;
}
```

이 코드는 사용자가 양수를 입력할 때까지 계속 입력을 요청한다. `do-while` 문을 사용하면 최소한 한 번은 입력을 받게 되므로, 메뉴 선택이나 게임의 재시작 여부 같은 경우에 적합하다.

**메뉴 시스템 예제:**

```cpp
#include <iostream>

int main() {
    int choice = 0;
    
    do {
        std::cout << "\n=== 메뉴 ===\n";
        std::cout << "1. 새 게임\n";
        std::cout << "2. 이어하기\n";
        std::cout << "3. 설정\n";
        std::cout << "4. 종료\n";
        std::cout << "선택: ";
        std::cin >> choice;
        
        switch (choice) {
            case 1:
                std::cout << "새 게임을 시작합니다.\n";
                break;
            case 2:
                std::cout << "저장된 게임을 불러옵니다.\n";
                break;
            case 3:
                std::cout << "설정 화면입니다.\n";
                break;
            case 4:
                std::cout << "게임을 종료합니다.\n";
                break;
            default:
                std::cout << "올바른 번호를 입력하세요.\n";
        }
    } while (choice != 4);
    
    return 0;
}
```

### 7.2.4 `for` vs `while` 선택 기준
언제 `for` 문을 쓰고 언제 `while` 문을 써야 할까? 일반적인 지침은 다음과 같다.

- **`for` 문**: 반복 횟수가 명확할 때 (예: 10번 반복, 배열의 모든 요소 순회)
- **`while` 문**: 조건에 따라 반복 횟수가 결정될 때 (예: 사용자 입력 검증, 파일 읽기)
- **`do-while` 문**: 최소 한 번은 실행해야 할 때 (예: 메뉴 표시, 초기 입력 받기)

하지만 이는 절대적인 규칙이 아니며, 상황에 따라 가장 읽기 쉽고 의도가 명확한 방식을 선택하면 된다.
  

</br>  
</br>  
  

## 7.3 `break`와 `continue` 키워드
때로는 반복문을 중간에 완전히 종료하거나, 현재 반복만 건너뛰고 다음 반복으로 넘어가야 할 때가 있다. 이럴 때 `break`와 `continue` 키워드를 사용한다.

### 7.3.1 `break` - 반복문 탈출
`break` 문은 반복문을 즉시 종료하고 반복문 다음 문장으로 제어를 이동시킨다.

```cpp
#include <iostream>

int main() {
    // 1부터 시작해서 제곱수를 출력하되, 100을 넘으면 중단
    for (int i = 1; i <= 100; ++i) {
        int square = i * i;
        
        if (square > 100) {
            break;  // 반복문 종료
        }
        
        std::cout << i << "의 제곱: " << square << "\n";
    }
    
    std::cout << "반복문 종료\n";
    
    return 0;
}
```

**출력 결과:**
```
1의 제곱: 1
2의 제곱: 4
3의 제곱: 9
4의 제곱: 16
5의 제곱: 25
6의 제곱: 36
7의 제곱: 49
8의 제곱: 64
9의 제곱: 81
10의 제곱: 100
반복문 종료
```

11의 제곱은 121로 100을 넘기 때문에, `break` 문이 실행되어 반복문이 종료된다.

**실용적 예제: 특정 값 찾기**

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {3, 7, 12, 5, 18, 9, 21};
    int target = 18;
    bool found = false;
    
    for (int i = 0; i < numbers.size(); ++i) {
        if (numbers[i] == target) {
            std::cout << "값 " << target << "을(를) 인덱스 " << i << "에서 발견\n";
            found = true;
            break;  // 찾았으므로 더 이상 검색할 필요 없음
        }
    }
    
    if (!found) {
        std::cout << "값을 찾지 못했습니다.\n";
    }
    
    return 0;
}
```

**출력 결과:**
```
값 18을(를) 인덱스 4에서 발견
```

### 7.3.2 `continue` - 현재 반복 건너뛰기
`continue` 문은 현재 반복의 나머지 부분을 건너뛰고 다음 반복으로 즉시 이동한다. `for` 문에서는 증감식으로 이동하고, `while` 문에서는 조건식으로 이동한다.

```cpp
#include <iostream>

int main() {
    // 1부터 10까지 출력하되, 5는 건너뛰기
    for (int i = 1; i <= 10; ++i) {
        if (i == 5) {
            continue;  // 5일 때는 출력하지 않고 다음 반복으로
        }
        
        std::cout << i << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 4 6 7 8 9 10
```

5가 출력되지 않았다. `i`가 5일 때 `continue` 문이 실행되어 `std::cout` 문을 건너뛰고 바로 `++i`로 이동했기 때문이다.

**홀수만 출력하기**

```cpp
#include <iostream>

int main() {
    // 1부터 20까지 중 홀수만 출력
    for (int i = 1; i <= 20; ++i) {
        if (i % 2 == 0) {
            continue;  // 짝수는 건너뛰기
        }
        
        std::cout << i << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
1 3 5 7 9 11 13 15 17 19
```

### 7.3.3 중첩 반복문에서의 `break`와 `continue`
중첩 반복문에서 `break`나 `continue`를 사용할 때는 주의가 필요하다. 이들은 가장 안쪽의 반복문에만 영향을 준다.

```cpp
#include <iostream>

int main() {
    for (int i = 1; i <= 3; ++i) {
        std::cout << "외부 반복 " << i << "\n";
        
        for (int j = 1; j <= 5; ++j) {
            if (j == 3) {
                break;  // 안쪽 for 문만 종료
            }
            std::cout << "  내부 반복 " << j << "\n";
        }
    }
    
    return 0;
}
```

**출력 결과:**
```
외부 반복 1
  내부 반복 1
  내부 반복 2
외부 반복 2
  내부 반복 1
  내부 반복 2
외부 반복 3
  내부 반복 1
  내부 반복 2
```

안쪽 반복문에서 `j`가 3이 되면 `break`가 실행되지만, 바깥쪽 반복문은 계속 실행된다.

바깥쪽 반복문까지 종료하고 싶다면 플래그 변수를 사용할 수 있다.

```cpp
#include <iostream>

int main() {
    bool should_exit = false;
    
    for (int i = 1; i <= 5 && !should_exit; ++i) {
        for (int j = 1; j <= 5; ++j) {
            if (i * j > 10) {
                should_exit = true;
                break;
            }
            std::cout << i << " × " << j << " = " << i * j << "\n";
        }
    }
    
    std::cout << "반복문 종료\n";
    
    return 0;
}
```
  

</br>  
</br>  
    
  
## 7.4 무한 루프와 루프 제어
무한 루프는 종료 조건이 없거나 종료 조건이 절대 만족되지 않는 반복문이다. 무한 루프는 보통 의도하지 않은 버그로 발생하지만, 때로는 의도적으로 사용하기도 한다.

### 7.4.1 의도하지 않은 무한 루프
가장 흔한 무한 루프 버그는 증감식을 빠뜨리는 경우다.

```cpp
// 잘못된 코드 - 무한 루프!
#include <iostream>

int main() {
    int i = 0;
    
    while (i < 10) {
        std::cout << i << "\n";
        // i를 증가시키는 것을 잊어버림!
    }
    
    return 0;
}
```

이 코드는 `i`가 항상 0이므로 조건 `i < 10`이 계속 `true`가 되어 무한히 반복한다. 이런 실수를 방지하려면 `for` 문을 사용하거나, `while` 문에서는 증감식을 반드시 포함시켜야 한다.

**또 다른 예: 잘못된 조건식**

```cpp
// 잘못된 코드 - 무한 루프!
#include <iostream>

int main() {
    for (int i = 10; i >= 0; ++i) {  // i는 계속 증가하므로 0 이상
        std::cout << i << "\n";
    }
    
    return 0;
}
```

`i`를 10에서 시작해서 계속 증가시키는데, 조건은 `i >= 0`이다. `i`는 절대 0보다 작아지지 않으므로 무한 루프가 된다. 정확한 코드는 `--i`를 사용해야 한다.

### 7.4.2 의도적인 무한 루프
서버 프로그램이나 게임 메인 루프처럼, 프로그램이 종료될 때까지 계속 실행되어야 하는 경우가 있다. 이럴 때는 의도적으로 무한 루프를 만들고, 특정 조건에서 `break`로 빠져나오도록 한다.

**방법 1: `while (true)`**

```cpp
#include <iostream>

int main() {
    int count = 0;
    
    while (true) {
        std::cout << "반복 " << ++count << "회\n";
        
        if (count >= 5) {
            std::cout << "종료 조건 만족\n";
            break;
        }
    }
    
    std::cout << "프로그램 종료\n";
    
    return 0;
}
```

**방법 2: `for (;;)`**

```cpp
#include <iostream>

int main() {
    int count = 0;
    
    for (;;) {  // 초기화, 조건, 증감 모두 생략
        std::cout << "반복 " << ++count << "회\n";
        
        if (count >= 5) {
            break;
        }
    }
    
    return 0;
}
```

두 방식 모두 동일하게 작동하지만, `while (true)`가 의도를 더 명확하게 표현하므로 Modern C++에서 선호된다.

**실용적 예제: 게임 메인 루프**

```cpp
#include <iostream>

int main() {
    bool game_running = true;
    int score = 0;
    
    while (game_running) {
        std::cout << "\n현재 점수: " << score << "\n";
        std::cout << "1. 게임 플레이 (+10점)\n";
        std::cout << "2. 게임 종료\n";
        std::cout << "선택: ";
        
        int choice = 0;
        std::cin >> choice;
        
        switch (choice) {
            case 1:
                score += 10;
                std::cout << "플레이 완료! 점수 획득\n";
                break;
            case 2:
                game_running = false;
                std::cout << "게임을 종료합니다.\n";
                break;
            default:
                std::cout << "올바른 선택을 하세요.\n";
        }
    }
    
    std::cout << "최종 점수: " << score << "\n";
    
    return 0;
}
```

### 7.4.3 무한 루프 디버깅
무한 루프에 빠졌을 때는 프로그램이 응답하지 않는다. 이럴 때는 다음과 같은 방법으로 디버깅할 수 있다.

**Visual Studio 2022에서:**

1. **일시 중지**: 프로그램 실행 중 `디버그 > 모두 중단` (Ctrl+Alt+Break)을 선택한다.
2. **중단점 설정**: 의심되는 반복문에 중단점을 설정하고, 변수 값이 어떻게 변하는지 관찰한다.
3. **조사식 추가**: 반복문의 조건식에 사용되는 변수들을 조사식 창에 추가해서 값을 확인한다.

**코드에 안전장치 추가:**

개발 중에는 무한 루프를 방지하기 위해 최대 반복 횟수를 설정할 수 있다.

```cpp
#include <iostream>

int main() {
    int count = 0;
    const int MAX_ITERATIONS = 1000;  // 안전장치
    
    while (true) {
        std::cout << "반복 중...\n";
        
        if (++count >= MAX_ITERATIONS) {
            std::cout << "경고: 최대 반복 횟수 도달!\n";
            break;
        }
        
        // 실제 종료 조건 (버그가 있을 수 있음)
        // if (some_condition) break;
    }
    
    return 0;
}
```
  
   
</br>  
</br>  
  
  
## 7.5 실습 문제

### 문제 1: 팩토리얼 계산
사용자로부터 정수 n을 입력받아 n! (n 팩토리얼)을 계산하는 프로그램을 작성하라. 예를 들어 5! = 5 × 4 × 3 × 2 × 1 = 120이다.

**요구사항:**
- `for` 문을 사용할 것
- 결과가 `long long` 타입을 넘지 않도록 n은 1~20 사이로 제한할 것
- 잘못된 입력에 대해서는 재입력을 요청할 것

**예상 출력:**
```
팩토리얼을 계산할 숫자를 입력하세요 (1-20): 5
5! = 120
```

### 문제 2: 피보나치 수열
피보나치 수열의 첫 n개 항을 출력하는 프로그램을 작성하라. 피보나치 수열은 첫 두 항이 0과 1이고, 그 다음 항부터는 바로 앞 두 항의 합으로 정의된다.

**요구사항:**
- `while` 문 또는 `for` 문 사용
- n은 1~50 사이로 제한
- 각 항을 한 줄에 하나씩 출력

**예상 출력 (n=10일 때):**
```
피보나치 수열의 항 개수를 입력하세요: 10
0
1
1
2
3
5
8
13
21
34
```

### 문제 3: 소수 판별
사용자로부터 정수를 입력받아 해당 숫자가 소수인지 판별하는 프로그램을 작성하라. 소수는 1과 자기 자신으로만 나누어떨어지는 1보다 큰 자연수다.

**요구사항:**
- 2부터 n-1까지 나누어떨어지는 수가 있는지 확인
- 최적화: √n까지만 확인해도 충분 (선택사항)
- 나누어떨어지는 수를 발견하면 즉시 반복문 종료 (`break` 사용)

**예상 출력:**
```
숫자를 입력하세요: 17
17은(는) 소수입니다.

숫자를 입력하세요: 24
24은(는) 소수가 아닙니다.
```

### 문제 4: 구구단 출력기
사용자가 원하는 단의 구구단을 반복해서 출력하는 프로그램을 작성하라. 사용자가 0을 입력하면 프로그램이 종료된다.

**요구사항:**
- `do-while` 문 또는 무한 루프 사용
- 2~9단만 유효하며, 잘못된 입력은 다시 요청
- 0을 입력하면 프로그램 종료

**예상 출력:**
```
구구단 몇 단을 출력할까요? (0: 종료): 3
3 × 1 = 3
3 × 2 = 6
...
3 × 9 = 27

구구단 몇 단을 출력할까요? (0: 종료): 0
프로그램을 종료합니다.
```

### 문제 5: 별 찍기 패턴
중첩 반복문을 사용하여 다음과 같은 패턴을 출력하라.

```
*
**
***
****
*****
```

**추가 도전:**
역삼각형 패턴도 만들어보라.

```
*****
****
***
**
*
```
  

</br>  
</br>  
  
  
## 7.6 심화 내용

### 7.6.1 반복문 성능 최적화
반복문은 프로그램에서 가장 많이 실행되는 부분이므로, 작은 최적화도 큰 성능 향상을 가져올 수 있다.

**루프 불변 코드 이동 (Loop-Invariant Code Motion)**

반복문 내에서 매번 같은 값을 계산한다면, 반복문 밖으로 이동시킨다.

```cpp
// 비효율적
for (int i = 0; i < 1000; ++i) {
    int size = vec.size();  // 매 반복마다 size() 호출
    if (i < size) {
        // ...
    }
}

// 효율적
int size = vec.size();  // 한 번만 호출
for (int i = 0; i < 1000; ++i) {
    if (i < size) {
        // ...
    }
}
```

**범위 기반 for 문의 성능**

범위 기반 `for` 문은 컴파일러가 최적화하기 쉬운 형태이므로, 가능하면 사용하는 것이 좋다.

```cpp
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 좋은 방법 - 범위 기반 for
    int sum = 0;
    for (const auto& num : numbers) {
        sum += num;
    }
    
    return 0;
}
```

### 7.6.2 C++20 Ranges와 반복문
C++20부터는 Ranges 라이브러리를 통해 더 선언적인 방식으로 반복 작업을 표현할 수 있다. 이는 Part 3에서 자세히 다루지만, 간단한 예제를 살펴보자.

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 짝수만 필터링하고 2배로 변환
    auto even_doubled = numbers 
        | std::views::filter([](int n) { return n % 2 == 0; })
        | std::views::transform([](int n) { return n * 2; });
    
    for (int num : even_doubled) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
4 8 12 16 20
```

이 방식은 전통적인 반복문보다 의도를 더 명확하게 표현하며, 지연 평가(lazy evaluation)를 통해 효율적이다.

### 7.6.3 반복문과 알고리즘
때로는 직접 반복문을 작성하는 것보다 표준 라이브러리의 알고리즘을 사용하는 것이 더 좋다. 코드가 간결해지고 의도가 명확해지며, 최적화도 잘 되어 있다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 합계 구하기 - 반복문 대신 std::accumulate
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    std::cout << "합계: " << sum << "\n";
    
    // 최댓값 찾기 - 반복문 대신 std::max_element
    auto max_it = std::max_element(numbers.begin(), numbers.end());
    std::cout << "최댓값: " << *max_it << "\n";
    
    // 조건을 만족하는 요소 개수 - 반복문 대신 std::count_if
    int even_count = std::count_if(numbers.begin(), numbers.end(),
                                    [](int n) { return n % 2 == 0; });
    std::cout << "짝수 개수: " << even_count << "\n";
    
    return 0;
}
```

**출력 결과:**
```
합계: 15
최댓값: 5
짝수 개수: 2
```

이런 알고리즘들은 Chapter 12에서 자세히 다룬다.

### 7.6.4 반복문 작성 시 주의사항
**1. 오프바이원 에러 (Off-by-One Error)**

가장 흔한 반복문 버그는 반복 횟수를 하나 많거나 적게 설정하는 것이다.

```cpp
// 잘못된 예: 마지막 요소를 처리하지 못함
for (int i = 0; i < vec.size() - 1; ++i) {  // 주의!
    std::cout << vec[i] << "\n";
}

// 올바른 예
for (int i = 0; i < vec.size(); ++i) {
    std::cout << vec[i] << "\n";
}

// 더 좋은 예: 범위 기반 for
for (const auto& item : vec) {
    std::cout << item << "\n";
}
```

**2. 부호 있는/없는 정수 비교**

`std::vector::size()`는 `size_t` 타입(부호 없는 정수)을 반환하므로, 부호 있는 정수와 비교할 때 주의해야 한다.

```cpp
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3};
    
    // 경고가 발생할 수 있음: signed/unsigned 비교
    for (int i = 0; i < vec.size(); ++i) {
        // ...
    }
    
    // 더 안전한 방법
    for (size_t i = 0; i < vec.size(); ++i) {
        // ...
    }
    
    // 또는 범위 기반 for 사용
    for (const auto& item : vec) {
        // ...
    }
    
    return 0;
}
```

**3. 반복 중 컨테이너 수정**

반복문을 돌면서 컨테이너의 크기를 변경하면 예기치 않은 동작이 발생할 수 있다.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // 위험: 반복 중 크기 변경
    for (size_t i = 0; i < vec.size(); ++i) {
        if (vec[i] % 2 == 0) {
            vec.push_back(vec[i] * 2);  // 벡터 크기 증가!
        }
    }
    
    // 안전한 방법: 미리 크기를 저장
    size_t original_size = vec.size();
    for (size_t i = 0; i < original_size; ++i) {
        if (vec[i] % 2 == 0) {
            vec.push_back(vec[i] * 2);
        }
    }
    
    return 0;
}
```
  

</br>  
</br>  
  

## 정리
이번 장에서는 C++의 세 가지 주요 반복문인 `for`, `while`, `do-while`을 배웠다. 각각의 용도와 특징을 정리하면 다음과 같다.

- **`for` 문**: 반복 횟수가 명확할 때 사용하며, 초기화, 조건, 증감을 한 곳에 모아 코드의 의도를 명확하게 한다.
- **범위 기반 `for` 문**: 컨테이너의 모든 요소를 순회할 때 가장 안전하고 간결한 방법이다.
- **`while` 문**: 조건이 만족되는 동안 반복하며, 반복 횟수가 미리 정해지지 않았을 때 적합하다.
- **`do-while` 문**: 최소한 한 번은 실행되어야 할 때 사용한다.

`break`와 `continue` 키워드를 통해 반복문의 흐름을 세밀하게 제어할 수 있으며, 무한 루프는 주로 버그이지만 때로는 의도적으로 사용되기도 한다.

Modern C++에서는 범위 기반 `for` 문과 `auto` 키워드를 적극 활용하여 코드를 간결하고 안전하게 작성하는 것을 권장한다. 또한 가능하면 표준 라이브러리의 알고리즘을 사용하여 코드의 의도를 더 명확하게 표현할 수 있다.

다음 장에서는 여러 개의 데이터를 효율적으로 관리하는 배열과 문자열을 Modern C++의 관점에서 살펴본다. `std::array`, `std::vector`, `std::string` 같은 안전한 컨테이너와 함께 범위 기반 `for` 문을 더 깊이 있게 활용하는 방법을 배운다.   