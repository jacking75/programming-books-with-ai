# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 25: 프로젝트 2 - 그래픽 에디터

이번 장에서는 본격적인 그래픽 에디터를 만들면서 Modern C++의 고급 디자인 패턴들을 실전에 적용한다. 도구 패턴(Tool Pattern)과 명령 패턴(Command Pattern)을 활용하여 확장 가능하고 유지보수하기 쉬운 구조를 설계하고, 실행 취소/다시 실행, 레이어 시스템, 파일 입출력 등 전문적인 그래픽 애플리케이션의 핵심 기능들을 구현한다.

## 25.1 프로젝트 개요와 설계

### 25.1.1 그래픽 에디터의 요구사항

우리가 만들 그래픽 에디터는 다음과 같은 기능을 제공한다:

**핵심 기능:**
- 펜, 브러시, 지우개, 도형 도구 등 다양한 그리기 도구
- 색상 선택 및 브러시 크기 조절
- 실행 취소(Undo) 및 다시 실행(Redo)
- 레이어 시스템 (추가, 삭제, 순서 변경, 표시/숨김)
- 이미지 저장 및 불러오기

**사용자 인터페이스:**
- 도구 팔레트
- 색상 선택기
- 레이어 패널
- 캔버스 영역
- 메뉴 바

### 25.1.2 아키텍처 설계

Modern C++의 장점을 최대한 활용하여 확장 가능하고 유지보수하기 쉬운 구조를 설계한다.

```
┌─────────────────────────────────────────┐
│         GraphicEditor (Main)            │
├─────────────────────────────────────────┤
│  - ToolManager                          │
│  - CommandManager (Undo/Redo)           │
│  - LayerManager                         │
│  - UIManager                            │
│  - FileManager                          │
└─────────────────────────────────────────┘
         │                │
         ▼                ▼
┌──────────────┐   ┌──────────────┐
│   ITool      │   │   ICommand   │
│ (Interface)  │   │ (Interface)  │
├──────────────┤   ├──────────────┤
│ - PenTool    │   │ - DrawCmd    │
│ - BrushTool  │   │ - EraseCmd   │
│ - EraserTool │   │ - LayerCmd   │
│ - ShapeTool  │   └──────────────┘
└──────────────┘
```

**설계 원칙:**
- **단일 책임 원칙**: 각 클래스는 하나의 책임만 갖는다
- **개방-폐쇄 원칙**: 확장에는 열려있고 수정에는 닫혀있다
- **의존성 역전**: 구체적인 구현이 아닌 추상화에 의존한다

### 25.1.3 프로젝트 구조

```cpp
// EditorConfig.h
#pragma once
#include <Siv3D.hpp>

namespace EditorConfig
{
    // 캔버스 설정
    constexpr Size CanvasSize{ 800, 600 };
    constexpr Point CanvasOffset{ 220, 80 };
    
    // UI 설정
    constexpr int32 ToolbarWidth = 200;
    constexpr int32 MenuBarHeight = 60;
    constexpr int32 LayerPanelWidth = 200;
    
    // 색상
    const ColorF BackgroundColor{ 0.95, 0.95, 0.95 };
    const ColorF CanvasColor{ 1.0, 1.0, 1.0 };
    const ColorF UIBackgroundColor{ 0.9, 0.9, 0.9 };
    const ColorF UIBorderColor{ 0.7, 0.7, 0.7 };
    
    // 기본값
    constexpr int32 DefaultBrushSize = 3;
    constexpr int32 MinBrushSize = 1;
    constexpr int32 MaxBrushSize = 50;
    
    // 레이어 설정
    constexpr int32 MaxLayers = 10;
}
```

## 25.2 도구 패턴과 명령 패턴 적용

### 25.2.1 도구 인터페이스 설계

도구 패턴을 사용하면 각 도구의 동작을 독립적으로 구현할 수 있다.

```cpp
// ITool.h
#pragma once
#include <Siv3D.hpp>

// 도구의 기본 인터페이스
class ITool
{
public:
    virtual ~ITool() = default;
    
    // 도구 이름
    virtual String getName() const = 0;
    
    // 도구 아이콘
    virtual Texture getIcon() const = 0;
    
    // 마우스 이벤트 처리
    virtual void onMouseDown(const Vec2& pos, Image& canvas) = 0;
    virtual void onMouseMove(const Vec2& pos, Image& canvas) = 0;
    virtual void onMouseUp(const Vec2& pos, Image& canvas) = 0;
    
    // 도구 설정
    virtual void setColor(const Color& color) { m_color = color; }
    virtual void setBrushSize(int32 size) { m_brushSize = size; }
    
    // 현재 설정 반환
    virtual Color getColor() const { return m_color; }
    virtual int32 getBrushSize() const { return m_brushSize; }
    
    // 프리뷰 그리기 (현재 마우스 위치에 도구 효과 미리보기)
    virtual void drawPreview(const Vec2& pos) const = 0;
    
protected:
    Color m_color{ Palette::Black };
    int32 m_brushSize = EditorConfig::DefaultBrushSize;
};
```

인터페이스를 사용하면 새로운 도구를 추가할 때 기존 코드를 수정하지 않아도 된다. 이것이 개방-폐쇄 원칙의 핵심이다.

### 25.2.2 펜 도구 구현

```cpp
// PenTool.h
#pragma once
#include "ITool.h"

class PenTool : public ITool
{
public:
    PenTool()
    {
        // 아이콘 로드 (또는 프로그래밍 방식으로 생성)
        m_icon = Texture{ Emoji{ U"✏️" } };
    }
    
    String getName() const override
    {
        return U"펜";
    }
    
    Texture getIcon() const override
    {
        return m_icon;
    }
    
    void onMouseDown(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = true;
        m_lastPos = pos;
        
        // 점 그리기
        drawPoint(pos, canvas);
    }
    
    void onMouseMove(const Vec2& pos, Image& canvas) override
    {
        if (not m_isDrawing)
            return;
        
        // 이전 위치와 현재 위치를 연결하는 선 그리기
        drawLine(m_lastPos, pos, canvas);
        m_lastPos = pos;
    }
    
    void onMouseUp(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = false;
    }
    
    void drawPreview(const Vec2& pos) const override
    {
        // 펜 위치에 작은 원 표시
        Circle{ pos, m_brushSize / 2.0 }
            .drawFrame(1.0, m_color);
    }
    
private:
    Texture m_icon;
    bool m_isDrawing = false;
    Vec2 m_lastPos{ 0, 0 };
    
    void drawPoint(const Vec2& pos, Image& canvas)
    {
        const Point p = pos.asPoint();
        
        if (not canvas.size().contains(p))
            return;
        
        canvas[p] = m_color;
    }
    
    void drawLine(const Vec2& from, const Vec2& to, Image& canvas)
    {
        // Bresenham's 라인 알고리즘 또는 Siv3D의 선 그리기 활용
        Line{ from, to }.overwrite(canvas, m_brushSize, m_color);
    }
};
```

Modern C++의 `override` 키워드를 사용하여 가상 함수를 재정의함을 명시한다. 컴파일러가 오타를 잡아내는 데 도움이 된다.

### 25.2.3 브러시 도구 구현

```cpp
// BrushTool.h
#pragma once
#include "ITool.h"

class BrushTool : public ITool
{
public:
    BrushTool()
    {
        m_icon = Texture{ Emoji{ U"🖌️" } };
    }
    
    String getName() const override
    {
        return U"브러시";
    }
    
    Texture getIcon() const override
    {
        return m_icon;
    }
    
    void onMouseDown(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = true;
        drawBrush(pos, canvas);
    }
    
    void onMouseMove(const Vec2& pos, Image& canvas) override
    {
        if (not m_isDrawing)
            return;
        
        drawBrush(pos, canvas);
    }
    
    void onMouseUp(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = false;
    }
    
    void drawPreview(const Vec2& pos) const override
    {
        Circle{ pos, m_brushSize }
            .drawFrame(1.0, m_color);
    }
    
    void setOpacity(double opacity)
    {
        m_opacity = Clamp(opacity, 0.0, 1.0);
    }
    
private:
    Texture m_icon;
    bool m_isDrawing = false;
    double m_opacity = 0.5;
    
    void drawBrush(const Vec2& pos, Image& canvas)
    {
        // 부드러운 브러시 효과 (알파 블렌딩)
        const int32 radius = m_brushSize;
        const Point center = pos.asPoint();
        
        for (int32 y = -radius; y <= radius; ++y)
        {
            for (int32 x = -radius; x <= radius; ++x)
            {
                const Point p{ center.x + x, center.y + y };
                
                if (not canvas.size().contains(p))
                    continue;
                
                const double distance = Vec2{ x, y }.length();
                
                if (distance <= radius)
                {
                    // 중심에서 멀수록 투명도 감소
                    const double alpha = (1.0 - distance / radius) * m_opacity;
                    
                    // 알파 블렌딩
                    const Color existingColor = canvas[p];
                    const Color blendedColor = Alpha(
                        static_cast<uint8>(m_color.r * alpha + existingColor.r * (1 - alpha)),
                        static_cast<uint8>(m_color.g * alpha + existingColor.g * (1 - alpha)),
                        static_cast<uint8>(m_color.b * alpha + existingColor.b * (1 - alpha))
                    );
                    
                    canvas[p] = blendedColor;
                }
            }
        }
    }
};
```

브러시 도구는 펜보다 복잡한 알고리즘을 사용한다. 거리 기반 알파 블렌딩으로 부드러운 효과를 만든다.

### 25.2.4 도형 도구 구현

```cpp
// ShapeTool.h
#pragma once
#include "ITool.h"

enum class ShapeType
{
    Rectangle,
    Circle,
    Line,
    Triangle
};

class ShapeTool : public ITool
{
public:
    ShapeTool(ShapeType type)
        : m_shapeType{ type }
    {
        m_icon = Texture{ Emoji{ getShapeEmoji() } };
    }
    
    String getName() const override
    {
        switch (m_shapeType)
        {
        case ShapeType::Rectangle:
            return U"사각형";
        case ShapeType::Circle:
            return U"원";
        case ShapeType::Line:
            return U"직선";
        case ShapeType::Triangle:
            return U"삼각형";
        default:
            return U"도형";
        }
    }
    
    Texture getIcon() const override
    {
        return m_icon;
    }
    
    void onMouseDown(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = true;
        m_startPos = pos;
        m_endPos = pos;
    }
    
    void onMouseMove(const Vec2& pos, Image& canvas) override
    {
        if (m_isDrawing)
        {
            m_endPos = pos;
        }
    }
    
    void onMouseUp(const Vec2& pos, Image& canvas) override
    {
        if (m_isDrawing)
        {
            m_endPos = pos;
            drawShape(canvas);
            m_isDrawing = false;
        }
    }
    
    void drawPreview(const Vec2& pos) const override
    {
        if (not m_isDrawing)
        {
            Circle{ pos, m_brushSize / 2.0 }
                .drawFrame(1.0, m_color);
            return;
        }
        
        // 현재 그리고 있는 도형 미리보기
        drawShapePreview();
    }
    
    void setFilled(bool filled)
    {
        m_filled = filled;
    }
    
private:
    Texture m_icon;
    ShapeType m_shapeType;
    bool m_isDrawing = false;
    Vec2 m_startPos{ 0, 0 };
    Vec2 m_endPos{ 0, 0 };
    bool m_filled = false;
    
    String getShapeEmoji() const
    {
        switch (m_shapeType)
        {
        case ShapeType::Rectangle:
            return U"▭";
        case ShapeType::Circle:
            return U"○";
        case ShapeType::Line:
            return U"╱";
        case ShapeType::Triangle:
            return U"△";
        default:
            return U"◇";
        }
    }
    
    void drawShape(Image& canvas)
    {
        switch (m_shapeType)
        {
        case ShapeType::Rectangle:
            drawRectangle(canvas);
            break;
        case ShapeType::Circle:
            drawCircle(canvas);
            break;
        case ShapeType::Line:
            drawLine(canvas);
            break;
        case ShapeType::Triangle:
            drawTriangle(canvas);
            break;
        }
    }
    
    void drawRectangle(Image& canvas)
    {
        const RectF rect{ m_startPos, m_endPos };
        
        if (m_filled)
        {
            rect.overwrite(canvas, m_color);
        }
        else
        {
            rect.overwriteFrame(canvas, m_brushSize, m_color);
        }
    }
    
    void drawCircle(Image& canvas)
    {
        const Vec2 center = (m_startPos + m_endPos) / 2.0;
        const double radius = m_startPos.distanceFrom(m_endPos) / 2.0;
        
        if (m_filled)
        {
            Circle{ center, radius }.overwrite(canvas, m_color);
        }
        else
        {
            Circle{ center, radius }.overwriteFrame(canvas, m_brushSize, m_color);
        }
    }
    
    void drawLine(Image& canvas)
    {
        Line{ m_startPos, m_endPos }.overwrite(canvas, m_brushSize, m_color);
    }
    
    void drawTriangle(Image& canvas)
    {
        const Vec2 p1 = m_startPos;
        const Vec2 p2{ m_endPos.x, m_startPos.y };
        const Vec2 p3{ (m_startPos.x + m_endPos.x) / 2.0, m_endPos.y };
        
        const Triangle triangle{ p1, p2, p3 };
        
        if (m_filled)
        {
            triangle.overwrite(canvas, m_color);
        }
        else
        {
            triangle.overwriteFrame(canvas, m_brushSize, m_color);
        }
    }
    
    void drawShapePreview() const
    {
        // 화면에 미리보기 표시 (Image가 아닌 화면에 직접)
        switch (m_shapeType)
        {
        case ShapeType::Rectangle:
            RectF{ m_startPos, m_endPos }
                .drawFrame(2.0, m_color);
            break;
        case ShapeType::Circle:
            {
                const Vec2 center = (m_startPos + m_endPos) / 2.0;
                const double radius = m_startPos.distanceFrom(m_endPos) / 2.0;
                Circle{ center, radius }.drawFrame(2.0, m_color);
            }
            break;
        case ShapeType::Line:
            Line{ m_startPos, m_endPos }.draw(m_brushSize, m_color);
            break;
        case ShapeType::Triangle:
            {
                const Vec2 p1 = m_startPos;
                const Vec2 p2{ m_endPos.x, m_startPos.y };
                const Vec2 p3{ (m_startPos.x + m_endPos.x) / 2.0, m_endPos.y };
                Triangle{ p1, p2, p3 }.drawFrame(2.0, m_color);
            }
            break;
        }
    }
};
```

도형 도구는 생성자에서 도형 타입을 받아 하나의 클래스로 여러 도형을 처리한다. 이는 코드 중복을 줄이면서도 확장성을 유지하는 방법이다.

### 25.2.5 도구 관리자

```cpp
// ToolManager.h
#pragma once
#include "ITool.h"
#include <memory>
#include <vector>

class ToolManager
{
public:
    ToolManager()
    {
        initializeTools();
    }
    
    // 현재 활성 도구 반환
    ITool* getCurrentTool() const
    {
        if (m_currentToolIndex < m_tools.size())
        {
            return m_tools[m_currentToolIndex].get();
        }
        return nullptr;
    }
    
    // 도구 선택
    void selectTool(size_t index)
    {
        if (index < m_tools.size())
        {
            m_currentToolIndex = index;
        }
    }
    
    // 모든 도구 반환
    const std::vector<std::unique_ptr<ITool>>& getTools() const
    {
        return m_tools;
    }
    
    size_t getCurrentToolIndex() const
    {
        return m_currentToolIndex;
    }
    
private:
    std::vector<std::unique_ptr<ITool>> m_tools;
    size_t m_currentToolIndex = 0;
    
    void initializeTools()
    {
        // 다양한 도구 추가
        m_tools.push_back(std::make_unique<PenTool>());
        m_tools.push_back(std::make_unique<BrushTool>());
        m_tools.push_back(std::make_unique<EraserTool>());
        m_tools.push_back(std::make_unique<ShapeTool>(ShapeType::Rectangle));
        m_tools.push_back(std::make_unique<ShapeTool>(ShapeType::Circle));
        m_tools.push_back(std::make_unique<ShapeTool>(ShapeType::Line));
    }
};
```

`std::unique_ptr`를 사용하여 도구 객체의 소유권을 명확하게 관리한다. `std::vector`에 `std::unique_ptr`를 저장하면 복사는 불가능하지만 이동은 가능하다.

### 25.2.6 지우개 도구

```cpp
// EraserTool.h
#pragma once
#include "ITool.h"

class EraserTool : public ITool
{
public:
    EraserTool()
    {
        m_icon = Texture{ Emoji{ U"🧹" } };
        m_color = Palette::White;  // 지우개는 흰색으로 그림
    }
    
    String getName() const override
    {
        return U"지우개";
    }
    
    Texture getIcon() const override
    {
        return m_icon;
    }
    
    void onMouseDown(const Vec2& pos, Image& canvas) override
    {
        m_isErasing = true;
        erase(pos, canvas);
    }
    
    void onMouseMove(const Vec2& pos, Image& canvas) override
    {
        if (m_isErasing)
        {
            erase(pos, canvas);
        }
    }
    
    void onMouseUp(const Vec2& pos, Image& canvas) override
    {
        m_isErasing = false;
    }
    
    void drawPreview(const Vec2& pos) const override
    {
        Circle{ pos, m_brushSize }
            .drawFrame(1.0, ColorF{ 0.5 });
    }
    
    // 지우개는 색상 변경 불가
    void setColor(const Color& color) override
    {
        // 아무 동작도 하지 않음
    }
    
private:
    Texture m_icon;
    bool m_isErasing = false;
    
    void erase(const Vec2& pos, Image& canvas)
    {
        Circle{ pos, m_brushSize }.overwrite(canvas, Palette::White);
    }
};
```

## 25.3 실행 취소/다시 실행 기능

### 25.3.1 명령 인터페이스 설계

명령 패턴을 사용하면 모든 작업을 객체로 만들어 저장하고 취소할 수 있다.

```cpp
// ICommand.h
#pragma once
#include <Siv3D.hpp>

// 명령 인터페이스
class ICommand
{
public:
    virtual ~ICommand() = default;
    
    // 명령 실행
    virtual void execute() = 0;
    
    // 명령 취소
    virtual void undo() = 0;
    
    // 명령 다시 실행
    virtual void redo()
    {
        execute();  // 기본적으로 다시 실행은 실행과 동일
    }
    
    // 명령 설명 (디버깅 및 UI용)
    virtual String getDescription() const = 0;
};
```

### 25.3.2 그리기 명령 구현

```cpp
// DrawCommand.h
#pragma once
#include "ICommand.h"

class DrawCommand : public ICommand
{
public:
    DrawCommand(Image& targetImage, const Image& beforeState, const Image& afterState, const String& toolName)
        : m_targetImage{ targetImage }
        , m_beforeState{ beforeState }
        , m_afterState{ afterState }
        , m_toolName{ toolName }
    {
    }
    
    void execute() override
    {
        m_targetImage = m_afterState;
    }
    
    void undo() override
    {
        m_targetImage = m_beforeState;
    }
    
    String getDescription() const override
    {
        return m_toolName + U" 사용";
    }
    
private:
    Image& m_targetImage;
    Image m_beforeState;  // 작업 전 이미지
    Image m_afterState;   // 작업 후 이미지
    String m_toolName;
};
```

이미지 전체를 복사하여 저장하는 방식은 메모리를 많이 사용하지만, 구현이 간단하고 모든 종류의 변경을 지원한다. 더 효율적인 방법은 변경된 영역만 저장하는 것이지만, 복잡도가 증가한다.

### 25.3.3 명령 관리자

```cpp
// CommandManager.h
#pragma once
#include "ICommand.h"
#include <memory>
#include <deque>

class CommandManager
{
public:
    // 새 명령 실행 및 히스토리에 추가
    void executeCommand(std::unique_ptr<ICommand> command)
    {
        command->execute();
        
        // 현재 위치 이후의 모든 명령 삭제 (새로운 분기)
        m_undoStack.erase(
            m_undoStack.begin() + m_currentIndex,
            m_undoStack.end()
        );
        
        // 새 명령 추가
        m_undoStack.push_back(std::move(command));
        m_currentIndex = m_undoStack.size();
        
        // 히스토리 크기 제한
        if (m_undoStack.size() > m_maxHistorySize)
        {
            m_undoStack.pop_front();
            --m_currentIndex;
        }
    }
    
    // 실행 취소
    bool undo()
    {
        if (not canUndo())
            return false;
        
        --m_currentIndex;
        m_undoStack[m_currentIndex]->undo();
        return true;
    }
    
    // 다시 실행
    bool redo()
    {
        if (not canRedo())
            return false;
        
        m_undoStack[m_currentIndex]->redo();
        ++m_currentIndex;
        return true;
    }
    
    // 실행 취소 가능 여부
    bool canUndo() const
    {
        return m_currentIndex > 0;
    }
    
    // 다시 실행 가능 여부
    bool canRedo() const
    {
        return m_currentIndex < m_undoStack.size();
    }
    
    // 히스토리 초기화
    void clear()
    {
        m_undoStack.clear();
        m_currentIndex = 0;
    }
    
    // 히스토리 정보
    size_t getHistorySize() const
    {
        return m_undoStack.size();
    }
    
    size_t getCurrentIndex() const
    {
        return m_currentIndex;
    }
    
    // 히스토리 목록 (UI용)
    std::vector<String> getHistoryList() const
    {
        std::vector<String> history;
        
        for (const auto& command : m_undoStack)
        {
            history.push_back(command->getDescription());
        }
        
        return history;
    }
    
    void setMaxHistorySize(size_t size)
    {
        m_maxHistorySize = size;
    }
    
private:
    std::deque<std::unique_ptr<ICommand>> m_undoStack;
    size_t m_currentIndex = 0;
    size_t m_maxHistorySize = 50;
};
```

`std::deque`를 사용하여 양쪽 끝에서 효율적으로 삽입과 삭제가 가능하다. 인덱스 기반 접근으로 특정 명령을 빠르게 찾을 수 있다.

**Undo/Redo 동작 원리:**

```
초기 상태: [ ]
           ^
         현재

그리기 1: [Cmd1]
                ^
              현재

그리기 2: [Cmd1, Cmd2]
                      ^
                    현재

Undo:     [Cmd1, Cmd2]
                ^
              현재 (Cmd2를 undo함)

그리기 3: [Cmd1, Cmd3]  // Cmd2는 삭제됨
                      ^
                    현재

Redo:     불가능 (현재가 끝에 있음)
```

### 25.3.4 명령 패턴 사용 예제

```cpp
// 그래픽 에디터에서 명령 사용
class GraphicEditor
{
private:
    CommandManager m_commandManager;
    Image m_currentLayer;
    
public:
    void handleDrawing(ITool* tool, const Vec2& pos)
    {
        // 작업 전 이미지 저장
        const Image beforeState = m_currentLayer;
        
        // 도구로 그리기
        tool->onMouseDown(pos, m_currentLayer);
        
        // 작업 후 이미지 저장
        const Image afterState = m_currentLayer;
        
        // 명령 생성 및 실행
        auto command = std::make_unique<DrawCommand>(
            m_currentLayer,
            beforeState,
            afterState,
            tool->getName()
        );
        
        m_commandManager.executeCommand(std::move(command));
    }
    
    void undo()
    {
        if (m_commandManager.undo())
        {
            Print << U"실행 취소 완료";
        }
    }
    
    void redo()
    {
        if (m_commandManager.redo())
        {
            Print << U"다시 실행 완료";
        }
    }
};
```

## 25.4 레이어 시스템 구현

### 25.4.1 레이어 클래스 설계

```cpp
// Layer.h
#pragma once
#include <Siv3D.hpp>

class Layer
{
public:
    Layer(const Size& size, const String& name = U"레이어")
        : m_image{ size, Palette::Transparent }
        , m_texture{ m_image }
        , m_name{ name }
    {
    }
    
    // 이미지 접근
    Image& getImage()
    {
        m_needsUpdate = true;
        return m_image;
    }
    
    const Image& getImage() const
    {
        return m_image;
    }
    
    // 텍스처 업데이트 및 반환
    const Texture& getTexture()
    {
        if (m_needsUpdate)
        {
            m_texture.fill(m_image);
            m_needsUpdate = false;
        }
        
        return m_texture;
    }
    
    // 레이어 속성
    void setName(const String& name)
    {
        m_name = name;
    }
    
    String getName() const
    {
        return m_name;
    }
    
    void setVisible(bool visible)
    {
        m_visible = visible;
    }
    
    bool isVisible() const
    {
        return m_visible;
    }
    
    void setOpacity(double opacity)
    {
        m_opacity = Clamp(opacity, 0.0, 1.0);
    }
    
    double getOpacity() const
    {
        return m_opacity;
    }
    
    void setLocked(bool locked)
    {
        m_locked = locked;
    }
    
    bool isLocked() const
    {
        return m_locked;
    }
    
    // 레이어 초기화
    void clear(const Color& color = Palette::Transparent)
    {
        m_image.fill(color);
        m_needsUpdate = true;
    }
    
private:
    Image m_image;
    DynamicTexture m_texture;
    String m_name;
    bool m_visible = true;
    bool m_locked = false;
    double m_opacity = 1.0;
    bool m_needsUpdate = false;
};
```

`DynamicTexture`를 사용하여 이미지가 변경될 때마다 텍스처를 업데이트할 수 있다. `m_needsUpdate` 플래그로 불필요한 업데이트를 방지한다.

### 25.4.2 레이어 관리자

```cpp
// LayerManager.h
#pragma once
#include "Layer.h"
#include <memory>
#include <vector>

class LayerManager
{
public:
    LayerManager(const Size& canvasSize)
        : m_canvasSize{ canvasSize }
    {
        // 기본 레이어 생성
        addLayer(U"배경");
    }
    
    // 레이어 추가
    size_t addLayer(const String& name = U"새 레이어")
    {
        if (m_layers.size() >= EditorConfig::MaxLayers)
        {
            return m_currentLayerIndex;
        }
        
        auto layer = std::make_unique<Layer>(m_canvasSize, name);
        m_layers.push_back(std::move(layer));
        m_currentLayerIndex = m_layers.size() - 1;
        
        return m_currentLayerIndex;
    }
    
    // 레이어 삭제
    bool removeLayer(size_t index)
    {
        if (m_layers.size() <= 1)  // 최소 1개는 유지
        {
            return false;
        }
        
        if (index >= m_layers.size())
        {
            return false;
        }
        
        m_layers.erase(m_layers.begin() + index);
        
        // 현재 레이어 인덱스 조정
        if (m_currentLayerIndex >= m_layers.size())
        {
            m_currentLayerIndex = m_layers.size() - 1;
        }
        
        return true;
    }
    
    // 레이어 순서 변경
    bool moveLayer(size_t from, size_t to)
    {
        if (from >= m_layers.size() || to >= m_layers.size())
        {
            return false;
        }
        
        if (from == to)
        {
            return true;
        }
        
        auto layer = std::move(m_layers[from]);
        m_layers.erase(m_layers.begin() + from);
        m_layers.insert(m_layers.begin() + to, std::move(layer));
        
        // 현재 레이어 인덱스 조정
        if (m_currentLayerIndex == from)
        {
            m_currentLayerIndex = to;
        }
        else if (from < m_currentLayerIndex && to >= m_currentLayerIndex)
        {
            --m_currentLayerIndex;
        }
        else if (from > m_currentLayerIndex && to <= m_currentLayerIndex)
        {
            ++m_currentLayerIndex;
        }
        
        return true;
    }
    
    // 현재 레이어 선택
    void selectLayer(size_t index)
    {
        if (index < m_layers.size())
        {
            m_currentLayerIndex = index;
        }
    }
    
    // 현재 레이어 반환
    Layer* getCurrentLayer()
    {
        if (m_currentLayerIndex < m_layers.size())
        {
            return m_layers[m_currentLayerIndex].get();
        }
        return nullptr;
    }
    
    const Layer* getCurrentLayer() const
    {
        if (m_currentLayerIndex < m_layers.size())
        {
            return m_layers[m_currentLayerIndex].get();
        }
        return nullptr;
    }
    
    // 모든 레이어 반환
    const std::vector<std::unique_ptr<Layer>>& getLayers() const
    {
        return m_layers;
    }
    
    size_t getCurrentLayerIndex() const
    {
        return m_currentLayerIndex;
    }
    
    size_t getLayerCount() const
    {
        return m_layers.size();
    }
    
    // 합성된 이미지 생성
    Image createCompositeImage() const
    {
        Image composite{ m_canvasSize, Palette::White };
        
        // 레이어를 아래에서 위로 합성
        for (const auto& layer : m_layers)
        {
            if (not layer->isVisible())
                continue;
            
            const Image& layerImage = layer->getImage();
            const double opacity = layer->getOpacity();
            
            // 알파 블렌딩
            for (int32 y = 0; y < m_canvasSize.y; ++y)
            {
                for (int32 x = 0; x < m_canvasSize.x; ++x)
                {
                    const Point p{ x, y };
                    const Color layerColor = layerImage[p];
                    
                    if (layerColor.a == 0)
                        continue;
                    
                    const Color existingColor = composite[p];
                    const double alpha = (layerColor.a / 255.0) * opacity;
                    
                    composite[p] = Color{
                        static_cast<uint8>(layerColor.r * alpha + existingColor.r * (1 - alpha)),
                        static_cast<uint8>(layerColor.g * alpha + existingColor.g * (1 - alpha)),
                        static_cast<uint8>(layerColor.b * alpha + existingColor.b * (1 - alpha))
                    };
                }
            }
        }
        
        return composite;
    }
    
private:
    std::vector<std::unique_ptr<Layer>> m_layers;
    size_t m_currentLayerIndex = 0;
    Size m_canvasSize;
};
```

레이어는 아래에서 위로 쌓이며, 위쪽 레이어가 아래쪽 레이어를 덮는다. 알파 블렌딩을 사용하여 투명도를 지원한다.

### 25.4.3 레이어 명령

레이어 조작도 명령 패턴으로 구현하여 취소할 수 있도록 한다.

```cpp
// LayerCommands.h
#pragma once
#include "ICommand.h"
#include "LayerManager.h"

// 레이어 추가 명령
class AddLayerCommand : public ICommand
{
public:
    AddLayerCommand(LayerManager& manager, const String& name)
        : m_manager{ manager }
        , m_layerName{ name }
    {
    }
    
    void execute() override
    {
        m_layerIndex = m_manager.addLayer(m_layerName);
    }
    
    void undo() override
    {
        m_manager.removeLayer(m_layerIndex);
    }
    
    String getDescription() const override
    {
        return U"레이어 추가: " + m_layerName;
    }
    
private:
    LayerManager& m_manager;
    String m_layerName;
    size_t m_layerIndex = 0;
};

// 레이어 삭제 명령
class RemoveLayerCommand : public ICommand
{
public:
    RemoveLayerCommand(LayerManager& manager, size_t index)
        : m_manager{ manager }
        , m_layerIndex{ index }
    {
        // 삭제 전에 레이어 데이터 백업
        if (auto* layer = m_manager.getLayers()[index].get())
        {
            m_layerBackup = layer->getImage();
            m_layerName = layer->getName();
            m_layerVisible = layer->isVisible();
            m_layerOpacity = layer->getOpacity();
        }
    }
    
    void execute() override
    {
        m_manager.removeLayer(m_layerIndex);
    }
    
    void undo() override
    {
        // 레이어 복원
        const size_t newIndex = m_manager.addLayer(m_layerName);
        
        if (auto* layer = m_manager.getLayers()[newIndex].get())
        {
            layer->getImage() = m_layerBackup;
            layer->setVisible(m_layerVisible);
            layer->setOpacity(m_layerOpacity);
        }
        
        // 원래 위치로 이동
        m_manager.moveLayer(newIndex, m_layerIndex);
    }
    
    String getDescription() const override
    {
        return U"레이어 삭제: " + m_layerName;
    }
    
private:
    LayerManager& m_manager;
    size_t m_layerIndex;
    Image m_layerBackup;
    String m_layerName;
    bool m_layerVisible;
    double m_layerOpacity;
};

// 레이어 이동 명령
class MoveLayerCommand : public ICommand
{
public:
    MoveLayerCommand(LayerManager& manager, size_t from, size_t to)
        : m_manager{ manager }
        , m_fromIndex{ from }
        , m_toIndex{ to }
    {
    }
    
    void execute() override
    {
        m_manager.moveLayer(m_fromIndex, m_toIndex);
    }
    
    void undo() override
    {
        m_manager.moveLayer(m_toIndex, m_fromIndex);
    }
    
    String getDescription() const override
    {
        return U"레이어 이동";
    }
    
private:
    LayerManager& m_manager;
    size_t m_fromIndex;
    size_t m_toIndex;
};
```

## 25.5 파일 저장과 불러오기

### 25.5.4 파일 관리자

```cpp
// FileManager.h
#pragma once
#include "LayerManager.h"
#include <Siv3D.hpp>

class FileManager
{
public:
    // 단일 이미지로 저장 (병합된 레이어)
    bool saveAsImage(const LayerManager& layerManager, const FilePath& path)
    {
        const Image composite = layerManager.createCompositeImage();
        return composite.save(path);
    }
    
    // 프로젝트 파일로 저장 (모든 레이어 포함)
    bool saveProject(const LayerManager& layerManager, const FilePath& path)
    {
        JSON json;
        
        // 캔버스 크기
        const auto& layers = layerManager.getLayers();
        if (layers.empty())
            return false;
        
        const Size canvasSize = layers[0]->getImage().size();
        json[U"canvas_width"] = canvasSize.x;
        json[U"canvas_height"] = canvasSize.y;
        
        // 현재 레이어 인덱스
        json[U"current_layer"] = layerManager.getCurrentLayerIndex();
        
        // 레이어 정보
        for (size_t i = 0; i < layers.size(); ++i)
        {
            const Layer* layer = layers[i].get();
            
            JSON layerJson;
            layerJson[U"name"] = layer->getName();
            layerJson[U"visible"] = layer->isVisible();
            layerJson[U"opacity"] = layer->getOpacity();
            layerJson[U"locked"] = layer->isLocked();
            
            // 레이어 이미지 저장
            const String layerImagePath = FileSystem::BaseName(path) 
                + U"_layer_" + ToString(i) + U".png";
            
            layer->getImage().save(FileSystem::ParentPath(path) + layerImagePath);
            layerJson[U"image_path"] = layerImagePath;
            
            json[U"layers"][i] = layerJson;
        }
        
        // JSON 파일 저장
        return json.save(path);
    }
    
    // 프로젝트 파일 불러오기
    bool loadProject(LayerManager& layerManager, const FilePath& path)
    {
        const JSON json = JSON::Load(path);
        
        if (not json)
            return false;
        
        try
        {
            // 캔버스 크기
            const int32 width = json[U"canvas_width"].get<int32>();
            const int32 height = json[U"canvas_height"].get<int32>();
            const Size canvasSize{ width, height };
            
            // 기존 레이어 모두 삭제
            layerManager = LayerManager{ canvasSize };
            
            // 레이어 불러오기
            const auto& layersJson = json[U"layers"];
            
            for (const auto& layerJson : layersJson.arrayView())
            {
                const String name = layerJson[U"name"].get<String>();
                const bool visible = layerJson[U"visible"].get<bool>();
                const double opacity = layerJson[U"opacity"].get<double>();
                const bool locked = layerJson[U"locked"].get<bool>();
                const String imagePath = layerJson[U"image_path"].get<String>();
                
                // 레이어 추가
                const size_t layerIndex = layerManager.addLayer(name);
                Layer* layer = layerManager.getLayers()[layerIndex].get();
                
                // 이미지 로드
                const String fullImagePath = FileSystem::ParentPath(path) + imagePath;
                const Image layerImage{ fullImagePath };
                
                if (not layerImage)
                {
                    Print << U"레이어 이미지 로드 실패: " << imagePath;
                    continue;
                }
                
                layer->getImage() = layerImage;
                layer->setVisible(visible);
                layer->setOpacity(opacity);
                layer->setLocked(locked);
            }
            
            // 현재 레이어 복원
            const size_t currentLayer = json[U"current_layer"].get<size_t>();
            layerManager.selectLayer(currentLayer);
            
            return true;
        }
        catch (const Error& error)
        {
            Print << U"프로젝트 로드 오류: " << error.what();
            return false;
        }
    }
    
    // 이미지 가져오기
    bool importImage(Layer& layer, const FilePath& path)
    {
        const Image image{ path };
        
        if (not image)
            return false;
        
        // 이미지 크기가 다르면 리사이즈
        const Size layerSize = layer.getImage().size();
        
        if (image.size() != layerSize)
        {
            Image resized{ layerSize, Palette::Transparent };
            image.scaled(layerSize).overwrite(resized);
            layer.getImage() = resized;
        }
        else
        {
            layer.getImage() = image;
        }
        
        return true;
    }
};
```

프로젝트 파일은 JSON 형식의 메타데이터와 각 레이어의 PNG 이미지로 구성된다. 이 방식은 간단하면서도 확장 가능하다.

### 25.5.2 파일 대화상자 사용

```cpp
// 그래픽 에디터에서 파일 저장/열기
class GraphicEditor
{
private:
    FileManager m_fileManager;
    LayerManager m_layerManager;
    
public:
    void saveImage()
    {
        // 파일 저장 대화상자
        if (const auto path = Dialog::SaveImage())
        {
            if (m_fileManager.saveAsImage(m_layerManager, path.value()))
            {
                Print << U"이미지 저장 완료: " << path.value();
            }
            else
            {
                Print << U"이미지 저장 실패";
            }
        }
    }
    
    void saveProject()
    {
        // 프로젝트 파일 저장
        if (const auto path = Dialog::SaveFile({ FileFilter::JSON() }))
        {
            if (m_fileManager.saveProject(m_layerManager, path.value()))
            {
                Print << U"프로젝트 저장 완료";
            }
            else
            {
                Print << U"프로젝트 저장 실패";
            }
        }
    }
    
    void loadProject()
    {
        // 프로젝트 파일 열기
        if (const auto path = Dialog::OpenFile({ FileFilter::JSON() }))
        {
            if (m_fileManager.loadProject(m_layerManager, path.value()))
            {
                Print << U"프로젝트 로드 완료";
                m_commandManager.clear();  // 히스토리 초기화
            }
            else
            {
                Print << U"프로젝트 로드 실패";
            }
        }
    }
    
    void importImage()
    {
        // 이미지 가져오기
        if (const auto path = Dialog::OpenImage())
        {
            if (auto* layer = m_layerManager.getCurrentLayer())
            {
                if (m_fileManager.importImage(*layer, path.value()))
                {
                    Print << U"이미지 가져오기 완료";
                }
                else
                {
                    Print << U"이미지 가져오기 실패";
                }
            }
        }
    }
};
```

`std::optional`을 반환하는 Siv3D의 대화상자 함수는 사용자가 취소했는지 명확하게 알려준다.

## 25.6 UI 구현

### 25.6.1 UI 매니저

```cpp
// UIManager.h
#pragma once
#include <Siv3D.hpp>
#include "ToolManager.h"
#include "LayerManager.h"

class UIManager
{
public:
    UIManager(ToolManager& toolManager, LayerManager& layerManager)
        : m_toolManager{ toolManager }
        , m_layerManager{ layerManager }
    {
        m_font = Font{ FontMethod::MSDF, 16 };
        m_iconFont = Font{ FontMethod::MSDF, 24 };
    }
    
    void update()
    {
        updateToolbar();
        updateColorPicker();
        updateLayerPanel();
        updateMenuBar();
    }
    
    void draw() const
    {
        drawToolbar();
        drawColorPicker();
        drawLayerPanel();
        drawMenuBar();
    }
    
    // 캔버스 영역 반환
    RectF getCanvasRect() const
    {
        return RectF{
            EditorConfig::CanvasOffset,
            EditorConfig::CanvasSize
        };
    }
    
private:
    ToolManager& m_toolManager;
    LayerManager& m_layerManager;
    Font m_font;
    Font m_iconFont;
    
    Color m_currentColor{ Palette::Black };
    int32 m_brushSize = EditorConfig::DefaultBrushSize;
    
    // 툴바 업데이트 및 그리기
    void updateToolbar()
    {
        const RectF toolbarRect{ 0, EditorConfig::MenuBarHeight, 
                                EditorConfig::ToolbarWidth, 
                                Scene::Height() - EditorConfig::MenuBarHeight };
        
        const auto& tools = m_toolManager.getTools();
        const int32 buttonSize = 50;
        const int32 margin = 10;
        
        for (size_t i = 0; i < tools.size(); ++i)
        {
            const int32 x = margin;
            const int32 y = EditorConfig::MenuBarHeight + margin + (buttonSize + margin) * i;
            
            const RectF buttonRect{ x, y, buttonSize, buttonSize };
            
            if (buttonRect.leftClicked())
            {
                m_toolManager.selectTool(i);
                
                // 도구에 현재 색상과 브러시 크기 설정
                if (auto* tool = m_toolManager.getCurrentTool())
                {
                    tool->setColor(m_currentColor);
                    tool->setBrushSize(m_brushSize);
                }
            }
        }
        
        // 브러시 크기 슬라이더
        const RectF sliderRect{ 
            margin, 
            EditorConfig::MenuBarHeight + margin + (buttonSize + margin) * tools.size() + 30,
            EditorConfig::ToolbarWidth - margin * 2,
            20
        };
        
        SimpleGUI::Slider(U"크기: {}"_fmt(m_brushSize), m_brushSize,
                         EditorConfig::MinBrushSize, EditorConfig::MaxBrushSize,
                         sliderRect.pos, sliderRect.w);
        
        // 도구에 브러시 크기 업데이트
        if (auto* tool = m_toolManager.getCurrentTool())
        {
            tool->setBrushSize(m_brushSize);
        }
    }
    
    void drawToolbar() const
    {
        const RectF toolbarRect{ 0, EditorConfig::MenuBarHeight,
                                EditorConfig::ToolbarWidth,
                                Scene::Height() - EditorConfig::MenuBarHeight };
        
        // 배경
        toolbarRect.draw(EditorConfig::UIBackgroundColor);
        toolbarRect.drawFrame(1, EditorConfig::UIBorderColor);
        
        // 도구 버튼
        const auto& tools = m_toolManager.getTools();
        const size_t currentTool = m_toolManager.getCurrentToolIndex();
        const int32 buttonSize = 50;
        const int32 margin = 10;
        
        for (size_t i = 0; i < tools.size(); ++i)
        {
            const int32 x = margin;
            const int32 y = EditorConfig::MenuBarHeight + margin + (buttonSize + margin) * i;
            
            const RectF buttonRect{ x, y, buttonSize, buttonSize };
            
            // 선택된 도구 하이라이트
            if (i == currentTool)
            {
                buttonRect.draw(ColorF{ 0.6, 0.8, 1.0 });
            }
            else if (buttonRect.mouseOver())
            {
                buttonRect.draw(ColorF{ 0.8, 0.8, 0.8 });
            }
            else
            {
                buttonRect.draw(ColorF{ 0.95 });
            }
            
            buttonRect.drawFrame(2, ColorF{ 0.5 });
            
            // 도구 아이콘
            const Texture icon = tools[i]->getIcon();
            icon.scaled(0.7).drawAt(buttonRect.center());
        }
    }
    
    void updateColorPicker()
    {
        const RectF pickerRect{
            10,
            Scene::Height() - 120,
            180,
            110
        };
        
        // 색상 선택 버튼들
        const std::array<Color, 8> colors = {
            Palette::Black, Palette::White, Palette::Red, Palette::Green,
            Palette::Blue, Palette::Yellow, Palette::Magenta, Palette::Cyan
        };
        
        const int32 colorBoxSize = 40;
        const int32 margin = 5;
        
        for (size_t i = 0; i < colors.size(); ++i)
        {
            const int32 col = i % 4;
            const int32 row = i / 4;
            
            const RectF colorBox{
                pickerRect.x + margin + (colorBoxSize + margin) * col,
                pickerRect.y + margin + (colorBoxSize + margin) * row,
                colorBoxSize,
                colorBoxSize
            };
            
            if (colorBox.leftClicked())
            {
                m_currentColor = colors[i];
                
                // 도구에 색상 업데이트
                if (auto* tool = m_toolManager.getCurrentTool())
                {
                    tool->setColor(m_currentColor);
                }
            }
        }
    }
    
    void drawColorPicker() const
    {
        const RectF pickerRect{
            10,
            Scene::Height() - 120,
            180,
            110
        };
        
        // 배경
        pickerRect.draw(EditorConfig::UIBackgroundColor);
        pickerRect.drawFrame(1, EditorConfig::UIBorderColor);
        
        // 색상 버튼들
        const std::array<Color, 8> colors = {
            Palette::Black, Palette::White, Palette::Red, Palette::Green,
            Palette::Blue, Palette::Yellow, Palette::Magenta, Palette::Cyan
        };
        
        const int32 colorBoxSize = 40;
        const int32 margin = 5;
        
        for (size_t i = 0; i < colors.size(); ++i)
        {
            const int32 col = i % 4;
            const int32 row = i / 4;
            
            const RectF colorBox{
                pickerRect.x + margin + (colorBoxSize + margin) * col,
                pickerRect.y + margin + (colorBoxSize + margin) * row,
                colorBoxSize,
                colorBoxSize
            };
            
            colorBox.draw(colors[i]);
            
            // 선택된 색상 표시
            if (colors[i] == m_currentColor)
            {
                colorBox.drawFrame(3, ColorF{ 1.0, 0.5, 0.0 });
            }
            else
            {
                colorBox.drawFrame(1, ColorF{ 0.5 });
            }
        }
    }
    
    void updateLayerPanel()
    {
        const RectF panelRect{
            Scene::Width() - EditorConfig::LayerPanelWidth,
            EditorConfig::MenuBarHeight,
            EditorConfig::LayerPanelWidth,
            Scene::Height() - EditorConfig::MenuBarHeight
        };
        
        const auto& layers = m_layerManager.getLayers();
        const int32 layerHeight = 60;
        const int32 margin = 5;
        
        // 레이어 추가 버튼
        const RectF addButton{
            panelRect.x + margin,
            panelRect.y + margin,
            panelRect.w - margin * 2,
            30
        };
        
        if (addButton.leftClicked())
        {
            m_layerManager.addLayer(U"레이어 " + ToString(layers.size() + 1));
        }
        
        // 레이어 목록 (아래에서 위로)
        for (int32 i = static_cast<int32>(layers.size()) - 1; i >= 0; --i)
        {
            const int32 reverseIndex = layers.size() - 1 - i;
            
            const RectF layerRect{
                panelRect.x + margin,
                panelRect.y + 50 + margin + (layerHeight + margin) * reverseIndex,
                panelRect.w - margin * 2,
                layerHeight
            };
            
            // 레이어 선택
            if (layerRect.leftClicked())
            {
                m_layerManager.selectLayer(i);
            }
            
            // 가시성 토글
            const RectF visibleButton{
                layerRect.x + 5,
                layerRect.y + 5,
                20,
                20
            };
            
            if (visibleButton.leftClicked())
            {
                layers[i]->setVisible(not layers[i]->isVisible());
            }
        }
    }
    
    void drawLayerPanel() const
    {
        const RectF panelRect{
            Scene::Width() - EditorConfig::LayerPanelWidth,
            EditorConfig::MenuBarHeight,
            EditorConfig::LayerPanelWidth,
            Scene::Height() - EditorConfig::MenuBarHeight
        };
        
        // 배경
        panelRect.draw(EditorConfig::UIBackgroundColor);
        panelRect.drawFrame(1, EditorConfig::UIBorderColor);
        
        // 레이어 추가 버튼
        const RectF addButton{
            panelRect.x + 5,
            panelRect.y + 5,
            panelRect.w - 10,
            30
        };
        
        addButton.rounded(5).draw(ColorF{ 0.6, 0.8, 0.6 });
        
        if (addButton.mouseOver())
        {
            addButton.rounded(5).draw(ColorF{ 0.7, 0.9, 0.7 });
        }
        
        m_font(U"+ 레이어 추가").drawAt(addButton.center(), ColorF{ 0.2 });
        
        // 레이어 목록
        const auto& layers = m_layerManager.getLayers();
        const size_t currentLayer = m_layerManager.getCurrentLayerIndex();
        const int32 layerHeight = 60;
        const int32 margin = 5;
        
        for (int32 i = static_cast<int32>(layers.size()) - 1; i >= 0; --i)
        {
            const int32 reverseIndex = layers.size() - 1 - i;
            
            const RectF layerRect{
                panelRect.x + margin,
                panelRect.y + 50 + margin + (layerHeight + margin) * reverseIndex,
                panelRect.w - margin * 2,
                layerHeight
            };
            
            // 선택된 레이어 하이라이트
            if (i == static_cast<int32>(currentLayer))
            {
                layerRect.draw(ColorF{ 0.7, 0.85, 1.0 });
            }
            else if (layerRect.mouseOver())
            {
                layerRect.draw(ColorF{ 0.85 });
            }
            else
            {
                layerRect.draw(ColorF{ 0.95 });
            }
            
            layerRect.drawFrame(1, ColorF{ 0.7 });
            
            // 레이어 썸네일
            const RectF thumbRect{
                layerRect.x + 5,
                layerRect.y + 5,
                50,
                50
            };
            
            layers[i]->getTexture()
                .scaled(50.0 / EditorConfig::CanvasSize.x)
                .draw(thumbRect.pos);
            
            thumbRect.drawFrame(1, ColorF{ 0.5 });
            
            // 레이어 이름
            m_font(layers[i]->getName()).draw(
                thumbRect.rightX() + 10,
                thumbRect.y + 5,
                ColorF{ 0.2 }
            );
            
            // 가시성 아이콘
            const RectF visibleButton{
                thumbRect.rightX() + 10,
                thumbRect.y + 25,
                20,
                20
            };
            
            const String visibleIcon = layers[i]->isVisible() ? U"👁" : U"🚫";
            m_iconFont(visibleIcon).drawAt(visibleButton.center());
            
            // 잠금 아이콘
            if (layers[i]->isLocked())
            {
                const RectF lockIcon{
                    visibleButton.rightX() + 5,
                    visibleButton.y,
                    20,
                    20
                };
                
                m_iconFont(U"🔒").drawAt(lockIcon.center());
            }
        }
    }
    
    void updateMenuBar()
    {
        // 메뉴 바는 별도로 구현 (파일, 편집, 보기 등)
    }
    
    void drawMenuBar() const
    {
        const RectF menuBarRect{ 0, 0, Scene::Width(), EditorConfig::MenuBarHeight };
        
        menuBarRect.draw(EditorConfig::UIBackgroundColor);
        menuBarRect.drawFrame(0, 2, EditorConfig::UIBorderColor);
        
        m_font(U"그래픽 에디터")
            .draw(20, (EditorConfig::MenuBarHeight - 20) / 2, ColorF{ 0.2 });
    }
};
```

## 25.7 메인 에디터 클래스

모든 구성 요소를 통합하여 완전한 그래픽 에디터를 만든다.

```cpp
// GraphicEditor.h
#pragma once
#include <Siv3D.hpp>
#include "ToolManager.h"
#include "CommandManager.h"
#include "LayerManager.h"
#include "FileManager.h"
#include "UIManager.h"

class GraphicEditor
{
public:
    GraphicEditor()
        : m_layerManager{ EditorConfig::CanvasSize }
        , m_uiManager{ m_toolManager, m_layerManager }
    {
    }
    
    void update()
    {
        // UI 업데이트
        m_uiManager.update();
        
        // 캔버스 영역에서의 입력 처리
        handleCanvasInput();
        
        // 단축키 처리
        handleShortcuts();
    }
    
    void draw() const
    {
        // 배경
        Scene::SetBackground(EditorConfig::BackgroundColor);
        
        // 캔버스 그리기
        drawCanvas();
        
        // UI 그리기
        m_uiManager.draw();
        
        // 도구 프리뷰
        drawToolPreview();
    }
    
private:
    ToolManager m_toolManager;
    CommandManager m_commandManager;
    LayerManager m_layerManager;
    FileManager m_fileManager;
    UIManager m_uiManager;
    
    // 그리기 상태
    bool m_isDrawing = false;
    Image m_beforeDrawing;
    
    void handleCanvasInput()
    {
        const RectF canvasRect = m_uiManager.getCanvasRect();
        
        if (not canvasRect.mouseOver())
            return;
        
        auto* currentTool = m_toolManager.getCurrentTool();
        if (not currentTool)
            return;
        
        auto* currentLayer = m_layerManager.getCurrentLayer();
        if (not currentLayer || currentLayer->isLocked())
            return;
        
        // 마우스 위치를 캔버스 좌표로 변환
        const Vec2 canvasPos = Cursor::Pos() - canvasRect.pos;
        
        // 마우스 다운
        if (MouseL.down())
        {
            m_isDrawing = true;
            m_beforeDrawing = currentLayer->getImage();
            currentTool->onMouseDown(canvasPos, currentLayer->getImage());
        }
        
        // 마우스 이동
        if (m_isDrawing && MouseL.pressed())
        {
            currentTool->onMouseMove(canvasPos, currentLayer->getImage());
        }
        
        // 마우스 업
        if (MouseL.up() && m_isDrawing)
        {
            currentTool->onMouseUp(canvasPos, currentLayer->getImage());
            
            // 그리기 명령 생성
            auto command = std::make_unique<DrawCommand>(
                currentLayer->getImage(),
                m_beforeDrawing,
                currentLayer->getImage(),
                currentTool->getName()
            );
            
            m_commandManager.executeCommand(std::move(command));
            
            m_isDrawing = false;
        }
    }
    
    void handleShortcuts()
    {
        // Ctrl+Z: 실행 취소
        if (KeyControl.pressed() && KeyZ.down())
        {
            m_commandManager.undo();
        }
        
        // Ctrl+Y 또는 Ctrl+Shift+Z: 다시 실행
        if (KeyControl.pressed() && (KeyY.down() || (KeyShift.pressed() && KeyZ.down())))
        {
            m_commandManager.redo();
        }
        
        // Ctrl+S: 저장
        if (KeyControl.pressed() && KeyS.down())
        {
            saveImage();
        }
        
        // Ctrl+Shift+S: 다른 이름으로 저장
        if (KeyControl.pressed() && KeyShift.pressed() && KeyS.down())
        {
            saveProject();
        }
        
        // Ctrl+O: 열기
        if (KeyControl.pressed() && KeyO.down())
        {
            loadProject();
        }
        
        // Ctrl+N: 새 프로젝트
        if (KeyControl.pressed() && KeyN.down())
        {
            newProject();
        }
    }
    
    void drawCanvas() const
    {
        const RectF canvasRect = m_uiManager.getCanvasRect();
        
        // 캔버스 배경 (체크무늬 패턴)
        drawCheckerboard(canvasRect);
        
        // 레이어 합성하여 그리기
        const auto& layers = m_layerManager.getLayers();
        
        for (const auto& layer : layers)
        {
            if (not layer->isVisible())
                continue;
            
            const Texture& texture = const_cast<Layer*>(layer.get())->getTexture();
            texture.draw(canvasRect.pos, Alpha(static_cast<uint8>(layer->getOpacity() * 255)));
        }
        
        // 캔버스 테두리
        canvasRect.drawFrame(2, ColorF{ 0.3 });
    }
    
    void drawCheckerboard(const RectF& rect) const
    {
        const int32 gridSize = 20;
        const ColorF lightColor{ 0.95 };
        const ColorF darkColor{ 0.85 };
        
        for (int32 y = 0; y < rect.h; y += gridSize)
        {
            for (int32 x = 0; x < rect.w; x += gridSize)
            {
                const bool isLight = ((x / gridSize) + (y / gridSize)) % 2 == 0;
                const ColorF color = isLight ? lightColor : darkColor;
                
                RectF{ rect.x + x, rect.y + y, gridSize, gridSize }.draw(color);
            }
        }
    }
    
    void drawToolPreview() const
    {
        const RectF canvasRect = m_uiManager.getCanvasRect();
        
        if (not canvasRect.mouseOver())
            return;
        
        const auto* currentTool = m_toolManager.getCurrentTool();
        if (not currentTool)
            return;
        
        const Vec2 canvasPos = Cursor::Pos() - canvasRect.pos;
        currentTool->drawPreview(Cursor::Pos());
    }
    
    void saveImage()
    {
        if (const auto path = Dialog::SaveImage())
        {
            m_fileManager.saveAsImage(m_layerManager, path.value());
        }
    }
    
    void saveProject()
    {
        if (const auto path = Dialog::SaveFile({ FileFilter::JSON() }))
        {
            m_fileManager.saveProject(m_layerManager, path.value());
        }
    }
    
    void loadProject()
    {
        if (const auto path = Dialog::OpenFile({ FileFilter::JSON() }))
        {
            if (m_fileManager.loadProject(m_layerManager, path.value()))
            {
                m_commandManager.clear();
            }
        }
    }
    
    void newProject()
    {
        // 확인 대화상자
        if (System::MessageBoxYesNo(U"새 프로젝트를 시작하시겠습니까?\n현재 작업은 저장되지 않습니다."))
        {
            m_layerManager = LayerManager{ EditorConfig::CanvasSize };
            m_commandManager.clear();
        }
    }
};
```

## 25.8 메인 함수

```cpp
// Main.cpp
#include <Siv3D.hpp>
#include "GraphicEditor.h"

void Main()
{
    // 윈도우 설정
    Window::SetTitle(U"Modern C++ 그래픽 에디터");
    Window::Resize(1280, 800);
    Scene::SetBackground(EditorConfig::BackgroundColor);
    
    // 에디터 생성
    GraphicEditor editor;
    
    // 메인 루프
    while (System::Update())
    {
        editor.update();
        editor.draw();
    }
}
```

## 25.9 실습 문제

### 기본 실습

1. **스포이트 도구**: 캔버스의 색상을 선택할 수 있는 스포이트 도구를 구현하라.

2. **텍스트 도구**: 캔버스에 텍스트를 입력할 수 있는 도구를 추가하라.

3. **레이어 복제**: 현재 레이어를 복제하는 기능을 구현하라.

### 중급 실습

4. **선택 영역**: 사각형 또는 자유 형태의 선택 영역을 만들고, 선택 영역 내에서만 그리기가 가능하도록 구현하라.

5. **그라데이션 도구**: 두 색상 사이의 그라데이션을 그리는 도구를 구현하라.

6. **레이어 블렌딩 모드**: 곱하기, 더하기, 오버레이 등 다양한 블렌딩 모드를 지원하라.

### 고급 실습

7. **필터 효과**: 흐림, 선명하게, 모자이크 등의 필터를 구현하라. `std::async`를 사용하여 비동기로 처리하라.

8. **브러시 에디터**: 사용자가 커스텀 브러시를 만들 수 있도록 브러시 에디터를 구현하라.

9. **애니메이션 지원**: 여러 프레임을 관리하고 GIF로 내보낼 수 있는 기능을 추가하라.

## 25.10 심화 내용: 성능 최적화

### 25.10.1 메모리 효율적인 명령 패턴

이미지 전체를 복사하는 대신 변경된 영역만 저장하는 방법이다.

```cpp
// DeltaDrawCommand.h
#pragma once
#include "ICommand.h"

struct PixelChange
{
    Point pos;
    Color oldColor;
    Color newColor;
};

class DeltaDrawCommand : public ICommand
{
public:
    DeltaDrawCommand(Image& targetImage, std::vector<PixelChange> changes, const String& toolName)
        : m_targetImage{ targetImage }
        , m_changes{ std::move(changes) }
        , m_toolName{ toolName }
    {
    }
    
    void execute() override
    {
        for (const auto& change : m_changes)
        {
            if (m_targetImage.size().contains(change.pos))
            {
                m_targetImage[change.pos] = change.newColor;
            }
        }
    }
    
    void undo() override
    {
        for (const auto& change : m_changes)
        {
            if (m_targetImage.size().contains(change.pos))
            {
                m_targetImage[change.pos] = change.oldColor;
            }
        }
    }
    
    String getDescription() const override
    {
        return m_toolName + U" 사용 (" + ToString(m_changes.size()) + U" 픽셀)";
    }
    
private:
    Image& m_targetImage;
    std::vector<PixelChange> m_changes;
    String m_toolName;
};
```

변경된 픽셀만 저장하면 메모리 사용량이 크게 줄어든다. 하지만 변경 사항을 추적하는 오버헤드가 있으므로, 큰 브러시로 넓은 영역을 그릴 때는 전체 이미지 복사가 더 효율적일 수 있다.

### 25.10.2 타일 기반 렌더링

큰 캔버스를 작은 타일로 나누어 필요한 부분만 렌더링한다.

```cpp
// TiledCanvas.h
#pragma once
#include <Siv3D.hpp>

class TiledCanvas
{
public:
    TiledCanvas(const Size& size, int32 tileSize = 256)
        : m_canvasSize{ size }
        , m_tileSize{ tileSize }
    {
        const int32 tilesX = (size.x + tileSize - 1) / tileSize;
        const int32 tilesY = (size.y + tileSize - 1) / tileSize;
        
        m_tiles.resize(tilesX * tilesY);
        
        for (auto& tile : m_tiles)
        {
            tile = Image{ tileSize, tileSize, Palette::Transparent };
        }
    }
    
    void setPixel(const Point& pos, const Color& color)
    {
        const int32 tileX = pos.x / m_tileSize;
        const int32 tileY = pos.y / m_tileSize;
        
        if (tileX < 0 || tileY < 0)
            return;
        
        const int32 tilesX = (m_canvasSize.x + m_tileSize - 1) / m_tileSize;
        const int32 tileIndex = tileY * tilesX + tileX;
        
        if (tileIndex >= static_cast<int32>(m_tiles.size()))
            return;
        
        const Point localPos{
            pos.x % m_tileSize,
            pos.y % m_tileSize
        };
        
        if (m_tiles[tileIndex].size().contains(localPos))
        {
            m_tiles[tileIndex][localPos] = color;
            m_dirtyTiles.insert(tileIndex);
        }
    }
    
    void updateTextures()
    {
        for (int32 tileIndex : m_dirtyTiles)
        {
            // 텍스처 업데이트 (실제로는 DynamicTexture 사용)
        }
        
        m_dirtyTiles.clear();
    }
    
private:
    Size m_canvasSize;
    int32 m_tileSize;
    std::vector<Image> m_tiles;
    std::set<int32> m_dirtyTiles;  // 변경된 타일 인덱스
};
```

### 25.10.3 비동기 저장

큰 프로젝트를 저장할 때 UI가 멈추지 않도록 비동기로 처리한다.

```cpp
#include <future>

class FileManager
{
private:
    std::future<bool> m_saveFuture;
    
public:
    void saveProjectAsync(const LayerManager& layerManager, const FilePath& path)
    {
        // 이전 저장이 완료되지 않았다면 대기
        if (m_saveFuture.valid())
        {
            m_saveFuture.wait();
        }
        
        // 레이어 데이터 복사 (원본 보호)
        std::vector<Image> layerImages;
        std::vector<String> layerNames;
        
        for (const auto& layer : layerManager.getLayers())
        {
            layerImages.push_back(layer->getImage());
            layerNames.push_back(layer->getName());
        }
        
        // 비동기 저장
        m_saveFuture = std::async(std::launch::async,
            [layerImages = std::move(layerImages), 
             layerNames = std::move(layerNames), 
             path]() -> bool
            {
                // 저장 작업 수행
                for (size_t i = 0; i < layerImages.size(); ++i)
                {
                    const String layerPath = path + U"_layer_" + ToString(i) + U".png";
                    
                    if (not layerImages[i].save(layerPath))
                    {
                        return false;
                    }
                }
                
                return true;
            });
    }
    
    bool isSaving() const
    {
        return m_saveFuture.valid() && 
               m_saveFuture.wait_for(std::chrono::seconds(0)) != std::future_status::ready;
    }
};
```

`std::async`를 사용하여 저장 작업을 백그라운드에서 수행한다. 원본 데이터를 복사하여 비동기 작업 중에도 사용자가 계속 편집할 수 있도록 한다.

## 25.11 요약

이번 장에서는 도구 패턴과 명령 패턴을 활용한 본격적인 그래픽 에디터를 구현했다. 주요 학습 내용은 다음과 같다:

**디자인 패턴:**
- 도구 패턴으로 확장 가능한 도구 시스템 구현
- 명령 패턴으로 실행 취소/다시 실행 기능 구현
- 인터페이스를 통한 다형성 활용

**Modern C++ 기능:**
- `std::unique_ptr`로 객체 소유권 관리
- `std::vector`와 `std::deque`로 효율적인 컬렉션 관리
- `std::optional`로 명확한 값 부재 표현
- `std::async`로 비동기 작업 처리

**그래픽 에디터 핵심 기능:**
- 다양한 그리기 도구 구현
- 레이어 시스템으로 복잡한 작업 지원
- 프로젝트 파일 저장 및 불러오기
- 직관적인 사용자 인터페이스

다음 장에서는 멀티스레딩을 활용한 데이터 시각화 도구를 만들면서 성능 최적화 기법을 배운다.

 