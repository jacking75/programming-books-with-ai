# ëª¨ë˜ C++ë¡œ ì‹œì‘í•˜ëŠ” ì•ˆì „í•˜ê³  ì‰¬ìš´ C++ í”„ë¡œê·¸ë˜ë° 

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  
  
# Chapter 25: í”„ë¡œì íŠ¸ 2 - ê·¸ë˜í”½ ì—ë””í„°

ì´ë²ˆ ì¥ì—ì„œëŠ” ë³¸ê²©ì ì¸ ê·¸ë˜í”½ ì—ë””í„°ë¥¼ ë§Œë“¤ë©´ì„œ Modern C++ì˜ ê³ ê¸‰ ë””ìì¸ íŒ¨í„´ë“¤ì„ ì‹¤ì „ì— ì ìš©í•œë‹¤. ë„êµ¬ íŒ¨í„´(Tool Pattern)ê³¼ ëª…ë ¹ íŒ¨í„´(Command Pattern)ì„ í™œìš©í•˜ì—¬ í™•ì¥ ê°€ëŠ¥í•˜ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ êµ¬ì¡°ë¥¼ ì„¤ê³„í•˜ê³ , ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰, ë ˆì´ì–´ ì‹œìŠ¤í…œ, íŒŒì¼ ì…ì¶œë ¥ ë“± ì „ë¬¸ì ì¸ ê·¸ë˜í”½ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ í•µì‹¬ ê¸°ëŠ¥ë“¤ì„ êµ¬í˜„í•œë‹¤.

## 25.1 í”„ë¡œì íŠ¸ ê°œìš”ì™€ ì„¤ê³„

### 25.1.1 ê·¸ë˜í”½ ì—ë””í„°ì˜ ìš”êµ¬ì‚¬í•­

ìš°ë¦¬ê°€ ë§Œë“¤ ê·¸ë˜í”½ ì—ë””í„°ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤:

**í•µì‹¬ ê¸°ëŠ¥:**
- íœ, ë¸ŒëŸ¬ì‹œ, ì§€ìš°ê°œ, ë„í˜• ë„êµ¬ ë“± ë‹¤ì–‘í•œ ê·¸ë¦¬ê¸° ë„êµ¬
- ìƒ‰ìƒ ì„ íƒ ë° ë¸ŒëŸ¬ì‹œ í¬ê¸° ì¡°ì ˆ
- ì‹¤í–‰ ì·¨ì†Œ(Undo) ë° ë‹¤ì‹œ ì‹¤í–‰(Redo)
- ë ˆì´ì–´ ì‹œìŠ¤í…œ (ì¶”ê°€, ì‚­ì œ, ìˆœì„œ ë³€ê²½, í‘œì‹œ/ìˆ¨ê¹€)
- ì´ë¯¸ì§€ ì €ì¥ ë° ë¶ˆëŸ¬ì˜¤ê¸°

**ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤:**
- ë„êµ¬ íŒ”ë ˆíŠ¸
- ìƒ‰ìƒ ì„ íƒê¸°
- ë ˆì´ì–´ íŒ¨ë„
- ìº”ë²„ìŠ¤ ì˜ì—­
- ë©”ë‰´ ë°”

### 25.1.2 ì•„í‚¤í…ì²˜ ì„¤ê³„

Modern C++ì˜ ì¥ì ì„ ìµœëŒ€í•œ í™œìš©í•˜ì—¬ í™•ì¥ ê°€ëŠ¥í•˜ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ êµ¬ì¡°ë¥¼ ì„¤ê³„í•œë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         GraphicEditor (Main)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  - ToolManager                          â”‚
â”‚  - CommandManager (Undo/Redo)           â”‚
â”‚  - LayerManager                         â”‚
â”‚  - UIManager                            â”‚
â”‚  - FileManager                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                â”‚
         â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ITool      â”‚   â”‚   ICommand   â”‚
â”‚ (Interface)  â”‚   â”‚ (Interface)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - PenTool    â”‚   â”‚ - DrawCmd    â”‚
â”‚ - BrushTool  â”‚   â”‚ - EraseCmd   â”‚
â”‚ - EraserTool â”‚   â”‚ - LayerCmd   â”‚
â”‚ - ShapeTool  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì„¤ê³„ ì›ì¹™:**
- **ë‹¨ì¼ ì±…ì„ ì›ì¹™**: ê° í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°–ëŠ”ë‹¤
- **ê°œë°©-íì‡„ ì›ì¹™**: í™•ì¥ì—ëŠ” ì—´ë ¤ìˆê³  ìˆ˜ì •ì—ëŠ” ë‹«í˜€ìˆë‹¤
- **ì˜ì¡´ì„± ì—­ì „**: êµ¬ì²´ì ì¸ êµ¬í˜„ì´ ì•„ë‹Œ ì¶”ìƒí™”ì— ì˜ì¡´í•œë‹¤

### 25.1.3 í”„ë¡œì íŠ¸ êµ¬ì¡°

```cpp
// EditorConfig.h
#pragma once
#include <Siv3D.hpp>

namespace EditorConfig
{
    // ìº”ë²„ìŠ¤ ì„¤ì •
    constexpr Size CanvasSize{ 800, 600 };
    constexpr Point CanvasOffset{ 220, 80 };
    
    // UI ì„¤ì •
    constexpr int32 ToolbarWidth = 200;
    constexpr int32 MenuBarHeight = 60;
    constexpr int32 LayerPanelWidth = 200;
    
    // ìƒ‰ìƒ
    const ColorF BackgroundColor{ 0.95, 0.95, 0.95 };
    const ColorF CanvasColor{ 1.0, 1.0, 1.0 };
    const ColorF UIBackgroundColor{ 0.9, 0.9, 0.9 };
    const ColorF UIBorderColor{ 0.7, 0.7, 0.7 };
    
    // ê¸°ë³¸ê°’
    constexpr int32 DefaultBrushSize = 3;
    constexpr int32 MinBrushSize = 1;
    constexpr int32 MaxBrushSize = 50;
    
    // ë ˆì´ì–´ ì„¤ì •
    constexpr int32 MaxLayers = 10;
}
```

## 25.2 ë„êµ¬ íŒ¨í„´ê³¼ ëª…ë ¹ íŒ¨í„´ ì ìš©

### 25.2.1 ë„êµ¬ ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„

ë„êµ¬ íŒ¨í„´ì„ ì‚¬ìš©í•˜ë©´ ê° ë„êµ¬ì˜ ë™ì‘ì„ ë…ë¦½ì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```cpp
// ITool.h
#pragma once
#include <Siv3D.hpp>

// ë„êµ¬ì˜ ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤
class ITool
{
public:
    virtual ~ITool() = default;
    
    // ë„êµ¬ ì´ë¦„
    virtual String getName() const = 0;
    
    // ë„êµ¬ ì•„ì´ì½˜
    virtual Texture getIcon() const = 0;
    
    // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
    virtual void onMouseDown(const Vec2& pos, Image& canvas) = 0;
    virtual void onMouseMove(const Vec2& pos, Image& canvas) = 0;
    virtual void onMouseUp(const Vec2& pos, Image& canvas) = 0;
    
    // ë„êµ¬ ì„¤ì •
    virtual void setColor(const Color& color) { m_color = color; }
    virtual void setBrushSize(int32 size) { m_brushSize = size; }
    
    // í˜„ì¬ ì„¤ì • ë°˜í™˜
    virtual Color getColor() const { return m_color; }
    virtual int32 getBrushSize() const { return m_brushSize; }
    
    // í”„ë¦¬ë·° ê·¸ë¦¬ê¸° (í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë„êµ¬ íš¨ê³¼ ë¯¸ë¦¬ë³´ê¸°)
    virtual void drawPreview(const Vec2& pos) const = 0;
    
protected:
    Color m_color{ Palette::Black };
    int32 m_brushSize = EditorConfig::DefaultBrushSize;
};
```

ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë©´ ìƒˆë¡œìš´ ë„êµ¬ë¥¼ ì¶”ê°€í•  ë•Œ ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì§€ ì•Šì•„ë„ ëœë‹¤. ì´ê²ƒì´ ê°œë°©-íì‡„ ì›ì¹™ì˜ í•µì‹¬ì´ë‹¤.

### 25.2.2 íœ ë„êµ¬ êµ¬í˜„

```cpp
// PenTool.h
#pragma once
#include "ITool.h"

class PenTool : public ITool
{
public:
    PenTool()
    {
        // ì•„ì´ì½˜ ë¡œë“œ (ë˜ëŠ” í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ ìƒì„±)
        m_icon = Texture{ Emoji{ U"âœï¸" } };
    }
    
    String getName() const override
    {
        return U"íœ";
    }
    
    Texture getIcon() const override
    {
        return m_icon;
    }
    
    void onMouseDown(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = true;
        m_lastPos = pos;
        
        // ì  ê·¸ë¦¬ê¸°
        drawPoint(pos, canvas);
    }
    
    void onMouseMove(const Vec2& pos, Image& canvas) override
    {
        if (not m_isDrawing)
            return;
        
        // ì´ì „ ìœ„ì¹˜ì™€ í˜„ì¬ ìœ„ì¹˜ë¥¼ ì—°ê²°í•˜ëŠ” ì„  ê·¸ë¦¬ê¸°
        drawLine(m_lastPos, pos, canvas);
        m_lastPos = pos;
    }
    
    void onMouseUp(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = false;
    }
    
    void drawPreview(const Vec2& pos) const override
    {
        // íœ ìœ„ì¹˜ì— ì‘ì€ ì› í‘œì‹œ
        Circle{ pos, m_brushSize / 2.0 }
            .drawFrame(1.0, m_color);
    }
    
private:
    Texture m_icon;
    bool m_isDrawing = false;
    Vec2 m_lastPos{ 0, 0 };
    
    void drawPoint(const Vec2& pos, Image& canvas)
    {
        const Point p = pos.asPoint();
        
        if (not canvas.size().contains(p))
            return;
        
        canvas[p] = m_color;
    }
    
    void drawLine(const Vec2& from, const Vec2& to, Image& canvas)
    {
        // Bresenham's ë¼ì¸ ì•Œê³ ë¦¬ì¦˜ ë˜ëŠ” Siv3Dì˜ ì„  ê·¸ë¦¬ê¸° í™œìš©
        Line{ from, to }.overwrite(canvas, m_brushSize, m_color);
    }
};
```

Modern C++ì˜ `override` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ìƒ í•¨ìˆ˜ë¥¼ ì¬ì •ì˜í•¨ì„ ëª…ì‹œí•œë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ì˜¤íƒ€ë¥¼ ì¡ì•„ë‚´ëŠ” ë° ë„ì›€ì´ ëœë‹¤.

### 25.2.3 ë¸ŒëŸ¬ì‹œ ë„êµ¬ êµ¬í˜„

```cpp
// BrushTool.h
#pragma once
#include "ITool.h"

class BrushTool : public ITool
{
public:
    BrushTool()
    {
        m_icon = Texture{ Emoji{ U"ğŸ–Œï¸" } };
    }
    
    String getName() const override
    {
        return U"ë¸ŒëŸ¬ì‹œ";
    }
    
    Texture getIcon() const override
    {
        return m_icon;
    }
    
    void onMouseDown(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = true;
        drawBrush(pos, canvas);
    }
    
    void onMouseMove(const Vec2& pos, Image& canvas) override
    {
        if (not m_isDrawing)
            return;
        
        drawBrush(pos, canvas);
    }
    
    void onMouseUp(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = false;
    }
    
    void drawPreview(const Vec2& pos) const override
    {
        Circle{ pos, m_brushSize }
            .drawFrame(1.0, m_color);
    }
    
    void setOpacity(double opacity)
    {
        m_opacity = Clamp(opacity, 0.0, 1.0);
    }
    
private:
    Texture m_icon;
    bool m_isDrawing = false;
    double m_opacity = 0.5;
    
    void drawBrush(const Vec2& pos, Image& canvas)
    {
        // ë¶€ë“œëŸ¬ìš´ ë¸ŒëŸ¬ì‹œ íš¨ê³¼ (ì•ŒíŒŒ ë¸”ë Œë”©)
        const int32 radius = m_brushSize;
        const Point center = pos.asPoint();
        
        for (int32 y = -radius; y <= radius; ++y)
        {
            for (int32 x = -radius; x <= radius; ++x)
            {
                const Point p{ center.x + x, center.y + y };
                
                if (not canvas.size().contains(p))
                    continue;
                
                const double distance = Vec2{ x, y }.length();
                
                if (distance <= radius)
                {
                    // ì¤‘ì‹¬ì—ì„œ ë©€ìˆ˜ë¡ íˆ¬ëª…ë„ ê°ì†Œ
                    const double alpha = (1.0 - distance / radius) * m_opacity;
                    
                    // ì•ŒíŒŒ ë¸”ë Œë”©
                    const Color existingColor = canvas[p];
                    const Color blendedColor = Alpha(
                        static_cast<uint8>(m_color.r * alpha + existingColor.r * (1 - alpha)),
                        static_cast<uint8>(m_color.g * alpha + existingColor.g * (1 - alpha)),
                        static_cast<uint8>(m_color.b * alpha + existingColor.b * (1 - alpha))
                    );
                    
                    canvas[p] = blendedColor;
                }
            }
        }
    }
};
```

ë¸ŒëŸ¬ì‹œ ë„êµ¬ëŠ” íœë³´ë‹¤ ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œë‹¤. ê±°ë¦¬ ê¸°ë°˜ ì•ŒíŒŒ ë¸”ë Œë”©ìœ¼ë¡œ ë¶€ë“œëŸ¬ìš´ íš¨ê³¼ë¥¼ ë§Œë“ ë‹¤.

### 25.2.4 ë„í˜• ë„êµ¬ êµ¬í˜„

```cpp
// ShapeTool.h
#pragma once
#include "ITool.h"

enum class ShapeType
{
    Rectangle,
    Circle,
    Line,
    Triangle
};

class ShapeTool : public ITool
{
public:
    ShapeTool(ShapeType type)
        : m_shapeType{ type }
    {
        m_icon = Texture{ Emoji{ getShapeEmoji() } };
    }
    
    String getName() const override
    {
        switch (m_shapeType)
        {
        case ShapeType::Rectangle:
            return U"ì‚¬ê°í˜•";
        case ShapeType::Circle:
            return U"ì›";
        case ShapeType::Line:
            return U"ì§ì„ ";
        case ShapeType::Triangle:
            return U"ì‚¼ê°í˜•";
        default:
            return U"ë„í˜•";
        }
    }
    
    Texture getIcon() const override
    {
        return m_icon;
    }
    
    void onMouseDown(const Vec2& pos, Image& canvas) override
    {
        m_isDrawing = true;
        m_startPos = pos;
        m_endPos = pos;
    }
    
    void onMouseMove(const Vec2& pos, Image& canvas) override
    {
        if (m_isDrawing)
        {
            m_endPos = pos;
        }
    }
    
    void onMouseUp(const Vec2& pos, Image& canvas) override
    {
        if (m_isDrawing)
        {
            m_endPos = pos;
            drawShape(canvas);
            m_isDrawing = false;
        }
    }
    
    void drawPreview(const Vec2& pos) const override
    {
        if (not m_isDrawing)
        {
            Circle{ pos, m_brushSize / 2.0 }
                .drawFrame(1.0, m_color);
            return;
        }
        
        // í˜„ì¬ ê·¸ë¦¬ê³  ìˆëŠ” ë„í˜• ë¯¸ë¦¬ë³´ê¸°
        drawShapePreview();
    }
    
    void setFilled(bool filled)
    {
        m_filled = filled;
    }
    
private:
    Texture m_icon;
    ShapeType m_shapeType;
    bool m_isDrawing = false;
    Vec2 m_startPos{ 0, 0 };
    Vec2 m_endPos{ 0, 0 };
    bool m_filled = false;
    
    String getShapeEmoji() const
    {
        switch (m_shapeType)
        {
        case ShapeType::Rectangle:
            return U"â–­";
        case ShapeType::Circle:
            return U"â—‹";
        case ShapeType::Line:
            return U"â•±";
        case ShapeType::Triangle:
            return U"â–³";
        default:
            return U"â—‡";
        }
    }
    
    void drawShape(Image& canvas)
    {
        switch (m_shapeType)
        {
        case ShapeType::Rectangle:
            drawRectangle(canvas);
            break;
        case ShapeType::Circle:
            drawCircle(canvas);
            break;
        case ShapeType::Line:
            drawLine(canvas);
            break;
        case ShapeType::Triangle:
            drawTriangle(canvas);
            break;
        }
    }
    
    void drawRectangle(Image& canvas)
    {
        const RectF rect{ m_startPos, m_endPos };
        
        if (m_filled)
        {
            rect.overwrite(canvas, m_color);
        }
        else
        {
            rect.overwriteFrame(canvas, m_brushSize, m_color);
        }
    }
    
    void drawCircle(Image& canvas)
    {
        const Vec2 center = (m_startPos + m_endPos) / 2.0;
        const double radius = m_startPos.distanceFrom(m_endPos) / 2.0;
        
        if (m_filled)
        {
            Circle{ center, radius }.overwrite(canvas, m_color);
        }
        else
        {
            Circle{ center, radius }.overwriteFrame(canvas, m_brushSize, m_color);
        }
    }
    
    void drawLine(Image& canvas)
    {
        Line{ m_startPos, m_endPos }.overwrite(canvas, m_brushSize, m_color);
    }
    
    void drawTriangle(Image& canvas)
    {
        const Vec2 p1 = m_startPos;
        const Vec2 p2{ m_endPos.x, m_startPos.y };
        const Vec2 p3{ (m_startPos.x + m_endPos.x) / 2.0, m_endPos.y };
        
        const Triangle triangle{ p1, p2, p3 };
        
        if (m_filled)
        {
            triangle.overwrite(canvas, m_color);
        }
        else
        {
            triangle.overwriteFrame(canvas, m_brushSize, m_color);
        }
    }
    
    void drawShapePreview() const
    {
        // í™”ë©´ì— ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ (Imageê°€ ì•„ë‹Œ í™”ë©´ì— ì§ì ‘)
        switch (m_shapeType)
        {
        case ShapeType::Rectangle:
            RectF{ m_startPos, m_endPos }
                .drawFrame(2.0, m_color);
            break;
        case ShapeType::Circle:
            {
                const Vec2 center = (m_startPos + m_endPos) / 2.0;
                const double radius = m_startPos.distanceFrom(m_endPos) / 2.0;
                Circle{ center, radius }.drawFrame(2.0, m_color);
            }
            break;
        case ShapeType::Line:
            Line{ m_startPos, m_endPos }.draw(m_brushSize, m_color);
            break;
        case ShapeType::Triangle:
            {
                const Vec2 p1 = m_startPos;
                const Vec2 p2{ m_endPos.x, m_startPos.y };
                const Vec2 p3{ (m_startPos.x + m_endPos.x) / 2.0, m_endPos.y };
                Triangle{ p1, p2, p3 }.drawFrame(2.0, m_color);
            }
            break;
        }
    }
};
```

ë„í˜• ë„êµ¬ëŠ” ìƒì„±ìì—ì„œ ë„í˜• íƒ€ì…ì„ ë°›ì•„ í•˜ë‚˜ì˜ í´ë˜ìŠ¤ë¡œ ì—¬ëŸ¬ ë„í˜•ì„ ì²˜ë¦¬í•œë‹¤. ì´ëŠ” ì½”ë“œ ì¤‘ë³µì„ ì¤„ì´ë©´ì„œë„ í™•ì¥ì„±ì„ ìœ ì§€í•˜ëŠ” ë°©ë²•ì´ë‹¤.

### 25.2.5 ë„êµ¬ ê´€ë¦¬ì

```cpp
// ToolManager.h
#pragma once
#include "ITool.h"
#include <memory>
#include <vector>

class ToolManager
{
public:
    ToolManager()
    {
        initializeTools();
    }
    
    // í˜„ì¬ í™œì„± ë„êµ¬ ë°˜í™˜
    ITool* getCurrentTool() const
    {
        if (m_currentToolIndex < m_tools.size())
        {
            return m_tools[m_currentToolIndex].get();
        }
        return nullptr;
    }
    
    // ë„êµ¬ ì„ íƒ
    void selectTool(size_t index)
    {
        if (index < m_tools.size())
        {
            m_currentToolIndex = index;
        }
    }
    
    // ëª¨ë“  ë„êµ¬ ë°˜í™˜
    const std::vector<std::unique_ptr<ITool>>& getTools() const
    {
        return m_tools;
    }
    
    size_t getCurrentToolIndex() const
    {
        return m_currentToolIndex;
    }
    
private:
    std::vector<std::unique_ptr<ITool>> m_tools;
    size_t m_currentToolIndex = 0;
    
    void initializeTools()
    {
        // ë‹¤ì–‘í•œ ë„êµ¬ ì¶”ê°€
        m_tools.push_back(std::make_unique<PenTool>());
        m_tools.push_back(std::make_unique<BrushTool>());
        m_tools.push_back(std::make_unique<EraserTool>());
        m_tools.push_back(std::make_unique<ShapeTool>(ShapeType::Rectangle));
        m_tools.push_back(std::make_unique<ShapeTool>(ShapeType::Circle));
        m_tools.push_back(std::make_unique<ShapeTool>(ShapeType::Line));
    }
};
```

`std::unique_ptr`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë„êµ¬ ê°ì²´ì˜ ì†Œìœ ê¶Œì„ ëª…í™•í•˜ê²Œ ê´€ë¦¬í•œë‹¤. `std::vector`ì— `std::unique_ptr`ë¥¼ ì €ì¥í•˜ë©´ ë³µì‚¬ëŠ” ë¶ˆê°€ëŠ¥í•˜ì§€ë§Œ ì´ë™ì€ ê°€ëŠ¥í•˜ë‹¤.

### 25.2.6 ì§€ìš°ê°œ ë„êµ¬

```cpp
// EraserTool.h
#pragma once
#include "ITool.h"

class EraserTool : public ITool
{
public:
    EraserTool()
    {
        m_icon = Texture{ Emoji{ U"ğŸ§¹" } };
        m_color = Palette::White;  // ì§€ìš°ê°œëŠ” í°ìƒ‰ìœ¼ë¡œ ê·¸ë¦¼
    }
    
    String getName() const override
    {
        return U"ì§€ìš°ê°œ";
    }
    
    Texture getIcon() const override
    {
        return m_icon;
    }
    
    void onMouseDown(const Vec2& pos, Image& canvas) override
    {
        m_isErasing = true;
        erase(pos, canvas);
    }
    
    void onMouseMove(const Vec2& pos, Image& canvas) override
    {
        if (m_isErasing)
        {
            erase(pos, canvas);
        }
    }
    
    void onMouseUp(const Vec2& pos, Image& canvas) override
    {
        m_isErasing = false;
    }
    
    void drawPreview(const Vec2& pos) const override
    {
        Circle{ pos, m_brushSize }
            .drawFrame(1.0, ColorF{ 0.5 });
    }
    
    // ì§€ìš°ê°œëŠ” ìƒ‰ìƒ ë³€ê²½ ë¶ˆê°€
    void setColor(const Color& color) override
    {
        // ì•„ë¬´ ë™ì‘ë„ í•˜ì§€ ì•ŠìŒ
    }
    
private:
    Texture m_icon;
    bool m_isErasing = false;
    
    void erase(const Vec2& pos, Image& canvas)
    {
        Circle{ pos, m_brushSize }.overwrite(canvas, Palette::White);
    }
};
```

## 25.3 ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ê¸°ëŠ¥

### 25.3.1 ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„

ëª…ë ¹ íŒ¨í„´ì„ ì‚¬ìš©í•˜ë©´ ëª¨ë“  ì‘ì—…ì„ ê°ì²´ë¡œ ë§Œë“¤ì–´ ì €ì¥í•˜ê³  ì·¨ì†Œí•  ìˆ˜ ìˆë‹¤.

```cpp
// ICommand.h
#pragma once
#include <Siv3D.hpp>

// ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤
class ICommand
{
public:
    virtual ~ICommand() = default;
    
    // ëª…ë ¹ ì‹¤í–‰
    virtual void execute() = 0;
    
    // ëª…ë ¹ ì·¨ì†Œ
    virtual void undo() = 0;
    
    // ëª…ë ¹ ë‹¤ì‹œ ì‹¤í–‰
    virtual void redo()
    {
        execute();  // ê¸°ë³¸ì ìœ¼ë¡œ ë‹¤ì‹œ ì‹¤í–‰ì€ ì‹¤í–‰ê³¼ ë™ì¼
    }
    
    // ëª…ë ¹ ì„¤ëª… (ë””ë²„ê¹… ë° UIìš©)
    virtual String getDescription() const = 0;
};
```

### 25.3.2 ê·¸ë¦¬ê¸° ëª…ë ¹ êµ¬í˜„

```cpp
// DrawCommand.h
#pragma once
#include "ICommand.h"

class DrawCommand : public ICommand
{
public:
    DrawCommand(Image& targetImage, const Image& beforeState, const Image& afterState, const String& toolName)
        : m_targetImage{ targetImage }
        , m_beforeState{ beforeState }
        , m_afterState{ afterState }
        , m_toolName{ toolName }
    {
    }
    
    void execute() override
    {
        m_targetImage = m_afterState;
    }
    
    void undo() override
    {
        m_targetImage = m_beforeState;
    }
    
    String getDescription() const override
    {
        return m_toolName + U" ì‚¬ìš©";
    }
    
private:
    Image& m_targetImage;
    Image m_beforeState;  // ì‘ì—… ì „ ì´ë¯¸ì§€
    Image m_afterState;   // ì‘ì—… í›„ ì´ë¯¸ì§€
    String m_toolName;
};
```

ì´ë¯¸ì§€ ì „ì²´ë¥¼ ë³µì‚¬í•˜ì—¬ ì €ì¥í•˜ëŠ” ë°©ì‹ì€ ë©”ëª¨ë¦¬ë¥¼ ë§ì´ ì‚¬ìš©í•˜ì§€ë§Œ, êµ¬í˜„ì´ ê°„ë‹¨í•˜ê³  ëª¨ë“  ì¢…ë¥˜ì˜ ë³€ê²½ì„ ì§€ì›í•œë‹¤. ë” íš¨ìœ¨ì ì¸ ë°©ë²•ì€ ë³€ê²½ëœ ì˜ì—­ë§Œ ì €ì¥í•˜ëŠ” ê²ƒì´ì§€ë§Œ, ë³µì¡ë„ê°€ ì¦ê°€í•œë‹¤.

### 25.3.3 ëª…ë ¹ ê´€ë¦¬ì

```cpp
// CommandManager.h
#pragma once
#include "ICommand.h"
#include <memory>
#include <deque>

class CommandManager
{
public:
    // ìƒˆ ëª…ë ¹ ì‹¤í–‰ ë° íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
    void executeCommand(std::unique_ptr<ICommand> command)
    {
        command->execute();
        
        // í˜„ì¬ ìœ„ì¹˜ ì´í›„ì˜ ëª¨ë“  ëª…ë ¹ ì‚­ì œ (ìƒˆë¡œìš´ ë¶„ê¸°)
        m_undoStack.erase(
            m_undoStack.begin() + m_currentIndex,
            m_undoStack.end()
        );
        
        // ìƒˆ ëª…ë ¹ ì¶”ê°€
        m_undoStack.push_back(std::move(command));
        m_currentIndex = m_undoStack.size();
        
        // íˆìŠ¤í† ë¦¬ í¬ê¸° ì œí•œ
        if (m_undoStack.size() > m_maxHistorySize)
        {
            m_undoStack.pop_front();
            --m_currentIndex;
        }
    }
    
    // ì‹¤í–‰ ì·¨ì†Œ
    bool undo()
    {
        if (not canUndo())
            return false;
        
        --m_currentIndex;
        m_undoStack[m_currentIndex]->undo();
        return true;
    }
    
    // ë‹¤ì‹œ ì‹¤í–‰
    bool redo()
    {
        if (not canRedo())
            return false;
        
        m_undoStack[m_currentIndex]->redo();
        ++m_currentIndex;
        return true;
    }
    
    // ì‹¤í–‰ ì·¨ì†Œ ê°€ëŠ¥ ì—¬ë¶€
    bool canUndo() const
    {
        return m_currentIndex > 0;
    }
    
    // ë‹¤ì‹œ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€
    bool canRedo() const
    {
        return m_currentIndex < m_undoStack.size();
    }
    
    // íˆìŠ¤í† ë¦¬ ì´ˆê¸°í™”
    void clear()
    {
        m_undoStack.clear();
        m_currentIndex = 0;
    }
    
    // íˆìŠ¤í† ë¦¬ ì •ë³´
    size_t getHistorySize() const
    {
        return m_undoStack.size();
    }
    
    size_t getCurrentIndex() const
    {
        return m_currentIndex;
    }
    
    // íˆìŠ¤í† ë¦¬ ëª©ë¡ (UIìš©)
    std::vector<String> getHistoryList() const
    {
        std::vector<String> history;
        
        for (const auto& command : m_undoStack)
        {
            history.push_back(command->getDescription());
        }
        
        return history;
    }
    
    void setMaxHistorySize(size_t size)
    {
        m_maxHistorySize = size;
    }
    
private:
    std::deque<std::unique_ptr<ICommand>> m_undoStack;
    size_t m_currentIndex = 0;
    size_t m_maxHistorySize = 50;
};
```

`std::deque`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì–‘ìª½ ëì—ì„œ íš¨ìœ¨ì ìœ¼ë¡œ ì‚½ì…ê³¼ ì‚­ì œê°€ ê°€ëŠ¥í•˜ë‹¤. ì¸ë±ìŠ¤ ê¸°ë°˜ ì ‘ê·¼ìœ¼ë¡œ íŠ¹ì • ëª…ë ¹ì„ ë¹ ë¥´ê²Œ ì°¾ì„ ìˆ˜ ìˆë‹¤.

**Undo/Redo ë™ì‘ ì›ë¦¬:**

```
ì´ˆê¸° ìƒíƒœ: [ ]
           ^
         í˜„ì¬

ê·¸ë¦¬ê¸° 1: [Cmd1]
                ^
              í˜„ì¬

ê·¸ë¦¬ê¸° 2: [Cmd1, Cmd2]
                      ^
                    í˜„ì¬

Undo:     [Cmd1, Cmd2]
                ^
              í˜„ì¬ (Cmd2ë¥¼ undoí•¨)

ê·¸ë¦¬ê¸° 3: [Cmd1, Cmd3]  // Cmd2ëŠ” ì‚­ì œë¨
                      ^
                    í˜„ì¬

Redo:     ë¶ˆê°€ëŠ¥ (í˜„ì¬ê°€ ëì— ìˆìŒ)
```

### 25.3.4 ëª…ë ¹ íŒ¨í„´ ì‚¬ìš© ì˜ˆì œ

```cpp
// ê·¸ë˜í”½ ì—ë””í„°ì—ì„œ ëª…ë ¹ ì‚¬ìš©
class GraphicEditor
{
private:
    CommandManager m_commandManager;
    Image m_currentLayer;
    
public:
    void handleDrawing(ITool* tool, const Vec2& pos)
    {
        // ì‘ì—… ì „ ì´ë¯¸ì§€ ì €ì¥
        const Image beforeState = m_currentLayer;
        
        // ë„êµ¬ë¡œ ê·¸ë¦¬ê¸°
        tool->onMouseDown(pos, m_currentLayer);
        
        // ì‘ì—… í›„ ì´ë¯¸ì§€ ì €ì¥
        const Image afterState = m_currentLayer;
        
        // ëª…ë ¹ ìƒì„± ë° ì‹¤í–‰
        auto command = std::make_unique<DrawCommand>(
            m_currentLayer,
            beforeState,
            afterState,
            tool->getName()
        );
        
        m_commandManager.executeCommand(std::move(command));
    }
    
    void undo()
    {
        if (m_commandManager.undo())
        {
            Print << U"ì‹¤í–‰ ì·¨ì†Œ ì™„ë£Œ";
        }
    }
    
    void redo()
    {
        if (m_commandManager.redo())
        {
            Print << U"ë‹¤ì‹œ ì‹¤í–‰ ì™„ë£Œ";
        }
    }
};
```

## 25.4 ë ˆì´ì–´ ì‹œìŠ¤í…œ êµ¬í˜„

### 25.4.1 ë ˆì´ì–´ í´ë˜ìŠ¤ ì„¤ê³„

```cpp
// Layer.h
#pragma once
#include <Siv3D.hpp>

class Layer
{
public:
    Layer(const Size& size, const String& name = U"ë ˆì´ì–´")
        : m_image{ size, Palette::Transparent }
        , m_texture{ m_image }
        , m_name{ name }
    {
    }
    
    // ì´ë¯¸ì§€ ì ‘ê·¼
    Image& getImage()
    {
        m_needsUpdate = true;
        return m_image;
    }
    
    const Image& getImage() const
    {
        return m_image;
    }
    
    // í…ìŠ¤ì²˜ ì—…ë°ì´íŠ¸ ë° ë°˜í™˜
    const Texture& getTexture()
    {
        if (m_needsUpdate)
        {
            m_texture.fill(m_image);
            m_needsUpdate = false;
        }
        
        return m_texture;
    }
    
    // ë ˆì´ì–´ ì†ì„±
    void setName(const String& name)
    {
        m_name = name;
    }
    
    String getName() const
    {
        return m_name;
    }
    
    void setVisible(bool visible)
    {
        m_visible = visible;
    }
    
    bool isVisible() const
    {
        return m_visible;
    }
    
    void setOpacity(double opacity)
    {
        m_opacity = Clamp(opacity, 0.0, 1.0);
    }
    
    double getOpacity() const
    {
        return m_opacity;
    }
    
    void setLocked(bool locked)
    {
        m_locked = locked;
    }
    
    bool isLocked() const
    {
        return m_locked;
    }
    
    // ë ˆì´ì–´ ì´ˆê¸°í™”
    void clear(const Color& color = Palette::Transparent)
    {
        m_image.fill(color);
        m_needsUpdate = true;
    }
    
private:
    Image m_image;
    DynamicTexture m_texture;
    String m_name;
    bool m_visible = true;
    bool m_locked = false;
    double m_opacity = 1.0;
    bool m_needsUpdate = false;
};
```

`DynamicTexture`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ í…ìŠ¤ì²˜ë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆë‹¤. `m_needsUpdate` í”Œë˜ê·¸ë¡œ ë¶ˆí•„ìš”í•œ ì—…ë°ì´íŠ¸ë¥¼ ë°©ì§€í•œë‹¤.

### 25.4.2 ë ˆì´ì–´ ê´€ë¦¬ì

```cpp
// LayerManager.h
#pragma once
#include "Layer.h"
#include <memory>
#include <vector>

class LayerManager
{
public:
    LayerManager(const Size& canvasSize)
        : m_canvasSize{ canvasSize }
    {
        // ê¸°ë³¸ ë ˆì´ì–´ ìƒì„±
        addLayer(U"ë°°ê²½");
    }
    
    // ë ˆì´ì–´ ì¶”ê°€
    size_t addLayer(const String& name = U"ìƒˆ ë ˆì´ì–´")
    {
        if (m_layers.size() >= EditorConfig::MaxLayers)
        {
            return m_currentLayerIndex;
        }
        
        auto layer = std::make_unique<Layer>(m_canvasSize, name);
        m_layers.push_back(std::move(layer));
        m_currentLayerIndex = m_layers.size() - 1;
        
        return m_currentLayerIndex;
    }
    
    // ë ˆì´ì–´ ì‚­ì œ
    bool removeLayer(size_t index)
    {
        if (m_layers.size() <= 1)  // ìµœì†Œ 1ê°œëŠ” ìœ ì§€
        {
            return false;
        }
        
        if (index >= m_layers.size())
        {
            return false;
        }
        
        m_layers.erase(m_layers.begin() + index);
        
        // í˜„ì¬ ë ˆì´ì–´ ì¸ë±ìŠ¤ ì¡°ì •
        if (m_currentLayerIndex >= m_layers.size())
        {
            m_currentLayerIndex = m_layers.size() - 1;
        }
        
        return true;
    }
    
    // ë ˆì´ì–´ ìˆœì„œ ë³€ê²½
    bool moveLayer(size_t from, size_t to)
    {
        if (from >= m_layers.size() || to >= m_layers.size())
        {
            return false;
        }
        
        if (from == to)
        {
            return true;
        }
        
        auto layer = std::move(m_layers[from]);
        m_layers.erase(m_layers.begin() + from);
        m_layers.insert(m_layers.begin() + to, std::move(layer));
        
        // í˜„ì¬ ë ˆì´ì–´ ì¸ë±ìŠ¤ ì¡°ì •
        if (m_currentLayerIndex == from)
        {
            m_currentLayerIndex = to;
        }
        else if (from < m_currentLayerIndex && to >= m_currentLayerIndex)
        {
            --m_currentLayerIndex;
        }
        else if (from > m_currentLayerIndex && to <= m_currentLayerIndex)
        {
            ++m_currentLayerIndex;
        }
        
        return true;
    }
    
    // í˜„ì¬ ë ˆì´ì–´ ì„ íƒ
    void selectLayer(size_t index)
    {
        if (index < m_layers.size())
        {
            m_currentLayerIndex = index;
        }
    }
    
    // í˜„ì¬ ë ˆì´ì–´ ë°˜í™˜
    Layer* getCurrentLayer()
    {
        if (m_currentLayerIndex < m_layers.size())
        {
            return m_layers[m_currentLayerIndex].get();
        }
        return nullptr;
    }
    
    const Layer* getCurrentLayer() const
    {
        if (m_currentLayerIndex < m_layers.size())
        {
            return m_layers[m_currentLayerIndex].get();
        }
        return nullptr;
    }
    
    // ëª¨ë“  ë ˆì´ì–´ ë°˜í™˜
    const std::vector<std::unique_ptr<Layer>>& getLayers() const
    {
        return m_layers;
    }
    
    size_t getCurrentLayerIndex() const
    {
        return m_currentLayerIndex;
    }
    
    size_t getLayerCount() const
    {
        return m_layers.size();
    }
    
    // í•©ì„±ëœ ì´ë¯¸ì§€ ìƒì„±
    Image createCompositeImage() const
    {
        Image composite{ m_canvasSize, Palette::White };
        
        // ë ˆì´ì–´ë¥¼ ì•„ë˜ì—ì„œ ìœ„ë¡œ í•©ì„±
        for (const auto& layer : m_layers)
        {
            if (not layer->isVisible())
                continue;
            
            const Image& layerImage = layer->getImage();
            const double opacity = layer->getOpacity();
            
            // ì•ŒíŒŒ ë¸”ë Œë”©
            for (int32 y = 0; y < m_canvasSize.y; ++y)
            {
                for (int32 x = 0; x < m_canvasSize.x; ++x)
                {
                    const Point p{ x, y };
                    const Color layerColor = layerImage[p];
                    
                    if (layerColor.a == 0)
                        continue;
                    
                    const Color existingColor = composite[p];
                    const double alpha = (layerColor.a / 255.0) * opacity;
                    
                    composite[p] = Color{
                        static_cast<uint8>(layerColor.r * alpha + existingColor.r * (1 - alpha)),
                        static_cast<uint8>(layerColor.g * alpha + existingColor.g * (1 - alpha)),
                        static_cast<uint8>(layerColor.b * alpha + existingColor.b * (1 - alpha))
                    };
                }
            }
        }
        
        return composite;
    }
    
private:
    std::vector<std::unique_ptr<Layer>> m_layers;
    size_t m_currentLayerIndex = 0;
    Size m_canvasSize;
};
```

ë ˆì´ì–´ëŠ” ì•„ë˜ì—ì„œ ìœ„ë¡œ ìŒ“ì´ë©°, ìœ„ìª½ ë ˆì´ì–´ê°€ ì•„ë˜ìª½ ë ˆì´ì–´ë¥¼ ë®ëŠ”ë‹¤. ì•ŒíŒŒ ë¸”ë Œë”©ì„ ì‚¬ìš©í•˜ì—¬ íˆ¬ëª…ë„ë¥¼ ì§€ì›í•œë‹¤.

### 25.4.3 ë ˆì´ì–´ ëª…ë ¹

ë ˆì´ì–´ ì¡°ì‘ë„ ëª…ë ¹ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„í•˜ì—¬ ì·¨ì†Œí•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

```cpp
// LayerCommands.h
#pragma once
#include "ICommand.h"
#include "LayerManager.h"

// ë ˆì´ì–´ ì¶”ê°€ ëª…ë ¹
class AddLayerCommand : public ICommand
{
public:
    AddLayerCommand(LayerManager& manager, const String& name)
        : m_manager{ manager }
        , m_layerName{ name }
    {
    }
    
    void execute() override
    {
        m_layerIndex = m_manager.addLayer(m_layerName);
    }
    
    void undo() override
    {
        m_manager.removeLayer(m_layerIndex);
    }
    
    String getDescription() const override
    {
        return U"ë ˆì´ì–´ ì¶”ê°€: " + m_layerName;
    }
    
private:
    LayerManager& m_manager;
    String m_layerName;
    size_t m_layerIndex = 0;
};

// ë ˆì´ì–´ ì‚­ì œ ëª…ë ¹
class RemoveLayerCommand : public ICommand
{
public:
    RemoveLayerCommand(LayerManager& manager, size_t index)
        : m_manager{ manager }
        , m_layerIndex{ index }
    {
        // ì‚­ì œ ì „ì— ë ˆì´ì–´ ë°ì´í„° ë°±ì—…
        if (auto* layer = m_manager.getLayers()[index].get())
        {
            m_layerBackup = layer->getImage();
            m_layerName = layer->getName();
            m_layerVisible = layer->isVisible();
            m_layerOpacity = layer->getOpacity();
        }
    }
    
    void execute() override
    {
        m_manager.removeLayer(m_layerIndex);
    }
    
    void undo() override
    {
        // ë ˆì´ì–´ ë³µì›
        const size_t newIndex = m_manager.addLayer(m_layerName);
        
        if (auto* layer = m_manager.getLayers()[newIndex].get())
        {
            layer->getImage() = m_layerBackup;
            layer->setVisible(m_layerVisible);
            layer->setOpacity(m_layerOpacity);
        }
        
        // ì›ë˜ ìœ„ì¹˜ë¡œ ì´ë™
        m_manager.moveLayer(newIndex, m_layerIndex);
    }
    
    String getDescription() const override
    {
        return U"ë ˆì´ì–´ ì‚­ì œ: " + m_layerName;
    }
    
private:
    LayerManager& m_manager;
    size_t m_layerIndex;
    Image m_layerBackup;
    String m_layerName;
    bool m_layerVisible;
    double m_layerOpacity;
};

// ë ˆì´ì–´ ì´ë™ ëª…ë ¹
class MoveLayerCommand : public ICommand
{
public:
    MoveLayerCommand(LayerManager& manager, size_t from, size_t to)
        : m_manager{ manager }
        , m_fromIndex{ from }
        , m_toIndex{ to }
    {
    }
    
    void execute() override
    {
        m_manager.moveLayer(m_fromIndex, m_toIndex);
    }
    
    void undo() override
    {
        m_manager.moveLayer(m_toIndex, m_fromIndex);
    }
    
    String getDescription() const override
    {
        return U"ë ˆì´ì–´ ì´ë™";
    }
    
private:
    LayerManager& m_manager;
    size_t m_fromIndex;
    size_t m_toIndex;
};
```

## 25.5 íŒŒì¼ ì €ì¥ê³¼ ë¶ˆëŸ¬ì˜¤ê¸°

### 25.5.4 íŒŒì¼ ê´€ë¦¬ì

```cpp
// FileManager.h
#pragma once
#include "LayerManager.h"
#include <Siv3D.hpp>

class FileManager
{
public:
    // ë‹¨ì¼ ì´ë¯¸ì§€ë¡œ ì €ì¥ (ë³‘í•©ëœ ë ˆì´ì–´)
    bool saveAsImage(const LayerManager& layerManager, const FilePath& path)
    {
        const Image composite = layerManager.createCompositeImage();
        return composite.save(path);
    }
    
    // í”„ë¡œì íŠ¸ íŒŒì¼ë¡œ ì €ì¥ (ëª¨ë“  ë ˆì´ì–´ í¬í•¨)
    bool saveProject(const LayerManager& layerManager, const FilePath& path)
    {
        JSON json;
        
        // ìº”ë²„ìŠ¤ í¬ê¸°
        const auto& layers = layerManager.getLayers();
        if (layers.empty())
            return false;
        
        const Size canvasSize = layers[0]->getImage().size();
        json[U"canvas_width"] = canvasSize.x;
        json[U"canvas_height"] = canvasSize.y;
        
        // í˜„ì¬ ë ˆì´ì–´ ì¸ë±ìŠ¤
        json[U"current_layer"] = layerManager.getCurrentLayerIndex();
        
        // ë ˆì´ì–´ ì •ë³´
        for (size_t i = 0; i < layers.size(); ++i)
        {
            const Layer* layer = layers[i].get();
            
            JSON layerJson;
            layerJson[U"name"] = layer->getName();
            layerJson[U"visible"] = layer->isVisible();
            layerJson[U"opacity"] = layer->getOpacity();
            layerJson[U"locked"] = layer->isLocked();
            
            // ë ˆì´ì–´ ì´ë¯¸ì§€ ì €ì¥
            const String layerImagePath = FileSystem::BaseName(path) 
                + U"_layer_" + ToString(i) + U".png";
            
            layer->getImage().save(FileSystem::ParentPath(path) + layerImagePath);
            layerJson[U"image_path"] = layerImagePath;
            
            json[U"layers"][i] = layerJson;
        }
        
        // JSON íŒŒì¼ ì €ì¥
        return json.save(path);
    }
    
    // í”„ë¡œì íŠ¸ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°
    bool loadProject(LayerManager& layerManager, const FilePath& path)
    {
        const JSON json = JSON::Load(path);
        
        if (not json)
            return false;
        
        try
        {
            // ìº”ë²„ìŠ¤ í¬ê¸°
            const int32 width = json[U"canvas_width"].get<int32>();
            const int32 height = json[U"canvas_height"].get<int32>();
            const Size canvasSize{ width, height };
            
            // ê¸°ì¡´ ë ˆì´ì–´ ëª¨ë‘ ì‚­ì œ
            layerManager = LayerManager{ canvasSize };
            
            // ë ˆì´ì–´ ë¶ˆëŸ¬ì˜¤ê¸°
            const auto& layersJson = json[U"layers"];
            
            for (const auto& layerJson : layersJson.arrayView())
            {
                const String name = layerJson[U"name"].get<String>();
                const bool visible = layerJson[U"visible"].get<bool>();
                const double opacity = layerJson[U"opacity"].get<double>();
                const bool locked = layerJson[U"locked"].get<bool>();
                const String imagePath = layerJson[U"image_path"].get<String>();
                
                // ë ˆì´ì–´ ì¶”ê°€
                const size_t layerIndex = layerManager.addLayer(name);
                Layer* layer = layerManager.getLayers()[layerIndex].get();
                
                // ì´ë¯¸ì§€ ë¡œë“œ
                const String fullImagePath = FileSystem::ParentPath(path) + imagePath;
                const Image layerImage{ fullImagePath };
                
                if (not layerImage)
                {
                    Print << U"ë ˆì´ì–´ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: " << imagePath;
                    continue;
                }
                
                layer->getImage() = layerImage;
                layer->setVisible(visible);
                layer->setOpacity(opacity);
                layer->setLocked(locked);
            }
            
            // í˜„ì¬ ë ˆì´ì–´ ë³µì›
            const size_t currentLayer = json[U"current_layer"].get<size_t>();
            layerManager.selectLayer(currentLayer);
            
            return true;
        }
        catch (const Error& error)
        {
            Print << U"í”„ë¡œì íŠ¸ ë¡œë“œ ì˜¤ë¥˜: " << error.what();
            return false;
        }
    }
    
    // ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
    bool importImage(Layer& layer, const FilePath& path)
    {
        const Image image{ path };
        
        if (not image)
            return false;
        
        // ì´ë¯¸ì§€ í¬ê¸°ê°€ ë‹¤ë¥´ë©´ ë¦¬ì‚¬ì´ì¦ˆ
        const Size layerSize = layer.getImage().size();
        
        if (image.size() != layerSize)
        {
            Image resized{ layerSize, Palette::Transparent };
            image.scaled(layerSize).overwrite(resized);
            layer.getImage() = resized;
        }
        else
        {
            layer.getImage() = image;
        }
        
        return true;
    }
};
```

í”„ë¡œì íŠ¸ íŒŒì¼ì€ JSON í˜•ì‹ì˜ ë©”íƒ€ë°ì´í„°ì™€ ê° ë ˆì´ì–´ì˜ PNG ì´ë¯¸ì§€ë¡œ êµ¬ì„±ëœë‹¤. ì´ ë°©ì‹ì€ ê°„ë‹¨í•˜ë©´ì„œë„ í™•ì¥ ê°€ëŠ¥í•˜ë‹¤.

### 25.5.2 íŒŒì¼ ëŒ€í™”ìƒì ì‚¬ìš©

```cpp
// ê·¸ë˜í”½ ì—ë””í„°ì—ì„œ íŒŒì¼ ì €ì¥/ì—´ê¸°
class GraphicEditor
{
private:
    FileManager m_fileManager;
    LayerManager m_layerManager;
    
public:
    void saveImage()
    {
        // íŒŒì¼ ì €ì¥ ëŒ€í™”ìƒì
        if (const auto path = Dialog::SaveImage())
        {
            if (m_fileManager.saveAsImage(m_layerManager, path.value()))
            {
                Print << U"ì´ë¯¸ì§€ ì €ì¥ ì™„ë£Œ: " << path.value();
            }
            else
            {
                Print << U"ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨";
            }
        }
    }
    
    void saveProject()
    {
        // í”„ë¡œì íŠ¸ íŒŒì¼ ì €ì¥
        if (const auto path = Dialog::SaveFile({ FileFilter::JSON() }))
        {
            if (m_fileManager.saveProject(m_layerManager, path.value()))
            {
                Print << U"í”„ë¡œì íŠ¸ ì €ì¥ ì™„ë£Œ";
            }
            else
            {
                Print << U"í”„ë¡œì íŠ¸ ì €ì¥ ì‹¤íŒ¨";
            }
        }
    }
    
    void loadProject()
    {
        // í”„ë¡œì íŠ¸ íŒŒì¼ ì—´ê¸°
        if (const auto path = Dialog::OpenFile({ FileFilter::JSON() }))
        {
            if (m_fileManager.loadProject(m_layerManager, path.value()))
            {
                Print << U"í”„ë¡œì íŠ¸ ë¡œë“œ ì™„ë£Œ";
                m_commandManager.clear();  // íˆìŠ¤í† ë¦¬ ì´ˆê¸°í™”
            }
            else
            {
                Print << U"í”„ë¡œì íŠ¸ ë¡œë“œ ì‹¤íŒ¨";
            }
        }
    }
    
    void importImage()
    {
        // ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
        if (const auto path = Dialog::OpenImage())
        {
            if (auto* layer = m_layerManager.getCurrentLayer())
            {
                if (m_fileManager.importImage(*layer, path.value()))
                {
                    Print << U"ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ";
                }
                else
                {
                    Print << U"ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨";
                }
            }
        }
    }
};
```

`std::optional`ì„ ë°˜í™˜í•˜ëŠ” Siv3Dì˜ ëŒ€í™”ìƒì í•¨ìˆ˜ëŠ” ì‚¬ìš©ìê°€ ì·¨ì†Œí–ˆëŠ”ì§€ ëª…í™•í•˜ê²Œ ì•Œë ¤ì¤€ë‹¤.

## 25.6 UI êµ¬í˜„

### 25.6.1 UI ë§¤ë‹ˆì €

```cpp
// UIManager.h
#pragma once
#include <Siv3D.hpp>
#include "ToolManager.h"
#include "LayerManager.h"

class UIManager
{
public:
    UIManager(ToolManager& toolManager, LayerManager& layerManager)
        : m_toolManager{ toolManager }
        , m_layerManager{ layerManager }
    {
        m_font = Font{ FontMethod::MSDF, 16 };
        m_iconFont = Font{ FontMethod::MSDF, 24 };
    }
    
    void update()
    {
        updateToolbar();
        updateColorPicker();
        updateLayerPanel();
        updateMenuBar();
    }
    
    void draw() const
    {
        drawToolbar();
        drawColorPicker();
        drawLayerPanel();
        drawMenuBar();
    }
    
    // ìº”ë²„ìŠ¤ ì˜ì—­ ë°˜í™˜
    RectF getCanvasRect() const
    {
        return RectF{
            EditorConfig::CanvasOffset,
            EditorConfig::CanvasSize
        };
    }
    
private:
    ToolManager& m_toolManager;
    LayerManager& m_layerManager;
    Font m_font;
    Font m_iconFont;
    
    Color m_currentColor{ Palette::Black };
    int32 m_brushSize = EditorConfig::DefaultBrushSize;
    
    // íˆ´ë°” ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
    void updateToolbar()
    {
        const RectF toolbarRect{ 0, EditorConfig::MenuBarHeight, 
                                EditorConfig::ToolbarWidth, 
                                Scene::Height() - EditorConfig::MenuBarHeight };
        
        const auto& tools = m_toolManager.getTools();
        const int32 buttonSize = 50;
        const int32 margin = 10;
        
        for (size_t i = 0; i < tools.size(); ++i)
        {
            const int32 x = margin;
            const int32 y = EditorConfig::MenuBarHeight + margin + (buttonSize + margin) * i;
            
            const RectF buttonRect{ x, y, buttonSize, buttonSize };
            
            if (buttonRect.leftClicked())
            {
                m_toolManager.selectTool(i);
                
                // ë„êµ¬ì— í˜„ì¬ ìƒ‰ìƒê³¼ ë¸ŒëŸ¬ì‹œ í¬ê¸° ì„¤ì •
                if (auto* tool = m_toolManager.getCurrentTool())
                {
                    tool->setColor(m_currentColor);
                    tool->setBrushSize(m_brushSize);
                }
            }
        }
        
        // ë¸ŒëŸ¬ì‹œ í¬ê¸° ìŠ¬ë¼ì´ë”
        const RectF sliderRect{ 
            margin, 
            EditorConfig::MenuBarHeight + margin + (buttonSize + margin) * tools.size() + 30,
            EditorConfig::ToolbarWidth - margin * 2,
            20
        };
        
        SimpleGUI::Slider(U"í¬ê¸°: {}"_fmt(m_brushSize), m_brushSize,
                         EditorConfig::MinBrushSize, EditorConfig::MaxBrushSize,
                         sliderRect.pos, sliderRect.w);
        
        // ë„êµ¬ì— ë¸ŒëŸ¬ì‹œ í¬ê¸° ì—…ë°ì´íŠ¸
        if (auto* tool = m_toolManager.getCurrentTool())
        {
            tool->setBrushSize(m_brushSize);
        }
    }
    
    void drawToolbar() const
    {
        const RectF toolbarRect{ 0, EditorConfig::MenuBarHeight,
                                EditorConfig::ToolbarWidth,
                                Scene::Height() - EditorConfig::MenuBarHeight };
        
        // ë°°ê²½
        toolbarRect.draw(EditorConfig::UIBackgroundColor);
        toolbarRect.drawFrame(1, EditorConfig::UIBorderColor);
        
        // ë„êµ¬ ë²„íŠ¼
        const auto& tools = m_toolManager.getTools();
        const size_t currentTool = m_toolManager.getCurrentToolIndex();
        const int32 buttonSize = 50;
        const int32 margin = 10;
        
        for (size_t i = 0; i < tools.size(); ++i)
        {
            const int32 x = margin;
            const int32 y = EditorConfig::MenuBarHeight + margin + (buttonSize + margin) * i;
            
            const RectF buttonRect{ x, y, buttonSize, buttonSize };
            
            // ì„ íƒëœ ë„êµ¬ í•˜ì´ë¼ì´íŠ¸
            if (i == currentTool)
            {
                buttonRect.draw(ColorF{ 0.6, 0.8, 1.0 });
            }
            else if (buttonRect.mouseOver())
            {
                buttonRect.draw(ColorF{ 0.8, 0.8, 0.8 });
            }
            else
            {
                buttonRect.draw(ColorF{ 0.95 });
            }
            
            buttonRect.drawFrame(2, ColorF{ 0.5 });
            
            // ë„êµ¬ ì•„ì´ì½˜
            const Texture icon = tools[i]->getIcon();
            icon.scaled(0.7).drawAt(buttonRect.center());
        }
    }
    
    void updateColorPicker()
    {
        const RectF pickerRect{
            10,
            Scene::Height() - 120,
            180,
            110
        };
        
        // ìƒ‰ìƒ ì„ íƒ ë²„íŠ¼ë“¤
        const std::array<Color, 8> colors = {
            Palette::Black, Palette::White, Palette::Red, Palette::Green,
            Palette::Blue, Palette::Yellow, Palette::Magenta, Palette::Cyan
        };
        
        const int32 colorBoxSize = 40;
        const int32 margin = 5;
        
        for (size_t i = 0; i < colors.size(); ++i)
        {
            const int32 col = i % 4;
            const int32 row = i / 4;
            
            const RectF colorBox{
                pickerRect.x + margin + (colorBoxSize + margin) * col,
                pickerRect.y + margin + (colorBoxSize + margin) * row,
                colorBoxSize,
                colorBoxSize
            };
            
            if (colorBox.leftClicked())
            {
                m_currentColor = colors[i];
                
                // ë„êµ¬ì— ìƒ‰ìƒ ì—…ë°ì´íŠ¸
                if (auto* tool = m_toolManager.getCurrentTool())
                {
                    tool->setColor(m_currentColor);
                }
            }
        }
    }
    
    void drawColorPicker() const
    {
        const RectF pickerRect{
            10,
            Scene::Height() - 120,
            180,
            110
        };
        
        // ë°°ê²½
        pickerRect.draw(EditorConfig::UIBackgroundColor);
        pickerRect.drawFrame(1, EditorConfig::UIBorderColor);
        
        // ìƒ‰ìƒ ë²„íŠ¼ë“¤
        const std::array<Color, 8> colors = {
            Palette::Black, Palette::White, Palette::Red, Palette::Green,
            Palette::Blue, Palette::Yellow, Palette::Magenta, Palette::Cyan
        };
        
        const int32 colorBoxSize = 40;
        const int32 margin = 5;
        
        for (size_t i = 0; i < colors.size(); ++i)
        {
            const int32 col = i % 4;
            const int32 row = i / 4;
            
            const RectF colorBox{
                pickerRect.x + margin + (colorBoxSize + margin) * col,
                pickerRect.y + margin + (colorBoxSize + margin) * row,
                colorBoxSize,
                colorBoxSize
            };
            
            colorBox.draw(colors[i]);
            
            // ì„ íƒëœ ìƒ‰ìƒ í‘œì‹œ
            if (colors[i] == m_currentColor)
            {
                colorBox.drawFrame(3, ColorF{ 1.0, 0.5, 0.0 });
            }
            else
            {
                colorBox.drawFrame(1, ColorF{ 0.5 });
            }
        }
    }
    
    void updateLayerPanel()
    {
        const RectF panelRect{
            Scene::Width() - EditorConfig::LayerPanelWidth,
            EditorConfig::MenuBarHeight,
            EditorConfig::LayerPanelWidth,
            Scene::Height() - EditorConfig::MenuBarHeight
        };
        
        const auto& layers = m_layerManager.getLayers();
        const int32 layerHeight = 60;
        const int32 margin = 5;
        
        // ë ˆì´ì–´ ì¶”ê°€ ë²„íŠ¼
        const RectF addButton{
            panelRect.x + margin,
            panelRect.y + margin,
            panelRect.w - margin * 2,
            30
        };
        
        if (addButton.leftClicked())
        {
            m_layerManager.addLayer(U"ë ˆì´ì–´ " + ToString(layers.size() + 1));
        }
        
        // ë ˆì´ì–´ ëª©ë¡ (ì•„ë˜ì—ì„œ ìœ„ë¡œ)
        for (int32 i = static_cast<int32>(layers.size()) - 1; i >= 0; --i)
        {
            const int32 reverseIndex = layers.size() - 1 - i;
            
            const RectF layerRect{
                panelRect.x + margin,
                panelRect.y + 50 + margin + (layerHeight + margin) * reverseIndex,
                panelRect.w - margin * 2,
                layerHeight
            };
            
            // ë ˆì´ì–´ ì„ íƒ
            if (layerRect.leftClicked())
            {
                m_layerManager.selectLayer(i);
            }
            
            // ê°€ì‹œì„± í† ê¸€
            const RectF visibleButton{
                layerRect.x + 5,
                layerRect.y + 5,
                20,
                20
            };
            
            if (visibleButton.leftClicked())
            {
                layers[i]->setVisible(not layers[i]->isVisible());
            }
        }
    }
    
    void drawLayerPanel() const
    {
        const RectF panelRect{
            Scene::Width() - EditorConfig::LayerPanelWidth,
            EditorConfig::MenuBarHeight,
            EditorConfig::LayerPanelWidth,
            Scene::Height() - EditorConfig::MenuBarHeight
        };
        
        // ë°°ê²½
        panelRect.draw(EditorConfig::UIBackgroundColor);
        panelRect.drawFrame(1, EditorConfig::UIBorderColor);
        
        // ë ˆì´ì–´ ì¶”ê°€ ë²„íŠ¼
        const RectF addButton{
            panelRect.x + 5,
            panelRect.y + 5,
            panelRect.w - 10,
            30
        };
        
        addButton.rounded(5).draw(ColorF{ 0.6, 0.8, 0.6 });
        
        if (addButton.mouseOver())
        {
            addButton.rounded(5).draw(ColorF{ 0.7, 0.9, 0.7 });
        }
        
        m_font(U"+ ë ˆì´ì–´ ì¶”ê°€").drawAt(addButton.center(), ColorF{ 0.2 });
        
        // ë ˆì´ì–´ ëª©ë¡
        const auto& layers = m_layerManager.getLayers();
        const size_t currentLayer = m_layerManager.getCurrentLayerIndex();
        const int32 layerHeight = 60;
        const int32 margin = 5;
        
        for (int32 i = static_cast<int32>(layers.size()) - 1; i >= 0; --i)
        {
            const int32 reverseIndex = layers.size() - 1 - i;
            
            const RectF layerRect{
                panelRect.x + margin,
                panelRect.y + 50 + margin + (layerHeight + margin) * reverseIndex,
                panelRect.w - margin * 2,
                layerHeight
            };
            
            // ì„ íƒëœ ë ˆì´ì–´ í•˜ì´ë¼ì´íŠ¸
            if (i == static_cast<int32>(currentLayer))
            {
                layerRect.draw(ColorF{ 0.7, 0.85, 1.0 });
            }
            else if (layerRect.mouseOver())
            {
                layerRect.draw(ColorF{ 0.85 });
            }
            else
            {
                layerRect.draw(ColorF{ 0.95 });
            }
            
            layerRect.drawFrame(1, ColorF{ 0.7 });
            
            // ë ˆì´ì–´ ì¸ë„¤ì¼
            const RectF thumbRect{
                layerRect.x + 5,
                layerRect.y + 5,
                50,
                50
            };
            
            layers[i]->getTexture()
                .scaled(50.0 / EditorConfig::CanvasSize.x)
                .draw(thumbRect.pos);
            
            thumbRect.drawFrame(1, ColorF{ 0.5 });
            
            // ë ˆì´ì–´ ì´ë¦„
            m_font(layers[i]->getName()).draw(
                thumbRect.rightX() + 10,
                thumbRect.y + 5,
                ColorF{ 0.2 }
            );
            
            // ê°€ì‹œì„± ì•„ì´ì½˜
            const RectF visibleButton{
                thumbRect.rightX() + 10,
                thumbRect.y + 25,
                20,
                20
            };
            
            const String visibleIcon = layers[i]->isVisible() ? U"ğŸ‘" : U"ğŸš«";
            m_iconFont(visibleIcon).drawAt(visibleButton.center());
            
            // ì ê¸ˆ ì•„ì´ì½˜
            if (layers[i]->isLocked())
            {
                const RectF lockIcon{
                    visibleButton.rightX() + 5,
                    visibleButton.y,
                    20,
                    20
                };
                
                m_iconFont(U"ğŸ”’").drawAt(lockIcon.center());
            }
        }
    }
    
    void updateMenuBar()
    {
        // ë©”ë‰´ ë°”ëŠ” ë³„ë„ë¡œ êµ¬í˜„ (íŒŒì¼, í¸ì§‘, ë³´ê¸° ë“±)
    }
    
    void drawMenuBar() const
    {
        const RectF menuBarRect{ 0, 0, Scene::Width(), EditorConfig::MenuBarHeight };
        
        menuBarRect.draw(EditorConfig::UIBackgroundColor);
        menuBarRect.drawFrame(0, 2, EditorConfig::UIBorderColor);
        
        m_font(U"ê·¸ë˜í”½ ì—ë””í„°")
            .draw(20, (EditorConfig::MenuBarHeight - 20) / 2, ColorF{ 0.2 });
    }
};
```

## 25.7 ë©”ì¸ ì—ë””í„° í´ë˜ìŠ¤

ëª¨ë“  êµ¬ì„± ìš”ì†Œë¥¼ í†µí•©í•˜ì—¬ ì™„ì „í•œ ê·¸ë˜í”½ ì—ë””í„°ë¥¼ ë§Œë“ ë‹¤.

```cpp
// GraphicEditor.h
#pragma once
#include <Siv3D.hpp>
#include "ToolManager.h"
#include "CommandManager.h"
#include "LayerManager.h"
#include "FileManager.h"
#include "UIManager.h"

class GraphicEditor
{
public:
    GraphicEditor()
        : m_layerManager{ EditorConfig::CanvasSize }
        , m_uiManager{ m_toolManager, m_layerManager }
    {
    }
    
    void update()
    {
        // UI ì—…ë°ì´íŠ¸
        m_uiManager.update();
        
        // ìº”ë²„ìŠ¤ ì˜ì—­ì—ì„œì˜ ì…ë ¥ ì²˜ë¦¬
        handleCanvasInput();
        
        // ë‹¨ì¶•í‚¤ ì²˜ë¦¬
        handleShortcuts();
    }
    
    void draw() const
    {
        // ë°°ê²½
        Scene::SetBackground(EditorConfig::BackgroundColor);
        
        // ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
        drawCanvas();
        
        // UI ê·¸ë¦¬ê¸°
        m_uiManager.draw();
        
        // ë„êµ¬ í”„ë¦¬ë·°
        drawToolPreview();
    }
    
private:
    ToolManager m_toolManager;
    CommandManager m_commandManager;
    LayerManager m_layerManager;
    FileManager m_fileManager;
    UIManager m_uiManager;
    
    // ê·¸ë¦¬ê¸° ìƒíƒœ
    bool m_isDrawing = false;
    Image m_beforeDrawing;
    
    void handleCanvasInput()
    {
        const RectF canvasRect = m_uiManager.getCanvasRect();
        
        if (not canvasRect.mouseOver())
            return;
        
        auto* currentTool = m_toolManager.getCurrentTool();
        if (not currentTool)
            return;
        
        auto* currentLayer = m_layerManager.getCurrentLayer();
        if (not currentLayer || currentLayer->isLocked())
            return;
        
        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
        const Vec2 canvasPos = Cursor::Pos() - canvasRect.pos;
        
        // ë§ˆìš°ìŠ¤ ë‹¤ìš´
        if (MouseL.down())
        {
            m_isDrawing = true;
            m_beforeDrawing = currentLayer->getImage();
            currentTool->onMouseDown(canvasPos, currentLayer->getImage());
        }
        
        // ë§ˆìš°ìŠ¤ ì´ë™
        if (m_isDrawing && MouseL.pressed())
        {
            currentTool->onMouseMove(canvasPos, currentLayer->getImage());
        }
        
        // ë§ˆìš°ìŠ¤ ì—…
        if (MouseL.up() && m_isDrawing)
        {
            currentTool->onMouseUp(canvasPos, currentLayer->getImage());
            
            // ê·¸ë¦¬ê¸° ëª…ë ¹ ìƒì„±
            auto command = std::make_unique<DrawCommand>(
                currentLayer->getImage(),
                m_beforeDrawing,
                currentLayer->getImage(),
                currentTool->getName()
            );
            
            m_commandManager.executeCommand(std::move(command));
            
            m_isDrawing = false;
        }
    }
    
    void handleShortcuts()
    {
        // Ctrl+Z: ì‹¤í–‰ ì·¨ì†Œ
        if (KeyControl.pressed() && KeyZ.down())
        {
            m_commandManager.undo();
        }
        
        // Ctrl+Y ë˜ëŠ” Ctrl+Shift+Z: ë‹¤ì‹œ ì‹¤í–‰
        if (KeyControl.pressed() && (KeyY.down() || (KeyShift.pressed() && KeyZ.down())))
        {
            m_commandManager.redo();
        }
        
        // Ctrl+S: ì €ì¥
        if (KeyControl.pressed() && KeyS.down())
        {
            saveImage();
        }
        
        // Ctrl+Shift+S: ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì €ì¥
        if (KeyControl.pressed() && KeyShift.pressed() && KeyS.down())
        {
            saveProject();
        }
        
        // Ctrl+O: ì—´ê¸°
        if (KeyControl.pressed() && KeyO.down())
        {
            loadProject();
        }
        
        // Ctrl+N: ìƒˆ í”„ë¡œì íŠ¸
        if (KeyControl.pressed() && KeyN.down())
        {
            newProject();
        }
    }
    
    void drawCanvas() const
    {
        const RectF canvasRect = m_uiManager.getCanvasRect();
        
        // ìº”ë²„ìŠ¤ ë°°ê²½ (ì²´í¬ë¬´ëŠ¬ íŒ¨í„´)
        drawCheckerboard(canvasRect);
        
        // ë ˆì´ì–´ í•©ì„±í•˜ì—¬ ê·¸ë¦¬ê¸°
        const auto& layers = m_layerManager.getLayers();
        
        for (const auto& layer : layers)
        {
            if (not layer->isVisible())
                continue;
            
            const Texture& texture = const_cast<Layer*>(layer.get())->getTexture();
            texture.draw(canvasRect.pos, Alpha(static_cast<uint8>(layer->getOpacity() * 255)));
        }
        
        // ìº”ë²„ìŠ¤ í…Œë‘ë¦¬
        canvasRect.drawFrame(2, ColorF{ 0.3 });
    }
    
    void drawCheckerboard(const RectF& rect) const
    {
        const int32 gridSize = 20;
        const ColorF lightColor{ 0.95 };
        const ColorF darkColor{ 0.85 };
        
        for (int32 y = 0; y < rect.h; y += gridSize)
        {
            for (int32 x = 0; x < rect.w; x += gridSize)
            {
                const bool isLight = ((x / gridSize) + (y / gridSize)) % 2 == 0;
                const ColorF color = isLight ? lightColor : darkColor;
                
                RectF{ rect.x + x, rect.y + y, gridSize, gridSize }.draw(color);
            }
        }
    }
    
    void drawToolPreview() const
    {
        const RectF canvasRect = m_uiManager.getCanvasRect();
        
        if (not canvasRect.mouseOver())
            return;
        
        const auto* currentTool = m_toolManager.getCurrentTool();
        if (not currentTool)
            return;
        
        const Vec2 canvasPos = Cursor::Pos() - canvasRect.pos;
        currentTool->drawPreview(Cursor::Pos());
    }
    
    void saveImage()
    {
        if (const auto path = Dialog::SaveImage())
        {
            m_fileManager.saveAsImage(m_layerManager, path.value());
        }
    }
    
    void saveProject()
    {
        if (const auto path = Dialog::SaveFile({ FileFilter::JSON() }))
        {
            m_fileManager.saveProject(m_layerManager, path.value());
        }
    }
    
    void loadProject()
    {
        if (const auto path = Dialog::OpenFile({ FileFilter::JSON() }))
        {
            if (m_fileManager.loadProject(m_layerManager, path.value()))
            {
                m_commandManager.clear();
            }
        }
    }
    
    void newProject()
    {
        // í™•ì¸ ëŒ€í™”ìƒì
        if (System::MessageBoxYesNo(U"ìƒˆ í”„ë¡œì íŠ¸ë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\ní˜„ì¬ ì‘ì—…ì€ ì €ì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."))
        {
            m_layerManager = LayerManager{ EditorConfig::CanvasSize };
            m_commandManager.clear();
        }
    }
};
```

## 25.8 ë©”ì¸ í•¨ìˆ˜

```cpp
// Main.cpp
#include <Siv3D.hpp>
#include "GraphicEditor.h"

void Main()
{
    // ìœˆë„ìš° ì„¤ì •
    Window::SetTitle(U"Modern C++ ê·¸ë˜í”½ ì—ë””í„°");
    Window::Resize(1280, 800);
    Scene::SetBackground(EditorConfig::BackgroundColor);
    
    // ì—ë””í„° ìƒì„±
    GraphicEditor editor;
    
    // ë©”ì¸ ë£¨í”„
    while (System::Update())
    {
        editor.update();
        editor.draw();
    }
}
```

## 25.9 ì‹¤ìŠµ ë¬¸ì œ

### ê¸°ë³¸ ì‹¤ìŠµ

1. **ìŠ¤í¬ì´íŠ¸ ë„êµ¬**: ìº”ë²„ìŠ¤ì˜ ìƒ‰ìƒì„ ì„ íƒí•  ìˆ˜ ìˆëŠ” ìŠ¤í¬ì´íŠ¸ ë„êµ¬ë¥¼ êµ¬í˜„í•˜ë¼.

2. **í…ìŠ¤íŠ¸ ë„êµ¬**: ìº”ë²„ìŠ¤ì— í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•  ìˆ˜ ìˆëŠ” ë„êµ¬ë¥¼ ì¶”ê°€í•˜ë¼.

3. **ë ˆì´ì–´ ë³µì œ**: í˜„ì¬ ë ˆì´ì–´ë¥¼ ë³µì œí•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ë¼.

### ì¤‘ê¸‰ ì‹¤ìŠµ

4. **ì„ íƒ ì˜ì—­**: ì‚¬ê°í˜• ë˜ëŠ” ììœ  í˜•íƒœì˜ ì„ íƒ ì˜ì—­ì„ ë§Œë“¤ê³ , ì„ íƒ ì˜ì—­ ë‚´ì—ì„œë§Œ ê·¸ë¦¬ê¸°ê°€ ê°€ëŠ¥í•˜ë„ë¡ êµ¬í˜„í•˜ë¼.

5. **ê·¸ë¼ë°ì´ì…˜ ë„êµ¬**: ë‘ ìƒ‰ìƒ ì‚¬ì´ì˜ ê·¸ë¼ë°ì´ì…˜ì„ ê·¸ë¦¬ëŠ” ë„êµ¬ë¥¼ êµ¬í˜„í•˜ë¼.

6. **ë ˆì´ì–´ ë¸”ë Œë”© ëª¨ë“œ**: ê³±í•˜ê¸°, ë”í•˜ê¸°, ì˜¤ë²„ë ˆì´ ë“± ë‹¤ì–‘í•œ ë¸”ë Œë”© ëª¨ë“œë¥¼ ì§€ì›í•˜ë¼.

### ê³ ê¸‰ ì‹¤ìŠµ

7. **í•„í„° íš¨ê³¼**: íë¦¼, ì„ ëª…í•˜ê²Œ, ëª¨ìì´í¬ ë“±ì˜ í•„í„°ë¥¼ êµ¬í˜„í•˜ë¼. `std::async`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬í•˜ë¼.

8. **ë¸ŒëŸ¬ì‹œ ì—ë””í„°**: ì‚¬ìš©ìê°€ ì»¤ìŠ¤í…€ ë¸ŒëŸ¬ì‹œë¥¼ ë§Œë“¤ ìˆ˜ ìˆë„ë¡ ë¸ŒëŸ¬ì‹œ ì—ë””í„°ë¥¼ êµ¬í˜„í•˜ë¼.

9. **ì• ë‹ˆë©”ì´ì…˜ ì§€ì›**: ì—¬ëŸ¬ í”„ë ˆì„ì„ ê´€ë¦¬í•˜ê³  GIFë¡œ ë‚´ë³´ë‚¼ ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ë¼.

## 25.10 ì‹¬í™” ë‚´ìš©: ì„±ëŠ¥ ìµœì í™”

### 25.10.1 ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ëª…ë ¹ íŒ¨í„´

ì´ë¯¸ì§€ ì „ì²´ë¥¼ ë³µì‚¬í•˜ëŠ” ëŒ€ì‹  ë³€ê²½ëœ ì˜ì—­ë§Œ ì €ì¥í•˜ëŠ” ë°©ë²•ì´ë‹¤.

```cpp
// DeltaDrawCommand.h
#pragma once
#include "ICommand.h"

struct PixelChange
{
    Point pos;
    Color oldColor;
    Color newColor;
};

class DeltaDrawCommand : public ICommand
{
public:
    DeltaDrawCommand(Image& targetImage, std::vector<PixelChange> changes, const String& toolName)
        : m_targetImage{ targetImage }
        , m_changes{ std::move(changes) }
        , m_toolName{ toolName }
    {
    }
    
    void execute() override
    {
        for (const auto& change : m_changes)
        {
            if (m_targetImage.size().contains(change.pos))
            {
                m_targetImage[change.pos] = change.newColor;
            }
        }
    }
    
    void undo() override
    {
        for (const auto& change : m_changes)
        {
            if (m_targetImage.size().contains(change.pos))
            {
                m_targetImage[change.pos] = change.oldColor;
            }
        }
    }
    
    String getDescription() const override
    {
        return m_toolName + U" ì‚¬ìš© (" + ToString(m_changes.size()) + U" í”½ì…€)";
    }
    
private:
    Image& m_targetImage;
    std::vector<PixelChange> m_changes;
    String m_toolName;
};
```

ë³€ê²½ëœ í”½ì…€ë§Œ ì €ì¥í•˜ë©´ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ í¬ê²Œ ì¤„ì–´ë“ ë‹¤. í•˜ì§€ë§Œ ë³€ê²½ ì‚¬í•­ì„ ì¶”ì í•˜ëŠ” ì˜¤ë²„í—¤ë“œê°€ ìˆìœ¼ë¯€ë¡œ, í° ë¸ŒëŸ¬ì‹œë¡œ ë„“ì€ ì˜ì—­ì„ ê·¸ë¦´ ë•ŒëŠ” ì „ì²´ ì´ë¯¸ì§€ ë³µì‚¬ê°€ ë” íš¨ìœ¨ì ì¼ ìˆ˜ ìˆë‹¤.

### 25.10.2 íƒ€ì¼ ê¸°ë°˜ ë Œë”ë§

í° ìº”ë²„ìŠ¤ë¥¼ ì‘ì€ íƒ€ì¼ë¡œ ë‚˜ëˆ„ì–´ í•„ìš”í•œ ë¶€ë¶„ë§Œ ë Œë”ë§í•œë‹¤.

```cpp
// TiledCanvas.h
#pragma once
#include <Siv3D.hpp>

class TiledCanvas
{
public:
    TiledCanvas(const Size& size, int32 tileSize = 256)
        : m_canvasSize{ size }
        , m_tileSize{ tileSize }
    {
        const int32 tilesX = (size.x + tileSize - 1) / tileSize;
        const int32 tilesY = (size.y + tileSize - 1) / tileSize;
        
        m_tiles.resize(tilesX * tilesY);
        
        for (auto& tile : m_tiles)
        {
            tile = Image{ tileSize, tileSize, Palette::Transparent };
        }
    }
    
    void setPixel(const Point& pos, const Color& color)
    {
        const int32 tileX = pos.x / m_tileSize;
        const int32 tileY = pos.y / m_tileSize;
        
        if (tileX < 0 || tileY < 0)
            return;
        
        const int32 tilesX = (m_canvasSize.x + m_tileSize - 1) / m_tileSize;
        const int32 tileIndex = tileY * tilesX + tileX;
        
        if (tileIndex >= static_cast<int32>(m_tiles.size()))
            return;
        
        const Point localPos{
            pos.x % m_tileSize,
            pos.y % m_tileSize
        };
        
        if (m_tiles[tileIndex].size().contains(localPos))
        {
            m_tiles[tileIndex][localPos] = color;
            m_dirtyTiles.insert(tileIndex);
        }
    }
    
    void updateTextures()
    {
        for (int32 tileIndex : m_dirtyTiles)
        {
            // í…ìŠ¤ì²˜ ì—…ë°ì´íŠ¸ (ì‹¤ì œë¡œëŠ” DynamicTexture ì‚¬ìš©)
        }
        
        m_dirtyTiles.clear();
    }
    
private:
    Size m_canvasSize;
    int32 m_tileSize;
    std::vector<Image> m_tiles;
    std::set<int32> m_dirtyTiles;  // ë³€ê²½ëœ íƒ€ì¼ ì¸ë±ìŠ¤
};
```

### 25.10.3 ë¹„ë™ê¸° ì €ì¥

í° í”„ë¡œì íŠ¸ë¥¼ ì €ì¥í•  ë•Œ UIê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬í•œë‹¤.

```cpp
#include <future>

class FileManager
{
private:
    std::future<bool> m_saveFuture;
    
public:
    void saveProjectAsync(const LayerManager& layerManager, const FilePath& path)
    {
        // ì´ì „ ì €ì¥ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ëŒ€ê¸°
        if (m_saveFuture.valid())
        {
            m_saveFuture.wait();
        }
        
        // ë ˆì´ì–´ ë°ì´í„° ë³µì‚¬ (ì›ë³¸ ë³´í˜¸)
        std::vector<Image> layerImages;
        std::vector<String> layerNames;
        
        for (const auto& layer : layerManager.getLayers())
        {
            layerImages.push_back(layer->getImage());
            layerNames.push_back(layer->getName());
        }
        
        // ë¹„ë™ê¸° ì €ì¥
        m_saveFuture = std::async(std::launch::async,
            [layerImages = std::move(layerImages), 
             layerNames = std::move(layerNames), 
             path]() -> bool
            {
                // ì €ì¥ ì‘ì—… ìˆ˜í–‰
                for (size_t i = 0; i < layerImages.size(); ++i)
                {
                    const String layerPath = path + U"_layer_" + ToString(i) + U".png";
                    
                    if (not layerImages[i].save(layerPath))
                    {
                        return false;
                    }
                }
                
                return true;
            });
    }
    
    bool isSaving() const
    {
        return m_saveFuture.valid() && 
               m_saveFuture.wait_for(std::chrono::seconds(0)) != std::future_status::ready;
    }
};
```

`std::async`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì €ì¥ ì‘ì—…ì„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìˆ˜í–‰í•œë‹¤. ì›ë³¸ ë°ì´í„°ë¥¼ ë³µì‚¬í•˜ì—¬ ë¹„ë™ê¸° ì‘ì—… ì¤‘ì—ë„ ì‚¬ìš©ìê°€ ê³„ì† í¸ì§‘í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

## 25.11 ìš”ì•½

ì´ë²ˆ ì¥ì—ì„œëŠ” ë„êµ¬ íŒ¨í„´ê³¼ ëª…ë ¹ íŒ¨í„´ì„ í™œìš©í•œ ë³¸ê²©ì ì¸ ê·¸ë˜í”½ ì—ë””í„°ë¥¼ êµ¬í˜„í–ˆë‹¤. ì£¼ìš” í•™ìŠµ ë‚´ìš©ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

**ë””ìì¸ íŒ¨í„´:**
- ë„êµ¬ íŒ¨í„´ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥í•œ ë„êµ¬ ì‹œìŠ¤í…œ êµ¬í˜„
- ëª…ë ¹ íŒ¨í„´ìœ¼ë¡œ ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ê¸°ëŠ¥ êµ¬í˜„
- ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•œ ë‹¤í˜•ì„± í™œìš©

**Modern C++ ê¸°ëŠ¥:**
- `std::unique_ptr`ë¡œ ê°ì²´ ì†Œìœ ê¶Œ ê´€ë¦¬
- `std::vector`ì™€ `std::deque`ë¡œ íš¨ìœ¨ì ì¸ ì»¬ë ‰ì…˜ ê´€ë¦¬
- `std::optional`ë¡œ ëª…í™•í•œ ê°’ ë¶€ì¬ í‘œí˜„
- `std::async`ë¡œ ë¹„ë™ê¸° ì‘ì—… ì²˜ë¦¬

**ê·¸ë˜í”½ ì—ë””í„° í•µì‹¬ ê¸°ëŠ¥:**
- ë‹¤ì–‘í•œ ê·¸ë¦¬ê¸° ë„êµ¬ êµ¬í˜„
- ë ˆì´ì–´ ì‹œìŠ¤í…œìœ¼ë¡œ ë³µì¡í•œ ì‘ì—… ì§€ì›
- í”„ë¡œì íŠ¸ íŒŒì¼ ì €ì¥ ë° ë¶ˆëŸ¬ì˜¤ê¸°
- ì§ê´€ì ì¸ ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤

ë‹¤ìŒ ì¥ì—ì„œëŠ” ë©€í‹°ìŠ¤ë ˆë”©ì„ í™œìš©í•œ ë°ì´í„° ì‹œê°í™” ë„êµ¬ë¥¼ ë§Œë“¤ë©´ì„œ ì„±ëŠ¥ ìµœì í™” ê¸°ë²•ì„ ë°°ìš´ë‹¤.

 