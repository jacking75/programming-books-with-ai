# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 20: 그래픽과 텍스트

## 20.1 들어가며
사용자 인터페이스의 핵심은 시각적 표현이다. 아름다운 그래픽과 읽기 쉬운 텍스트는 애플리케이션의 품질을 결정하는 중요한 요소다. 이번 장에서는 Siv3D를 활용하여 이미지를 로드하고 출력하는 방법, 다양한 폰트로 텍스트를 렌더링하는 방법, 그리고 기본 도형부터 커스텀 그래픽까지 그리는 방법을 배운다.

Modern C++의 RAII(Resource Acquisition Is Initialization) 원칙 덕분에, Siv3D의 그래픽 리소스는 메모리 누수 걱정 없이 안전하게 사용할 수 있다. 스마트 포인터나 수동 메모리 관리 없이도, 객체의 생명주기가 자동으로 관리된다.

## 20.2 이미지 로드와 출력

### 20.2.1 이미지 파일 로드하기
Siv3D는 PNG, JPEG, BMP, GIF 등 다양한 이미지 포맷을 지원한다. `Texture` 클래스를 사용하면 이미지 파일을 GPU 메모리에 로드하여 빠르게 렌더링할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 이미지 파일을 텍스처로 로드
    const Texture texture{ U"example/windmill.png" };
    
    const Font font{ FontMethod::SDF, 20, Typeface::CJK_Regular_KR };

    // 로드 실패 확인
    if (!texture)
    {
        Print << U"이미지 로드 실패!";
        return;
    }
    
    while (System::Update())
    {
        // 텍스처를 (0, 0) 위치에 그리기
        texture.draw(0, 0);
        
        // 텍스처 정보 표시
        font(U"크기: {}x{}"_fmt(texture.width(), texture.height()))
            .draw(10, 10, Palette::White);
    }
}
```

`Texture` 객체는 생성자에서 파일을 로드한다. 파일이 존재하지 않거나 손상된 경우, `bool` 변환 연산자로 로드 성공 여부를 확인할 수 있다. 이는 Modern C++의 명시적 불린 변환(explicit bool conversion)을 활용한 안전한 패턴이다.

### 20.2.2 이미지 크기 조정과 위치 지정
이미지를 다양한 크기와 위치로 그릴 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    const Texture texture{ U"example/windmill.png" };
    
    const Font font{ FontMethod::SDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 원본 크기로 왼쪽 위에 그리기
        texture.draw(0, 0);
        
        // 50% 크기로 축소하여 그리기
        texture.scaled(0.5).draw(400, 0);
        
        // 특정 크기로 그리기 (가로 200, 세로 150)
        texture.resized(200, 150).draw(0, 300);
        
        // 화면 중앙에 그리기
        texture.drawAt(Scene::Center());
        
        font(U"원본").draw(10, 250, Palette::Yellow);
        font(U"50% 축소").draw(410, 250, Palette::Yellow);
        font(U"200x150").draw(10, 460, Palette::Yellow);
    }
}
```

`scaled()`는 비율로 크기를 조정하고, `resized()`는 절대 크기를 지정한다. `drawAt()`은 이미지의 중심을 기준으로 그린다. 이러한 함수들은 메서드 체이닝(method chaining)을 지원하여, 여러 변환을 연속으로 적용할 수 있다.

### 20.2.3 이미지 회전과 대칭
이미지를 회전하거나 뒤집을 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
	const Texture texture{ U"example/windmill.png" };
	double angle = 0.0;

	const Font font{ FontMethod::SDF, 20, Typeface::CJK_Regular_KR };

	while (System::Update())
	{
		angle += Scene::DeltaTime() * 45_deg; // 초당 45도 회전

		// 회전하여 그리기 (중심점 기준)
		texture.scaled(0.5).rotated(angle).drawAt(200, 200);

		// 좌우 반전
		texture.scaled(0.5).flipped().draw(400, 50);

		// 상하 반전
		texture.scaled(0.5).mirrored().draw(400, 300);

		// 회전 + 반전 조합
		texture
			.flipped()          // 세로 반전
			.scaled(0.3)
			.rotated(angle)
			.drawAt(600, 400);

		font{ 18 }(U"회전: {:.0f}도"_fmt(Math::ToDegrees(angle)))
			.draw(20, 20, Palette::White);
	}
}
```

`rotated()`는 라디안 단위로 회전 각도를 받는다. Siv3D는 `_deg` 리터럴 연산자를 제공하여 도 단위를 쉽게 라디안으로 변환할 수 있다. `flipped()`는 좌우 반전, `mirrored()`는 상하 반전을 수행한다.

### 20.2.4 이미지 영역 자르기
이미지의 특정 영역만 그릴 수 있다. 스프라이트 시트나 타일맵을 다룰 때 유용하다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    const Texture texture{ U"example/windmill.png" };
    
    // 잘라낼 영역 (x, y, width, height)
    Rect clipRect{ 100, 100, 200, 200 };
    bool dragging = false;
    
    const Font font{ FontMethod::SDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 원본 이미지 표시
        texture.draw(0, 0);
        
        // 자르기 영역 표시
        clipRect.drawFrame(3, Palette::Red);
        
        // 자른 영역을 오른쪽에 확대하여 표시
        texture(clipRect).scaled(2.0).draw(texture.width() + 20, 0);
        
        // 마우스로 자르기 영역 이동
        if (clipRect.leftClicked())
        {
            dragging = true;
        }
        
        if (dragging)
        {
            clipRect.moveBy(Cursor::Delta());
            
            if (MouseL.up())
            {
                dragging = false;
            }
        }
        
        font(U"빨간 사각형을 드래그하여 영역 선택")
            .draw(20, texture.height() + 20, Palette::White);
    }
}
```

`texture(clipRect)`는 텍스처의 일부분을 나타내는 `TextureRegion` 객체를 반환한다. 이 객체도 `Texture`와 동일한 그리기 함수들을 지원한다.

### 20.2.5 동적 텍스처 생성
런타임에 텍스처를 생성하거나 수정할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 빈 이미지 생성 (가로 400, 세로 300, 흰색)
    Image image{ 400, 300, Palette::White };
    
    // 픽셀 직접 조작
    for (auto y : step(image.height()))
    {
        for (auto x : step(image.width()))
        {
            // 그라디언트 효과
            const uint8 r = static_cast<uint8>(x * 255 / image.width());
            const uint8 g = static_cast<uint8>(y * 255 / image.height());
            const uint8 b = 128;
            
            image[y][x] = Color{ r, g, b };
        }
    }
    
    // Image를 Texture로 변환
    const Texture texture{ image };
    
    const Font font{ FontMethod::SDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        texture.draw(0, 0);
        
        font(U"프로그래밍으로 생성한 텍스처")
            .draw(20, image.height() + 20, Palette::White);
    }
}
```

`Image` 클래스는 CPU 메모리에서 픽셀 데이터를 조작할 수 있게 해준다. 수정이 완료되면 `Texture`로 변환하여 GPU에서 빠르게 렌더링한다. `image[y][x]`로 개별 픽셀에 접근할 수 있으며, 이는 2차원 배열과 동일한 문법이다.
  

</br>  
  
## 20.3 텍스트 렌더링과 폰트 관리

### 20.3.1 기본 폰트 사용하기
Siv3D는 기본 폰트를 내장하고 있어, 별도의 폰트 파일 없이도 텍스트를 렌더링할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
	// 다양한 크기의 폰트 생성
	const Font font12{ FontMethod::SDF, 12, Typeface::CJK_Regular_KR };
	const Font font24{ FontMethod::SDF, 24, Typeface::CJK_Regular_KR };
	const Font font48{ FontMethod::SDF, 48, Typeface::CJK_Regular_KR };
	const Font font72{ 72, Typeface::CJK_Regular_KR, FontStyle::Bold };

	while (System::Update())
	{
		font12(U"12포인트 텍스트").draw(20, 20, Palette::White);
		font24(U"24포인트 텍스트").draw(20, 50, Palette::Yellow);
		font48(U"48포인트 텍스트").draw(20, 100, Palette::Orange);
		font72(U"72포인트 굵은 글씨").draw(20, 180, Palette::Red);

		// 텍스트 크기 측정
		const auto textSize = font48(U"크기 측정").region().size;
		font24(U"텍스트 크기: {}x{}"_fmt(textSize.x, textSize.y))
			.draw(20, 300, Palette::Skyblue);
	}
}
```

`Font` 생성자의 첫 번째 인자는 폰트 크기다. 두 번째 인자로 `Typeface`를 지정하여 글꼴 스타일을 선택할 수 있다. `region()`은 텍스트가 차지하는 영역을 `Rect` 객체로 반환하며, 이를 통해 텍스트 정렬이나 레이아웃을 계산할 수 있다.

### 20.3.2 커스텀 폰트 로드하기
시스템 폰트나 외부 폰트 파일을 로드하여 사용할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 시스템에 설치된 폰트 사용
    const Font gameFont{ 36, Typeface::Medium, U"Arial" };
    
    // 폰트 파일에서 로드 (TTF, OTF 지원)
    // const Font customFont{ 40, U"path/to/font.ttf" };
    
    // 폰트 로드 실패 확인
    if (!gameFont)
    {
        Print << U"폰트 로드 실패!";
        return;
    }
    
    String text = U"Modern C++ 프로그래밍";
    
    const Font font{ 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        gameFont(text).draw(50, 100, Palette::White);
        
        // 그림자 효과
        const Vec2 shadowOffset{ 3, 3 };
        gameFont(text).draw(50 + shadowOffset.x, 100 + shadowOffset.y, 
                           ColorF{ 0.0, 0.0, 0.0, 0.5 });
        gameFont(text).draw(50, 100, Palette::Yellow);
        
        font(U"폰트: {}"_fmt(gameFont.familyName()))
            .draw(50, 200, Palette::Skyblue);
    }
}
```

폰트 파일을 로드할 때는 파일 경로를 지정한다. 시스템 폰트를 사용할 때는 폰트 이름을 문자열로 전달한다. 한글을 포함한 유니코드 문자를 완벽하게 지원한다.

### 20.3.3 텍스트 정렬과 배치
텍스트를 다양한 방식으로 정렬할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    const Font font{ 30, Typeface::CJK_Regular_KR };
    const String text = U"중앙 정렬 텍스트";
    
    while (System::Update())
    {
        // 왼쪽 정렬 (기본)
        font(U"왼쪽 정렬").draw(20, 50, Palette::White);
        
        // 중앙 정렬
        font(text).drawAt(Scene::Center(), Palette::Yellow);
        
        // 오른쪽 정렬
        const double rightX = Scene::Width() - 20;
        const auto textWidth = font(U"오른쪽 정렬").region().w;
        font(U"오른쪽 정렬").draw(rightX - textWidth, 400, Palette::Orange);
        
        // 특정 영역에 중앙 정렬
        const Rect box{ 100, 500, 400, 100 };
        box.drawFrame(2, Palette::Gray);
        font(U"박스 중앙").drawAt(box.center(), Palette::Skyblue);
        
        // 베이스라인 정렬
        const int32 baseline = 250;
        Line{ 0, baseline, Scene::Width(), baseline }.draw(1, Palette::Red);
        font(U"Baseline Aligned Text").draw(50, baseline - font.height(), 
                                            Palette::White);
    }
}
```

`draw()`는 왼쪽 위를 기준으로 텍스트를 그리고, `drawAt()`은 중심을 기준으로 그린다. `region()`으로 텍스트 영역을 구한 후 수동으로 위치를 계산할 수도 있다.

### 20.3.4 서식 있는 텍스트
텍스트에 다양한 효과와 스타일을 적용할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    const Font font{ 40, , Typeface::CJK_Regular_KR };
    double time = 0.0;
    
    while (System::Update())
    {
        time += Scene::DeltaTime();
        
        // 무지개 색상 텍스트
        const String rainbowText = U"Rainbow Text";
        for (size_t i = 0; i < rainbowText.size(); ++i)
        {
            const double hue = (i * 30.0 + time * 100) % 360;
            const ColorF color = HSV{ hue, 0.8, 1.0 };
            
            font(rainbowText[i]).draw(50 + i * 25, 50, color);
        }
        
        // 외곽선 텍스트
        const String outlineText = U"Outline";
        for (int32 dy = -2; dy <= 2; ++dy)
        {
            for (int32 dx = -2; dx <= 2; ++dx)
            {
                if (dx == 0 && dy == 0) continue;
                font(outlineText).draw(50 + dx, 150 + dy, Palette::Black);
            }
        }
        font(outlineText).draw(50, 150, Palette::Yellow);
        
        // 그라디언트 배경
        const String gradText = U"Gradient Background";
        const auto textRegion = font(gradText).region(50, 250);
        
        RectF{ textRegion }.draw(Arg::top = Palette::Blue, 
                                 Arg::bottom = Palette::Skyblue);
        font(gradText).draw(50, 250, Palette::White);
        
        // 흔들리는 텍스트
        const String shakeText = U"Shake!";
        for (size_t i = 0; i < shakeText.size(); ++i)
        {
            const double offsetY = Math::Sin(time * 10 + i) * 5;
            font(shakeText[i]).draw(50 + i * 30, 350 + offsetY, Palette::Orange);
        }
    }
}
```

각 문자를 개별적으로 그리면 다양한 애니메이션 효과를 만들 수 있다. HSV 색상 공간을 활용하면 무지개 효과를 쉽게 구현할 수 있다.

### 20.3.5 다중 행 텍스트와 워드랩
긴 텍스트를 여러 줄로 나누어 표시할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    const Font font{ 24, Typeface::CJK_Regular_KR };
    const String longText = U"Siv3D는 C++ 프로그래밍을 즐겁게 만드는 "
                           U"크로스플랫폼 라이브러리입니다. "
                           U"게임, 시뮬레이션, 비주얼라이제이션 등 "
                           U"다양한 용도로 활용할 수 있습니다.";
    
    const int32 boxWidth = 500;
    const Rect textBox{ 50, 50, boxWidth, 400 };
    
    while (System::Update())
    {
        textBox.drawFrame(2, Palette::Gray);
        
        // 자동 줄바꿈 텍스트
        font(longText).draw(textBox.stretched(-10), Palette::White);
        
        // 수동 줄바꿈
        const Array<String> lines = {
            U"첫 번째 줄",
            U"두 번째 줄",
            U"세 번째 줄"
        };
        
        int32 yPos = 500;
        for (const auto& line : lines)
        {
            font(line).draw(50, yPos, Palette::Yellow);
            yPos += font.height() + 5; // 줄 간격
        }
    }
}
```

`draw()`에 `Rect`를 전달하면 해당 영역 내에서 자동으로 줄바꿈된다. `stretched()`는 여백을 추가하거나 제거한다. 수동으로 줄바꿈할 때는 `font.height()`로 폰트의 높이를 구하여 줄 간격을 계산한다.
  

</br>  

## 20.4 기본 도형과 커스텀 그래픽

### 20.4.1 기본 도형 그리기
Siv3D는 다양한 기본 도형을 제공한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {
        // 원
        Circle{ 100, 100, 50 }.draw(Palette::Red);
        
        // 사각형
        Rect{ 200, 50, 100, 100 }.draw(Palette::Green);
        
        // 둥근 사각형
        RoundRect{ 350, 50, 100, 100, 20 }.draw(Palette::Blue);
        
        // 삼각형
        Triangle{ Vec2{100, 250}, Vec2{50, 350}, Vec2{150, 350} }
            .draw(Palette::Yellow);
        
        // 타원
        Ellipse{ 250, 300, 80, 50 }.draw(Palette::Purple);
        
        // 다각형
        const Array<Vec2> points = {
            Vec2{400, 250}, Vec2{450, 280}, Vec2{440, 330},
            Vec2{410, 350}, Vec2{370, 320}, Vec2{380, 270}
        };
        Polygon{ points }.draw(Palette::Orange);
        
        // 선
        Line{ 50, 400, 450, 450 }.draw(5, Palette::White);
        
        // 베지어 곡선
        Bezier2{ Vec2{50, 500}, Vec2{250, 400}, Vec2{450, 500} }
            .draw(3, Palette::Skyblue);
    }
}
```

각 도형 클래스는 생성자에서 위치와 크기를 받는다. `draw()` 함수에 색상을 전달하면 해당 색으로 도형이 그려진다. 선과 곡선은 두께를 지정할 수 있다.

### 20.4.2 도형의 외곽선과 채우기
도형을 채우기와 외곽선으로 구분하여 그릴 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {
        // 채워진 원
        Circle{ 100, 100, 50 }.draw(Palette::Red);
        
        // 외곽선만 있는 원
        Circle{ 250, 100, 50 }.drawFrame(3, Palette::Red);
        
        // 채우기 + 외곽선
        Circle{ 400, 100, 50 }.draw(Palette::Red);
        Circle{ 400, 100, 50 }.drawFrame(3, Palette::White);
        
        // 사각형 외곽선
        Rect{ 50, 200, 100, 100 }.drawFrame(2, Palette::Green);
        
        // 안쪽 외곽선
        Rect{ 200, 200, 100, 100 }.draw(Palette::Blue);
        Rect{ 200, 200, 100, 100 }.drawFrame(5, 0, Palette::Yellow);
        
        // 바깥쪽 외곽선
        Rect{ 350, 200, 100, 100 }.draw(Palette::Purple);
        Rect{ 350, 200, 100, 100 }.drawFrame(0, 5, Palette::Orange);
        
        // 그라디언트 채우기
        Rect{ 100, 350, 200, 100 }
            .draw(Arg::top = Palette::Red, Arg::bottom = Palette::Yellow);
        
        Circle{ 400, 400, 60 }
            .draw(Arg::center = Palette::White, Arg::outer = Palette::Blue);
    }
}
```

`drawFrame()`의 첫 번째 인자는 안쪽 외곽선 두께, 두 번째 인자는 바깥쪽 외곽선 두께다. `Arg::top`, `Arg::bottom` 등을 사용하면 그라디언트 효과를 쉽게 만들 수 있다.

### 20.4.3 도형의 변형과 애니메이션
도형을 이동, 회전, 크기 조정할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    double time = 0.0;
    
    while (System::Update())
    {
        time += Scene::DeltaTime();
        
        // 회전하는 사각형
        const double angle1 = time * 90_deg;
        RectF{ Arg::center = Vec2{150, 150}, 80, 80 }
            .rotated(angle1)
            .draw(Palette::Red);
        
        // 크기가 변하는 원
        const double scale = 1.0 + Math::Sin(time * 2) * 0.3;
        Circle{ 350, 150, static_cast<int32>(40 * scale) }
            .draw(Palette::Blue);
        
        // 움직이는 삼각형
        const double x = 250 + Math::Cos(time) * 100;
        const double y = 350;
        Triangle{ Vec2{x, y - 30}, Vec2{x - 30, y + 30}, Vec2{x + 30, y + 30} }
            .draw(Palette::Green);
        
        // 확대/회전/이동 조합
        const double angle2 = time * 180_deg;
        const double scale2 = 1.0 + Math::Sin(time * 3) * 0.2;
        const Vec2 pos = Scene::Center() + Vec2{Math::Cos(time * 2) * 150, 0};
        
        RectF{ Arg::center = pos, 60 * scale2, 60 * scale2 }
            .rotated(angle2)
            .draw(Palette::Yellow);
    }
}
```

`rotated()`는 도형을 회전시킨다. 시간에 따라 각도나 크기를 변화시키면 자연스러운 애니메이션을 만들 수 있다. 삼각 함수(`Math::Sin`, `Math::Cos`)를 활용하면 주기적인 움직임을 구현할 수 있다.

### 20.4.4 복잡한 도형 조합하기
여러 도형을 조합하여 복잡한 형태를 만들 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {
        // 눈사람 그리기
        const Vec2 basePos{ 150, 400 };
        
        // 몸통
        Circle{ basePos, 60 }.draw(Palette::White);
        Circle{ basePos.movedBy(0, -100), 45 }.draw(Palette::White);
        Circle{ basePos.movedBy(0, -170), 35 }.draw(Palette::White);
        
        // 눈
        Circle{ basePos.movedBy(-15, -180), 5 }.draw(Palette::Black);
        Circle{ basePos.movedBy(15, -180), 5 }.draw(Palette::Black);
        
        // 코 (삼각형)
        Triangle{ basePos.movedBy(0, -170), 
                 basePos.movedBy(30, -165), 
                 basePos.movedBy(0, -160) }
            .draw(Palette::Orange);
        
        // 버튼
        for (int32 i = 0; i < 3; ++i)
        {
            Circle{ basePos.movedBy(0, -80 + i * 30), 5 }
                .draw(Palette::Black);
        }
        
        // 집 그리기
        const Vec2 housePos{ 450, 300 };
        
        // 벽
        Rect{ Arg::bottomCenter = housePos, 150, 120 }
            .draw(Palette::Brown);
        
        // 지붕
        Triangle{ housePos.movedBy(0, -120), 
                 housePos.movedBy(-90, -30), 
                 housePos.movedBy(90, -30) }
            .draw(Palette::Red);
        
        // 문
        Rect{ Arg::bottomCenter = housePos.movedBy(0, 0), 40, 60 }
            .draw(Palette::Saddlebrown);
        
        // 창문
        Rect{ housePos.movedBy(-40, -70), 30, 30 }
            .draw(Palette::Skyblue);
        Rect{ housePos.movedBy(40, -70), 30, 30 }
            .draw(Palette::Skyblue);
    }
}
```

`movedBy()`는 도형을 상대적으로 이동시킨다. 기준점을 정하고 거기서부터 상대 좌표로 다른 요소들을 배치하면, 전체 구조를 쉽게 이동시킬 수 있다.

### 20.4.5 커스텀 도형 그리기
정점 배열을 사용하여 자유로운 형태를 그릴 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 별 모양 만들기
    Array<Vec2> createStar(const Vec2& center, double radius, int32 points)
    {
        Array<Vec2> vertices;
        const double angleStep = Math::TwoPi / (points * 2);
        
        for (int32 i = 0; i < points * 2; ++i)
        {
            const double angle = i * angleStep - Math::HalfPi;
            const double r = (i % 2 == 0) ? radius : radius * 0.4;
            
            vertices.push_back(center + Vec2{
                Math::Cos(angle) * r,
                Math::Sin(angle) * r
            });
        }
        
        return vertices;
    }
    
    double rotation = 0.0;
    
    while (System::Update())
    {
        rotation += Scene::DeltaTime() * 45_deg;
        
        // 5각 별
        auto star5 = createStar(Vec2{ 150, 150 }, 60, 5);
        Polygon{ star5 }.draw(Palette::Yellow);
        
        // 8각 별 (회전)
        auto star8 = createStar(Vec2{ 400, 150 }, 80, 8);
        
        // 회전 변환
        for (auto& vertex : star8)
        {
            const Vec2 centered = vertex - Vec2{ 400, 150 };
            const double cos_r = Math::Cos(rotation);
            const double sin_r = Math::Sin(rotation);
            
            vertex = Vec2{
                centered.x * cos_r - centered.y * sin_r,
                centered.x * sin_r + centered.y * cos_r
            } + Vec2{ 400, 150 };
        }
        
        Polygon{ star8 }.draw(Palette::Orange);
        
        // 하트 모양
        Array<Vec2> heart;
        const Vec2 heartCenter{ 250, 400 };
        const int32 segments = 100;
        
        for (int32 i = 0; i <= segments; ++i)
        {
            const double t = i * Math::TwoPi / segments;
            const double x = 16 * Math::Pow(Math::Sin(t), 3);
            const double y = -(13 * Math::Cos(t) - 5 * Math::Cos(2 * t) 
                              - 2 * Math::Cos(3 * t) - Math::Cos(4 * t));
            
            heart.push_back(heartCenter + Vec2{ x * 5, y * 5 });
        }
        
        Polygon{ heart }.draw(Palette::Red);
    }
}
```

정점 배열로 도형을 정의하면 수학 공식을 활용하여 복잡한 모양을 만들 수 있다. 극좌표계를 사용하면 별이나 원형 패턴을 쉽게 생성할 수 있다.


</br>  
  
## 20.5 색상과 투명도 처리

### 20.5.1 색상 표현 방식
Siv3D는 여러 가지 색상 표현 방식을 지원한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {
        // RGB (0-255)
        Circle{ 100, 100, 40 }.draw(Color{ 255, 0, 0 });
        
        // RGBf (0.0-1.0)
        Circle{ 250, 100, 40 }.draw(ColorF{ 0.0, 1.0, 0.0 });
        
        // HSV (색조, 채도, 명도)
        Circle{ 400, 100, 40 }.draw(HSV{ 240, 1.0, 1.0 }); // 파랑
        
        // 팔레트 색상
        Circle{ 100, 250, 40 }.draw(Palette::Orange);
        
        // 16진수 색상
        Circle{ 250, 250, 40 }.draw(Color{ U"#FF1493" }); // Deep Pink
        
        // HSV로 무지개 만들기
        for (int32 i = 0; i < 360; i += 30)
        {
            const double x = 100 + i;
            const double y = 400;
            
            Circle{ x, y, 15 }.draw(HSV{ static_cast<double>(i), 0.8, 1.0 });
        }
        
        Font{ 18 }(U"RGB").draw(70, 150, Palette::White);
        Font{ 18 }(U"RGBf").draw(220, 150, Palette::White);
        Font{ 18 }(U"HSV").draw(370, 150, Palette::White);
        Font{ 18 }(U"Palette").draw(60, 300, Palette::White);
        Font{ 18 }(U"Hex").draw(220, 300, Palette::White);
    }
}
```

`Color`는 0-255 범위의 정수를 사용하고, `ColorF`는 0.0-1.0 범위의 실수를 사용한다. `HSV`는 색조(Hue), 채도(Saturation), 명도(Value)로 색상을 표현한다. HSV는 색상 애니메이션이나 그라디언트를 만들 때 유용하다.

### 20.5.2 투명도와 알파 블렌딩
알파 채널을 사용하여 반투명 효과를 만들 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    const Texture background{ U"example/windmill.png" };
    
    while (System::Update())
    {
        background.draw(0, 0);
        
        // 다양한 투명도의 사각형
        for (int32 i = 0; i < 5; ++i)
        {
            const double alpha = (i + 1) * 0.2;
            Rect{ 50 + i * 110, 50, 100, 100 }
                .draw(ColorF{ 1.0, 0.0, 0.0, alpha });
        }
        
        // 반투명 원
        Circle{ 300, 300, 80 }.draw(ColorF{ 0.0, 1.0, 0.0, 0.5 });
        Circle{ 350, 300, 80 }.draw(ColorF{ 0.0, 0.0, 1.0, 0.5 });
        
        // 알파 값이 변하는 애니메이션
        const double alpha = Math::Abs(Math::Sin(Scene::Time()));
        Rect{ 100, 450, 150, 100 }
            .draw(ColorF{ 1.0, 1.0, 0.0, alpha });
        
        Font{ 18 }(U"알파: {:.2f}"_fmt(alpha))
            .draw(110, 470, Palette::Black);
    }
}
```

`ColorF`의 네 번째 인자가 알파(투명도) 값이다. 0.0은 완전 투명, 1.0은 완전 불투명이다. 여러 반투명 도형이 겹치면 색상이 혼합된다.

### 20.5.3 블렌드 모드
다양한 블렌드 모드로 색상 혼합 방식을 변경할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    const Texture background{ U"example/windmill.png" };
    
    const Array<std::pair<BlendState, String>> blendModes = {
        { BlendState::Default, U"Default" },
        { BlendState::Additive, U"Additive" },
        { BlendState::Multiplicative, U"Multiplicative" },
        { BlendState::Subtractive, U"Subtractive" }
    };
    
    size_t currentMode = 0;
    
    while (System::Update())
    {
        // 모드 전환
        if (KeyRight.down())
        {
            currentMode = (currentMode + 1) % blendModes.size();
        }
        if (KeyLeft.down())
        {
            currentMode = (currentMode + blendModes.size() - 1) 
                         % blendModes.size();
        }
        
        background.draw(0, 0);
        
        // 현재 블렌드 모드 적용
        const ScopedRenderStates2D blend{ blendModes[currentMode].first };
        
        Circle{ Cursor::Pos(), 80 }.draw(ColorF{ 1.0, 0.0, 0.0, 0.7 });
        Circle{ Cursor::Pos().movedBy(40, 0), 80 }
            .draw(ColorF{ 0.0, 1.0, 0.0, 0.7 });
        Circle{ Cursor::Pos().movedBy(20, 40), 80 }
            .draw(ColorF{ 0.0, 0.0, 1.0, 0.7 });
        
        Font{ 25 }(U"블렌드 모드: {}"_fmt(blendModes[currentMode].second))
            .draw(20, 20, Palette::Yellow);
        
        Font{ 20 }(U"← → 키로 모드 변경")
            .draw(20, 60, Palette::White);
    }
}
```

`ScopedRenderStates2D`는 RAII 패턴을 사용하여 렌더링 상태를 관리한다. 블록 내에서만 특정 블렌드 모드가 적용되고, 블록을 벗어나면 자동으로 이전 상태로 복원된다.

- **Default**: 일반적인 알파 블렌딩
- **Additive**: 색상을 더함 (밝아짐)
- **Multiplicative**: 색상을 곱함 (어두워짐)
- **Subtractive**: 색상을 뺌 (어두워짐)

### 20.5.4 색상 조작과 변환
색상을 프로그래밍으로 조작할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    ColorF baseColor{ 0.8, 0.3, 0.2 };
    double hue = 0.0;
    double saturation = 0.8;
    double brightness = 0.8;
    
    while (System::Update())
    {
        // HSV 슬라이더
        SimpleGUI::Slider(U"색조", hue, 0.0, 360.0, Vec2{ 20, 20 }, 150, 300);
        SimpleGUI::Slider(U"채도", saturation, 0.0, 1.0, Vec2{ 20, 70 }, 150, 300);
        SimpleGUI::Slider(U"명도", brightness, 0.0, 1.0, Vec2{ 20, 120 }, 150, 300);
        
        // HSV로부터 색상 생성
        const ColorF color = HSV{ hue, saturation, brightness };
        
        // 큰 사각형으로 색상 표시
        Rect{ 20, 200, 450, 200 }.draw(color);
        
        // 색상 정보 표시
        Font{ 20 }(U"RGB: ({:.2f}, {:.2f}, {:.2f})"_fmt(
            color.r, color.g, color.b))
            .draw(20, 420, Palette::White);
        
        // 보색 (Hue를 180도 회전)
        const ColorF complementary = HSV{ hue + 180, saturation, brightness };
        Rect{ 500, 200, 100, 200 }.draw(complementary);
        Font{ 18 }(U"보색").draw(520, 410, Palette::White);
        
        // 어두운 버전
        const ColorF darker = color * 0.5;
        Rect{ 620, 200, 100, 200 }.draw(darker);
        Font{ 18 }(U"어두움").draw(630, 410, Palette::White);
        
        // 밝은 버전
        const ColorF lighter = color.lerp(Palette::White, 0.5);
        Rect{ 740, 200, 100, 200 }.draw(lighter);
        Font{ 18 }(U"밝음").draw(760, 410, Palette::White);
    }
}
```

`lerp()`는 두 색상 사이를 보간한다. 0.0에서 1.0 사이의 값으로 혼합 비율을 조절할 수 있다. 색상에 스칼라를 곱하면 밝기를 조절할 수 있다.

### 20.5.5 그라디언트 고급 기법
복잡한 그라디언트를 만들 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {
        // 수평 그라디언트
        Rect{ 20, 20, 200, 100 }
            .draw(Arg::left = Palette::Red, Arg::right = Palette::Blue);
        
        // 수직 그라디언트
        Rect{ 240, 20, 200, 100 }
            .draw(Arg::top = Palette::Yellow, Arg::bottom = Palette::Green);
        
        // 원형 그라디언트
        Circle{ 120, 220, 80 }
            .draw(Arg::center = Palette::White, Arg::outer = Palette::Purple);
        
        // 커스텀 그라디언트 (수동)
        for (int32 y = 0; y < 200; ++y)
        {
            const double t = y / 200.0;
            const ColorF color = ColorF{ 1.0, t, 1.0 - t };
            
            Line{ 460, 20 + y, 660, 20 + y }.draw(color);
        }
        
        // 다중 색상 그라디언트
        for (int32 x = 0; x < 400; ++x)
        {
            const double t = x / 400.0;
            ColorF color;
            
            if (t < 0.33)
            {
                color = ColorF{ 1.0, 0.0, 0.0 }.lerp(
                    ColorF{ 1.0, 1.0, 0.0 }, t / 0.33);
            }
            else if (t < 0.67)
            {
                color = ColorF{ 1.0, 1.0, 0.0 }.lerp(
                    ColorF{ 0.0, 1.0, 0.0 }, (t - 0.33) / 0.34);
            }
            else
            {
                color = ColorF{ 0.0, 1.0, 0.0 }.lerp(
                    ColorF{ 0.0, 0.0, 1.0 }, (t - 0.67) / 0.33);
            }
            
            Line{ 20 + x, 350, 20 + x, 450 }.draw(color);
        }
        
        Font{ 16 }(U"수평").draw(70, 130, Palette::White);
        Font{ 16 }(U"수직").draw(290, 130, Palette::White);
        Font{ 16 }(U"원형").draw(90, 310, Palette::White);
        Font{ 16 }(U"커스텀").draw(540, 230, Palette::White);
        Font{ 16 }(U"다중 색상").draw(180, 460, Palette::White);
    }
}
```

선을 반복해서 그리면서 색상을 점진적으로 변경하면 복잡한 그라디언트를 만들 수 있다. `lerp()`를 연속적으로 사용하면 여러 색상을 거치는 그라디언트를 구현할 수 있다.
  

</br>  
  
## 20.6 실습 문제

### 문제 1: 이미지 갤러리 뷰어
여러 이미지를 전환하면서 볼 수 있는 간단한 갤러리를 만들어보자.

**요구사항:**
1. 프로그램 시작 시 `example` 폴더의 이미지들을 로드한다
2. 좌우 화살표 키로 이미지를 전환할 수 있다
3. 현재 이미지 번호와 총 이미지 개수를 표시한다
4. 이미지가 화면보다 크면 자동으로 축소한다
5. Space 키를 누르면 확대/축소 모드를 전환한다

**힌트:**
```cpp
// 폴더의 파일 목록 가져오기
const Array<FilePath> files = FileSystem::DirectoryContents(U"example", false);

// 이미지 파일만 필터링
Array<Texture> textures;
for (const auto& file : files)
{
    if (FileSystem::Extension(file) == U"png" || 
        FileSystem::Extension(file) == U"jpg")
    {
        textures.emplace_back(file);
    }
}
```

### 문제 2: 동적 타이틀 화면
게임의 타이틀 화면을 만들어보자.

**요구사항:**
1. 배경에 그라디언트 또는 이미지를 사용한다
2. 게임 타이틀이 천천히 위아래로 흔들린다
3. "게임 시작", "옵션", "종료" 버튼이 있다
4. 마우스를 버튼 위에 올리면 색상이 변한다
5. 버튼을 클릭하면 해당 동작을 Print로 출력한다
6. 배경에 별이 반짝이는 애니메이션을 추가한다

**힌트:**
```cpp
struct Star
{
    Vec2 pos;
    double brightness;
    double speed;
};

// 별 밝기 변화
star.brightness += star.speed * Scene::DeltaTime();
if (star.brightness > 1.0 || star.brightness < 0.3)
{
    star.speed *= -1;
}
```

### 문제 3: 색상 팔레트 생성기
HSV 색상 공간을 탐색하는 도구를 만들어보자.

**요구사항:**
1. 색조(Hue) 슬라이더로 기본 색상을 선택한다
2. 선택한 색상의 다양한 변형(밝기, 채도 변화)을 격자로 표시한다
3. 각 색상 칸을 클릭하면 RGB 값이 클립보드에 복사된다
4. 선택한 색상으로 큰 미리보기 영역을 표시한다
5. 보색, 유사색, 3색 조화 색상을 자동으로 생성하여 표시한다

**힌트:**
```cpp
// 클립보드에 복사
Clipboard::SetText(U"#{:02X}{:02X}{:02X}"_fmt(
    static_cast<int>(color.r * 255),
    static_cast<int>(color.g * 255),
    static_cast<int>(color.b * 255)
));

// 3색 조화 (120도씩 간격)
ColorF color1 = HSV{ hue, sat, val };
ColorF color2 = HSV{ hue + 120, sat, val };
ColorF color3 = HSV{ hue + 240, sat, val };
```
   
</br>  


## 20.7 심화 내용

### 20.7.1 셰이더를 활용한 효과
Siv3D는 픽셀 셰이더를 지원하여 GPU에서 실행되는 커스텀 효과를 만들 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    const Texture texture{ U"example/windmill.png" };
    
    // 간단한 픽셀 셰이더 (그레이스케일)
    const PixelShader ps = HLSL{ U"example/shader/grayscale.hlsl", U"PS" }
        | GLSL{ U"example/shader/grayscale.frag", {{ U"PSConstants2D", 0 }} };
    
    if (!ps)
    {
        Print << U"셰이더 로드 실패";
        return;
    }
    
    bool useShader = false;
    
    while (System::Update())
    {
        if (KeySpace.down())
        {
            useShader = !useShader;
        }
        
        if (useShader)
        {
            const ScopedCustomShader2D shader{ ps };
            texture.draw(0, 0);
        }
        else
        {
            texture.draw(0, 0);
        }
        
        Font{ 25 }(useShader ? U"셰이더 ON" : U"셰이더 OFF")
            .draw(20, 20, Palette::Yellow);
        
        Font{ 20 }(U"Space: 셰이더 전환")
            .draw(20, 60, Palette::White);
    }
}
```

셰이더를 사용하면 블러, 모자이크, 왜곡 등 다양한 이미지 효과를 실시간으로 적용할 수 있다. 하지만 셰이더 프로그래밍은 별도의 학습이 필요하므로, 초급 단계에서는 Siv3D가 제공하는 기본 효과를 활용하는 것을 권장한다.

### 20.7.2 렌더 텍스처
화면에 직접 그리지 않고 텍스처에 그린 후, 그 텍스처를 활용할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 렌더 타겟 생성 (400x400)
    RenderTexture renderTexture{ 400, 400, Palette::White };
    
    Array<Vec2> drawPoints;
    
    while (System::Update())
    {
        // 마우스로 렌더 텍스처에 그리기
        if (MouseL.pressed())
        {
            drawPoints.push_back(Cursor::PosF());
        }
        
        if (MouseR.down())
        {
            drawPoints.clear();
        }
        
        // 렌더 타겟 변경
        {
            const ScopedRenderTarget2D target{ renderTexture };
            
            // 이전에 그린 내용 유지
            // renderTexture.clear(Palette::White); // 지우려면 주석 해제
            
            // 선 그리기
            for (size_t i = 1; i < drawPoints.size(); ++i)
            {
                Line{ drawPoints[i - 1], drawPoints[i] }
                    .draw(5, Palette::Red);
            }
        }
        
        // 렌더 텍스처를 화면에 표시
        renderTexture.draw(0, 0);
        
        // 같은 내용을 축소하여 오른쪽에 표시
        renderTexture.scaled(0.5).draw(450, 0);
        
        // 회전하여 아래에 표시
        renderTexture.scaled(0.3).rotated(Scene::Time() * 30_deg)
            .drawAt(600, 450);
        
        Font{ 20 }(U"왼쪽 클릭: 그리기, 오른쪽 클릭: 지우기")
            .draw(20, 420, Palette::Black);
    }
}
```

`RenderTexture`는 일종의 오프스크린 버퍼다. 여기에 그린 내용은 텍스처로 저장되며, 이를 다시 화면에 그릴 수 있다. 이를 활용하면 복잡한 그래픽을 한 번만 렌더링하고 재사용할 수 있어 성능이 향상된다.

### 20.7.3 파티클 시스템
많은 수의 작은 개체를 효율적으로 관리하는 파티클 시스템을 구현할 수 있다.

```cpp
# include <Siv3D.hpp>

struct Particle
{
    Vec2 pos;
    Vec2 velocity;
    ColorF color;
    double lifetime;
    double maxLifetime;
    
    void update(double deltaTime)
    {
        pos += velocity * deltaTime;
        velocity.y += 100 * deltaTime; // 중력
        lifetime -= deltaTime;
    }
    
    bool isAlive() const
    {
        return lifetime > 0;
    }
    
    void draw() const
    {
        const double alpha = lifetime / maxLifetime;
        Circle{ pos, 5 }.draw(color.withAlpha(alpha));
    }
};

void Main()
{
    Array<Particle> particles;
    
    while (System::Update())
    {
        // 마우스 위치에서 파티클 생성
        if (MouseL.pressed())
        {
            for (int32 i = 0; i < 5; ++i)
            {
                Particle p;
                p.pos = Cursor::PosF();
                
                const double angle = Random(Math::TwoPi);
                const double speed = Random(50.0, 150.0);
                p.velocity = Vec2{ Math::Cos(angle), Math::Sin(angle) } * speed;
                
                p.color = HSV{ Random(360.0), 0.8, 1.0 };
                p.lifetime = p.maxLifetime = Random(1.0, 2.0);
                
                particles.push_back(p);
            }
        }
        
        // 파티클 업데이트
        const double deltaTime = Scene::DeltaTime();
        for (auto& particle : particles)
        {
            particle.update(deltaTime);
        }
        
        // 죽은 파티클 제거
        particles.remove_if([](const Particle& p) { return !p.isAlive(); });
        
        // 파티클 그리기
        for (const auto& particle : particles)
        {
            particle.draw();
        }
        
        Font{ 20 }(U"파티클 수: {}"_fmt(particles.size()))
            .draw(20, 20, Palette::White);
        
        Font{ 18 }(U"마우스를 누르고 있으세요")
            .draw(20, 50, Palette::Yellow);
    }
}
```

파티클 시스템은 불, 연기, 폭발, 마법 효과 등을 구현할 때 유용하다. 각 파티클은 독립적인 생명주기와 물리 법칙을 가지며, 많은 수의 파티클이 모여 복잡한 시각 효과를 만든다.

### 20.7.4 텍스처 아틀라스 최적화
많은 작은 이미지를 개별적으로 로드하는 대신, 하나의 큰 텍스처에 모아서 사용하면 성능이 향상된다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 타일 시트 로드
    const Texture tileSheet{ U"example/texture.png" };
    
    // 각 타일의 크기
    constexpr Size tileSize{ 32, 32 };
    
    // 타일 맵 (2D 배열로 타일 인덱스 저장)
    const Grid<int32> tileMap = {
        {0, 1, 0, 1, 0, 1, 0, 1},
        {1, 2, 2, 2, 2, 2, 2, 0},
        {0, 2, 3, 3, 3, 3, 2, 1},
        {1, 2, 3, 4, 4, 3, 2, 0},
        {0, 2, 3, 4, 4, 3, 2, 1},
        {1, 2, 3, 3, 3, 3, 2, 0},
        {0, 2, 2, 2, 2, 2, 2, 1},
        {1, 0, 1, 0, 1, 0, 1, 0}
    };
    
    while (System::Update())
    {
        for (auto y : step(tileMap.height()))
        {
            for (auto x : step(tileMap.width()))
            {
                const int32 tileIndex = tileMap[y][x];
                
                // 타일 시트에서 해당 타일의 위치 계산
                const int32 tileX = (tileIndex % 4) * tileSize.x;
                const int32 tileY = (tileIndex / 4) * tileSize.y;
                
                // 해당 영역만 잘라서 그리기
                tileSheet(Rect{ tileX, tileY, tileSize })
                    .scaled(2.0) // 2배 확대
                    .draw(x * tileSize.x * 2, y * tileSize.y * 2);
            }
        }
        
        Font{ 20 }(U"타일 맵 렌더링")
            .draw(20, 20, Palette::White);
    }
}
```

타일 기반 게임에서는 이 방법이 필수적이다. 수백, 수천 개의 타일을 효율적으로 렌더링할 수 있다.

### 20.7.5 텍스트 효과 라이브러리 만들기
재사용 가능한 텍스트 효과 시스템을 구축해보자.

```cpp
# include <Siv3D.hpp>

class TextEffect
{
public:
    virtual ~TextEffect() = default;
    virtual void draw(const Font& font, const String& text, 
                     const Vec2& pos, double time) const = 0;
};

class WaveEffect : public TextEffect
{
public:
    void draw(const Font& font, const String& text, 
             const Vec2& pos, double time) const override
    {
        for (size_t i = 0; i < text.size(); ++i)
        {
            const double offsetY = Math::Sin(time * 5 + i * 0.5) * 10;
            font(text[i]).draw(pos.x + i * 25, pos.y + offsetY, 
                             Palette::White);
        }
    }
};

class RainbowEffect : public TextEffect
{
public:
    void draw(const Font& font, const String& text, 
             const Vec2& pos, double time) const override
    {
        for (size_t i = 0; i < text.size(); ++i)
        {
            const double hue = (i * 30.0 + time * 100) % 360;
            font(text[i]).draw(pos.x + i * 25, pos.y, 
                             HSV{ hue, 0.8, 1.0 });
        }
    }
};

class ShakeEffect : public TextEffect
{
public:
    void draw(const Font& font, const String& text, 
             const Vec2& pos, double time) const override
    {
        for (size_t i = 0; i < text.size(); ++i)
        {
            const double offsetX = Random(-2.0, 2.0);
            const double offsetY = Random(-2.0, 2.0);
            font(text[i]).draw(pos.x + i * 25 + offsetX, 
                             pos.y + offsetY, Palette::Red);
        }
    }
};

void Main()
{
    const Font font{ 40 };
    const String text = U"Text Effects!";
    double time = 0.0;
    
    Array<std::unique_ptr<TextEffect>> effects;
    effects.push_back(std::make_unique<WaveEffect>());
    effects.push_back(std::make_unique<RainbowEffect>());
    effects.push_back(std::make_unique<ShakeEffect>());
    
    while (System::Update())
    {
        time += Scene::DeltaTime();
        
        effects[0]->draw(font, text, Vec2{ 50, 100 }, time);
        effects[1]->draw(font, text, Vec2{ 50, 200 }, time);
        effects[2]->draw(font, text, Vec2{ 50, 300 }, time);
        
        Font{ 20 }(U"Wave Effect").draw(50, 150, Palette::Yellow);
        Font{ 20 }(U"Rainbow Effect").draw(50, 250, Palette::Yellow);
        Font{ 20 }(U"Shake Effect").draw(50, 350, Palette::Yellow);
    }
}
```

다형성을 활용하여 다양한 텍스트 효과를 통일된 인터페이스로 관리할 수 있다. 새로운 효과를 추가하려면 `TextEffect`를 상속받는 클래스를 만들기만 하면 된다.
  

</br>  

## 20.8 정리
이번 장에서는 Siv3D의 강력한 그래픽 기능을 배웠다. 이미지 로드와 변형, 다양한 폰트로 텍스트 렌더링, 기본 도형부터 복잡한 커스텀 그래픽까지 다루었다.

**핵심 요점:**

1. `Texture` 클래스는 RAII 패턴으로 자동 메모리 관리를 제공하며, 다양한 이미지 포맷을 지원한다.

2. 메서드 체이닝을 통해 이미지 변형(`scaled`, `rotated`, `flipped`)을 직관적으로 조합할 수 있다.

3. `Font` 클래스로 유니코드 텍스트를 완벽하게 지원하며, 다양한 정렬과 효과를 쉽게 적용할 수 있다.

4. 기본 도형 클래스들(`Circle`, `Rect`, `Triangle` 등)은 충돌 감지, 마우스 상호작용 등 유용한 기능을 내장하고 있다.

5. HSV 색상 공간을 활용하면 색상 애니메이션과 그라디언트를 쉽게 만들 수 있다.

6. 블렌드 모드와 투명도를 조합하여 다양한 시각 효과를 구현할 수 있다.

Modern C++의 스마트 포인터, RAII, 람다 표현식 등을 활용하면 복잡한 그래픽 시스템도 안전하고 명확하게 구현할 수 있다. 다음 장에서는 시간과 애니메이션을 다루어 그래픽에 생명을 불어넣는 방법을 배운다.


 