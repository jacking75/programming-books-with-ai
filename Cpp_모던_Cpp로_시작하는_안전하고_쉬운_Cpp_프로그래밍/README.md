# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

----- 
  
## 📄 01.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 1: Modern C++와의 첫 만남
  - 1.1 C++의 진화와 Modern C++의 철학
    - C++은 정말 어려운 언어일까?
    - Modern C++의 핵심 철학
    - 왜 지금 C++을 배워야 할까?
  - 1.2 안전하고 사용하기 쉬운 C++23의 특징
    - 1. 스마트 포인터 - 자동 메모리 관리
    - 2. auto 키워드 - 타입 추론
    - 3. Range-based for loop - 간결한 반복문
    - 4. std::optional - 값의 부재 표현
    - 5. std::format - 현대적인 문자열 포매팅 (C++20)
    - 6. Concepts - 템플릿 제약 (C++20)
    - 7. Ranges - 강력한 데이터 처리 (C++20)
    - 8. Lambda 표현식 - 간단한 함수 정의
    - C++23의 새로운 기능
  - 1.3 Visual Studio 2022 설치 및 프로젝트 생성
    - Visual Studio 2022 다운로드 및 설치
    - 첫 번째 C++ 프로젝트 만들기
    - 프로젝트 구조 이해하기
  - 1.4 첫 번째 "Hello, World!" 프로그램
    - 기본 코드 살펴보기
    - 코드 분석
    - Modern C++ 스타일로 개선하기
    - 프로그램 실행하기
    - 코드 수정 실습
      - 실습 1: 자기소개 프로그램 만들기
      - 실습 2: 간단한 계산 결과 출력하기
      - 실습 3: 여러 줄 출력하기
    - 오류 발생 시 대처하기
    - Visual Studio의 도움 기능 활용하기
  - 1.5 Chapter 1 요약 및 복습
    - 핵심 개념 정리
    - C++ 프로그램의 기본 구조
    - 복습 문제
    - 다음 챕터 미리보기
    - 추가 학습 자료
    - 학습 체크리스트
  - 마치며

## 📄 02.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 2: 개발 환경 마스터하기
  - 2.1 Visual Studio 2022 인터페이스 익히기
    - 주요 인터페이스 구성 요소
    - 창 레이아웃 관리
    - 유용한 단축키 모음
    - 인터페이스 커스터마이징
    - 실습: 인터페이스 탐험하기
  - 2.2 디버깅 기초와 오류 해결
    - 디버깅이란?
    - 중단점 (Breakpoint) 사용하기
    - 프로그램 실행 제어
    - 변수 값 확인하기
    - 조건부 중단점
    - 호출 스택 (Call Stack) 이해하기
    - 일반적인 오류와 해결 방법
    - 디버깅 실습 문제
  - 2.3 IntelliSense와 코드 자동완성 활용
    - IntelliSense란?
    - 자동 완성 사용하기
    - 멤버 목록 보기
    - 매개변수 정보 확인
    - 빠른 정보 (Quick Info)
    - 정의로 이동
    - 코드 스니펫 (Code Snippets)
    - 스니펫 관리자
    - 리팩터링 도구
    - 빠른 작업 및 수정 (Quick Actions)
    - IntelliSense 설정 조정
    - 실습: IntelliSense 마스터하기
  - 2.4 프로젝트 설정과 C++23 표준 활성화
    - 프로젝트 속성 창 열기
    - 구성(Configuration)과 플랫폼(Platform)
    - C++ 언어 표준 설정
    - 경고 수준 설정
    - 추가 포함 디렉터리
    - 전처리기 정의
    - 최적화 설정
    - 런타임 라이브러리
    - 출력 디렉터리 및 중간 디렉터리
    - 문자 집합 설정
    - 프로젝트 설정 실습
    - 속성 시트로 설정 재사용
    - 빌드 구성 이해하기
    - 프로젝트 설정 체크리스트
    - 일반적인 설정 문제 해결
    - 프로젝트 템플릿 만들기
  - 2.5 Chapter 2 요약 및 복습
    - 핵심 개념 정리
    - 필수 단축키 정리
    - 복습 문제
    - 다음 챕터 미리보기
    - 학습 체크리스트
  - 마치며

## 📄 03.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 3: 데이터 타입과 변수
  - 3.1 기본 데이터 타입
    - 왜 데이터 타입이 필요할까?
    - 정수 타입 (int)
    - 실수 타입 (double, float)
    - 논리 타입 (bool)
    - 문자 타입 (char)
    - 문자열 타입 (std::string)
    - 데이터 타입 크기 확인하기
    - 실습 예제 1: 데이터 타입 사용하기
  - 3.2 변수 선언과 초기화
    - 변수 선언의 기본
    - 안전한 초기화 방법
    - 0으로 초기화
    - 여러 변수 동시 선언
    - 변수 이름 짓기 규칙
    - 실습 예제 2: 안전한 변수 초기화
  - 3.3 auto 키워드와 타입 추론
    - auto의 기본 사용법
    - auto가 타입을 추론하는 방법
    - auto의 장점
    - auto 사용 시 주의사항
    - auto와 중괄호 초기화
    - auto를 사용해야 할 때 vs 사용하지 말아야 할 때
    - 실습 예제 3: auto 활용하기
  - 3.4 상수와 const, constexpr의 차이점
    - const: 런타임 상수
    - constexpr: 컴파일 타임 상수
    - const, constexpr, #define 비교
    - 언제 무엇을 사용할까?
    - 상수와 참조
    - 실습 예제 4: 상수 활용하기
  - 3.5 종합 실습 문제
    - 실습 1: 개인 정보 관리 프로그램
    - 실습 2: 상품 정보 시스템
    - 실습 3: 게임 캐릭터 스탯 시스템
  - 3.6 심화 내용
    - 타입 별칭 (Type Alias)
    - 리터럴 (Literals)
    - 사용자 정의 리터럴 (User-Defined Literals)
    - sizeof 연산자 심화
  - 3.7 Chapter 3 요약 및 복습
    - 핵심 개념 정리
    - 코딩 스타일 가이드
    - 복습 문제
    - 학습 체크리스트
  - 마치며

## 📄 04.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 4: 연산자와 표현식
  - 4.1 산술 연산자
    - 기본 산술 연산자
    - 실수 연산과 정밀도
    - 나머지 연산자의 활용
    - 증감 연산자
  - 4.2 비교 연산자
    - 기본 비교 연산자
    - 실수 비교의 주의사항
    - 문자열 비교
  - 4.3 논리 연산자
    - 기본 논리 연산자
    - 단락 평가 (Short-circuit Evaluation)
    - 복잡한 조건 표현
  - 4.4 대입 연산자와 복합 대입 연산자
    - 기본 대입 연산자
    - 복합 대입 연산자
    - 실용적인 활용 예제
  - 4.5 연산자 우선순위와 괄호 사용
    - 기본 우선순위
    - 주요 연산자 우선순위 표
    - 명확한 코드를 위한 괄호 사용
    - 실용적인 예제: 할인 계산기
  - 4.6 실습 예제: 계산기 프로그램
  - 4.7 실습 문제
    - 문제 1: 온도 변환기
    - 문제 2: BMI 계산기
    - 문제 3: 윤년 판정
    - 문제 4: 시간 계산기
  - 4.8 심화 내용
    - 비트 연산자
    - 비트 연산자의 실용적 활용
    - 삼항 연산자
    - comma 연산자
    - sizeof 연산자
  - 정리

## 📄 05.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 5: 입력과 출력
  - 5.1 std::cout과 std::cin 기초
    - 기본 출력
    - std::endl과 \n의 차이
    - 기본 입력
    - 입력 오류 처리
    - 실용적인 입력 함수 작성
  - 5.2 서식 지정자와 std::format, std::print (C++20/C++23)
    - std::format 기본 사용법
    - std::print (C++23)
    - 서식 지정자
    - 실수 서식
    - 문자열 서식
    - 실용적인 표 만들기
    - 색상 출력 (터미널 지원 시)
  - 5.3 문자열 입출력과 getline
    - std::cin의 한계
    - std::getline 사용
    - std::cin과 std::getline 혼용 시 주의사항
    - 구분자를 지정한 입력
    - CSV 파싱 예제
    - 여러 줄 입력 받기
  - 5.4 파일 입출력 기초
    - 파일에 쓰기
    - 파일에서 읽기
    - 파일 열기 모드
    - 구조화된 데이터 저장과 로드
    - 이진 파일 입출력
    - 파일 존재 여부 확인
  - 5.5 실습 예제: 메모장 프로그램
  - 5.6 실습 문제
    - 문제 1: 단어 카운터
    - 문제 2: 성적 관리 프로그램
    - 문제 3: 로그 파일 생성기
    - 문제 4: CSV 파일 파서
  - 5.7 심화 내용
    - 스트림 상태 확인
    - 파일 위치 제어
    - 버퍼링 제어
    - 사용자 정의 타입 출력
    - std::format을 활용한 고급 포맷팅
  - 정리

## 📄 06.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 6: 제어문 - 조건문
  - 6.1 if, else if, else 문
    - 기본 if 문
    - if-else 문
    - if-else if-else 문
    - 중괄호 생략
    - 중첩된 if 문
    - 실용적인 예제: 로그인 시스템
  - 6.2 조건식과 불린 표현식
    - 비교 연산자를 사용한 조건
    - 논리 연산자를 사용한 복합 조건
    - 암시적 불린 변환
    - 조건부 초기화 (C++17)
    - constexpr if (C++17)
  - 6.3 switch 문과 case 레이블
    - 기본 switch 문
    - fall-through 동작
    - C++17의 [[fallthrough]] 속성
    - switch 문에서의 변수 선언
    - switch 문의 초기화 (C++17)
    - enum class와 switch
    - 실용적인 예제: 계산기
    - switch 문 vs if-else 선택 기준
  - 6.4 삼항 연산자 (? :)
    - 기본 사용법
    - 값 선택
    - 중첩된 삼항 연산자
    - 삼항 연산자 활용 예제
    - std::format과 함께 사용
    - 주의사항
  - 6.5 실습 예제: 간단한 게임 메뉴
  - 6.6 실습 문제
    - 문제 1: 성적 판정 프로그램
    - 문제 2: 계절 판정
    - 문제 3: 윤년 판정기
    - 문제 4: 자판기 프로그램
  - 6.7 심화 내용
    - 조건 연산자 체이닝
    - Early Return 패턴
    - std::optional을 사용한 조건부 값 (C++17)
    - 구조적 바인딩과 조건문 (C++17)
    - 컴파일 타임 조건 분기
  - 정리

## 📄 07.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 7: 제어문 - 반복문
  - 7.1 `for` 문의 기본 형태
    - 7.1.1 기본 구조
    - 7.1.2 간단한 예제
    - 7.1.3 다양한 `for` 문 활용
    - 7.1.4 중첩 `for` 문
    - 7.1.5 범위 기반 `for` 문 (Range-based for loop)
  - 7.2 `while`과 `do-while` 문
    - 7.2.1 `while` 문의 기본 구조
    - 7.2.2 `while` 문의 실용적 예제
    - 7.2.3 `do-while` 문
    - 7.2.4 `for` vs `while` 선택 기준
  - 7.3 `break`와 `continue` 키워드
    - 7.3.1 `break` - 반복문 탈출
    - 7.3.2 `continue` - 현재 반복 건너뛰기
    - 7.3.3 중첩 반복문에서의 `break`와 `continue`
  - 7.4 무한 루프와 루프 제어
    - 7.4.1 의도하지 않은 무한 루프
    - 7.4.2 의도적인 무한 루프
    - 7.4.3 무한 루프 디버깅
  - 7.5 실습 문제
    - 문제 1: 팩토리얼 계산
    - 문제 2: 피보나치 수열
    - 문제 3: 소수 판별
    - 문제 4: 구구단 출력기
    - 문제 5: 별 찍기 패턴
  - 7.6 심화 내용
    - 7.6.1 반복문 성능 최적화
    - 7.6.2 C++20 Ranges와 반복문
    - 7.6.3 반복문과 알고리즘
    - 7.6.4 반복문 작성 시 주의사항
  - 정리

## 📄 08.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 8: 배열과 문자열의 Modern 접근
  - 8.1 C 스타일 배열의 한계
    - 8.1.1 C 스타일 배열의 기본
    - 8.1.2 C 스타일 배열의 문제점
  - 8.2 `std::array`로 안전한 고정 배열
    - 8.2.1 `std::array`의 기본 사용법
    - 8.2.2 안전한 접근: `at()` vs `[]`
    - 8.2.3 `std::array`의 유용한 기능
    - 8.2.4 범위 기반 `for` 문과 함께 사용
    - 8.2.5 다차원 배열
    - 8.2.6 `std::array` vs C 스타일 배열 비교
  - 8.3 `std::vector`로 동적 배열 관리
    - 8.3.1 `std::vector`의 기본 사용법
    - 8.3.2 다양한 생성 방법
    - 8.3.3 요소 추가와 삭제
    - 8.3.4 벡터의 크기와 용량 관리
    - 8.3.5 실용적인 예제
    - 8.3.6 2차원 벡터
  - 8.4 `std::string`과 문자열 처리
    - 8.4.1 C 스타일 문자열의 문제
    - 8.4.2 `std::string`의 기본 사용법
    - 8.4.3 문자열 입력
    - 8.4.4 문자열 연산
    - 8.4.5 문자열 검색
    - 8.4.6 부분 문자열 추출
    - 8.4.7 문자열 수정
    - 8.4.8 문자열과 숫자 변환
    - 8.4.9 문자열 실용 예제
  - 8.5 Range-based for loop 활용
    - 8.5.1 기본 문법 복습
    - 8.5.2 `auto` 키워드와 함께 사용
    - 8.5.3 문자열 순회
    - 8.5.4 중첩 범위 기반 `for` 문
    - 8.5.5 인덱스가 필요한 경우
  - 8.6 실습 문제
    - 문제 1: 배열 통계
    - 문제 2: 동적 쇼핑 목록
    - 문제 3: 회문 검사
    - 문제 4: 단어 빈도수
    - 문제 5: 성적 등급 분류
  - 8.7 심화 내용
    - 8.7.1 벡터의 메모리 관리 최적화
    - 8.7.2 C++20/23의 새로운 문자열 기능
    - 8.7.3 std::string_view (C++17)
    - 8.7.4 C++20 Ranges와 Views
    - 8.7.5 문자열 포맷팅 (C++20)
  - 정리

## 📄 09.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 9: 함수와 매개변수
  - 9.1 함수 정의와 호출
    - 9.1.1 함수의 기본 구조
    - 9.1.2 반환 값이 없는 함수
    - 9.1.3 함수 선언과 정의 분리
    - 9.1.4 여러 값을 반환하는 방법
    - 9.1.5 재귀 함수
  - 9.2 매개변수 전달 방식
    - 9.2.1 값 전달 (Pass by Value)
    - 9.2.2 참조 전달 (Pass by Reference)
    - 9.2.3 포인터 전달 (Pass by Pointer)
    - 9.2.4 배열 전달
  - 9.3 기본 매개변수와 오버로딩
    - 9.3.1 기본 매개변수
    - 9.3.2 함수 오버로딩
    - 9.3.3 기본 매개변수 vs 오버로딩
  - 9.4 `auto` 반환 타입과 후행 반환 타입
    - 9.4.1 `auto` 반환 타입
    - 9.4.2 후행 반환 타입
    - 9.4.3 `decltype`과 함께 사용
  - 9.5 지역 변수와 전역 변수
    - 9.5.1 지역 변수
    - 9.5.2 전역 변수
    - 9.5.3 정적 변수
    - 9.5.4 constexpr 함수
  - 9.6 실습 문제
    - 문제 1: 온도 변환기
    - 문제 2: 소수 판별 함수
    - 문제 3: 문자열 처리 함수
    - 문제 4: 벡터 연산 함수
    - 문제 5: 계산기 함수
  - 9.7 심화 내용
    - 9.7.1 인라인 함수
    - 9.7.2 함수 템플릿 미리보기
    - 9.7.3 [[nodiscard]] 속성 (C++17)
    - 9.7.4 함수 포인터와 std::function
    - 9.7.5 가변 인자 템플릿 (Variadic Templates)
    - 9.7.6 consteval 함수 (C++20)
  - 정리

## 📄 10.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 10: 람다 표현식과 함수 객체
  - 10.1 람다 표현식이란?
    - 10.1.1 람다 표현식의 기본 문법
    - 10.1.2 람다 표현식의 실용적 활용
  - 10.2 캡처 리스트 이해하기
    - 10.2.1 빈 캡처 리스트 `[]`
    - 10.2.2 값 캡처 `[=]`
    - 10.2.3 참조 캡처 `[&]`
    - 10.2.4 선택적 캡처
    - 10.2.5 this 포인터 캡처
    - 10.2.6 캡처 초기화 (C++14)
  - 10.3 std::function과 함수 포인터
    - 10.3.1 auto를 사용한 저장
    - 10.3.2 std::function 사용하기
    - 10.3.3 함수 포인터
    - 10.3.4 성능 고려사항
  - 10.4 콜백 함수와 이벤트 처리
    - 10.4.1 콜백 함수의 기본 개념
    - 10.4.2 다중 이벤트 핸들러
    - 10.4.3 조건부 콜백
  - 10.5 함수 객체 (Functor)
    - 10.5.1 함수 객체의 기본
    - 10.5.2 상태를 가진 함수 객체
    - 10.5.3 람다 vs 함수 객체
  - 10.6 실습 문제
    - 실습 10-1: 데이터 필터링
    - 실습 10-2: 간단한 계산기
    - 실습 10-3: 이벤트 시스템
  - 10.7 심화 내용
    - 10.7.1 제네릭 람다 (C++14)
    - 10.7.2 템플릿 람다 (C++20)
    - 10.7.3 즉시 실행 람다 (IIFE - Immediately Invoked Function Expression)
    - 10.7.4 재귀 람다
    - 10.7.5 실전 활용: 체이닝 가능한 API

## 📄 11.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 11: 스마트 포인터와 메모리 관리
  - 11.1 포인터와 메모리의 기초 개념
    - 11.1.1 메모리의 종류
    - 11.1.2 포인터의 기본
    - 11.1.3 동적 메모리 할당
  - 11.2 왜 raw pointer는 위험한가?
    - 11.2.1 메모리 누수 (Memory Leak)
    - 11.2.2 댕글링 포인터 (Dangling Pointer)
    - 11.2.3 이중 해제 (Double Delete)
    - 11.2.4 예외 안전성 문제
    - 11.2.5 소유권 불명확
  - 11.3 std::unique_ptr로 단독 소유 관리
    - 11.3.1 unique_ptr의 기본 사용법
    - 11.3.2 unique_ptr의 소유권 이전
    - 11.3.3 배열을 위한 unique_ptr
    - 11.3.4 커스텀 삭제자
    - 11.3.5 unique_ptr의 실전 활용
  - 11.4 std::shared_ptr로 공유 소유 관리
    - 11.4.1 shared_ptr의 기본 사용법
    - 11.4.2 shared_ptr을 사용하는 이유
    - 11.4.3 weak_ptr로 순환 참조 방지
    - 11.4.4 shared_ptr과 unique_ptr의 선택
  - 11.5 RAII 패턴과 자동 리소스 관리
    - 11.5.1 RAII의 기본 개념
    - 11.5.2 RAII를 활용한 커스텀 리소스 관리
    - 11.5.3 스마트 포인터와 RAII
    - 11.5.4 RAII의 장점
  - 11.6 실습 문제
    - 실습 11-1: 게임 인벤토리 시스템
    - 실습 11-2: 텍스처 관리자
    - 실습 11-3: 리소스 풀
  - 11.7 심화 내용
    - 11.7.1 make_unique와 make_shared의 이점
    - 11.7.2 enable_shared_from_this
    - 11.7.3 커스텀 allocator와 스마트 포인터
    - 11.7.4 스마트 포인터 성능 최적화
    - 11.7.5 실전 패턴: 팩토리 함수

## 📄 12.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 12: 컨테이너와 알고리즘
  - 12.1 STL 컨테이너 개요
    - 12.1.1 왜 STL 컨테이너를 사용하는가?
    - 12.1.2 STL 컨테이너의 분류
  - 12.2 std::vector 완전 정복
    - 12.2.1 vector의 기본 사용법
    - 12.2.2 vector의 메모리 관리
    - 12.2.3 vector의 삽입과 삭제
    - 12.2.4 vector의 실전 활용
  - 12.3 std::array - 고정 크기 배열
    - 12.3.1 array의 기본 사용법
    - 12.3.2 array vs vector
    - 12.3.3 array의 실전 활용
  - 12.4 std::map - 키-값 쌍 컨테이너
    - 12.4.1 map의 기본 사용법
    - 12.4.2 map의 고급 기능
    - 12.4.3 map의 실전 활용
  - 12.5 반복자 (Iterator)의 개념과 사용법
    - 12.5.1 반복자의 기본
    - 12.5.2 반복자의 종류
    - 12.5.3 반복자를 활용한 알고리즘
  - 12.6 std::ranges와 알고리즘 라이브러리 (C++20/C++23)
    - `std::ranges`가 도입된 배경과 목표
    - 범위(Range)와 관련 개념
    - Range 관련 개념(Concepts) 계층
    - Range 어댑터와 파이프라인
    - Ranges 알고리즘의 특징
    - 프로젝션과 비교자
    - 이터레이터·센티넬 모델의 실용성
    - 소유 뷰와 비소유 뷰, 수명 관리
    - Borrowed Range와 `dangling` 처리
    - 병렬·범위 알고리즘과의 관계
    - 상호 운용성
    - 성능·예외 안전성 고려사항
    - 표준의 범위와 확장
    - 실무 활용 지침
    - 12.6.1 ranges의 기본 개념
    - 12.6.2 주요 ranges 뷰
    - 12.6.3 ranges 알고리즘
  - 12.7 주요 알고리즘 활용
    - 12.7.1 정렬 알고리즘
    - 12.7.2 검색 알고리즘
    - 12.7.3 변환 알고리즘
    - 12.7.4 집합 알고리즘
  - 12.8 실습 문제
    - 실습 12-1: 학생 관리 시스템
    - 실습 12-2: 단어 통계
    - 실습 12-3: ranges를 활용한 데이터 처리
  - 12.9 심화 내용
    - 12.9.1 커스텀 비교 함수와 함수 객체
    - 12.9.2 알고리즘 성능 비교
    - 12.9.3 컨테이너 선택 가이드
    - 12.9.4 뷰(View)와 지연 평가

## 📄 13.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 13: 클래스와 객체 기초
  - 13.1 클래스와 객체의 개념
    - 13.1.1 객체지향 프로그래밍이란?
    - 13.1.2 클래스 정의하기
    - 13.1.3 객체 생성과 사용
  - 13.2 멤버 변수와 멤버 함수
    - 13.2.1 멤버 변수 (Member Variables)
    - 13.2.2 멤버 함수 (Member Functions)
    - 13.2.3 클래스 내부 정의와 외부 정의
  - 13.3 접근 지정자
    - 13.3.1 접근 지정자의 필요성
    - 13.3.2 세 가지 접근 지정자
    - 13.3.3 캡슐화 (Encapsulation)
  - 13.4 생성자와 소멸자
    - 13.4.1 생성자란?
    - 13.4.2 기본 생성자
    - 13.4.3 매개변수가 있는 생성자
    - 13.4.4 멤버 초기화 리스트
    - 13.4.5 소멸자
    - 13.4.6 생성자와 소멸자의 실행 순서
  - 13.5 `this` 포인터
    - 13.5.1 `this` 포인터란?
    - 13.5.2 매개변수와 멤버 변수 이름이 같을 때
    - 13.5.3 현재 객체의 참조 반환
    - 13.5.4 객체 복사 방지
  - 13.6 실습 예제: 간단한 게임 캐릭터 클래스
  - 13.7 연습 문제
    - 문제 1: 도서 관리 클래스
    - 문제 2: 은행 계좌 클래스 확장
    - 문제 3: 벡터 클래스
  - 13.8 심화 내용
    - 13.8.1 `static` 멤버 변수와 함수
    - 13.8.2 `friend` 함수와 클래스
    - 13.8.3 중첩 클래스 (Nested Class)
  - 13.9 정리

## 📄 14.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 14: 생성자와 소멸자의 Modern 접근
  - 14.1 기본 생성자와 매개변수 생성자 심화
    - 14.1.1 생성자의 종류
    - 14.1.2 기본 인자를 활용한 생성자
    - 14.1.3 명시적 생성자 (explicit)
  - 14.2 생성자 위임과 멤버 초기화 리스트
    - 14.2.1 생성자 위임 (Constructor Delegation)
    - 14.2.2 멤버 초기화 리스트의 중요성
    - 14.2.3 초기화 순서
  - 14.3 복사 생성자와 이동 생성자
    - 14.3.1 복사 생성자 (Copy Constructor)
    - 14.3.2 얕은 복사 vs 깊은 복사
    - 14.3.3 이동 생성자 (Move Constructor) - C++11
    - 14.3.4 언제 복사하고 언제 이동하는가?
  - 14.4 `= default`와 `= delete` 키워드
    - 14.4.1 `= default` - 명시적 기본 구현
    - 14.4.2 `= delete` - 함수 삭제
    - 14.4.3 실용적 예제: 싱글턴 패턴
    - 14.4.4 특정 타입의 함수 오버로드 금지
  - 14.5 Rule of Five와 Rule of Zero
    - 14.5.1 Rule of Three (C++98)
    - 14.5.2 Rule of Five (C++11)
    - 14.5.3 Rule of Zero (Modern C++)
    - 14.5.4 언제 어떤 규칙을 따를까?
  - 14.6 실습 예제: 스마트 문자열 클래스
  - 14.7 연습 문제
    - 문제 1: 동적 배열 클래스
    - 문제 2: Rule of Zero 적용
    - 문제 3: 생성자 위임 연습
  - 14.8 심화 내용
    - 14.8.1 복사 생략과 RVO (Return Value Optimization)
  - 14.9 정리

## 📄 15.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 15: 상속과 다형성
  - 15.1 상속의 기본 개념
    - 15.1.1 상속이란?
    - 15.1.2 상속의 구문
    - 15.1.3 생성자와 소멸자의 호출 순서
    - 15.1.4 파생 클래스에서 기본 클래스 생성자 호출
  - 15.2 `public`, `protected`, `private` 상속
    - 15.2.1 접근 지정자의 의미
    - 15.2.2 상속 방식에 따른 접근 권한 변화
    - 15.2.3 실용적인 예제: 게임 캐릭터 계층
  - 15.3 가상 함수와 `virtual` 키워드
    - 15.3.1 다형성의 필요성
    - 15.3.2 가상 함수의 도입
    - 15.3.3 가상 소멸자의 중요성
  - 15.4 `override`와 `final` 키워드 (C++11)
    - 15.4.1 `override` - 명시적 오버라이딩
    - 15.4.2 `final` - 오버라이딩 금지
    - 15.4.3 실용적 예제: 게임 엔티티 시스템
  - 15.5 순수 가상 함수와 추상 클래스
    - 15.5.1 순수 가상 함수
    - 15.5.2 인터페이스 클래스
    - 15.5.3 추상 클래스 vs 인터페이스
  - 15.6 실습 예제: RPG 스킬 시스템
  - 15.7 연습 문제
    - 문제 1: 도형 계층 구조
    - 문제 2: 차량 관리 시스템
    - 문제 3: 인터페이스 다중 상속
  - 15.8 심화 내용
    - 15.8.1 다중 상속
    - 15.8.2 다이아몬드 문제와 가상 상속
    - 15.8.3 CRTP (Curiously Recurring Template Pattern)
  - 15.9 정리

## 📄 16.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 16: 템플릿 기초
  - 16.1 함수 템플릿의 기본
    - 16.1.1 템플릿이 필요한 이유
    - 16.1.2 기본 함수 템플릿
    - 16.1.3 여러 타입 매개변수 사용
    - 16.1.4 템플릿 특수화 미리보기
  - 16.2 클래스 템플릿 활용
    - 16.2.1 기본 클래스 템플릿
    - 16.2.2 C++17 클래스 템플릿 인자 추론 (CTAD)
    - 16.2.3 여러 매개변수를 가진 클래스 템플릿
    - 16.2.4 템플릿 멤버 함수
  - 16.3 템플릿 특수화
    - 16.3.1 함수 템플릿 특수화
    - 16.3.2 클래스 템플릿 완전 특수화
    - 16.3.3 클래스 템플릿 부분 특수화
  - 16.4 typename과 class 키워드
    - 16.4.1 기본 사용법
    - 16.4.2 typename이 필수인 경우
    - 16.4.3 타입 별칭과 템플릿
  - 16.5 Concepts 기초 (C++20)
    - 16.5.1 Concepts가 필요한 이유
    - 16.5.2 표준 Concepts 사용하기
    - 16.5.3 자체 Concepts 정의하기
    - 16.5.4 requires 표현식의 다양한 사용법
    - 16.5.5 축약 함수 템플릿 (C++20)
  - 16.6 실습 예제: 제네릭 컨테이너 만들기
  - 16.7 실습 문제
    - 문제 1: 제네릭 최소값/최대값 찾기
    - 문제 2: 제네릭 배열 클래스
    - 문제 3: 조건부 컨테이너
  - 16.8 심화 내용
    - 16.8.1 가변 인자 템플릿 (Variadic Templates)
    - 16.8.2 SFINAE와 std::enable_if
    - 16.8.3 템플릿 메타프로그래밍 맛보기
    - 16.8.4 타입 특성 (Type Traits)
  - 16.9 정리

## 📄 17.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 17: 예외 처리와 오류 관리
  - 17.1 예외 처리의 필요성
    - 17.1.1 오류 처리가 없는 코드의 문제점
    - 17.1.2 전통적인 오류 처리 방법의 한계
    - 17.1.3 예외 처리의 장점
  - 17.2 try, catch, throw 키워드
    - 17.2.1 기본 예외 처리 구조
    - 17.2.2 여러 종류의 예외 처리
    - 17.2.3 모든 예외 잡기
    - 17.2.4 예외 다시 던지기
  - 17.3 표준 예외 클래스들
    - 17.3.1 예외 클래스 계층 구조
    - 17.3.2 주요 예외 클래스 사용 예제
    - 17.3.3 사용자 정의 예외 클래스
  - 17.4 std::optional로 값의 부재 표현 (C++17)
    - 17.4.1 std::optional의 기본 사용법
    - 17.4.2 std::optional의 다양한 사용 패턴
    - 17.4.3 std::optional과 예외 처리 비교
    - 17.4.4 std::optional의 고급 기능
  - 17.5 std::expected 소개 (C++23)
    - 17.5.1 std::expected의 기본 개념
    - 17.5.2 std::expected의 실용적 예제
    - 17.5.3 std::expected vs 예외 vs std::optional
  - 17.6 실습 예제: 안전한 파일 처리 시스템
  - 17.7 실습 문제
    - 문제 1: 계산기 예외 처리
    - 문제 2: 안전한 설정 관리자
    - 문제 3: 체인 가능한 파일 처리 파이프라인
  - 17.8 심화 내용
    - 17.8.1 RAII와 예외 안전성
    - 17.8.2 예외 안전성 보장 수준
    - 17.8.3 noexcept 지정자
    - 17.8.4 스택 풀기 (Stack Unwinding)
  - 17.9 정리

## 📄 18.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 18: Siv3D 환경 구축과 첫 GUI
  - 18.1 Siv3D 라이브러리 소개 및 설치
    - 18.1.1 Siv3D란?
    - 18.1.2 Visual Studio 2022에 Siv3D 설치하기
    - 18.1.3 설치 확인
  - 18.2 기본 윈도우 생성과 그래픽 출력
    - 18.2.1 Siv3D 프로그램의 기본 구조
    - 18.2.2 윈도우 설정
    - 18.2.3 장면(Scene) 이해하기
    - 18.2.4 좌표계 이해하기
  - 18.3 기본 도형 그리기와 색상 처리
    - 18.3.1 원(Circle) 그리기
    - 18.3.2 사각형(Rect) 그리기
    - 18.3.3 선(Line)과 다각형 그리기
    - 18.3.4 색상 다루기
    - 18.3.5 다양한 도형 조합하기
  - 18.4 게임 루프와 프레임 관리
    - 18.4.1 게임 루프의 이해
    - 18.4.2 DeltaTime을 활용한 프레임 독립적 움직임
    - 18.4.3 시간 기반 애니메이션
    - 18.4.4 프레임 레이트 제한
    - 18.4.5 Print을 이용한 디버깅
  - 18.5 실습 예제: 간단한 인터랙티브 프로그램
  - 18.6 실습 문제
    - 문제 1: 바운싱 볼
    - 문제 2: 클릭 이펙트
    - 문제 3: 색상 팔레트
  - 18.7 심화 내용
    - 18.7.1 Scene과 Window의 차이
    - 18.7.2 RenderTexture를 이용한 오프스크린 렌더링
    - 18.7.3 Transformer2D를 이용한 좌표 변환
  - 18.8 정리

## 📄 19.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 19: 입력 처리와 상호작용
  - 19.1 들어가며
  - 19.2 마우스 입력 처리
    - 19.2.1 마우스 좌표 얻기
- include <Siv3D.hpp>
- include <Siv3D.hpp>
    - 19.2.2 마우스 버튼 클릭 감지
- include <Siv3D.hpp>
- include <Siv3D.hpp>
    - 19.2.3 특정 영역 클릭 감지
- include <Siv3D.hpp>
    - 19.2.4 마우스 휠 입력
- include <Siv3D.hpp>
  - 19.3 키보드 입력 처리
    - 19.3.1 키 입력 기본
- include <Siv3D.hpp>
    - 19.3.2 문자 키와 수정자 키
- include <Siv3D.hpp>
    - 19.3.3 텍스트 입력 처리
- include <Siv3D.hpp>
    - 19.3.4 키 상태의 지속 시간
- include <Siv3D.hpp>
  - 19.4 터치 입력 기초
    - 19.4.1 터치 입력과 마우스 입력의 통합
- include <Siv3D.hpp>
    - 19.4.2 멀티터치 처리
- include <Siv3D.hpp>
    - 19.4.3 제스처 감지
- include <Siv3D.hpp>
  - 19.5 입력 상태 관리와 이벤트 처리
    - 19.5.1 입력 상태 클래스 설계
- include <Siv3D.hpp>
    - 19.5.2 입력 버퍼링과 커맨드 패턴
- include <Siv3D.hpp>
    - 19.5.3 입력 우선순위와 컨텍스트
- include <Siv3D.hpp>
  - 19.6 실습 문제
    - 문제 1: 드로잉 애플리케이션
    - 문제 2: 반응 속도 테스트 게임
    - 문제 3: 간단한 피아노 애플리케이션
  - 19.7 심화 내용
    - 19.7.1 게임패드 입력 처리
- include <Siv3D.hpp>
    - 19.7.2 입력 리플레이 시스템
- include <Siv3D.hpp>
    - 19.7.3 접근성을 고려한 입력 처리
- include <Siv3D.hpp>
  - 19.8 정리

## 📄 20.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 20: 그래픽과 텍스트
  - 20.1 들어가며
  - 20.2 이미지 로드와 출력
    - 20.2.1 이미지 파일 로드하기
- include <Siv3D.hpp>
    - 20.2.2 이미지 크기 조정과 위치 지정
- include <Siv3D.hpp>
    - 20.2.3 이미지 회전과 대칭
- include <Siv3D.hpp>
    - 20.2.4 이미지 영역 자르기
- include <Siv3D.hpp>
    - 20.2.5 동적 텍스처 생성
- include <Siv3D.hpp>
  - 20.3 텍스트 렌더링과 폰트 관리
    - 20.3.1 기본 폰트 사용하기
- include <Siv3D.hpp>
    - 20.3.2 커스텀 폰트 로드하기
- include <Siv3D.hpp>
    - 20.3.3 텍스트 정렬과 배치
- include <Siv3D.hpp>
    - 20.3.4 서식 있는 텍스트
- include <Siv3D.hpp>
    - 20.3.5 다중 행 텍스트와 워드랩
- include <Siv3D.hpp>
  - 20.4 기본 도형과 커스텀 그래픽
    - 20.4.1 기본 도형 그리기
- include <Siv3D.hpp>
    - 20.4.2 도형의 외곽선과 채우기
- include <Siv3D.hpp>
    - 20.4.3 도형의 변형과 애니메이션
- include <Siv3D.hpp>
    - 20.4.4 복잡한 도형 조합하기
- include <Siv3D.hpp>
    - 20.4.5 커스텀 도형 그리기
- include <Siv3D.hpp>
  - 20.5 색상과 투명도 처리
    - 20.5.1 색상 표현 방식
- include <Siv3D.hpp>
    - 20.5.2 투명도와 알파 블렌딩
- include <Siv3D.hpp>
    - 20.5.3 블렌드 모드
- include <Siv3D.hpp>
    - 20.5.4 색상 조작과 변환
- include <Siv3D.hpp>
    - 20.5.5 그라디언트 고급 기법
- include <Siv3D.hpp>
  - 20.6 실습 문제
    - 문제 1: 이미지 갤러리 뷰어
    - 문제 2: 동적 타이틀 화면
    - 문제 3: 색상 팔레트 생성기
  - 20.7 심화 내용
    - 20.7.1 셰이더를 활용한 효과
- include <Siv3D.hpp>
    - 20.7.2 렌더 텍스처
- include <Siv3D.hpp>
    - 20.7.3 파티클 시스템
- include <Siv3D.hpp>
    - 20.7.4 텍스처 아틀라스 최적화
- include <Siv3D.hpp>
    - 20.7.5 텍스트 효과 라이브러리 만들기
- include <Siv3D.hpp>
  - 20.8 정리

## 📄 21.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 21: 애니메이션과 시간 관리
  - 21.1 들어가며
  - 21.2 `std::chrono`를 이용한 시간 처리
    - 21.2.1 `std::chrono` 기초
    - 21.2.2 Siv3D의 시간 관리 기능
- include <Siv3D.hpp>
    - 21.2.3 프레임 독립적인 움직임
- include <Siv3D.hpp>
    - 21.2.4 시간 측정과 성능 분석
- include <Siv3D.hpp>
  - 21.3 애니메이션 기초
    - 21.3.1 선형 애니메이션
- include <Siv3D.hpp>
    - 21.3.2 반복 애니메이션
- include <Siv3D.hpp>
    - 21.3.3 다중 속성 애니메이션
- include <Siv3D.hpp>
    - 21.3.4 시퀀스 애니메이션
- include <Siv3D.hpp>
  - 21.4 이징(Easing) 함수 활용
    - 21.4.1 이징 함수란?
- include <Siv3D.hpp>
    - 21.4.2 Siv3D의 내장 이징 함수
- include <Siv3D.hpp>
    - 21.4.3 이징 함수의 실용적 활용
- include <Siv3D.hpp>
    - 21.4.4 커스텀 이징 함수 만들기
- include <Siv3D.hpp>
  - 21.5 타이머와 카운터 구현
    - 21.5.1 카운트다운 타이머
- include <Siv3D.hpp>
    - 21.5.2 스톱워치
- include <Siv3D.hpp>
    - 21.5.3 간격 타이머
- include <Siv3D.hpp>
    - 21.5.4 프레임 카운터
- include <Siv3D.hpp>
  - 21.6 실습 문제
    - 문제 1: 애니메이션 컬렉션
    - 문제 2: 스킬 쿨다운 시스템
    - 문제 3: 타이핑 애니메이션
  - 21.7 심화 내용
    - 21.7.1 스프링 애니메이션
- include <Siv3D.hpp>
    - 21.7.2 키프레임 애니메이션 시스템
- include <Siv3D.hpp>
    - 21.7.3 타임라인 시스템
- include <Siv3D.hpp>
  - 21.8 정리

## 📄 22.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 22: 사운드와 음악
  - 22.1 사운드 시스템 개요
  - 22.2 사운드 파일 로드와 재생
    - 22.2.1 기본적인 사운드 재생
    - 22.2.2 사운드 재생 제어
  - 22.3 배경 음악 관리
    - 22.3.1 반복 재생과 페이드 효과
    - 22.3.2 여러 배경 음악 관리
  - 22.4 효과음 처리
    - 22.4.1 효과음 풀(Pool) 시스템
    - 22.4.2 효과음 관리자
  - 22.5 볼륨 조절과 사운드 이펙트
    - 22.5.1 동적 볼륨 조절
    - 22.5.2 3D 사운드와 패닝
    - 22.5.3 재생 속도 조절
  - 22.6 실습 문제
  - 22.7 심화 내용
    - 22.7.1 오디오 파형 시각화
    - 22.7.2 다중 채널 오디오와 믹싱
    - 22.7.3 오디오 스트리밍과 메모리 관리
  - 22.8 정리

## 📄 23.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 23: 파일 시스템과 데이터 관리
  - 23.1 std::filesystem으로 파일 처리
    - 23.1.1 파일 시스템 기초
    - 23.1.2 디렉토리 생성과 삭제
    - 23.1.3 파일 복사와 이동
  - 23.2 설정 파일 읽기와 쓰기
    - 23.2.1 간단한 키-값 형식의 설정 파일
    - 23.2.2 Siv3D를 활용한 설정 관리
  - 23.3 JSON 데이터 처리
    - 23.3.1 JSON 기초
    - 23.3.2 복잡한 게임 데이터 저장
  - 23.4 게임 데이터 저장과 로드
    - 23.4.1 다중 슬롯 세이브 시스템
    - 23.4.2 자동 저장 시스템
  - 23.5 실습 문제
  - 23.6 심화 내용
    - 23.6.1 암호화된 세이브 파일
    - 23.6.2 데이터 압축
    - 23.6.3 클라우드 저장소 연동
  - 23.7 정리

## 📄 24.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 24: 프로젝트 1 - 간단한 퍼즐 게임
  - 24.1 게임 기획과 요구사항 분석
    - 24.1.1 슬라이딩 퍼즐이란?
    - 24.1.2 게임 요구사항
    - 24.1.3 프로젝트 구조 설계
  - 24.2 게임 상태 관리 (`enum class` 활용)
    - 24.2.1 게임 상태 정의
    - 24.2.2 타일 데이터 구조
    - 24.2.3 게임 설정 상수
  - 24.3 PuzzleGame 클래스 구현
    - 24.3.1 클래스 설계
    - 24.3.2 생성자와 초기화
    - 24.3.3 타일 섞기 알고리즘
    - 24.3.4 타일 이동 로직
    - 24.3.5 게임 완성 감지
  - 24.4 사용자 인터페이스 구현
    - 24.4.1 메인 업데이트 루프
    - 24.4.2 렌더링 구현
  - 24.5 점수 시스템과 데이터 저장
    - 24.5.1 JSON을 활용한 데이터 저장
    - 24.5.2 확장된 기록 시스템
    - 24.5.3 통계 정보 표시
  - 24.6 추가 기능과 개선사항
    - 24.6.1 애니메이션 효과
    - 24.6.2 효과음 추가
    - 24.6.3 난이도 선택
  - 24.7 메인 함수 작성
  - 24.8 실습 문제
    - 기본 실습
    - 중급 실습
    - 고급 실습
  - 24.9 심화 내용: 디자인 패턴 적용
    - 24.9.1 상태 패턴 (State Pattern)
    - 24.9.2 명령 패턴 (Command Pattern)
    - 24.9.3 관찰자 패턴 (Observer Pattern)
  - 24.10 성능 최적화
    - 24.10.1 불필요한 복사 방지
    - 24.10.2 범위 기반 for 문 최적화
    - 24.10.3 문자열 포맷팅 최적화
  - 24.11 요약

## 📄 25.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 25: 프로젝트 2 - 그래픽 에디터
  - 25.1 프로젝트 개요와 설계
    - 25.1.1 그래픽 에디터의 요구사항
    - 25.1.2 아키텍처 설계
    - 25.1.3 프로젝트 구조
  - 25.2 도구 패턴과 명령 패턴 적용
    - 25.2.1 도구 인터페이스 설계
    - 25.2.2 펜 도구 구현
    - 25.2.3 브러시 도구 구현
    - 25.2.4 도형 도구 구현
    - 25.2.5 도구 관리자
    - 25.2.6 지우개 도구
  - 25.3 실행 취소/다시 실행 기능
    - 25.3.1 명령 인터페이스 설계
    - 25.3.2 그리기 명령 구현
    - 25.3.3 명령 관리자
    - 25.3.4 명령 패턴 사용 예제
  - 25.4 레이어 시스템 구현
    - 25.4.1 레이어 클래스 설계
    - 25.4.2 레이어 관리자
    - 25.4.3 레이어 명령
  - 25.5 파일 저장과 불러오기
    - 25.5.4 파일 관리자
    - 25.5.2 파일 대화상자 사용
  - 25.6 UI 구현
    - 25.6.1 UI 매니저
  - 25.7 메인 에디터 클래스
  - 25.8 메인 함수
  - 25.9 실습 문제
    - 기본 실습
    - 중급 실습
    - 고급 실습
  - 25.10 심화 내용: 성능 최적화
    - 25.10.1 메모리 효율적인 명령 패턴
    - 25.10.2 타일 기반 렌더링
    - 25.10.3 비동기 저장
  - 25.11 요약

## 📄 26.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 26: 프로젝트 3 - 데이터 시각화 도구
  - 26.1 프로젝트 개요
    - 26.1.1 무엇을 만들 것인가
    - 26.1.2 프로젝트 구조 설계
  - 26.2 데이터 시리즈 구현
    - 26.2.1 스레드 안전한 데이터 관리
    - 26.2.2 실습: 기본 데이터 시리즈 테스트
  - 26.3 선 그래프 구현
    - 26.3.1 화면 좌표 변환
    - 26.3.2 실습: 선 그래프 테스트
  - 26.4 막대 그래프와 원 그래프
    - 26.4.1 막대 그래프 구현
    - 26.4.2 원 그래프 구현
    - 26.4.3 실습: 여러 차트 타입 전환
  - 26.5 실시간 시스템 모니터링
    - 26.5.1 시스템 정보 수집
    - 26.5.2 멀티스레딩 적용
  - 26.6 비동기 작업과 std::async
    - 26.6.1 std::async 소개
    - 26.6.2 실습: 파일 입출력과 비동기 처리
  - 26.7 성능 최적화
    - 26.7.1 데이터 샘플링
    - 26.7.2 렌더링 최적화
    - 26.7.3 메모리 최적화
  - 26.8 인터랙티브 기능
    - 26.8.1 마우스 상호작용
    - 26.8.2 줌과 패닝
  - 26.9 종합 실습 프로젝트
    - 26.9.1 완성된 데이터 시각화 도구
  - 26.10 심화 학습
    - 26.10.1 성능 프로파일링
    - 26.10.2 메모리 사용량 모니터링
    - 26.10.3 연습 문제
  - 26.11 마치며

## 📄 27.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 27: 고급 주제와 성능 최적화
  - 27.1 메모리 효율적인 코딩
    - 27.1.1 메모리 할당의 이해
    - 27.1.2 불필요한 복사 피하기
    - 27.1.3 메모리 풀 사용하기
    - 27.1.4 컨테이너 예약과 축소
  - 27.2 프로파일링과 성능 측정
    - 27.2.1 Visual Studio 프로파일러 사용하기
    - 27.2.2 커스텀 프로파일러 만들기
    - 27.2.3 핫스팟 찾기와 최적화
  - 27.3 코드 리팩토링 기법
    - 27.3.1 리팩토링이란?
    - 27.3.2 SOLID 원칙 적용하기
    - 27.3.3 코드 냄새와 해결 방법
  - 27.4 단위 테스트 기초
    - 27.4.1 테스트의 중요성
    - 27.4.2 테스트 주도 개발 (TDD)
    - 27.4.3 Siv3D 프로젝트 테스트하기
    - 27.4.4 통합 테스트 예제
  - 27.5 종합 실습
    - 27.5.1 최적화된 데이터 처리 시스템 만들기
  - 27.6 실습 문제
  - 27.7 마치며

## 📄 28.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- Chapter 28: 마무리와 다음 단계
  - 28.1 C++23의 고급 기능들
    - 28.1.1 std::expected - 오류 처리의 새로운 방식
    - 28.1.2 std::mdspan - 다차원 배열 뷰
    - 28.1.3 범위 어댑터의 고급 활용
    - 28.1.4 constexpr 함수의 확장
    - 28.1.5 모듈 시스템의 활용
  - 28.2 Modern C++ 코딩 스타일 가이드
    - 28.2.1 명명 규칙과 코드 구조
    - 28.2.2 RAII와 리소스 관리
    - 28.2.3 const-correctness
    - 28.2.4 타입 안정성과 열거형
    - 28.2.5 에러 처리 전략
  - 28.3 오픈소스 프로젝트 참여하기
    - 28.3.1 GitHub 시작하기
- 프로젝트 복제
- 새 브랜치 생성
- 파일 수정 후 스테이징
- 커밋
- 원격 저장소에 푸시
    - 28.3.2 초보자 친화적인 C++ 프로젝트
    - 28.3.3 기여하는 방법
- 빌드 지침 따라하기
  - 변경 사항
  - 관련 이슈
  - 테스트
  - 스크린샷 (해당되는 경우)
    - 28.3.4 코드 리뷰 받기
  - 28.4 추가 학습 리소스와 커뮤니티
    - 28.4.1 온라인 학습 자료
    - 28.4.2 책 추천
    - 28.4.3 커뮤니티와 포럼
    - 28.4.4 실습 플랫폼
  - 28.5 실전 프로젝트 아이디어
    - 28.5.1 초급 프로젝트
    - 28.5.2 중급 프로젝트
    - 28.5.3 고급 프로젝트
  - 28.6 성능과 최적화
    - 28.6.1 측정 먼저, 최적화는 나중에
    - 28.6.2 일반적인 최적화 기법
    - 28.6.3 Modern C++의 성능 향상 기법
  - 28.7 마치며
    - 28.7.1 지속적인 학습의 중요성
    - 28.7.2 커뮤니티와 함께 성장하기
    - 28.7.3 즐거움을 잃지 않기
    - 28.7.4 다음 목표 설정하기
  - 실습 문제
    - 문제 1: 학습 로그 애플리케이션 (Siv3D)
    - 문제 2: 코드 스니펫 관리자
    - 문제 3: 성능 벤치마크 도구
  - 심화 학습
    - 1. C++26 미리보기
    - 2. C++ 생태계 도구들
    - 3. 실전 디자인 패턴
  - 정리

## 📄 99부록.md
- 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍
- 부록
  - 부록 A: C++ 키워드 완전 정리
    - A.1 기본 타입 관련 키워드
    - A.2 저장 클래스 지정자
    - A.3 제어 흐름 키워드
    - A.4 클래스와 구조체 관련 키워드
    - A.5 템플릿 관련 키워드
    - A.6 네임스페이스 관련 키워드
    - A.7 예외 처리 키워드
    - A.8 메모리 관리 키워드
    - A.9 캐스팅 키워드
    - A.10 특수 키워드
    - A.11 C++11 이후 추가된 주요 키워드 요약
    - A.12 문맥 의존 키워드
  - 부록 B: Visual Studio 2022 단축키 모음
    - B.1 편집 및 탐색
    - B.2 코드 탐색 및 검색
    - B.3 IntelliSense 및 리팩터링
    - B.4 빌드 및 디버깅
    - B.5 창 및 프로젝트 관리
    - B.6 코드 스니펫
    - B.7 고급 편집 기능
    - B.8 테스트 관련
    - B.9 사용자 정의 단축키 설정
    - B.10 자주 사용하는 조합 단축키
  - 부록 C: C++23 주요 기능 요약
    - C.1 `if consteval` - 컴파일 타임 분기
    - C.2 `std::expected` - 오류 처리 개선
    - C.3 `std::mdspan` - 다차원 배열 뷰
    - C.4 범위 어댑터 개선
    - C.5 `std::print` 및 `std::println` - 포맷 출력
    - C.6 `std::stacktrace` - 스택 추적
    - C.7 명시적 객체 매개변수 (Deducing this)
    - C.8 `std::flat_map` 및 `std::flat_set`
    - C.9 `std::generator` - 코루틴 생성기
    - C.10 `constexpr` 개선
    - C.11 멀티차원 첨자 연산자
    - C.12 `std::move_only_function`
    - C.13 문자열 포맷 개선
    - C.14 기타 작은 개선 사항
    - C.15 C++23 채택 가이드
  - 부록 D: 자주 발생하는 오류와 해결책
    - D.1 컴파일 오류
      - D.1.1 식별자를 찾을 수 없습니다
      - D.1.2 형식 불일치
      - D.1.3 함수 오버로드 모호성
      - D.1.4 정의되지 않은 참조
    - D.2 런타임 오류
      - D.2.1 접근 위반 (Segmentation Fault)
      - D.2.2 Use After Free
      - D.2.3 메모리 누수
    - D.3 논리 오류
      - D.3.1 정수 나누기 문제
      - D.3.2 부동소수점 비교
      - D.3.3 무한 루프
    - D.4 Visual Studio 특정 문제
      - D.4.1 미리 컴파일된 헤더 오류
      - D.4.2 문자 인코딩 문제
    - D.5 일반적인 실수와 예방법
      - D.5.1 초기화하지 않은 변수
      - D.5.2 댕글링 참조
      - D.5.3 복사 생성자 누락
    - D.6 디버깅 팁
  - 부록 E: 코딩 스타일 체크리스트
    - E.1 명명 규칙
    - E.2 코드 구조
    - E.3 Modern C++ 기능 사용
    - E.4 오류 처리
    - E.5 주석과 문서화
    - E.6 포맷팅
    - E.7 성능 고려사항
    - E.8 안전성
    - E.9 체크리스트
    - E.10 추천 도구
