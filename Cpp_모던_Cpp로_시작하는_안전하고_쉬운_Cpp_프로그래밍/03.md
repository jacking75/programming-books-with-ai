# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 3: 데이터 타입과 변수
프로그래밍의 가장 기본이 되는 것은 데이터를 저장하고 다루는 것이다. 이번 챕터에서는 C++에서 데이터를 어떻게 표현하고 저장하는지 배워본다. Modern C++의 안전하고 편리한 기능들을 중심으로 학습할 것이다.


## 3.1 기본 데이터 타입
컴퓨터는 다양한 종류의 데이터를 처리한다. 숫자, 문자, 참/거짓 등 각각의 데이터는 고유한 **타입(type)**을 가진다.

### 왜 데이터 타입이 필요할까?
데이터 타입은 다음을 결정한다:
- **메모리 크기**: 얼마나 많은 메모리를 사용할지
- **표현 범위**: 어떤 값들을 저장할 수 있는지
- **가능한 연산**: 어떤 연산을 수행할 수 있는지

예를 들어:
```cpp
42        // 정수
3.14      // 실수
true      // 논리값
'A'       // 문자
```

### 정수 타입 (int)
**int**는 정수(whole number)를 저장하는 가장 기본적인 타입이다.

```cpp
#include <iostream>

int main()
{
    int age = 25;           // 나이
    int temperature = -5;   // 영하 5도
    int score = 100;        // 점수
    
    std::cout << "나이: " << age << "\n";
    std::cout << "온도: " << temperature << "도\n";
    std::cout << "점수: " << score << "점\n";
    
    return 0;
}
```

**int의 특징:**
- 소수점 없는 정수만 저장
- 양수, 음수, 0 모두 가능
- 일반적으로 -2,147,483,648 ~ 2,147,483,647 범위 (32비트 시스템)

**정수 타입의 변형:**

```cpp
#include <iostream>

int main()
{
    short smallNumber = 100;        // 작은 범위 (-32,768 ~ 32,767)
    int normalNumber = 100000;      // 일반 범위
    long bigNumber = 1000000000;    // 큰 범위
    long long hugeNumber = 1000000000000LL;  // 아주 큰 범위
    
    unsigned int positiveOnly = 100;  // 양수만 (0 ~ 4,294,967,295)
    
    std::cout << "작은 숫자: " << smallNumber << "\n";
    std::cout << "일반 숫자: " << normalNumber << "\n";
    std::cout << "큰 숫자: " << bigNumber << "\n";
    std::cout << "아주 큰 숫자: " << hugeNumber << "\n";
    std::cout << "양수만: " << positiveOnly << "\n";
    
    return 0;
}
```

> **초보자 팁**: 대부분의 경우 그냥 `int`를 사용하면 충분하다. 특별한 이유가 없다면 단순하게 시작하자!
  
### 실수 타입 (double, float)
소수점이 있는 숫자를 저장할 때는 **double** 또는 **float**를 사용한다.

```cpp
#include <iostream>

int main()
{
    double pi = 3.14159;           // 원주율
    double temperature = 36.5;     // 체온
    double price = 12.99;          // 가격
    
    float smallDecimal = 3.14f;    // float는 끝에 'f' 붙임
    
    std::cout << "원주율: " << pi << "\n";
    std::cout << "체온: " << temperature << "도\n";
    std::cout << "가격: $" << price << "\n";
    
    return 0;
}
```

**double vs float:**

| 특징 | float | double |
|------|-------|--------|
| 정밀도 | 약 7자리 | 약 15자리 |
| 메모리 | 4바이트 | 8바이트 |
| 사용 | 메모리 절약 필요 시 | 일반적인 경우 (권장!) |

```cpp
#include <iostream>
#include <iomanip>  // setprecision 사용

int main()
{
    float f = 3.141592653589793f;
    double d = 3.141592653589793;
    
    std::cout << std::setprecision(15);
    std::cout << "float:  " << f << "\n";   // 약 7자리까지 정확
    std::cout << "double: " << d << "\n";   // 약 15자리까지 정확
    
    return 0;
}
```

출력:
```
float:  3.14159274101257
double: 3.14159265358979
```

> **Modern C++ 권장사항**: 실수를 사용할 때는 `double`을 기본으로 하자. 더 정확하고 현대 컴퓨터에서는 성능 차이가 거의 없다.
  
### 논리 타입 (bool)
**bool**은 참(true) 또는 거짓(false) 두 가지 값만 가질 수 있다.

```cpp
#include <iostream>

int main()
{
    bool isRaining = true;          // 비가 오는가?
    bool isWeekend = false;         // 주말인가?
    bool hasLicense = true;         // 면허가 있는가?
    
    std::cout << "비가 오나요? " << isRaining << "\n";      // 1 (true)
    std::cout << "주말인가요? " << isWeekend << "\n";        // 0 (false)
    std::cout << "면허가 있나요? " << hasLicense << "\n";    // 1 (true)
    
    return 0;
}
```

**bool의 출력:**
- `true`는 `1`로 출력
- `false`는 `0`으로 출력

텍스트로 출력하려면:

```cpp
#include <iostream>

int main()
{
    bool isReady = true;
    
    // boolalpha 조작자를 사용하면 true/false로 출력
    std::cout << std::boolalpha;
    std::cout << "준비되었나요? " << isReady << "\n";  // true
    
    return 0;
}
```

**실용 예제:**

```cpp
#include <iostream>

int main()
{
    int age = 20;
    bool isAdult = age >= 18;  // 18세 이상이면 true
    
    std::cout << std::boolalpha;
    std::cout << "성인인가요? " << isAdult << "\n";
    
    return 0;
}
```

### 문자 타입 (char)
**char**는 단일 문자를 저장한다.

```cpp
#include <iostream>

int main()
{
    char grade = 'A';              // 성적
    char initial = 'K';            // 이니셜
    char symbol = '@';             // 기호
    
    std::cout << "성적: " << grade << "\n";
    std::cout << "이니셜: " << initial << "\n";
    std::cout << "기호: " << symbol << "\n";
    
    return 0;
}
```

**중요**: 문자는 **작은따옴표('')**로 감싼다!

```cpp
char letter = 'A';     // 올바름 - 작은따옴표
char wrong = "A";      // 오류! - 큰따옴표는 문자열용
```

**ASCII 코드:**

문자는 실제로 숫자로 저장된다.

```cpp
#include <iostream>

int main()
{
    char letter = 'A';
    
    std::cout << "문자: " << letter << "\n";
    std::cout << "ASCII 코드: " << static_cast<int>(letter) << "\n";
    // 'A'의 ASCII 코드는 65
    
    char nextLetter = letter + 1;  // 66 = 'B'
    std::cout << "다음 문자: " << nextLetter << "\n";
    
    return 0;
}
```

출력:
```
문자: A
ASCII 코드: 65
다음 문자: B
```

**특수 문자:**

```cpp
#include <iostream>

int main()
{
    char newline = '\n';       // 줄바꿈
    char tab = '\t';           // 탭
    char backslash = '\\';     // 백슬래시
    char quote = '\'';         // 작은따옴표
    
    std::cout << "첫 줄" << newline << "둘째 줄\n";
    std::cout << "이름:" << tab << "홍길동\n";
    std::cout << "경로: C:" << backslash << "Users\n";
    
    return 0;
}
```

### 문자열 타입 (std::string)
여러 문자를 연결한 것이 **문자열(string)** 이다. Modern C++에서는 `std::string`을 사용한다.

```cpp
#include <iostream>
#include <string>  // string을 사용하려면 필요!

int main()
{
    std::string name = "홍길동";
    std::string greeting = "안녕하세요!";
    std::string empty = "";  // 빈 문자열
    
    std::cout << greeting << " " << name << "님\n";
    
    return 0;
}
```

**문자열의 장점:**

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string firstName = "길동";
    std::string lastName = "홍";
    
    // 문자열 연결 (concatenation)
    std::string fullName = lastName + firstName;
    std::cout << "이름: " << fullName << "\n";
    
    // 문자열 길이
    std::cout << "길이: " << fullName.length() << "\n";
    
    // 문자열 비교
    if (firstName == "길동")
    {
        std::cout << "이름이 일치합니다!\n";
    }
    
    return 0;
}
```

> **C 스타일 vs Modern C++**:
> ```cpp
> // 옛날 방식 (사용하지 마세요!)
> char oldStyle[] = "Hello";
> 
> // Modern 방식 (권장!)
> std::string modernStyle = "Hello";
> ```

### 데이터 타입 크기 확인하기
각 타입이 차지하는 메모리 크기를 확인할 수 있다.

```cpp
#include <iostream>

int main()
{
    std::cout << "bool 크기: " << sizeof(bool) << " 바이트\n";
    std::cout << "char 크기: " << sizeof(char) << " 바이트\n";
    std::cout << "int 크기: " << sizeof(int) << " 바이트\n";
    std::cout << "long 크기: " << sizeof(long) << " 바이트\n";
    std::cout << "long long 크기: " << sizeof(long long) << " 바이트\n";
    std::cout << "float 크기: " << sizeof(float) << " 바이트\n";
    std::cout << "double 크기: " << sizeof(double) << " 바이트\n";
    
    return 0;
}
```

일반적인 출력 (64비트 시스템):
```
bool 크기: 1 바이트
char 크기: 1 바이트
int 크기: 4 바이트
long 크기: 4 바이트
long long 크기: 8 바이트
float 크기: 4 바이트
double 크기: 8 바이트
```
  

### 실습 예제 1: 데이터 타입 사용하기
다양한 데이터 타입을 사용하는 프로그램을 만들어보자.

```cpp
#include <iostream>
#include <string>

int main()
{
    // 학생 정보를 저장하는 프로그램
    std::string studentName = "김철수";
    int age = 20;
    char grade = 'A';
    double gpa = 3.85;
    bool isScholarship = true;
    
    std::cout << "=== 학생 정보 ===\n";
    std::cout << "이름: " << studentName << "\n";
    std::cout << "나이: " << age << "세\n";
    std::cout << "학점: " << grade << "\n";
    std::cout << "평균 평점: " << gpa << "\n";
    std::cout << std::boolalpha;
    std::cout << "장학금 수혜: " << isScholarship << "\n";
    
    return 0;
}
```

</br>  
  

## 3.2 변수 선언과 초기화
변수는 데이터를 저장하는 **이름이 붙은 메모리 공간**이다.

### 변수 선언의 기본
변수를 사용하려면 먼저 **선언(declaration)** 해야 한다.

**기본 형식:**
```
타입 변수이름;
```

```cpp
#include <iostream>

int main()
{
    int number;        // 변수 선언만 (값이 없음 - 위험!)
    number = 42;       // 값 대입
    
    std::cout << number << "\n";
    
    return 0;
}
```

> **주의**: 초기화하지 않은 변수는 **쓰레기 값(garbage value)** 을 가질 수 있다!

```cpp
#include <iostream>

int main()
{
    int uninitialized;  // 초기화 안 함
    std::cout << uninitialized << "\n";  // 예측 불가능한 값 출력!
    
    return 0;
}
```

### 안전한 초기화 방법
Modern C++에서는 변수를 선언할 때 **반드시 초기화**하는 것이 좋다.

**1. 등호 초기화 (Copy Initialization)**

```cpp
int age = 25;
double pi = 3.14;
std::string name = "홍길동";
```

**2. 중괄호 초기화 (Uniform Initialization) - 권장!**

```cpp
int age{25};
double pi{3.14};
std::string name{"홍길동"};
```

중괄호 초기화의 장점:
- **타입 안전**: 잘못된 변환을 방지
- **일관성**: 모든 타입에 동일하게 적용
- **명확성**: 초기화 의도가 명확

```cpp
#include <iostream>

int main()
{
    int x = 3.14;      // 경고 없이 3으로 변환 (정보 손실!)
    int y{3.14};       // 컴파일 오류! (안전함)
    
    return 0;
}
```

**3. 직접 초기화 (Direct Initialization)**

```cpp
int age(25);
double pi(3.14);
```

**초기화 방법 비교:**

```cpp
#include <iostream>

int main()
{
    // 모두 같은 결과
    int a = 10;    // 등호 초기화
    int b(10);     // 직접 초기화
    int c{10};     // 중괄호 초기화 (권장!)
    
    std::cout << a << " " << b << " " << c << "\n";
    
    return 0;
}
```

> **Modern C++ 권장사항**: 중괄호 초기화 `{}`를 기본으로 사용하자!

### 0으로 초기화
변수를 0으로 초기화하는 여러 방법:

```cpp
#include <iostream>

int main()
{
    int a = 0;       // 명시적 0
    int b{0};        // 명시적 0 (중괄호)
    int c{};         // 0으로 초기화 (암시적)
    int d = int{};   // 0으로 초기화
    
    std::cout << a << " " << b << " " << c << " " << d << "\n";
    // 출력: 0 0 0 0
    
    return 0;
}
```

### 여러 변수 동시 선언

```cpp
#include <iostream>

int main()
{
    // 같은 타입의 여러 변수를 한 줄에 선언
    int x = 1, y = 2, z = 3;
    
    // 하지만 가독성을 위해 각각 선언하는 것을 권장
    int a{1};
    int b{2};
    int c{3};
    
    return 0;
}
```

### 변수 이름 짓기 규칙

**규칙 (반드시 지켜야 함):**

1. 문자, 숫자, 언더스코어(_)만 사용
2. 숫자로 시작할 수 없음
3. 예약어(키워드) 사용 불가
4. 대소문자 구분

```cpp
// 올바른 변수 이름
int age;
int student_count;
int maxValue;
int number1;
int _private;

// 잘못된 변수 이름
int 123number;     // 숫자로 시작
int my-name;       // 하이픈 사용
int for;           // 예약어
int student count; // 공백 사용
```

**관례 (권장사항):**

```cpp
// camelCase (일반 변수) - 권장!
int studentAge;
int maxScore;
int isReady;

// snake_case (대안)
int student_age;
int max_score;
int is_ready;

// PascalCase (클래스/구조체용)
class StudentInfo;
struct PersonData;

// UPPER_CASE (상수용)
const int MAX_STUDENTS = 100;
const double PI = 3.14159;
```

**의미 있는 이름 사용:**

```cpp
// 나쁜 예
int a, b, c, x, y, z;
int data, temp, value;

// 좋은 예
int studentAge, teacherAge;
int totalScore, averageScore;
int currentIndex, maxIndex;
```

### 실습 예제 2: 안전한 변수 초기화

```cpp
#include <iostream>
#include <string>

int main()
{
    // Modern C++ 스타일의 안전한 초기화
    int age{25};
    double height{175.5};
    bool isStudent{true};
    std::string name{"김민수"};
    char grade{'A'};
    
    // 0/빈 값으로 초기화
    int count{};              // 0
    double price{};           // 0.0
    bool flag{};              // false
    std::string text{};       // ""
    
    std::cout << "이름: " << name << "\n";
    std::cout << "나이: " << age << "\n";
    std::cout << "키: " << height << "cm\n";
    std::cout << "학점: " << grade << "\n";
    std::cout << std::boolalpha;
    std::cout << "학생 여부: " << isStudent << "\n";
    
    return 0;
}
```

</br>  
  

## 3.3 auto 키워드와 타입 추론
Modern C++의 가장 편리한 기능 중 하나가 **auto** 키워드이다. 컴파일러가 자동으로 타입을 추론해준다!

### auto의 기본 사용법

```cpp
#include <iostream>

int main()
{
    auto age = 25;           // int로 추론
    auto pi = 3.14;          // double로 추론
    auto name = "홍길동";     // const char*로 추론
    auto isReady = true;     // bool로 추론
    
    std::cout << age << "\n";
    std::cout << pi << "\n";
    std::cout << name << "\n";
    std::cout << std::boolalpha << isReady << "\n";
    
    return 0;
}
```

### auto가 타입을 추론하는 방법

```cpp
#include <iostream>
#include <string>

int main()
{
    auto a = 42;              // int
    auto b = 42L;             // long
    auto c = 42LL;            // long long
    auto d = 42u;             // unsigned int
    
    auto e = 3.14;            // double
    auto f = 3.14f;           // float
    
    auto g = 'A';             // char
    auto h = "Hello";         // const char*
    auto i = std::string{"Hello"};  // std::string
    
    auto j = true;            // bool
    
    return 0;
}
```

### auto의 장점

**1. 긴 타입 이름 단순화:**

```cpp
#include <vector>
#include <map>
#include <string>

int main()
{
    // 복잡한 타입을 auto로 간단하게!
    
    // 옛날 방식
    std::map<std::string, std::vector<int>> oldStyle;
    std::map<std::string, std::vector<int>>::iterator it = oldStyle.begin();
    
    // Modern 방식
    auto modernStyle = std::map<std::string, std::vector<int>>{};
    auto iter = modernStyle.begin();  // 훨씬 간단!
    
    return 0;
}
```

**2. 타입 변경 시 유연성:**

```cpp
#include <iostream>

int main()
{
    // 나중에 int를 double로 바꿔도 코드 수정 불필요
    auto value = 42;  // int로 시작
    // auto value = 42.0;  // double로 변경해도 나머지 코드는 그대로!
    
    auto doubled = value * 2;
    auto halved = value / 2;
    
    std::cout << doubled << " " << halved << "\n";
    
    return 0;
}
```

**3. 컴파일러 오류 방지:**

```cpp
#include <vector>

int main()
{
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 실수하기 쉬운 코드
    for (unsigned int i = 0; i < numbers.size(); ++i)  // size()는 size_t 반환
    {
        // 타입 불일치 경고 발생 가능
    }
    
    // auto 사용 - 항상 정확한 타입
    for (auto i = 0u; i < numbers.size(); ++i)
    {
        // 안전!
    }
    
    return 0;
}
```

### auto 사용 시 주의사항

**1. 의도한 타입인지 확인:**

```cpp
#include <iostream>

int main()
{
    auto x = 3.14;     // double
    auto y = 3.14f;    // float
    
    // 정수를 원했다면?
    auto wrong = 10 / 3;      // int (3)
    auto correct = 10.0 / 3;  // double (3.333...)
    
    std::cout << wrong << "\n";    // 3
    std::cout << correct << "\n";  // 3.33333
    
    return 0;
}
```

**2. 초기값이 반드시 필요:**

```cpp
int main()
{
    auto x;        // 오류! 초기값 없이는 타입 추론 불가
    auto y = 10;   // 올바름
    
    return 0;
}
```

**3. 참조와 const는 추론되지 않음:**

```cpp
#include <iostream>

int main()
{
    int value = 42;
    const int& ref = value;
    
    auto copy = ref;        // int (복사본, const와 참조 제거됨)
    auto& reference = ref;  // const int& (참조 유지)
    
    copy = 100;       // OK - copy는 그냥 int
    // reference = 100;  // 오류 - reference는 const
    
    return 0;
}
```

### auto와 중괄호 초기화

```cpp
#include <iostream>
#include <initializer_list>

int main()
{
    auto a = 42;       // int
    auto b{42};        // int (C++17부터)
    auto c = {42};     // std::initializer_list<int> (주의!)
    auto d{1, 2, 3};   // 오류! (C++17부터)
    
    std::cout << a << "\n";
    std::cout << b << "\n";
    
    return 0;
}
```

> **권장사항**: `auto`와 함께 `{}`를 사용할 때는 단일 값만 넣자.

### auto를 사용해야 할 때 vs 사용하지 말아야 할 때

**사용해야 할 때:**

```cpp
#include <vector>
#include <string>
#include <map>

int main()
{
    // 1. 복잡한 타입
    auto data = std::map<std::string, std::vector<int>>{};
    
    // 2. 반복자
    std::vector<int> vec = {1, 2, 3};
    auto it = vec.begin();
    
    // 3. 람다 표현식
    auto lambda = [](int x) { return x * 2; };
    
    return 0;
}
```

**명시적 타입이 나을 때:**

```cpp
#include <iostream>

int main()
{
    // 1. 간단하고 명확한 타입
    int count = 0;           // auto보다 명확
    double price = 12.99;    // 의도가 분명
    bool isReady = false;    // 읽기 쉬움
    
    // 2. 타입이 중요한 경우
    float precision = 3.14f; // float이 중요하면 명시
    
    // 3. 코드 가독성
    std::string name = "홍길동";  // 문자열임이 명확
    
    return 0;
}
```

### 실습 예제 3: auto 활용하기

```cpp
#include <iostream>
#include <string>
#include <vector>

int main()
{
    // auto로 다양한 타입 추론
    auto age = 25;
    auto height = 175.5;
    auto name = std::string{"김철수"};
    auto grades = std::vector<int>{90, 85, 88, 92};
    
    std::cout << "이름: " << name << "\n";
    std::cout << "나이: " << age << "\n";
    std::cout << "키: " << height << "cm\n";
    
    std::cout << "성적: ";
    for (auto grade : grades)  // range-based for + auto
    {
        std::cout << grade << " ";
    }
    std::cout << "\n";
    
    // 계산된 값도 auto로
    auto totalGrades = 0;
    for (auto grade : grades)
    {
        totalGrades += grade;
    }
    
    auto average = static_cast<double>(totalGrades) / grades.size();
    std::cout << "평균: " << average << "\n";
    
    return 0;
}
```

</br>  
  

## 3.4 상수와 const, constexpr의 차이점
변경되지 않아야 하는 값은 **상수(constant)**로 선언하는 것이 안전하다.

### const: 런타임 상수
**const**는 변경할 수 없는 변수를 만든다.

```cpp
#include <iostream>

int main()
{
    const int maxStudents = 30;
    const double pi = 3.14159;
    const std::string school = "서울고등학교";
    
    std::cout << "최대 학생 수: " << maxStudents << "\n";
    std::cout << "원주율: " << pi << "\n";
    std::cout << "학교: " << school << "\n";
    
    // maxStudents = 40;  // 컴파일 오류! const는 변경 불가
    
    return 0;
}
```

**const의 장점:**

1. **안전성**: 실수로 값을 변경하는 것 방지
2. **의도 표현**: 이 값은 변하지 않는다는 것을 명확히 표시
3. **최적화**: 컴파일러가 더 나은 최적화 가능

**const와 auto:**

```cpp
#include <iostream>

int main()
{
    const auto pi = 3.14159;        // const double
    const auto name = "홍길동";      // const char* const
    
    // pi = 3.14;     // 오류!
    // name = "김철수"; // 오류!
    
    return 0;
}
```

### constexpr: 컴파일 타임 상수
**constexpr**은 **컴파일 시간**에 값이 결정되는 상수이다.

```cpp
#include <iostream>

int main()
{
    constexpr int maxValue = 100;
    constexpr double pi = 3.14159;
    constexpr int doubled = maxValue * 2;  // 컴파일 시 계산
    
    std::cout << "최대값: " << maxValue << "\n";
    std::cout << "두 배: " << doubled << "\n";
    
    return 0;
}
```

**const vs constexpr:**

```cpp
#include <iostream>

int getValue()
{
    return 42;
}

int main()
{
    const int a = 10;              // 컴파일 타임 상수
    const int b = getValue();      // 런타임 상수 (함수 호출)
    
    constexpr int c = 10;          // 컴파일 타임 상수
    // constexpr int d = getValue();  // 오류! getValue는 constexpr 아님
    
    // 배열 크기로 사용 가능
    int arr1[a];    // OK - 컴파일 타임 상수
    // int arr2[b];    // 오류 (일부 컴파일러) - 런타임 상수
    int arr3[c];    // OK - constexpr
    
    return 0;
}
```

**constexpr 함수:**

```cpp
#include <iostream>

// constexpr 함수 - 컴파일 타임에 계산 가능
constexpr int square(int x)
{
    return x * x;
}

constexpr int factorial(int n)
{
    return n <= 1 ? 1 : n * factorial(n - 1);
}

int main()
{
    constexpr int a = square(5);      // 컴파일 타임에 25로 계산
    constexpr int b = factorial(5);   // 컴파일 타임에 120으로 계산
    
    std::cout << "5의 제곱: " << a << "\n";
    std::cout << "5!: " << b << "\n";
    
    // 런타임에도 사용 가능
    int x = 10;
    int c = square(x);  // 런타임 계산
    std::cout << "10의 제곱: " << c << "\n";
    
    return 0;
}
```

### const, constexpr, #define 비교

```cpp
#include <iostream>

#define OLD_MAX 100        // 옛날 방식 (사용 비추천!)

int main()
{
    const int MODERN_MAX = 100;          // 런타임 상수
    constexpr int COMPILE_MAX = 100;     // 컴파일 타임 상수
    
    // #define의 문제점
    // - 타입 안전성 없음
    // - 디버깅 어려움
    // - 스코프 개념 없음
    
    // Modern C++ 권장
    std::cout << MODERN_MAX << "\n";
    std::cout << COMPILE_MAX << "\n";
    
    return 0;
}
```

| 특징 | #define | const | constexpr |
|------|---------|-------|-----------|
| 타입 안전 | ❌ | ✅ | ✅ |
| 스코프 | ❌ | ✅ | ✅ |
| 디버깅 | ❌ | ✅ | ✅ |
| 컴파일 타임 | ✅ | ⚠️ | ✅ |
| 권장 여부 | ❌ | ✅ | ✅ |

> **Modern C++ 권장사항**: `#define` 대신 `const` 또는 `constexpr`을 사용하자!

### 언제 무엇을 사용할까?

**constexpr 사용:**
```cpp
constexpr int MAX_STUDENTS = 30;        // 컴파일 타임 상수
constexpr double PI = 3.14159265359;    // 수학 상수
constexpr int GRID_SIZE = 10;           // 고정 크기
```

**const 사용:**
```cpp
#include <iostream>
#include <string>

int getUserAge()
{
    int age;
    std::cout << "나이를 입력하세요: ";
    std::cin >> age;
    return age;
}

int main()
{
    const int userAge = getUserAge();    // 런타임에 결정
    const std::string userName = "홍길동";
    
    // userAge는 런타임에 결정되지만 이후 변경 불가
    
    return 0;
}
```

### 상수와 참조

```cpp
#include <iostream>
#include <string>

void printName(const std::string& name)  // const 참조 매개변수
{
    std::cout << name << "\n";
    // name = "다른이름";  // 오류! const 참조는 변경 불가
}

int main()
{
    std::string myName = "홍길동";
    printName(myName);  // 복사 없이 전달, 변경도 방지
    
    return 0;
}
```

### 실습 예제 4: 상수 활용하기

```cpp
#include <iostream>
#include <string>

int main()
{
    // 프로그램 설정 상수
    constexpr int MAX_LEVEL = 100;
    constexpr double EXP_MULTIPLIER = 1.5;
    constexpr int STARTING_HP = 100;
    
    // 게임 캐릭터 정보
    const std::string playerName = "용사";
    int currentLevel = 1;
    int currentExp = 0;
    int hp = STARTING_HP;
    
    std::cout << "=== 게임 캐릭터 정보 ===\n";
    std::cout << "이름: " << playerName << "\n";
    std::cout << "레벨: " << currentLevel << "/" << MAX_LEVEL << "\n";
    std::cout << "경험치: " << currentExp << "\n";
    std::cout << "체력: " << hp << "\n";
    
    // 레벨업 계산
    int expNeeded = static_cast<int>(100 * EXP_MULTIPLIER);
    std::cout << "다음 레벨까지: " << expNeeded << " EXP\n";
    
    // MAX_LEVEL = 200;  // 오류! constexpr는 변경 불가
    // playerName = "마법사";  // 오류! const는 변경 불가
    currentLevel = 2;  // OK - 일반 변수는 변경 가능
    
    return 0;
}
```

</br>   
  

## 3.5 종합 실습 문제
배운 내용을 활용하여 실제 프로그램을 작성해보자!

### 실습 1: 개인 정보 관리 프로그램
다양한 데이터 타입을 사용하여 개인 정보를 저장하고 출력하는 프로그램을 작성하자.

**요구사항:**
- 이름 (문자열)
- 나이 (정수)
- 키 (실수)
- 성별 (문자)
- 학생 여부 (불린)
- 모두 적절한 타입으로 선언하고 초기화
- 정보를 보기 좋게 출력

<details>
<summary>예제 답안 보기</summary>

```cpp
#include <iostream>
#include <string>

int main()
{
    // 개인 정보 변수 선언 및 초기화
    std::string name{"김영희"};
    int age{22};
    double height{165.5};
    char gender{'F'};
    bool isStudent{true};
    
    // 정보 출력
    std::cout << "========== 개인 정보 ==========\n";
    std::cout << "이름:     " << name << "\n";
    std::cout << "나이:     " << age << "세\n";
    std::cout << "키:       " << height << "cm\n";
    std::cout << "성별:     " << gender << "\n";
    std::cout << std::boolalpha;
    std::cout << "학생:     " << isStudent << "\n";
    std::cout << "==============================\n";
    
    return 0;
}
```
</details>

### 실습 2: 상품 정보 시스템
온라인 쇼핑몰의 상품 정보를 관리하는 프로그램을 작성하자.

**요구사항:**
- 상품명, 가격, 재고 수량, 할인 여부 등의 정보 저장
- const와 constexpr를 적절히 활용
- auto 키워드 활용

<details>
<summary>예제 답안 보기</summary>

```cpp
#include <iostream>
#include <string>

int main()
{
    // 상수 정의
    constexpr double TAX_RATE = 0.1;  // 세율 10%
    constexpr int MAX_STOCK = 1000;   // 최대 재고
    
    // 상품 정보
    const std::string productName{"무선 키보드"};
    auto price = 45000.0;              // double로 추론
    auto stock = 150;                  // int로 추론
    auto isOnSale = true;              // bool로 추론
    auto discountRate = 0.15;          // 15% 할인
    
    // 계산
    auto finalPrice = price * (1 - discountRate);
    auto priceWithTax = finalPrice * (1 + TAX_RATE);
    
    // 출력
    std::cout << "========== 상품 정보 ==========\n";
    std::cout << "상품명:   " << productName << "\n";
    std::cout << "정가:     " << price << "원\n";
    std::cout << "재고:     " << stock << "/" << MAX_STOCK << "\n";
    std::cout << std::boolalpha;
    std::cout << "할인 중:  " << isOnSale << "\n";
    
    if (isOnSale)
    {
        std::cout << "할인가:   " << finalPrice << "원\n";
        std::cout << "세금포함: " << priceWithTax << "원\n";
    }
    std::cout << "==============================\n";
    
    return 0;
}
```
</details>

### 실습 3: 게임 캐릭터 스탯 시스템
RPG 게임의 캐릭터 스탯을 관리하는 프로그램을 작성하자.

**요구사항:**
- 캐릭터 이름, 레벨, HP, MP, 공격력, 방어력 등
- constexpr로 최대값 정의
- 스탯 정보를 보기 좋게 출력

<details>
<summary>예제 답안 보기</summary>

```cpp
#include <iostream>
#include <string>

int main()
{
    // 게임 상수
    constexpr int MAX_LEVEL = 99;
    constexpr int MAX_HP = 9999;
    constexpr int MAX_MP = 999;
    
    // 캐릭터 정보
    const std::string characterName{"드래곤슬레이어"};
    auto level = 45;
    auto hp = 1250;
    auto maxHp = 1500;
    auto mp = 380;
    auto maxMp = 450;
    auto attack = 245;
    auto defense = 189;
    auto gold = 125000;
    
    // HP/MP 백분율 계산
    auto hpPercent = (static_cast<double>(hp) / maxHp) * 100;
    auto mpPercent = (static_cast<double>(mp) / maxMp) * 100;
    
    // 출력
    std::cout << "╔════════════════════════════════╗\n";
    std::cout << "║     캐릭터 스탯 정보           ║\n";
    std::cout << "╠════════════════════════════════╣\n";
    std::cout << "║ 이름: " << characterName << "      ║\n";
    std::cout << "║ 레벨: Lv." << level << " / " << MAX_LEVEL << "          ║\n";
    std::cout << "╠════════════════════════════════╣\n";
    std::cout << "║ HP:   " << hp << " / " << maxHp 
              << " (" << static_cast<int>(hpPercent) << "%)  ║\n";
    std::cout << "║ MP:   " << mp << " / " << maxMp 
              << " (" << static_cast<int>(mpPercent) << "%)   ║\n";
    std::cout << "╠════════════════════════════════╣\n";
    std::cout << "║ 공격력: " << attack << "               ║\n";
    std::cout << "║ 방어력: " << defense << "               ║\n";
    std::cout << "║ 골드:   " << gold << "          ║\n";
    std::cout << "╚════════════════════════════════╝\n";
    
    return 0;
}
```
</details>
    

</br>  
  

## 3.6 심화 내용

### 타입 별칭 (Type Alias)
복잡한 타입에 간단한 이름을 붙일 수 있다.

```cpp
#include <iostream>
#include <string>
#include <vector>

int main()
{
    // using을 사용한 타입 별칭 (Modern C++)
    using StudentID = int;
    using StudentName = std::string;
    using Grades = std::vector<double>;
    
    StudentID id{20230001};
    StudentName name{"홍길동"};
    Grades scores{95.5, 88.0, 92.5};
    
    std::cout << "학번: " << id << "\n";
    std::cout << "이름: " << name << "\n";
    std::cout << "성적 수: " << scores.size() << "\n";
    
    return 0;
}
```

**typedef vs using:**

```cpp
// 옛날 방식
typedef unsigned long long ull;

// Modern 방식 (권장!)
using ull = unsigned long long;

// using이 더 읽기 쉬움
using IntVector = std::vector<int>;
// typedef std::vector<int> IntVector;  // 복잡함
```

### 리터럴 (Literals)
값을 표현하는 다양한 방법들:

```cpp
#include <iostream>

int main()
{
    // 정수 리터럴
    auto decimal = 42;        // 10진수
    auto hex = 0x2A;          // 16진수 (42)
    auto octal = 052;         // 8진수 (42)
    auto binary = 0b101010;   // 2진수 (42) - C++14
    
    // 큰 숫자의 가독성 (C++14)
    auto million = 1'000'000;
    auto billion = 1'000'000'000LL;
    
    // 실수 리터럴
    auto pi1 = 3.14;          // double
    auto pi2 = 3.14f;         // float
    auto pi3 = 3.14L;         // long double
    auto scientific = 1.23e-4; // 과학적 표기법
    
    // 문자 리터럴
    auto ch1 = 'A';           // char
    auto ch2 = L'A';          // wchar_t
    auto ch3 = u'A';          // char16_t
    auto ch4 = U'A';          // char32_t
    
    // 문자열 리터럴
    auto str1 = "Hello";      // const char*
    auto str2 = L"Hello";     // const wchar_t*
    auto str3 = u8"Hello";    // UTF-8
    
    // bool 리터럴
    auto isTrue = true;
    auto isFalse = false;
    
    // nullptr 리터럴 (포인터용)
    int* ptr = nullptr;
    
    std::cout << "10진수: " << decimal << "\n";
    std::cout << "16진수: " << hex << "\n";
    std::cout << "백만: " << million << "\n";
    
    return 0;
}
```

### 사용자 정의 리터럴 (User-Defined Literals)
C++11부터 자신만의 리터럴을 만들 수 있다.

```cpp
#include <iostream>
#include <chrono>

// 거리 단위 변환
constexpr long double operator"" _km(long double km)
{
    return km * 1000;  // 미터로 변환
}

constexpr long double operator"" _m(long double m)
{
    return m;
}

int main()
{
    auto distance1 = 5.5_km;  // 5500 미터
    auto distance2 = 100.0_m; // 100 미터
    
    std::cout << "거리 1: " << distance1 << " 미터\n";
    std::cout << "거리 2: " << distance2 << " 미터\n";
    std::cout << "합계: " << (distance1 + distance2) << " 미터\n";
    
    // 표준 라이브러리의 사용자 정의 리터럴
    using namespace std::chrono_literals;
    
    auto duration1 = 5s;      // 5초
    auto duration2 = 100ms;   // 100밀리초
    auto duration3 = 2min;    // 2분
    
    return 0;
}
```

### sizeof 연산자 심화

```cpp
#include <iostream>
#include <string>
#include <array>

int main()
{
    int x = 42;
    double y = 3.14;
    std::string str = "Hello";
    std::array<int, 10> arr;
    
    std::cout << "int 크기: " << sizeof(int) << " 바이트\n";
    std::cout << "변수 x 크기: " << sizeof(x) << " 바이트\n";
    std::cout << "double 크기: " << sizeof(double) << " 바이트\n";
    std::cout << "string 객체 크기: " << sizeof(str) << " 바이트\n";
    std::cout << "array 크기: " << sizeof(arr) << " 바이트\n";
    std::cout << "array 요소 수: " << sizeof(arr) / sizeof(arr[0]) << "\n";
    
    // C++17: std::size 사용 (더 안전)
    std::cout << "array 크기 (std::size): " << std::size(arr) << "\n";
    
    return 0;
}
```

</br>  
  
  
## 3.7 Chapter 3 요약 및 복습

### 핵심 개념 정리

**1. 기본 데이터 타입**
- ✅ `int`: 정수 (-2,147,483,648 ~ 2,147,483,647)
- ✅ `double`: 실수 (소수점, 약 15자리 정밀도)
- ✅ `bool`: 논리값 (true/false)
- ✅ `char`: 단일 문자 ('A', 'B', ...)
- ✅ `std::string`: 문자열 ("Hello")

**2. 변수 선언과 초기화**
- ✅ 중괄호 초기화 권장: `int x{10};`
- ✅ 항상 초기화하기: 쓰레기 값 방지
- ✅ 의미 있는 변수 이름 사용

**3. auto 키워드**
- ✅ 컴파일러가 타입 자동 추론
- ✅ 복잡한 타입 단순화
- ✅ 반드시 초기값 필요

**4. const와 constexpr**
- ✅ `const`: 런타임 상수, 변경 불가
- ✅ `constexpr`: 컴파일 타임 상수
- ✅ `#define` 대신 사용

### 코딩 스타일 가이드

```cpp
#include <iostream>
#include <string>

int main()
{
    // 좋은 코드 예시
    
    // 1. 의미 있는 이름
    int studentAge{20};
    double accountBalance{1000.50};
    
    // 2. 중괄호 초기화
    std::string userName{"홍길동"};
    bool isVerified{true};
    
    // 3. const 활용
    const double TAX_RATE{0.1};
    constexpr int MAX_USERS{100};
    
    // 4. auto 적절히 사용
    auto totalAmount = accountBalance * (1 + TAX_RATE);
    
    // 5. 한 줄에 하나씩
    int score1{95};
    int score2{88};
    int score3{92};
    
    return 0;
}
```

### 복습 문제

**문제 1: 타입 선택**

다음 데이터를 저장하기에 가장 적합한 타입을 선택해라:

1. 사람의 나이: _______
2. 원주율 (3.14159...): _______
3. 로그인 성공 여부: _______
4. 사용자 이름: _______
5. 성적 등급 (A, B, C): _______

<details>
<summary>정답 보기</summary>

1. `int` (또는 `unsigned int`)
2. `double`
3. `bool`
4. `std::string`
5. `char`
</details>

**문제 2: 초기화 방법**

다음 코드의 문제점을 찾고 수정한다:

```cpp
#include <iostream>

int main()
{
    int age;
    double price = 12.99f;
    auto name;
    const int max;
    
    std::cout << age << " " << price << " " << max << "\n";
    
    return 0;
}
```

<details>
<summary>정답 보기</summary>

```cpp
#include <iostream>
#include <string>

int main()
{
    int age{25};              // 초기화 필요
    double price{12.99};      // float 리터럴 대신 double
    auto name = std::string{"홍길동"};  // auto는 초기값 필요
    const int max{100};       // const는 초기화 필수
    
    std::cout << age << " " << price << " " << max << "\n";
    
    return 0;
}
```

문제점:
1. `age`: 초기화하지 않음
2. `price`: `double`인데 `f` 리터럴 사용
3. `name`: `auto`는 초기값 필요
4. `max`: `const`는 반드시 초기화 필요
</details>

**문제 3: const vs constexpr**

다음 중 `constexpr`을 사용해야 하는 것은?

```cpp
A. const int maxValue = 100;
B. const int userInput = getUserInput();
C. const std::string appName = "MyApp";
D. const double pi = 3.14159;
```

<details>
<summary>정답 보기</summary>

**A와 D**를 `constexpr`로 변경 가능:

```cpp
constexpr int maxValue = 100;        // 컴파일 타임 상수
const int userInput = getUserInput(); // 런타임 상수 (const 유지)
const std::string appName = "MyApp";  // string은 constexpr 제한적
constexpr double pi = 3.14159;        // 컴파일 타임 상수
```

- **A, D**: 컴파일 타임에 값이 결정되므로 `constexpr` 사용 가능
- **B**: 함수 호출 결과이므로 런타임 결정, `const` 유지
- **C**: `std::string`은 `constexpr` 제약이 있음 (C++20부터 일부 지원)
</details>

**문제 4: 실전 프로그램 작성**

은행 계좌 정보를 관리하는 프로그램을 작성한다.  

요구사항:
- 계좌 소유자 이름
- 계좌 번호
- 잔액
- 이자율 (상수)
- 1년 후 잔액 계산
- 모든 정보 출력

<details>
<summary>예제 답안 보기</summary>

```cpp
#include <iostream>
#include <string>

int main()
{
    // 계좌 정보
    const std::string accountHolder{"김철수"};
    const std::string accountNumber{"1234-5678-9012"};
    auto balance = 1000000.0;  // double로 추론
    
    // 상수
    constexpr double INTEREST_RATE = 0.035;  // 3.5%
    
    // 1년 후 잔액 계산
    auto interest = balance * INTEREST_RATE;
    auto futureBalance = balance + interest;
    
    // 출력
    std::cout << "========== 계좌 정보 ==========\n";
    std::cout << "예금주:     " << accountHolder << "\n";
    std::cout << "계좌번호:   " << accountNumber << "\n";
    std::cout << "현재 잔액:  " << balance << "원\n";
    std::cout << "이자율:     " << (INTEREST_RATE * 100) << "%\n";
    std::cout << "1년 이자:   " << interest << "원\n";
    std::cout << "1년 후:     " << futureBalance << "원\n";
    std::cout << "==============================\n";
    
    return 0;
}
```
</details>
    
  
### 학습 체크리스트
스스로 확인해보자:

- [ ] 기본 데이터 타입 6가지를 설명할 수 있다
- [ ] 각 타입에 적합한 데이터를 판단할 수 있다
- [ ] 중괄호 초기화를 사용할 수 있다
- [ ] `auto` 키워드의 장단점을 이해했다
- [ ] `const`와 `constexpr`의 차이를 설명할 수 있다
- [ ] 의미 있는 변수 이름을 지을 수 있다
- [ ] `sizeof` 연산자를 사용할 수 있다
- [ ] 타입 안전한 코드를 작성할 수 있다


## 마치며
축하한다! C++의 기본 구성 요소인 데이터 타입과 변수를 마스터했다.

이번 챕터에서 배운 내용:
- **기본 타입**: int, double, bool, char, string
- **안전한 초기화**: 중괄호 초기화 `{}`
- **편리한 auto**: 타입 자동 추론
- **불변성**: const와 constexpr

기억하세요:
- **항상 변수를 초기화하세요** - 쓰레기 값은 버그의 원인
- **의미 있는 이름을 사용하세요** - 코드는 사람이 읽는 것
- **Modern C++ 기능을 활용하세요** - auto, constexpr 등

다음 챕터에서는 이 변수들을 가지고 계산하고 비교하는 방법을 배울 것이다. 연산자의 세계로 출발하자! 🚀

 