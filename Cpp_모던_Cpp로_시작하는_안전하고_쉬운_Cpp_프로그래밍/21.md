# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 21: 애니메이션과 시간 관리

## 21.1 들어가며

정적인 화면은 지루하다. 움직임과 변화가 있어야 사용자의 관심을 끌 수 있고, 직관적인 피드백을 제공할 수 있다. 이번 장에서는 시간을 정밀하게 측정하고 관리하는 방법, 부드러운 애니메이션을 만드는 기법, 그리고 다양한 이징 함수를 활용하여 자연스러운 움직임을 구현하는 방법을 배운다.

Modern C++의 `std::chrono` 라이브러리는 타입 안전하고 정밀한 시간 처리를 제공한다. Siv3D는 이를 기반으로 게임과 애니메이션에 필요한 시간 관리 기능을 제공한다. 프레임레이트에 독립적인 애니메이션을 만들면, 다양한 환경에서 일관된 경험을 제공할 수 있다.

## 21.2 `std::chrono`를 이용한 시간 처리

### 21.2.1 `std::chrono` 기초

C++11부터 도입된 `std::chrono`는 시간을 다루는 표준 라이브러리다. 타입 안전성과 정밀도를 보장한다.

```cpp
#include <Siv3D.hpp>
#include <chrono>

void Main()
{
    using namespace std::chrono;
    
    // 시작 시간 기록
    auto startTime = high_resolution_clock::now();
    
    int32 frameCount = 0;
    
    while (System::Update())
    {
        ++frameCount;
        
        // 현재 시간
        auto currentTime = high_resolution_clock::now();
        
        // 경과 시간 계산 (duration)
        auto elapsed = currentTime - startTime;
        
        // 다양한 단위로 변환
        auto seconds = duration_cast<std::chrono::seconds>(elapsed).count();
        auto milliseconds = duration_cast<milliseconds>(elapsed).count();
        auto microseconds = duration_cast<microseconds>(elapsed).count();
        
        Font{ 25 }(U"경과 시간: {}초"_fmt(seconds)).draw(20, 20, Palette::White);
        Font{ 20 }(U"밀리초: {}"_fmt(milliseconds)).draw(20, 60, Palette::Yellow);
        Font{ 20 }(U"마이크로초: {}"_fmt(microseconds)).draw(20, 90, Palette::Yellow);
        Font{ 20 }(U"프레임: {}"_fmt(frameCount)).draw(20, 130, Palette::Skyblue);
        
        // 평균 FPS 계산
        if (seconds > 0)
        {
            const double avgFPS = frameCount / static_cast<double>(seconds);
            Font{ 20 }(U"평균 FPS: {:.1f}"_fmt(avgFPS)).draw(20, 170, Palette::Orange);
        }
    }
}
```

`std::chrono`의 핵심 개념은 다음과 같다:

- **Clock**: 시간을 측정하는 시계 (`system_clock`, `steady_clock`, `high_resolution_clock`)
- **Time Point**: 특정 시점을 나타내는 객체
- **Duration**: 두 시점 사이의 시간 차이

`duration_cast`를 사용하여 원하는 시간 단위로 변환할 수 있다. Modern C++의 타입 시스템이 단위 변환 오류를 컴파일 타임에 방지한다.

### 21.2.2 Siv3D의 시간 관리 기능

Siv3D는 `std::chrono`를 기반으로 더 편리한 시간 관리 API를 제공한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {
        // 애플리케이션 시작 이후 경과 시간 (초)
        const double elapsed = Scene::Time();
        
        // 이전 프레임과의 시간 차이 (초)
        const double deltaTime = Scene::DeltaTime();
        
        // 현재 프레임레이트
        const double fps = Profiler::FPS();
        
        // 프레임 번호
        const int64 frameCount = Scene::FrameCount();
        
        Font{ 30 }(U"경과 시간: {:.2f}초"_fmt(elapsed))
            .draw(20, 20, Palette::White);
        
        Font{ 25 }(U"델타 타임: {:.4f}초"_fmt(deltaTime))
            .draw(20, 70, Palette::Yellow);
        
        Font{ 25 }(U"FPS: {:.1f}"_fmt(fps))
            .draw(20, 110, Palette::Orange);
        
        Font{ 25 }(U"프레임: {}"_fmt(frameCount))
            .draw(20, 150, Palette::Skyblue);
        
        // 델타 타임을 시각화
        const double barWidth = deltaTime * 1000; // 밀리초 단위로 변환
        Rect{ 20, 200, static_cast<int32>(barWidth * 10), 30 }
            .draw(Palette::Green);
        
        Font{ 18 }(U"델타 타임 시각화 (x10)")
            .draw(20, 240, Palette::Gray);
    }
}
```

`Scene::DeltaTime()`은 프레임 독립적인 애니메이션을 만드는 핵심이다. 이 값을 속도에 곱하면, 프레임레이트가 변해도 움직임의 속도가 일정하게 유지된다.

### 21.2.3 프레임 독립적인 움직임

프레임레이트가 달라도 동일한 속도로 움직이는 객체를 만들어보자.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 프레임 의존 방식
    Vec2 pos1 = Scene::Center();
    
    // 프레임 독립 방식
    Vec2 pos2 = Scene::Center();
    
    const double speed = 200.0; // 픽셀/초
    
    while (System::Update())
    {
        // 프레임 의존: 프레임마다 일정 거리 이동
        // (프레임레이트가 높으면 더 빠르게 이동)
        if (KeyLeft.pressed())
        {
            pos1.x -= 3; // 매 프레임마다 3픽셀
        }
        if (KeyRight.pressed())
        {
            pos1.x += 3;
        }
        
        // 프레임 독립: 초당 일정 거리 이동
        // (프레임레이트에 관계없이 일정한 속도)
        const double deltaTime = Scene::DeltaTime();
        
        if (KeyA.pressed())
        {
            pos2.x -= speed * deltaTime;
        }
        if (KeyD.pressed())
        {
            pos2.x += speed * deltaTime;
        }
        
        // 시각화
        Circle{ pos1, 30 }.draw(Palette::Red);
        Font{ 18 }(U"프레임 의존").drawAt(pos1.x, pos1.y - 50, Palette::White);
        Font{ 16 }(U"← → 키").drawAt(pos1.x, pos1.y + 50, Palette::Gray);
        
        Circle{ pos2, 30 }.draw(Palette::Blue);
        Font{ 18 }(U"프레임 독립").drawAt(pos2.x, pos2.y - 50, Palette::White);
        Font{ 16 }(U"A D 키").drawAt(pos2.x, pos2.y + 50, Palette::Gray);
        
        Font{ 20 }(U"FPS: {:.1f}"_fmt(Profiler::FPS()))
            .draw(20, 20, Palette::Yellow);
        
        Font{ 18 }(U"위: 프레임레이트가 변하면 속도도 변함")
            .draw(20, 550, Palette::Red);
        
        Font{ 18 }(U"아래: 프레임레이트에 관계없이 일정한 속도 ({} px/s)"_fmt(speed))
            .draw(20, 580, Palette::Blue);
    }
}
```

프레임 독립적인 방식이 올바른 접근법이다. 게임이나 애니메이션에서는 항상 델타 타임을 고려해야 한다.

### 21.2.4 시간 측정과 성능 분석

특정 코드 블록의 실행 시간을 측정할 수 있다.

```cpp
# include <Siv3D.hpp>

// 무거운 계산을 시뮬레이션
void heavyComputation(int32 iterations)
{
    double result = 0.0;
    for (int32 i = 0; i < iterations; ++i)
    {
        result += Math::Sin(i * 0.001) * Math::Cos(i * 0.001);
    }
}

void Main()
{
    int32 iterations = 100000;
    double lastMeasurement = 0.0;
    
    while (System::Update())
    {
        // 슬라이더로 반복 횟수 조절
        SimpleGUI::Slider(U"반복 횟수: {}"_fmt(iterations), 
                         iterations, 10000, 1000000, 
                         Vec2{ 20, 20 }, 200, 400);
        
        if (SimpleGUI::Button(U"측정 시작", Vec2{ 20, 80 }, 150))
        {
            // 시간 측정 시작
            const auto startTime = std::chrono::high_resolution_clock::now();
            
            // 측정할 코드
            heavyComputation(iterations);
            
            // 시간 측정 종료
            const auto endTime = std::chrono::high_resolution_clock::now();
            
            // 경과 시간 계산 (마이크로초)
            const auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
                endTime - startTime
            );
            
            lastMeasurement = duration.count() / 1000.0; // 밀리초로 변환
        }
        
        Font{ 25 }(U"마지막 측정: {:.2f}ms"_fmt(lastMeasurement))
            .draw(20, 150, Palette::Yellow);
        
        // 예상 FPS 영향 계산
        if (lastMeasurement > 0)
        {
            const double frameTime = lastMeasurement;
            const double maxFPS = 1000.0 / frameTime;
            
            Font{ 20 }(U"이 작업만으로 최대 {:.0f} FPS"_fmt(maxFPS))
                .draw(20, 190, frameTime > 16.67 ? Palette::Red : Palette::Green);
            
            if (frameTime > 16.67)
            {
                Font{ 18 }(U"⚠ 60 FPS를 유지하기 어렵습니다")
                    .draw(20, 220, Palette::Orange);
            }
        }
        
        Font{ 18 }(U"16.67ms = 60 FPS 기준")
            .draw(20, 260, Palette::Gray);
    }
}
```

성능에 민감한 코드는 이런 방식으로 측정하고 최적화해야 한다. 60 FPS를 유지하려면 한 프레임이 약 16.67ms 이내에 완료되어야 한다.

## 21.3 애니메이션 기초

### 21.3.1 선형 애니메이션

가장 단순한 형태의 애니메이션은 시간에 따라 값을 선형적으로 변화시키는 것이다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    double animationTime = 0.0;
    const double duration = 3.0; // 3초 동안 애니메이션
    bool isAnimating = false;
    
    while (System::Update())
    {
        if (SimpleGUI::Button(U"애니메이션 시작", Vec2{ 20, 20 }))
        {
            animationTime = 0.0;
            isAnimating = true;
        }
        
        if (isAnimating)
        {
            animationTime += Scene::DeltaTime();
            
            if (animationTime >= duration)
            {
                animationTime = duration;
                isAnimating = false;
            }
        }
        
        // 진행도 (0.0 ~ 1.0)
        const double progress = Math::Clamp(animationTime / duration, 0.0, 1.0);
        
        // 위치 애니메이션
        const double startX = 100.0;
        const double endX = 700.0;
        const double currentX = Math::Lerp(startX, endX, progress);
        
        Circle{ currentX, 200, 30 }.draw(Palette::Skyblue);
        
        // 크기 애니메이션
        const double startRadius = 20.0;
        const double endRadius = 80.0;
        const double currentRadius = Math::Lerp(startRadius, endRadius, progress);
        
        Circle{ 400, 350, currentRadius }.draw(Palette::Orange);
        
        // 색상 애니메이션
        const ColorF startColor{ 1.0, 0.0, 0.0 };
        const ColorF endColor{ 0.0, 0.0, 1.0 };
        const ColorF currentColor = startColor.lerp(endColor, progress);
        
        Circle{ 400, 500, 40 }.draw(currentColor);
        
        // 진행 바
        const Rect progressBar{ 50, 100, 700, 30 };
        progressBar.draw(Palette::Gray);
        Rect{ 50, 100, static_cast<int32>(700 * progress), 30 }
            .draw(Palette::Green);
        
        Font{ 20 }(U"진행도: {:.0f}%"_fmt(progress * 100))
            .drawAt(400, 115, Palette::White);
        
        Font{ 18 }(U"위치 변화").draw(320, 240, Palette::White);
        Font{ 18 }(U"크기 변화").draw(320, 390, Palette::White);
        Font{ 18 }(U"색상 변화").draw(320, 540, Palette::White);
    }
}
```

`Math::Lerp()` 함수는 선형 보간(Linear Interpolation)을 수행한다. 시작값과 끝값 사이를 진행도에 따라 계산한다. `ColorF::lerp()`는 색상 간 부드러운 전환을 구현한다.

### 21.3.2 반복 애니메이션

애니메이션을 무한히 반복하거나 왕복시킬 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {
        const double time = Scene::Time();
        
        // 1. 무한 반복 (0 ~ 1 반복)
        const double loop1 = Math::Fraction(time);
        const double x1 = Math::Lerp(100.0, 700.0, loop1);
        Circle{ x1, 100, 25 }.draw(Palette::Red);
        Font{ 16 }(U"무한 반복").draw(50, 130, Palette::White);
        
        // 2. 느린 반복 (3초 주기)
        const double loop2 = Math::Fraction(time / 3.0);
        const double x2 = Math::Lerp(100.0, 700.0, loop2);
        Circle{ x2, 200, 25 }.draw(Palette::Orange);
        Font{ 16 }(U"3초 주기").draw(50, 230, Palette::White);
        
        // 3. 왕복 애니메이션 (삼각파)
        const double pingPong = Math::Abs(Math::Fraction(time / 2.0) * 2.0 - 1.0);
        const double x3 = Math::Lerp(100.0, 700.0, pingPong);
        Circle{ x3, 300, 25 }.draw(Palette::Yellow);
        Font{ 16 }(U"왕복 (2초)").draw(50, 330, Palette::White);
        
        // 4. 사인파 (부드러운 왕복)
        const double sine = (Math::Sin(time * Math::TwoPi / 2.0) + 1.0) / 2.0;
        const double x4 = Math::Lerp(100.0, 700.0, sine);
        Circle{ x4, 400, 25 }.draw(Palette::Green);
        Font{ 16 }(U"사인파 왕복").draw(50, 430, Palette::White);
        
        // 5. 회전 애니메이션
        const Vec2 center{ 400, 520 };
        const double angle = time * 90_deg; // 90도/초
        const Vec2 offset{ Math::Cos(angle) * 80, Math::Sin(angle) * 80 };
        Circle{ center + offset, 20 }.draw(Palette::Skyblue);
        Circle{ center, 5 }.draw(Palette::White);
        Font{ 16 }(U"원형 회전").draw(50, 550, Palette::White);
    }
}
```

`Math::Fraction()`은 소수 부분만 추출하여 0~1 사이의 값을 반환한다. 이를 활용하면 반복 애니메이션을 쉽게 만들 수 있다.

### 21.3.3 다중 속성 애니메이션

여러 속성을 동시에 애니메이션할 수 있다.

```cpp
# include <Siv3D.hpp>

struct AnimatedObject
{
    Vec2 position;
    double rotation;
    double scale;
    ColorF color;
};

void Main()
{
    AnimatedObject startState{
        .position = Vec2{ 150, 300 },
        .rotation = 0.0,
        .scale = 1.0,
        .color = ColorF{ 1.0, 0.0, 0.0 }
    };
    
    AnimatedObject endState{
        .position = Vec2{ 650, 300 },
        .rotation = Math::TwoPi,
        .scale = 2.0,
        .color = ColorF{ 0.0, 0.0, 1.0 }
    };
    
    double animationTime = 0.0;
    const double duration = 2.0;
    bool isAnimating = false;
    bool reverse = false;
    
    while (System::Update())
    {
        if (SimpleGUI::Button(U"정방향 재생", Vec2{ 20, 20 }))
        {
            animationTime = 0.0;
            isAnimating = true;
            reverse = false;
        }
        
        if (SimpleGUI::Button(U"역방향 재생", Vec2{ 20, 60 }))
        {
            animationTime = 0.0;
            isAnimating = true;
            reverse = true;
        }
        
        if (isAnimating)
        {
            animationTime += Scene::DeltaTime();
            
            if (animationTime >= duration)
            {
                animationTime = duration;
                isAnimating = false;
            }
        }
        
        double progress = Math::Clamp(animationTime / duration, 0.0, 1.0);
        if (reverse)
        {
            progress = 1.0 - progress;
        }
        
        // 모든 속성 보간
        AnimatedObject current;
        current.position = startState.position.lerp(endState.position, progress);
        current.rotation = Math::Lerp(startState.rotation, endState.rotation, progress);
        current.scale = Math::Lerp(startState.scale, endState.scale, progress);
        current.color = startState.color.lerp(endState.color, progress);
        
        // 변환 적용하여 그리기
        const Transformer2D transformer{
            Mat3x2::Scale(current.scale, current.position)
                .rotated(current.rotation, current.position)
        };
        
        RectF{ Arg::center = current.position, 60, 60 }
            .draw(current.color);
        
        // 정보 표시
        Font{ 18 }(U"위치: ({:.0f}, {:.0f})"_fmt(current.position.x, current.position.y))
            .draw(20, 120, Palette::White);
        
        Font{ 18 }(U"회전: {:.0f}도"_fmt(Math::ToDegrees(current.rotation)))
            .draw(20, 150, Palette::White);
        
        Font{ 18 }(U"스케일: {:.2f}배"_fmt(current.scale))
            .draw(20, 180, Palette::White);
        
        Font{ 18 }(U"진행도: {:.0f}%"_fmt(progress * 100))
            .draw(20, 210, Palette::Yellow);
    }
}
```

C++20의 지정 초기화(designated initializers)를 사용하면 구조체를 명확하게 초기화할 수 있다. `Transformer2D`는 변환 행렬을 적용하여 도형을 회전, 확대/축소할 수 있게 해준다.

### 21.3.4 시퀀스 애니메이션

여러 애니메이션을 순서대로 실행할 수 있다.

```cpp
# include <Siv3D.hpp>

enum class AnimationPhase
{
    MoveRight,
    MoveDown,
    MoveLeft,
    MoveUp,
    Finished
};

void Main()
{
    Vec2 position{ 150, 150 };
    AnimationPhase currentPhase = AnimationPhase::Finished;
    double phaseTime = 0.0;
    const double phaseDuration = 1.0; // 각 단계 1초
    
    while (System::Update())
    {
        if (SimpleGUI::Button(U"시퀀스 시작", Vec2{ 20, 20 }))
        {
            position = Vec2{ 150, 150 };
            currentPhase = AnimationPhase::MoveRight;
            phaseTime = 0.0;
        }
        
        // 애니메이션 업데이트
        if (currentPhase != AnimationPhase::Finished)
        {
            phaseTime += Scene::DeltaTime();
            
            if (phaseTime >= phaseDuration)
            {
                phaseTime = 0.0;
                
                // 다음 단계로 전환
                switch (currentPhase)
                {
                case AnimationPhase::MoveRight:
                    currentPhase = AnimationPhase::MoveDown;
                    break;
                case AnimationPhase::MoveDown:
                    currentPhase = AnimationPhase::MoveLeft;
                    break;
                case AnimationPhase::MoveLeft:
                    currentPhase = AnimationPhase::MoveUp;
                    break;
                case AnimationPhase::MoveUp:
                    currentPhase = AnimationPhase::Finished;
                    break;
                default:
                    break;
                }
            }
            
            const double progress = phaseTime / phaseDuration;
            const double distance = 400.0;
            
            // 각 단계별 이동
            switch (currentPhase)
            {
            case AnimationPhase::MoveRight:
                position.x = Math::Lerp(150.0, 150.0 + distance, progress);
                position.y = 150.0;
                break;
            case AnimationPhase::MoveDown:
                position.x = 550.0;
                position.y = Math::Lerp(150.0, 150.0 + distance, progress);
                break;
            case AnimationPhase::MoveLeft:
                position.x = Math::Lerp(550.0, 150.0, progress);
                position.y = 550.0;
                break;
            case AnimationPhase::MoveUp:
                position.x = 150.0;
                position.y = Math::Lerp(550.0, 150.0, progress);
                break;
            default:
                break;
            }
        }
        
        // 경로 표시
        Line{ 150, 150, 550, 150 }.draw(2, Palette::Gray);
        Line{ 550, 150, 550, 550 }.draw(2, Palette::Gray);
        Line{ 550, 550, 150, 550 }.draw(2, Palette::Gray);
        Line{ 150, 550, 150, 150 }.draw(2, Palette::Gray);
        
        // 객체 그리기
        Circle{ position, 30 }.draw(Palette::Orange);
        
        // 상태 표시
        String phaseText;
        switch (currentPhase)
        {
        case AnimationPhase::MoveRight: phaseText = U"→ 오른쪽 이동"; break;
        case AnimationPhase::MoveDown:  phaseText = U"↓ 아래 이동"; break;
        case AnimationPhase::MoveLeft:  phaseText = U"← 왼쪽 이동"; break;
        case AnimationPhase::MoveUp:    phaseText = U"↑ 위 이동"; break;
        case AnimationPhase::Finished:  phaseText = U"완료"; break;
        }
        
        Font{ 25 }(phaseText).draw(20, 80, Palette::Yellow);
        
        if (currentPhase != AnimationPhase::Finished)
        {
            const double progress = phaseTime / phaseDuration;
            Font{ 20 }(U"진행: {:.0f}%"_fmt(progress * 100))
                .draw(20, 120, Palette::White);
        }
    }
}
```

`enum class`를 사용하여 애니메이션 단계를 명확하게 정의한다. 각 단계가 완료되면 다음 단계로 자동 전환된다.

## 21.4 이징(Easing) 함수 활용

### 21.4.1 이징 함수란?

선형 애니메이션은 일정한 속도로 변화하지만, 실제 세계의 움직임은 가속과 감속이 있다. 이징 함수는 애니메이션에 자연스러운 가속도를 부여한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    double animationTime = 0.0;
    const double duration = 2.0;
    bool isAnimating = false;
    
    // 다양한 이징 함수 목록
    const Array<std::pair<std::function<double(double)>, String>> easings = {
        { [](double t) { return t; }, U"Linear" },
        { [](double t) { return t * t; }, U"Quad In" },
        { [](double t) { return t * (2.0 - t); }, U"Quad Out" },
        { [](double t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }, U"Quad InOut" },
        { [](double t) { return t * t * t; }, U"Cubic In" },
        { [](double t) { double f = t - 1.0; return f * f * f + 1.0; }, U"Cubic Out" }
    };
    
    while (System::Update())
    {
        if (SimpleGUI::Button(U"애니메이션 시작", Vec2{ 20, 20 }))
        {
            animationTime = 0.0;
            isAnimating = true;
        }
        
        if (isAnimating)
        {
            animationTime += Scene::DeltaTime();
            
            if (animationTime >= duration)
            {
                animationTime = duration;
                isAnimating = false;
            }
        }
        
        const double progress = Math::Clamp(animationTime / duration, 0.0, 1.0);
        
        // 각 이징 함수 적용
        const double startX = 100.0;
        const double endX = 700.0;
        
        for (size_t i = 0; i < easings.size(); ++i)
        {
            const double easedProgress = easings[i].first(progress);
            const double x = Math::Lerp(startX, endX, easedProgress);
            const double y = 100.0 + i * 80.0;
            
            // 경로 선
            Line{ startX, y, endX, y }.draw(2, Palette::Gray);
            
            // 이동하는 원
            Circle{ x, y, 20 }.draw(Palette::Skyblue);
            
            // 이징 이름
            Font{ 16 }(easings[i].second).draw(startX + 10, y - 40, Palette::White);
        }
        
        Font{ 20 }(U"진행도: {:.0f}%"_fmt(progress * 100))
            .draw(20, 70, Palette::Yellow);
    }
}
```

각 이징 함수는 0~1 사이의 입력을 받아 변형된 0~1 값을 반환한다. 람다 표현식을 사용하여 간결하게 정의할 수 있다.

### 21.4.2 Siv3D의 내장 이징 함수

Siv3D는 다양한 이징 함수를 제공한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    double animationTime = 0.0;
    const double duration = 2.0;
    bool isAnimating = false;
    
    while (System::Update())
    {
        if (SimpleGUI::Button(U"애니메이션 시작", Vec2{ 20, 20 }))
        {
            animationTime = 0.0;
            isAnimating = true;
        }
        
        if (isAnimating)
        {
            animationTime += Scene::DeltaTime();
            
            if (animationTime >= duration)
            {
                animationTime = duration;
                isAnimating = false;
            }
        }
        
        const double t = Math::Clamp(animationTime / duration, 0.0, 1.0);
        
        // Siv3D 이징 함수들
        const double linear = t;
        const double easeInQuad = EaseInQuad(t);
        const double easeOutQuad = EaseOutQuad(t);
        const double easeInOutQuad = EaseInOutQuad(t);
        const double easeInCubic = EaseInCubic(t);
        const double easeOutCubic = EaseOutCubic(t);
        const double easeInBack = EaseInBack(t);
        const double easeOutBack = EaseOutBack(t);
        const double easeInBounce = EaseInBounce(t);
        const double easeOutBounce = EaseOutBounce(t);
        
        // 시각화
        const Array<std::pair<double, String>> values = {
            { linear, U"Linear" },
            { easeInQuad, U"Ease In Quad" },
            { easeOutQuad, U"Ease Out Quad" },
            { easeInOutQuad, U"Ease InOut Quad" },
            { easeInCubic, U"Ease In Cubic" },
            { easeOutCubic, U"Ease Out Cubic" },
            { easeInBack, U"Ease In Back" },
            { easeOutBack, U"Ease Out Back" },
            { easeInBounce, U"Ease In Bounce" },
            { easeOutBounce, U"Ease Out Bounce" }
        };
        
        const double startX = 200.0;
        const double endX = 750.0;
        
        for (size_t i = 0; i < values.size(); ++i)
        {
            const double x = Math::Lerp(startX, endX, values[i].first);
            const double y = 100.0 + i * 50.0;
            
            Line{ startX, y, endX, y }.draw(1, Palette::Gray);
            Circle{ x, y, 15 }.draw(Palette::Orange);
            Font{ 14 }(values[i].second).draw(20, y - 7, Palette::White);
        }
        
        Font{ 20 }(U"진행도: {:.0f}%"_fmt(t * 100))
            .draw(20, 70, Palette::Yellow);
    }
}
```

Siv3D가 제공하는 이징 함수는 다음과 같다:

- **Linear**: 선형 (일정한 속도)
- **Quad**: 2차 곡선
- **Cubic**: 3차 곡선
- **Quart**: 4차 곡선
- **Quint**: 5차 곡선
- **Sine**: 사인 곡선
- **Expo**: 지수 곡선
- **Circ**: 원형 곡선
- **Back**: 뒤로 살짝 갔다가 앞으로 (오버슈트)
- **Elastic**: 탄성 효과
- **Bounce**: 바운스 효과

각각 In, Out, InOut 변형이 있다.

### 21.4.3 이징 함수의 실용적 활용

UI 요소에 이징을 적용하여 전문적인 느낌을 만들어보자.

```cpp
# include <Siv3D.hpp>

class AnimatedButton
{
public:
    AnimatedButton(const Vec2& pos, const String& text)
        : m_rect{ Arg::center = pos, 200, 60 }
        , m_text{ text }
        , m_normalScale{ 1.0 }
        , m_currentScale{ 1.0 }
        , m_targetScale{ 1.0 }
    {
    }
    
    bool update()
    {
        const bool mouseOver = m_rect.mouseOver();
        m_targetScale = mouseOver ? 1.1 : 1.0;
        
        // 부드러운 스케일 전환
        const double lerpSpeed = 10.0 * Scene::DeltaTime();
        m_currentScale += (m_targetScale - m_currentScale) * lerpSpeed;
        
        return m_rect.leftClicked();
    }
    
    void draw() const
    {
        const Vec2 center = m_rect.center();
        
        // 스케일 변환 적용
        const Transformer2D transformer{
            Mat3x2::Scale(m_currentScale, center)
        };
        
        const bool mouseOver = m_rect.mouseOver();
        
        m_rect.rounded(10).draw(mouseOver ? Palette::Orange : Palette::Gray);
        m_rect.rounded(10).drawFrame(2, Palette::White);
        
        Font{ 25 }(m_text).drawAt(center, Palette::White);
    }
    
private:
    RectF m_rect;
    String m_text;
    double m_normalScale;
    double m_currentScale;
    double m_targetScale;
};

void Main()
{
    Array<AnimatedButton> buttons = {
        AnimatedButton{ Vec2{ 200, 150 }, U"새 게임" },
        AnimatedButton{ Vec2{ 200, 250 }, U"이어하기" },
        AnimatedButton{ Vec2{ 200, 350 }, U"설정" },
        AnimatedButton{ Vec2{ 200, 450 }, U"종료" }
    };
    
    // 메시지 박스 애니메이션
    double messageTime = 0.0;
    String message;
    bool showMessage = false;
    
    while (System::Update())
    {
        // 배경
        Scene::Rect().draw(ColorF{ 0.2, 0.3, 0.4 });
        
        Font{ 50 }(U"메인 메뉴").drawAt(200, 50, Palette::White);
        
        // 버튼 업데이트 및 그리기
        for (size_t i = 0; i < buttons.size(); ++i)
        {
            if (buttons[i].update())
            {
                switch (i)
                {
                case 0: message = U"새 게임을 시작합니다"; break;
                case 1: message = U"게임을 이어합니다"; break;
                case 2: message = U"설정 화면을 엽니다"; break;
                case 3: message = U"게임을 종료합니다"; break;
                }
                showMessage = true;
                messageTime = 0.0;
            }
            
            buttons[i].draw();
        }
        
        // 메시지 박스 애니메이션
        if (showMessage)
        {
            messageTime += Scene::DeltaTime();
            
            if (messageTime > 2.0)
            {
                showMessage = false;
            }
            
            // 페이드 인/아웃
            double alpha = 1.0;
            if (messageTime < 0.3)
            {
                alpha = EaseOutQuad(messageTime / 0.3);
            }
            else if (messageTime > 1.7)
            {
                alpha = EaseInQuad(1.0 - (messageTime - 1.7) / 0.3);
            }
            
            // 슬라이드 인
            const double slideProgress = EaseOutBack(Math::Min(messageTime / 0.5, 1.0));
            const double messageY = Math::Lerp(700.0, 550.0, slideProgress);
            
            const RectF messageBox{ Arg::center = Vec2{ 500, messageY }, 400, 80 };
            messageBox.rounded(15).draw(ColorF{ 0.1, 0.1, 0.1, alpha * 0.9 });
            messageBox.rounded(15).drawFrame(3, ColorF{ 1.0, 1.0, 1.0, alpha });
            
            Font{ 25 }(message).drawAt(messageBox.center(), ColorF{ 1.0, 1.0, 1.0, alpha });
        }
    }
}
```

버튼의 스케일을 부드럽게 변경하고, 메시지 박스는 슬라이드와 페이드 효과를 조합한다. 이러한 미세한 애니메이션이 사용자 경험을 크게 향상시킨다.

### 21.4.4 커스텀 이징 함수 만들기

특별한 효과를 위해 자신만의 이징 함수를 만들 수 있다.

```cpp
# include <Siv3D.hpp>

// 계단식 이징 (단계별로 변화)
double EaseSteps(double t, int32 steps)
{
    return Math::Floor(t * steps) / steps;
}

// 지그재그 이징
double EaseZigZag(double t, int32 count)
{
    const double frequency = count * 2.0;
    return Math::Abs(Math::Fraction(t * frequency) * 2.0 - 1.0);
}

// 웨이브 이징
double EaseWave(double t, double frequency, double amplitude)
{
    return t + Math::Sin(t * Math::TwoPi * frequency) * amplitude;
}

void Main()
{
    double animationTime = 0.0;
    const double duration = 3.0;
    bool isAnimating = false;
    
    while (System::Update())
    {
        if (SimpleGUI::Button(U"애니메이션 시작", Vec2{ 20, 20 }))
        {
            animationTime = 0.0;
            isAnimating = true;
        }
        
        if (isAnimating)
        {
            animationTime += Scene::DeltaTime();
            
            if (animationTime >= duration)
            {
                animationTime = duration;
                isAnimating = false;
            }
        }
        
        const double t = Math::Clamp(animationTime / duration, 0.0, 1.0);
        const double startX = 100.0;
        const double endX = 700.0;
        
        // 일반 선형
        {
            const double x = Math::Lerp(startX, endX, t);
            Line{ startX, 100, endX, 100 }.draw(1, Palette::Gray);
            Circle{ x, 100, 15 }.draw(Palette::White);
            Font{ 16 }(U"Linear").draw(20, 85, Palette::White);
        }
        
        // 계단식 (5단계)
        {
            const double eased = EaseSteps(t, 5);
            const double x = Math::Lerp(startX, endX, eased);
            Line{ startX, 200, endX, 200 }.draw(1, Palette::Gray);
            Circle{ x, 200, 15 }.draw(Palette::Orange);
            Font{ 16 }(U"Steps (5)").draw(20, 185, Palette::White);
        }
        
        // 지그재그 (3회)
        {
            const double eased = EaseZigZag(t, 3);
            const double x = startX;
            const double y = Math::Lerp(300.0, 400.0, eased);
            Line{ startX, 300, startX, 400 }.draw(1, Palette::Gray);
            Circle{ x, y, 15 }.draw(Palette::Yellow);
            Font{ 16 }(U"ZigZag (3)").draw(20, 335, Palette::White);
        }
        
        // 웨이브 (주파수 3, 진폭 0.1)
        {
            const double eased = EaseWave(t, 3.0, 0.1);
            const double clampedEased = Math::Clamp(eased, 0.0, 1.0);
            const double x = Math::Lerp(startX, endX, clampedEased);
            Line{ startX, 500, endX, 500 }.draw(1, Palette::Gray);
            Circle{ x, 500, 15 }.draw(Palette::Skyblue);
            Font{ 16 }(U"Wave").draw(20, 485, Palette::White);
        }
        
        Font{ 20 }(U"진행도: {:.0f}%"_fmt(t * 100))
            .draw(20, 70, Palette::Yellow);
    }
}
```

커스텀 이징 함수는 특별한 시각 효과를 만들 때 유용하다. 게임의 특성에 맞는 독특한 움직임을 구현할 수 있다.

## 21.5 타이머와 카운터 구현

### 21.5.1 카운트다운 타이머

시간 제한이 있는 게임이나 퀴즈에서 사용하는 타이머를 만들어보자.

```cpp
# include <Siv3D.hpp>

class CountdownTimer
{
public:
    CountdownTimer(double duration)
        : m_duration{ duration }
        , m_remaining{ duration }
        , m_isRunning{ false }
    {
    }
    
    void start()
    {
        m_remaining = m_duration;
        m_isRunning = true;
    }
    
    void pause()
    {
        m_isRunning = false;
    }
    
    void resume()
    {
        m_isRunning = true;
    }
    
    void reset()
    {
        m_remaining = m_duration;
        m_isRunning = false;
    }
    
    void update()
    {
        if (m_isRunning && m_remaining > 0.0)
        {
            m_remaining -= Scene::DeltaTime();
            
            if (m_remaining <= 0.0)
            {
                m_remaining = 0.0;
                m_isRunning = false;
            }
        }
    }
    
    bool isFinished() const
    {
        return m_remaining <= 0.0;
    }
    
    bool isRunning() const
    {
        return m_isRunning;
    }
    
    double getRemaining() const
    {
        return m_remaining;
    }
    
    double getProgress() const
    {
        return 1.0 - (m_remaining / m_duration);
    }
    
    String getFormattedTime() const
    {
        const int32 minutes = static_cast<int32>(m_remaining) / 60;
        const int32 seconds = static_cast<int32>(m_remaining) % 60;
        const int32 milliseconds = static_cast<int32>((m_remaining - static_cast<int32>(m_remaining)) * 100);
        
        return U"{:02d}:{:02d}.{:02d}"_fmt(minutes, seconds, milliseconds);
    }
    
private:
    double m_duration;
    double m_remaining;
    bool m_isRunning;
};

void Main()
{
    CountdownTimer timer{ 60.0 }; // 60초
    
    while (System::Update())
    {
        timer.update();
        
        // 컨트롤 버튼
        if (SimpleGUI::Button(U"시작", Vec2{ 20, 20 }, 100, !timer.isRunning()))
        {
            timer.start();
        }
        
        if (SimpleGUI::Button(U"일시정지", Vec2{ 140, 20 }, 100, timer.isRunning()))
        {
            timer.pause();
        }
        
        if (SimpleGUI::Button(U"재개", Vec2{ 260, 20 }, 100, !timer.isRunning() && !timer.isFinished()))
        {
            timer.resume();
        }
        
        if (SimpleGUI::Button(U"리셋", Vec2{ 380, 20 }, 100))
        {
            timer.reset();
        }
        
        // 타이머 표시
        const String timeText = timer.getFormattedTime();
        const Font largeFont{ 80, Typeface::Bold };
        
        // 시간이 10초 미만이면 빨간색
        const ColorF timeColor = timer.getRemaining() < 10.0 ? 
            Palette::Red : Palette::White;
        
        largeFont(timeText).drawAt(Scene::Center(), timeColor);
        
        // 진행 바
        const RectF progressBar{ 100, 400, 600, 40 };
        progressBar.draw(Palette::Gray);
        
        const double progress = timer.getProgress();
        RectF{ 100, 400, 600 * progress, 40 }
            .draw(progress < 0.8 ? Palette::Green : Palette::Orange);
        
        // 종료 메시지
        if (timer.isFinished())
        {
            Font{ 50 }(U"시간 종료!").drawAt(Scene::Center().movedBy(0, 100), Palette::Yellow);
        }
        
        // 상태 표시
        Font{ 20 }(timer.isRunning() ? U"실행 중" : U"정지")
            .draw(20, 500, Palette::Skyblue);
    }
}
```

이 타이머는 게임, 퀴즈, 프레젠테이션 등 다양한 곳에서 재사용할 수 있다. RAII 패턴을 따르며, 명확한 인터페이스를 제공한다.

### 21.5.2 스톱워치

경과 시간을 측정하는 스톱워치를 만들어보자.

```cpp
# include <Siv3D.hpp>

class Stopwatch
{
public:
    Stopwatch()
        : m_elapsed{ 0.0 }
        , m_isRunning{ false }
    {
    }
    
    void start()
    {
        if (!m_isRunning)
        {
            m_isRunning = true;
        }
    }
    
    void stop()
    {
        m_isRunning = false;
    }
    
    void reset()
    {
        m_elapsed = 0.0;
        m_isRunning = false;
    }
    
    void update()
    {
        if (m_isRunning)
        {
            m_elapsed += Scene::DeltaTime();
        }
    }
    
    double getElapsed() const
    {
        return m_elapsed;
    }
    
    bool isRunning() const
    {
        return m_isRunning;
    }
    
    String getFormattedTime() const
    {
        const int32 hours = static_cast<int32>(m_elapsed) / 3600;
        const int32 minutes = (static_cast<int32>(m_elapsed) % 3600) / 60;
        const int32 seconds = static_cast<int32>(m_elapsed) % 60;
        const int32 milliseconds = static_cast<int32>((m_elapsed - static_cast<int32>(m_elapsed)) * 100);
        
        if (hours > 0)
        {
            return U"{:02d}:{:02d}:{:02d}.{:02d}"_fmt(hours, minutes, seconds, milliseconds);
        }
        else
        {
            return U"{:02d}:{:02d}.{:02d}"_fmt(minutes, seconds, milliseconds);
        }
    }
    
private:
    double m_elapsed;
    bool m_isRunning;
};

void Main()
{
    Stopwatch stopwatch;
    Array<double> lapTimes;
    
    while (System::Update())
    {
        stopwatch.update();
        
        // 컨트롤
        if (SimpleGUI::Button(U"시작/정지", Vec2{ 20, 20 }, 150))
        {
            if (stopwatch.isRunning())
            {
                stopwatch.stop();
            }
            else
            {
                stopwatch.start();
            }
        }
        
        if (SimpleGUI::Button(U"랩 타임", Vec2{ 190, 20 }, 150, stopwatch.isRunning()))
        {
            lapTimes.push_back(stopwatch.getElapsed());
        }
        
        if (SimpleGUI::Button(U"리셋", Vec2{ 360, 20 }, 150))
        {
            stopwatch.reset();
            lapTimes.clear();
        }
        
        // 메인 타이머 표시
        const Font largeFont{ 60, Typeface::Bold };
        largeFont(stopwatch.getFormattedTime())
            .drawAt(Scene::Center().movedBy(0, -100), Palette::White);
        
        // 상태 표시
        const String status = stopwatch.isRunning() ? U"▶ 실행 중" : U"⏸ 정지";
        Font{ 25 }(status).drawAt(Scene::Center().movedBy(0, -30), Palette::Yellow);
        
        // 랩 타임 목록
        Font{ 25 }(U"랩 타임 기록").draw(50, 350, Palette::Skyblue);
        
        const int32 maxDisplay = 5;
        const int32 startIndex = Math::Max(0, static_cast<int32>(lapTimes.size()) - maxDisplay);
        
        for (int32 i = startIndex; i < static_cast<int32>(lapTimes.size()); ++i)
        {
            const int32 lapNumber = i + 1;
            const double lapTime = lapTimes[i];
            const double prevTime = (i > 0) ? lapTimes[i - 1] : 0.0;
            const double splitTime = lapTime - prevTime;
            
            const int32 yPos = 390 + (i - startIndex) * 35;
            
            Font{ 20 }(U"#{}: {:.2f}초 (구간: {:.2f}초)"_fmt(
                lapNumber, lapTime, splitTime))
                .draw(70, yPos, Palette::White);
        }
        
        if (lapTimes.size() > maxDisplay)
        {
            Font{ 16 }(U"... 그 외 {} 개"_fmt(lapTimes.size() - maxDisplay))
                .draw(70, 570, Palette::Gray);
        }
    }
}
```

스톱워치는 운동 기록, 게임 플레이 시간 측정, 작업 시간 추적 등에 활용할 수 있다.

### 21.5.3 간격 타이머

일정 간격마다 이벤트를 발생시키는 타이머를 만들어보자.

```cpp
# include <Siv3D.hpp>

class IntervalTimer
{
public:
    IntervalTimer(double interval)
        : m_interval{ interval }
        , m_elapsed{ 0.0 }
    {
    }
    
    bool update()
    {
        m_elapsed += Scene::DeltaTime();
        
        if (m_elapsed >= m_interval)
        {
            m_elapsed -= m_interval;
            return true; // 간격 도달
        }
        
        return false;
    }
    
    void reset()
    {
        m_elapsed = 0.0;
    }
    
    double getProgress() const
    {
        return m_elapsed / m_interval;
    }
    
    void setInterval(double interval)
    {
        m_interval = interval;
    }
    
private:
    double m_interval;
    double m_elapsed;
};

void Main()
{
    IntervalTimer spawnTimer{ 1.0 }; // 1초마다
    IntervalTimer animationTimer{ 0.1 }; // 0.1초마다
    
    struct Enemy
    {
        Vec2 pos;
        double speed;
        int32 frame;
    };
    
    Array<Enemy> enemies;
    int32 spawnCount = 0;
    
    while (System::Update())
    {
        // 적 생성
        if (spawnTimer.update())
        {
            Enemy enemy;
            enemy.pos = Vec2{ 800, Random(100.0, 500.0) };
            enemy.speed = Random(50.0, 150.0);
            enemy.frame = 0;
            
            enemies.push_back(enemy);
            ++spawnCount;
        }
        
        // 애니메이션 프레임 업데이트
        const bool frameChanged = animationTimer.update();
        
        // 적 업데이트
        for (auto& enemy : enemies)
        {
            enemy.pos.x -= enemy.speed * Scene::DeltaTime();
            
            if (frameChanged)
            {
                enemy.frame = (enemy.frame + 1) % 4;
            }
        }
        
        // 화면 밖 적 제거
        enemies.remove_if([](const Enemy& e) { return e.pos.x < -50; });
        
        // 적 그리기
        for (const auto& enemy : enemies)
        {
            // 간단한 애니메이션 (4프레임)
            const double offset = (enemy.frame % 2) * 10 - 5;
            
            Circle{ enemy.pos.x, enemy.pos.y + offset, 20 }
                .draw(HSV{ enemy.speed * 2, 0.8, 1.0 });
            
            Circle{ enemy.pos.x - 10, enemy.pos.y - 5, 5 }
                .draw(Palette::White); // 눈
            Circle{ enemy.pos.x + 10, enemy.pos.y - 5, 5 }
                .draw(Palette::White);
        }
        
        // UI
        Font{ 25 }(U"생성된 적: {}"_fmt(spawnCount))
            .draw(20, 20, Palette::White);
        
        Font{ 25 }(U"현재 적: {}"_fmt(enemies.size()))
            .draw(20, 60, Palette::Yellow);
        
        // 다음 스폰까지 진행 바
        const double spawnProgress = spawnTimer.getProgress();
        Rect{ 20, 100, static_cast<int32>(200 * spawnProgress), 20 }
            .draw(Palette::Green);
        Rect{ 20, 100, 200, 20 }.drawFrame(2, Palette::White);
        
        Font{ 16 }(U"다음 스폰").draw(20, 130, Palette::Gray);
    }
}
```

간격 타이머는 적 생성, 아이템 드롭, 주기적인 이벤트 등에 활용된다. 여러 개의 타이머를 조합하면 복잡한 타이밍을 관리할 수 있다.

### 21.5.4 프레임 카운터

특정 프레임 수마다 이벤트를 발생시키는 카운터를 만들어보자.

```cpp
# include <Siv3D.hpp>

class FrameCounter
{
public:
    FrameCounter(int32 interval)
        : m_interval{ interval }
        , m_count{ 0 }
    {
    }
    
    bool update()
    {
        ++m_count;
        
        if (m_count >= m_interval)
        {
            m_count = 0;
            return true;
        }
        
        return false;
    }
    
    void reset()
    {
        m_count = 0;
    }
    
    int32 getCount() const
    {
        return m_count;
    }
    
    double getProgress() const
    {
        return static_cast<double>(m_count) / m_interval;
    }
    
private:
    int32 m_interval;
    int32 m_count;
};

void Main()
{
    FrameCounter slowCounter{ 60 }; // 60프레임(약 1초)마다
    FrameCounter fastCounter{ 10 }; // 10프레임마다
    
    int32 slowEvents = 0;
    int32 fastEvents = 0;
    
    Array<Vec2> particles;
    
    while (System::Update())
    {
        // 느린 카운터
        if (slowCounter.update())
        {
            ++slowEvents;
        }
        
        // 빠른 카운터
        if (fastCounter.update())
        {
            ++fastEvents;
            
            // 파티클 생성
            particles.push_back(Vec2{ Random(100.0, 700.0), 0 });
        }
        
        // 파티클 업데이트
        for (auto& particle : particles)
        {
            particle.y += 200.0 * Scene::DeltaTime();
        }
        
        // 화면 밖 파티클 제거
        particles.remove_if([](const Vec2& p) { return p.y > 650; });
        
        // 파티클 그리기
        for (const auto& particle : particles)
        {
            Circle{ particle, 8 }.draw(Palette::Yellow);
        }
        
        // 카운터 정보
        Font{ 25 }(U"느린 이벤트 (60프레임): {}"_fmt(slowEvents))
            .draw(20, 20, Palette::White);
        
        Font{ 25 }(U"빠른 이벤트 (10프레임): {}"_fmt(fastEvents))
            .draw(20, 60, Palette::Yellow);
        
        Font{ 25 }(U"활성 파티클: {}"_fmt(particles.size()))
            .draw(20, 100, Palette::Skyblue);
        
        // 진행 바
        const double slowProgress = slowCounter.getProgress();
        Rect{ 20, 150, static_cast<int32>(300 * slowProgress), 20 }
            .draw(Palette::Green);
        Rect{ 20, 150, 300, 20 }.drawFrame(2, Palette::White);
        Font{ 16 }(U"느린 카운터").draw(20, 180, Palette::Gray);
        
        const double fastProgress = fastCounter.getProgress();
        Rect{ 20, 210, static_cast<int32>(300 * fastProgress), 20 }
            .draw(Palette::Orange);
        Rect{ 20, 210, 300, 20 }.drawFrame(2, Palette::White);
        Font{ 16 }(U"빠른 카운터").draw(20, 240, Palette::Gray);
    }
}
```

프레임 카운터는 델타 타임에 의존하지 않으므로, 정확히 일정한 프레임 간격으로 이벤트를 발생시킬 수 있다. 애니메이션 프레임 전환, 게임 로직 업데이트 등에 유용하다.

## 21.6 실습 문제

### 문제 1: 애니메이션 컬렉션

다양한 이징 함수를 시각적으로 비교할 수 있는 도구를 만들어보자.

**요구사항:**
1. 여러 이징 함수를 동시에 표시한다
2. 각 이징 함수의 이름과 그래프를 보여준다
3. 애니메이션 속도를 조절할 수 있다
4. 특정 이징 함수를 선택하여 자세히 볼 수 있다
5. 커스텀 베지어 곡선으로 이징 함수를 만들 수 있다

**힌트:**
```cpp
// 베지어 곡선 이징
double CubicBezier(double t, double p1, double p2)
{
    const double u = 1.0 - t;
    return 3.0 * u * u * t * p1 + 3.0 * u * t * t * p2 + t * t * t;
}
```

### 문제 2: 스킬 쿨다운 시스템

게임의 스킬 쿨다운을 관리하는 시스템을 만들어보자.

**요구사항:**
1. 여러 개의 스킬을 관리한다 (각각 다른 쿨다운 시간)
2. 스킬 사용 시 쿨다운이 시작된다
3. 쿨다운 중에는 스킬을 사용할 수 없다
4. 남은 쿨다운 시간을 원형 진행 바로 표시한다
5. 쿨다운이 끝나면 시각적 효과로 알려준다

**힌트:**
```cpp
class Skill
{
    String name;
    double cooldown;
    double remaining;
    bool isReady() const { return remaining <= 0.0; }
    void use() { if (isReady()) remaining = cooldown; }
};
```

### 문제 3: 타이핑 애니메이션

텍스트가 한 글자씩 나타나는 타이핑 효과를 만들어보자.

**요구사항:**
1. 긴 텍스트를 한 글자씩 표시한다
2. 타이핑 속도를 조절할 수 있다
3. 구두점(쉼표, 마침표)에서는 잠시 멈춘다
4. 전체 텍스트를 즉시 표시하는 스킵 기능이 있다
5. 커서 깜빡임 효과를 추가한다

**힌트:**
```cpp
class TypeWriter
{
    String fullText;
    size_t currentIndex = 0;
    double charTimer = 0.0;
    double charInterval = 0.05; // 글자당 0.05초
    
    String getCurrentText() const
    {
        return fullText.substr(0, currentIndex);
    }
};
```

## 21.7 심화 내용

### 21.7.1 스프링 애니메이션

물리 기반 스프링 시뮬레이션으로 자연스러운 애니메이션을 만들 수 있다.

```cpp
# include <Siv3D.hpp>

class SpringAnimation
{
public:
    SpringAnimation(double stiffness = 100.0, double damping = 10.0)
        : m_current{ 0.0 }
        , m_target{ 0.0 }
        , m_velocity{ 0.0 }
        , m_stiffness{ stiffness }
        , m_damping{ damping }
    {
    }
    
    void setTarget(double target)
    {
        m_target = target;
    }
    
    void update(double deltaTime)
    {
        const double displacement = m_current - m_target;
        const double springForce = -m_stiffness * displacement;
        const double dampingForce = -m_damping * m_velocity;
        const double acceleration = springForce + dampingForce;
        
        m_velocity += acceleration * deltaTime;
        m_current += m_velocity * deltaTime;
    }
    
    double getValue() const
    {
        return m_current;
    }
    
    void setValue(double value)
    {
        m_current = value;
        m_velocity = 0.0;
    }
    
private:
    double m_current;
    double m_target;
    double m_velocity;
    double m_stiffness;
    double m_damping;
};

void Main()
{
    SpringAnimation spring{ 100.0, 10.0 };
    spring.setValue(100.0);
    
    double targetY = 100.0;
    
    while (System::Update())
    {
        // 마우스 클릭 위치로 타겟 설정
        if (MouseL.down())
        {
            targetY = Cursor::Pos().y;
            spring.setTarget(targetY);
        }
        
        spring.update(Scene::DeltaTime());
        
        const double currentY = spring.getValue();
        
        // 타겟 위치 표시
        Circle{ 400, targetY, 30 }.drawFrame(3, Palette::Gray);
        Font{ 18 }(U"Target").drawAt(400, targetY, Palette::Gray);
        
        // 현재 위치
        Circle{ 400, currentY, 40 }.draw(Palette::Orange);
        
        // 속도 벡터 표시
        Line{ 400, currentY, 400, currentY + spring.m_velocity * 0.1 }
            .draw(3, Palette::Yellow);
        
        Font{ 20 }(U"클릭하여 타겟 설정").draw(20, 20, Palette::White);
        Font{ 18 }(U"현재 Y: {:.1f}"_fmt(currentY)).draw(20, 60, Palette::Yellow);
        Font{ 18 }(U"타겟 Y: {:.1f}"_fmt(targetY)).draw(20, 90, Palette::Gray);
    }
}
```

스프링 애니메이션은 UI의 자연스러운 움직임, 카메라 추적, 물리 시뮬레이션 등에 활용된다.

### 21.7.2 키프레임 애니메이션 시스템

복잡한 다단계 애니메이션을 키프레임으로 관리할 수 있다.

```cpp
# include <Siv3D.hpp>

template<typename T>
struct Keyframe
{
    double time;
    T value;
    std::function<double(double)> easing;
};

template<typename T>
class KeyframeAnimation
{
public:
    void addKeyframe(double time, const T& value, std::function<double(double)> easing = [](double t) { return t; })
    {
        m_keyframes.push_back({ time, value, easing });
        
        // 시간 순으로 정렬
        m_keyframes.sort_by([](const Keyframe<T>& a, const Keyframe<T>& b) {
            return a.time < b.time;
        });
    }
    
    T getValue(double time) const
    {
        if (m_keyframes.empty())
            return T{};
        
        if (time <= m_keyframes.front().time)
            return m_keyframes.front().value;
        
        if (time >= m_keyframes.back().time)
            return m_keyframes.back().value;
        
        // 현재 시간이 속한 구간 찾기
        for (size_t i = 0; i < m_keyframes.size() - 1; ++i)
        {
            const auto& keyA = m_keyframes[i];
            const auto& keyB = m_keyframes[i + 1];
            
            if (time >= keyA.time && time <= keyB.time)
            {
                const double duration = keyB.time - keyA.time;
                const double localTime = time - keyA.time;
                const double t = localTime / duration;
                const double easedT = keyB.easing(t);
                
                return Lerp(keyA.value, keyB.value, easedT);
            }
        }
        
        return m_keyframes.back().value;
    }
    
    double getDuration() const
    {
        return m_keyframes.empty() ? 0.0 : m_keyframes.back().time;
    }
    
private:
    Array<Keyframe<T>> m_keyframes;
    
    static T Lerp(const T& a, const T& b, double t)
    {
        if constexpr (std::is_same_v<T, Vec2>)
            return a.lerp(b, t);
        else if constexpr (std::is_same_v<T, ColorF>)
            return a.lerp(b, t);
        else
            return static_cast<T>(a + (b - a) * t);
    }
};

void Main()
{
    // 위치 애니메이션
    KeyframeAnimation<Vec2> posAnim;
    posAnim.addKeyframe(0.0, Vec2{ 100, 300 }, EaseOutQuad);
    posAnim.addKeyframe(1.0, Vec2{ 400, 100 }, EaseInOutQuad);
    posAnim.addKeyframe(2.0, Vec2{ 700, 300 }, EaseOutBounce);
    posAnim.addKeyframe(3.0, Vec2{ 400, 500 }, EaseInBack);
    posAnim.addKeyframe(4.0, Vec2{ 100, 300 }, EaseOutQuad);
    
    // 색상 애니메이션
    KeyframeAnimation<ColorF> colorAnim;
    colorAnim.addKeyframe(0.0, ColorF{ 1.0, 0.0, 0.0 });
    colorAnim.addKeyframe(1.0, ColorF{ 1.0, 1.0, 0.0 });
    colorAnim.addKeyframe(2.0, ColorF{ 0.0, 1.0, 0.0 });
    colorAnim.addKeyframe(3.0, ColorF{ 0.0, 0.0, 1.0 });
    colorAnim.addKeyframe(4.0, ColorF{ 1.0, 0.0, 0.0 });
    
    // 크기 애니메이션
    KeyframeAnimation<double> scaleAnim;
    scaleAnim.addKeyframe(0.0, 1.0, EaseInQuad);
    scaleAnim.addKeyframe(1.5, 2.0, EaseOutElastic);
    scaleAnim.addKeyframe(3.0, 0.5, EaseInBack);
    scaleAnim.addKeyframe(4.0, 1.0, EaseOutQuad);
    
    double animTime = 0.0;
    bool isPlaying = true;
    
    while (System::Update())
    {
        if (SimpleGUI::Button(U"재생/일시정지", Vec2{ 20, 20 }))
        {
            isPlaying = !isPlaying;
        }
        
        if (SimpleGUI::Button(U"리셋", Vec2{ 180, 20 }))
        {
            animTime = 0.0;
        }
        
        if (isPlaying)
        {
            animTime += Scene::DeltaTime();
            
            // 루프
            if (animTime > posAnim.getDuration())
            {
                animTime = 0.0;
            }
        }
        
        // 현재 값 가져오기
        const Vec2 pos = posAnim.getValue(animTime);
        const ColorF color = colorAnim.getValue(animTime);
        const double scale = scaleAnim.getValue(animTime);
        
        // 그리기
        Circle{ pos, 50 * scale }.draw(color);
        
        // 타임라인 표시
        const Rect timeline{ 50, 500, 700, 60 };
        timeline.draw(Palette::Gray);
        
        const double progress = animTime / posAnim.getDuration();
        const int32 markerX = 50 + static_cast<int32>(700 * progress);
        Line{ markerX, 500, markerX, 560 }.draw(3, Palette::Yellow);
        
        Font{ 18 }(U"시간: {:.2f}초"_fmt(animTime))
            .draw(50, 470, Palette::White);
    }
}
```

키프레임 애니메이션은 복잡한 모션 그래픽이나 컷신 제작에 필수적이다.

### 21.7.3 타임라인 시스템

여러 애니메이션을 동기화하는 타임라인 시스템을 구현할 수 있다.

```cpp
# include <Siv3D.hpp>

class Timeline
{
public:
    struct Event
    {
        double time;
        std::function<void()> callback;
    };
    
    void addEvent(double time, std::function<void()> callback)
    {
        m_events.push_back({ time, callback });
        m_events.sort_by([](const Event& a, const Event& b) {
            return a.time < b.time;
        });
    }
    
    void update(double currentTime)
    {
        while (!m_events.empty() && m_events.front().time <= currentTime)
        {
            m_events.front().callback();
            m_events.pop_front();
        }
    }
    
    void reset()
    {
        m_processedEvents.clear();
        m_currentEventIndex = 0;
    }
    
private:
    Array<Event> m_events;
    HashSet<size_t> m_processedEvents;
    size_t m_currentEventIndex = 0;
};

void Main()
{
    Timeline timeline;
    
    // 이벤트 등록
    timeline.addEvent(0.5, []() { Print << U"0.5초: 시작!"; });
    timeline.addEvent(1.0, []() { Print << U"1.0초: 첫 번째 이벤트"; });
    timeline.addEvent(2.0, []() { Print << U"2.0초: 두 번째 이벤트"; });
    timeline.addEvent(3.0, []() { Print << U"3.0초: 세 번째 이벤트"; });
    timeline.addEvent(4.0, []() { Print << U"4.0초: 완료!"; });
    
    double time = 0.0;
    bool isPlaying = false;
    
    while (System::Update())
    {
        if (SimpleGUI::Button(U"재생", Vec2{ 20, 20 }))
        {
            isPlaying = true;
            time = 0.0;
            timeline.reset();
            ClearPrint();
        }
        
        if (isPlaying)
        {
            time += Scene::DeltaTime();
            timeline.update(time);
            
            if (time > 4.5)
            {
                isPlaying = false;
            }
        }
        
        Font{ 25 }(U"현재 시간: {:.2f}초"_fmt(time))
            .draw(20, 80, Palette::White);
    }
}
```

타임라인은 컷신, 튜토리얼, 스크립트 이벤트 등을 관리할 때 유용하다.

## 21.8 정리

이번 장에서는 시간 관리와 애니메이션의 핵심 개념을 배웠다. `std::chrono`의 타입 안전한 시간 처리부터, Siv3D의 편리한 시간 API, 다양한 이징 함수, 그리고 실용적인 타이머 구현까지 다루었다.

**핵심 요점:**

1. `Scene::DeltaTime()`을 사용하여 프레임레이트에 독립적인 애니메이션을 만든다.

2. 이징 함수는 선형 보간에 가속도를 더하여 자연스러운 움직임을 만든다.

3. 타이머와 카운터는 게임의 다양한 타이밍을 관리하는 필수 도구다.

4. Modern C++의 람다, `std::function`, 템플릿을 활용하면 유연하고 재사용 가능한 애니메이션 시스템을 만들 수 있다.

5. 물리 기반 애니메이션(스프링)과 키프레임 시스템으로 더욱 정교한 움직임을 구현할 수 있다.

시간 관리와 애니메이션은 모든 인터랙티브 애플리케이션의 기반이다. 다음 장에서는 사운드와 음악을 다루어 청각적 피드백을 추가하는 방법을 배운다.


