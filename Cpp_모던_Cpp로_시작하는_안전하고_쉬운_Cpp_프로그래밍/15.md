# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 15: 상속과 다형성
객체지향 프로그래밍의 핵심 개념 중 하나인 상속(Inheritance)과 다형성(Polymorphism)을 이번 장에서 다룬다. 상속은 기존 클래스의 기능을 재사용하고 확장할 수 있게 해주며, 다형성은 하나의 인터페이스로 여러 타입의 객체를 다룰 수 있게 한다. Modern C++의 `override`, `final` 키워드를 활용하면 더욱 안전하고 명확한 코드를 작성할 수 있다.

## 15.1 상속의 기본 개념

### 15.1.1 상속이란?
상속은 기존 클래스(기본 클래스 또는 부모 클래스)의 특성을 물려받아 새로운 클래스(파생 클래스 또는 자식 클래스)를 만드는 메커니즘이다. 이를 통해 코드 재사용성이 높아지고 계층적 구조를 표현할 수 있다.

현실 세계의 예를 생각해보자. "동물"이라는 일반적인 개념이 있고, "개", "고양이", "새"는 모두 동물이다. 이들은 동물의 공통 특성(먹다, 움직이다)을 물려받으면서도 각자만의 고유한 특성(짖다, 야옹거리다, 날다)을 가진다.

```cpp
#include <iostream>
#include <string>

// 기본 클래스 (Base Class, Parent Class)
class Animal {
protected:
    std::string name_;
    int age_;
    
public:
    Animal(const std::string& name, int age) 
        : name_(name), age_(age) {
        std::cout << "Animal 생성자: " << name_ << "\n";
    }
    
    void Eat() const {
        std::cout << name_ << "이(가) 먹이를 먹는다.\n";
    }
    
    void Sleep() const {
        std::cout << name_ << "이(가) 잠을 잔다.\n";
    }
    
    virtual ~Animal() {
        std::cout << "Animal 소멸자: " << name_ << "\n";
    }
};

// 파생 클래스 (Derived Class, Child Class)
class Dog : public Animal {
private:
    std::string breed_;
    
public:
    Dog(const std::string& name, int age, const std::string& breed)
        : Animal(name, age), breed_(breed) {
        std::cout << "Dog 생성자: " << name_ << " (" << breed_ << ")\n";
    }
    
    void Bark() const {
        std::cout << name_ << "이(가) 짖는다: 멍멍!\n";
    }
    
    ~Dog() {
        std::cout << "Dog 소멸자: " << name_ << "\n";
    }
};

class Cat : public Animal {
private:
    bool isIndoor_;
    
public:
    Cat(const std::string& name, int age, bool isIndoor)
        : Animal(name, age), isIndoor_(isIndoor) {
        std::cout << "Cat 생성자: " << name_ << "\n";
    }
    
    void Meow() const {
        std::cout << name_ << "이(가) 운다: 야옹~\n";
    }
    
    ~Cat() {
        std::cout << "Cat 소멸자: " << name_ << "\n";
    }
};

int main() {
    std::cout << "=== Dog 객체 생성 ===\n";
    Dog myDog("멍멍이", 3, "진돗개");
    myDog.Eat();    // Animal에서 상속받은 함수
    myDog.Sleep();  // Animal에서 상속받은 함수
    myDog.Bark();   // Dog만의 고유 함수
    
    std::cout << "\n=== Cat 객체 생성 ===\n";
    Cat myCat("나비", 2, true);
    myCat.Eat();    // Animal에서 상속받은 함수
    myCat.Sleep();  // Animal에서 상속받은 함수
    myCat.Meow();   // Cat만의 고유 함수
    
    std::cout << "\n=== 프로그램 종료 ===\n";
    return 0;
}
```

**출력 결과:**
```
=== Dog 객체 생성 ===
Animal 생성자: 멍멍이
Dog 생성자: 멍멍이 (진돗개)
멍멍이이(가) 먹이를 먹는다.
멍멍이이(가) 잠을 잔다.
멍멍이이(가) 짖는다: 멍멍!

=== Cat 객체 생성 ===
Animal 생성자: 나비
Cat 생성자: 나비
나비이(가) 먹이를 먹는다.
나비이(가) 잠을 잔다.
나비이(가) 운다: 야옹~

=== 프로그램 종료 ===
Cat 소멸자: 나비
Animal 소멸자: 나비
Dog 소멸자: 멍멍이
Animal 소멸자: 멍멍이
```


### 15.1.2 상속의 구문

```cpp
class 파생클래스이름 : 접근지정자 기본클래스이름 {
    // 파생 클래스의 멤버들
};
```

가장 일반적인 형태는 `public` 상속이다.

```cpp
class Base {
    // 기본 클래스 내용
};

class Derived : public Base {
    // 파생 클래스 내용
};
```

### 15.1.3 생성자와 소멸자의 호출 순서
상속 관계에서 생성자와 소멸자는 특정 순서로 호출된다.

**생성 순서:**
1. 기본 클래스 생성자
2. 파생 클래스 멤버 변수 초기화
3. 파생 클래스 생성자 본문

**소멸 순서:**
1. 파생 클래스 소멸자
2. 파생 클래스 멤버 변수 소멸
3. 기본 클래스 소멸자

```cpp
#include <iostream>

class Base {
public:
    Base() { std::cout << "1. Base 생성자\n"; }
    ~Base() { std::cout << "4. Base 소멸자\n"; }
};

class Member {
public:
    Member() { std::cout << "2. Member 생성자\n"; }
    ~Member() { std::cout << "3. Member 소멸자\n"; }
};

class Derived : public Base {
private:
    Member member_;
    
public:
    Derived() { std::cout << "3. Derived 생성자\n"; }
    ~Derived() { std::cout << "2. Derived 소멸자\n"; }
};

int main() {
    std::cout << "=== 객체 생성 ===\n";
    Derived d;
    std::cout << "\n=== 객체 소멸 ===\n";
    return 0;
}
```

**출력 결과:**
```
=== 객체 생성 ===
1. Base 생성자
2. Member 생성자
3. Derived 생성자

=== 객체 소멸 ===
2. Derived 소멸자
3. Member 소멸자
4. Base 소멸자
```

### 15.1.4 파생 클래스에서 기본 클래스 생성자 호출
파생 클래스 생성자는 명시적으로 기본 클래스 생성자를 호출해야 한다.

```cpp
#include <iostream>
#include <string>

class Person {
protected:
    std::string name_;
    int age_;
    
public:
    Person(const std::string& name, int age)
        : name_(name), age_(age) {
        std::cout << "Person 생성: " << name_ << ", " << age_ << "세\n";
    }
    
    virtual ~Person() = default;
    
    void Introduce() const {
        std::cout << "안녕하세요, 저는 " << name_ << "이고 ";
        std::cout << age_ << "세입니다.\n";
    }
};

class Student : public Person {
private:
    std::string school_;
    int grade_;
    
public:
    // 기본 클래스 생성자를 명시적으로 호출
    Student(const std::string& name, int age, const std::string& school, int grade)
        : Person(name, age),  // 기본 클래스 생성자 호출
          school_(school),
          grade_(grade) {
        std::cout << "Student 생성: " << school_ << " " << grade_ << "학년\n";
    }
    
    void Study() const {
        std::cout << name_ << "이(가) " << school_ << "에서 공부한다.\n";
    }
};

int main() {
    Student student("김철수", 16, "서울고등학교", 1);
    student.Introduce();
    student.Study();
    
    return 0;
}
```
  

</br>  
</br>  
  

## 15.2 `public`, `protected`, `private` 상속

### 15.2.1 접근 지정자의 의미
기본 클래스의 멤버를 파생 클래스에서 어떻게 접근할 수 있는지는 접근 지정자에 따라 달라진다.

**기본 클래스의 접근 지정자:**
- `public`: 클래스 외부에서 접근 가능
- `protected`: 파생 클래스에서만 접근 가능
- `private`: 클래스 내부에서만 접근 가능

```cpp
#include <iostream>

class Base {
public:
    int publicMember_;
    
protected:
    int protectedMember_;
    
private:
    int privateMember_;
    
public:
    Base() : publicMember_(1), protectedMember_(2), privateMember_(3) {}
    
    void ShowMembers() const {
        std::cout << "Base 클래스 내부에서:\n";
        std::cout << "  public: " << publicMember_ << "\n";
        std::cout << "  protected: " << protectedMember_ << "\n";
        std::cout << "  private: " << privateMember_ << "\n";
    }
};

class Derived : public Base {
public:
    void AccessMembers() {
        std::cout << "Derived 클래스에서:\n";
        std::cout << "  public: " << publicMember_ << " (접근 가능)\n";
        std::cout << "  protected: " << protectedMember_ << " (접근 가능)\n";
        // std::cout << privateMember_;  // 오류! private 멤버는 접근 불가
    }
};

int main() {
    Derived d;
    
    std::cout << "외부에서:\n";
    std::cout << "  public: " << d.publicMember_ << " (접근 가능)\n";
    // std::cout << d.protectedMember_;  // 오류! protected는 외부에서 접근 불가
    // std::cout << d.privateMember_;    // 오류! private는 외부에서 접근 불가
    
    std::cout << "\n";
    d.ShowMembers();
    
    std::cout << "\n";
    d.AccessMembers();
    
    return 0;
}
```

### 15.2.2 상속 방식에 따른 접근 권한 변화
상속 시 사용하는 접근 지정자에 따라 기본 클래스 멤버의 접근 권한이 달라진다.

**`public` 상속 (가장 일반적):**
- 기본 클래스의 `public` → 파생 클래스의 `public`
- 기본 클래스의 `protected` → 파생 클래스의 `protected`
- 기본 클래스의 `private` → 접근 불가

**`protected` 상속:**
- 기본 클래스의 `public` → 파생 클래스의 `protected`
- 기본 클래스의 `protected` → 파생 클래스의 `protected`
- 기본 클래스의 `private` → 접근 불가

**`private` 상속:**
- 기본 클래스의 `public` → 파생 클래스의 `private`
- 기본 클래스의 `protected` → 파생 클래스의 `private`
- 기본 클래스의 `private` → 접근 불가

```cpp
#include <iostream>

class Base {
public:
    void PublicFunc() { std::cout << "Base::PublicFunc()\n"; }
protected:
    void ProtectedFunc() { std::cout << "Base::ProtectedFunc()\n"; }
private:
    void PrivateFunc() { std::cout << "Base::PrivateFunc()\n"; }
};

// public 상속
class PublicDerived : public Base {
public:
    void Test() {
        PublicFunc();      // OK
        ProtectedFunc();   // OK
        // PrivateFunc();  // 오류!
    }
};

// protected 상속
class ProtectedDerived : protected Base {
public:
    void Test() {
        PublicFunc();      // OK (하지만 이제 protected)
        ProtectedFunc();   // OK
    }
};

// private 상속
class PrivateDerived : private Base {
public:
    void Test() {
        PublicFunc();      // OK (하지만 이제 private)
        ProtectedFunc();   // OK (하지만 이제 private)
    }
};

int main() {
    PublicDerived pd;
    pd.PublicFunc();  // OK: public 상속이므로 public으로 유지
    
    ProtectedDerived prd;
    // prd.PublicFunc();  // 오류! protected 상속으로 protected가 됨
    
    PrivateDerived pvd;
    // pvd.PublicFunc();  // 오류! private 상속으로 private가 됨
    
    return 0;
}
```

**Modern C++ 권장사항:** 대부분의 경우 `public` 상속을 사용한다. `protected`나 `private` 상속은 특수한 경우에만 사용하며, 일반적인 "is-a" 관계를 표현할 때는 항상 `public` 상속을 사용한다.

### 15.2.3 실용적인 예제: 게임 캐릭터 계층

```cpp
#include <iostream>
#include <string>

class Character {
protected:
    std::string name_;
    int health_;
    int maxHealth_;
    int level_;
    
public:
    Character(const std::string& name, int maxHealth, int level)
        : name_(name), 
          health_(maxHealth), 
          maxHealth_(maxHealth), 
          level_(level) {
    }
    
    virtual ~Character() = default;
    
    void TakeDamage(int damage) {
        health_ -= damage;
        if (health_ < 0) health_ = 0;
        std::cout << name_ << "이(가) " << damage << "의 피해를 입었다. ";
        std::cout << "남은 체력: " << health_ << "/" << maxHealth_ << "\n";
    }
    
    void Heal(int amount) {
        health_ += amount;
        if (health_ > maxHealth_) health_ = maxHealth_;
        std::cout << name_ << "이(가) " << amount << "만큼 회복했다. ";
        std::cout << "현재 체력: " << health_ << "/" << maxHealth_ << "\n";
    }
    
    bool IsAlive() const {
        return health_ > 0;
    }
    
    void DisplayStatus() const {
        std::cout << "[" << name_ << "] ";
        std::cout << "레벨: " << level_ << ", ";
        std::cout << "체력: " << health_ << "/" << maxHealth_ << "\n";
    }
};

class Warrior : public Character {
private:
    int stamina_;
    
public:
    Warrior(const std::string& name, int level)
        : Character(name, 150 + level * 20, level),
          stamina_(100) {
    }
    
    void PowerAttack() {
        if (stamina_ >= 30) {
            stamina_ -= 30;
            std::cout << name_ << "이(가) 강력한 공격을 시전했다! ";
            std::cout << "(스태미나: " << stamina_ << ")\n";
        } else {
            std::cout << name_ << "의 스태미나가 부족하다.\n";
        }
    }
    
    void DefensiveStance() {
        std::cout << name_ << "이(가) 방어 태세를 취했다.\n";
    }
};

class Mage : public Character {
private:
    int mana_;
    
public:
    Mage(const std::string& name, int level)
        : Character(name, 80 + level * 10, level),
          mana_(200 + level * 15) {
    }
    
    void CastFireball() {
        if (mana_ >= 50) {
            mana_ -= 50;
            std::cout << name_ << "이(가) 파이어볼을 시전했다! ";
            std::cout << "(마나: " << mana_ << ")\n";
        } else {
            std::cout << name_ << "의 마나가 부족하다.\n";
        }
    }
    
    void Meditate() {
        mana_ += 30;
        std::cout << name_ << "이(가) 명상하여 마나를 회복했다. ";
        std::cout << "(마나: " << mana_ << ")\n";
    }
};

int main() {
    Warrior warrior("전사", 5);
    Mage mage("마법사", 5);
    
    std::cout << "=== 초기 상태 ===\n";
    warrior.DisplayStatus();
    mage.DisplayStatus();
    
    std::cout << "\n=== 전투 시작 ===\n";
    warrior.PowerAttack();
    mage.CastFireball();
    
    std::cout << "\n=== 피해 입음 ===\n";
    warrior.TakeDamage(50);
    mage.TakeDamage(30);
    
    std::cout << "\n=== 회복 ===\n";
    warrior.Heal(20);
    mage.Meditate();
    
    std::cout << "\n=== 최종 상태 ===\n";
    warrior.DisplayStatus();
    mage.DisplayStatus();
    
    return 0;
}
``` 
   

</br>  
</br>  
  

## 15.3 가상 함수와 `virtual` 키워드

### 15.3.1 다형성의 필요성
다형성(Polymorphism)은 하나의 인터페이스로 여러 타입을 다룰 수 있게 해준다. 하지만 일반 함수로는 진정한 다형성을 구현할 수 없다.

```cpp
#include <iostream>
#include <string>

class Shape {
protected:
    std::string name_;
    
public:
    Shape(const std::string& name) : name_(name) {}
    
    // 가상 함수가 아닌 일반 함수
    void Draw() const {
        std::cout << "Shape을 그린다.\n";
    }
};

class Circle : public Shape {
public:
    Circle() : Shape("Circle") {}
    
    void Draw() const {
        std::cout << "○ 원을 그린다.\n";
    }
};

class Rectangle : public Shape {
public:
    Rectangle() : Shape("Rectangle") {}
    
    void Draw() const {
        std::cout << "□ 사각형을 그린다.\n";
    }
};

int main() {
    Circle circle;
    Rectangle rectangle;
    
    std::cout << "=== 직접 호출 ===\n";
    circle.Draw();      // Circle::Draw() 호출
    rectangle.Draw();   // Rectangle::Draw() 호출
    
    std::cout << "\n=== 포인터를 통한 호출 (문제 발생!) ===\n";
    Shape* shapes[2];
    shapes[0] = &circle;
    shapes[1] = &rectangle;
    
    for (int i = 0; i < 2; ++i) {
        shapes[i]->Draw();  // 모두 Shape::Draw() 호출! (원하는 동작 아님)
    }
    
    return 0;
}
```

**출력 결과:**
```
=== 직접 호출 ===
○ 원을 그린다.
□ 사각형을 그린다.

=== 포인터를 통한 호출 (문제 발생!) ===
Shape을 그린다.
Shape을 그린다.
```

기본 클래스 포인터로 파생 클래스 객체를 가리킬 때, 일반 함수는 컴파일 시간에 결정되므로(정적 바인딩) 항상 기본 클래스의 함수가 호출된다.

### 15.3.2 가상 함수의 도입
`virtual` 키워드를 사용하면 **동적 바인딩(Dynamic Binding)**이 가능해진다. 함수 호출이 실행 시간에 결정되어 실제 객체 타입에 맞는 함수가 호출된다.

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>

class Shape {
protected:
    std::string name_;
    
public:
    Shape(const std::string& name) : name_(name) {}
    
    // 가상 함수로 선언
    virtual void Draw() const {
        std::cout << "Shape을 그린다.\n";
    }
    
    virtual double GetArea() const {
        return 0.0;
    }
    
    // 가상 소멸자 (중요!)
    virtual ~Shape() {
        std::cout << name_ << " 소멸\n";
    }
    
    std::string GetName() const { return name_; }
};

class Circle : public Shape {
private:
    double radius_;
    
public:
    Circle(double radius) 
        : Shape("Circle"), radius_(radius) {}
    
    // 가상 함수 오버라이딩
    virtual void Draw() const {
        std::cout << "○ 반지름 " << radius_ << "인 원을 그린다.\n";
    }
    
    virtual double GetArea() const {
        return 3.14159 * radius_ * radius_;
    }
};

class Rectangle : public Shape {
private:
    double width_;
    double height_;
    
public:
    Rectangle(double width, double height)
        : Shape("Rectangle"), width_(width), height_(height) {}
    
    virtual void Draw() const {
        std::cout << "□ " << width_ << "x" << height_ << " 사각형을 그린다.\n";
    }
    
    virtual double GetArea() const {
        return width_ * height_;
    }
};

int main() {
    // 스마트 포인터를 사용한 다형성 (Modern C++)
    std::vector<std::unique_ptr<Shape>> shapes;
    
    shapes.push_back(std::make_unique<Circle>(5.0));
    shapes.push_back(std::make_unique<Rectangle>(4.0, 6.0));
    shapes.push_back(std::make_unique<Circle>(3.0));
    
    std::cout << "=== 모든 도형 그리기 ===\n";
    for (const auto& shape : shapes) {
        shape->Draw();  // 각 객체의 실제 타입에 맞는 Draw() 호출!
        std::cout << "넓이: " << shape->GetArea() << "\n\n";
    }
    
    std::cout << "=== 프로그램 종료 (자동 소멸) ===\n";
    return 0;
}
```

**출력 결과:**
```
=== 모든 도형 그리기 ===
○ 반지름 5인 원을 그린다.
넓이: 78.5398

□ 4x6 사각형을 그린다.
넓이: 24

○ 반지름 3인 원을 그린다.
넓이: 28.2743

=== 프로그램 종료 (자동 소멸) ===
Circle 소멸
Rectangle 소멸
Circle 소멸
```

### 15.3.3 가상 소멸자의 중요성
기본 클래스의 소멸자는 **반드시 `virtual`로 선언**해야 한다. 그렇지 않으면 메모리 누수가 발생할 수 있다.

```cpp
#include <iostream>

class Base {
public:
    Base() { std::cout << "Base 생성자\n"; }
    
    // 가상 소멸자가 아님 (위험!)
    ~Base() { std::cout << "Base 소멸자\n"; }
};

class Derived : public Base {
private:
    int* data_;
    
public:
    Derived() : data_(new int[100]) {
        std::cout << "Derived 생성자 (메모리 할당)\n";
    }
    
    ~Derived() {
        std::cout << "Derived 소멸자 (메모리 해제)\n";
        delete[] data_;
    }
};

int main() {
    std::cout << "=== 문제 있는 코드 ===\n";
    Base* ptr = new Derived();
    delete ptr;  // Derived 소멸자가 호출되지 않음! 메모리 누수!
    
    return 0;
}
```

**출력 결과:**
```
=== 문제 있는 코드 ===
Base 생성자
Derived 생성자 (메모리 할당)
Base 소멸자
```

`Derived` 소멸자가 호출되지 않아 메모리가 해제되지 않았다!

**올바른 코드:**

```cpp
#include <iostream>

class Base {
public:
    Base() { std::cout << "Base 생성자\n"; }
    
    // 가상 소멸자로 선언
    virtual ~Base() { std::cout << "Base 소멸자\n"; }
};

class Derived : public Base {
private:
    int* data_;
    
public:
    Derived() : data_(new int[100]) {
        std::cout << "Derived 생성자 (메모리 할당)\n";
    }
    
    ~Derived() {
        std::cout << "Derived 소멸자 (메모리 해제)\n";
        delete[] data_;
    }
};

int main() {
    std::cout << "=== 올바른 코드 ===\n";
    Base* ptr = new Derived();
    delete ptr;  // Derived 소멸자가 올바르게 호출됨!
    
    return 0;
}
```

**출력 결과:**
```
=== 올바른 코드 ===
Base 생성자
Derived 생성자 (메모리 할당)
Derived 소멸자 (메모리 해제)
Base 소멸자
```

**Modern C++ 권장사항:** 상속을 사용하는 기본 클래스는 항상 가상 소멸자를 선언하거나, 상속을 금지하라 (`final` 키워드 사용).
  

</br>  
</br>  
    

## 15.4 `override`와 `final` 키워드 (C++11)

### 15.4.1 `override` - 명시적 오버라이딩
C++11부터 도입된 `override` 키워드는 함수가 기본 클래스의 가상 함수를 오버라이드하고 있음을 명시적으로 표시한다. 이는 실수를 방지하는 데 매우 유용하다.

```cpp
#include <iostream>

class Base {
public:
    virtual void Function1() const {
        std::cout << "Base::Function1()\n";
    }
    
    virtual void Function2(int value) {
        std::cout << "Base::Function2(" << value << ")\n";
    }
    
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    // override 키워드로 명시적 표시
    void Function1() const override {
        std::cout << "Derived::Function1()\n";
    }
    
    // 실수: 매개변수 타입이 다름
    // void Function2(double value) override {  // 컴파일 오류! 오버라이드할 함수가 없음
    //     std::cout << "Derived::Function2(" << value << ")\n";
    // }
    
    // 올바른 오버라이드
    void Function2(int value) override {
        std::cout << "Derived::Function2(" << value << ")\n";
    }
};

int main() {
    Base* ptr = new Derived();
    ptr->Function1();
    ptr->Function2(42);
    delete ptr;
    
    return 0;
}
```

`override` 키워드가 없었다면, `Function2(double value)`를 새로운 함수로 간주하여 컴파일은 성공하지만 의도한 대로 동작하지 않았을 것이다.

**`override` 키워드의 장점:**
1. 오버라이드 의도를 명확히 표현
2. 기본 클래스 함수 시그니처 변경 시 컴파일 오류로 감지
3. 코드 가독성 향상
4. 리팩토링 시 안전성 증가

### 15.4.2 `final` - 오버라이딩 금지
`final` 키워드는 두 가지 용도로 사용된다:
1. 가상 함수의 추가 오버라이딩 금지
2. 클래스의 상속 금지

**가상 함수에 `final` 사용:**

```cpp
#include <iostream>

class Base {
public:
    virtual void NormalFunction() {
        std::cout << "Base::NormalFunction()\n";
    }
    
    virtual void FinalFunction() final {  // 더 이상 오버라이드 불가
        std::cout << "Base::FinalFunction()\n";
    }
    
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    void NormalFunction() override {  // OK
        std::cout << "Derived::NormalFunction()\n";
    }
    
    // void FinalFunction() override {  // 컴파일 오류! final 함수는 오버라이드 불가
    //     std::cout << "Derived::FinalFunction()\n";
    // }
};

int main() {
    Derived d;
    d.NormalFunction();
    d.FinalFunction();  // Base의 FinalFunction 호출
    
    return 0;
}
```

**클래스에 `final` 사용:**

```cpp
#include <iostream>

class FinalClass final {  // 이 클래스는 상속 불가
public:
    void DoSomething() {
        std::cout << "FinalClass::DoSomething()\n";
    }
};

// class Derived : public FinalClass {  // 컴파일 오류! final 클래스는 상속 불가
// };

int main() {
    FinalClass fc;
    fc.DoSomething();
    
    return 0;
}
```

### 15.4.3 실용적 예제: 게임 엔티티 시스템

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>

// 기본 엔티티 클래스
class Entity {
protected:
    std::string name_;
    double x_, y_;
    
public:
    Entity(const std::string& name, double x, double y)
        : name_(name), x_(x), y_(y) {}
    
    virtual ~Entity() = default;
    
    // 모든 엔티티가 구현해야 하는 인터페이스
    virtual void Update(double deltaTime) = 0;  // 순수 가상 함수 (다음 절에서 설명)
    virtual void Render() const = 0;
    
    // 위치 관련 함수
    virtual void Move(double dx, double dy) {
        x_ += dx;
        y_ += dy;
    }
    
    void GetPosition(double& x, double& y) const {
        x = x_;
        y = y_;
    }
    
    std::string GetName() const { return name_; }
};

// 플레이어 클래스
class Player final : public Entity {  // final: 더 이상 상속 불가
private:
    int health_;
    int score_;
    
public:
    Player(const std::string& name, double x, double y)
        : Entity(name, x, y), health_(100), score_(0) {}
    
    void Update(double deltaTime) override {
        // 플레이어 업데이트 로직
    }
    
    void Render() const override final {  // 함수를 final로 지정 (의미상 중복이지만 명시 가능)
        std::cout << "플레이어 [" << name_ << "] 렌더링 at (" << x_ << ", " << y_ << ")\n";
        std::cout << "  체력: " << health_ << ", 점수: " << score_ << "\n";
    }
    
    void TakeDamage(int damage) {
        health_ -= damage;
        std::cout << name_ << "이(가) " << damage << "의 피해를 입었다.\n";
    }
    
    void AddScore(int points) {
        score_ += points;
        std::cout << name_ << "이(가) " << points << "점을 획득했다.\n";
    }
};

// 적 기본 클래스
class Enemy : public Entity {
protected:
    int health_;
    
public:
    Enemy(const std::string& name, double x, double y, int health)
        : Entity(name, x, y), health_(health) {}
    
    virtual ~Enemy() = default;
    
    void Update(double deltaTime) override {
        // 기본 적 업데이트 로직
    }
    
    void Render() const override {
        std::cout << "적 [" << name_ << "] at (" << x_ << ", " << y_ << ")\n";
    }
    
    virtual void Attack() {  // 파생 클래스에서 오버라이드 가능
        std::cout << name_ << "이(가) 공격한다!\n";
    }
};

// 보스 적 클래스
class BossEnemy : public Enemy {
private:
    bool isEnraged_;
    
public:
    BossEnemy(const std::string& name, double x, double y)
        : Enemy(name, x, y, 500), isEnraged_(false) {}
    
    void Update(double deltaTime) override {
        Enemy::Update(deltaTime);  // 부모 클래스 함수 호출
        
        if (health_ < 100 && !isEnraged_) {
            isEnraged_ = true;
            std::cout << name_ << "이(가) 분노했다!\n";
        }
    }
    
    void Render() const override {
        std::cout << "보스 [" << name_ << "] at (" << x_ << ", " << y_ << ")";
        if (isEnraged_) std::cout << " (분노!)";
        std::cout << "\n";
    }
    
    void Attack() override final {  // final: 더 이상 오버라이드 불가
        if (isEnraged_) {
            std::cout << name_ << "이(가) 강력한 공격을 시전한다!!\n";
        } else {
            std::cout << name_ << "이(가) 공격한다.\n";
        }
    }
};

int main() {
    std::vector<std::unique_ptr<Entity>> entities;
    
    entities.push_back(std::make_unique<Player>("용사", 0, 0));
    entities.push_back(std::make_unique<Enemy>("고블린", 10, 5, 30));
    entities.push_back(std::make_unique<BossEnemy>("드래곤", 50, 50));
    
    std::cout << "=== 모든 엔티티 렌더링 ===\n";
    for (const auto& entity : entities) {
        entity->Render();  // 각 타입에 맞는 Render() 호출
    }
    
    std::cout << "\n=== 업데이트 ===\n";
    for (const auto& entity : entities) {
        entity->Update(0.016);  // 약 60 FPS
    }
    
    return 0;
}
```
  

## 15.5 순수 가상 함수와 추상 클래스

### 15.5.1 순수 가상 함수
**순수 가상 함수(Pure Virtual Function)**는 구현이 없는 가상 함수다. `= 0`을 붙여서 선언한다.

```cpp
class AbstractClass {
public:
    virtual void PureVirtualFunction() = 0;  // 순수 가상 함수
};
```

순수 가상 함수를 하나라도 포함하는 클래스는 **추상 클래스(Abstract Class)**가 되며, 직접 인스턴스화할 수 없다.

```cpp
#include <iostream>
#include <string>

// 추상 클래스
class Animal {
protected:
    std::string name_;
    
public:
    Animal(const std::string& name) : name_(name) {}
    
    virtual ~Animal() = default;
    
    // 순수 가상 함수: 모든 동물은 소리를 내야 함
    virtual void MakeSound() const = 0;
    
    // 순수 가상 함수: 모든 동물은 움직여야 함
    virtual void Move() const = 0;
    
    // 일반 함수: 모든 동물이 공유하는 구현
    void Eat() const {
        std::cout << name_ << "이(가) 먹이를 먹는다.\n";
    }
};

class Dog : public Animal {
public:
    Dog(const std::string& name) : Animal(name) {}
    
    void MakeSound() const override {
        std::cout << name_ << ": 멍멍!\n";
    }
    
    void Move() const override {
        std::cout << name_ << "이(가) 네 발로 달린다.\n";
    }
};

class Bird : public Animal {
public:
    Bird(const std::string& name) : Animal(name) {}
    
    void MakeSound() const override {
        std::cout << name_ << ": 짹짹!\n";
    }
    
    void Move() const override {
        std::cout << name_ << "이(가) 날아간다.\n";
    }
};

// 불완전한 파생 클래스: 여전히 추상 클래스
class IncompleteAnimal : public Animal {
public:
    IncompleteAnimal(const std::string& name) : Animal(name) {}
    
    void MakeSound() const override {
        std::cout << name_ << ": ???\n";
    }
    
    // Move()를 구현하지 않음 → 여전히 추상 클래스
};

int main() {
    // Animal animal("동물");  // 오류! 추상 클래스는 인스턴스화 불가
    // IncompleteAnimal ia("불완전");  // 오류! 여전히 추상 클래스
    
    Dog dog("멍멍이");
    Bird bird("짹짹이");
    
    std::cout << "=== 개 ===\n";
    dog.MakeSound();
    dog.Move();
    dog.Eat();
    
    std::cout << "\n=== 새 ===\n";
    bird.MakeSound();
    bird.Move();
    bird.Eat();
    
    std::cout << "\n=== 다형성 ===\n";
    Animal* animals[] = { &dog, &bird };
    for (int i = 0; i < 2; ++i) {
        animals[i]->MakeSound();
        animals[i]->Move();
    }
    
    return 0;
}
```

### 15.5.2 인터페이스 클래스
C++에는 Java나 C#의 `interface` 키워드가 없지만, 순수 가상 함수만으로 이루어진 클래스를 **인터페이스**로 사용할 수 있다.

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>

// 인터페이스: Drawable
class IDrawable {
public:
    virtual ~IDrawable() = default;
    virtual void Draw() const = 0;
};

// 인터페이스: Updatable
class IUpdatable {
public:
    virtual ~IUpdatable() = default;
    virtual void Update(double deltaTime) = 0;
};

// 인터페이스: Collidable
class ICollidable {
public:
    virtual ~ICollidable() = default;
    virtual bool CheckCollision(const ICollidable& other) const = 0;
    virtual void OnCollision(const ICollidable& other) = 0;
};

// 게임 오브젝트: 여러 인터페이스 구현
class GameObject : public IDrawable, public IUpdatable, public ICollidable {
protected:
    std::string name_;
    double x_, y_;
    double width_, height_;
    
public:
    GameObject(const std::string& name, double x, double y, double width, double height)
        : name_(name), x_(x), y_(y), width_(width), height_(height) {}
    
    virtual ~GameObject() = default;
    
    // IDrawable 구현
    void Draw() const override {
        std::cout << "[" << name_ << "] 그리기 at (" << x_ << ", " << y_ << ")\n";
    }
    
    // IUpdatable 구현
    void Update(double deltaTime) override {
        // 기본 업데이트 로직
    }
    
    // ICollidable 구현
    bool CheckCollision(const ICollidable& other) const override {
        // 간단한 충돌 감지 (실제로는 더 복잡)
        return false;
    }
    
    void OnCollision(const ICollidable& other) override {
        std::cout << name_ << "이(가) 충돌했다!\n";
    }
    
    std::string GetName() const { return name_; }
};

class Bullet : public GameObject {
private:
    double velocityX_, velocityY_;
    
public:
    Bullet(double x, double y)
        : GameObject("Bullet", x, y, 2, 2),
          velocityX_(10), velocityY_(0) {}
    
    void Update(double deltaTime) override {
        x_ += velocityX_ * deltaTime;
        y_ += velocityY_ * deltaTime;
    }
    
    void Draw() const override {
        std::cout << "• 총알 at (" << x_ << ", " << y_ << ")\n";
    }
};

class Enemy : public GameObject {
private:
    int health_;
    
public:
    Enemy(double x, double y)
        : GameObject("Enemy", x, y, 20, 20), health_(100) {}
    
    void Update(double deltaTime) override {
        // 적 AI 로직
        x_ -= 5 * deltaTime;  // 왼쪽으로 이동
    }
    
    void Draw() const override {
        std::cout << "👾 적 at (" << x_ << ", " << y_ << ") [체력: " << health_ << "]\n";
    }
    
    void TakeDamage(int damage) {
        health_ -= damage;
        if (health_ <= 0) {
            std::cout << "적이 파괴되었다!\n";
        }
    }
};

int main() {
    std::vector<std::unique_ptr<IDrawable>> drawables;
    std::vector<std::unique_ptr<IUpdatable>> updatables;
    
    auto bullet = std::make_unique<Bullet>(0, 10);
    auto enemy = std::make_unique<Enemy>(100, 10);
    
    std::cout << "=== 초기 렌더링 ===\n";
    bullet->Draw();
    enemy->Draw();
    
    std::cout << "\n=== 업데이트 (1초) ===\n";
    bullet->Update(1.0);
    enemy->Update(1.0);
    
    std::cout << "\n=== 업데이트 후 렌더링 ===\n";
    bullet->Draw();
    enemy->Draw();
    
    return 0;
}
```

**인터페이스 명명 규칙:** C++에서는 인터페이스 클래스 이름 앞에 `I`를 붙이는 것이 일반적이다 (예: `IDrawable`, `IUpdatable`).

### 15.5.3 추상 클래스 vs 인터페이스

| 특성 | 추상 클래스 | 인터페이스 |
|------|-------------|------------|
| 순수 가상 함수 | 일부 또는 전체 | 전체 |
| 일반 함수 | 가질 수 있음 | 없음 (관례상) |
| 멤버 변수 | 가질 수 있음 | 없음 (관례상) |
| 다중 상속 | 권장하지 않음 | 일반적 |
| 용도 | 공통 기능 공유 | 계약 정의 |
  

</br>  
</br>  
  
  
## 15.6 실습 예제: RPG 스킬 시스템
지금까지 배운 내용을 종합하여 RPG 게임의 스킬 시스템을 만들어보자.

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>

// 스킬 인터페이스
class ISkill {
public:
    virtual ~ISkill() = default;
    virtual std::string GetName() const = 0;
    virtual int GetManaCost() const = 0;
    virtual void Cast() = 0;
    virtual bool CanCast(int currentMana) const = 0;
};

// 기본 스킬 추상 클래스
class Skill : public ISkill {
protected:
    std::string name_;
    int manaCost_;
    int cooldown_;
    int currentCooldown_;
    
public:
    Skill(const std::string& name, int manaCost, int cooldown)
        : name_(name), manaCost_(manaCost), cooldown_(cooldown), currentCooldown_(0) {}
    
    virtual ~Skill() = default;
    
    std::string GetName() const override {
        return name_;
    }
    
    int GetManaCost() const override {
        return manaCost_;
    }
    
    bool CanCast(int currentMana) const override {
        return currentMana >= manaCost_ && currentCooldown_ == 0;
    }
    
    void Update() {
        if (currentCooldown_ > 0) {
            currentCooldown_--;
        }
    }
    
    // 순수 가상 함수: 각 스킬의 고유 효과
    void Cast() override = 0;
    
protected:
    void StartCooldown() {
        currentCooldown_ = cooldown_;
    }
};

// 공격 스킬
class AttackSkill : public Skill {
private:
    int damage_;
    
public:
    AttackSkill(const std::string& name, int manaCost, int cooldown, int damage)
        : Skill(name, manaCost, cooldown), damage_(damage) {}
    
    void Cast() override {
        std::cout << "💥 [" << name_ << "] " << damage_ << "의 피해를 입힌다!\n";
        StartCooldown();
    }
};

// 회복 스킬
class HealSkill : public Skill {
private:
    int healAmount_;
    
public:
    HealSkill(const std::string& name, int manaCost, int cooldown, int healAmount)
        : Skill(name, manaCost, cooldown), healAmount_(healAmount) {}
    
    void Cast() override {
        std::cout << "💚 [" << name_ << "] " << healAmount_ << "만큼 체력을 회복한다!\n";
        StartCooldown();
    }
};

// 버프 스킬
class BuffSkill final : public Skill {  // final: 더 이상 상속 불가
private:
    std::string buffType_;
    int duration_;
    
public:
    BuffSkill(const std::string& name, int manaCost, int cooldown,
              const std::string& buffType, int duration)
        : Skill(name, manaCost, cooldown), buffType_(buffType), duration_(duration) {}
    
    void Cast() override final {  // final: 더 이상 오버라이드 불가
        std::cout << "✨ [" << name_ << "] " << buffType_ << " 버프를 ";
        std::cout << duration_ << "초간 적용한다!\n";
        StartCooldown();
    }
};

// 캐릭터 클래스
class Character {
private:
    std::string name_;
    int health_;
    int maxHealth_;
    int mana_;
    int maxMana_;
    std::vector<std::unique_ptr<Skill>> skills_;
    
public:
    Character(const std::string& name, int maxHealth, int maxMana)
        : name_(name),
          health_(maxHealth),
          maxHealth_(maxHealth),
          mana_(maxMana),
          maxMana_(maxMana) {}
    
    void AddSkill(std::unique_ptr<Skill> skill) {
        skills_.push_back(std::move(skill));
    }
    
    void UseSkill(int index) {
        if (index < 0 || index >= skills_.size()) {
            std::cout << "잘못된 스킬 번호다.\n";
            return;
        }
        
        Skill* skill = skills_[index].get();
        
        if (!skill->CanCast(mana_)) {
            std::cout << "마나가 부족하거나 재사용 대기 중이다.\n";
            return;
        }
        
        mana_ -= skill->GetManaCost();
        skill->Cast();
        
        std::cout << "  (남은 마나: " << mana_ << "/" << maxMana_ << ")\n";
    }
    
    void UpdateSkills() {
        for (auto& skill : skills_) {
            skill->Update();
        }
    }
    
    void DisplaySkills() const {
        std::cout << "\n=== " << name_ << "의 스킬 목록 ===\n";
        for (size_t i = 0; i < skills_.size(); ++i) {
            std::cout << i << ". " << skills_[i]->GetName();
            std::cout << " (마나: " << skills_[i]->GetManaCost() << ")\n";
        }
    }
    
    void DisplayStatus() const {
        std::cout << "\n[" << name_ << "] ";
        std::cout << "체력: " << health_ << "/" << maxHealth_ << ", ";
        std::cout << "마나: " << mana_ << "/" << maxMana_ << "\n";
    }
    
    void RestoreMana(int amount) {
        mana_ += amount;
        if (mana_ > maxMana_) mana_ = maxMana_;
    }
};

int main() {
    Character mage("마법사", 100, 200);
    
    // 스킬 추가
    mage.AddSkill(std::make_unique<AttackSkill>("파이어볼", 30, 2, 50));
    mage.AddSkill(std::make_unique<AttackSkill>("라이트닝", 50, 3, 80));
    mage.AddSkill(std::make_unique<HealSkill>("힐", 40, 5, 60));
    mage.AddSkill(std::make_unique<BuffSkill>("마법 보호막", 25, 10, "방어력 증가", 30));
    
    mage.DisplayStatus();
    mage.DisplaySkills();
    
    std::cout << "\n=== 전투 시작 ===\n";
    
    // 턴 1
    std::cout << "\n--- 턴 1 ---\n";
    mage.UseSkill(0);  // 파이어볼
    
    // 턴 2
    std::cout << "\n--- 턴 2 ---\n";
    mage.UseSkill(1);  // 라이트닝
    mage.UpdateSkills();
    
    // 턴 3
    std::cout << "\n--- 턴 3 ---\n";
    mage.UseSkill(3);  // 버프
    mage.UpdateSkills();
    
    // 턴 4
    std::cout << "\n--- 턴 4 ---\n";
    mage.UseSkill(0);  // 파이어볼 (재사용 대기 중)
    mage.UpdateSkills();
    
    // 턴 5
    std::cout << "\n--- 턴 5 ---\n";
    mage.UseSkill(0);  // 파이어볼 (이제 사용 가능)
    mage.UseSkill(2);  // 힐
    
    mage.DisplayStatus();
    
    return 0;
}
```
  
  
</br>  
</br>      
  

## 15.7 연습 문제

### 문제 1: 도형 계층 구조
다양한 도형을 표현하는 클래스 계층 구조를 만들어라.

**요구사항:**
- `Shape` 추상 기본 클래스
  - 순수 가상 함수: `GetArea()`, `GetPerimeter()`, `Draw()`
- 파생 클래스: `Circle`, `Rectangle`, `Triangle`
- 각 도형의 넓이와 둘레를 계산하는 함수 구현
- `override` 키워드 사용

**해답:**

```cpp
#include <iostream>
#include <cmath>
#include <vector>
#include <memory>

// 추상 기본 클래스
class Shape {
protected:
    std::string name_;
    
public:
    Shape(const std::string& name) : name_(name) {}
    virtual ~Shape() = default;
    
    // 순수 가상 함수들
    virtual double GetArea() const = 0;
    virtual double GetPerimeter() const = 0;
    virtual void Draw() const = 0;
    
    std::string GetName() const { return name_; }
    
    void DisplayInfo() const {
        std::cout << "\n=== " << name_ << " ===\n";
        Draw();
        std::cout << "넓이: " << GetArea() << "\n";
        std::cout << "둘레: " << GetPerimeter() << "\n";
    }
};

// 원
class Circle final : public Shape {
private:
    double radius_;
    static constexpr double PI = 3.14159265359;
    
public:
    Circle(double radius) : Shape("원"), radius_(radius) {}
    
    double GetArea() const override {
        return PI * radius_ * radius_;
    }
    
    double GetPerimeter() const override {
        return 2 * PI * radius_;
    }
    
    void Draw() const override {
        std::cout << "○ 반지름: " << radius_ << "\n";
    }
};

// 직사각형
class Rectangle final : public Shape {
private:
    double width_;
    double height_;
    
public:
    Rectangle(double width, double height)
        : Shape("직사각형"), width_(width), height_(height) {}
    
    double GetArea() const override {
        return width_ * height_;
    }
    
    double GetPerimeter() const override {
        return 2 * (width_ + height_);
    }
    
    void Draw() const override {
        std::cout << "□ 가로: " << width_ << ", 세로: " << height_ << "\n";
    }
};

// 삼각형
class Triangle final : public Shape {
private:
    double side1_;
    double side2_;
    double side3_;
    
public:
    Triangle(double side1, double side2, double side3)
        : Shape("삼각형"), side1_(side1), side2_(side2), side3_(side3) {}
    
    double GetArea() const override {
        // 헤론의 공식
        double s = GetPerimeter() / 2.0;
        return std::sqrt(s * (s - side1_) * (s - side2_) * (s - side3_));
    }
    
    double GetPerimeter() const override {
        return side1_ + side2_ + side3_;
    }
    
    void Draw() const override {
        std::cout << "△ 변의 길이: " << side1_ << ", " << side2_ << ", " << side3_ << "\n";
    }
};

int main() {
    std::vector<std::unique_ptr<Shape>> shapes;
    
    shapes.push_back(std::make_unique<Circle>(5.0));
    shapes.push_back(std::make_unique<Rectangle>(4.0, 6.0));
    shapes.push_back(std::make_unique<Triangle>(3.0, 4.0, 5.0));
    
    double totalArea = 0.0;
    
    for (const auto& shape : shapes) {
        shape->DisplayInfo();
        totalArea += shape->GetArea();
    }
    
    std::cout << "\n총 넓이: " << totalArea << "\n";
    
    return 0;
}
```

### 문제 2: 차량 관리 시스템
다양한 종류의 차량을 관리하는 시스템을 만들어라.

**요구사항:**
- `Vehicle` 기본 클래스 (가상 소멸자 포함)
- `Car`, `Truck`, `Motorcycle` 파생 클래스
- 각 차량의 연료 효율 계산
- 다형성을 활용한 차량 목록 관리

**해답:**

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>

class Vehicle {
protected:
    std::string model_;
    int year_;
    double fuelCapacity_;
    double currentFuel_;
    
public:
    Vehicle(const std::string& model, int year, double fuelCapacity)
        : model_(model), year_(year), fuelCapacity_(fuelCapacity), currentFuel_(0) {}
    
    virtual ~Vehicle() {
        std::cout << model_ << " 차량 정보 삭제\n";
    }
    
    // 순수 가상 함수
    virtual double GetFuelEfficiency() const = 0;
    virtual std::string GetVehicleType() const = 0;
    
    void Refuel(double amount) {
        currentFuel_ += amount;
        if (currentFuel_ > fuelCapacity_) {
            currentFuel_ = fuelCapacity_;
        }
        std::cout << model_ << " 주유: " << amount << "L\n";
    }
    
    virtual void Drive(double distance) {
        double fuelNeeded = distance / GetFuelEfficiency();
        if (fuelNeeded <= currentFuel_) {
            currentFuel_ -= fuelNeeded;
            std::cout << model_ << "이(가) " << distance << "km 주행했다. ";
            std::cout << "(남은 연료: " << currentFuel_ << "L)\n";
        } else {
            std::cout << model_ << ": 연료가 부족하다!\n";
        }
    }
    
    void DisplayInfo() const {
        std::cout << "\n[" << GetVehicleType() << "] " << model_ << " (" << year_ << "년식)\n";
        std::cout << "연료: " << currentFuel_ << "/" << fuelCapacity_ << "L\n";
        std::cout << "연비: " << GetFuelEfficiency() << "km/L\n";
    }
};

class Car : public Vehicle {
private:
    int numDoors_;
    
public:
    Car(const std::string& model, int year, int numDoors)
        : Vehicle(model, year, 50.0), numDoors_(numDoors) {}
    
    double GetFuelEfficiency() const override {
        return 12.0;  // 12 km/L
    }
    
    std::string GetVehicleType() const override {
        return "승용차";
    }
};

class Truck : public Vehicle {
private:
    double cargoCapacity_;
    
public:
    Truck(const std::string& model, int year, double cargoCapacity)
        : Vehicle(model, year, 100.0), cargoCapacity_(cargoCapacity) {}
    
    double GetFuelEfficiency() const override {
        return 6.0;  // 6 km/L
    }
    
    std::string GetVehicleType() const override {
        return "트럭";
    }
    
    void Drive(double distance) override {
        std::cout << "화물을 싣고 ";
        Vehicle::Drive(distance);
    }
};

class Motorcycle : public Vehicle {
private:
    bool hasSidecar_;
    
public:
    Motorcycle(const std::string& model, int year, bool hasSidecar)
        : Vehicle(model, year, 15.0), hasSidecar_(hasSidecar) {}
    
    double GetFuelEfficiency() const override {
        return 25.0;  // 25 km/L
    }
    
    std::string GetVehicleType() const override {
        return "오토바이";
    }
};

int main() {
    std::vector<std::unique_ptr<Vehicle>> fleet;
    
    fleet.push_back(std::make_unique<Car>("소나타", 2023, 4));
    fleet.push_back(std::make_unique<Truck>("포터", 2022, 1000));
    fleet.push_back(std::make_unique<Motorcycle>("할리데이비슨", 2021, false));
    
    std::cout << "=== 차량 정보 ===\n";
    for (const auto& vehicle : fleet) {
        vehicle->DisplayInfo();
    }
    
    std::cout << "\n=== 주유 ===\n";
    for (const auto& vehicle : fleet) {
        vehicle->Refuel(50);
    }
    
    std::cout << "\n=== 주행 ===\n";
    for (const auto& vehicle : fleet) {
        vehicle->Drive(100);
    }
    
    std::cout << "\n=== 프로그램 종료 ===\n";
    return 0;
}
```

### 문제 3: 인터페이스 다중 상속
파일 시스템의 파일과 디렉토리를 표현하는 클래스를 만들어라. 인터페이스를 활용하라.

**요구사항:**
- `IReadable`, `IWritable` 인터페이스
- `File`과 `Directory` 클래스
- 다형성을 활용한 파일 시스템 탐색

**해답:**

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>

// 읽기 인터페이스
class IReadable {
public:
    virtual ~IReadable() = default;
    virtual std::string Read() const = 0;
};

// 쓰기 인터페이스
class IWritable {
public:
    virtual ~IWritable() = default;
    virtual void Write(const std::string& content) = 0;
};

// 파일 시스템 요소 기본 클래스
class FileSystemElement {
protected:
    std::string name_;
    size_t size_;
    
public:
    FileSystemElement(const std::string& name, size_t size)
        : name_(name), size_(size) {}
    
    virtual ~FileSystemElement() = default;
    
    virtual void DisplayInfo(int indent = 0) const = 0;
    
    std::string GetName() const { return name_; }
    size_t GetSize() const { return size_; }
};

// 파일 클래스
class File final : public FileSystemElement, public IReadable, public IWritable {
private:
    std::string content_;
    
public:
    File(const std::string& name)
        : FileSystemElement(name, 0), content_("") {}
    
    std::string Read() const override {
        return content_;
    }
    
    void Write(const std::string& content) override {
        content_ = content;
        size_ = content.length();
        std::cout << "파일 \"" << name_ << "\"에 " << size_ << " 바이트 작성됨\n";
    }
    
    void DisplayInfo(int indent = 0) const override {
        std::string indentStr(indent * 2, ' ');
        std::cout << indentStr << "📄 " << name_ << " (" << size_ << " bytes)\n";
    }
};

// 디렉토리 클래스
class Directory final : public FileSystemElement {
private:
    std::vector<std::unique_ptr<FileSystemElement>> elements_;
    
public:
    Directory(const std::string& name)
        : FileSystemElement(name, 0) {}
    
    void AddElement(std::unique_ptr<FileSystemElement> element) {
        size_ += element->GetSize();
        elements_.push_back(std::move(element));
    }
    
    void DisplayInfo(int indent = 0) const override {
        std::string indentStr(indent * 2, ' ');
        std::cout << indentStr << "📁 " << name_ << "/\n";
        
        for (const auto& element : elements_) {
            element->DisplayInfo(indent + 1);
        }
    }
    
    size_t GetTotalSize() const {
        size_t total = 0;
        for (const auto& element : elements_) {
            total += element->GetSize();
        }
        return total;
    }
};

int main() {
    // 루트 디렉토리
    auto root = std::make_unique<Directory>("root");
    
    // 파일 생성 및 작성
    auto file1 = std::make_unique<File>("readme.txt");
    file1->Write("This is a readme file.");
    
    auto file2 = std::make_unique<File>("data.txt");
    file2->Write("Some data here.");
    
    // 서브 디렉토리
    auto docs = std::make_unique<Directory>("documents");
    auto doc1 = std::make_unique<File>("report.doc");
    doc1->Write("Annual report content...");
    docs->AddElement(std::move(doc1));
    
    // 파일 시스템 구성
    root->AddElement(std::move(file1));
    root->AddElement(std::move(file2));
    root->AddElement(std::move(docs));
    
    std::cout << "\n=== 파일 시스템 구조 ===\n";
    root->DisplayInfo();
    
    std::cout << "\n총 크기: " << root->GetTotalSize() << " bytes\n";
    
    return 0;
}
```
  

</br>  
</br>  
  

## 15.8 심화 내용

### 15.8.1 다중 상속
C++는 여러 클래스로부터 동시에 상속받는 다중 상속을 지원한다. 하지만 복잡성이 증가하므로 신중하게 사용해야 한다.

```cpp
#include <iostream>
#include <string>

class Flyable {
public:
    virtual void Fly() {
        std::cout << "날아간다.\n";
    }
    virtual ~Flyable() = default;
};

class Swimmable {
public:
    virtual void Swim() {
        std::cout << "헤엄친다.\n";
    }
    virtual ~Swimmable() = default;
};

// 다중 상속
class Duck : public Flyable, public Swimmable {
private:
    std::string name_;
    
public:
    Duck(const std::string& name) : name_(name) {}
    
    void Fly() override {
        std::cout << name_ << "이(가) 날아간다.\n";
    }
    
    void Swim() override {
        std::cout << name_ << "이(가) 헤엄친다.\n";
    }
    
    void Quack() {
        std::cout << name_ << ": 꽥꽥!\n";
    }
};

int main() {
    Duck donald("도날드");
    
    donald.Fly();
    donald.Swim();
    donald.Quack();
    
    // 각 기본 클래스 포인터로 변환 가능
    Flyable* flyable = &donald;
    flyable->Fly();
    
    Swimmable* swimmable = &donald;
    swimmable->Swim();
    
    return 0;
}
```

### 15.8.2 다이아몬드 문제와 가상 상속
다중 상속 시 발생할 수 있는 다이아몬드 문제를 해결하기 위해 가상 상속을 사용할 수 있다.

```cpp
#include <iostream>

// 다이아몬드 문제
class Animal {
public:
    void Eat() {
        std::cout << "동물이 먹는다.\n";
    }
};

class Mammal : virtual public Animal {  // 가상 상속
public:
    void GiveBirth() {
        std::cout << "새끼를 낳는다.\n";
    }
};

class Bird : virtual public Animal {  // 가상 상속
public:
    void LayEggs() {
        std::cout << "알을 낳는다.\n";
    }
};

// Bat은 Animal을 한 번만 상속받음
class Bat : public Mammal, public Bird {
public:
    void Echolocate() {
        std::cout << "초음파를 사용한다.\n";
    }
};

int main() {
    Bat bat;
    bat.Eat();  // 모호하지 않음 (가상 상속 덕분)
    bat.GiveBirth();
    bat.LayEggs();
    bat.Echolocate();
    
    return 0;
}
```

**Modern C++ 권장사항:** 다중 상속은 복잡도를 증가시키므로, 가능하면 인터페이스(순수 가상 함수만 있는 클래스)의 다중 상속만 사용하라.

### 15.8.3 CRTP (Curiously Recurring Template Pattern)
고급 기법으로, 컴파일 타임 다형성을 구현할 수 있다.

```cpp
#include <iostream>

// CRTP: 파생 클래스를 템플릿 매개변수로 받음
template<typename Derived>
class Shape {
public:
    void Draw() const {
        static_cast<const Derived*>(this)->DrawImpl();
    }
    
    double GetArea() const {
        return static_cast<const Derived*>(this)->GetAreaImpl();
    }
};

class Circle : public Shape<Circle> {
private:
    double radius_;
    
public:
    Circle(double radius) : radius_(radius) {}
    
    void DrawImpl() const {
        std::cout << "○ 원 그리기\n";
    }
    
    double GetAreaImpl() const {
        return 3.14159 * radius_ * radius_;
    }
};

class Rectangle : public Shape<Rectangle> {
private:
    double width_, height_;
    
public:
    Rectangle(double w, double h) : width_(w), height_(h) {}
    
    void DrawImpl() const {
        std::cout << "□ 사각형 그리기\n";
    }
    
    double GetAreaImpl() const {
        return width_ * height_;
    }
};

// 제네릭 함수 (런타임 다형성 없이 작동)
template<typename T>
void ProcessShape(const Shape<T>& shape) {
    shape.Draw();
    std::cout << "넓이: " << shape.GetArea() << "\n";
}

int main() {
    Circle circle(5.0);
    Rectangle rect(4.0, 6.0);
    
    ProcessShape(circle);
    ProcessShape(rect);
    
    return 0;
}
```

CRTP는 가상 함수의 오버헤드 없이 다형성을 구현할 수 있지만, 런타임 다형성이 불가능하다는 단점이 있다.
  

</br>  
</br>  


## 15.9 정리
이번 장에서는 상속과 다형성에 대해 배웠다. 핵심 내용을 정리하면:

1. **상속**: 기존 클래스의 기능을 재사용하고 확장한다
2. **접근 지정자**: `public` 상속이 가장 일반적이며 "is-a" 관계를 나타낸다
3. **가상 함수**: `virtual` 키워드로 동적 바인딩을 활성화한다
4. **가상 소멸자**: 상속 관계에서는 반드시 가상 소멸자를 사용한다
5. **`override`**: 오버라이딩 의도를 명확히 하고 실수를 방지한다
6. **`final`**: 추가 오버라이딩이나 상속을 금지한다
7. **순수 가상 함수**: 인터페이스를 정의하고 구현을 강제한다
8. **추상 클래스**: 직접 인스턴스화할 수 없으며 파생 클래스의 템플릿 역할을 한다

**Modern C++ 베스트 프랙티스:**

```cpp
// ✅ 좋은 예
class Base {
public:
    virtual ~Base() = default;  // 가상 소멸자
    virtual void Function() = 0;  // 순수 가상 함수
};

class Derived final : public Base {  // final: 더 이상 상속 불가
public:
    void Function() override {  // override: 명시적 표시
        // 구현
    }
};

// ⚠️ 주의할 예
class OldBase {
public:
    ~OldBase() {}  // 가상이 아닌 소멸자 (위험!)
    virtual void Function() {}  // override 없이 오버라이딩 (권장하지 않음)
};
```

다음 장에서는 템플릿을 다루며, 타입에 독립적인 제네릭 프로그래밍을 배운다. 상속과 다형성을 통한 런타임 다형성과 템플릿을 통한 컴파일 타임 다형성을 비교하면서 각각의 장단점을 이해하게 될 것이다.  