# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 11: 스마트 포인터와 메모리 관리

## 11.1 포인터와 메모리의 기초 개념
C++에서 메모리 관리는 프로그래밍의 핵심이면서도 가장 어려운 부분 중 하나다. 하지만 Modern C++의 스마트 포인터를 사용하면 안전하고 쉽게 메모리를 관리할 수 있다. 먼저 포인터와 메모리의 기본 개념부터 이해해보자.

### 11.1.1 메모리의 종류
C++ 프로그램이 사용하는 메모리는 크게 세 가지 영역으로 나뉜다.

**스택(Stack) 메모리**는 함수 내에서 선언된 지역 변수들이 저장되는 공간이다. 함수가 호출되면 자동으로 할당되고, 함수가 끝나면 자동으로 해제된다.

```cpp
#include <iostream>

void stackExample() {
    int x = 10;        // 스택에 할당
    double y = 3.14;   // 스택에 할당
    
    std::cout << "x = " << x << ", y = " << y << "\n";
    
    // 함수가 끝나면 x와 y는 자동으로 해제됨
}

int main() {
    stackExample();
    // 여기서는 x와 y에 접근할 수 없음
    
    return 0;
}
```

**힙(Heap) 메모리**는 프로그래머가 직접 할당하고 해제하는 메모리 영역이다. 스택보다 크고 유연하지만, 수동으로 관리해야 한다.

```cpp
#include <iostream>

int main() {
    // new를 사용하여 힙 메모리 할당
    int* ptr = new int(42);
    
    std::cout << "값: " << *ptr << "\n";
    std::cout << "주소: " << ptr << "\n";
    
    // 사용 후 반드시 해제해야 함
    delete ptr;
    ptr = nullptr;  // 댕글링 포인터 방지
    
    return 0;
}
```

**정적(Static) 메모리**는 프로그램 시작부터 종료까지 유지되는 전역 변수와 정적 변수가 저장되는 공간이다.

```cpp
#include <iostream>

int globalVar = 100;  // 정적 메모리

void staticExample() {
    static int counter = 0;  // 정적 메모리
    counter++;
    std::cout << "호출 횟수: " << counter << "\n";
}

int main() {
    staticExample();  // 호출 횟수: 1
    staticExample();  // 호출 횟수: 2
    staticExample();  // 호출 횟수: 3
    
    return 0;
}
```

### 11.1.2 포인터의 기본
포인터는 메모리 주소를 저장하는 변수다. 변수가 실제 값을 저장한다면, 포인터는 그 값이 있는 위치를 가리킨다.

```cpp
#include <iostream>

int main() {
    int value = 42;
    int* ptr = &value;  // value의 주소를 ptr에 저장
    
    std::cout << "value의 값: " << value << "\n";
    std::cout << "value의 주소: " << &value << "\n";
    std::cout << "ptr이 가리키는 주소: " << ptr << "\n";
    std::cout << "ptr이 가리키는 값: " << *ptr << "\n";
    
    // 포인터를 통한 값 변경
    *ptr = 100;
    std::cout << "변경 후 value: " << value << "\n";  // 100
    
    return 0;
}
```

포인터를 사용하는 주요 이유는 다음과 같다.

1. **동적 메모리 할당**: 실행 시간에 필요한 크기만큼 메모리를 할당할 수 있다.
2. **큰 객체의 효율적 전달**: 객체를 복사하지 않고 주소만 전달하여 성능을 향상시킨다.
3. **다형성 구현**: 상속 관계에서 부모 클래스 포인터로 자식 클래스 객체를 가리킬 수 있다.

### 11.1.3 동적 메모리 할당
`new`와 `delete` 키워드를 사용하여 힙 메모리를 관리할 수 있다.

```cpp
#include <iostream>
#include <string>

int main() {
    // 단일 객체 할당
    int* num = new int(100);
    std::cout << *num << "\n";
    delete num;
    
    // 배열 할당
    int* arr = new int[5]{1, 2, 3, 4, 5};
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
    delete[] arr;  // 배열은 delete[]로 해제
    
    // 객체 할당
    std::string* str = new std::string("Hello, C++!");
    std::cout << *str << "\n";
    delete str;
    
    return 0;
}
```
  

</br>  
</br>  
  

## 11.2 왜 raw pointer는 위험한가?
전통적인 포인터(raw pointer)는 강력하지만 여러 문제를 일으킬 수 있다.

### 11.2.1 메모리 누수 (Memory Leak)
메모리를 할당하고 해제하지 않으면 메모리 누수가 발생한다.

```cpp
#include <iostream>

void memoryLeakExample() {
    int* data = new int[1000];
    
    // 어떤 작업 수행
    
    // delete[]를 호출하지 않음 - 메모리 누수!
}

int main() {
    // 이 함수를 반복 호출하면 메모리가 계속 소모됨
    for (int i = 0; i < 1000; ++i) {
        memoryLeakExample();
    }
    
    // 프로그램이 종료되어야 메모리가 해제됨
    return 0;
}
```

### 11.2.2 댕글링 포인터 (Dangling Pointer)
이미 해제된 메모리를 가리키는 포인터를 댕글링 포인터라고 한다.

```cpp
#include <iostream>

int main() {
    int* ptr = new int(42);
    delete ptr;
    
    // ptr은 이제 댕글링 포인터
    // *ptr = 100;  // 정의되지 않은 동작! 위험!
    
    // 안전한 방법: nullptr로 설정
    ptr = nullptr;
    
    if (ptr != nullptr) {
        *ptr = 100;  // 이 코드는 실행되지 않음
    }
    
    return 0;
}
```

### 11.2.3 이중 해제 (Double Delete)
같은 메모리를 두 번 해제하면 프로그램이 충돌할 수 있다.

```cpp
#include <iostream>

int main() {
    int* ptr1 = new int(42);
    int* ptr2 = ptr1;  // 같은 메모리를 가리킴
    
    delete ptr1;
    // delete ptr2;  // 오류! 이미 해제된 메모리를 다시 해제
    
    return 0;
}
```

### 11.2.4 예외 안전성 문제
예외가 발생하면 메모리 해제 코드가 실행되지 않을 수 있다.

```cpp
#include <iostream>
#include <stdexcept>

void riskyFunction() {
    int* data = new int[100];
    
    // 어떤 작업 중 예외 발생
    throw std::runtime_error("오류 발생!");
    
    // 이 코드는 실행되지 않음 - 메모리 누수!
    delete[] data;
}

int main() {
    try {
        riskyFunction();
    }
    catch (const std::exception& e) {
        std::cout << "예외 발생: " << e.what() << "\n";
    }
    
    return 0;
}
```

### 11.2.5 소유권 불명확
여러 포인터가 같은 메모리를 가리킬 때 누가 해제해야 하는지 불명확하다.

```cpp
#include <iostream>

class Resource {
public:
    Resource() { std::cout << "Resource 생성\n"; }
    ~Resource() { std::cout << "Resource 해제\n"; }
};

void confusingOwnership() {
    Resource* res1 = new Resource();
    Resource* res2 = res1;
    Resource* res3 = res1;
    
    // res1, res2, res3 중 누가 delete를 호출해야 하나?
    // 한 곳에서만 delete를 호출해야 하는데, 이를 보장하기 어렵다
    
    delete res1;
    // res2와 res3는 이제 댕글링 포인터
}

int main() {
    confusingOwnership();
    return 0;
}
```

이러한 문제들을 해결하기 위해 Modern C++에서는 **스마트 포인터**를 제공한다.
  

</br>  
</br>  
  

## 11.3 std::unique_ptr로 단독 소유 관리
`std::unique_ptr`은 가장 기본적이고 효율적인 스마트 포인터다. 한 번에 하나의 `unique_ptr`만이 객체를 소유할 수 있으며, 스코프를 벗어나면 자동으로 메모리를 해제한다.

### 11.3.1 unique_ptr의 기본 사용법

```cpp
#include <iostream>
#include <memory>

class Player {
private:
    std::string name;
    int level;

public:
    Player(const std::string& n, int lv) : name(n), level(lv) {
        std::cout << name << " 생성 (레벨 " << level << ")\n";
    }
    
    ~Player() {
        std::cout << name << " 소멸\n";
    }
    
    void levelUp() {
        level++;
        std::cout << name << "이(가) 레벨업! 현재 레벨: " << level << "\n";
    }
    
    void showInfo() const {
        std::cout << "이름: " << name << ", 레벨: " << level << "\n";
    }
};

int main() {
    // unique_ptr 생성
    std::unique_ptr<Player> player1(new Player("전사", 1));
    player1->showInfo();
    player1->levelUp();
    
    // C++14 이상: make_unique 사용 (권장)
    auto player2 = std::make_unique<Player>("마법사", 1);
    player2->showInfo();
    
    // 스코프를 벗어나면 자동으로 delete 호출됨
    // 수동으로 delete를 호출할 필요 없음!
    
    return 0;
}
```

위 코드의 출력 결과는 다음과 같다.

```
전사 생성 (레벨 1)
이름: 전사, 레벨: 1
전사이(가) 레벨업! 현재 레벨: 2
마법사 생성 (레벨 1)
이름: 마법사, 레벨: 1
마법사 소멸
전사 소멸
```

### 11.3.2 unique_ptr의 소유권 이전
`unique_ptr`은 복사할 수 없지만 이동(move)할 수 있다.

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Weapon {
private:
    std::string name;
    int damage;

public:
    Weapon(const std::string& n, int d) : name(n), damage(d) {
        std::cout << name << " 생성 (공격력: " << damage << ")\n";
    }
    
    ~Weapon() {
        std::cout << name << " 파괴\n";
    }
    
    void use() const {
        std::cout << name << "으로 " << damage << " 데미지!\n";
    }
};

std::unique_ptr<Weapon> createWeapon(const std::string& type) {
    if (type == "sword") {
        return std::make_unique<Weapon>("엑스칼리버", 100);
    }
    else if (type == "bow") {
        return std::make_unique<Weapon>("엘프의 활", 80);
    }
    return nullptr;
}

int main() {
    // 함수에서 unique_ptr 반환 (소유권 이전)
    auto weapon1 = createWeapon("sword");
    weapon1->use();
    
    // 복사는 불가능
    // auto weapon2 = weapon1;  // 오류!
    
    // 이동은 가능 (std::move 사용)
    auto weapon2 = std::move(weapon1);
    weapon2->use();
    
    // weapon1은 이제 nullptr
    if (weapon1 == nullptr) {
        std::cout << "weapon1은 비어있음\n";
    }
    
    // vector에 저장 (이동을 통해)
    std::vector<std::unique_ptr<Weapon>> inventory;
    inventory.push_back(std::make_unique<Weapon>("마법 지팡이", 120));
    inventory.push_back(std::make_unique<Weapon>("단검", 50));
    
    std::cout << "\n인벤토리:\n";
    for (const auto& weapon : inventory) {
        weapon->use();
    }
    
    return 0;
}
```

### 11.3.3 배열을 위한 unique_ptr
`unique_ptr`은 배열도 관리할 수 있다.

```cpp
#include <iostream>
#include <memory>

int main() {
    // 배열을 위한 unique_ptr
    auto numbers = std::make_unique<int[]>(5);
    
    for (int i = 0; i < 5; ++i) {
        numbers[i] = i * 10;
    }
    
    for (int i = 0; i < 5; ++i) {
        std::cout << numbers[i] << " ";
    }
    std::cout << "\n";
    
    // 하지만 대부분의 경우 std::vector를 사용하는 것이 더 낫다
    std::vector<int> betterNumbers = {0, 10, 20, 30, 40};
    
    return 0;
}
```

### 11.3.4 커스텀 삭제자
특별한 정리 작업이 필요한 경우 커스텀 삭제자를 지정할 수 있다.

```cpp
#include <iostream>
#include <memory>

class FileHandle {
private:
    std::string filename;

public:
    FileHandle(const std::string& name) : filename(name) {
        std::cout << filename << " 파일 열기\n";
    }
    
    ~FileHandle() {
        std::cout << filename << " 파일 닫기\n";
    }
    
    void write(const std::string& data) {
        std::cout << filename << "에 쓰기: " << data << "\n";
    }
};

// 커스텀 삭제자
struct FileDeleter {
    void operator()(FileHandle* file) const {
        std::cout << "커스텀 삭제자 호출\n";
        delete file;
    }
};

int main() {
    // 커스텀 삭제자 사용
    std::unique_ptr<FileHandle, FileDeleter> file(
        new FileHandle("data.txt"),
        FileDeleter()
    );
    
    file->write("Hello, World!");
    
    // 람다를 삭제자로 사용
    auto deleter = [](FileHandle* f) {
        std::cout << "람다 삭제자 호출\n";
        delete f;
    };
    
    std::unique_ptr<FileHandle, decltype(deleter)> file2(
        new FileHandle("log.txt"),
        deleter
    );
    
    file2->write("로그 메시지");
    
    return 0;
}
```

### 11.3.5 unique_ptr의 실전 활용

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

class Monster {
private:
    std::string name;
    int hp;

public:
    Monster(const std::string& n, int h) : name(n), hp(h) {
        std::cout << name << " 등장! (HP: " << hp << ")\n";
    }
    
    ~Monster() {
        std::cout << name << " 퇴치됨\n";
    }
    
    void takeDamage(int damage) {
        hp -= damage;
        std::cout << name << "에게 " << damage << " 데미지! ";
        if (hp > 0) {
            std::cout << "(남은 HP: " << hp << ")\n";
        }
        else {
            std::cout << "(사망)\n";
        }
    }
    
    bool isAlive() const {
        return hp > 0;
    }
    
    const std::string& getName() const {
        return name;
    }
};

class Game {
private:
    std::vector<std::unique_ptr<Monster>> monsters;

public:
    void spawnMonster(const std::string& name, int hp) {
        monsters.push_back(std::make_unique<Monster>(name, hp));
    }
    
    void attackAll(int damage) {
        std::cout << "\n전체 공격! (데미지: " << damage << ")\n";
        for (const auto& monster : monsters) {
            monster->takeDamage(damage);
        }
        
        // 죽은 몬스터 제거
        auto it = std::remove_if(
            monsters.begin(),
            monsters.end(),
            [](const std::unique_ptr<Monster>& m) {
                return !m->isAlive();
            }
        );
        
        monsters.erase(it, monsters.end());
    }
    
    void showMonsters() const {
        std::cout << "\n현재 몬스터 목록:\n";
        if (monsters.empty()) {
            std::cout << "(없음)\n";
        }
        else {
            for (const auto& monster : monsters) {
                std::cout << "- " << monster->getName() << "\n";
            }
        }
    }
};

int main() {
    Game game;
    
    game.spawnMonster("슬라임", 30);
    game.spawnMonster("고블린", 50);
    game.spawnMonster("오크", 80);
    
    game.showMonsters();
    game.attackAll(25);
    game.showMonsters();
    game.attackAll(30);
    game.showMonsters();
    
    return 0;
}
```
  

</br>  
</br>      

  
## 11.4 std::shared_ptr로 공유 소유 관리
때로는 여러 곳에서 동일한 객체를 참조해야 할 때가 있다. `std::shared_ptr`은 참조 횟수를 세어 마지막 참조가 사라질 때 객체를 해제한다.

### 11.4.1 shared_ptr의 기본 사용법

```cpp
#include <iostream>
#include <memory>

class Texture {
private:
    std::string filename;

public:
    Texture(const std::string& file) : filename(file) {
        std::cout << filename << " 텍스처 로드\n";
    }
    
    ~Texture() {
        std::cout << filename << " 텍스처 해제\n";
    }
    
    void draw() const {
        std::cout << filename << " 그리기\n";
    }
};

int main() {
    // shared_ptr 생성
    std::shared_ptr<Texture> tex1 = std::make_shared<Texture>("player.png");
    std::cout << "참조 카운트: " << tex1.use_count() << "\n";
    
    {
        // 복사 - 참조 카운트 증가
        std::shared_ptr<Texture> tex2 = tex1;
        std::cout << "참조 카운트: " << tex1.use_count() << "\n";
        
        std::shared_ptr<Texture> tex3 = tex1;
        std::cout << "참조 카운트: " << tex1.use_count() << "\n";
        
        tex2->draw();
        tex3->draw();
        
        // 스코프를 벗어나면 tex2, tex3 소멸
        // 하지만 tex1이 아직 있으므로 Texture 객체는 유지됨
    }
    
    std::cout << "참조 카운트: " << tex1.use_count() << "\n";
    tex1->draw();
    
    // main 함수가 끝나면 tex1도 소멸
    // 참조 카운트가 0이 되므로 Texture 객체 해제
    
    return 0;
}
```

출력 결과:

```
player.png 텍스처 로드
참조 카운트: 1
참조 카운트: 2
참조 카운트: 3
player.png 그리기
player.png 그리기
참조 카운트: 1
player.png 그리기
player.png 텍스처 해제
```

### 11.4.2 shared_ptr을 사용하는 이유

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Mesh {
private:
    std::string name;
    std::vector<int> vertices;  // 실제로는 훨씬 큰 데이터

public:
    Mesh(const std::string& n, int vertexCount) : name(n) {
        vertices.resize(vertexCount);
        std::cout << name << " 메시 로드 (정점 " << vertexCount << "개)\n";
    }
    
    ~Mesh() {
        std::cout << name << " 메시 해제\n";
    }
    
    void render() const {
        std::cout << name << " 렌더링\n";
    }
};

class GameObject {
private:
    std::string name;
    std::shared_ptr<Mesh> mesh;  // 여러 오브젝트가 같은 메시 공유

public:
    GameObject(const std::string& n, std::shared_ptr<Mesh> m)
        : name(n), mesh(m) {
        std::cout << name << " 생성\n";
    }
    
    ~GameObject() {
        std::cout << name << " 소멸\n";
    }
    
    void draw() const {
        std::cout << name << ": ";
        mesh->render();
    }
};

int main() {
    // 큰 메시 데이터를 한 번만 로드
    auto cubeMesh = std::make_shared<Mesh>("큐브", 10000);
    
    std::cout << "\n게임 오브젝트 생성:\n";
    
    std::vector<std::unique_ptr<GameObject>> objects;
    
    // 여러 오브젝트가 같은 메시를 공유
    objects.push_back(std::make_unique<GameObject>("상자1", cubeMesh));
    objects.push_back(std::make_unique<GameObject>("상자2", cubeMesh));
    objects.push_back(std::make_unique<GameObject>("상자3", cubeMesh));
    
    std::cout << "\n메시 참조 카운트: " << cubeMesh.use_count() << "\n";
    
    std::cout << "\n렌더링:\n";
    for (const auto& obj : objects) {
        obj->draw();
    }
    
    std::cout << "\n오브젝트 제거:\n";
    objects.clear();
    
    std::cout << "\n메시 참조 카운트: " << cubeMesh.use_count() << "\n";
    
    std::cout << "\nprogram 종료:\n";
    // cubeMesh도 사라지면서 메시 데이터 해제
    
    return 0;
}
```

### 11.4.3 weak_ptr로 순환 참조 방지
`shared_ptr`의 한 가지 문제는 순환 참조다. 두 객체가 서로를 가리키면 참조 카운트가 0이 되지 않아 메모리 누수가 발생한다.

```cpp
#include <iostream>
#include <memory>

class Player;
class Team;

// 잘못된 예제 - 순환 참조
class BadPlayer {
private:
    std::string name;
    std::shared_ptr<Team> team;  // Player -> Team

public:
    BadPlayer(const std::string& n) : name(n) {
        std::cout << name << " 생성\n";
    }
    
    ~BadPlayer() {
        std::cout << name << " 소멸\n";
    }
    
    void setTeam(std::shared_ptr<Team> t) {
        team = t;
    }
};

class BadTeam {
private:
    std::string name;
    std::shared_ptr<BadPlayer> leader;  // Team -> Player (순환!)

public:
    BadTeam(const std::string& n) : name(n) {
        std::cout << name << " 팀 생성\n";
    }
    
    ~BadTeam() {
        std::cout << name << " 팀 소멸\n";
    }
    
    void setLeader(std::shared_ptr<BadPlayer> p) {
        leader = p;
    }
};

// 올바른 예제 - weak_ptr 사용
class Player {
private:
    std::string name;
    std::weak_ptr<Team> team;  // weak_ptr 사용!

public:
    Player(const std::string& n) : name(n) {
        std::cout << name << " 생성\n";
    }
    
    ~Player() {
        std::cout << name << " 소멸\n";
    }
    
    void setTeam(std::shared_ptr<Team> t) {
        team = t;
    }
    
    void showTeam() const;
};

class Team {
private:
    std::string name;
    std::shared_ptr<Player> leader;

public:
    Team(const std::string& n) : name(n) {
        std::cout << name << " 팀 생성\n";
    }
    
    ~Team() {
        std::cout << name << " 팀 소멸\n";
    }
    
    void setLeader(std::shared_ptr<Player> p) {
        leader = p;
    }
    
    const std::string& getName() const {
        return name;
    }
};

void Player::showTeam() const {
    // weak_ptr을 사용하려면 lock()으로 shared_ptr로 변환
    if (auto t = team.lock()) {
        std::cout << name << "의 팀: " << t->getName() << "\n";
    }
    else {
        std::cout << name << "은(는) 팀이 없습니다.\n";
    }
}

int main() {
    std::cout << "=== 잘못된 예제 (순환 참조) ===\n";
    {
        auto badPlayer = std::make_shared<BadPlayer>("철수");
        auto badTeam = std::make_shared<BadTeam>("레드");
        
        badPlayer->setTeam(badTeam);
        badTeam->setLeader(badPlayer);
        
        // 스코프를 벗어나도 소멸자가 호출되지 않음!
        // 순환 참조로 인해 메모리 누수 발생
    }
    std::cout << "스코프 종료\n\n";
    
    std::cout << "=== 올바른 예제 (weak_ptr 사용) ===\n";
    {
        auto player = std::make_shared<Player>("영희");
        auto team = std::make_shared<Team>("블루");
        
        player->setTeam(team);
        team->setLeader(player);
        
        player->showTeam();
        
        // 스코프를 벗어나면 정상적으로 소멸
    }
    std::cout << "스코프 종료\n";
    
    return 0;
}
```

### 11.4.4 shared_ptr과 unique_ptr의 선택

어떤 스마트 포인터를 사용해야 할까?

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Resource {
private:
    std::string name;

public:
    Resource(const std::string& n) : name(n) {
        std::cout << name << " 생성\n";
    }
    
    ~Resource() {
        std::cout << name << " 소멸\n";
    }
    
    void use() const {
        std::cout << name << " 사용\n";
    }
};

int main() {
    std::cout << "=== unique_ptr 사용 (기본 선택) ===\n";
    {
        // 명확한 소유권, 오버헤드 없음
        auto res1 = std::make_unique<Resource>("리소스1");
        res1->use();
    }  // 자동 해제
    
    std::cout << "\n=== shared_ptr 사용 (공유 필요) ===\n";
    {
        // 여러 곳에서 참조해야 할 때
        auto res2 = std::make_shared<Resource>("공유리소스");
        
        std::vector<std::shared_ptr<Resource>> users;
        users.push_back(res2);
        users.push_back(res2);
        users.push_back(res2);
        
        std::cout << "참조 카운트: " << res2.use_count() << "\n";
        
        for (const auto& user : users) {
            user->use();
        }
    }  // 마지막 참조가 사라지면 해제
    
    std::cout << "\n=== 성능 비교 ===\n";
    {
        // unique_ptr: 포인터 크기만큼의 오버헤드
        std::cout << "unique_ptr 크기: " << sizeof(std::unique_ptr<int>) << " 바이트\n";
        
        // shared_ptr: 포인터 + 제어 블록 (참조 카운트)
        std::cout << "shared_ptr 크기: " << sizeof(std::shared_ptr<int>) << " 바이트\n";
        
        // raw pointer
        std::cout << "포인터 크기: " << sizeof(int*) << " 바이트\n";
    }
    
    return 0;
}
```

**선택 가이드:**

1. **기본적으로 `unique_ptr` 사용**: 가볍고 빠르며 명확한 소유권
2. **공유가 필요하면 `shared_ptr` 사용**: 여러 곳에서 동시에 참조
3. **순환 참조 가능성이 있으면 `weak_ptr` 사용**: 관찰자 패턴, 캐시 등
4. **raw pointer는 사용하지 않기**: 소유권이 없는 참조만 필요한 경우 참조(`&`)나 `weak_ptr` 사용
    
  
</br>     
</br>  
  
  
## 11.5 RAII 패턴과 자동 리소스 관리
RAII(Resource Acquisition Is Initialization)는 리소스의 획득과 해제를 객체의 생성과 소멸에 묶는 C++의 핵심 패턴이다.

### 11.5.1 RAII의 기본 개념

```cpp
#include <iostream>
#include <fstream>
#include <string>

// RAII를 사용하지 않는 예제 (나쁜 예)
void badFileHandling() {
    std::ofstream file("data.txt");
    
    if (!file.is_open()) {
        std::cout << "파일 열기 실패\n";
        return;  // 파일 닫기 누락
    }
    
    file << "데이터 쓰기\n";
    
    // 예외가 발생하면?
    // throw std::runtime_error("오류!");  // 파일이 닫히지 않음!
    
    file.close();  // 수동으로 닫아야 함
}

// RAII를 사용하는 예제 (좋은 예)
void goodFileHandling() {
    std::ofstream file("data.txt");
    
    if (!file.is_open()) {
        std::cout << "파일 열기 실패\n";
        return;
    }
    
    file << "데이터 쓰기\n";
    
    // 예외가 발생해도 안전
    // throw std::runtime_error("오류!");
    
    // 스코프를 벗어나면 자동으로 파일 닫힘
    // close()를 명시적으로 호출할 필요 없음
}

int main() {
    try {
        goodFileHandling();
        std::cout << "파일 처리 완료\n";
    }
    catch (const std::exception& e) {
        std::cout << "예외 발생: " << e.what() << "\n";
    }
    
    return 0;
}
```

### 11.5.2 RAII를 활용한 커스텀 리소스 관리

```cpp
#include <iostream>
#include <memory>
#include <string>

// 데이터베이스 연결을 시뮬레이션하는 클래스
class DatabaseConnection {
private:
    std::string connectionString;
    bool connected;

public:
    DatabaseConnection(const std::string& connStr) 
        : connectionString(connStr), connected(false) {
        connect();
    }
    
    ~DatabaseConnection() {
        disconnect();
    }
    
    // 복사 방지 (연결은 고유해야 함)
    DatabaseConnection(const DatabaseConnection&) = delete;
    DatabaseConnection& operator=(const DatabaseConnection&) = delete;
    
    // 이동은 허용
    DatabaseConnection(DatabaseConnection&& other) noexcept 
        : connectionString(std::move(other.connectionString)), 
          connected(other.connected) {
        other.connected = false;
    }
    
    void connect() {
        std::cout << connectionString << "에 연결 중...\n";
        connected = true;
        std::cout << "연결 성공!\n";
    }
    
    void disconnect() {
        if (connected) {
            std::cout << connectionString << " 연결 종료\n";
            connected = false;
        }
    }
    
    void query(const std::string& sql) {
        if (connected) {
            std::cout << "쿼리 실행: " << sql << "\n";
        }
        else {
            std::cout << "연결되지 않음!\n";
        }
    }
};

// 트랜잭션 관리 클래스 (RAII)
class Transaction {
private:
    DatabaseConnection& db;
    bool committed;

public:
    Transaction(DatabaseConnection& database) 
        : db(database), committed(false) {
        std::cout << "트랜잭션 시작\n";
    }
    
    ~Transaction() {
        if (!committed) {
            rollback();
        }
    }
    
    void commit() {
        std::cout << "트랜잭션 커밋\n";
        committed = true;
    }
    
    void rollback() {
        std::cout << "트랜잭션 롤백\n";
    }
};

int main() {
    std::cout << "=== 정상 실행 ===\n";
    {
        DatabaseConnection db("localhost:5432/mydb");
        
        Transaction trans(db);
        db.query("INSERT INTO users VALUES (1, 'Alice')");
        db.query("INSERT INTO users VALUES (2, 'Bob')");
        trans.commit();
        
        // 스코프를 벗어나면 자동으로 트랜잭션 종료 및 연결 해제
    }
    
    std::cout << "\n=== 예외 발생 ===\n";
    {
        DatabaseConnection db("localhost:5432/mydb");
        
        try {
            Transaction trans(db);
            db.query("INSERT INTO users VALUES (3, 'Charlie')");
            
            // 예외 발생
            throw std::runtime_error("데이터베이스 오류!");
            
            trans.commit();  // 실행되지 않음
        }
        catch (const std::exception& e) {
            std::cout << "예외 처리: " << e.what() << "\n";
            // Transaction 소멸자가 자동으로 롤백 수행
        }
        
        // DatabaseConnection 소멸자가 자동으로 연결 종료
    }
    
    return 0;
}
```

### 11.5.3 스마트 포인터와 RAII
스마트 포인터 자체가 RAII 패턴의 완벽한 구현이다.

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Image {
private:
    std::string filename;
    std::vector<unsigned char> data;

public:
    Image(const std::string& file, size_t size) 
        : filename(file), data(size) {
        std::cout << filename << " 로드 (크기: " << size << " 바이트)\n";
    }
    
    ~Image() {
        std::cout << filename << " 언로드\n";
    }
    
    void process() {
        std::cout << filename << " 처리 중...\n";
    }
};

class ImageProcessor {
private:
    std::vector<std::unique_ptr<Image>> images;

public:
    void loadImage(const std::string& filename, size_t size) {
        images.push_back(std::make_unique<Image>(filename, size));
    }
    
    void processAll() {
        for (const auto& img : images) {
            img->process();
        }
    }
    
    // 소멸자에서 특별히 할 일이 없음
    // unique_ptr이 자동으로 모든 이미지를 해제
    ~ImageProcessor() {
        std::cout << "ImageProcessor 종료\n";
    }
};

int main() {
    std::cout << "=== 이미지 처리 시작 ===\n";
    {
        ImageProcessor processor;
        
        processor.loadImage("photo1.jpg", 1024000);
        processor.loadImage("photo2.jpg", 2048000);
        processor.loadImage("photo3.jpg", 512000);
        
        processor.processAll();
        
        // 예외가 발생해도 안전
        // throw std::runtime_error("처리 오류!");
        
        // 스코프를 벗어나면 모든 리소스 자동 해제
    }
    std::cout << "=== 이미지 처리 완료 ===\n";
    
    return 0;
}
```

### 11.5.4 RAII의 장점

```cpp
#include <iostream>
#include <memory>
#include <mutex>
#include <thread>
#include <vector>

// 잠금 관리 (RAII의 또 다른 활용)
class Counter {
private:
    int value;
    std::mutex mtx;

public:
    Counter() : value(0) {}
    
    void increment() {
        // RAII를 사용한 자동 잠금 관리
        std::lock_guard<std::mutex> lock(mtx);
        value++;
        // lock이 스코프를 벗어나면 자동으로 뮤텍스 해제
    }
    
    int getValue() {
        std::lock_guard<std::mutex> lock(mtx);
        return value;
    }
};

int main() {
    Counter counter;
    std::vector<std::thread> threads;
    
    // 여러 스레드에서 카운터 증가
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back([&counter]() {
            for (int j = 0; j < 1000; ++j) {
                counter.increment();
            }
        });
    }
    
    // 모든 스레드 완료 대기
    for (auto& thread : threads) {
        thread.join();
    }
    
    std::cout << "최종 값: " << counter.getValue() << "\n";
    
    return 0;
}
```

RAII의 핵심 원칙은 다음과 같다.

1. **획득은 초기화다**: 리소스는 생성자에서 획득한다.
2. **해제는 소멸이다**: 리소스는 소멸자에서 해제한다.
3. **예외 안전성**: 예외가 발생해도 리소스가 올바르게 해제된다.
4. **수동 관리 불필요**: `delete`, `close()` 등을 명시적으로 호출할 필요가 없다.
  

</br>  
</br>  
  

## 11.6 실습 문제

### 실습 11-1: 게임 인벤토리 시스템
`unique_ptr`을 사용하여 게임 인벤토리 시스템을 구현하라.

**요구사항:**
1. `Item` 클래스를 만든다 (이름, 가격, 무게 속성).
2. `Inventory` 클래스를 만든다.
3. 아이템을 추가, 제거, 전체 출력하는 기능을 구현한다.
4. 총 무게와 총 가치를 계산하는 기능을 추가한다.

**예상 출력:**

```
검 추가 (가격: 100, 무게: 5)
방패 추가 (가격: 80, 무게: 8)
물약 추가 (가격: 20, 무게: 1)

인벤토리:
- 검 (가격: 100, 무게: 5)
- 방패 (가격: 80, 무게: 8)
- 물약 (가격: 20, 무게: 1)
총 가치: 200
총 무게: 14

방패 제거
총 가치: 120
총 무게: 6
```

### 실습 11-2: 텍스처 관리자
`shared_ptr`을 사용하여 텍스처 관리 시스템을 구현하라.

**요구사항:**
1. `Texture` 클래스를 만든다 (파일명, 크기 정보).
2. `TextureManager` 클래스를 만든다 (캐싱 기능).
3. 같은 텍스처를 여러 번 요청하면 이미 로드된 것을 반환한다.
4. 사용 중인 텍스처의 참조 횟수를 출력한다.

### 실습 11-3: 리소스 풀
RAII 패턴을 활용하여 리소스 풀을 구현하라.

**요구사항:**
1. 제한된 수의 리소스를 관리하는 풀을 만든다.
2. 리소스를 획득하고 자동으로 반환하는 RAII 래퍼를 만든다.
3. 사용 가능한 리소스가 없으면 대기하거나 예외를 발생시킨다.
   

</br>  
</br>  
  

## 11.7 심화 내용

### 11.7.1 make_unique와 make_shared의 이점
`make_unique`와 `make_shared`를 사용하면 여러 이점이 있다.

```cpp
#include <iostream>
#include <memory>

class Widget {
private:
    int value;

public:
    Widget(int v) : value(v) {
        std::cout << "Widget(" << value << ") 생성\n";
    }
    
    ~Widget() {
        std::cout << "Widget(" << value << ") 소멸\n";
    }
};

void processWidget(std::unique_ptr<Widget> w, int priority) {
    std::cout << "processWidget 호출\n";
}

int computePriority() {
    std::cout << "우선순위 계산\n";
    return 10;
}

int main() {
    std::cout << "=== 예외 안전성 문제 (나쁜 예) ===\n";
    // 다음 코드는 메모리 누수 가능성이 있음
    // processWidget(std::unique_ptr<Widget>(new Widget(1)), computePriority());
    // 평가 순서가 보장되지 않아, computePriority()가 new 이후 예외를 발생시키면
    // Widget이 해제되지 않을 수 있음
    
    std::cout << "\n=== 예외 안전성 보장 (좋은 예) ===\n";
    processWidget(std::make_unique<Widget>(2), computePriority());
    // make_unique는 예외 안전성을 보장
    
    std::cout << "\n=== shared_ptr의 메모리 효율성 ===\n";
    {
        // 비효율적: 두 번의 메모리 할당
        std::shared_ptr<Widget> sp1(new Widget(3));
        
        // 효율적: 한 번의 메모리 할당
        auto sp2 = std::make_shared<Widget>(4);
        
        std::cout << "shared_ptr 크기: " << sizeof(sp1) << " 바이트\n";
    }
    
    return 0;
}
```

### 11.7.2 enable_shared_from_this
객체 내부에서 자기 자신을 가리키는 `shared_ptr`을 생성해야 할 때 사용한다.

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Task : public std::enable_shared_from_this<Task> {
private:
    std::string name;

public:
    Task(const std::string& n) : name(n) {
        std::cout << name << " 생성\n";
    }
    
    ~Task() {
        std::cout << name << " 소멸\n";
    }
    
    void registerCallback(std::vector<std::shared_ptr<Task>>& tasks) {
        // 자기 자신의 shared_ptr을 얻음
        tasks.push_back(shared_from_this());
        std::cout << name << " 등록 (참조 카운트: " 
                  << shared_from_this().use_count() << ")\n";
    }
    
    void execute() {
        std::cout << name << " 실행\n";
    }
};

int main() {
    std::vector<std::shared_ptr<Task>> taskQueue;
    
    {
        auto task1 = std::make_shared<Task>("작업1");
        auto task2 = std::make_shared<Task>("작업2");
        
        task1->registerCallback(taskQueue);
        task2->registerCallback(taskQueue);
        
        std::cout << "\n작업 실행:\n";
        for (auto& task : taskQueue) {
            task->execute();
        }
        
        // task1, task2는 스코프를 벗어나지만
        // taskQueue에 의해 유지됨
    }
    
    std::cout << "\n작업 큐 비우기:\n";
    taskQueue.clear();
    
    return 0;
}
```

### 11.7.3 커스텀 allocator와 스마트 포인터
고급 메모리 관리가 필요한 경우 커스텀 allocator를 사용할 수 있다.

```cpp
#include <iostream>
#include <memory>

template<typename T>
class PoolAllocator {
private:
    static constexpr size_t POOL_SIZE = 1000;
    static T pool[POOL_SIZE];
    static bool used[POOL_SIZE];

public:
    T* allocate() {
        for (size_t i = 0; i < POOL_SIZE; ++i) {
            if (!used[i]) {
                used[i] = true;
                std::cout << "풀에서 할당 (인덱스 " << i << ")\n";
                return &pool[i];
            }
        }
        throw std::bad_alloc();
    }
    
    void deallocate(T* ptr) {
        size_t index = ptr - pool;
        if (index < POOL_SIZE) {
            used[index] = false;
            std::cout << "풀에 반환 (인덱스 " << index << ")\n";
        }
    }
};

template<typename T>
T PoolAllocator<T>::pool[POOL_SIZE];

template<typename T>
bool PoolAllocator<T>::used[POOL_SIZE] = {};

class GameObject {
private:
    int id;
    
public:
    GameObject(int i) : id(i) {
        std::cout << "GameObject " << id << " 생성\n";
    }
    
    ~GameObject() {
        std::cout << "GameObject " << id << " 소멸\n";
    }
};

int main() {
    PoolAllocator<GameObject> allocator;
    
    // 커스텀 삭제자와 함께 unique_ptr 사용
    auto deleter = [&allocator](GameObject* ptr) {
        ptr->~GameObject();
        allocator.deallocate(ptr);
    };
    
    {
        std::unique_ptr<GameObject, decltype(deleter)> obj1(
            new (allocator.allocate()) GameObject(1),
            deleter
        );
        
        std::unique_ptr<GameObject, decltype(deleter)> obj2(
            new (allocator.allocate()) GameObject(2),
            deleter
        );
    }
    
    std::cout << "오브젝트들이 소멸되고 풀에 반환됨\n";
    
    return 0;
}
```

### 11.7.4 스마트 포인터 성능 최적화

```cpp
#include <iostream>
#include <memory>
#include <chrono>
#include <vector>

class SimpleObject {
private:
    int data[10];
    
public:
    SimpleObject() {
        for (int i = 0; i < 10; ++i) {
            data[i] = i;
        }
    }
};

template<typename Func>
void measureTime(const std::string& name, Func func) {
    auto start = std::chrono::high_resolution_clock::now();
    func();
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << name << ": " << duration.count() << " μs\n";
}

int main() {
    const int ITERATIONS = 100000;
    
    std::cout << "=== 성능 비교 (" << ITERATIONS << "회 반복) ===\n\n";
    
    // raw pointer
    measureTime("Raw pointer", [&]() {
        for (int i = 0; i < ITERATIONS; ++i) {
            SimpleObject* obj = new SimpleObject();
            delete obj;
        }
    });
    
    // unique_ptr (거의 raw pointer와 동일한 성능)
    measureTime("unique_ptr", [&]() {
        for (int i = 0; i < ITERATIONS; ++i) {
            auto obj = std::make_unique<SimpleObject>();
        }
    });
    
    // shared_ptr (참조 카운팅 오버헤드)
    measureTime("shared_ptr", [&]() {
        for (int i = 0; i < ITERATIONS; ++i) {
            auto obj = std::make_shared<SimpleObject>();
        }
    });
    
    // shared_ptr 복사 (참조 카운트 증가/감소)
    measureTime("shared_ptr 복사", [&]() {
        auto original = std::make_shared<SimpleObject>();
        for (int i = 0; i < ITERATIONS; ++i) {
            auto copy = original;
        }
    });
    
    std::cout << "\n=== 메모리 사용량 ===\n";
    std::cout << "int* 크기: " << sizeof(int*) << " 바이트\n";
    std::cout << "unique_ptr<int> 크기: " << sizeof(std::unique_ptr<int>) << " 바이트\n";
    std::cout << "shared_ptr<int> 크기: " << sizeof(std::shared_ptr<int>) << " 바이트\n";
    
    return 0;
}
```

### 11.7.5 실전 패턴: 팩토리 함수
스마트 포인터를 반환하는 팩토리 함수는 Modern C++의 일반적인 패턴이다.

```cpp
#include <iostream>
#include <memory>
#include <string>

enum class EnemyType {
    Goblin,
    Orc,
    Dragon
};

class Enemy {
protected:
    std::string name;
    int hp;
    int attack;

public:
    Enemy(const std::string& n, int h, int a) 
        : name(n), hp(h), attack(a) {
        std::cout << name << " 생성 (HP: " << hp << ", 공격력: " << attack << ")\n";
    }
    
    virtual ~Enemy() {
        std::cout << name << " 제거\n";
    }
    
    virtual void performAttack() const = 0;
    
    const std::string& getName() const { return name; }
};

class Goblin : public Enemy {
public:
    Goblin() : Enemy("고블린", 30, 10) {}
    
    void performAttack() const override {
        std::cout << name << "의 빠른 공격! (" << attack << " 데미지)\n";
    }
};

class Orc : public Enemy {
public:
    Orc() : Enemy("오크", 60, 20) {}
    
    void performAttack() const override {
        std::cout << name << "의 강력한 일격! (" << attack << " 데미지)\n";
    }
};

class Dragon : public Enemy {
public:
    Dragon() : Enemy("드래곤", 150, 50) {}
    
    void performAttack() const override {
        std::cout << name << "의 화염 브레스! (" << attack << " 데미지)\n";
    }
};

// 팩토리 함수
std::unique_ptr<Enemy> createEnemy(EnemyType type) {
    switch (type) {
        case EnemyType::Goblin:
            return std::make_unique<Goblin>();
        case EnemyType::Orc:
            return std::make_unique<Orc>();
        case EnemyType::Dragon:
            return std::make_unique<Dragon>();
        default:
            return nullptr;
    }
}

int main() {
    std::vector<std::unique_ptr<Enemy>> enemies;
    
    enemies.push_back(createEnemy(EnemyType::Goblin));
    enemies.push_back(createEnemy(EnemyType::Orc));
    enemies.push_back(createEnemy(EnemyType::Dragon));
    enemies.push_back(createEnemy(EnemyType::Goblin));
    
    std::cout << "\n전투 시작!\n";
    for (const auto& enemy : enemies) {
        enemy->performAttack();
    }
    
    std::cout << "\n적 제거:\n";
    // enemies 벡터가 소멸되면서 모든 적 자동 제거
    
    return 0;
}
```

이 장에서는 Modern C++의 메모리 관리 방법을 배웠다. 스마트 포인터를 사용하면 메모리 누수, 댕글링 포인터, 이중 해제 같은 문제를 자동으로 방지할 수 있다. `unique_ptr`은 명확한 소유권을 가진 경우에, `shared_ptr`은 공유 소유권이 필요한 경우에 사용한다. RAII 패턴을 이해하고 활용하면 안전하고 효율적인 C++ 코드를 작성할 수 있다. 다음 장에서는 STL 컨테이너와 알고리즘을 배워 데이터를 효율적으로 관리하는 방법을 알아볼 것이다.

 