# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 17: 예외 처리와 오류 관리
프로그램을 작성하다 보면 예상치 못한 상황에 직면하게 된다. 파일이 존재하지 않거나, 메모리가 부족하거나, 잘못된 입력이 들어오는 등의 오류 상황을 어떻게 처리하느냐가 프로그램의 안정성을 결정한다. Modern C++은 전통적인 예외 처리 메커니즘뿐만 아니라 `std::optional`과 `std::expected` 같은 안전하고 명확한 오류 처리 도구를 제공한다.

## 17.1 예외 처리의 필요성

### 17.1.1 오류 처리가 없는 코드의 문제점
예외 처리 없이 작성된 코드를 살펴보자.

```cpp
#include <iostream>
#include <vector>

int divide(int a, int b) {
    return a / b;  // b가 0이면?
}

int getElement(const std::vector<int>& vec, size_t index) {
    return vec[index];  // index가 범위를 벗어나면?
}

int main() {
    std::cout << divide(10, 2) << '\n';   // 정상 작동
    std::cout << divide(10, 0) << '\n';   // 런타임 오류! (정의되지 않은 동작)
    
    std::vector<int> numbers{1, 2, 3};
    std::cout << getElement(numbers, 1) << '\n';   // 정상 작동
    std::cout << getElement(numbers, 10) << '\n';  // 정의되지 않은 동작!
}
```

이 코드는 컴파일은 되지만 실행 시 심각한 문제를 일으킬 수 있다. 0으로 나누기는 정의되지 않은 동작이며, 범위를 벗어난 인덱스 접근도 마찬가지다.

### 17.1.2 전통적인 오류 처리 방법의 한계
예외가 도입되기 전에는 반환값이나 전역 오류 코드로 오류를 처리했다.

```cpp
#include <iostream>
#include <vector>
#include <limits>

// 오류 시 특수한 값을 반환
int divide_old_style(int a, int b) {
    if (b == 0) {
        return std::numeric_limits<int>::min();  // 오류를 나타내는 특수 값
    }
    return a / b;
}

// 오류 코드를 매개변수로 전달
int divide_with_error_code(int a, int b, bool& success) {
    if (b == 0) {
        success = false;
        return 0;
    }
    success = true;
    return a / b;
}

int main() {
    // 방법 1: 특수 값 확인
    int result1 = divide_old_style(10, 0);
    if (result1 == std::numeric_limits<int>::min()) {
        std::cout << "오류 발생!\n";
    }
    
    // 방법 2: 오류 플래그 확인
    bool success;
    int result2 = divide_with_error_code(10, 0, success);
    if (!success) {
        std::cout << "오류 발생!\n";
    }
}
```

이 방법들은 다음과 같은 문제가 있다.
- 반환값과 오류 코드가 혼재되어 코드가 복잡해진다
- 호출자가 오류를 확인하지 않으면 오류가 무시된다
- 여러 단계의 함수 호출에서 오류를 전파하기 어렵다

### 17.1.3 예외 처리의 장점
예외 처리는 이러한 문제를 해결한다.

```cpp
#include <iostream>
#include <stdexcept>

int divide(int a, int b) {
    if (b == 0) {
        throw std::invalid_argument("0으로 나눌 수 없다");
    }
    return a / b;
}

int calculate(int a, int b, int c) {
    // 여러 단계의 연산에서 예외가 자동으로 전파된다
    int temp = divide(a, b);
    return divide(temp, c);
}

int main() {
    try {
        std::cout << divide(10, 2) << '\n';
        std::cout << divide(10, 0) << '\n';  // 예외 발생
        std::cout << "이 줄은 실행되지 않는다\n";
    } catch (const std::invalid_argument& e) {
        std::cout << "오류: " << e.what() << '\n';
    }
    
    std::cout << "프로그램 계속 실행\n";
}
```
   

</br>  
  
  
## 17.2 try, catch, throw 키워드
예외 처리의 핵심은 세 가지 키워드다.

### 17.2.1 기본 예외 처리 구조

```cpp
#include <iostream>
#include <stdexcept>

double safeDivide(double a, double b) {
    if (b == 0.0) {
        throw std::runtime_error("0으로 나눌 수 없다");
    }
    return a / b;
}

int main() {
    try {
        // 예외가 발생할 수 있는 코드
        double result1 = safeDivide(10.0, 2.0);
        std::cout << "10 / 2 = " << result1 << '\n';
        
        double result2 = safeDivide(10.0, 0.0);  // 예외 발생!
        std::cout << "이 줄은 실행되지 않는다\n";
        
    } catch (const std::runtime_error& e) {
        // 예외 처리 코드
        std::cout << "예외 발생: " << e.what() << '\n';
    }
    
    std::cout << "프로그램이 정상적으로 계속된다\n";
}
```

`try` 블록 안에서 예외가 발생하면 즉시 실행이 중단되고 대응하는 `catch` 블록으로 제어가 이동한다.

### 17.2.2 여러 종류의 예외 처리
하나의 `try` 블록에 여러 개의 `catch` 블록을 사용할 수 있다.

```cpp
#include <iostream>
#include <stdexcept>
#include <string>

class InvalidAgeException : public std::exception {
private:
    std::string message;
    
public:
    explicit InvalidAgeException(int age) 
        : message("유효하지 않은 나이: " + std::to_string(age)) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

void checkAge(int age) {
    if (age < 0) {
        throw InvalidAgeException(age);
    }
    if (age > 150) {
        throw std::out_of_range("나이가 너무 많다");
    }
}

void processInput(const std::string& input) {
    if (input.empty()) {
        throw std::invalid_argument("입력이 비어있다");
    }
    
    int age = std::stoi(input);  // 변환 실패 시 std::invalid_argument 발생
    checkAge(age);
    
    std::cout << "나이 " << age << "세가 등록되었다\n";
}

int main() {
    std::vector<std::string> inputs{"25", "", "-5", "200", "abc"};
    
    for (const auto& input : inputs) {
        try {
            std::cout << "입력 처리: \"" << input << "\"\n";
            processInput(input);
            
        } catch (const InvalidAgeException& e) {
            std::cout << "사용자 정의 예외: " << e.what() << '\n';
            
        } catch (const std::out_of_range& e) {
            std::cout << "범위 오류: " << e.what() << '\n';
            
        } catch (const std::invalid_argument& e) {
            std::cout << "잘못된 인자: " << e.what() << '\n';
            
        } catch (const std::exception& e) {
            std::cout << "일반 예외: " << e.what() << '\n';
        }
        
        std::cout << "---\n";
    }
}
```

`catch` 블록은 위에서부터 순서대로 확인되므로, 더 구체적인 예외를 먼저 처리하고 일반적인 예외를 나중에 처리해야 한다.

### 17.2.3 모든 예외 잡기
때로는 예외의 종류와 관계없이 모든 예외를 처리하고 싶을 때가 있다.

```cpp
#include <iostream>
#include <stdexcept>

void riskyFunction(int value) {
    if (value == 1) {
        throw std::runtime_error("Runtime error");
    } else if (value == 2) {
        throw std::logic_error("Logic error");
    } else if (value == 3) {
        throw 42;  // 정수를 던지기
    } else if (value == 4) {
        throw "문자열 예외";  // 문자열을 던지기 (권장하지 않음)
    }
}

int main() {
    for (int i = 0; i <= 5; ++i) {
        try {
            std::cout << "시도 " << i << ": ";
            riskyFunction(i);
            std::cout << "성공\n";
            
        } catch (const std::exception& e) {
            std::cout << "표준 예외: " << e.what() << '\n';
            
        } catch (...) {
            // 모든 종류의 예외를 잡는다
            std::cout << "알 수 없는 예외 발생\n";
        }
    }
}
```

`catch(...)` 구문은 모든 예외를 잡지만, 예외에 대한 정보를 얻을 수 없다. 따라서 마지막 수단으로만 사용해야 한다.

### 17.2.4 예외 다시 던지기
예외를 잡은 후 다시 던질 수 있다.

```cpp
#include <iostream>
#include <stdexcept>
#include <fstream>

void processFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file) {
        throw std::runtime_error("파일을 열 수 없다: " + filename);
    }
    // 파일 처리...
}

void handleFile(const std::string& filename) {
    try {
        processFile(filename);
    } catch (const std::runtime_error& e) {
        std::cout << "handleFile에서 예외 감지: " << e.what() << '\n';
        std::cout << "로그를 기록한다...\n";
        throw;  // 예외를 다시 던진다
    }
}

int main() {
    try {
        handleFile("nonexistent.txt");
    } catch (const std::runtime_error& e) {
        std::cout << "main에서 최종 처리: " << e.what() << '\n';
    }
}
```

`throw;` 구문은 현재 처리 중인 예외를 그대로 다시 던진다. 이를 통해 예외를 로깅하면서도 상위 호출자에게 전달할 수 있다.
  

</br>  
</br>  
  

## 17.3 표준 예외 클래스들
C++ 표준 라이브러리는 `<stdexcept>` 헤더에 다양한 예외 클래스를 제공한다.

### 17.3.1 예외 클래스 계층 구조

```cpp
#include <iostream>
#include <exception>
#include <stdexcept>

void demonstrateExceptionHierarchy() {
    std::cout << "std::exception 계층 구조:\n";
    std::cout << "  std::exception (기본 클래스)\n";
    std::cout << "    ├─ std::logic_error\n";
    std::cout << "    │   ├─ std::invalid_argument\n";
    std::cout << "    │   ├─ std::domain_error\n";
    std::cout << "    │   ├─ std::length_error\n";
    std::cout << "    │   └─ std::out_of_range\n";
    std::cout << "    ├─ std::runtime_error\n";
    std::cout << "    │   ├─ std::range_error\n";
    std::cout << "    │   ├─ std::overflow_error\n";
    std::cout << "    │   └─ std::underflow_error\n";
    std::cout << "    ├─ std::bad_alloc\n";
    std::cout << "    └─ std::bad_cast\n";
}

int main() {
    demonstrateExceptionHierarchy();
}
```

### 17.3.2 주요 예외 클래스 사용 예제

```cpp
#include <iostream>
#include <stdexcept>
#include <vector>
#include <cmath>

// std::invalid_argument - 함수에 잘못된 인자가 전달됨
void setAge(int age) {
    if (age < 0 || age > 150) {
        throw std::invalid_argument("나이는 0에서 150 사이여야 한다");
    }
}

// std::out_of_range - 범위를 벗어난 접근
int safeAccess(const std::vector<int>& vec, size_t index) {
    if (index >= vec.size()) {
        throw std::out_of_range("인덱스가 벡터 범위를 벗어났다");
    }
    return vec[index];
}

// std::domain_error - 수학적 정의역 오류
double safeSqrt(double value) {
    if (value < 0) {
        throw std::domain_error("음수의 제곱근을 계산할 수 없다");
    }
    return std::sqrt(value);
}

// std::length_error - 크기 제한 초과
void addElements(std::vector<int>& vec, size_t count) {
    if (vec.size() + count > vec.max_size()) {
        throw std::length_error("벡터의 최대 크기를 초과한다");
    }
    vec.resize(vec.size() + count);
}

// std::runtime_error - 실행 시간 오류
void processData(bool condition) {
    if (!condition) {
        throw std::runtime_error("데이터 처리 중 오류 발생");
    }
}

int main() {
    // invalid_argument 테스트
    try {
        setAge(200);
    } catch (const std::invalid_argument& e) {
        std::cout << "invalid_argument: " << e.what() << '\n';
    }
    
    // out_of_range 테스트
    try {
        std::vector<int> numbers{1, 2, 3};
        safeAccess(numbers, 10);
    } catch (const std::out_of_range& e) {
        std::cout << "out_of_range: " << e.what() << '\n';
    }
    
    // domain_error 테스트
    try {
        safeSqrt(-4.0);
    } catch (const std::domain_error& e) {
        std::cout << "domain_error: " << e.what() << '\n';
    }
    
    // runtime_error 테스트
    try {
        processData(false);
    } catch (const std::runtime_error& e) {
        std::cout << "runtime_error: " << e.what() << '\n';
    }
}
```

### 17.3.3 사용자 정의 예외 클래스
표준 예외를 상속하여 자신만의 예외 클래스를 만들 수 있다.

```cpp
#include <iostream>
#include <exception>
#include <string>

// 기본적인 사용자 정의 예외
class FileException : public std::exception {
private:
    std::string message;
    
public:
    explicit FileException(const std::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

// 더 복잡한 예외 클래스
class DatabaseException : public std::runtime_error {
private:
    int errorCode;
    std::string query;
    
public:
    DatabaseException(const std::string& msg, int code, const std::string& q)
        : std::runtime_error(msg), errorCode(code), query(q) {}
    
    int getErrorCode() const { return errorCode; }
    const std::string& getQuery() const { return query; }
};

// 예외 클래스 계층 구조
class NetworkException : public std::runtime_error {
public:
    using std::runtime_error::runtime_error;
};

class ConnectionException : public NetworkException {
private:
    std::string serverAddress;
    int port;
    
public:
    ConnectionException(const std::string& msg, const std::string& addr, int p)
        : NetworkException(msg), serverAddress(addr), port(p) {}
    
    std::string getServerAddress() const { return serverAddress; }
    int getPort() const { return port; }
};

class TimeoutException : public NetworkException {
private:
    int timeoutSeconds;
    
public:
    TimeoutException(const std::string& msg, int timeout)
        : NetworkException(msg), timeoutSeconds(timeout) {}
    
    int getTimeout() const { return timeoutSeconds; }
};

void simulateFileOperation(bool success) {
    if (!success) {
        throw FileException("파일 읽기 실패");
    }
}

void simulateDatabaseQuery(const std::string& query, bool success) {
    if (!success) {
        throw DatabaseException("쿼리 실행 실패", 1064, query);
    }
}

void simulateNetworkOperation(int scenario) {
    if (scenario == 1) {
        throw ConnectionException("서버에 연결할 수 없다", "192.168.1.1", 8080);
    } else if (scenario == 2) {
        throw TimeoutException("연결 시간 초과", 30);
    }
}

int main() {
    // FileException 테스트
    try {
        simulateFileOperation(false);
    } catch (const FileException& e) {
        std::cout << "파일 예외: " << e.what() << '\n';
    }
    
    // DatabaseException 테스트
    try {
        simulateDatabaseQuery("SELECT * FROM users", false);
    } catch (const DatabaseException& e) {
        std::cout << "데이터베이스 예외: " << e.what() << '\n';
        std::cout << "  오류 코드: " << e.getErrorCode() << '\n';
        std::cout << "  쿼리: " << e.getQuery() << '\n';
    }
    
    // NetworkException 계층 테스트
    try {
        simulateNetworkOperation(1);
    } catch (const ConnectionException& e) {
        std::cout << "연결 예외: " << e.what() << '\n';
        std::cout << "  서버: " << e.getServerAddress() 
                  << ":" << e.getPort() << '\n';
    } catch (const TimeoutException& e) {
        std::cout << "타임아웃 예외: " << e.what() << '\n';
        std::cout << "  타임아웃: " << e.getTimeout() << "초\n";
    } catch (const NetworkException& e) {
        std::cout << "네트워크 예외: " << e.what() << '\n';
    }
}
```
    

</br>  
</br>  
  

## 17.4 std::optional로 값의 부재 표현 (C++17)
모든 오류 상황이 예외로 처리되어야 하는 것은 아니다. 값이 없을 수 있는 상황은 `std::optional`로 명확하게 표현할 수 있다.

### 17.4.1 std::optional의 기본 사용법

```cpp
#include <iostream>
#include <optional>
#include <string>

// 값이 있을 수도, 없을 수도 있는 함수
std::optional<int> findIndex(const std::string& text, char target) {
    for (size_t i = 0; i < text.size(); ++i) {
        if (text[i] == target) {
            return static_cast<int>(i);  // 값을 반환
        }
    }
    return std::nullopt;  // 값이 없음을 반환
}

std::optional<double> safeDivide(double a, double b) {
    if (b == 0.0) {
        return std::nullopt;
    }
    return a / b;
}

int main() {
    // 값이 있는 경우
    auto result1 = findIndex("Hello World", 'o');
    if (result1.has_value()) {
        std::cout << "'o'를 찾았다. 위치: " << result1.value() << '\n';
    } else {
        std::cout << "'o'를 찾지 못했다\n";
    }
    
    // 값이 없는 경우
    auto result2 = findIndex("Hello World", 'x');
    if (result2) {  // has_value()와 동일
        std::cout << "'x'를 찾았다. 위치: " << *result2 << '\n';
    } else {
        std::cout << "'x'를 찾지 못했다\n";
    }
    
    // 나눗셈 예제
    auto div1 = safeDivide(10.0, 2.0);
    std::cout << "10 / 2 = " << div1.value_or(-1.0) << '\n';
    
    auto div2 = safeDivide(10.0, 0.0);
    std::cout << "10 / 0 = " << div2.value_or(-1.0) << '\n';
}
```

### 17.4.2 std::optional의 다양한 사용 패턴

```cpp
#include <iostream>
#include <optional>
#include <string>
#include <map>

// 설정값을 저장하는 클래스
class Configuration {
private:
    std::map<std::string, std::string> settings;
    
public:
    void set(const std::string& key, const std::string& value) {
        settings[key] = value;
    }
    
    std::optional<std::string> get(const std::string& key) const {
        auto it = settings.find(key);
        if (it != settings.end()) {
            return it->second;
        }
        return std::nullopt;
    }
    
    std::optional<int> getInt(const std::string& key) const {
        auto value = get(key);
        if (!value) {
            return std::nullopt;
        }
        
        try {
            return std::stoi(*value);
        } catch (...) {
            return std::nullopt;
        }
    }
};

// 사용자 정보
struct User {
    std::string name;
    std::optional<std::string> email;  // 이메일은 선택사항
    std::optional<int> age;            // 나이는 선택사항
    
    void print() const {
        std::cout << "이름: " << name << '\n';
        
        if (email) {
            std::cout << "이메일: " << *email << '\n';
        } else {
            std::cout << "이메일: (없음)\n";
        }
        
        if (age) {
            std::cout << "나이: " << *age << "세\n";
        } else {
            std::cout << "나이: (비공개)\n";
        }
    }
};

int main() {
    // Configuration 사용 예제
    Configuration config;
    config.set("server", "localhost");
    config.set("port", "8080");
    
    auto server = config.get("server");
    std::cout << "서버: " << server.value_or("default") << '\n';
    
    auto port = config.getInt("port");
    std::cout << "포트: " << port.value_or(80) << '\n';
    
    auto timeout = config.getInt("timeout");
    std::cout << "타임아웃: " << timeout.value_or(30) << '\n';
    
    std::cout << '\n';
    
    // User 사용 예제
    User user1{"Alice", "alice@example.com", 25};
    user1.print();
    
    std::cout << '\n';
    
    User user2{"Bob", std::nullopt, std::nullopt};
    user2.print();
}
```

### 17.4.3 std::optional과 예외 처리 비교

```cpp
#include <iostream>
#include <optional>
#include <string>
#include <map>

// 예외를 사용하는 버전
class UserDatabase_Exception {
private:
    std::map<int, std::string> users;
    
public:
    void addUser(int id, const std::string& name) {
        users[id] = name;
    }
    
    std::string getUser(int id) const {
        auto it = users.find(id);
        if (it == users.end()) {
            throw std::out_of_range("사용자를 찾을 수 없다");
        }
        return it->second;
    }
};

// optional을 사용하는 버전
class UserDatabase_Optional {
private:
    std::map<int, std::string> users;
    
public:
    void addUser(int id, const std::string& name) {
        users[id] = name;
    }
    
    std::optional<std::string> getUser(int id) const {
        auto it = users.find(id);
        if (it != users.end()) {
            return it->second;
        }
        return std::nullopt;
    }
};

int main() {
    std::cout << "=== 예외 버전 ===\n";
    UserDatabase_Exception db1;
    db1.addUser(1, "Alice");
    db1.addUser(2, "Bob");
    
    try {
        std::cout << "사용자 1: " << db1.getUser(1) << '\n';
        std::cout << "사용자 2: " << db1.getUser(2) << '\n';
        std::cout << "사용자 3: " << db1.getUser(3) << '\n';  // 예외 발생
    } catch (const std::out_of_range& e) {
        std::cout << "오류: " << e.what() << '\n';
    }
    
    std::cout << "\n=== Optional 버전 ===\n";
    UserDatabase_Optional db2;
    db2.addUser(1, "Alice");
    db2.addUser(2, "Bob");
    
    auto user1 = db2.getUser(1);
    if (user1) {
        std::cout << "사용자 1: " << *user1 << '\n';
    }
    
    auto user2 = db2.getUser(2);
    if (user2) {
        std::cout << "사용자 2: " << *user2 << '\n';
    }
    
    auto user3 = db2.getUser(3);
    if (user3) {
        std::cout << "사용자 3: " << *user3 << '\n';
    } else {
        std::cout << "사용자 3을 찾을 수 없다\n";
    }
}
```

예외는 진짜 예외적인 상황에 사용하고, 값이 없을 수 있는 정상적인 경우에는 `std::optional`을 사용하는 것이 좋다.

### 17.4.4 std::optional의 고급 기능

```cpp
#include <iostream>
#include <optional>
#include <string>

std::optional<std::string> getMiddleName(const std::string& fullName) {
    // 간단한 예제: 공백이 2개 이상이면 중간 이름이 있다고 가정
    size_t firstSpace = fullName.find(' ');
    if (firstSpace == std::string::npos) {
        return std::nullopt;
    }
    
    size_t secondSpace = fullName.find(' ', firstSpace + 1);
    if (secondSpace == std::string::npos) {
        return std::nullopt;
    }
    
    return fullName.substr(firstSpace + 1, secondSpace - firstSpace - 1);
}

int main() {
    std::string name1 = "John Smith";
    std::string name2 = "John Michael Smith";
    
    // value_or를 사용한 기본값 제공
    auto middle1 = getMiddleName(name1);
    std::cout << "중간 이름: " << middle1.value_or("(없음)") << '\n';
    
    // and_then을 사용한 체이닝 (C++23)
    auto middle2 = getMiddleName(name2);
    if (middle2) {
        std::cout << "중간 이름: " << *middle2 << '\n';
    }
    
    // transform을 사용한 변환 (C++23)
    // auto upperMiddle = middle2.transform([](const std::string& s) {
    //     std::string result = s;
    //     for (char& c : result) c = std::toupper(c);
    //     return result;
    // });
    
    // emplace를 사용한 생성
    std::optional<std::string> opt;
    opt.emplace("새로운 값");
    std::cout << "Emplace된 값: " << *opt << '\n';
    
    // reset을 사용한 초기화
    opt.reset();
    std::cout << "Reset 후: " << (opt.has_value() ? "값 있음" : "값 없음") << '\n';
}
```
  

</br>  
</br>  
  

## 17.5 std::expected 소개 (C++23)
C++23에서 도입된 `std::expected`는 함수가 성공 시 값을 반환하거나 실패 시 오류 정보를 반환할 수 있게 해준다. 예외를 던지지 않으면서도 오류 정보를 전달할 수 있다.

### 17.5.1 std::expected의 기본 개념

```cpp
#include <iostream>
#include <expected>
#include <string>

// 오류 타입 정의
enum class ParseError {
    InvalidFormat,
    OutOfRange,
    Empty
};

// 오류 메시지 변환
std::string errorToString(ParseError error) {
    switch (error) {
        case ParseError::InvalidFormat: return "잘못된 형식";
        case ParseError::OutOfRange: return "범위 초과";
        case ParseError::Empty: return "빈 문자열";
        default: return "알 수 없는 오류";
    }
}

// std::expected를 반환하는 함수
std::expected<int, ParseError> parseInteger(const std::string& str) {
    if (str.empty()) {
        return std::unexpected(ParseError::Empty);
    }
    
    try {
        int value = std::stoi(str);
        
        if (value < 0 || value > 100) {
            return std::unexpected(ParseError::OutOfRange);
        }
        
        return value;  // 성공 시 값 반환
        
    } catch (...) {
        return std::unexpected(ParseError::InvalidFormat);
    }
}

int main() {
    std::vector<std::string> inputs{"42", "150", "abc", "", "25"};
    
    for (const auto& input : inputs) {
        auto result = parseInteger(input);
        
        if (result) {
            // 성공한 경우
            std::cout << "\"" << input << "\" -> " << *result << '\n';
        } else {
            // 실패한 경우
            std::cout << "\"" << input << "\" -> 오류: " 
                      << errorToString(result.error()) << '\n';
        }
    }
}
```

### 17.5.2 std::expected의 실용적 예제

```cpp
#include <iostream>
#include <expected>
#include <string>
#include <fstream>
#include <vector>

// 파일 읽기 오류
enum class FileError {
    NotFound,
    PermissionDenied,
    ReadError
};

std::string fileErrorToString(FileError error) {
    switch (error) {
        case FileError::NotFound: return "파일을 찾을 수 없다";
        case FileError::PermissionDenied: return "권한이 없다";
        case FileError::ReadError: return "읽기 오류";
        default: return "알 수 없는 오류";
    }
}

// 파일 내용을 읽는 함수
std::expected<std::string, FileError> readFile(const std::string& filename) {
    std::ifstream file(filename);
    
    if (!file) {
        return std::unexpected(FileError::NotFound);
    }
    
    std::string content;
    std::string line;
    
    while (std::getline(file, line)) {
        content += line + '\n';
    }
    
    if (file.bad()) {
        return std::unexpected(FileError::ReadError);
    }
    
    return content;
}

// 설정 파일 파싱
struct Config {
    std::string serverAddress;
    int port;
    int timeout;
};

enum class ConfigError {
    FileError,
    ParseError,
    MissingField
};

std::expected<Config, ConfigError> loadConfig(const std::string& filename) {
    auto fileContent = readFile(filename);
    
    if (!fileContent) {
        return std::unexpected(ConfigError::FileError);
    }
    
    // 간단한 파싱 (실제로는 더 복잡할 것)
    Config config;
    config.serverAddress = "localhost";
    config.port = 8080;
    config.timeout = 30;
    
    return config;
}

int main() {
    // 파일 읽기 예제
    auto content = readFile("test.txt");
    
    if (content) {
        std::cout << "파일 내용:\n" << *content << '\n';
    } else {
        std::cout << "파일 읽기 실패: " 
                  << fileErrorToString(content.error()) << '\n';
    }
    
    // 설정 로드 예제
    auto config = loadConfig("config.txt");
    
    if (config) {
        std::cout << "설정 로드 성공\n";
        std::cout << "  서버: " << config->serverAddress << '\n';
        std::cout << "  포트: " << config->port << '\n';
        std::cout << "  타임아웃: " << config->timeout << "초\n";
    } else {
        std::cout << "설정 로드 실패\n";
    }
}
```

### 17.5.3 std::expected vs 예외 vs std::optional

```cpp
#include <iostream>
#include <expected>
#include <optional>
#include <string>

// 방법 1: 예외 사용
class Division_Exception {
public:
    static double divide(double a, double b) {
        if (b == 0.0) {
            throw std::invalid_argument("0으로 나눌 수 없다");
        }
        return a / b;
    }
};

// 방법 2: optional 사용
class Division_Optional {
public:
    static std::optional<double> divide(double a, double b) {
        if (b == 0.0) {
            return std::nullopt;
        }
        return a / b;
    }
};

// 방법 3: expected 사용
enum class DivisionError {
    DivideByZero
};

class Division_Expected {
public:
    static std::expected<double, DivisionError> divide(double a, double b) {
        if (b == 0.0) {
            return std::unexpected(DivisionError::DivideByZero);
        }
        return a / b;
    }
};

int main() {
    std::cout << "=== 예외 버전 ===\n";
    try {
        std::cout << "10 / 2 = " << Division_Exception::divide(10.0, 2.0) << '\n';
        std::cout << "10 / 0 = " << Division_Exception::divide(10.0, 0.0) << '\n';
    } catch (const std::invalid_argument& e) {
        std::cout << "예외: " << e.what() << '\n';
    }
    
    std::cout << "\n=== Optional 버전 ===\n";
    auto result1 = Division_Optional::divide(10.0, 2.0);
    std::cout << "10 / 2 = " << result1.value_or(-1) << '\n';
    
    auto result2 = Division_Optional::divide(10.0, 0.0);
    if (result2) {
        std::cout << "10 / 0 = " << *result2 << '\n';
    } else {
        std::cout << "10 / 0 = 오류 (이유를 알 수 없음)\n";
    }
    
    std::cout << "\n=== Expected 버전 ===\n";
    auto result3 = Division_Expected::divide(10.0, 2.0);
    if (result3) {
        std::cout << "10 / 2 = " << *result3 << '\n';
    }
    
    auto result4 = Division_Expected::divide(10.0, 0.0);
    if (result4) {
        std::cout << "10 / 0 = " << *result4 << '\n';
    } else {
        std::cout << "10 / 0 = 오류 (0으로 나누기)\n";
    }
}
```

**사용 지침:**
- **예외**: 정말 예외적인 상황, 복구 불가능한 오류
- **optional**: 값이 없는 것이 정상적인 경우
- **expected**: 오류가 예상되지만 오류 정보가 필요한 경우
  

</br>  
</br>  

  
## 17.6 실습 예제: 안전한 파일 처리 시스템
배운 내용을 종합하여 안전한 파일 처리 시스템을 만들어보자.

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <optional>
#include <expected>

// 오류 타입 정의
enum class FileOperationError {
    FileNotFound,
    PermissionDenied,
    InvalidFormat,
    IOError
};

std::string errorToString(FileOperationError error) {
    switch (error) {
        case FileOperationError::FileNotFound: 
            return "파일을 찾을 수 없다";
        case FileOperationError::PermissionDenied: 
            return "파일 접근 권한이 없다";
        case FileOperationError::InvalidFormat: 
            return "잘못된 파일 형식";
        case FileOperationError::IOError: 
            return "입출력 오류";
        default: 
            return "알 수 없는 오류";
    }
}

// 파일 정보 구조체
struct FileInfo {
    std::string filename;
    size_t lineCount;
    size_t wordCount;
    size_t charCount;
    
    void print() const {
        std::cout << "파일: " << filename << '\n';
        std::cout << "  줄 수: " << lineCount << '\n';
        std::cout << "  단어 수: " << wordCount << '\n';
        std::cout << "  문자 수: " << charCount << '\n';
    }
};

// 안전한 파일 읽기 클래스
class SafeFileReader {
public:
    // 파일 존재 여부 확인
    static bool fileExists(const std::string& filename) {
        std::ifstream file(filename);
        return file.good();
    }
    
    // 파일 내용 읽기 (expected 사용)
    static std::expected<std::string, FileOperationError> 
    readContent(const std::string& filename) {
        std::ifstream file(filename);
        
        if (!file) {
            if (!fileExists(filename)) {
                return std::unexpected(FileOperationError::FileNotFound);
            }
            return std::unexpected(FileOperationError::PermissionDenied);
        }
        
        std::string content;
        std::string line;
        
        while (std::getline(file, line)) {
            content += line + '\n';
        }
        
        if (file.bad()) {
            return std::unexpected(FileOperationError::IOError);
        }
        
        return content;
    }
    
    // 특정 줄 읽기 (optional 사용)
    static std::optional<std::string> 
    readLine(const std::string& filename, size_t lineNumber) {
        std::ifstream file(filename);
        
        if (!file) {
            return std::nullopt;
        }
        
        std::string line;
        size_t currentLine = 0;
        
        while (std::getline(file, line)) {
            if (currentLine == lineNumber) {
                return line;
            }
            ++currentLine;
        }
        
        return std::nullopt;
    }
    
    // 파일 정보 분석
    static std::expected<FileInfo, FileOperationError> 
    analyzeFile(const std::string& filename) {
        auto content = readContent(filename);
        
        if (!content) {
            return std::unexpected(content.error());
        }
        
        FileInfo info;
        info.filename = filename;
        info.lineCount = 0;
        info.wordCount = 0;
        info.charCount = content->size();
        
        std::istringstream stream(*content);
        std::string line;
        
        while (std::getline(stream, line)) {
            ++info.lineCount;
            
            // 단어 수 세기
            std::istringstream lineStream(line);
            std::string word;
            while (lineStream >> word) {
                ++info.wordCount;
            }
        }
        
        return info;
    }
};

// 파일 작성 클래스
class SafeFileWriter {
public:
    static std::expected<void, FileOperationError> 
    writeContent(const std::string& filename, const std::string& content) {
        std::ofstream file(filename);
        
        if (!file) {
            return std::unexpected(FileOperationError::PermissionDenied);
        }
        
        file << content;
        
        if (file.fail()) {
            return std::unexpected(FileOperationError::IOError);
        }
        
        return {};
    }
    
    static std::expected<void, FileOperationError> 
    appendContent(const std::string& filename, const std::string& content) {
        std::ofstream file(filename, std::ios::app);
        
        if (!file) {
            return std::unexpected(FileOperationError::PermissionDenied);
        }
        
        file << content;
        
        if (file.fail()) {
            return std::unexpected(FileOperationError::IOError);
        }
        
        return {};
    }
};

int main() {
    const std::string testFile = "test_file.txt";
    
    // 파일 작성
    std::cout << "=== 파일 작성 ===\n";
    auto writeResult = SafeFileWriter::writeContent(testFile, 
        "첫 번째 줄\n두 번째 줄\n세 번째 줄\n");
    
    if (writeResult) {
        std::cout << "파일 작성 성공\n";
    } else {
        std::cout << "파일 작성 실패: " 
                  << errorToString(writeResult.error()) << '\n';
    }
    
    std::cout << "\n=== 파일 읽기 ===\n";
    auto content = SafeFileReader::readContent(testFile);
    
    if (content) {
        std::cout << "파일 내용:\n" << *content << '\n';
    } else {
        std::cout << "파일 읽기 실패: " 
                  << errorToString(content.error()) << '\n';
    }
    
    std::cout << "\n=== 특정 줄 읽기 ===\n";
    auto line = SafeFileReader::readLine(testFile, 1);
    if (line) {
        std::cout << "두 번째 줄: " << *line << '\n';
    } else {
        std::cout << "줄을 읽을 수 없다\n";
    }
    
    std::cout << "\n=== 파일 분석 ===\n";
    auto info = SafeFileReader::analyzeFile(testFile);
    
    if (info) {
        info->print();
    } else {
        std::cout << "파일 분석 실패: " 
                  << errorToString(info.error()) << '\n';
    }
    
    std::cout << "\n=== 존재하지 않는 파일 ===\n";
    auto nonExistent = SafeFileReader::readContent("nonexistent.txt");
    
    if (!nonExistent) {
        std::cout << "예상된 오류: " 
                  << errorToString(nonExistent.error()) << '\n';
    }
}
```
  
</br>  
</br>  


## 17.7 실습 문제

### 문제 1: 계산기 예외 처리
사칙연산을 수행하는 계산기 클래스를 작성하라. 0으로 나누기, 오버플로우 등의 오류를 적절한 예외로 처리해야 한다.

```cpp
// 요구사항:
// - add, subtract, multiply, divide 메서드 구현
// - 0으로 나누기 시 std::invalid_argument 던지기
// - 오버플로우 감지 및 처리
// - 사용자 정의 예외 클래스 사용
```

### 문제 2: 안전한 설정 관리자
`std::expected`를 사용하여 설정 파일을 관리하는 클래스를 작성하라.

```cpp
// 요구사항:
// - 설정 파일 로드 (키-값 형식)
// - 타입별로 값 읽기 (문자열, 정수, 실수)
// - 누락된 키, 잘못된 타입 등의 오류를 expected로 처리
// - 기본값 제공 기능
```

### 문제 3: 체인 가능한 파일 처리 파이프라인
`std::optional`과 함수형 프로그래밍 스타일을 결합하여 파일 처리 파이프라인을 만들어라.

```cpp
// 요구사항:
// - 파일 읽기 -> 변환 -> 필터링 -> 저장의 파이프라인
// - 각 단계에서 optional 반환
// - 메서드 체이닝 지원
```
  

</br>  
</br>  
  

## 17.8 심화 내용

### 17.8.1 RAII와 예외 안전성
RAII(Resource Acquisition Is Initialization)는 C++에서 예외 안전성을 보장하는 핵심 기법이다.

```cpp
#include <iostream>
#include <fstream>
#include <memory>
#include <mutex>

// 나쁜 예: 예외가 발생하면 리소스 누수
void badExample() {
    int* ptr = new int(42);
    
    // 여기서 예외가 발생하면?
    if (someCondition()) {
        throw std::runtime_error("오류 발생");
    }
    
    delete ptr;  // 실행되지 않을 수 있음!
}

// 좋은 예: RAII 사용
void goodExample() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    
    // 예외가 발생해도 ptr은 자동으로 정리된다
    if (someCondition()) {
        throw std::runtime_error("오류 발생");
    }
    
    // 명시적인 delete 불필요
}

// 파일 RAII 래퍼
class FileGuard {
private:
    std::ofstream file;
    
public:
    explicit FileGuard(const std::string& filename) : file(filename) {
        if (!file) {
            throw std::runtime_error("파일을 열 수 없다");
        }
    }
    
    ~FileGuard() {
        if (file.is_open()) {
            file.close();
            std::cout << "파일이 자동으로 닫혔다\n";
        }
    }
    
    void write(const std::string& text) {
        file << text;
        if (file.fail()) {
            throw std::runtime_error("쓰기 실패");
        }
    }
};

// 잠금 RAII 래퍼 (표준 라이브러리의 std::lock_guard와 유사)
class LockGuard {
private:
    std::mutex& mtx;
    
public:
    explicit LockGuard(std::mutex& m) : mtx(m) {
        mtx.lock();
        std::cout << "뮤텍스 잠금\n";
    }
    
    ~LockGuard() {
        mtx.unlock();
        std::cout << "뮤텍스 해제\n";
    }
    
    // 복사 방지
    LockGuard(const LockGuard&) = delete;
    LockGuard& operator=(const LockGuard&) = delete;
};

void demonstrateRAII() {
    try {
        FileGuard file("output.txt");
        file.write("첫 번째 줄\n");
        file.write("두 번째 줄\n");
        
        // 예외 발생해도 파일은 자동으로 닫힌다
        throw std::runtime_error("테스트 예외");
        
    } catch (const std::exception& e) {
        std::cout << "예외 처리: " << e.what() << '\n';
    }
}

int main() {
    demonstrateRAII();
}
```

### 17.8.2 예외 안전성 보장 수준
C++에서는 세 가지 수준의 예외 안전성을 정의한다.

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>

// 1. 기본 보장 (Basic Guarantee)
// - 예외가 발생해도 리소스 누수가 없다
// - 객체의 불변조건이 유지된다
class BasicSafe {
private:
    std::vector<int> data;
    
public:
    void addElement(int value) {
        data.push_back(value);  // 예외 발생 가능하지만 안전
    }
};

// 2. 강한 보장 (Strong Guarantee)
// - 예외가 발생하면 상태가 변경되지 않는다 (rollback)
class StrongSafe {
private:
    std::vector<int> data;
    
public:
    void addElements(const std::vector<int>& newData) {
        auto backup = data;  // 백업 생성
        
        try {
            for (int value : newData) {
                data.push_back(value);
            }
        } catch (...) {
            data = backup;  // 롤백
            throw;
        }
    }
    
    // copy-and-swap 관용구를 사용한 강한 보장
    void setData(const std::vector<int>& newData) {
        std::vector<int> temp(newData);  // 복사 (예외 발생 가능)
        data.swap(temp);                 // swap (예외 안전)
    }
};

// 3. 예외 없음 보장 (No-throw Guarantee)
// - 절대 예외를 던지지 않는다
class NoThrowSafe {
private:
    int value;
    
public:
    NoThrowSafe() noexcept : value(0) {}
    
    int getValue() const noexcept {
        return value;
    }
    
    void setValue(int v) noexcept {
        value = v;
    }
    
    void swap(NoThrowSafe& other) noexcept {
        std::swap(value, other.value);
    }
};

int main() {
    BasicSafe basic;
    basic.addElement(10);
    
    StrongSafe strong;
    strong.setData({1, 2, 3});
    
    NoThrowSafe noThrow;
    noThrow.setValue(42);
}
```

### 17.8.3 noexcept 지정자
`noexcept` 지정자는 함수가 예외를 던지지 않음을 명시한다.

```cpp
#include <iostream>
#include <vector>
#include <type_traits>

// noexcept 함수
void safeFunction() noexcept {
    // 예외를 던지지 않는 코드
}

// 조건부 noexcept
template <typename T>
void conditionalNoexcept(T value) noexcept(std::is_nothrow_copy_constructible_v<T>) {
    T copy = value;
}

// noexcept 이동 생성자와 이동 대입 연산자
class MoveOptimized {
private:
    std::vector<int> data;
    
public:
    MoveOptimized() = default;
    
    // 이동 생성자 (noexcept로 최적화)
    MoveOptimized(MoveOptimized&& other) noexcept 
        : data(std::move(other.data)) {}
    
    // 이동 대입 연산자 (noexcept로 최적화)
    MoveOptimized& operator=(MoveOptimized&& other) noexcept {
        data = std::move(other.data);
        return *this;
    }
};

// noexcept 검사
void demonstrateNoexcept() {
    std::cout << std::boolalpha;
    std::cout << "safeFunction은 noexcept인가? " 
              << noexcept(safeFunction()) << '\n';
    
    std::cout << "vector<int>의 이동 생성자는 noexcept인가? " 
              << std::is_nothrow_move_constructible_v<std::vector<int>> << '\n';
}

int main() {
    demonstrateNoexcept();
}
```

### 17.8.4 스택 풀기 (Stack Unwinding)
예외가 발생하면 스택이 풀리면서 지역 객체의 소멸자가 호출된다.

```cpp
#include <iostream>
#include <string>

class Tracer {
private:
    std::string name;
    
public:
    explicit Tracer(const std::string& n) : name(n) {
        std::cout << "[" << name << "] 생성자\n";
    }
    
    ~Tracer() {
        std::cout << "[" << name << "] 소멸자\n";
    }
};

void level3() {
    Tracer t("level3");
    std::cout << "level3 실행\n";
    throw std::runtime_error("level3에서 예외 발생");
}

void level2() {
    Tracer t("level2");
    std::cout << "level2 실행\n";
    level3();
    std::cout << "이 줄은 실행되지 않는다\n";
}

void level1() {
    Tracer t("level1");
    std::cout << "level1 실행\n";
    level2();
    std::cout << "이 줄은 실행되지 않는다\n";
}

int main() {
    try {
        Tracer t("main");
        level1();
    } catch (const std::exception& e) {
        std::cout << "\n예외 처리: " << e.what() << '\n';
    }
    
    std::cout << "\n프로그램 종료\n";
}
```
  
</br>  
</br>  
  

## 17.9 정리
이 장에서는 C++의 예외 처리와 Modern C++의 안전한 오류 처리 방법을 배웠다. 전통적인 `try-catch-throw` 메커니즘부터 C++17의 `std::optional`, C++23의 `std::expected`까지 다양한 오류 처리 도구를 살펴보았다.

**핵심 원칙:**
- 예외는 정말 예외적인 상황에만 사용한다
- 값이 없을 수 있는 정상적인 경우는 `std::optional`을 사용한다
- 오류 정보가 필요한 경우는 `std::expected`를 사용한다
- RAII를 활용하여 예외 안전성을 보장한다
- `noexcept`를 적절히 사용하여 최적화한다

Modern C++의 오류 처리 도구를 잘 활용하면 안전하고 명확한 코드를 작성할 수 있다. 다음 장부터는 Siv3D를 사용하여 실제로 동작하는 GUI 프로그램을 만들면서 배운 내용을 실전에 적용해본다.  