# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 24: 프로젝트 1 - 간단한 퍼즐 게임

이번 장에서는 지금까지 배운 Modern C++의 기능들과 Siv3D를 활용하여 실제 동작하는 퍼즐 게임을 만들어본다. 슬라이딩 퍼즐(15 퍼즐)을 구현하면서 게임 로직, 상태 관리, UI 구현, 데이터 저장 등 실무에서 필요한 기술들을 종합적으로 활용한다.

## 24.1 게임 기획과 요구사항 분석

### 24.1.1 슬라이딩 퍼즐이란?

슬라이딩 퍼즐은 정사각형 격자 안에 번호가 매겨진 타일들이 있고, 한 칸의 빈 공간을 이용해 타일을 이동시켜 순서대로 배열하는 퍼즐이다. 우리는 4×4 크기의 15 퍼즐을 구현한다.

![슬라이딩 퍼즐 개념도]
```
초기 상태 (섞인 상태)          목표 상태
┌────┬────┬────┬────┐      ┌────┬────┬────┬────┐
│  5 │  2 │  3 │  4 │      │  1 │  2 │  3 │  4 │
├────┼────┼────┼────┤      ├────┼────┼────┼────┤
│  1 │  6 │  7 │  8 │      │  5 │  6 │  7 │  8 │
├────┼────┼────┼────┤      ├────┼────┼────┼────┤
│  9 │ 10 │ 11 │ 12 │      │  9 │ 10 │ 11 │ 12 │
├────┼────┼────┼────┤      ├────┼────┼────┼────┤
│ 13 │ 14 │    │ 15 │      │ 13 │ 14 │ 15 │    │
└────┴────┴────┴────┘      └────┴────┴────┴────┘
```

### 24.1.2 게임 요구사항

우리가 만들 퍼즐 게임은 다음과 같은 기능을 갖춘다:

**핵심 기능:**
- 4×4 격자의 타일 배치 및 표시
- 마우스 클릭으로 타일 이동
- 타일 섞기 기능
- 게임 완성 감지
- 이동 횟수 기록

**부가 기능:**
- 타이머 표시
- 최고 기록 저장 및 표시
- 게임 리셋 버튼
- 시각적 피드백 (애니메이션, 효과음)

### 24.1.3 프로젝트 구조 설계

프로젝트를 시작하기 전에 코드를 어떻게 구조화할지 계획한다. Modern C++의 장점을 활용하여 깔끔하고 유지보수하기 쉬운 코드를 작성한다.

**주요 컴포넌트:**
- `PuzzleGame` 클래스: 게임의 전체 로직을 담당
- `Tile` 구조체: 개별 타일의 정보를 저장
- 게임 상태 관리: `enum class`를 활용한 상태 머신
- UI 컴포넌트: 버튼, 점수판 등

## 24.2 게임 상태 관리 (`enum class` 활용)

### 24.2.1 게임 상태 정의

게임은 여러 상태를 가질 수 있다. Modern C++의 `enum class`를 사용하면 타입 안전성을 보장하면서 명확하게 상태를 관리할 수 있다.

```cpp
// GameState.h
#pragma once

enum class GameState
{
    Title,      // 타이틀 화면
    Playing,    // 게임 진행 중
    Completed,  // 게임 완성
    Paused      // 일시 정지
};
```

`enum class`를 사용하면 일반 `enum`과 달리 다음과 같은 장점이 있다:
- 네임스페이스 오염 방지 (`GameState::Playing`으로 명시적 사용)
- 암시적 타입 변환 방지 (더 안전한 코드)
- 강한 타입 검사 (컴파일 시간에 오류 발견)

### 24.2.2 타일 데이터 구조

각 타일의 정보를 저장할 구조체를 정의한다. Modern C++의 기본값 멤버 초기화를 활용한다.

```cpp
// Tile.h
#pragma once
#include <Siv3D.hpp>

struct Tile
{
    int32 number = 0;           // 타일 번호 (0은 빈 칸)
    Point position{ 0, 0 };     // 격자상의 위치
    Vec2 displayPos{ 0, 0 };    // 실제 화면 표시 위치 (애니메이션용)
    
    bool isEmpty() const
    {
        return number == 0;
    }
};
```

기본값 멤버 초기화를 사용하면 생성자를 별도로 작성하지 않아도 안전하게 초기화된 객체를 얻을 수 있다.

### 24.2.3 게임 설정 상수

게임에서 사용할 상수들을 `constexpr`로 정의한다. `constexpr`을 사용하면 컴파일 시간에 값이 결정되어 실행 시간 오버헤드가 없다.

```cpp
// GameConfig.h
#pragma once
#include <Siv3D.hpp>

namespace GameConfig
{
    // 격자 설정
    constexpr int32 GridSize = 4;
    constexpr int32 TileCount = GridSize * GridSize;
    
    // 화면 레이아웃
    constexpr int32 TileSize = 100;
    constexpr int32 TileMargin = 5;
    constexpr int32 BoardOffsetX = 100;
    constexpr int32 BoardOffsetY = 150;
    
    // 색상
    const ColorF BackgroundColor{ 0.9, 0.9, 0.95 };
    const ColorF TileColor{ 0.3, 0.6, 0.9 };
    const ColorF EmptyTileColor{ 0.95, 0.95, 0.95 };
    const ColorF TextColor{ 1.0, 1.0, 1.0 };
    
    // 애니메이션
    constexpr double TileMoveDuration = 0.15;
    
    // 게임 설정
    constexpr int32 ShuffleMoves = 100;
}
```

네임스페이스를 사용하여 관련된 상수들을 논리적으로 그룹화했다.

## 24.3 PuzzleGame 클래스 구현

### 24.3.1 클래스 설계

게임의 핵심 로직을 담당하는 `PuzzleGame` 클래스를 설계한다. Modern C++의 기능들을 최대한 활용한다.

```cpp
// PuzzleGame.h
#pragma once
#include <Siv3D.hpp>
#include "GameState.h"
#include "Tile.h"
#include "GameConfig.h"
#include <array>
#include <optional>

class PuzzleGame
{
public:
    PuzzleGame();
    
    void update();
    void draw() const;
    
private:
    // 게임 상태
    GameState m_state = GameState::Title;
    std::array<Tile, GameConfig::TileCount> m_tiles;
    Point m_emptyPos{ 3, 3 };
    
    // 게임 기록
    int32 m_moveCount = 0;
    double m_elapsedTime = 0.0;
    int32 m_bestMoves = std::numeric_limits<int32>::max();
    
    // 타이머
    Stopwatch m_stopwatch;
    
    // 초기화 및 게임 로직
    void initializeTiles();
    void shuffleTiles();
    bool isSolved() const;
    
    // 타일 이동
    std::optional<Point> getTileAt(Point screenPos) const;
    bool canMoveTile(Point tilePos) const;
    void moveTile(Point tilePos);
    
    // UI 업데이트
    void updateTitle();
    void updatePlaying();
    void updateCompleted();
    
    // 렌더링
    void drawTitle() const;
    void drawGame() const;
    void drawTile(const Tile& tile) const;
    void drawUI() const;
    void drawCompleted() const;
    
    // 데이터 저장/로드
    void saveRecord();
    void loadRecord();
};
```

클래스 멤버 변수에 대해 살펴보자:

**`std::array` 사용**: 고정 크기 배열은 `std::array`를 사용한다. C 스타일 배열보다 안전하고 `std::vector`보다 효율적이다.

**`std::optional` 사용**: 값이 없을 수 있는 경우 `std::optional`을 사용한다. 포인터나 특수값(-1 등)을 사용하는 것보다 의도가 명확하다.

**멤버 변수 초기화**: 클래스 정의에서 직접 초기화하여 안전성을 높인다.

### 24.3.2 생성자와 초기화

```cpp
// PuzzleGame.cpp
#include "PuzzleGame.h"

PuzzleGame::PuzzleGame()
{
    // 타일 초기화
    initializeTiles();
    
    // 최고 기록 불러오기
    loadRecord();
}

void PuzzleGame::initializeTiles()
{
    int32 number = 1;
    
    for (int32 y = 0; y < GameConfig::GridSize; ++y)
    {
        for (int32 x = 0; x < GameConfig::GridSize; ++x)
        {
            const int32 index = y * GameConfig::GridSize + x;
            
            m_tiles[index].position = Point{ x, y };
            m_tiles[index].number = number;
            
            // 화면 표시 위치 계산
            m_tiles[index].displayPos = Vec2{
                GameConfig::BoardOffsetX + x * (GameConfig::TileSize + GameConfig::TileMargin),
                GameConfig::BoardOffsetY + y * (GameConfig::TileSize + GameConfig::TileMargin)
            };
            
            // 마지막 타일은 빈 칸으로
            if (x == GameConfig::GridSize - 1 && y == GameConfig::GridSize - 1)
            {
                m_tiles[index].number = 0;
                m_emptyPos = Point{ x, y };
            }
            else
            {
                ++number;
            }
        }
    }
}
```

초기화 함수에서는 모든 타일을 정렬된 상태로 배치한다. 범위 기반 for 문 대신 인덱스를 사용한 이유는 2차원 격자의 x, y 좌표가 필요하기 때문이다.

### 24.3.3 타일 섞기 알고리즘

단순히 타일을 무작위로 배치하면 풀 수 없는 상태가 될 수 있다. 해결 가능한 상태를 보장하기 위해 유효한 이동만을 반복하여 타일을 섞는다.

```cpp
void PuzzleGame::shuffleTiles()
{
    // Fisher-Yates 셔플 대신 유효한 이동만 반복
    Random rng{ RandomDeviceSeed() };
    
    for (int32 i = 0; i < GameConfig::ShuffleMoves; ++i)
    {
        // 빈 칸에 인접한 타일들의 위치 찾기
        std::vector<Point> adjacentTiles;
        
        const std::array<Point, 4> directions = {
            Point{ 0, -1 },  // 위
            Point{ 0, 1 },   // 아래
            Point{ -1, 0 },  // 왼쪽
            Point{ 1, 0 }    // 오른쪽
        };
        
        for (const auto& dir : directions)
        {
            const Point neighborPos = m_emptyPos + dir;
            
            if (neighborPos.x >= 0 && neighborPos.x < GameConfig::GridSize &&
                neighborPos.y >= 0 && neighborPos.y < GameConfig::GridSize)
            {
                adjacentTiles.push_back(neighborPos);
            }
        }
        
        // 인접한 타일 중 하나를 무작위로 선택하여 이동
        if (not adjacentTiles.empty())
        {
            const Point selectedTile = adjacentTiles[rng(adjacentTiles.size())];
            moveTile(selectedTile);
        }
    }
    
    // 게임 시작
    m_state = GameState::Playing;
    m_moveCount = 0;
    m_elapsedTime = 0.0;
    m_stopwatch.restart();
}
```

이 알고리즘은 다음과 같은 장점이 있다:
- 항상 풀 수 있는 상태를 보장한다
- 구현이 간단하다
- 충분히 섞인 상태를 만들어낸다

`std::array`를 사용하여 방향 벡터를 저장했다. 고정된 크기이므로 `std::array`가 적합하다.

### 24.3.4 타일 이동 로직

```cpp
std::optional<Point> PuzzleGame::getTileAt(Point screenPos) const
{
    for (const auto& tile : m_tiles)
    {
        if (tile.isEmpty())
            continue;
            
        const RectF tileRect{
            tile.displayPos,
            GameConfig::TileSize,
            GameConfig::TileSize
        };
        
        if (tileRect.contains(screenPos))
        {
            return tile.position;
        }
    }
    
    return std::nullopt;  // 타일을 찾지 못함
}

bool PuzzleGame::canMoveTile(Point tilePos) const
{
    // 빈 칸과 인접해 있는지 확인
    const int32 dx = Math::Abs(tilePos.x - m_emptyPos.x);
    const int32 dy = Math::Abs(tilePos.y - m_emptyPos.y);
    
    // 같은 행 또는 같은 열에 있고, 한 칸 떨어져 있어야 함
    return (dx == 1 && dy == 0) || (dx == 0 && dy == 1);
}

void PuzzleGame::moveTile(Point tilePos)
{
    if (not canMoveTile(tilePos))
        return;
    
    // 타일 찾기
    auto it = std::find_if(m_tiles.begin(), m_tiles.end(),
        [tilePos](const Tile& tile) {
            return tile.position == tilePos;
        });
    
    if (it == m_tiles.end())
        return;
    
    // 타일과 빈 칸의 위치 교환
    const Point oldEmptyPos = m_emptyPos;
    m_emptyPos = it->position;
    it->position = oldEmptyPos;
    
    // 화면 표시 위치 업데이트
    it->displayPos = Vec2{
        GameConfig::BoardOffsetX + oldEmptyPos.x * (GameConfig::TileSize + GameConfig::TileMargin),
        GameConfig::BoardOffsetY + oldEmptyPos.y * (GameConfig::TileSize + GameConfig::TileMargin)
    };
    
    // 이동 횟수 증가 (게임 플레이 중일 때만)
    if (m_state == GameState::Playing)
    {
        ++m_moveCount;
        
        // 완성 여부 확인
        if (isSolved())
        {
            m_state = GameState::Completed;
            m_stopwatch.pause();
            
            // 최고 기록 갱신
            if (m_moveCount < m_bestMoves)
            {
                m_bestMoves = m_moveCount;
                saveRecord();
            }
        }
    }
}
```

`std::optional`을 반환하는 `getTileAt()` 함수는 타일을 찾지 못했을 때 명확하게 표현한다. `std::find_if()` 알고리즘과 람다 표현식을 사용하여 특정 조건을 만족하는 타일을 찾는다.

### 24.3.5 게임 완성 감지

```cpp
bool PuzzleGame::isSolved() const
{
    int32 expectedNumber = 1;
    
    for (int32 y = 0; y < GameConfig::GridSize; ++y)
    {
        for (int32 x = 0; x < GameConfig::GridSize; ++x)
        {
            const int32 index = y * GameConfig::GridSize + x;
            
            // 마지막 칸은 빈 칸이어야 함
            if (x == GameConfig::GridSize - 1 && y == GameConfig::GridSize - 1)
            {
                return m_tiles[index].isEmpty();
            }
            
            // 나머지 칸은 순서대로 배열되어야 함
            if (m_tiles[index].number != expectedNumber)
            {
                return false;
            }
            
            ++expectedNumber;
        }
    }
    
    return true;
}
```

## 24.4 사용자 인터페이스 구현

### 24.4.1 메인 업데이트 루프

```cpp
void PuzzleGame::update()
{
    switch (m_state)
    {
    case GameState::Title:
        updateTitle();
        break;
        
    case GameState::Playing:
        updatePlaying();
        break;
        
    case GameState::Completed:
        updateCompleted();
        break;
        
    default:
        break;
    }
}

void PuzzleGame::updateTitle()
{
    // 시작 버튼 영역
    const RectF startButton{
        300, 400, 200, 60
    };
    
    if (startButton.leftClicked())
    {
        shuffleTiles();
    }
}

void PuzzleGame::updatePlaying()
{
    // 경과 시간 업데이트
    m_elapsedTime = m_stopwatch.sF();
    
    // 마우스 클릭 처리
    if (MouseL.down())
    {
        const auto tilePos = getTileAt(Cursor::Pos());
        
        if (tilePos.has_value())
        {
            moveTile(tilePos.value());
        }
    }
    
    // 리셋 버튼
    const RectF resetButton{
        600, 50, 150, 50
    };
    
    if (resetButton.leftClicked())
    {
        shuffleTiles();
    }
}

void PuzzleGame::updateCompleted()
{
    // 새 게임 버튼
    const RectF newGameButton{
        300, 500, 200, 60
    };
    
    if (newGameButton.leftClicked())
    {
        shuffleTiles();
    }
}
```

상태 패턴을 사용하여 게임 상태에 따라 다른 업데이트 로직을 실행한다. `switch` 문에서 `enum class`를 사용하면 컴파일러가 모든 케이스를 처리했는지 검사해준다.

### 24.4.2 렌더링 구현

```cpp
void PuzzleGame::draw() const
{
    // 배경
    Scene::SetBackground(GameConfig::BackgroundColor);
    
    switch (m_state)
    {
    case GameState::Title:
        drawTitle();
        break;
        
    case GameState::Playing:
        drawGame();
        break;
        
    case GameState::Completed:
        drawGame();
        drawCompleted();
        break;
        
    default:
        break;
    }
}

void PuzzleGame::drawTitle() const
{
    // 제목
    const Font titleFont{ FontMethod::MSDF, 60, Typeface::Bold };
    titleFont(U"슬라이딩 퍼즐").drawAt(400, 200, ColorF{ 0.2, 0.4, 0.7 });
    
    // 설명
    const Font descFont{ 20 };
    descFont(U"타일을 클릭하여 빈 칸으로 이동시키세요").drawAt(400, 300, ColorF{ 0.4 });
    descFont(U"모든 숫자를 순서대로 배열하면 승리!").drawAt(400, 330, ColorF{ 0.4 });
    
    // 시작 버튼
    const RectF startButton{ 300, 400, 200, 60 };
    startButton.draw(ColorF{ 0.3, 0.6, 0.9 });
    
    if (startButton.mouseOver())
    {
        startButton.draw(ColorF{ 0.4, 0.7, 1.0 });
    }
    
    const Font buttonFont{ 30, Typeface::Bold };
    buttonFont(U"게임 시작").drawAt(startButton.center(), ColorF{ 1.0 });
    
    // 최고 기록
    if (m_bestMoves != std::numeric_limits<int32>::max())
    {
        const Font recordFont{ 24 };
        recordFont(U"최고 기록: {} 이동", m_bestMoves)
            .drawAt(400, 550, ColorF{ 0.3, 0.6, 0.3 });
    }
}

void PuzzleGame::drawGame() const
{
    // 타이틀
    const Font titleFont{ FontMethod::MSDF, 40, Typeface::Bold };
    titleFont(U"슬라이딩 퍼즐").drawAt(400, 50, ColorF{ 0.2, 0.4, 0.7 });
    
    // UI 정보
    drawUI();
    
    // 타일들 그리기
    for (const auto& tile : m_tiles)
    {
        drawTile(tile);
    }
}

void PuzzleGame::drawTile(const Tile& tile) const
{
    if (tile.isEmpty())
    {
        // 빈 칸 표시
        const RectF tileRect{ tile.displayPos, GameConfig::TileSize };
        tileRect.draw(GameConfig::EmptyTileColor);
        tileRect.drawFrame(2, ColorF{ 0.8 });
    }
    else
    {
        // 타일 그리기
        const RectF tileRect{ tile.displayPos, GameConfig::TileSize };
        
        // 마우스 오버 효과
        ColorF tileColor = GameConfig::TileColor;
        if (tileRect.mouseOver() && canMoveTile(tile.position))
        {
            tileColor = ColorF{ 0.4, 0.7, 1.0 };
        }
        
        tileRect.rounded(8).draw(tileColor);
        tileRect.rounded(8).drawFrame(3, ColorF{ 0.2, 0.5, 0.8 });
        
        // 숫자 표시
        const Font numberFont{ FontMethod::MSDF, 48, Typeface::Bold };
        numberFont(tile.number).drawAt(
            tileRect.center(),
            GameConfig::TextColor
        );
    }
}

void PuzzleGame::drawUI() const
{
    const Font uiFont{ 24 };
    
    // 이동 횟수
    uiFont(U"이동: {}", m_moveCount).draw(20, 20, ColorF{ 0.3 });
    
    // 경과 시간
    const int32 minutes = static_cast<int32>(m_elapsedTime) / 60;
    const int32 seconds = static_cast<int32>(m_elapsedTime) % 60;
    uiFont(U"시간: {:02d}:{:02d}", minutes, seconds).draw(20, 60, ColorF{ 0.3 });
    
    // 최고 기록
    if (m_bestMoves != std::numeric_limits<int32>::max())
    {
        uiFont(U"최고: {}", m_bestMoves).draw(20, 100, ColorF{ 0.3, 0.6, 0.3 });
    }
    
    // 리셋 버튼
    const RectF resetButton{ 600, 50, 150, 50 };
    resetButton.rounded(8).draw(ColorF{ 0.9, 0.4, 0.4 });
    
    if (resetButton.mouseOver())
    {
        resetButton.rounded(8).draw(ColorF{ 1.0, 0.5, 0.5 });
    }
    
    const Font buttonFont{ 24, Typeface::Bold };
    buttonFont(U"다시 섞기").drawAt(resetButton.center(), ColorF{ 1.0 });
}

void PuzzleGame::drawCompleted() const
{
    // 반투명 오버레이
    Scene::Rect().draw(ColorF{ 0, 0, 0, 0.7 });
    
    // 완성 메시지
    const Font titleFont{ FontMethod::MSDF, 60, Typeface::Bold };
    titleFont(U"완성!").drawAt(400, 250, ColorF{ 1.0, 0.8, 0.0 });
    
    const Font infoFont{ 30 };
    infoFont(U"이동 횟수: {}", m_moveCount).drawAt(400, 350, ColorF{ 1.0 });
    
    const int32 minutes = static_cast<int32>(m_elapsedTime) / 60;
    const int32 seconds = static_cast<int32>(m_elapsedTime) % 60;
    infoFont(U"소요 시간: {:02d}:{:02d}", minutes, seconds)
        .drawAt(400, 390, ColorF{ 1.0 });
    
    // 새로운 기록인 경우
    if (m_moveCount == m_bestMoves)
    {
        const Font recordFont{ 28, Typeface::Bold };
        recordFont(U"★ 새로운 기록! ★").drawAt(400, 440, ColorF{ 1.0, 0.5, 0.0 });
    }
    
    // 새 게임 버튼
    const RectF newGameButton{ 300, 500, 200, 60 };
    newGameButton.rounded(8).draw(ColorF{ 0.3, 0.6, 0.9 });
    
    if (newGameButton.mouseOver())
    {
        newGameButton.rounded(8).draw(ColorF{ 0.4, 0.7, 1.0 });
    }
    
    const Font buttonFont{ 30, Typeface::Bold };
    buttonFont(U"새 게임").drawAt(newGameButton.center(), ColorF{ 1.0 });
}
```

렌더링 코드는 `const` 멤버 함수로 작성하여 게임 상태를 변경하지 않음을 명시한다. Siv3D의 다양한 그래픽 기능을 활용하여 시각적으로 매력적인 UI를 만든다.

## 24.5 점수 시스템과 데이터 저장

### 24.5.1 JSON을 활용한 데이터 저장

Modern C++에서는 구조화된 데이터를 JSON 형식으로 저장하는 것이 일반적이다. Siv3D는 JSON 파싱과 생성을 지원한다.

```cpp
void PuzzleGame::saveRecord()
{
    // JSON 객체 생성
    JSON json;
    json[U"best_moves"] = m_bestMoves;
    json[U"last_updated"] = DateTime::Now().format(U"yyyy-MM-dd HH:mm:ss");
    
    // 파일에 저장
    json.save(U"puzzle_record.json");
}

void PuzzleGame::loadRecord()
{
    // JSON 파일 읽기
    const JSON json = JSON::Load(U"puzzle_record.json");
    
    if (not json)
    {
        // 파일이 없거나 읽기 실패
        m_bestMoves = std::numeric_limits<int32>::max();
        return;
    }
    
    // 데이터 로드
    m_bestMoves = json[U"best_moves"].get<int32>();
}
```

`JSON::Load()`는 파일이 없거나 형식이 잘못된 경우 빈 JSON 객체를 반환한다. 이를 `if (not json)`으로 확인하여 안전하게 처리한다.

### 24.5.2 확장된 기록 시스템

더 복잡한 기록 시스템이 필요하다면 구조체를 사용하여 데이터를 구조화할 수 있다.

```cpp
struct GameRecord
{
    int32 moves = 0;
    double time = 0.0;
    String date;
    
    // JSON 변환
    void write(JSON& json) const
    {
        json[U"moves"] = moves;
        json[U"time"] = time;
        json[U"date"] = date;
    }
    
    void read(const JSON& json)
    {
        moves = json[U"moves"].get<int32>();
        time = json[U"time"].get<double>();
        date = json[U"date"].getOr<String>(U"");
    }
};

class PuzzleGame
{
private:
    std::vector<GameRecord> m_records;
    static constexpr int32 MaxRecords = 10;
    
    void saveRecords()
    {
        JSON json;
        
        for (size_t i = 0; i < m_records.size(); ++i)
        {
            JSON recordJson;
            m_records[i].write(recordJson);
            json[U"records"][i] = recordJson;
        }
        
        json.save(U"puzzle_records.json");
    }
    
    void loadRecords()
    {
        const JSON json = JSON::Load(U"puzzle_records.json");
        
        if (not json)
            return;
        
        const auto& recordsArray = json[U"records"];
        
        for (const auto& recordJson : recordsArray.arrayView())
        {
            GameRecord record;
            record.read(recordJson);
            m_records.push_back(record);
        }
        
        // 이동 횟수 기준으로 정렬
        std::sort(m_records.begin(), m_records.end(),
            [](const GameRecord& a, const GameRecord& b) {
                return a.moves < b.moves;
            });
        
        // 최대 개수 유지
        if (m_records.size() > MaxRecords)
        {
            m_records.resize(MaxRecords);
        }
    }
    
    void addRecord(int32 moves, double time)
    {
        GameRecord newRecord;
        newRecord.moves = moves;
        newRecord.time = time;
        newRecord.date = DateTime::Now().format(U"yyyy-MM-dd HH:mm:ss");
        
        m_records.push_back(newRecord);
        
        // 정렬 및 최대 개수 유지
        std::sort(m_records.begin(), m_records.end(),
            [](const GameRecord& a, const GameRecord& b) {
                return a.moves < b.moves;
            });
        
        if (m_records.size() > MaxRecords)
        {
            m_records.resize(MaxRecords);
        }
        
        saveRecords();
    }
};
```

`std::sort()`와 람다 표현식을 사용하여 기록을 정렬한다. `std::vector`의 `resize()` 메서드로 최대 개수를 유지한다.

### 24.5.3 통계 정보 표시

저장된 기록을 바탕으로 통계 정보를 표시하는 기능을 추가한다.

```cpp
void PuzzleGame::drawStatistics() const
{
    if (m_records.empty())
        return;
    
    const Font titleFont{ 32, Typeface::Bold };
    const Font dataFont{ 24 };
    
    titleFont(U"기록 순위").draw(600, 200, ColorF{ 0.3 });
    
    int32 rank = 1;
    double yPos = 250;
    
    for (const auto& record : m_records)
    {
        const int32 minutes = static_cast<int32>(record.time) / 60;
        const int32 seconds = static_cast<int32>(record.time) % 60;
        
        dataFont(U"{}. {} 이동 ({:02d}:{:02d}) - {}",
            rank,
            record.moves,
            minutes,
            seconds,
            record.date
        ).draw(610, yPos, ColorF{ 0.4 });
        
        ++rank;
        yPos += 35;
        
        if (rank > 5)  // 상위 5개만 표시
            break;
    }
}
```

## 24.6 추가 기능과 개선사항

### 24.6.1 애니메이션 효과

타일 이동 시 부드러운 애니메이션을 추가하면 사용자 경험이 향상된다.

```cpp
class PuzzleGame
{
private:
    struct TileAnimation
    {
        size_t tileIndex;
        Vec2 startPos;
        Vec2 endPos;
        Stopwatch timer;
    };
    
    std::optional<TileAnimation> m_currentAnimation;
    
    void moveTile(Point tilePos)
    {
        if (not canMoveTile(tilePos))
            return;
        
        auto it = std::find_if(m_tiles.begin(), m_tiles.end(),
            [tilePos](const Tile& tile) {
                return tile.position == tilePos;
            });
        
        if (it == m_tiles.end())
            return;
        
        // 애니메이션 설정
        const size_t tileIndex = std::distance(m_tiles.begin(), it);
        const Vec2 startPos = it->displayPos;
        const Vec2 endPos{
            GameConfig::BoardOffsetX + m_emptyPos.x * (GameConfig::TileSize + GameConfig::TileMargin),
            GameConfig::BoardOffsetY + m_emptyPos.y * (GameConfig::TileSize + GameConfig::TileMargin)
        };
        
        m_currentAnimation = TileAnimation{
            tileIndex,
            startPos,
            endPos,
            Stopwatch{ StartImmediately::Yes }
        };
        
        // 위치 업데이트
        const Point oldEmptyPos = m_emptyPos;
        m_emptyPos = it->position;
        it->position = oldEmptyPos;
        
        ++m_moveCount;
    }
    
    void updateAnimation()
    {
        if (not m_currentAnimation.has_value())
            return;
        
        auto& anim = m_currentAnimation.value();
        const double t = Math::Saturate(anim.timer.sF() / GameConfig::TileMoveDuration);
        
        // Ease Out 함수 사용
        const double easedT = 1.0 - Math::Pow(1.0 - t, 3.0);
        
        m_tiles[anim.tileIndex].displayPos = 
            anim.startPos.lerp(anim.endPos, easedT);
        
        // 애니메이션 완료
        if (t >= 1.0)
        {
            m_tiles[anim.tileIndex].displayPos = anim.endPos;
            m_currentAnimation = std::nullopt;
            
            // 완성 확인
            if (isSolved())
            {
                m_state = GameState::Completed;
                m_stopwatch.pause();
                
                if (m_moveCount < m_bestMoves)
                {
                    m_bestMoves = m_moveCount;
                    saveRecord();
                }
            }
        }
    }
};
```

`std::optional`을 사용하여 애니메이션이 진행 중인지 여부를 명확하게 표현한다. `lerp()` 함수로 선형 보간을 하고, Ease Out 함수로 자연스러운 감속 효과를 적용한다.

### 24.6.2 효과음 추가

```cpp
class PuzzleGame
{
private:
    Audio m_moveSE{ U"assets/move.mp3" };
    Audio m_completeSE{ U"assets/complete.mp3" };
    
    void moveTile(Point tilePos)
    {
        // ... 기존 코드 ...
        
        // 효과음 재생
        m_moveSE.playOneShot(0.5);
    }
    
    void updateAnimation()
    {
        // ... 기존 코드 ...
        
        if (isSolved())
        {
            m_state = GameState::Completed;
            m_completeSE.playOneShot(0.7);
            
            // ... 기존 코드 ...
        }
    }
};
```

### 24.6.3 난이도 선택

```cpp
enum class Difficulty
{
    Easy,    // 3x3
    Normal,  // 4x4
    Hard     // 5x5
};

class PuzzleGame
{
private:
    Difficulty m_difficulty = Difficulty::Normal;
    
    int32 getGridSize() const
    {
        switch (m_difficulty)
        {
        case Difficulty::Easy:
            return 3;
        case Difficulty::Normal:
            return 4;
        case Difficulty::Hard:
            return 5;
        default:
            return 4;
        }
    }
    
    void setDifficulty(Difficulty difficulty)
    {
        m_difficulty = difficulty;
        
        // 타일 크기 조정
        const int32 gridSize = getGridSize();
        const int32 totalBoardSize = 500;
        const int32 tileSize = (totalBoardSize - (gridSize + 1) * GameConfig::TileMargin) / gridSize;
        
        // 타일 재초기화
        m_tiles.clear();
        m_tiles.resize(gridSize * gridSize);
        initializeTiles();
    }
};
```

## 24.7 메인 함수 작성

모든 구성 요소를 합쳐 완전한 프로그램을 만든다.

```cpp
// Main.cpp
#include <Siv3D.hpp>
#include "PuzzleGame.h"

void Main()
{
    // 윈도우 설정
    Window::SetTitle(U"슬라이딩 퍼즐 게임");
    Window::Resize(800, 700);
    Scene::SetBackground(ColorF{ 0.9, 0.9, 0.95 });
    
    // 게임 객체 생성
    PuzzleGame game;
    
    // 메인 루프
    while (System::Update())
    {
        game.update();
        game.draw();
    }
}
```

간결하고 명확한 메인 함수다. 모든 복잡한 로직은 `PuzzleGame` 클래스 내부에 캡슐화되어 있다.

## 24.8 실습 문제

### 기본 실습

1. **힌트 기능 추가**: 다음에 이동할 타일을 하이라이트로 표시하는 기능을 구현하라.

2. **실행 취소 기능**: 최근 3번의 이동을 취소할 수 있는 기능을 `std::deque`를 사용하여 구현하라.

3. **타이머 일시정지**: 게임 중 일시정지 기능을 추가하라.

### 중급 실습

4. **이미지 퍼즐**: 숫자 대신 이미지를 조각내어 퍼즐을 만드는 기능을 구현하라.

5. **자동 풀이**: A* 알고리즘을 사용하여 자동으로 퍼즐을 푸는 기능을 구현하라.

6. **멀티플레이어**: 두 명의 플레이어가 같은 퍼즐을 동시에 풀 수 있도록 화면 분할 모드를 구현하라.

### 고급 실습

7. **성과 시스템**: "50회 이하로 완성", "3분 이내 완성" 등의 업적 시스템을 구현하라.

8. **리플레이 기능**: 게임 진행 과정을 녹화하고 다시 재생하는 기능을 구현하라.

9. **온라인 순위표**: 웹 API를 사용하여 전 세계 플레이어들과 점수를 공유하는 시스템을 구현하라.

## 24.9 심화 내용: 디자인 패턴 적용

### 24.9.1 상태 패턴 (State Pattern)

현재 코드는 `switch` 문으로 상태를 관리하지만, 상태 패턴을 사용하면 더 확장 가능한 구조를 만들 수 있다.

```cpp
// IGameState.h
class IGameState
{
public:
    virtual ~IGameState() = default;
    
    virtual void update(PuzzleGame& game) = 0;
    virtual void draw(const PuzzleGame& game) const = 0;
    virtual void enter(PuzzleGame& game) = 0;
    virtual void exit(PuzzleGame& game) = 0;
};

// TitleState.h
class TitleState : public IGameState
{
public:
    void update(PuzzleGame& game) override
    {
        const RectF startButton{ 300, 400, 200, 60 };
        
        if (startButton.leftClicked())
        {
            game.changeState(std::make_unique<PlayingState>());
        }
    }
    
    void draw(const PuzzleGame& game) const override
    {
        // 타이틀 화면 그리기
    }
    
    void enter(PuzzleGame& game) override
    {
        // 타이틀 상태 진입 시 초기화
    }
    
    void exit(PuzzleGame& game) override
    {
        // 타이틀 상태 종료 시 정리
    }
};

// PuzzleGame.h (수정)
class PuzzleGame
{
private:
    std::unique_ptr<IGameState> m_currentState;
    
public:
    void changeState(std::unique_ptr<IGameState> newState)
    {
        if (m_currentState)
        {
            m_currentState->exit(*this);
        }
        
        m_currentState = std::move(newState);
        
        if (m_currentState)
        {
            m_currentState->enter(*this);
        }
    }
    
    void update()
    {
        if (m_currentState)
        {
            m_currentState->update(*this);
        }
    }
    
    void draw() const
    {
        if (m_currentState)
        {
            m_currentState->draw(*this);
        }
    }
};
```

상태 패턴의 장점:
- 각 상태의 로직이 별도 클래스로 분리되어 관리하기 쉽다
- 새로운 상태를 추가할 때 기존 코드를 수정하지 않는다
- 상태 전환 로직이 명확하다

### 24.9.2 명령 패턴 (Command Pattern)

실행 취소 기능을 구현하기 위해 명령 패턴을 사용한다.

```cpp
// ICommand.h
class ICommand
{
public:
    virtual ~ICommand() = default;
    
    virtual void execute() = 0;
    virtual void undo() = 0;
};

// MoveTileCommand.h
class MoveTileCommand : public ICommand
{
private:
    PuzzleGame& m_game;
    Point m_tilePos;
    Point m_oldEmptyPos;
    
public:
    MoveTileCommand(PuzzleGame& game, Point tilePos)
        : m_game{ game }
        , m_tilePos{ tilePos }
        , m_oldEmptyPos{ game.getEmptyPos() }
    {
    }
    
    void execute() override
    {
        m_game.moveTileInternal(m_tilePos);
    }
    
    void undo() override
    {
        m_game.moveTileInternal(m_oldEmptyPos);
    }
};

// PuzzleGame.h (수정)
class PuzzleGame
{
private:
    std::deque<std::unique_ptr<ICommand>> m_commandHistory;
    static constexpr size_t MaxHistorySize = 100;
    
public:
    void executeCommand(std::unique_ptr<ICommand> command)
    {
        command->execute();
        
        m_commandHistory.push_back(std::move(command));
        
        // 히스토리 크기 제한
        if (m_commandHistory.size() > MaxHistorySize)
        {
            m_commandHistory.pop_front();
        }
    }
    
    void undoLastCommand()
    {
        if (m_commandHistory.empty())
            return;
        
        auto command = std::move(m_commandHistory.back());
        m_commandHistory.pop_back();
        
        command->undo();
    }
};
```

`std::deque`를 사용하여 양쪽 끝에서 효율적인 삽입과 삭제가 가능하다. `std::unique_ptr`로 명령 객체의 소유권을 명확하게 관리한다.

### 24.9.3 관찰자 패턴 (Observer Pattern)

게임 이벤트를 다른 시스템에 알리기 위해 관찰자 패턴을 사용한다.

```cpp
// IGameEventListener.h
class IGameEventListener
{
public:
    virtual ~IGameEventListener() = default;
    
    virtual void onTileMoved(int32 moveCount) = 0;
    virtual void onGameCompleted(int32 moves, double time) = 0;
    virtual void onGameStarted() = 0;
};

// AchievementSystem.h
class AchievementSystem : public IGameEventListener
{
private:
    std::set<String> m_unlockedAchievements;
    
public:
    void onTileMoved(int32 moveCount) override
    {
        if (moveCount == 1)
        {
            unlockAchievement(U"첫 걸음");
        }
    }
    
    void onGameCompleted(int32 moves, double time) override
    {
        if (moves <= 50)
        {
            unlockAchievement(U"효율적인 해결사");
        }
        
        if (time <= 180.0)
        {
            unlockAchievement(U"스피드 마스터");
        }
    }
    
    void onGameStarted() override
    {
        // 게임 시작 시 처리
    }
    
private:
    void unlockAchievement(const String& name)
    {
        if (m_unlockedAchievements.insert(name).second)
        {
            Print << U"업적 달성: " << name;
            // 시각적 피드백 추가
        }
    }
};

// PuzzleGame.h (수정)
class PuzzleGame
{
private:
    std::vector<std::shared_ptr<IGameEventListener>> m_listeners;
    
public:
    void addListener(std::shared_ptr<IGameEventListener> listener)
    {
        m_listeners.push_back(listener);
    }
    
    void removeListener(std::shared_ptr<IGameEventListener> listener)
    {
        m_listeners.erase(
            std::remove(m_listeners.begin(), m_listeners.end(), listener),
            m_listeners.end()
        );
    }
    
private:
    void notifyTileMoved()
    {
        for (auto& listener : m_listeners)
        {
            listener->onTileMoved(m_moveCount);
        }
    }
    
    void notifyGameCompleted()
    {
        for (auto& listener : m_listeners)
        {
            listener->onGameCompleted(m_moveCount, m_elapsedTime);
        }
    }
};
```

`std::shared_ptr`를 사용하여 여러 객체가 리스너를 공유할 수 있도록 한다.

## 24.10 성능 최적화

### 24.10.1 불필요한 복사 방지

```cpp
// 개선 전
void drawTile(Tile tile) const  // 값으로 전달 (복사 발생)
{
    // ...
}

// 개선 후
void drawTile(const Tile& tile) const  // const 참조로 전달 (복사 없음)
{
    // ...
}
```

### 24.10.2 범위 기반 for 문 최적화

```cpp
// 개선 전
for (auto tile : m_tiles)  // 각 타일을 복사
{
    drawTile(tile);
}

// 개선 후
for (const auto& tile : m_tiles)  // const 참조 사용
{
    drawTile(tile);
}
```

### 24.10.3 문자열 포맷팅 최적화

```cpp
// 자주 호출되는 함수에서는 문자열 생성 최소화
void drawUI() const
{
    // 매 프레임마다 문자열을 생성하지 않고 캐시 활용
    static String moveText;
    static int32 lastMoveCount = -1;
    
    if (m_moveCount != lastMoveCount)
    {
        moveText = Format(U"이동: {}", m_moveCount);
        lastMoveCount = m_moveCount;
    }
    
    m_uiFont(moveText).draw(20, 20, ColorF{ 0.3 });
}
```

## 24.11 요약

이번 장에서는 지금까지 배운 Modern C++ 기능들을 활용하여 완전한 퍼즐 게임을 만들었다. 주요 학습 내용은 다음과 같다:

**Modern C++ 기능 활용:**
- `enum class`로 타입 안전한 상태 관리
- `std::array`와 `std::vector`로 안전한 컨테이너 사용
- `std::optional`로 명확한 값 부재 표현
- `std::unique_ptr`와 `std::shared_ptr`로 메모리 안전성 보장
- 람다 표현식으로 간결한 코드 작성
- `constexpr`로 컴파일 시간 최적화

**게임 개발 기법:**
- 게임 상태 관리
- 사용자 입력 처리
- 애니메이션 구현
- 데이터 저장 및 로드
- UI/UX 설계

**디자인 패턴:**
- 상태 패턴으로 확장 가능한 구조
- 명령 패턴으로 실행 취소 구현
- 관찰자 패턴으로 느슨한 결합

다음 장에서는 더 복잡한 그래픽 에디터를 만들면서 고급 디자인 패턴과 최적화 기법을 배운다.


