# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 13: 클래스와 객체 기초
객체지향 프로그래밍(Object-Oriented Programming, OOP)은 현대 소프트웨어 개발의 핵심 패러다임이다. C++는 객체지향 프로그래밍을 강력하게 지원하는 언어로, 클래스와 객체를 통해 현실 세계의 개념을 코드로 표현할 수 있다. 이번 장에서는 클래스의 기본 개념부터 시작하여 멤버 변수, 멤버 함수, 접근 지정자, 생성자와 소멸자, 그리고 `this` 포인터까지 차근차근 알아본다.

## 13.1 클래스와 객체의 개념

### 13.1.1 객체지향 프로그래밍이란?
지금까지 우리는 데이터를 저장하는 변수와 데이터를 처리하는 함수를 별도로 다루었다. 하지만 실제 프로그램에서는 서로 관련된 데이터와 기능을 하나로 묶어서 관리하는 것이 훨씬 효율적이다.

예를 들어, 게임에서 플레이어 캐릭터를 생각해보자. 플레이어는 이름, 체력, 위치 등의 **속성(데이터)**을 가지며, 동시에 이동하기, 공격하기, 아이템 사용하기 등의 **행동(기능)**을 할 수 있다. 객체지향 프로그래밍은 이렇게 관련된 데이터와 기능을 하나의 **객체(Object)**로 묶어서 표현하는 프로그래밍 방식이다.

**클래스(Class)**는 객체를 만들기 위한 설계도 또는 틀이다. 건축 설계도가 실제 건물을 짓기 위한 청사진인 것처럼, 클래스는 객체를 생성하기 위한 청사진이라고 할 수 있다. 반면 **객체(Object)**는 클래스라는 설계도를 바탕으로 실제로 생성된 실체다.

### 13.1.2 클래스 정의하기
C++에서 클래스를 정의하는 기본 문법은 다음과 같다.

```cpp
class 클래스이름 {
    // 멤버 변수와 멤버 함수 선언
};
```

간단한 `Player` 클래스를 정의해보자.

```cpp
#include <iostream>
#include <string>

class Player {
public:
    std::string name;
    int health;
    int x;
    int y;
    
    void Move(int dx, int dy) {
        x += dx;
        y += dy;
        std::cout << name << "이(가) (" << x << ", " << y << ")로 이동했다.\n";
    }
    
    void TakeDamage(int damage) {
        health -= damage;
        std::cout << name << "이(가) " << damage << "의 피해를 입었다. ";
        std::cout << "남은 체력: " << health << "\n";
    }
};
```

이 클래스는 플레이어의 이름, 체력, 위치를 나타내는 멤버 변수와 이동 및 피해 받기 기능을 하는 멤버 함수를 포함한다.

### 13.1.3 객체 생성과 사용
클래스를 정의했다면, 이제 실제 객체를 생성하여 사용할 수 있다.

```cpp
int main() {
    // Player 타입의 객체 생성
    Player player1;
    
    // 멤버 변수 초기화
    player1.name = "전사";
    player1.health = 100;
    player1.x = 0;
    player1.y = 0;
    
    // 멤버 함수 호출
    player1.Move(10, 5);
    player1.TakeDamage(20);
    
    // 또 다른 객체 생성
    Player player2;
    player2.name = "마법사";
    player2.health = 80;
    player2.x = 5;
    player2.y = 5;
    
    player2.Move(-3, 7);
    player2.TakeDamage(15);
    
    return 0;
}
```

**출력 결과:**
```
전사이(가) (10, 5)로 이동했다.
전사이(가) 20의 피해를 입었다. 남은 체력: 80
마법사이(가) (2, 12)로 이동했다.
마법사이(가) 15의 피해를 입었다. 남은 체력: 65
```

위 예제에서 `player1`과 `player2`는 같은 `Player` 클래스로부터 생성된 서로 다른 객체다. 각 객체는 독립적인 멤버 변수 값을 가지며, 같은 멤버 함수를 공유한다.


</br>  
</br>  
  

## 13.2 멤버 변수와 멤버 함수

### 13.2.1 멤버 변수 (Member Variables)
멤버 변수는 클래스 내부에 선언된 변수로, 객체의 상태나 속성을 나타낸다. 각 객체는 자신만의 멤버 변수 복사본을 갖는다.

```cpp
class BankAccount {
public:
    std::string owner;      // 계좌 소유자
    std::string accountNumber;  // 계좌 번호
    double balance;         // 잔액
    double interestRate;    // 이자율
};
```

멤버 변수를 선언할 때 Modern C++의 기능을 활용하면 더욱 안전하고 명확한 코드를 작성할 수 있다.

```cpp
class BankAccount {
public:
    std::string owner{};           // 기본값으로 빈 문자열 초기화
    std::string accountNumber{};
    double balance{ 0.0 };         // 기본값 0.0으로 초기화
    double interestRate{ 0.02 };   // 기본 이자율 2%
};
```

C++11부터는 클래스 정의 내부에서 멤버 변수에 직접 기본값을 지정할 수 있다. 이를 **비정적 데이터 멤버 초기화(Non-static Data Member Initialization, NSDMI)**라고 한다.

### 13.2.2 멤버 함수 (Member Functions)
멤버 함수는 클래스 내부에 선언된 함수로, 객체의 동작이나 행위를 정의한다. 멤버 함수는 해당 객체의 멤버 변수에 접근할 수 있다.

```cpp
class BankAccount {
public:
    std::string owner{};
    std::string accountNumber{};
    double balance{ 0.0 };
    double interestRate{ 0.02 };
    
    // 입금 함수
    void Deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            std::cout << amount << "원이 입금되었다. 현재 잔액: " << balance << "원\n";
        }
    }
    
    // 출금 함수
    void Withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            std::cout << amount << "원이 출금되었다. 현재 잔액: " << balance << "원\n";
        } else {
            std::cout << "출금 실패: 잔액 부족\n";
        }
    }
    
    // 이자 적용 함수
    void ApplyInterest() {
        double interest = balance * interestRate;
        balance += interest;
        std::cout << "이자 " << interest << "원이 적용되었다. 현재 잔액: " << balance << "원\n";
    }
    
    // 계좌 정보 출력 함수
    void DisplayInfo() const {
        std::cout << "=== 계좌 정보 ===\n";
        std::cout << "소유자: " << owner << "\n";
        std::cout << "계좌번호: " << accountNumber << "\n";
        std::cout << "잔액: " << balance << "원\n";
        std::cout << "이자율: " << (interestRate * 100) << "%\n";
    }
};
```

멤버 함수 뒤에 붙은 `const` 키워드는 해당 함수가 객체의 상태를 변경하지 않음을 명시한다. `DisplayInfo()` 함수는 단순히 정보를 출력할 뿐 멤버 변수를 수정하지 않으므로 `const`로 선언했다.

### 13.2.3 클래스 내부 정의와 외부 정의
멤버 함수는 클래스 내부에서 직접 정의할 수도 있고, 클래스 외부에서 정의할 수도 있다.

**클래스 내부 정의:**

```cpp
class Rectangle {
public:
    double width{ 0.0 };
    double height{ 0.0 };
    
    // 클래스 내부에서 직접 정의
    double GetArea() const {
        return width * height;
    }
};
```

**클래스 외부 정의:**

```cpp
class Rectangle {
public:
    double width{ 0.0 };
    double height{ 0.0 };
    
    // 클래스 내부에서는 선언만
    double GetArea() const;
    double GetPerimeter() const;
};

// 클래스 외부에서 정의 (스코프 연산자 :: 사용)
double Rectangle::GetArea() const {
    return width * height;
}

double Rectangle::GetPerimeter() const {
    return 2 * (width + height);
}
```

일반적으로 간단한 함수는 클래스 내부에, 복잡한 함수는 외부에 정의한다. 외부 정의는 헤더 파일과 소스 파일을 분리할 때 유용하다.
  

</br>  
</br>  


## 13.3 접근 지정자

### 13.3.1 접근 지정자의 필요성
지금까지 작성한 예제에서는 모든 멤버에 `public` 키워드를 사용했다. 하지만 실제 프로그램에서는 객체의 내부 데이터를 외부에서 마음대로 접근하지 못하도록 제한할 필요가 있다.

예를 들어, 은행 계좌의 잔액을 직접 수정할 수 있다면 어떻게 될까?

```cpp
BankAccount account;
account.balance = 1000000000;  // 임의로 잔액을 10억으로 설정!
```

이는 명백히 문제가 있는 코드다. 이러한 문제를 방지하기 위해 C++는 **접근 지정자(Access Specifiers)**를 제공한다.

### 13.3.2 세 가지 접근 지정자
C++에는 세 가지 접근 지정자가 있다.

1. **`public`**: 클래스 외부에서 자유롭게 접근 가능
2. **`private`**: 클래스 내부에서만 접근 가능 (기본값)
3. **`protected`**: 클래스 내부와 파생 클래스에서 접근 가능 (상속과 관련, 15장에서 다룸)



### 13.3.3 캡슐화 (Encapsulation)
접근 지정자를 활용하여 데이터를 보호하는 것을 **캡슐화(Encapsulation)**라고 한다. 일반적으로 멤버 변수는 `private`으로 선언하고, 필요한 경우 `public` 멤버 함수를 통해서만 접근하도록 한다.

```cpp
class BankAccount {
private:
    std::string owner_{};
    std::string accountNumber_{};
    double balance_{ 0.0 };
    double interestRate_{ 0.02 };
    
public:
    // 생성자 (다음 절에서 자세히 다룸)
    BankAccount(const std::string& owner, const std::string& accountNumber)
        : owner_(owner), accountNumber_(accountNumber) {
    }
    
    // Getter 함수들 - 값을 읽기만 함
    std::string GetOwner() const { return owner_; }
    std::string GetAccountNumber() const { return accountNumber_; }
    double GetBalance() const { return balance_; }
    double GetInterestRate() const { return interestRate_; }
    
    // Setter 함수들 - 유효성 검사 후 값을 설정
    void SetInterestRate(double rate) {
        if (rate >= 0.0 && rate <= 0.1) {  // 0~10% 범위만 허용
            interestRate_ = rate;
        } else {
            std::cout << "유효하지 않은 이자율이다.\n";
        }
    }
    
    void Deposit(double amount) {
        if (amount > 0) {
            balance_ += amount;
            std::cout << amount << "원이 입금되었다.\n";
        } else {
            std::cout << "입금액은 0보다 커야 한다.\n";
        }
    }
    
    bool Withdraw(double amount) {
        if (amount <= 0) {
            std::cout << "출금액은 0보다 커야 한다.\n";
            return false;
        }
        
        if (amount > balance_) {
            std::cout << "잔액이 부족하다.\n";
            return false;
        }
        
        balance_ -= amount;
        std::cout << amount << "원이 출금되었다.\n";
        return true;
    }
};
```

이제 잔액은 외부에서 직접 수정할 수 없고, 반드시 `Deposit()` 또는 `Withdraw()` 함수를 통해서만 변경할 수 있다. 이 함수들은 유효성 검사를 수행하므로 데이터의 무결성이 보장된다.

```cpp
int main() {
    BankAccount myAccount("홍길동", "123-456-789");
    
    // myAccount.balance_ = 1000000;  // 컴파일 오류! private 멤버에 접근 불가
    
    myAccount.Deposit(50000);     // 올바른 방법
    myAccount.Withdraw(30000);
    
    std::cout << "현재 잔액: " << myAccount.GetBalance() << "원\n";
    
    return 0;
}
```

**명명 규칙 참고사항:**

위 예제에서 private 멤버 변수 이름에 밑줄(`_`)을 붙였다. 이는 멤버 변수임을 명확히 하기 위한 일반적인 명명 규칙 중 하나다. 다른 규칙으로는 `m_balance`, `mBalance` 등이 있으며, 프로젝트나 팀의 코딩 스타일 가이드를 따르면 된다.
  

</br>  
</br>  
  

## 13.4 생성자와 소멸자

### 13.4.1 생성자란?
**생성자(Constructor)**는 객체가 생성될 때 자동으로 호출되는 특수한 멤버 함수다. 생성자는 객체의 초기 상태를 설정하는 역할을 한다.

생성자의 특징:
- 클래스 이름과 동일한 이름을 가진다
- 반환 타입이 없다 (`void`도 쓰지 않음)
- 객체 생성 시 자동으로 호출된다
- 오버로딩이 가능하다 (여러 개의 생성자 정의 가능)

### 13.4.2 기본 생성자

매개변수가 없는 생성자를 **기본 생성자(Default Constructor)**라고 한다.

```cpp
class Point {
private:
    int x_;
    int y_;
    
public:
    // 기본 생성자
    Point() {
        x_ = 0;
        y_ = 0;
        std::cout << "Point 객체가 생성되었다: (" << x_ << ", " << y_ << ")\n";
    }
    
    void Print() const {
        std::cout << "(" << x_ << ", " << y_ << ")\n";
    }
};

int main() {
    Point p1;       // 기본 생성자 호출
    Point p2{};     // Modern C++ 방식, 기본 생성자 호출
    
    p1.Print();
    p2.Print();
    
    return 0;
}
```

**중요한 주의사항:**

```cpp
Point p1;       // 올바름: 기본 생성자 호출
Point p2();     // 잘못됨: 함수 선언으로 해석됨! (가장 짜증나는 파싱 문제)
Point p3{};     // 올바름: 기본 생성자 호출 (Modern C++ 권장 방식)
```

### 13.4.3 매개변수가 있는 생성자
특정 값으로 객체를 초기화하려면 매개변수가 있는 생성자를 정의한다.

```cpp
class Point {
private:
    int x_;
    int y_;
    
public:
    // 기본 생성자
    Point() : x_(0), y_(0) {
        std::cout << "기본 생성자 호출\n";
    }
    
    // 매개변수가 있는 생성자
    Point(int x, int y) : x_(x), y_(y) {
        std::cout << "매개변수 생성자 호출: (" << x_ << ", " << y_ << ")\n";
    }
    
    void Print() const {
        std::cout << "(" << x_ << ", " << y_ << ")\n";
    }
};

int main() {
    Point p1;           // 기본 생성자 호출
    Point p2(10, 20);   // 매개변수 생성자 호출
    Point p3{ 30, 40 }; // Modern C++ 방식 (권장)
    
    p1.Print();
    p2.Print();
    p3.Print();
    
    return 0;
}
```

### 13.4.4 멤버 초기화 리스트
생성자에서 멤버 변수를 초기화하는 방법에는 두 가지가 있다.

**방법 1: 생성자 본문에서 대입**

```cpp
Point(int x, int y) {
    x_ = x;
    y_ = y;
}
```

**방법 2: 멤버 초기화 리스트 (권장)**

```cpp
Point(int x, int y) : x_(x), y_(y) {
    // 생성자 본문
}
```

멤버 초기화 리스트가 권장되는 이유:
1. **효율성**: 대입이 아닌 직접 초기화되므로 더 효율적이다
2. **const 멤버**: const 멤버 변수는 반드시 초기화 리스트로만 초기화해야 한다
3. **참조 멤버**: 참조 멤버 변수도 반드시 초기화 리스트로만 초기화해야 한다
4. **명확성**: 초기화 순서가 선언 순서를 따른다는 것이 명확하다

```cpp
class Student {
private:
    const int id_;           // const 멤버
    std::string& name_;      // 참조 멤버
    int grade_;
    
public:
    // const와 참조 멤버는 반드시 초기화 리스트 사용
    Student(int id, std::string& name, int grade)
        : id_(id), name_(name), grade_(grade) {
    }
};
```

### 13.4.5 소멸자
**소멸자(Destructor)**는 객체가 소멸될 때 자동으로 호출되는 특수한 멤버 함수다. 소멸자는 객체가 사용한 자원을 정리하는 역할을 한다.

소멸자의 특징:
- 클래스 이름 앞에 `~`(물결표)를 붙인 이름을 가진다
- 매개변수를 가질 수 없다
- 반환 타입이 없다
- 오버로딩할 수 없다 (하나만 존재)
- 객체 소멸 시 자동으로 호출된다

```cpp
class FileHandler {
private:
    std::string filename_;
    
public:
    // 생성자
    FileHandler(const std::string& filename) : filename_(filename) {
        std::cout << "파일 " << filename_ << "을(를) 열었다.\n";
    }
    
    // 소멸자
    ~FileHandler() {
        std::cout << "파일 " << filename_ << "을(를) 닫았다.\n";
    }
    
    void Write(const std::string& content) {
        std::cout << filename_ << "에 내용을 썼다: " << content << "\n";
    }
};

int main() {
    {
        FileHandler file1("data.txt");
        file1.Write("Hello, World!");
        
        FileHandler file2("config.ini");
        file2.Write("Setting=Value");
        
        // 블록을 벗어나면 file2, file1 순서로 소멸자 호출 (생성의 역순)
    }
    
    std::cout << "프로그램 계속 실행 중...\n";
    
    return 0;
}
```

**출력 결과:**
```
파일 data.txt을(를) 열었다.
data.txt에 내용을 썼다: Hello, World!
파일 config.ini을(를) 열었다.
config.ini에 내용을 썼다: Setting=Value
파일 config.ini을(를) 닫았다.
파일 data.txt을(를) 닫았다.
프로그램 계속 실행 중...
```

객체는 생성된 순서의 **역순**으로 소멸된다. 이는 스택(Stack) 구조와 같다.

### 13.4.6 생성자와 소멸자의 실행 순서
```cpp
class Demo {
private:
    std::string name_;
    
public:
    Demo(const std::string& name) : name_(name) {
        std::cout << name_ << " 생성됨\n";
    }
    
    ~Demo() {
        std::cout << name_ << " 소멸됨\n";
    }
};

int main() {
    std::cout << "=== 프로그램 시작 ===\n";
    
    Demo obj1("첫 번째 객체");
    
    {
        Demo obj2("두 번째 객체");
        Demo obj3("세 번째 객체");
        std::cout << "--- 내부 블록 끝 ---\n";
    }
    
    Demo obj4("네 번째 객체");
    
    std::cout << "=== 프로그램 종료 ===\n";
    return 0;
}
```

**출력 결과:**
```
=== 프로그램 시작 ===
첫 번째 객체 생성됨
두 번째 객체 생성됨
세 번째 객체 생성됨
--- 내부 블록 끝 ---
세 번째 객체 소멸됨
두 번째 객체 소멸됨
네 번째 객체 생성됨
=== 프로그램 종료 ===
네 번째 객체 소멸됨
첫 번째 객체 소멸됨
```


</br>  
</br>     
  

## 13.5 `this` 포인터

### 13.5.1 `this` 포인터란?
`this`는 현재 객체를 가리키는 포인터다. 모든 비정적 멤버 함수는 암묵적으로 `this` 포인터를 매개변수로 받는다.

```cpp
class Counter {
private:
    int count_;
    
public:
    Counter() : count_(0) {}
    
    void Increment() {
        count_++;           // this->count_++ 와 동일
        this->count_++;     // 명시적으로 this 사용
    }
    
    int GetCount() const {
        return count_;      // this->count_ 와 동일
    }
};
```

일반적으로 `this->` 를 명시적으로 쓸 필요는 없지만, 다음과 같은 경우에 유용하다.

### 13.5.2 매개변수와 멤버 변수 이름이 같을 때

```cpp
class Rectangle {
private:
    double width_;
    double height_;
    
public:
    // 좋은 방법: 멤버 변수에 접미사 사용
    void SetSize(double width, double height) {
        width_ = width;
        height_ = height;
    }
    
    // this 포인터를 사용하는 방법
    void SetSize2(double width, double height) {
        this->width_ = width;
        this->height_ = height;
    }
};
```

하지만 Modern C++ 에서는 멤버 변수에 접미사(`_`, `m_` 등)를 붙이는 것이 더 명확하므로, `this->`를 굳이 쓸 필요가 없는 경우가 많다.

### 13.5.3 현재 객체의 참조 반환
메서드 체이닝(Method Chaining)을 구현할 때 `this` 포인터가 유용하다.

```cpp
class Calculator {
private:
    double value_;
    
public:
    Calculator() : value_(0) {}
    
    // 현재 객체의 참조를 반환하여 체이닝 가능
    Calculator& Add(double num) {
        value_ += num;
        return *this;
    }
    
    Calculator& Subtract(double num) {
        value_ -= num;
        return *this;
    }
    
    Calculator& Multiply(double num) {
        value_ *= num;
        return *this;
    }
    
    Calculator& Divide(double num) {
        if (num != 0) {
            value_ /= num;
        }
        return *this;
    }
    
    double GetValue() const {
        return value_;
    }
};

int main() {
    Calculator calc;
    
    // 메서드 체이닝: 여러 연산을 연속으로 수행
    double result = calc.Add(10)
                        .Multiply(2)
                        .Subtract(5)
                        .Divide(3)
                        .GetValue();
    
    std::cout << "결과: " << result << "\n";  // 출력: 결과: 5
    
    return 0;
}
```

`*this`는 현재 객체 자체를 나타내며, `return *this;`는 현재 객체의 참조를 반환한다.

### 13.5.4 객체 복사 방지
`this` 포인터를 사용하여 자기 자신으로의 대입을 방지할 수 있다. 이는 다음 장에서 다룰 복사 대입 연산자에서 중요하다.

```cpp
class MyClass {
private:
    int* data_;
    
public:
    MyClass& operator=(const MyClass& other) {
        // 자기 자신으로의 대입인지 확인
        if (this == &other) {
            return *this;
        }
        
        // 실제 복사 작업 수행
        // ...
        
        return *this;
    }
};
```
   

</br>  
</br>  
  
  
## 13.6 실습 예제: 간단한 게임 캐릭터 클래스
지금까지 배운 내용을 종합하여 게임 캐릭터를 표현하는 클래스를 만들어보자.

```cpp
#include <iostream>
#include <string>
#include <algorithm>

class GameCharacter {
private:
    std::string name_;
    int level_;
    int health_;
    int maxHealth_;
    int attackPower_;
    int defense_;
    
public:
    // 생성자
    GameCharacter(const std::string& name, int level = 1)
        : name_(name),
          level_(level),
          maxHealth_(100 + (level - 1) * 20),
          health_(maxHealth_),
          attackPower_(10 + (level - 1) * 5),
          defense_(5 + (level - 1) * 2) {
        std::cout << name_ << " 캐릭터가 생성되었다. (레벨 " << level_ << ")\n";
    }
    
    // 소멸자
    ~GameCharacter() {
        std::cout << name_ << " 캐릭터가 소멸되었다.\n";
    }
    
    // Getter 함수들
    std::string GetName() const { return name_; }
    int GetLevel() const { return level_; }
    int GetHealth() const { return health_; }
    int GetMaxHealth() const { return maxHealth_; }
    bool IsAlive() const { return health_ > 0; }
    
    // 공격 함수
    void Attack(GameCharacter& target) {
        if (!IsAlive()) {
            std::cout << name_ << "은(는) 전투 불능 상태다.\n";
            return;
        }
        
        std::cout << name_ << "이(가) " << target.name_ << "을(를) 공격한다!\n";
        target.TakeDamage(attackPower_);
    }
    
    // 피해 받기 함수
    void TakeDamage(int damage) {
        if (!IsAlive()) {
            return;
        }
        
        // 방어력만큼 피해 감소
        int actualDamage = std::max(1, damage - defense_);
        health_ -= actualDamage;
        
        std::cout << name_ << "이(가) " << actualDamage << "의 피해를 입었다. ";
        
        if (health_ < 0) {
            health_ = 0;
        }
        
        std::cout << "남은 체력: " << health_ << "/" << maxHealth_ << "\n";
        
        if (!IsAlive()) {
            std::cout << name_ << "이(가) 쓰러졌다!\n";
        }
    }
    
    // 회복 함수
    void Heal(int amount) {
        if (!IsAlive()) {
            std::cout << name_ << "은(는) 전투 불능 상태다.\n";
            return;
        }
        
        int oldHealth = health_;
        health_ = std::min(maxHealth_, health_ + amount);
        int actualHeal = health_ - oldHealth;
        
        std::cout << name_ << "이(가) " << actualHeal << "만큼 회복했다. ";
        std::cout << "현재 체력: " << health_ << "/" << maxHealth_ << "\n";
    }
    
    // 레벨업 함수
    GameCharacter& LevelUp() {
        level_++;
        maxHealth_ += 20;
        health_ = maxHealth_;
        attackPower_ += 5;
        defense_ += 2;
        
        std::cout << name_ << "이(가) 레벨 " << level_ << "이(가) 되었다!\n";
        std::cout << "체력: " << maxHealth_ << ", 공격력: " << attackPower_;
        std::cout << ", 방어력: " << defense_ << "\n";
        
        return *this;  // 메서드 체이닝을 위해 자기 자신 반환
    }
    
    // 정보 출력 함수
    void DisplayInfo() const {
        std::cout << "====== 캐릭터 정보 ======\n";
        std::cout << "이름: " << name_ << "\n";
        std::cout << "레벨: " << level_ << "\n";
        std::cout << "체력: " << health_ << "/" << maxHealth_ << "\n";
        std::cout << "공격력: " << attackPower_ << "\n";
        std::cout << "방어력: " << defense_ << "\n";
        std::cout << "상태: " << (IsAlive() ? "생존" : "전투 불능") << "\n";
        std::cout << "========================\n";
    }
};

int main() {
    std::cout << "=== 게임 시작 ===\n\n";
    
    // 캐릭터 생성
    GameCharacter player("용사", 5);
    GameCharacter enemy("오크", 4);
    
    std::cout << "\n";
    
    // 초기 상태 출력
    player.DisplayInfo();
    std::cout << "\n";
    enemy.DisplayInfo();
    
    std::cout << "\n=== 전투 시작 ===\n";
    
    // 전투 시뮬레이션
    int turn = 1;
    while (player.IsAlive() && enemy.IsAlive()) {
        std::cout << "\n--- 턴 " << turn << " ---\n";
        
        player.Attack(enemy);
        
        if (enemy.IsAlive()) {
            enemy.Attack(player);
        }
        
        turn++;
        
        // 무한 루프 방지
        if (turn > 20) {
            std::cout << "전투가 너무 길어져 중단한다.\n";
            break;
        }
    }
    
    std::cout << "\n=== 전투 종료 ===\n";
    
    if (player.IsAlive() && !enemy.IsAlive()) {
        std::cout << player.GetName() << "의 승리!\n";
        player.LevelUp();  // 레벨업
    } else if (!player.IsAlive() && enemy.IsAlive()) {
        std::cout << enemy.GetName() << "의 승리!\n";
    } else {
        std::cout << "무승부!\n";
    }
    
    std::cout << "\n";
    player.DisplayInfo();
    
    std::cout << "\n=== 게임 종료 ===\n";
    
    return 0;
    // main 함수가 끝나면 player, enemy 순서로 소멸자 호출
}
```

이 예제는 클래스의 핵심 요소들을 모두 포함한다:
- `private` 멤버 변수로 캡슐화
- 생성자와 소멸자
- `const` 멤버 함수 (상태를 변경하지 않는 함수)
- 멤버 함수 간 상호작용
- `this` 포인터를 사용한 메서드 체이닝
   

</br>  


## 13.7 연습 문제

### 문제 1: 도서 관리 클래스
책을 나타내는 `Book` 클래스를 작성하라. 이 클래스는 다음 요구사항을 만족해야 한다:

- `private` 멤버: 제목(title), 저자(author), ISBN, 대출 가능 여부(isAvailable)
- 생성자: 제목, 저자, ISBN을 받아 초기화 (대출 가능 상태로 시작)
- `BorrowBook()`: 책을 대출하는 함수 (이미 대출된 책은 대출 불가)
- `ReturnBook()`: 책을 반납하는 함수
- `DisplayInfo()`: 책 정보를 출력하는 함수

**해답:**

```cpp
#include <iostream>
#include <string>

class Book {
private:
    std::string title_;
    std::string author_;
    std::string isbn_;
    bool isAvailable_;
    
public:
    // 생성자
    Book(const std::string& title, const std::string& author, const std::string& isbn)
        : title_(title), author_(author), isbn_(isbn), isAvailable_(true) {
        std::cout << "도서 등록: " << title_ << "\n";
    }
    
    // 소멸자
    ~Book() {
        std::cout << "도서 제거: " << title_ << "\n";
    }
    
    // 책 대출
    bool BorrowBook() {
        if (!isAvailable_) {
            std::cout << "\"" << title_ << "\"은(는) 이미 대출 중이다.\n";
            return false;
        }
        
        isAvailable_ = false;
        std::cout << "\"" << title_ << "\"을(를) 대출했다.\n";
        return true;
    }
    
    // 책 반납
    void ReturnBook() {
        if (isAvailable_) {
            std::cout << "\"" << title_ << "\"은(는) 대출되지 않았다.\n";
            return;
        }
        
        isAvailable_ = true;
        std::cout << "\"" << title_ << "\"을(를) 반납했다.\n";
    }
    
    // 정보 출력
    void DisplayInfo() const {
        std::cout << "====== 도서 정보 ======\n";
        std::cout << "제목: " << title_ << "\n";
        std::cout << "저자: " << author_ << "\n";
        std::cout << "ISBN: " << isbn_ << "\n";
        std::cout << "대출 가능: " << (isAvailable_ ? "예" : "아니오") << "\n";
        std::cout << "=====================\n";
    }
};

int main() {
    Book book1("Modern C++", "김철수", "978-1234567890");
    
    book1.DisplayInfo();
    std::cout << "\n";
    
    book1.BorrowBook();
    book1.BorrowBook();  // 이미 대출됨
    std::cout << "\n";
    
    book1.DisplayInfo();
    std::cout << "\n";
    
    book1.ReturnBook();
    book1.ReturnBook();  // 이미 반납됨
    
    return 0;
}
```

### 문제 2: 은행 계좌 클래스 확장
앞서 작성한 `BankAccount` 클래스에 다음 기능을 추가하라:

- 거래 내역 카운터 (입금/출금 횟수)
- `Transfer()` 함수: 다른 계좌로 송금하는 기능
- 거래 수수료 적용 (출금 시 1%, 송금 시 2%)

**해답:**

```cpp
#include <iostream>
#include <string>

class BankAccount {
private:
    std::string owner_;
    std::string accountNumber_;
    double balance_;
    double interestRate_;
    int depositCount_;
    int withdrawCount_;
    
    static constexpr double WITHDRAW_FEE_RATE = 0.01;  // 1%
    static constexpr double TRANSFER_FEE_RATE = 0.02;  // 2%
    
public:
    // 생성자
    BankAccount(const std::string& owner, const std::string& accountNumber)
        : owner_(owner),
          accountNumber_(accountNumber),
          balance_(0.0),
          interestRate_(0.02),
          depositCount_(0),
          withdrawCount_(0) {
        std::cout << owner_ << "의 계좌가 개설되었다. (계좌번호: " << accountNumber_ << ")\n";
    }
    
    // 소멸자
    ~BankAccount() {
        std::cout << owner_ << "의 계좌가 폐쇄되었다.\n";
    }
    
    // Getter 함수들
    std::string GetOwner() const { return owner_; }
    double GetBalance() const { return balance_; }
    
    // 입금
    void Deposit(double amount) {
        if (amount <= 0) {
            std::cout << "입금액은 0보다 커야 한다.\n";
            return;
        }
        
        balance_ += amount;
        depositCount_++;
        std::cout << amount << "원이 입금되었다. 현재 잔액: " << balance_ << "원\n";
    }
    
    // 출금
    bool Withdraw(double amount) {
        if (amount <= 0) {
            std::cout << "출금액은 0보다 커야 한다.\n";
            return false;
        }
        
        double fee = amount * WITHDRAW_FEE_RATE;
        double totalAmount = amount + fee;
        
        if (totalAmount > balance_) {
            std::cout << "잔액이 부족하다. (필요 금액: " << totalAmount << "원)\n";
            return false;
        }
        
        balance_ -= totalAmount;
        withdrawCount_++;
        std::cout << amount << "원이 출금되었다. (수수료: " << fee << "원)\n";
        std::cout << "현재 잔액: " << balance_ << "원\n";
        return true;
    }
    
    // 송금
    bool Transfer(BankAccount& targetAccount, double amount) {
        if (amount <= 0) {
            std::cout << "송금액은 0보다 커야 한다.\n";
            return false;
        }
        
        double fee = amount * TRANSFER_FEE_RATE;
        double totalAmount = amount + fee;
        
        if (totalAmount > balance_) {
            std::cout << "잔액이 부족하다. (필요 금액: " << totalAmount << "원)\n";
            return false;
        }
        
        balance_ -= totalAmount;
        targetAccount.balance_ += amount;
        
        std::cout << targetAccount.owner_ << "에게 " << amount << "원을 송금했다. ";
        std::cout << "(수수료: " << fee << "원)\n";
        std::cout << "현재 잔액: " << balance_ << "원\n";
        
        return true;
    }
    
    // 정보 출력
    void DisplayInfo() const {
        std::cout << "====== 계좌 정보 ======\n";
        std::cout << "소유자: " << owner_ << "\n";
        std::cout << "계좌번호: " << accountNumber_ << "\n";
        std::cout << "잔액: " << balance_ << "원\n";
        std::cout << "이자율: " << (interestRate_ * 100) << "%\n";
        std::cout << "입금 횟수: " << depositCount_ << "회\n";
        std::cout << "출금 횟수: " << withdrawCount_ << "회\n";
        std::cout << "======================\n";
    }
};

int main() {
    BankAccount account1("홍길동", "123-456-789");
    BankAccount account2("김철수", "987-654-321");
    
    std::cout << "\n";
    
    account1.Deposit(100000);
    account2.Deposit(50000);
    
    std::cout << "\n";
    
    account1.Withdraw(10000);
    account1.Transfer(account2, 20000);
    
    std::cout << "\n";
    
    account1.DisplayInfo();
    std::cout << "\n";
    account2.DisplayInfo();
    
    return 0;
}
```

### 문제 3: 벡터 클래스
2D 벡터를 나타내는 `Vector2D` 클래스를 작성하라:

- `private` 멤버: x, y 좌표
- 생성자: 기본 생성자(0, 0), 매개변수 생성자(x, y)
- `Add()`: 다른 벡터와 더하기
- `GetLength()`: 벡터의 길이 계산
- `Normalize()`: 벡터 정규화 (길이를 1로 만들기)
- `Print()`: 벡터 정보 출력

**해답:**

```cpp
#include <iostream>
#include <cmath>

class Vector2D {
private:
    double x_;
    double y_;
    
public:
    // 기본 생성자
    Vector2D() : x_(0.0), y_(0.0) {}
    
    // 매개변수 생성자
    Vector2D(double x, double y) : x_(x), y_(y) {}
    
    // Getter
    double GetX() const { return x_; }
    double GetY() const { return y_; }
    
    // 벡터 덧셈
    Vector2D& Add(const Vector2D& other) {
        x_ += other.x_;
        y_ += other.y_;
        return *this;  // 메서드 체이닝
    }
    
    // 벡터 길이 계산
    double GetLength() const {
        return std::sqrt(x_ * x_ + y_ * y_);
    }
    
    // 벡터 정규화
    Vector2D& Normalize() {
        double length = GetLength();
        
        if (length > 0.0) {
            x_ /= length;
            y_ /= length;
        }
        
        return *this;  // 메서드 체이닝
    }
    
    // 정보 출력
    void Print() const {
        std::cout << "Vector2D(" << x_ << ", " << y_ << ")\n";
        std::cout << "  길이: " << GetLength() << "\n";
    }
};

int main() {
    Vector2D v1(3.0, 4.0);
    Vector2D v2(1.0, 2.0);
    
    std::cout << "v1: ";
    v1.Print();
    
    std::cout << "\nv2: ";
    v2.Print();
    
    std::cout << "\nv1 + v2: ";
    v1.Add(v2);
    v1.Print();
    
    std::cout << "\nv1 정규화: ";
    v1.Normalize();
    v1.Print();
    
    // 메서드 체이닝 예제
    std::cout << "\n메서드 체이닝 테스트:\n";
    Vector2D v3(10.0, 10.0);
    v3.Add(Vector2D(5.0, 5.0)).Normalize();
    v3.Print();
    
    return 0;
}
```
  

</br>  
</br>  


## 13.8 심화 내용

### 13.8.1 `static` 멤버 변수와 함수
클래스의 모든 객체가 공유하는 변수나 함수를 만들 때 `static` 키워드를 사용한다.

```cpp
#include <iostream>
#include <string>

class Player {
private:
    std::string name_;
    int health_;
    
    // static 멤버 변수: 모든 Player 객체가 공유
    static int totalPlayers_;
    static int nextId_;
    int id_;
    
public:
    Player(const std::string& name, int health)
        : name_(name), health_(health), id_(nextId_++) {
        totalPlayers_++;
        std::cout << "플레이어 #" << id_ << " \"" << name_ << "\"이(가) 생성되었다.\n";
    }
    
    ~Player() {
        totalPlayers_--;
        std::cout << "플레이어 #" << id_ << " \"" << name_ << "\"이(가) 소멸되었다.\n";
    }
    
    // static 멤버 함수: 객체 없이 호출 가능
    static int GetTotalPlayers() {
        return totalPlayers_;
    }
    
    static void ShowStatistics() {
        std::cout << "=== 플레이어 통계 ===\n";
        std::cout << "현재 플레이어 수: " << totalPlayers_ << "\n";
        std::cout << "생성된 총 플레이어 수: " << nextId_ << "\n";
    }
};

// static 멤버 변수는 클래스 외부에서 정의
int Player::totalPlayers_ = 0;
int Player::nextId_ = 1;

int main() {
    std::cout << "게임 시작 시 플레이어 수: " << Player::GetTotalPlayers() << "\n\n";
    
    {
        Player p1("용사", 100);
        Player p2("마법사", 80);
        
        std::cout << "\n";
        Player::ShowStatistics();
        
        {
            Player p3("도적", 90);
            std::cout << "\n";
            Player::ShowStatistics();
        }
        
        std::cout << "\n";
        Player::ShowStatistics();
    }
    
    std::cout << "\n";
    Player::ShowStatistics();
    
    return 0;
}
```

`static` 멤버의 특징:
- 클래스의 모든 객체가 공유한다
- 객체를 생성하지 않아도 접근 가능하다 (클래스명::멤버명)
- `static` 멤버 함수는 `this` 포인터를 가지지 않으며, 비정적 멤버에 접근할 수 없다

### 13.8.2 `friend` 함수와 클래스
때로는 특정 외부 함수나 클래스가 `private` 멤버에 접근해야 할 필요가 있다. 이럴 때 `friend` 키워드를 사용한다.

```cpp
#include <iostream>

class Rectangle {
private:
    double width_;
    double height_;
    
public:
    Rectangle(double w, double h) : width_(w), height_(h) {}
    
    // friend 함수 선언: 이 함수는 private 멤버에 접근 가능
    friend double CalculateArea(const Rectangle& rect);
    friend class GeometryHelper;  // friend 클래스 선언
};

// friend 함수 정의
double CalculateArea(const Rectangle& rect) {
    // private 멤버인 width_와 height_에 직접 접근
    return rect.width_ * rect.height_;
}

// friend 클래스
class GeometryHelper {
public:
    static double GetDiagonal(const Rectangle& rect) {
        // friend 클래스이므로 private 멤버에 접근 가능
        return std::sqrt(rect.width_ * rect.width_ + rect.height_ * rect.height_);
    }
};

int main() {
    Rectangle rect(3.0, 4.0);
    
    std::cout << "넓이: " << CalculateArea(rect) << "\n";
    std::cout << "대각선: " << GeometryHelper::GetDiagonal(rect) << "\n";
    
    return 0;
}
```

`friend`는 캡슐화를 깨뜨릴 수 있으므로 신중하게 사용해야 한다. 일반적으로 연산자 오버로딩이나 밀접하게 관련된 클래스 간의 협력이 필요할 때만 사용한다.

### 13.8.3 중첩 클래스 (Nested Class)
클래스 안에 다른 클래스를 정의할 수 있다. 이를 중첩 클래스 또는 내부 클래스라고 한다.

```cpp
#include <iostream>
#include <vector>
#include <string>

class University {
private:
    std::string name_;
    
    // 중첩 클래스: University와 밀접하게 관련된 Student
    class Student {
    private:
        std::string name_;
        int studentId_;
        double gpa_;
        
    public:
        Student(const std::string& name, int id, double gpa)
            : name_(name), studentId_(id), gpa_(gpa) {}
        
        void DisplayInfo() const {
            std::cout << "학생: " << name_;
            std::cout << " (학번: " << studentId_ << ", 학점: " << gpa_ << ")\n";
        }
        
        double GetGPA() const { return gpa_; }
    };
    
    std::vector<Student> students_;
    
public:
    University(const std::string& name) : name_(name) {}
    
    void AddStudent(const std::string& name, int id, double gpa) {
        students_.emplace_back(name, id, gpa);
    }
    
    void ShowAllStudents() const {
        std::cout << "=== " << name_ << " 학생 목록 ===\n";
        for (const auto& student : students_) {
            student.DisplayInfo();
        }
    }
    
    double GetAverageGPA() const {
        if (students_.empty()) return 0.0;
        
        double sum = 0.0;
        for (const auto& student : students_) {
            sum += student.GetGPA();
        }
        return sum / students_.size();
    }
};

int main() {
    University university("서울대학교");
    
    university.AddStudent("김철수", 20230001, 3.8);
    university.AddStudent("이영희", 20230002, 4.0);
    university.AddStudent("박민수", 20230003, 3.5);
    
    university.ShowAllStudents();
    std::cout << "\n평균 학점: " << university.GetAverageGPA() << "\n";
    
    return 0;
}
```

중첩 클래스는 외부 클래스의 구현 세부사항을 숨기고, 논리적으로 관련된 클래스들을 그룹화할 때 유용하다.
   

</br>  
</br>  


## 13.9 정리
이번 장에서는 C++ 객체지향 프로그래밍의 기초를 다루었다. 다음은 핵심 내용이다:

1. **클래스와 객체**: 클래스는 설계도이고 객체는 그 설계도로 만든 실체다
2. **멤버 변수와 함수**: 클래스는 데이터(멤버 변수)와 기능(멤버 함수)을 하나로 묶는다
3. **접근 지정자**: `public`, `private`, `protected`를 통해 캡슐화를 구현한다
4. **생성자와 소멸자**: 객체의 생성과 소멸 시 자동으로 호출되는 특수 함수다
5. **`this` 포인터**: 현재 객체 자신을 가리키는 포인터다

다음 장에서는 생성자와 소멸자를 더욱 깊이 있게 다루며, Modern C++의 `= default`, `= delete`, 이동 생성자 등을 배운다. 또한 Rule of Five와 Rule of Zero 같은 중요한 개념도 알아본다.

**Modern C++ 관점에서의 조언:**

- 멤버 변수는 항상 `private`으로 선언하고 Getter/Setter로 접근하라
- 멤버 변수 초기화는 멤버 초기화 리스트를 사용하라
- 기본값을 가진 멤버 변수는 클래스 정의에서 직접 초기화하라 (NSDMI)
- 상태를 변경하지 않는 멤버 함수는 `const`로 선언하라
- 메서드 체이닝이 필요하면 `return *this;`를 활용하라

클래스는 Modern C++의 핵심이며, 이후 배울 모든 고급 기능의 기초가 된다. 이번 장의 내용을 확실히 이해하고 넘어가기 바란다.  