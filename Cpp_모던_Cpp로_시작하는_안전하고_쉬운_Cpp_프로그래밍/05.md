# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 5: 입력과 출력
프로그램이 사용자와 소통하려면 입력과 출력 기능이 필수다. C++은 표준 라이브러리를 통해 강력하고 안전한 입출력 기능을 제공한다. 이번 챕터에서는 콘솔 입출력의 기초부터 Modern C++의 최신 기능인 `std::format`과 `std::print`, 그리고 파일 입출력까지 학습한다.

## 5.1 std::cout과 std::cin 기초
C++에서 가장 기본적인 출력은 `std::cout`을 통해, 입력은 `std::cin`을 통해 이루어진다. 이들은 `<iostream>` 헤더에 정의되어 있다.

### 기본 출력

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, C++!\n";
    std::cout << "Modern C++로 안전한 프로그래밍을 배운다\n";

    // 여러 값을 연속해서 출력
    int age = 25;
    std::cout << "나이: " << age << "세\n";

    // 여러 줄 출력
    std::cout << "첫 번째 줄\n";
    std::cout << "두 번째 줄\n";
    std::cout << "세 번째 줄\n";
}
```

**출력:**
```
Hello, C++!
Modern C++로 안전한 프로그래밍을 배운다
나이: 25세
첫 번째 줄
두 번째 줄
세 번째 줄
```

`<<` 연산자는 스트림 삽입 연산자(stream insertion operator)라고 부르며, 데이터를 출력 스트림에 삽입한다. `\n`은 줄바꿈 문자로, 커서를 다음 줄로 이동시킨다.

### std::endl과 \n의 차이

```cpp
#include <iostream>

int main()
{
    // \n 사용: 빠름
    std::cout << "첫 번째 방법\n";
    
    // std::endl 사용: 버퍼를 비우므로 느림
    std::cout << "두 번째 방법" << std::endl;

    // 성능상 \n을 권장
    std::cout << "세 번째 방법\n";
}
```

`std::endl`은 줄바꿈뿐만 아니라 출력 버퍼를 비우는(flush) 작업도 수행한다. 대부분의 경우 버퍼 플러시는 불필요하므로, Modern C++에서는 `\n`을 사용하는 것을 권장한다.

### 기본 입력

```cpp
#include <iostream>

int main()
{
    int number;
    std::cout << "정수를 입력하세요: ";
    std::cin >> number;
    std::cout << "입력한 값: " << number << "\n";

    // 여러 값을 한 번에 입력
    int a, b;
    std::cout << "두 정수를 입력하세요 (공백으로 구분): ";
    std::cin >> a >> b;
    std::cout << "입력한 값: " << a << ", " << b << "\n";

    // 다양한 타입 입력
    std::string name;
    int age;
    double height;

    std::cout << "이름, 나이, 키를 입력하세요: ";
    std::cin >> name >> age >> height;
    std::cout << "이름: " << name << "\n";
    std::cout << "나이: " << age << "세\n";
    std::cout << "키: " << height << "cm\n";
}
```

`>>` 연산자는 스트림 추출 연산자(stream extraction operator)라고 부르며, 입력 스트림에서 데이터를 추출한다. 공백(스페이스, 탭, 줄바꿈)을 구분자로 사용한다.

### 입력 오류 처리
사용자가 잘못된 형식의 데이터를 입력하면 스트림이 오류 상태가 된다.

```cpp
#include <iostream>

int main()
{
    int number;
    std::cout << "정수를 입력하세요: ";
    std::cin >> number;

    // 입력 성공 여부 확인
    if (std::cin.fail())
    {
        std::cout << "오류: 정수가 아닌 값을 입력했다\n";
        
        // 오류 상태 초기화
        std::cin.clear();
        
        // 입력 버퍼 비우기
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }
    else
    {
        std::cout << "입력한 값: " << number << "\n";
    }
}
```

Modern C++에서는 입력 검증을 철저히 하여 프로그램의 안정성을 높이는 것이 중요하다.

### 실용적인 입력 함수 작성

```cpp
#include <iostream>
#include <limits>

int get_valid_integer(const std::string& prompt)
{
    int value;
    while (true)
    {
        std::cout << prompt;
        std::cin >> value;

        if (std::cin.fail())
        {
            std::cout << "오류: 정수를 입력해야 한다\n";
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
        else
        {
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            return value;
        }
    }
}

int main()
{
    int age = get_valid_integer("나이를 입력하세요: ");
    std::cout << "입력한 나이: " << age << "세\n";

    int count = get_valid_integer("개수를 입력하세요: ");
    std::cout << "입력한 개수: " << count << "개\n";
}
```
    

</br>  
</br>  


## 5.2 서식 지정자와 std::format, std::print (C++20/C++23)
전통적인 C++ 출력은 `<<` 연산자를 연쇄적으로 사용하여 가독성이 떨어진다. C++20에서 도입된 `std::format`과 C++23의 `std::print`는 Python의 f-string과 유사한 방식으로 깔끔하고 안전한 출력을 제공한다.

### std::format 기본 사용법

```cpp
#include <iostream>
#include <format>
#include <string>

int main()
{
    // 기본 형식
    std::string message = std::format("Hello, {}!", "World");
    std::cout << message << "\n";

    // 여러 값 포맷팅
    int age = 25;
    std::string name = "철수";
    std::string formatted = std::format("이름: {}, 나이: {}세", name, age);
    std::cout << formatted << "\n";

    // 위치 지정자
    std::cout << std::format("{0}와 {1}, 그리고 다시 {0}\n", "사과", "바나나");

    // 직접 출력
    std::cout << std::format("2 + 3 = {}\n", 2 + 3);
}
```

**출력:**
```
Hello, World!
이름: 철수, 나이: 25세
사과와 바나나, 그리고 다시 사과
2 + 3 = 5
```

### std::print (C++23)
C++23에서 도입된 `std::print`는 `std::format`의 결과를 바로 출력하는 간편한 함수다.

```cpp
#include <print>
#include <string>

int main()
{
    // std::cout 대신 std::print 사용
    std::print("Hello, C++23!\n");

    // 형식화된 출력
    int score = 95;
    std::print("점수: {}점\n", score);

    // 여러 값 출력
    std::string name = "영희";
    int age = 22;
    double height = 165.5;
    std::print("이름: {}, 나이: {}세, 키: {}cm\n", name, age, height);
}
```

**출력:**
```
Hello, C++23!
점수: 95점
이름: 영희, 나이: 22세, 키: 165.5cm
```

`std::print`는 자동으로 줄바꿈을 하지 않으므로, 필요하면 `\n`을 명시적으로 추가해야 한다. 줄바꿈이 필요한 경우 `std::println`을 사용할 수도 있다.

```cpp
#include <print>

int main()
{
    // 자동 줄바꿈이 없음
    std::print("첫 번째 ");
    std::print("두 번째\n");

    // C++23: println으로 자동 줄바꿈
    std::println("세 번째");
    std::println("네 번째");
}
```

### 서식 지정자
`std::format`과 `std::print`는 다양한 서식 지정자를 지원한다.

```cpp
#include <print>

int main()
{
    // 정수 서식
    int number = 42;
    std::println("10진수: {}", number);
    std::println("16진수: {:x}", number);
    std::println("16진수(대문자): {:X}", number);
    std::println("8진수: {:o}", number);
    std::println("2진수: {:b}", number);

    // 너비 지정
    std::println("오른쪽 정렬(10칸): {:>10}", number);
    std::println("왼쪽 정렬(10칸): {:<10}", number);
    std::println("중앙 정렬(10칸): {:^10}", number);

    // 0으로 채우기
    std::println("0으로 채우기: {:05}", number);

    // 부호 표시
    std::println("항상 부호 표시: {:+}", number);
    std::println("음수만 부호 표시: {}", number);
}
```

**출력:**
```
10진수: 42
16진수: 2a
16진수(대문자): 2A
8진수: 52
2진수: 101010
오른쪽 정렬(10칸):         42
왼쪽 정렬(10칸): 42        
중앙 정렬(10칸):     42    
0으로 채우기: 00042
항상 부호 표시: +42
음수만 부호 표시: 42
```

### 실수 서식

```cpp
#include <print>

int main()
{
    double pi = 3.14159265358979323846;

    // 기본 출력
    std::println("기본: {}", pi);

    // 소수점 자릿수 지정
    std::println("소수점 2자리: {:.2f}", pi);
    std::println("소수점 5자리: {:.5f}", pi);
    std::println("소수점 10자리: {:.10f}", pi);

    // 과학적 표기법
    std::println("과학적 표기법: {:e}", pi);
    std::println("과학적 표기법(대문자): {:E}", pi);

    // 너비와 정밀도 함께 사용
    std::println("너비 15, 소수점 3자리: {:15.3f}", pi);

    // 큰 수
    double large = 1234567.89;
    std::println("큰 수: {}", large);
    std::println("큰 수(과학적 표기): {:e}", large);
}
```

**출력:**
```
기본: 3.141592653589793
소수점 2자리: 3.14
소수점 5자리: 3.14159
소수점 10자리: 3.1415926536
과학적 표기법: 3.141593e+00
과학적 표기법(대문자): 3.141593E+00
너비 15, 소수점 3자리:           3.142
큰 수: 1234567.89
큰 수(과학적 표기): 1.234568e+06
```

### 문자열 서식

```cpp
#include <print>
#include <string>

int main()
{
    std::string name = "홍길동";
    std::string job = "프로그래머";

    // 기본 출력
    std::println("이름: {}, 직업: {}", name, job);

    // 너비 지정
    std::println("이름(10칸): {:>10}", name);
    std::println("직업(15칸): {:<15}", job);

    // 특수 문자 포함
    std::string path = "C:\\Users\\Documents";
    std::println("경로: {}", path);

    // 여러 줄 문자열
    std::string multiline = R"(첫 번째 줄
두 번째 줄
세 번째 줄)";
    std::println("{}", multiline);
}
```

### 실용적인 표 만들기

```cpp
#include <print>
#include <vector>
#include <string>

struct Student
{
    std::string name;
    int korean;
    int english;
    int math;
};

int main()
{
    std::vector<Student> students = {
        {"김철수", 85, 90, 88},
        {"이영희", 92, 87, 95},
        {"박민수", 78, 85, 82},
        {"정수진", 88, 91, 89}
    };

    // 표 헤더
    std::println("┌{0:─^10}┬{0:─^8}┬{0:─^8}┬{0:─^8}┬{0:─^8}┐", "");
    std::println("│{:^10}│{:^8}│{:^8}│{:^8}│{:^8}│", 
                 "이름", "국어", "영어", "수학", "평균");
    std::println("├{0:─^10}┼{0:─^8}┼{0:─^8}┼{0:─^8}┼{0:─^8}┤", "");

    // 학생 데이터
    for (const auto& student : students)
    {
        double average = (student.korean + student.english + student.math) / 3.0;
        std::println("│{:^10}│{:^8}│{:^8}│{:^8}│{:^8.1f}│",
                     student.name, student.korean, student.english, 
                     student.math, average);
    }

    std::println("└{0:─^10}┴{0:─^8}┴{0:─^8}┴{0:─^8}┴{0:─^8}┘", "");
}
```

**출력:**
```
┌──────────┬────────┬────────┬────────┬────────┐
│   이름   │  국어  │  영어  │  수학  │  평균  │
├──────────┼────────┼────────┼────────┼────────┤
│  김철수  │   85   │   90   │   88   │  87.7  │
│  이영희  │   92   │   87   │   95   │  91.3  │
│  박민수  │   78   │   85   │   82   │  81.7  │
│  정수진  │   88   │   91   │   89   │  89.3  │
└──────────┴────────┴────────┴────────┴────────┘
```

### 색상 출력 (터미널 지원 시)
일부 터미널에서는 ANSI 이스케이프 코드를 통해 색상 출력이 가능하다.

```cpp
#include <print>

int main()
{
    // ANSI 색상 코드
    std::string reset = "\033[0m";
    std::string red = "\033[31m";
    std::string green = "\033[32m";
    std::string yellow = "\033[33m";
    std::string blue = "\033[34m";

    std::println("{}빨간색 텍스트{}", red, reset);
    std::println("{}초록색 텍스트{}", green, reset);
    std::println("{}노란색 텍스트{}", yellow, reset);
    std::println("{}파란색 텍스트{}", blue, reset);

    // 배경색
    std::string bg_red = "\033[41m";
    std::string bg_green = "\033[42m";
    std::println("{}빨간 배경{}", bg_red, reset);
    std::println("{}초록 배경{}", bg_green, reset);
}
```
  

</br>  
</br>  
  

## 5.3 문자열 입출력과 getline
`std::cin`은 공백을 구분자로 사용하므로, 공백이 포함된 문자열을 입력받으려면 `std::getline`을 사용해야 한다.

### std::cin의 한계

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string name;
    
    std::cout << "이름을 입력하세요: ";
    std::cin >> name;  // 공백 전까지만 읽음
    
    std::cout << "입력한 이름: " << name << "\n";
    // "홍 길동"을 입력하면 "홍"만 저장됨
}
```

### std::getline 사용

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string full_name;
    
    std::cout << "전체 이름을 입력하세요: ";
    std::getline(std::cin, full_name);
    
    std::cout << "입력한 이름: " << full_name << "\n";
    // "홍 길동"을 입력하면 "홍 길동" 전체가 저장됨
}
```

### std::cin과 std::getline 혼용 시 주의사항
`std::cin`과 `std::getline`을 함께 사용할 때는 입력 버퍼에 남아있는 줄바꿈 문자를 처리해야 한다.

```cpp
#include <iostream>
#include <string>

int main()
{
    int age;
    std::string name;

    std::cout << "나이를 입력하세요: ";
    std::cin >> age;

    // 입력 버퍼에 남은 줄바꿈 문자 제거
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    std::cout << "이름을 입력하세요: ";
    std::getline(std::cin, name);

    std::cout << "나이: " << age << "세\n";
    std::cout << "이름: " << name << "\n";
}
```

`std::cin.ignore()`를 호출하지 않으면, `std::getline`이 남아있는 줄바꿈 문자를 읽어 빈 문자열을 반환한다.

### 구분자를 지정한 입력
`std::getline`은 기본적으로 줄바꿈 문자(`\n`)를 구분자로 사용하지만, 다른 구분자를 지정할 수도 있다.

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string data;

    std::cout << "쉼표로 구분된 데이터를 입력하세요: ";
    std::getline(std::cin, data, ',');  // 쉼표를 구분자로 사용

    std::cout << "첫 번째 항목: " << data << "\n";

    std::getline(std::cin, data, ',');
    std::cout << "두 번째 항목: " << data << "\n";

    std::getline(std::cin, data);  // 나머지 전체
    std::cout << "나머지: " << data << "\n";
}
```

**입력:** `사과,바나나,오렌지`

**출력:**
```
첫 번째 항목: 사과
두 번째 항목: 바나나
나머지: 오렌지
```

### CSV 파싱 예제

```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <vector>

std::vector<std::string> parse_csv_line(const std::string& line)
{
    std::vector<std::string> result;
    std::stringstream ss(line);
    std::string item;

    while (std::getline(ss, item, ','))
    {
        result.push_back(item);
    }

    return result;
}

int main()
{
    std::string csv_line = "홍길동,25,서울,프로그래머";
    
    auto fields = parse_csv_line(csv_line);

    std::cout << "이름: " << fields[0] << "\n";
    std::cout << "나이: " << fields[1] << "\n";
    std::cout << "지역: " << fields[2] << "\n";
    std::cout << "직업: " << fields[3] << "\n";
}
```

### 여러 줄 입력 받기

```cpp
#include <iostream>
#include <string>
#include <vector>

int main()
{
    std::vector<std::string> lines;
    std::string line;

    std::cout << "여러 줄을 입력하세요 (빈 줄을 입력하면 종료):\n";

    while (true)
    {
        std::getline(std::cin, line);
        
        if (line.empty())
        {
            break;
        }

        lines.push_back(line);
    }

    std::cout << "\n입력한 내용:\n";
    for (size_t i = 0; i < lines.size(); ++i)
    {
        std::cout << (i + 1) << ": " << lines[i] << "\n";
    }
}
```
   

</br>  
</br>  

  
## 5.4 파일 입출력 기초
파일 입출력은 데이터를 영구적으로 저장하고 읽어오는 핵심 기능이다. C++은 `<fstream>` 헤더를 통해 파일 스트림을 제공한다.

### 파일에 쓰기

```cpp
#include <fstream>
#include <iostream>
#include <string>

int main()
{
    // 파일 출력 스트림 생성
    std::ofstream output_file("output.txt");

    // 파일 열림 확인
    if (!output_file.is_open())
    {
        std::cout << "파일을 열 수 없다\n";
        return 1;
    }

    // 파일에 데이터 쓰기
    output_file << "Hello, File I/O!\n";
    output_file << "Modern C++ 파일 입출력\n";
    output_file << "숫자: " << 42 << "\n";
    output_file << "실수: " << 3.14 << "\n";

    // 파일 자동 닫힘 (RAII)
    std::cout << "파일 쓰기 완료\n";
}
```

`std::ofstream`은 RAII 패턴을 따르므로, 객체가 소멸될 때 자동으로 파일이 닫힌다. 명시적으로 `close()`를 호출할 필요는 없지만, 원한다면 호출할 수 있다.

### 파일에서 읽기

```cpp
#include <fstream>
#include <iostream>
#include <string>

int main()
{
    // 파일 입력 스트림 생성
    std::ifstream input_file("output.txt");

    if (!input_file.is_open())
    {
        std::cout << "파일을 열 수 없다\n";
        return 1;
    }

    // 한 줄씩 읽기
    std::string line;
    while (std::getline(input_file, line))
    {
        std::cout << line << "\n";
    }

    std::cout << "파일 읽기 완료\n";
}
```

### 파일 열기 모드
파일을 열 때 다양한 모드를 지정할 수 있다.

```cpp
#include <fstream>
#include <iostream>

int main()
{
    // 기본 쓰기 모드 (파일이 있으면 덮어씀)
    std::ofstream file1("file1.txt");

    // 추가 모드 (파일 끝에 내용 추가)
    std::ofstream file2("file2.txt", std::ios::app);

    // 이진 모드
    std::ofstream file3("file3.bin", std::ios::binary);

    // 모드 조합 (이진 + 추가)
    std::ofstream file4("file4.bin", std::ios::binary | std::ios::app);

    // 읽기와 쓰기 동시
    std::fstream file5("file5.txt", std::ios::in | std::ios::out);

    if (file2.is_open())
    {
        file2 << "추가된 내용\n";
    }

    std::cout << "여러 모드로 파일 처리 완료\n";
}
```

주요 파일 열기 모드는 다음과 같다.

- `std::ios::in`: 읽기
- `std::ios::out`: 쓰기
- `std::ios::app`: 추가 (append)
- `std::ios::binary`: 이진 모드
- `std::ios::trunc`: 파일 내용 삭제 (truncate)

### 구조화된 데이터 저장과 로드

```cpp
#include <fstream>
#include <print>
#include <string>
#include <vector>

struct Person
{
    std::string name;
    int age;
    double height;
};

void save_people(const std::vector<Person>& people, const std::string& filename)
{
    std::ofstream file(filename);
    
    if (!file.is_open())
    {
        std::println("파일을 열 수 없다: {}", filename);
        return;
    }

    for (const auto& person : people)
    {
        file << person.name << "," 
             << person.age << "," 
             << person.height << "\n";
    }

    std::println("{}에 {} 명의 데이터 저장 완료", filename, people.size());
}

std::vector<Person> load_people(const std::string& filename)
{
    std::vector<Person> people;
    std::ifstream file(filename);

    if (!file.is_open())
    {
        std::println("파일을 열 수 없다: {}", filename);
        return people;
    }

    std::string line;
    while (std::getline(file, line))
    {
        Person person;
        size_t pos1 = line.find(',');
        size_t pos2 = line.find(',', pos1 + 1);

        person.name = line.substr(0, pos1);
        person.age = std::stoi(line.substr(pos1 + 1, pos2 - pos1 - 1));
        person.height = std::stod(line.substr(pos2 + 1));

        people.push_back(person);
    }

    std::println("{}에서 {} 명의 데이터 로드 완료", filename, people.size());
    return people;
}

int main()
{
    // 데이터 생성
    std::vector<Person> people = {
        {"홍길동", 25, 175.5},
        {"김철수", 30, 180.0},
        {"이영희", 28, 165.3}
    };

    // 파일에 저장
    save_people(people, "people.csv");

    // 파일에서 로드
    auto loaded_people = load_people("people.csv");

    // 로드된 데이터 출력
    for (const auto& person : loaded_people)
    {
        std::println("이름: {}, 나이: {}, 키: {:.1f}cm", 
                     person.name, person.age, person.height);
    }
}
```

**출력:**
```
people.csv에 3 명의 데이터 저장 완료
people.csv에서 3 명의 데이터 로드 완료
이름: 홍길동, 나이: 25, 키: 175.5cm
이름: 김철수, 나이: 30, 키: 180.0cm
이름: 이영희, 나이: 28, 키: 165.3cm
```

### 이진 파일 입출력
텍스트 파일이 아닌 이진 데이터를 저장할 때는 `std::ios::binary` 모드를 사용한다.

```cpp
#include <fstream>
#include <print>
#include <vector>

void save_binary_data(const std::vector<int>& data, const std::string& filename)
{
    std::ofstream file(filename, std::ios::binary);

    if (!file.is_open())
    {
        std::println("파일을 열 수 없다: {}", filename);
        return;
    }

    // 벡터 크기 저장
    size_t size = data.size();
    file.write(reinterpret_cast<const char*>(&size), sizeof(size));

    // 데이터 저장
    file.write(reinterpret_cast<const char*>(data.data()), 
               data.size() * sizeof(int));

    std::println("{}에 이진 데이터 저장 완료", filename);
}

std::vector<int> load_binary_data(const std::string& filename)
{
    std::ifstream file(filename, std::ios::binary);

    if (!file.is_open())
    {
        std::println("파일을 열 수 없다: {}", filename);
        return {};
    }

    // 벡터 크기 읽기
    size_t size;
    file.read(reinterpret_cast<char*>(&size), sizeof(size));

    // 데이터 읽기
    std::vector<int> data(size);
    file.read(reinterpret_cast<char*>(data.data()), 
              size * sizeof(int));

    std::println("{}에서 이진 데이터 로드 완료", filename);
    return data;
}

int main()
{
    // 데이터 생성
    std::vector<int> numbers = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

    // 이진 파일로 저장
    save_binary_data(numbers, "data.bin");

    // 이진 파일에서 로드
    auto loaded_numbers = load_binary_data("data.bin");

    // 로드된 데이터 출력
    std::print("로드된 숫자: ");
    for (int num : loaded_numbers)
    {
        std::print("{} ", num);
    }
    std::println("");
}
```

### 파일 존재 여부 확인

```cpp
#include <fstream>
#include <print>
#include <string>

bool file_exists(const std::string& filename)
{
    std::ifstream file(filename);
    return file.good();
}

int main()
{
    std::string filename = "test.txt";

    if (file_exists(filename))
    {
        std::println("파일 {}이(가) 존재한다", filename);
    }
    else
    {
        std::println("파일 {}이(가) 존재하지 않는다", filename);
    }
}
```

Modern C++에서는 `<filesystem>` 라이브러리를 사용하여 더 안전하고 강력한 파일 시스템 작업을 수행할 수 있다. (Chapter 23에서 자세히 다룬다)
  

</br>  
</br>  
  

## 5.5 실습 예제: 메모장 프로그램
지금까지 배운 입출력 기능을 활용하여 간단한 메모장 프로그램을 만들어보자.

```cpp
#include <fstream>
#include <print>
#include <string>
#include <vector>
#include <limits>

class SimpleNotebook
{
private:
    std::vector<std::string> notes;
    std::string filename;

public:
    SimpleNotebook(const std::string& file) : filename(file)
    {
        load();
    }

    void add_note()
    {
        std::string note;
        std::println("\n메모를 입력하세요 (빈 줄을 입력하면 종료):");
        
        std::string line;
        while (std::getline(std::cin, line))
        {
            if (line.empty())
            {
                break;
            }
            note += line + "\n";
        }

        if (!note.empty())
        {
            notes.push_back(note);
            std::println("메모가 추가되었다");
        }
    }

    void list_notes()
    {
        if (notes.empty())
        {
            std::println("\n저장된 메모가 없다");
            return;
        }

        std::println("\n=== 저장된 메모 목록 ===");
        for (size_t i = 0; i < notes.size(); ++i)
        {
            std::println("\n[메모 {}]", i + 1);
            std::println("{}", notes[i]);
            std::println("{}",  std::string(40, '-'));
        }
    }

    void delete_note()
    {
        if (notes.empty())
        {
            std::println("\n삭제할 메모가 없다");
            return;
        }

        list_notes();

        int index;
        std::print("\n삭제할 메모 번호: ");
        std::cin >> index;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

        if (index > 0 && index <= static_cast<int>(notes.size()))
        {
            notes.erase(notes.begin() + index - 1);
            std::println("메모가 삭제되었다");
        }
        else
        {
            std::println("잘못된 번호다");
        }
    }

    void save()
    {
        std::ofstream file(filename);
        
        if (!file.is_open())
        {
            std::println("파일을 저장할 수 없다");
            return;
        }

        for (const auto& note : notes)
        {
            file << "---NOTE---\n";
            file << note;
            file << "---END---\n";
        }

        std::println("파일에 저장되었다");
    }

    void load()
    {
        std::ifstream file(filename);

        if (!file.is_open())
        {
            return;  // 파일이 없으면 무시
        }

        std::string line;
        std::string current_note;
        bool reading_note = false;

        while (std::getline(file, line))
        {
            if (line == "---NOTE---")
            {
                reading_note = true;
                current_note.clear();
            }
            else if (line == "---END---")
            {
                reading_note = false;
                if (!current_note.empty())
                {
                    notes.push_back(current_note);
                }
            }
            else if (reading_note)
            {
                current_note += line + "\n";
            }
        }

        if (!notes.empty())
        {
            std::println("{}개의 메모를 불러왔다", notes.size());
        }
    }
};

void show_menu()
{
    std::println("\n=== 간단한 메모장 ===");
    std::println("1. 메모 추가");
    std::println("2. 메모 목록");
    std::println("3. 메모 삭제");
    std::println("4. 저장");
    std::println("5. 종료");
    std::print("선택: ");
}

int main()
{
    SimpleNotebook notebook("notes.txt");

    while (true)
    {
        show_menu();

        int choice;
        std::cin >> choice;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

        if (choice == 1)
        {
            notebook.add_note();
        }
        else if (choice == 2)
        {
            notebook.list_notes();
        }
        else if (choice == 3)
        {
            notebook.delete_note();
        }
        else if (choice == 4)
        {
            notebook.save();
        }
        else if (choice == 5)
        {
            notebook.save();
            std::println("프로그램을 종료한다");
            break;
        }
        else
        {
            std::println("잘못된 선택이다");
        }
    }
}
```
  

</br>  
</br>  
  
  
## 5.6 실습 문제

### 문제 1: 단어 카운터
텍스트 파일을 읽어 총 단어 수, 줄 수, 문자 수를 세는 프로그램을 작성하라.

```cpp
#include <fstream>
#include <print>
#include <string>
#include <sstream>

int main()
{
    // 여기에 코드를 작성하라
    
    return 0;
}
```

**힌트**: `std::getline`으로 한 줄씩 읽고, `std::stringstream`으로 단어를 분리한다.

### 문제 2: 성적 관리 프로그램
학생의 이름과 점수를 입력받아 파일에 저장하고, 평균, 최고점, 최저점을 출력하는 프로그램을 작성하라.

```cpp
#include <fstream>
#include <print>
#include <string>
#include <vector>

struct Student
{
    std::string name;
    int score;
};

int main()
{
    // 여기에 코드를 작성하라
    
    return 0;
}
```

### 문제 3: 로그 파일 생성기
현재 날짜와 시간을 포함한 로그 메시지를 파일에 기록하는 함수를 작성하라.

```cpp
#include <fstream>
#include <print>
#include <string>
#include <chrono>
#include <format>

void log_message(const std::string& message)
{
    // 여기에 코드를 작성하라
    // 힌트: std::chrono로 현재 시간을 얻는다
}

int main()
{
    log_message("프로그램 시작");
    log_message("데이터 로드 완료");
    log_message("프로그램 종료");
    
    return 0;
}
```

### 문제 4: CSV 파일 파서
CSV 파일을 읽어 표 형태로 출력하는 프로그램을 작성하라.

```cpp
#include <fstream>
#include <print>
#include <string>
#include <vector>
#include <sstream>

int main()
{
    // 여기에 코드를 작성하라
    // data.csv 파일을 읽어 표 형태로 출력
    
    return 0;
}
```
   

</br>  
</br>  
  
  
## 5.7 심화 내용

### 스트림 상태 확인
파일 스트림은 여러 상태 플래그를 가지며, 이를 확인하여 오류를 처리할 수 있다.

```cpp
#include <fstream>
#include <print>
#include <string>

int main()
{
    std::ifstream file("nonexistent.txt");

    // 다양한 상태 확인 방법
    if (file.good())
    {
        std::println("스트림이 정상 상태다");
    }

    if (file.eof())
    {
        std::println("파일의 끝에 도달했다");
    }

    if (file.fail())
    {
        std::println("논리적 오류가 발생했다");
    }

    if (file.bad())
    {
        std::println("읽기/쓰기 오류가 발생했다");
    }

    // 상태 확인을 이용한 안전한 읽기
    std::ifstream data_file("data.txt");
    int value;

    while (data_file >> value)
    {
        std::println("읽은 값: {}", value);
        
        if (data_file.fail() && !data_file.eof())
        {
            std::println("읽기 오류 발생");
            data_file.clear();  // 오류 플래그 초기화
            data_file.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
    }
}
```

### 파일 위치 제어
파일 내에서 읽기/쓰기 위치를 이동할 수 있다.

```cpp
#include <fstream>
#include <print>
#include <string>

int main()
{
    // 파일 생성 및 데이터 쓰기
    std::ofstream out_file("position_test.txt");
    out_file << "0123456789";
    out_file.close();

    // 파일 읽기와 위치 제어
    std::ifstream in_file("position_test.txt");

    // 현재 위치 확인
    std::streampos pos = in_file.tellg();
    std::println("현재 위치: {}", static_cast<long>(pos));

    // 특정 위치로 이동
    in_file.seekg(5);  // 5바이트 위치로 이동
    char ch;
    in_file >> ch;
    std::println("5번째 문자: {}", ch);

    // 상대적 위치 이동
    in_file.seekg(-3, std::ios::cur);  // 현재 위치에서 3바이트 뒤로
    in_file >> ch;
    std::println("3바이트 뒤로 이동 후: {}", ch);

    // 파일 끝에서 이동
    in_file.seekg(-1, std::ios::end);  // 파일 끝에서 1바이트 앞으로
    in_file >> ch;
    std::println("파일 끝에서 1바이트 앞: {}", ch);
}
```

### 버퍼링 제어
스트림의 버퍼링을 제어하여 성능을 최적화하거나 즉시 출력할 수 있다.

```cpp
#include <iostream>
#include <fstream>
#include <print>

int main()
{
    std::ofstream file("buffered.txt");

    // 버퍼링된 쓰기 (기본값)
    for (int i = 0; i < 1000; ++i)
    {
        file << i << "\n";
    }

    // 명시적 버퍼 비우기
    file.flush();

    // unitbuf 조작자로 자동 플러시
    file << std::unitbuf;
    file << "이 줄은 즉시 쓰인다\n";
    file << std::nounitbuf;

    // cout의 버퍼 제어
    std::cout << "버퍼링됨 ";
    std::cout.flush();  // 즉시 출력
    std::cout << "즉시 출력됨\n";
}
```

### 사용자 정의 타입 출력
`operator<<`를 오버로딩하여 사용자 정의 타입을 스트림에 출력할 수 있다.

```cpp
#include <iostream>
#include <print>
#include <string>

struct Point
{
    int x;
    int y;
};

// 출력 연산자 오버로딩
std::ostream& operator<<(std::ostream& os, const Point& p)
{
    os << "(" << p.x << ", " << p.y << ")";
    return os;
}

// 입력 연산자 오버로딩
std::istream& operator>>(std::istream& is, Point& p)
{
    char ch;
    is >> ch >> p.x >> ch >> p.y >> ch;  // (x, y) 형식으로 입력
    return is;
}

int main()
{
    Point p1 = {10, 20};
    
    // 직접 출력 가능
    std::cout << "점의 위치: " << p1 << "\n";

    // 파일에 쓰기
    std::ofstream file("points.txt");
    file << p1 << "\n";
    file.close();

    // 파일에서 읽기
    std::ifstream in_file("points.txt");
    Point p2;
    in_file >> p2;
    std::cout << "파일에서 읽은 점: " << p2 << "\n";
}
```

### std::format을 활용한 고급 포맷팅
`std::format`은 사용자 정의 포맷터를 만들 수 있다.

```cpp
#include <format>
#include <print>
#include <string>

struct RGB
{
    int r, g, b;
};

// std::format을 위한 특수화
template<>
struct std::formatter<RGB>
{
    constexpr auto parse(std::format_parse_context& ctx)
    {
        return ctx.begin();
    }

    auto format(const RGB& color, std::format_context& ctx) const
    {
        return std::format_to(ctx.out(), "RGB({}, {}, {})", 
                             color.r, color.g, color.b);
    }
};

int main()
{
    RGB red = {255, 0, 0};
    RGB green = {0, 255, 0};

    // 사용자 정의 타입을 std::format으로 출력
    std::println("빨강: {}", red);
    std::println("초록: {}", green);

    // 파일에도 포맷팅하여 쓰기 가능
    std::ofstream file("colors.txt");
    file << std::format("빨강: {}\n", red);
    file << std::format("초록: {}\n", green);
}
```
  

</br>  
</br>  
  

## 정리
이번 챕터에서는 C++의 입출력 시스템을 종합적으로 학습했다. 전통적인 `std::cout`과 `std::cin`부터 시작하여, Modern C++의 `std::format`과 `std::print`를 통한 안전하고 편리한 출력, 그리고 `std::getline`을 활용한 문자열 입력과 파일 입출력의 기초까지 다루었다.

Modern C++에서 입출력의 핵심은 안전성과 편의성이다. `std::format`과 `std::print`는 타입 안전한 방식으로 데이터를 포맷팅하며, RAII 패턴을 따르는 파일 스트림은 자동으로 리소스를 관리한다. 입력 검증을 철저히 하고, 오류 상태를 확인하는 습관을 들이면 견고한 프로그램을 작성할 수 있다.

다음 챕터에서는 조건문을 학습하여 프로그램이 상황에 따라 다른 동작을 수행하도록 만드는 방법을 배운다. 입출력과 조건문을 결합하면 사용자와 상호작용하는 지능적인 프로그램을 만들 수 있다.  