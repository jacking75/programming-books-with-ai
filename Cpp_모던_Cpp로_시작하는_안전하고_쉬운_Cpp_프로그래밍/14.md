# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 14: 생성자와 소멸자의 Modern 접근
지난 장에서 생성자와 소멸자의 기본 개념을 배웠다. 이번 장에서는 Modern C++의 관점에서 생성자와 소멸자를 더 깊이 있게 다룬다. 특히 C++11 이후 도입된 이동 의미론(Move Semantics), `= default`와 `= delete` 키워드, 그리고 안전한 클래스 설계를 위한 Rule of Five와 Rule of Zero를 배운다.

## 14.1 기본 생성자와 매개변수 생성자 심화

### 14.1.1 생성자의 종류
C++에서 클래스는 여러 종류의 생성자를 가질 수 있다.

```cpp
#include <iostream>
#include <string>

class Player {
private:
    std::string name_;
    int level_;
    int health_;
    
public:
    // 1. 기본 생성자 (Default Constructor)
    Player() : name_("Unknown"), level_(1), health_(100) {
        std::cout << "기본 생성자 호출\n";
    }
    
    // 2. 매개변수 생성자 (Parameterized Constructor)
    Player(const std::string& name) : name_(name), level_(1), health_(100) {
        std::cout << "이름만 받는 생성자 호출\n";
    }
    
    // 3. 여러 매개변수를 받는 생성자
    Player(const std::string& name, int level, int health)
        : name_(name), level_(level), health_(health) {
        std::cout << "모든 매개변수를 받는 생성자 호출\n";
    }
    
    void DisplayInfo() const {
        std::cout << "이름: " << name_ << ", 레벨: " << level_;
        std::cout << ", 체력: " << health_ << "\n";
    }
};

int main() {
    Player p1;                              // 기본 생성자
    Player p2("전사");                      // 이름만 받는 생성자
    Player p3("마법사", 10, 80);            // 모든 매개변수를 받는 생성자
    
    p1.DisplayInfo();
    p2.DisplayInfo();
    p3.DisplayInfo();
    
    return 0;
}
```

### 14.1.2 기본 인자를 활용한 생성자
생성자 오버로딩을 줄이고 싶다면 기본 인자를 사용할 수 있다.

```cpp
class Player {
private:
    std::string name_;
    int level_;
    int health_;
    
public:
    // 하나의 생성자로 여러 경우를 처리
    Player(const std::string& name = "Unknown", 
           int level = 1, 
           int health = 100)
        : name_(name), level_(level), health_(health) {
        std::cout << "생성자 호출: " << name_ << "\n";
    }
    
    void DisplayInfo() const {
        std::cout << "이름: " << name_ << ", 레벨: " << level_;
        std::cout << ", 체력: " << health_ << "\n";
    }
};

int main() {
    Player p1;                          // 모든 기본값 사용
    Player p2("전사");                  // 이름만 지정
    Player p3("마법사", 10);            // 이름과 레벨 지정
    Player p4("궁수", 5, 90);           // 모두 지정
    
    p1.DisplayInfo();
    p2.DisplayInfo();
    p3.DisplayInfo();
    p4.DisplayInfo();
    
    return 0;
}
```

하지만 이 방식은 주의가 필요하다. 중간 매개변수만 기본값을 사용하고 싶을 때는 불가능하기 때문이다.

```cpp
// Player p5("도적", 100);  // 레벨을 기본값으로, 체력만 100으로 하고 싶지만 불가능!
```

이런 경우 명명된 매개변수 관용구(Named Parameter Idiom)나 빌더 패턴을 사용할 수 있지만, 초보자에게는 단순히 필요한 생성자들을 명시적으로 오버로딩하는 것이 더 명확하다.

### 14.1.3 명시적 생성자 (explicit)
단일 매개변수 생성자는 암묵적 타입 변환을 허용한다. 이는 때로 예상치 못한 버그를 일으킬 수 있다.

```cpp
#include <iostream>
#include <string>

class Document {
private:
    std::string content_;
    
public:
    // 암묵적 변환을 허용하는 생성자
    Document(const std::string& content) : content_(content) {
        std::cout << "Document 생성: " << content_ << "\n";
    }
    
    void Print() const {
        std::cout << "내용: " << content_ << "\n";
    }
};

void ProcessDocument(const Document& doc) {
    doc.Print();
}

int main() {
    Document doc1("Hello");
    ProcessDocument(doc1);              // 정상
    
    // 암묵적 변환이 발생! std::string → Document
    ProcessDocument("World");           // Document("World") 가 자동 생성됨
    
    return 0;
}
```

위 코드에서 `ProcessDocument("World")`는 암묵적으로 `Document` 객체를 생성한다. 이는 편리할 수 있지만, 의도하지 않은 변환이 발생할 수 있다.

이를 방지하려면 `explicit` 키워드를 사용한다.

```cpp
class Document {
private:
    std::string content_;
    
public:
    // 명시적 생성자: 암묵적 변환 금지
    explicit Document(const std::string& content) : content_(content) {
        std::cout << "Document 생성: " << content_ << "\n";
    }
    
    void Print() const {
        std::cout << "내용: " << content_ << "\n";
    }
};

void ProcessDocument(const Document& doc) {
    doc.Print();
}

int main() {
    Document doc1("Hello");
    ProcessDocument(doc1);                      // 정상
    
    // ProcessDocument("World");                // 컴파일 오류!
    ProcessDocument(Document("World"));         // 명시적 변환은 가능
    
    return 0;
}
```

**Modern C++ 권장사항:** 단일 매개변수 생성자는 특별한 이유가 없는 한 `explicit`으로 선언하라.

   
</br>     
</br>     
  

## 14.2 생성자 위임과 멤버 초기화 리스트

### 14.2.1 생성자 위임 (Constructor Delegation)
C++11부터는 한 생성자가 같은 클래스의 다른 생성자를 호출할 수 있다. 이를 생성자 위임이라고 한다.

**생성자 위임이 없을 때의 코드 중복:**

```cpp
class Rectangle {
private:
    double width_;
    double height_;
    std::string color_;
    
public:
    Rectangle() {
        width_ = 1.0;
        height_ = 1.0;
        color_ = "white";
        // 공통 초기화 코드
        std::cout << "사각형 생성됨\n";
    }
    
    Rectangle(double width, double height) {
        width_ = width;
        height_ = height;
        color_ = "white";
        // 공통 초기화 코드 중복!
        std::cout << "사각형 생성됨\n";
    }
    
    Rectangle(double width, double height, const std::string& color) {
        width_ = width;
        height_ = height;
        color_ = color;
        // 공통 초기화 코드 중복!
        std::cout << "사각형 생성됨\n";
    }
};
```

**생성자 위임을 사용한 개선:**

```cpp
class Rectangle {
private:
    double width_;
    double height_;
    std::string color_;
    
public:
    // 주 생성자 (Target Constructor)
    Rectangle(double width, double height, const std::string& color)
        : width_(width), height_(height), color_(color) {
        // 공통 초기화 코드를 한 곳에만!
        std::cout << "사각형 생성됨: " << width_ << " x " << height_;
        std::cout << ", 색상: " << color_ << "\n";
    }
    
    // 위임 생성자들 (Delegating Constructors)
    Rectangle() : Rectangle(1.0, 1.0, "white") {
        // 추가 작업이 필요하면 여기에
    }
    
    Rectangle(double width, double height) 
        : Rectangle(width, height, "white") {
    }
};

int main() {
    Rectangle r1;
    Rectangle r2(5.0, 3.0);
    Rectangle r3(10.0, 8.0, "blue");
    
    return 0;
}
```

**출력 결과:**
```
사각형 생성됨: 1 x 1, 색상: white
사각형 생성됨: 5 x 3, 색상: white
사각형 생성됨: 10 x 8, 색상: blue
```

생성자 위임의 장점:
1. 코드 중복 제거
2. 초기화 로직을 한 곳에서 관리
3. 유지보수 용이성 향상

**주의사항:** 생성자 위임을 사용할 때는 멤버 초기화 리스트에서 다른 생성자를 호출하며, 추가로 멤버를 초기화할 수 없다.

```cpp
// 잘못된 예
Rectangle() : Rectangle(1.0, 1.0, "white"), width_(2.0) {  // 오류!
}
```

### 14.2.2 멤버 초기화 리스트의 중요성
멤버 초기화 리스트는 생성자 본문이 실행되기 전에 멤버를 초기화한다. 이는 대입과는 다르다.

```cpp
#include <iostream>

class ExpensiveObject {
public:
    ExpensiveObject() {
        std::cout << "ExpensiveObject 기본 생성자\n";
    }
    
    ExpensiveObject(const ExpensiveObject&) {
        std::cout << "ExpensiveObject 복사 생성자\n";
    }
    
    ExpensiveObject& operator=(const ExpensiveObject&) {
        std::cout << "ExpensiveObject 대입 연산자\n";
        return *this;
    }
};

class Container {
private:
    ExpensiveObject obj_;
    
public:
    // 나쁜 방법: 생성자 본문에서 대입
    Container(const ExpensiveObject& obj) {
        // obj_가 먼저 기본 생성되고, 그 다음 대입됨
        obj_ = obj;
    }
};

class BetterContainer {
private:
    ExpensiveObject obj_;
    
public:
    // 좋은 방법: 멤버 초기화 리스트 사용
    BetterContainer(const ExpensiveObject& obj) : obj_(obj) {
        // obj_가 복사 생성자로 직접 초기화됨
    }
};

int main() {
    ExpensiveObject source;
    
    std::cout << "\n=== Container 생성 ===\n";
    Container c(source);
    
    std::cout << "\n=== BetterContainer 생성 ===\n";
    BetterContainer bc(source);
    
    return 0;
}
```

**출력 결과:**
```
ExpensiveObject 기본 생성자

=== Container 생성 ===
ExpensiveObject 기본 생성자
ExpensiveObject 대입 연산자

=== BetterContainer 생성 ===
ExpensiveObject 복사 생성자
```

`Container`는 불필요하게 기본 생성자와 대입 연산자를 모두 호출하지만, `BetterContainer`는 복사 생성자 한 번만 호출한다. 이는 성능에 큰 차이를 만든다.

### 14.2.3 초기화 순서
멤버 변수는 클래스에 **선언된 순서대로** 초기화된다. 초기화 리스트의 순서는 상관없다.

```cpp
class Order {
private:
    int first_;
    int second_;
    int third_;
    
public:
    // 초기화 리스트의 순서와 관계없이,
    // 선언 순서대로 first_ → second_ → third_ 초기화됨
    Order(int a, int b, int c) : third_(c), first_(a), second_(b) {
        std::cout << "first_: " << first_ << "\n";
        std::cout << "second_: " << second_ << "\n";
        std::cout << "third_: " << third_ << "\n";
    }
};
```

이는 특히 한 멤버가 다른 멤버에 의존할 때 중요하다.

```cpp
class Dangerous {
private:
    int size_;
    int* data_;
    
public:
    // 위험! data_가 size_보다 먼저 선언되어 있으므로,
    // size_가 초기화되기 전에 data_ 초기화가 시도됨
    Dangerous(int size) : data_(new int[size_]), size_(size) {
        // data_를 초기화할 때 size_는 아직 쓰레기 값!
    }
};

class Safe {
private:
    int size_;      // 먼저 선언
    int* data_;     // 나중에 선언
    
public:
    // 안전: 선언 순서대로 size_ → data_ 초기화
    Safe(int size) : size_(size), data_(new int[size_]) {
        // size_가 먼저 초기화되므로 안전
    }
    
    ~Safe() {
        delete[] data_;
    }
};
```

**Modern C++ 권장사항:** 멤버 초기화 리스트의 순서를 선언 순서와 일치시켜라. 많은 컴파일러가 순서가 다를 때 경고를 준다.

    
</br>     
  
  
## 14.3 복사 생성자와 이동 생성자

### 14.3.1 복사 생성자 (Copy Constructor)
복사 생성자는 같은 타입의 다른 객체로부터 새 객체를 생성할 때 호출된다.

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data_;
    size_t length_;
    
public:
    // 일반 생성자
    String(const char* str = "") {
        length_ = std::strlen(str);
        data_ = new char[length_ + 1];
        std::strcpy(data_, str);
        std::cout << "생성자: \"" << data_ << "\" 생성됨\n";
    }
    
    // 복사 생성자
    String(const String& other) {
        length_ = other.length_;
        data_ = new char[length_ + 1];
        std::strcpy(data_, other.data_);
        std::cout << "복사 생성자: \"" << data_ << "\" 복사됨\n";
    }
    
    // 소멸자
    ~String() {
        std::cout << "소멸자: \"" << data_ << "\" 해제됨\n";
        delete[] data_;
    }
    
    void Print() const {
        std::cout << "String: \"" << data_ << "\"\n";
    }
};

int main() {
    String s1("Hello");
    String s2 = s1;         // 복사 생성자 호출
    String s3(s1);          // 복사 생성자 호출
    
    s1.Print();
    s2.Print();
    s3.Print();
    
    return 0;
}
```

**출력 결과:**
```
생성자: "Hello" 생성됨
복사 생성자: "Hello" 복사됨
복사 생성자: "Hello" 복사됨
String: "Hello"
String: "Hello"
String: "Hello"
소멸자: "Hello" 해제됨
소멸자: "Hello" 해제됨
소멸자: "Hello" 해제됨
```

복사 생성자가 호출되는 경우:
1. 객체를 다른 객체로 초기화할 때
2. 함수에 객체를 값으로 전달할 때
3. 함수에서 객체를 값으로 반환할 때 (최적화되지 않은 경우)

### 14.3.2 얕은 복사 vs 깊은 복사
복사 생성자를 명시적으로 정의하지 않으면 컴파일러가 자동으로 생성한다. 하지만 기본 복사 생성자는 **얕은 복사(Shallow Copy)**만 수행한다.

```cpp
class ShallowString {
private:
    char* data_;
    
public:
    ShallowString(const char* str) {
        data_ = new char[std::strlen(str) + 1];
        std::strcpy(data_, str);
    }
    
    // 복사 생성자를 정의하지 않음 → 기본 복사 생성자 사용
    // ~ShallowString() { delete[] data_; }  // 주석 처리 (이중 해제 방지)
    
    void Print() const {
        std::cout << "String: \"" << data_ << "\"\n";
    }
};

int main() {
    ShallowString s1("Hello");
    ShallowString s2 = s1;  // 포인터만 복사됨! (얕은 복사)
    
    // s1.data_와 s2.data_가 같은 메모리를 가리킴
    // 소멸 시 이중 해제(double delete) 문제 발생!
    
    return 0;
}
```

동적 메모리를 사용하는 클래스는 반드시 **깊은 복사(Deep Copy)**를 수행하는 복사 생성자를 정의해야 한다.
  
### 14.3.3 이동 생성자 (Move Constructor) - C++11
C++11부터 **이동 의미론(Move Semantics)**이 도입되었다. 이는 복사 대신 리소스의 소유권을 이전하여 성능을 크게 향상시킨다.

```cpp
#include <iostream>
#include <cstring>
#include <utility>  // std::move

class String {
private:
    char* data_;
    size_t length_;
    
public:
    // 일반 생성자
    String(const char* str = "") {
        length_ = std::strlen(str);
        data_ = new char[length_ + 1];
        std::strcpy(data_, str);
        std::cout << "생성자: \"" << data_ << "\" 생성됨 (메모리: " << (void*)data_ << ")\n";
    }
    
    // 복사 생성자
    String(const String& other) {
        length_ = other.length_;
        data_ = new char[length_ + 1];
        std::strcpy(data_, other.data_);
        std::cout << "복사 생성자: \"" << data_ << "\" 복사됨 (새 메모리: " << (void*)data_ << ")\n";
    }
    
    // 이동 생성자
    String(String&& other) noexcept {
        // 리소스 소유권 이전
        data_ = other.data_;
        length_ = other.length_;
        
        // other를 유효하지만 정의되지 않은 상태로 만듦
        other.data_ = nullptr;
        other.length_ = 0;
        
        std::cout << "이동 생성자: 리소스 이전됨 (메모리: " << (void*)data_ << ")\n";
    }
    
    // 소멸자
    ~String() {
        if (data_) {
            std::cout << "소멸자: \"" << data_ << "\" 해제됨\n";
            delete[] data_;
        } else {
            std::cout << "소멸자: 이동된 객체 (해제할 것 없음)\n";
        }
    }
    
    void Print() const {
        if (data_) {
            std::cout << "String: \"" << data_ << "\"\n";
        } else {
            std::cout << "String: (이동됨)\n";
        }
    }
};

String CreateString() {
    String temp("Temporary");
    return temp;  // 이동 생성자 호출 (또는 RVO로 최적화)
}

int main() {
    std::cout << "=== 복사 생성 ===\n";
    String s1("Hello");
    String s2 = s1;  // 복사 생성자
    
    std::cout << "\n=== 이동 생성 ===\n";
    String s3 = std::move(s1);  // 이동 생성자 (명시적 이동)
    
    std::cout << "\n=== 상태 확인 ===\n";
    s1.Print();  // 이동된 상태
    s2.Print();
    s3.Print();
    
    std::cout << "\n=== 함수 반환 ===\n";
    String s4 = CreateString();  // 이동 생성자 (또는 RVO)
    
    std::cout << "\n=== 프로그램 종료 ===\n";
    return 0;
}
```

**주요 개념:**

1. **rvalue 참조 (`&&`)**: 임시 객체나 이동될 객체를 나타낸다
2. **`std::move()`**: lvalue를 rvalue로 캐스팅한다 (실제로 이동하는 것은 아님)
3. **`noexcept`**: 이동 생성자는 예외를 던지지 않음을 보장한다 (성능 최적화에 중요)

### 14.3.4 언제 복사하고 언제 이동하는가?

```cpp
#include <vector>
#include <iostream>

class Widget {
private:
    int* data_;
    
public:
    Widget(int value) : data_(new int(value)) {
        std::cout << "Widget 생성: " << *data_ << "\n";
    }
    
    Widget(const Widget& other) : data_(new int(*other.data_)) {
        std::cout << "Widget 복사: " << *data_ << "\n";
    }
    
    Widget(Widget&& other) noexcept : data_(other.data_) {
        other.data_ = nullptr;
        std::cout << "Widget 이동\n";
    }
    
    ~Widget() {
        if (data_) {
            std::cout << "Widget 소멸: " << *data_ << "\n";
            delete data_;
        } else {
            std::cout << "Widget 소멸: (이동됨)\n";
        }
    }
};

Widget CreateWidget() {
    return Widget(42);
}

int main() {
    std::cout << "=== 케이스 1: lvalue 복사 ===\n";
    Widget w1(10);
    Widget w2 = w1;  // 복사 (w1은 lvalue)
    
    std::cout << "\n=== 케이스 2: rvalue 이동 ===\n";
    Widget w3 = Widget(20);  // 이동 (또는 RVO)
    
    std::cout << "\n=== 케이스 3: 명시적 이동 ===\n";
    Widget w4 = std::move(w1);  // 이동 (std::move 사용)
    
    std::cout << "\n=== 케이스 4: 컨테이너 ===\n";
    std::vector<Widget> widgets;
    widgets.push_back(Widget(30));  // 이동
    
    std::cout << "\n=== 프로그램 종료 ===\n";
    return 0;
}
```

**이동의 장점:**
- 복사에 비해 훨씬 빠르다 (특히 큰 객체의 경우)
- 메모리 할당/해제가 없다
- 컨테이너 성능이 크게 향상된다

 </br>    
 </br>       
  

## 14.4 `= default`와 `= delete` 키워드

### 14.4.1 `= default` - 명시적 기본 구현
C++11부터는 컴파일러가 자동으로 생성하는 특수 멤버 함수를 명시적으로 요청할 수 있다.

```cpp
class Point {
private:
    int x_;
    int y_;
    
public:
    // 기본 생성자를 명시적으로 요청
    Point() = default;
    
    // 매개변수 생성자
    Point(int x, int y) : x_(x), y_(y) {}
    
    // 복사 생성자를 명시적으로 요청
    Point(const Point&) = default;
    
    // 이동 생성자를 명시적으로 요청
    Point(Point&&) = default;
    
    // 복사 대입 연산자를 명시적으로 요청
    Point& operator=(const Point&) = default;
    
    // 이동 대입 연산자를 명시적으로 요청
    Point& operator=(Point&&) = default;
    
    // 소멸자를 명시적으로 요청
    ~Point() = default;
};
```

`= default`의 장점:
1. 의도를 명확하게 표현한다
2. 컴파일러 최적화를 받을 수 있다
3. 코드 가독성이 향상된다

### 14.4.2 `= delete` - 함수 삭제
특정 함수를 사용하지 못하게 막고 싶을 때 `= delete`를 사용한다.

```cpp
#include <iostream>

class NonCopyable {
private:
    int value_;
    
public:
    NonCopyable(int value) : value_(value) {}
    
    // 복사 생성자 삭제
    NonCopyable(const NonCopyable&) = delete;
    
    // 복사 대입 연산자 삭제
    NonCopyable& operator=(const NonCopyable&) = delete;
    
    // 이동은 허용
    NonCopyable(NonCopyable&&) = default;
    NonCopyable& operator=(NonCopyable&&) = default;
    
    int GetValue() const { return value_; }
};

int main() {
    NonCopyable nc1(10);
    
    // NonCopyable nc2 = nc1;  // 컴파일 오류! 복사 불가
    
    NonCopyable nc3 = std::move(nc1);  // 이동은 가능
    
    std::cout << "nc3 값: " << nc3.GetValue() << "\n";
    
    return 0;
}
```

### 14.4.3 실용적 예제: 싱글턴 패턴

```cpp
#include <iostream>
#include <memory>

class DatabaseConnection {
private:
    std::string connectionString_;
    
    // private 생성자
    DatabaseConnection(const std::string& connStr) 
        : connectionString_(connStr) {
        std::cout << "데이터베이스 연결: " << connectionString_ << "\n";
    }
    
public:
    // 복사와 이동을 모두 금지
    DatabaseConnection(const DatabaseConnection&) = delete;
    DatabaseConnection(DatabaseConnection&&) = delete;
    DatabaseConnection& operator=(const DatabaseConnection&) = delete;
    DatabaseConnection& operator=(DatabaseConnection&&) = delete;
    
    // 싱글턴 인스턴스 반환
    static DatabaseConnection& GetInstance() {
        static DatabaseConnection instance("Server=localhost;Database=mydb");
        return instance;
    }
    
    void ExecuteQuery(const std::string& query) {
        std::cout << "쿼리 실행: " << query << "\n";
    }
    
    ~DatabaseConnection() {
        std::cout << "데이터베이스 연결 종료\n";
    }
};

int main() {
    // 싱글턴 인스턴스 사용
    DatabaseConnection::GetInstance().ExecuteQuery("SELECT * FROM users");
    DatabaseConnection::GetInstance().ExecuteQuery("INSERT INTO logs VALUES (...)");
    
    // DatabaseConnection db = DatabaseConnection::GetInstance();  // 오류!
    
    return 0;
}
```

### 14.4.4 특정 타입의 함수 오버로드 금지
`= delete`는 일반 함수에도 사용할 수 있다.

```cpp
#include <iostream>

void ProcessValue(int value) {
    std::cout << "정수 처리: " << value << "\n";
}

// double 타입은 명시적으로 금지
void ProcessValue(double value) = delete;

// bool 타입도 금지 (int로의 암묵적 변환 방지)
void ProcessValue(bool value) = delete;

int main() {
    ProcessValue(42);       // 정상
    // ProcessValue(3.14);  // 컴파일 오류!
    // ProcessValue(true);  // 컴파일 오류!
    
    return 0;
}
```
   

</br>     
  
  
## 14.5 Rule of Five와 Rule of Zero

### 14.5.1 Rule of Three (C++98)
C++98에서는 다음 세 가지 중 하나라도 명시적으로 정의하면, 나머지도 정의해야 한다는 규칙이 있었다:

1. 소멸자
2. 복사 생성자
3. 복사 대입 연산자

```cpp
class ResourceHolder {
private:
    int* data_;
    
public:
    // 1. 생성자
    ResourceHolder(int value) : data_(new int(value)) {}
    
    // 2. 소멸자
    ~ResourceHolder() {
        delete data_;
    }
    
    // 3. 복사 생성자
    ResourceHolder(const ResourceHolder& other) 
        : data_(new int(*other.data_)) {}
    
    // 4. 복사 대입 연산자
    ResourceHolder& operator=(const ResourceHolder& other) {
        if (this != &other) {
            delete data_;
            data_ = new int(*other.data_);
        }
        return *this;
    }
};
```

### 14.5.2 Rule of Five (C++11)
C++11부터 이동 의미론이 추가되면서 Rule of Five가 되었다:

1. 소멸자
2. 복사 생성자
3. 복사 대입 연산자
4. 이동 생성자
5. 이동 대입 연산자

```cpp
#include <iostream>
#include <utility>

class ResourceHolder {
private:
    int* data_;
    
public:
    // 생성자
    ResourceHolder(int value) : data_(new int(value)) {
        std::cout << "생성자: " << *data_ << "\n";
    }
    
    // 1. 소멸자
    ~ResourceHolder() {
        if (data_) {
            std::cout << "소멸자: " << *data_ << "\n";
            delete data_;
        }
    }
    
    // 2. 복사 생성자
    ResourceHolder(const ResourceHolder& other) 
        : data_(new int(*other.data_)) {
        std::cout << "복사 생성자: " << *data_ << "\n";
    }
    
    // 3. 복사 대입 연산자
    ResourceHolder& operator=(const ResourceHolder& other) {
        std::cout << "복사 대입 연산자\n";
        if (this != &other) {
            delete data_;
            data_ = new int(*other.data_);
        }
        return *this;
    }
    
    // 4. 이동 생성자
    ResourceHolder(ResourceHolder&& other) noexcept 
        : data_(other.data_) {
        std::cout << "이동 생성자\n";
        other.data_ = nullptr;
    }
    
    // 5. 이동 대입 연산자
    ResourceHolder& operator=(ResourceHolder&& other) noexcept {
        std::cout << "이동 대입 연산자\n";
        if (this != &other) {
            delete data_;
            data_ = other.data_;
            other.data_ = nullptr;
        }
        return *this;
    }
    
    int GetValue() const { return data_ ? *data_ : 0; }
};

int main() {
    ResourceHolder r1(10);
    ResourceHolder r2 = r1;              // 복사 생성자
    ResourceHolder r3 = std::move(r1);   // 이동 생성자
    
    r2 = r3;                             // 복사 대입
    r3 = std::move(r2);                  // 이동 대입
    
    return 0;
}
```

[그림 14-5: Rule of Five의 다섯 가지 특수 멤버 함수 관계도]

### 14.5.3 Rule of Zero (Modern C++)

**Rule of Zero**는 가장 권장되는 Modern C++ 접근 방식이다: 직접 리소스를 관리하지 말고, RAII 래퍼를 사용하라.

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

// Rule of Zero: 특수 멤버 함수를 정의할 필요 없음!
class Player {
private:
    std::string name_;                          // 자동 메모리 관리
    std::unique_ptr<int[]> inventory_;          // 스마트 포인터
    std::vector<std::string> achievements_;     // 컨테이너
    
public:
    Player(const std::string& name, int inventorySize) 
        : name_(name),
          inventory_(std::make_unique<int[]>(inventorySize)) {
        std::cout << "Player 생성: " << name_ << "\n";
    }
    
    // 컴파일러가 자동으로 생성하는 함수들:
    // ~Player() = default;                        // 소멸자
    // Player(const Player&) = default;            // 복사 생성자 (unique_ptr 때문에 삭제됨)
    // Player& operator=(const Player&) = default; // 복사 대입 (unique_ptr 때문에 삭제됨)
    // Player(Player&&) = default;                 // 이동 생성자
    // Player& operator=(Player&&) = default;      // 이동 대입
    
    void AddAchievement(const std::string& achievement) {
        achievements_.push_back(achievement);
        std::cout << name_ << "이(가) 업적을 달성했다: " << achievement << "\n";
    }
    
    void DisplayInfo() const {
        std::cout << "플레이어: " << name_ << "\n";
        std::cout << "업적 수: " << achievements_.size() << "\n";
    }
};

int main() {
    Player p1("용사", 10);
    p1.AddAchievement("첫 전투 승리");
    
    // Player p2 = p1;  // 오류! unique_ptr는 복사 불가
    
    Player p3 = std::move(p1);  // 이동은 가능
    p3.DisplayInfo();
    
    return 0;
}
```

**Rule of Zero의 핵심:**
- `std::unique_ptr`, `std::shared_ptr` 사용
- `std::vector`, `std::string` 등 표준 컨테이너 사용
- 수동 메모리 관리 피하기
- 특수 멤버 함수를 직접 구현하지 않기

### 14.5.4 언제 어떤 규칙을 따를까?

```cpp
// Rule of Zero: 대부분의 경우 권장
class ModernClass {
    std::string name_;
    std::vector<int> data_;
    std::unique_ptr<Resource> resource_;
    // 특수 멤버 함수 정의 불필요!
};

// Rule of Five: 저수준 리소스 관리가 필요한 경우
class LowLevelResource {
    int* rawPointer_;
    // 5가지 특수 멤버 함수 모두 정의 필요
};

// 복사 금지, 이동만 허용
class MoveOnlyResource {
    std::unique_ptr<int> data_;
    
public:
    MoveOnlyResource() = default;
    
    // 복사 금지
    MoveOnlyResource(const MoveOnlyResource&) = delete;
    MoveOnlyResource& operator=(const MoveOnlyResource&) = delete;
    
    // 이동 허용 (기본 구현)
    MoveOnlyResource(MoveOnlyResource&&) = default;
    MoveOnlyResource& operator=(MoveOnlyResource&&) = default;
};

// 복사와 이동 모두 금지 (싱글턴 등)
class NonMovableResource {
public:
    NonMovableResource() = default;
    
    NonMovableResource(const NonMovableResource&) = delete;
    NonMovableResource(NonMovableResource&&) = delete;
    NonMovableResource& operator=(const NonMovableResource&) = delete;
    NonMovableResource& operator=(NonMovableResource&&) = delete;
};
```

[그림 14-6: Rule of Zero, Five 선택 흐름도]

## 14.6 실습 예제: 스마트 문자열 클래스

지금까지 배운 내용을 종합하여 안전하고 효율적인 문자열 클래스를 만들어보자.

```cpp
#include <iostream>
#include <cstring>
#include <utility>

class SmartString {
private:
    char* data_;
    size_t length_;
    size_t capacity_;
    
    // 내부 헬퍼 함수
    void Allocate(size_t capacity) {
        capacity_ = capacity;
        data_ = new char[capacity_ + 1];
    }
    
public:
    // 1. 기본 생성자
    SmartString() : data_(nullptr), length_(0), capacity_(0) {
        Allocate(0);
        data_[0] = '\0';
        std::cout << "[기본 생성자]\n";
    }
    
    // 2. C 문자열로부터 생성
    explicit SmartString(const char* str) {
        length_ = std::strlen(str);
        Allocate(length_);
        std::strcpy(data_, str);
        std::cout << "[문자열 생성자] \"" << data_ << "\"\n";
    }
    
    // 3. 소멸자
    ~SmartString() {
        std::cout << "[소멸자] ";
        if (data_) {
            std::cout << "\"" << data_ << "\" 해제\n";
            delete[] data_;
        } else {
            std::cout << "(이미 이동됨)\n";
        }
    }
    
    // 4. 복사 생성자
    SmartString(const SmartString& other) 
        : length_(other.length_) {
        Allocate(other.capacity_);
        std::strcpy(data_, other.data_);
        std::cout << "[복사 생성자] \"" << data_ << "\"\n";
    }
    
    // 5. 복사 대입 연산자
    SmartString& operator=(const SmartString& other) {
        std::cout << "[복사 대입] \"" << other.data_ << "\"\n";
        
        if (this != &other) {
            // 기존 리소스 해제
            delete[] data_;
            
            // 새로운 리소스 할당 및 복사
            length_ = other.length_;
            Allocate(other.capacity_);
            std::strcpy(data_, other.data_);
        }
        
        return *this;
    }
    
    // 6. 이동 생성자
    SmartString(SmartString&& other) noexcept
        : data_(other.data_),
          length_(other.length_),
          capacity_(other.capacity_) {
        
        // other를 비워둠
        other.data_ = nullptr;
        other.length_ = 0;
        other.capacity_ = 0;
        
        std::cout << "[이동 생성자] 리소스 이전\n";
    }
    
    // 7. 이동 대입 연산자
    SmartString& operator=(SmartString&& other) noexcept {
        std::cout << "[이동 대입] 리소스 이전\n";
        
        if (this != &other) {
            // 기존 리소스 해제
            delete[] data_;
            
            // 리소스 이전
            data_ = other.data_;
            length_ = other.length_;
            capacity_ = other.capacity_;
            
            // other를 비워둠
            other.data_ = nullptr;
            other.length_ = 0;
            other.capacity_ = 0;
        }
        
        return *this;
    }
    
    // 유틸리티 함수들
    const char* CStr() const { return data_ ? data_ : ""; }
    size_t Length() const { return length_; }
    bool IsEmpty() const { return length_ == 0; }
    
    // 문자열 연결
    SmartString& Append(const SmartString& other) {
        size_t newLength = length_ + other.length_;
        
        if (newLength > capacity_) {
            // 재할당 필요
            char* newData = new char[newLength + 1];
            std::strcpy(newData, data_);
            std::strcat(newData, other.data_);
            
            delete[] data_;
            data_ = newData;
            capacity_ = newLength;
        } else {
            std::strcat(data_, other.data_);
        }
        
        length_ = newLength;
        return *this;
    }
    
    void Print() const {
        if (data_) {
            std::cout << "SmartString: \"" << data_ << "\" ";
            std::cout << "(길이: " << length_ << ", 용량: " << capacity_ << ")\n";
        } else {
            std::cout << "SmartString: (이동됨)\n";
        }
    }
};

// 헬퍼 함수
SmartString CreateTempString(const char* str) {
    return SmartString(str);  // RVO 또는 이동
}

int main() {
    std::cout << "=== 1. 생성과 복사 ===\n";
    SmartString s1("Hello");
    SmartString s2 = s1;  // 복사 생성자
    
    std::cout << "\n=== 2. 대입 ===\n";
    SmartString s3("World");
    s3 = s2;  // 복사 대입
    
    std::cout << "\n=== 3. 이동 ===\n";
    SmartString s4 = std::move(s1);  // 이동 생성자
    s1.Print();  // 이동된 상태
    s4.Print();
    
    std::cout << "\n=== 4. 이동 대입 ===\n";
    SmartString s5("Temporary");
    s5 = std::move(s4);  // 이동 대입
    
    std::cout << "\n=== 5. 함수 반환 (RVO/이동) ===\n";
    SmartString s6 = CreateTempString("Function Return");
    
    std::cout << "\n=== 6. 문자열 연결 ===\n";
    SmartString s7("Hello");
    SmartString s8(" World");
    s7.Append(s8);
    s7.Print();
    
    std::cout << "\n=== 7. 프로그램 종료 (소멸자 호출) ===\n";
    return 0;
}
```

이 예제는 Rule of Five를 완전히 구현한 클래스다. 각 특수 멤버 함수가 언제 호출되는지 로그로 확인할 수 있다.
  

</br>  
</br>  


## 14.7 연습 문제

### 문제 1: 동적 배열 클래스
Rule of Five를 적용하여 동적 배열을 관리하는 `DynamicArray` 클래스를 작성하라.

**요구사항:**
- 정수 배열을 동적으로 관리
- 크기 지정 생성자
- 요소 추가/제거 기능
- 5가지 특수 멤버 함수 모두 구현
- 안전한 메모리 관리

**해답:**

```cpp
#include <iostream>
#include <algorithm>
#include <utility>

class DynamicArray {
private:
    int* data_;
    size_t size_;
    size_t capacity_;
    
    void Resize(size_t newCapacity) {
        int* newData = new int[newCapacity];
        size_t copySize = std::min(size_, newCapacity);
        
        for (size_t i = 0; i < copySize; ++i) {
            newData[i] = data_[i];
        }
        
        delete[] data_;
        data_ = newData;
        capacity_ = newCapacity;
    }
    
public:
    // 생성자
    explicit DynamicArray(size_t capacity = 10)
        : data_(new int[capacity]), size_(0), capacity_(capacity) {
        std::cout << "생성자: 용량 " << capacity_ << "\n";
    }
    
    // 소멸자
    ~DynamicArray() {
        std::cout << "소멸자: 크기 " << size_ << "\n";
        delete[] data_;
    }
    
    // 복사 생성자
    DynamicArray(const DynamicArray& other)
        : data_(new int[other.capacity_]),
          size_(other.size_),
          capacity_(other.capacity_) {
        
        std::copy(other.data_, other.data_ + other.size_, data_);
        std::cout << "복사 생성자: 크기 " << size_ << "\n";
    }
    
    // 복사 대입 연산자
    DynamicArray& operator=(const DynamicArray& other) {
        std::cout << "복사 대입: 크기 " << other.size_ << "\n";
        
        if (this != &other) {
            delete[] data_;
            
            data_ = new int[other.capacity_];
            size_ = other.size_;
            capacity_ = other.capacity_;
            
            std::copy(other.data_, other.data_ + other.size_, data_);
        }
        
        return *this;
    }
    
    // 이동 생성자
    DynamicArray(DynamicArray&& other) noexcept
        : data_(other.data_),
          size_(other.size_),
          capacity_(other.capacity_) {
        
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
        
        std::cout << "이동 생성자\n";
    }
    
    // 이동 대입 연산자
    DynamicArray& operator=(DynamicArray&& other) noexcept {
        std::cout << "이동 대입\n";
        
        if (this != &other) {
            delete[] data_;
            
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        
        return *this;
    }
    
    // 요소 추가
    void PushBack(int value) {
        if (size_ >= capacity_) {
            Resize(capacity_ * 2);
        }
        data_[size_++] = value;
    }
    
    // 요소 접근
    int& operator[](size_t index) {
        return data_[index];
    }
    
    const int& operator[](size_t index) const {
        return data_[index];
    }
    
    // 정보
    size_t Size() const { return size_; }
    size_t Capacity() const { return capacity_; }
    
    void Print() const {
        std::cout << "배열 [";
        for (size_t i = 0; i < size_; ++i) {
            std::cout << data_[i];
            if (i < size_ - 1) std::cout << ", ";
        }
        std::cout << "] (크기: " << size_ << ", 용량: " << capacity_ << ")\n";
    }
};

int main() {
    std::cout << "=== 생성 및 요소 추가 ===\n";
    DynamicArray arr1(5);
    arr1.PushBack(10);
    arr1.PushBack(20);
    arr1.PushBack(30);
    arr1.Print();
    
    std::cout << "\n=== 복사 ===\n";
    DynamicArray arr2 = arr1;
    arr2.Print();
    
    std::cout << "\n=== 이동 ===\n";
    DynamicArray arr3 = std::move(arr1);
    arr3.Print();
    
    std::cout << "\n=== 프로그램 종료 ===\n";
    return 0;
}
```

### 문제 2: Rule of Zero 적용
위의 `DynamicArray`를 Rule of Zero 방식으로 다시 작성하라. `std::unique_ptr`와 `std::vector`를 활용하라.

**해답:**

```cpp
#include <iostream>
#include <vector>
#include <memory>

// Rule of Zero 버전
class ModernDynamicArray {
private:
    std::vector<int> data_;  // 자동 메모리 관리!
    
public:
    // 생성자
    explicit ModernDynamicArray(size_t capacity = 10) {
        data_.reserve(capacity);
        std::cout << "생성자: 예약 용량 " << capacity << "\n";
    }
    
    // 특수 멤버 함수는 컴파일러가 자동 생성
    // (std::vector가 모든 것을 처리함)
    
    void PushBack(int value) {
        data_.push_back(value);
    }
    
    int& operator[](size_t index) {
        return data_[index];
    }
    
    const int& operator[](size_t index) const {
        return data_[index];
    }
    
    size_t Size() const { return data_.size(); }
    size_t Capacity() const { return data_.capacity(); }
    
    void Print() const {
        std::cout << "배열 [";
        for (size_t i = 0; i < data_.size(); ++i) {
            std::cout << data_[i];
            if (i < data_.size() - 1) std::cout << ", ";
        }
        std::cout << "] (크기: " << data_.size();
        std::cout << ", 용량: " << data_.capacity() << ")\n";
    }
};

int main() {
    ModernDynamicArray arr1(5);
    arr1.PushBack(10);
    arr1.PushBack(20);
    arr1.PushBack(30);
    arr1.Print();
    
    // 복사와 이동이 자동으로 잘 작동함!
    ModernDynamicArray arr2 = arr1;  // 깊은 복사
    ModernDynamicArray arr3 = std::move(arr1);  // 이동
    
    arr2.Print();
    arr3.Print();
    
    return 0;
}
```

훨씬 간단하고 안전하다! 이것이 Rule of Zero의 힘이다.

### 문제 3: 생성자 위임 연습
다양한 생성자를 가진 `Rectangle` 클래스를 작성하되, 생성자 위임을 사용하여 코드 중복을 제거하라.

**해답:**

```cpp
#include <iostream>
#include <string>

class Rectangle {
private:
    double width_;
    double height_;
    std::string color_;
    
    // 초기화 로직
    void Initialize() {
        std::cout << "사각형 초기화: " << width_ << " x " << height_;
        std::cout << ", 색상: " << color_ << "\n";
    }
    
public:
    // 주 생성자
    Rectangle(double width, double height, const std::string& color)
        : width_(width), height_(height), color_(color) {
        Initialize();
    }
    
    // 위임 생성자들
    Rectangle() : Rectangle(1.0, 1.0, "white") {}
    
    Rectangle(double side) : Rectangle(side, side, "white") {}
    
    Rectangle(double width, double height) 
        : Rectangle(width, height, "white") {}
    
    double GetArea() const { return width_ * height_; }
    
    void Display() const {
        std::cout << "사각형: " << width_ << " x " << height_;
        std::cout << ", 색상: " << color_;
        std::cout << ", 넓이: " << GetArea() << "\n";
    }
};

int main() {
    Rectangle r1;                      // 기본 정사각형
    Rectangle r2(5.0);                 // 한 변의 길이만 지정
    Rectangle r3(3.0, 4.0);            // 가로, 세로 지정
    Rectangle r4(2.0, 6.0, "blue");    // 모두 지정
    
    std::cout << "\n";
    r1.Display();
    r2.Display();
    r3.Display();
    r4.Display();
    
    return 0;
}
```

## 14.8 심화 내용

### 14.8.1 복사 생략과 RVO (Return Value Optimization)
컴파일러는 불필요한 복사를 자동으로 생략할 수 있다.

```cpp
#include <iostream>

class Heavy {
private:
    int data_[1000];
    
public:
    Heavy() {
        std::cout << "Heavy 생성자\n";
    }
    
    Heavy(const Heavy&) {
        std::cout << "Heavy 복사 생성자\n";
    }
    
    Heavy(Heavy&&) noexcept {
        std::cout << "Heavy 이동 생성자\n";
    }
};

Heavy CreateHeavy() {
    Heavy temp;
    return temp;  // RVO가 적용되면 복사/이동 없음!
}

int main() {
    std::cout << "=== 함수 호출 ===\n";
    Heavy h = CreateHeavy();  // RVO: 복사도 이동도 발생하지 않을 수 있음
    
    std::cout << "\n=== 명시적 이동 ===\n";
    Heavy h2 = std::move(h);  // 명시적 이동은 발생
    
    return 0;
}
```

C++17부터는 특정 상황에서 **복사 생략이 강제**된다. 이를 **보장된 복사 생략(Guaranteed Copy Elision)**이라고 한다.


## 14.9 정리
이번 장에서는 생성자와 소멸자의 Modern C++ 접근 방식을 배웠다. 핵심 내용을 정리하면:

1. **생성자 위임**: 코드 중복을 줄이고 유지보수성을 높인다
2. **멤버 초기화 리스트**: 효율적이고 안전한 초기화 방법이다
3. **복사와 이동**: 복사는 비용이 크고, 이동은 효율적이다
4. **`= default`와 `= delete`**: 의도를 명확히 표현한다
5. **Rule of Five**: 리소스를 직접 관리할 때 5가지 함수를 모두 구현한다
6. **Rule of Zero**: 가능하면 표준 라이브러리를 사용하여 리소스 관리를 맡긴다

**Modern C++ 베스트 프랙티스:**

```cpp
// ✅ 좋은 예: Rule of Zero
class GoodClass {
    std::string name_;
    std::vector<int> data_;
    std::unique_ptr<Resource> resource_;
    // 특수 멤버 함수 불필요!
};

// ⚠️ 필요한 경우에만: Rule of Five
class ResourceManager {
    int* data_;
    
public:
    ResourceManager(int value);
    ~ResourceManager();
    ResourceManager(const ResourceManager&);
    ResourceManager& operator=(const ResourceManager&);
    ResourceManager(ResourceManager&&) noexcept;
    ResourceManager& operator=(ResourceManager&&) noexcept;
};

// ✅ 명시적 의도 표현
class NonCopyable {
public:
    NonCopyable() = default;
    NonCopyable(const NonCopyable&) = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;
    NonCopyable(NonCopyable&&) = default;
    NonCopyable& operator=(NonCopyable&&) = default;
};
```

다음 장에서는 상속과 다형성을 다루며, 가상 함수, `override`, `final` 키워드 등 객체지향 프로그래밍의 핵심 개념을 배운다. 이번 장에서 배운 생성자와 소멸자 지식은 상속 관계에서도 매우 중요하므로 확실히 이해하고 넘어가자.  