# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 27: 고급 주제와 성능 최적화

지금까지 Modern C++의 다양한 기능을 배우고 실전 프로젝트를 완성했다. 이제 코드를 더 효율적이고 유지보수하기 쉽게 만드는 고급 기법들을 배울 차례다. 이번 장에서는 메모리 효율적인 코딩, 프로파일링, 리팩토링, 그리고 단위 테스트에 대해 다룬다.

## 27.1 메모리 효율적인 코딩

### 27.1.1 메모리 할당의 이해

C++에서 메모리는 크게 스택(Stack), 힙(Heap), 그리고 정적 메모리(Static Memory) 영역으로 나뉜다.

```cpp
#include <iostream>
#include <memory>
#include <vector>

// 정적 메모리에 할당
int globalVariable = 42;

void demonstrateMemoryAreas() {
    // 스택 메모리에 할당
    int stackVariable = 10;
    int stackArray[100];  // 400 바이트 (대부분의 시스템에서)
    
    // 힙 메모리에 할당
    int* heapVariable = new int(20);
    std::unique_ptr<int> smartHeapVariable = std::make_unique<int>(30);
    
    // 벡터는 내부적으로 힙 메모리를 사용
    std::vector<int> dynamicArray(1000);  // 4000 바이트
    
    std::cout << "Stack variable address: " << &stackVariable << std::endl;
    std::cout << "Heap variable address: " << heapVariable << std::endl;
    std::cout << "Global variable address: " << &globalVariable << std::endl;
    
    delete heapVariable;  // 수동 해제 필요
    // smartHeapVariable는 자동으로 해제됨
}
```

**핵심 개념: 메모리 영역별 특징**

- **스택**: 빠르지만 크기 제한이 있다 (보통 1-8MB). 함수가 끝나면 자동으로 해제된다.
- **힙**: 크기 제한이 거의 없지만 할당/해제가 느리다. 명시적으로 관리해야 한다.
- **정적**: 프로그램 실행 중 계속 존재한다.

### 27.1.2 불필요한 복사 피하기

객체를 복사하는 것은 비용이 크다. 이동 의미론(Move Semantics)과 참조를 활용하여 최적화한다.

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <chrono>

class LargeObject {
private:
    std::vector<int> data_;
    std::string name_;
    
public:
    // 생성자
    LargeObject(const std::string& name, size_t size) 
        : name_(name), data_(size, 0) {
        std::cout << "Constructing " << name_ << std::endl;
    }
    
    // 복사 생성자
    LargeObject(const LargeObject& other) 
        : name_(other.name_ + "_copy"), data_(other.data_) {
        std::cout << "Copying " << other.name_ << " to " << name_ << std::endl;
    }
    
    // 이동 생성자
    LargeObject(LargeObject&& other) noexcept
        : name_(std::move(other.name_)), data_(std::move(other.data_)) {
        std::cout << "Moving " << name_ << std::endl;
    }
    
    // 복사 대입 연산자
    LargeObject& operator=(const LargeObject& other) {
        if (this != &other) {
            name_ = other.name_ + "_copied";
            data_ = other.data_;
            std::cout << "Copy assignment to " << name_ << std::endl;
        }
        return *this;
    }
    
    // 이동 대입 연산자
    LargeObject& operator=(LargeObject&& other) noexcept {
        if (this != &other) {
            name_ = std::move(other.name_);
            data_ = std::move(other.data_);
            std::cout << "Move assignment to " << name_ << std::endl;
        }
        return *this;
    }
    
    const std::string& getName() const { return name_; }
    size_t getSize() const { return data_.size(); }
};

// 나쁜 예: 값으로 반환 (불필요한 복사)
LargeObject createObjectBad() {
    LargeObject obj("TempObject", 1000000);
    return obj;  // RVO(Return Value Optimization)가 적용될 수 있지만 보장되지 않음
}

// 좋은 예: 이동 의미론 활용
LargeObject createObjectGood() {
    LargeObject obj("TempObject", 1000000);
    return obj;  // 자동으로 이동 생성자 호출 (C++11 이후)
}

// 나쁜 예: 값으로 매개변수 받기
void processBad(LargeObject obj) {
    std::cout << "Processing " << obj.getName() << std::endl;
}

// 좋은 예: const 참조로 매개변수 받기
void processGood(const LargeObject& obj) {
    std::cout << "Processing " << obj.getName() << std::endl;
}

// 소유권 이전이 필요한 경우: rvalue 참조
void takeOwnership(LargeObject&& obj) {
    LargeObject owned = std::move(obj);
    std::cout << "Took ownership of " << owned.getName() << std::endl;
}

void demonstrateCopyVsMove() {
    std::cout << "=== Creating object ===" << std::endl;
    LargeObject obj1("Original", 1000000);
    
    std::cout << "\n=== Copy (expensive) ===" << std::endl;
    LargeObject obj2 = obj1;  // 복사 생성자 호출
    
    std::cout << "\n=== Move (cheap) ===" << std::endl;
    LargeObject obj3 = std::move(obj1);  // 이동 생성자 호출
    
    std::cout << "\n=== Function call with copy ===" << std::endl;
    processBad(obj2);  // 복사 발생
    
    std::cout << "\n=== Function call with reference ===" << std::endl;
    processGood(obj2);  // 복사 없음
}
```

### 27.1.3 메모리 풀 사용하기

빈번한 메모리 할당/해제는 성능 저하의 원인이 된다. 메모리 풀을 사용하면 이를 개선할 수 있다.

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <cstddef>

// 간단한 메모리 풀 구현
template<typename T, size_t PoolSize = 100>
class MemoryPool {
private:
    union Slot {
        T element;
        Slot* next;
    };
    
    Slot* currentSlot_;
    Slot* lastSlot_;
    Slot* freeSlots_;
    
    std::vector<std::unique_ptr<Slot[]>> pools_;
    
    void allocatePool() {
        auto newPool = std::make_unique<Slot[]>(PoolSize);
        Slot* poolStart = newPool.get();
        
        // 새 풀을 free list에 연결
        for (size_t i = 0; i < PoolSize - 1; ++i) {
            poolStart[i].next = &poolStart[i + 1];
        }
        poolStart[PoolSize - 1].next = freeSlots_;
        
        freeSlots_ = poolStart;
        pools_.push_back(std::move(newPool));
    }
    
public:
    MemoryPool() : currentSlot_(nullptr), lastSlot_(nullptr), freeSlots_(nullptr) {
        allocatePool();
    }
    
    ~MemoryPool() {
        // 모든 객체가 해제되었는지 확인 (디버그용)
    }
    
    template<typename... Args>
    T* allocate(Args&&... args) {
        if (freeSlots_ == nullptr) {
            allocatePool();
        }
        
        Slot* slot = freeSlots_;
        freeSlots_ = slot->next;
        
        // placement new를 사용하여 객체 생성
        return new (&slot->element) T(std::forward<Args>(args)...);
    }
    
    void deallocate(T* ptr) {
        if (ptr == nullptr) return;
        
        // 소멸자 호출
        ptr->~T();
        
        // free list에 추가
        Slot* slot = reinterpret_cast<Slot*>(ptr);
        slot->next = freeSlots_;
        freeSlots_ = slot;
    }
};

// 메모리 풀 사용 예제
class GameObject {
private:
    int id_;
    double x_, y_;
    std::string name_;
    
public:
    GameObject(int id, double x, double y, const std::string& name)
        : id_(id), x_(x), y_(y), name_(name) {
        // std::cout << "GameObject " << id_ << " created" << std::endl;
    }
    
    ~GameObject() {
        // std::cout << "GameObject " << id_ << " destroyed" << std::endl;
    }
    
    void update(double dx, double dy) {
        x_ += dx;
        y_ += dy;
    }
};

void comparePerformance() {
    using namespace std::chrono;
    
    const int iterations = 10000;
    
    // 표준 new/delete 사용
    auto start1 = high_resolution_clock::now();
    {
        std::vector<GameObject*> objects;
        for (int i = 0; i < iterations; ++i) {
            objects.push_back(new GameObject(i, 0, 0, "Object"));
        }
        for (auto obj : objects) {
            obj->update(1.0, 1.0);
            delete obj;
        }
    }
    auto end1 = high_resolution_clock::now();
    
    // 메모리 풀 사용
    auto start2 = high_resolution_clock::now();
    {
        MemoryPool<GameObject> pool;
        std::vector<GameObject*> objects;
        for (int i = 0; i < iterations; ++i) {
            objects.push_back(pool.allocate(i, 0, 0, "Object"));
        }
        for (auto obj : objects) {
            obj->update(1.0, 1.0);
            pool.deallocate(obj);
        }
    }
    auto end2 = high_resolution_clock::now();
    
    auto duration1 = duration_cast<microseconds>(end1 - start1).count();
    auto duration2 = duration_cast<microseconds>(end2 - start2).count();
    
    std::cout << "Standard new/delete: " << duration1 << " μs" << std::endl;
    std::cout << "Memory pool: " << duration2 << " μs" << std::endl;
    std::cout << "Speedup: " << (double)duration1 / duration2 << "x" << std::endl;
}
```

### 27.1.4 컨테이너 예약과 축소

벡터와 같은 동적 컨테이너는 크기가 증가할 때 재할당이 발생한다. 이를 최소화하는 방법을 알아본다.

```cpp
#include <iostream>
#include <vector>
#include <string>

void demonstrateReservation() {
    // 나쁜 예: reserve 없이 사용
    std::cout << "=== Without reserve ===" << std::endl;
    {
        std::vector<int> vec;
        std::cout << "Initial capacity: " << vec.capacity() << std::endl;
        
        for (int i = 0; i < 1000; ++i) {
            vec.push_back(i);
            if (vec.capacity() != vec.size()) {
                std::cout << "Size: " << vec.size() 
                         << ", Capacity: " << vec.capacity() << std::endl;
            }
        }
    }
    
    // 좋은 예: reserve 사용
    std::cout << "\n=== With reserve ===" << std::endl;
    {
        std::vector<int> vec;
        vec.reserve(1000);  // 미리 공간 확보
        std::cout << "Initial capacity: " << vec.capacity() << std::endl;
        
        for (int i = 0; i < 1000; ++i) {
            vec.push_back(i);
        }
        std::cout << "Final size: " << vec.size() 
                 << ", capacity: " << vec.capacity() << std::endl;
    }
    
    // shrink_to_fit으로 불필요한 메모리 해제
    std::cout << "\n=== Shrink to fit ===" << std::endl;
    {
        std::vector<int> vec;
        vec.reserve(1000);
        for (int i = 0; i < 100; ++i) {
            vec.push_back(i);
        }
        
        std::cout << "Before shrink - Size: " << vec.size() 
                 << ", Capacity: " << vec.capacity() << std::endl;
        
        vec.shrink_to_fit();
        
        std::cout << "After shrink - Size: " << vec.size() 
                 << ", Capacity: " << vec.capacity() << std::endl;
    }
}

// 실전 예제: 대량의 문자열 처리
void processLargeDataset() {
    const int dataSize = 100000;
    
    // 최적화 전
    auto start1 = std::chrono::high_resolution_clock::now();
    {
        std::vector<std::string> data;
        for (int i = 0; i < dataSize; ++i) {
            data.push_back("Item " + std::to_string(i));
        }
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // 최적화 후
    auto start2 = std::chrono::high_resolution_clock::now();
    {
        std::vector<std::string> data;
        data.reserve(dataSize);  // 재할당 방지
        for (int i = 0; i < dataSize; ++i) {
            data.push_back("Item " + std::to_string(i));
        }
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1).count();
    auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2).count();
    
    std::cout << "Without reserve: " << duration1 << " ms" << std::endl;
    std::cout << "With reserve: " << duration2 << " ms" << std::endl;
}
```

## 27.2 프로파일링과 성능 측정

### 27.2.1 Visual Studio 프로파일러 사용하기

Visual Studio 2022는 강력한 프로파일링 도구를 제공한다.

**프로파일링 시작 방법:**

1. 메뉴에서 `Debug` → `Performance Profiler` 선택 (단축키: Alt+F2)
2. 분석 도구 선택:
   - **CPU Usage**: CPU 사용률 분석
   - **Memory Usage**: 메모리 할당 패턴 분석
   - **Instrumentation**: 함수별 실행 시간 측정
3. `Start` 버튼 클릭
4. 프로그램 실행 및 작업 수행
5. 분석 종료 및 결과 확인

```cpp
// 프로파일링할 샘플 코드
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <random>

class PerformanceTest {
public:
    // 비효율적인 버전
    static std::vector<int> inefficientSort(std::vector<int> data) {
        // 버블 정렬 (O(n²))
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j < data.size() - 1; ++j) {
                if (data[j] > data[j + 1]) {
                    std::swap(data[j], data[j + 1]);
                }
            }
        }
        return data;
    }
    
    // 효율적인 버전
    static std::vector<int> efficientSort(std::vector<int> data) {
        // 표준 라이브러리 정렬 (O(n log n))
        std::sort(data.begin(), data.end());
        return data;
    }
    
    // 메모리 집약적 작업
    static void memoryIntensiveTask() {
        std::vector<std::vector<int>> matrix;
        for (int i = 0; i < 1000; ++i) {
            matrix.push_back(std::vector<int>(1000, i));
        }
        
        // 행렬 처리
        for (auto& row : matrix) {
            std::sort(row.begin(), row.end());
        }
    }
};

void runPerformanceTests() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 10000);
    
    // 테스트 데이터 생성
    std::vector<int> testData(10000);
    for (auto& val : testData) {
        val = dis(gen);
    }
    
    // 비효율적인 버전 측정
    auto start1 = std::chrono::high_resolution_clock::now();
    auto result1 = PerformanceTest::inefficientSort(testData);
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // 효율적인 버전 측정
    auto start2 = std::chrono::high_resolution_clock::now();
    auto result2 = PerformanceTest::efficientSort(testData);
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    
    std::cout << "Inefficient sort: " << duration1.count() << " ms" << std::endl;
    std::cout << "Efficient sort: " << duration2.count() << " ms" << std::endl;
    std::cout << "Speedup: " << (double)duration1.count() / duration2.count() << "x" << std::endl;
}
```

### 27.2.2 커스텀 프로파일러 만들기

자체 프로파일러를 만들어 특정 코드 섹션의 성능을 측정한다.

```cpp
#include <iostream>
#include <chrono>
#include <string>
#include <unordered_map>
#include <iomanip>

class Profiler {
private:
    struct ProfileData {
        std::chrono::nanoseconds totalTime{0};
        size_t callCount{0};
        std::chrono::nanoseconds minTime{std::chrono::nanoseconds::max()};
        std::chrono::nanoseconds maxTime{0};
        
        void addSample(std::chrono::nanoseconds time) {
            totalTime += time;
            ++callCount;
            minTime = std::min(minTime, time);
            maxTime = std::max(maxTime, time);
        }
        
        double averageMs() const {
            if (callCount == 0) return 0.0;
            return (totalTime.count() / callCount) / 1'000'000.0;
        }
        
        double totalMs() const {
            return totalTime.count() / 1'000'000.0;
        }
        
        double minMs() const {
            return minTime.count() / 1'000'000.0;
        }
        
        double maxMs() const {
            return maxTime.count() / 1'000'000.0;
        }
    };
    
    static inline std::unordered_map<std::string, ProfileData> profiles_;
    
public:
    class ScopedTimer {
    private:
        std::string name_;
        std::chrono::high_resolution_clock::time_point start_;
        
    public:
        explicit ScopedTimer(const std::string& name) 
            : name_(name), start_(std::chrono::high_resolution_clock::now()) {}
        
        ~ScopedTimer() {
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start_);
            Profiler::profiles_[name_].addSample(duration);
        }
    };
    
    static void reset() {
        profiles_.clear();
    }
    
    static void printReport() {
        std::cout << "\n=== Performance Report ===" << std::endl;
        std::cout << std::fixed << std::setprecision(3);
        std::cout << std::setw(30) << std::left << "Function"
                  << std::setw(12) << std::right << "Calls"
                  << std::setw(15) << "Total (ms)"
                  << std::setw(15) << "Avg (ms)"
                  << std::setw(15) << "Min (ms)"
                  << std::setw(15) << "Max (ms)" << std::endl;
        std::cout << std::string(102, '-') << std::endl;
        
        for (const auto& [name, data] : profiles_) {
            std::cout << std::setw(30) << std::left << name
                      << std::setw(12) << std::right << data.callCount
                      << std::setw(15) << data.totalMs()
                      << std::setw(15) << data.averageMs()
                      << std::setw(15) << data.minMs()
                      << std::setw(15) << data.maxMs() << std::endl;
        }
    }
};

// 매크로로 편리하게 사용
#define PROFILE_SCOPE(name) Profiler::ScopedTimer _timer##__LINE__(name)
#define PROFILE_FUNCTION() PROFILE_SCOPE(__FUNCTION__)

// 프로파일링 예제
void heavyComputation() {
    PROFILE_FUNCTION();
    
    double sum = 0.0;
    for (int i = 0; i < 1'000'000; ++i) {
        sum += std::sqrt(i);
    }
}

void lightComputation() {
    PROFILE_FUNCTION();
    
    int sum = 0;
    for (int i = 0; i < 1000; ++i) {
        sum += i;
    }
}

void recursiveFunction(int depth) {
    PROFILE_FUNCTION();
    
    if (depth <= 0) return;
    
    {
        PROFILE_SCOPE("RecursiveWork");
        // 실제 작업
        for (int i = 0; i < 10000; ++i) {
            volatile int x = i * i;
        }
    }
    
    recursiveFunction(depth - 1);
}

void demonstrateProfiler() {
    Profiler::reset();
    
    // 여러 함수 호출
    for (int i = 0; i < 10; ++i) {
        heavyComputation();
        lightComputation();
    }
    
    recursiveFunction(5);
    
    // 결과 출력
    Profiler::printReport();
}
```

### 27.2.3 핫스팟 찾기와 최적화

프로파일링 결과를 바탕으로 성능 병목 지점을 찾고 최적화한다.

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <numeric>

class DataProcessor {
public:
    // 최적화 전: 비효율적인 문자열 연결
    static std::string processDataSlow(const std::vector<std::string>& data) {
        PROFILE_FUNCTION();
        
        std::string result;
        for (const auto& item : data) {
            result += item;  // 매번 재할당 발생
            result += ", ";
        }
        return result;
    }
    
    // 최적화 후: 미리 크기를 계산하고 reserve 사용
    static std::string processDataFast(const std::vector<std::string>& data) {
        PROFILE_FUNCTION();
        
        // 전체 크기 계산
        size_t totalSize = std::accumulate(data.begin(), data.end(), size_t(0),
            [](size_t sum, const std::string& s) { return sum + s.size() + 2; });
        
        std::string result;
        result.reserve(totalSize);
        
        for (const auto& item : data) {
            result += item;
            result += ", ";
        }
        return result;
    }
    
    // 최적화 전: 중복된 계산
    static double calculateMetricSlow(const std::vector<int>& data) {
        PROFILE_FUNCTION();
        
        double sum = 0.0;
        for (size_t i = 0; i < data.size(); ++i) {
            sum += data[i] * std::sqrt(data.size());  // 매번 계산
        }
        return sum / data.size();
    }
    
    // 최적화 후: 공통 부분 식 제거
    static double calculateMetricFast(const std::vector<int>& data) {
        PROFILE_FUNCTION();
        
        if (data.empty()) return 0.0;
        
        const double sqrtSize = std::sqrt(data.size());  // 한 번만 계산
        const size_t size = data.size();
        
        double sum = 0.0;
        for (int value : data) {
            sum += value * sqrtSize;
        }
        return sum / size;
    }
};

void compareOptimizations() {
    // 테스트 데이터 준비
    std::vector<std::string> stringData(1000, "TestString");
    std::vector<int> numericData(100000);
    std::iota(numericData.begin(), numericData.end(), 1);
    
    Profiler::reset();
    
    // 문자열 처리 비교
    std::cout << "Testing string processing..." << std::endl;
    for (int i = 0; i < 10; ++i) {
        auto result1 = DataProcessor::processDataSlow(stringData);
        auto result2 = DataProcessor::processDataFast(stringData);
    }
    
    // 숫자 처리 비교
    std::cout << "Testing numeric processing..." << std::endl;
    for (int i = 0; i < 100; ++i) {
        auto result1 = DataProcessor::calculateMetricSlow(numericData);
        auto result2 = DataProcessor::calculateMetricFast(numericData);
    }
    
    Profiler::printReport();
}
```

## 27.3 코드 리팩토링 기법

### 27.3.1 리팩토링이란?

리팩토링은 코드의 외부 동작은 유지하면서 내부 구조를 개선하는 과정이다. 가독성, 유지보수성, 확장성을 향상시킨다.

```cpp
// 리팩토링 전: 긴 함수, 중복 코드, 매직 넘버
class OrderProcessorBefore {
public:
    void processOrder(int orderId, int customerId, double amount, int itemCount) {
        // 주문 유효성 검사
        if (amount < 0 || itemCount < 0) {
            std::cout << "Invalid order" << std::endl;
            return;
        }
        
        // 할인 계산
        double discount = 0.0;
        if (amount > 1000) {
            discount = amount * 0.1;
        } else if (amount > 500) {
            discount = amount * 0.05;
        }
        
        double finalAmount = amount - discount;
        
        // 배송비 계산
        double shipping = 0.0;
        if (finalAmount < 500) {
            shipping = 50;
        }
        
        finalAmount += shipping;
        
        // 처리
        std::cout << "Order " << orderId << " processed" << std::endl;
        std::cout << "Customer: " << customerId << std::endl;
        std::cout << "Amount: " << finalAmount << std::endl;
    }
};

// 리팩토링 후: 의미 있는 함수 분리, 상수 사용, 명확한 구조
class OrderProcessorAfter {
private:
    static constexpr double LARGE_ORDER_THRESHOLD = 1000.0;
    static constexpr double MEDIUM_ORDER_THRESHOLD = 500.0;
    static constexpr double LARGE_ORDER_DISCOUNT = 0.1;
    static constexpr double MEDIUM_ORDER_DISCOUNT = 0.05;
    static constexpr double FREE_SHIPPING_THRESHOLD = 500.0;
    static constexpr double SHIPPING_FEE = 50.0;
    
    struct Order {
        int id;
        int customerId;
        double amount;
        int itemCount;
        
        bool isValid() const {
            return amount >= 0 && itemCount >= 0;
        }
    };
    
    static double calculateDiscount(double amount) {
        if (amount >= LARGE_ORDER_THRESHOLD) {
            return amount * LARGE_ORDER_DISCOUNT;
        } else if (amount >= MEDIUM_ORDER_THRESHOLD) {
            return amount * MEDIUM_ORDER_DISCOUNT;
        }
        return 0.0;
    }
    
    static double calculateShipping(double amount) {
        return (amount < FREE_SHIPPING_THRESHOLD) ? SHIPPING_FEE : 0.0;
    }
    
    static double calculateFinalAmount(double amount) {
        double discount = calculateDiscount(amount);
        double afterDiscount = amount - discount;
        double shipping = calculateShipping(afterDiscount);
        return afterDiscount + shipping;
    }
    
    static void printOrderSummary(const Order& order, double finalAmount) {
        std::cout << "Order " << order.id << " processed" << std::endl;
        std::cout << "Customer: " << order.customerId << std::endl;
        std::cout << "Final amount: $" << std::fixed << std::setprecision(2) 
                  << finalAmount << std::endl;
    }
    
public:
    void processOrder(int orderId, int customerId, double amount, int itemCount) {
        Order order{orderId, customerId, amount, itemCount};
        
        if (!order.isValid()) {
            std::cout << "Invalid order parameters" << std::endl;
            return;
        }
        
        double finalAmount = calculateFinalAmount(order.amount);
        printOrderSummary(order, finalAmount);
    }
};
```

### 27.3.2 SOLID 원칙 적용하기

SOLID는 객체지향 설계의 5가지 핵심 원칙이다.

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

// S - Single Responsibility Principle (단일 책임 원칙)
// 각 클래스는 하나의 책임만 가져야 한다

// 나쁜 예: 여러 책임을 가진 클래스
class UserManagerBad {
public:
    void createUser(const std::string& name) { /* ... */ }
    void deleteUser(int id) { /* ... */ }
    void sendEmail(int userId, const std::string& message) { /* ... */ }  // 이메일은 별도 책임
    void saveToDatabase(int userId) { /* ... */ }  // 데이터베이스는 별도 책임
};

// 좋은 예: 책임 분리
class User {
private:
    int id_;
    std::string name_;
    std::string email_;
    
public:
    User(int id, const std::string& name, const std::string& email)
        : id_(id), name_(name), email_(email) {}
    
    int getId() const { return id_; }
    const std::string& getName() const { return name_; }
    const std::string& getEmail() const { return email_; }
};

class UserRepository {
public:
    void save(const User& user) {
        std::cout << "Saving user to database..." << std::endl;
    }
    
    void remove(int userId) {
        std::cout << "Removing user from database..." << std::endl;
    }
};

class EmailService {
public:
    void send(const std::string& to, const std::string& message) {
        std::cout << "Sending email to " << to << ": " << message << std::endl;
    }
};

class UserService {
private:
    UserRepository repository_;
    EmailService emailService_;
    
public:
    void createUser(const std::string& name, const std::string& email) {
        User user(0, name, email);
        repository_.save(user);
        emailService_.send(email, "Welcome!");
    }
};

// O - Open/Closed Principle (개방/폐쇄 원칙)
// 확장에는 열려 있고 수정에는 닫혀 있어야 한다

class Shape {
public:
    virtual ~Shape() = default;
    virtual double area() const = 0;
};

class Rectangle : public Shape {
private:
    double width_, height_;
    
public:
    Rectangle(double w, double h) : width_(w), height_(h) {}
    
    double area() const override {
        return width_ * height_;
    }
};

class Circle : public Shape {
private:
    double radius_;
    
public:
    Circle(double r) : radius_(r) {}
    
    double area() const override {
        return 3.14159 * radius_ * radius_;
    }
};

// 새로운 도형을 추가해도 기존 코드 수정 불필요
class Triangle : public Shape {
private:
    double base_, height_;
    
public:
    Triangle(double b, double h) : base_(b), height_(h) {}
    
    double area() const override {
        return 0.5 * base_ * height_;
    }
};

class AreaCalculator {
public:
    double totalArea(const std::vector<std::unique_ptr<Shape>>& shapes) const {
        double total = 0.0;
        for (const auto& shape : shapes) {
            total += shape->area();
        }
        return total;
    }
};

// L - Liskov Substitution Principle (리스코프 치환 원칙)
// 하위 타입은 상위 타입을 대체할 수 있어야 한다

class Bird {
public:
    virtual ~Bird() = default;
    virtual void eat() { std::cout << "Bird is eating" << std::endl; }
};

// 나쁜 예: 펭귄은 날 수 없으므로 LSP 위반
class FlyingBird : public Bird {
public:
    virtual void fly() { std::cout << "Bird is flying" << std::endl; }
};

// 좋은 예: 인터페이스 분리
class WalkingBird : public Bird {
public:
    virtual void walk() { std::cout << "Bird is walking" << std::endl; }
};

class Sparrow : public Bird {
public:
    void fly() { std::cout << "Sparrow is flying" << std::endl; }
};

class Penguin : public WalkingBird {
public:
    void walk() override { std::cout << "Penguin is walking" << std::endl; }
    void swim() { std::cout << "Penguin is swimming" << std::endl; }
};

// I - Interface Segregation Principle (인터페이스 분리 원칙)
// 클라이언트는 사용하지 않는 인터페이스에 의존하면 안 된다

// 나쁜 예: 너무 많은 기능을 가진 인터페이스
class WorkerBad {
public:
    virtual ~WorkerBad() = default;
    virtual void work() = 0;
    virtual void eat() = 0;
    virtual void sleep() = 0;
    virtual void program() = 0;  // 모든 작업자가 프로그래밍을 하는 것은 아님
};

// 좋은 예: 인터페이스 분리
class Workable {
public:
    virtual ~Workable() = default;
    virtual void work() = 0;
};

class Eatable {
public:
    virtual ~Eatable() = default;
    virtual void eat() = 0;
};

class Sleepable {
public:
    virtual ~Sleepable() = default;
    virtual void sleep() = 0;
};

class Programmable {
public:
    virtual ~Programmable() = default;
    virtual void program() = 0;
};

class Developer : public Workable, public Eatable, public Sleepable, public Programmable {
public:
    void work() override { std::cout << "Developer is working" << std::endl; }
    void eat() override { std::cout << "Developer is eating" << std::endl; }
    void sleep() override { std::cout << "Developer is sleeping" << std::endl; }
    void program() override { std::cout << "Developer is programming" << std::endl; }
};

class Robot : public Workable {
public:
    void work() override { std::cout << "Robot is working" << std::endl; }
    // eat, sleep 불필요
};

// D - Dependency Inversion Principle (의존성 역전 원칙)
// 고수준 모듈은 저수준 모듈에 의존하면 안 되고, 둘 다 추상화에 의존해야 한다

// 나쁜 예: 구체 클래스에 직접 의존
class MySQLDatabaseBad {
public:
    void connect() { std::cout << "Connecting to MySQL" << std::endl; }
    void query(const std::string& sql) { std::cout << "Executing: " << sql << std::endl; }
};

class UserRepositoryBad {
private:
    MySQLDatabaseBad db_;  // 구체 클래스에 직접 의존
    
public:
    void save() {
        db_.connect();
        db_.query("INSERT INTO users...");
    }
};

// 좋은 예: 추상화에 의존
class Database {
public:
    virtual ~Database() = default;
    virtual void connect() = 0;
    virtual void query(const std::string& sql) = 0;
};

class MySQLDatabase : public Database {
public:
    void connect() override { std::cout << "Connecting to MySQL" << std::endl; }
    void query(const std::string& sql) override { 
        std::cout << "MySQL query: " << sql << std::endl; 
    }
};

class PostgreSQLDatabase : public Database {
public:
    void connect() override { std::cout << "Connecting to PostgreSQL" << std::endl; }
    void query(const std::string& sql) override { 
        std::cout << "PostgreSQL query: " << sql << std::endl; 
    }
};

class UserRepositoryGood {
private:
    std::unique_ptr<Database> db_;  // 추상화에 의존
    
public:
    UserRepositoryGood(std::unique_ptr<Database> db) : db_(std::move(db)) {}
    
    void save() {
        db_->connect();
        db_->query("INSERT INTO users...");
    }
};
```

### 27.3.3 코드 냄새와 해결 방법

코드 냄새(Code Smell)는 더 깊은 문제를 나타내는 징후다.

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

// 1. 긴 매개변수 목록 (Long Parameter List)
// 나쁜 예
void createUserBad(const std::string& name, const std::string& email, 
                   int age, const std::string& address, const std::string& phone,
                   const std::string& city, const std::string& country) {
    // ...
}

// 좋은 예: 매개변수 객체 도입
struct UserInfo {
    std::string name;
    std::string email;
    int age;
    std::string address;
    std::string phone;
    std::string city;
    std::string country;
};

void createUserGood(const UserInfo& userInfo) {
    // ...
}

// 2. 중복 코드 (Duplicated Code)
// 나쁜 예
double calculateDiscountForStudent(double price) {
    double discount = price * 0.1;
    double tax = price * 0.05;
    return price - discount + tax;
}

double calculateDiscountForSenior(double price) {
    double discount = price * 0.15;
    double tax = price * 0.05;
    return price - discount + tax;
}

// 좋은 예: 공통 로직 추출
double calculateFinalPrice(double price, double discountRate) {
    constexpr double TAX_RATE = 0.05;
    double discount = price * discountRate;
    double tax = price * TAX_RATE;
    return price - discount + tax;
}

double calculateDiscountForStudentGood(double price) {
    return calculateFinalPrice(price, 0.1);
}

double calculateDiscountForSeniorGood(double price) {
    return calculateFinalPrice(price, 0.15);
}

// 3. 거대 클래스 (Large Class)
// 나쁜 예: 너무 많은 책임을 가진 클래스
class ProductManagerBad {
public:
    void addProduct() { /* ... */ }
    void removeProduct() { /* ... */ }
    void updatePrice() { /* ... */ }
    void calculateDiscount() { /* ... */ }
    void sendEmail() { /* ... */ }
    void generateReport() { /* ... */ }
    void exportToCSV() { /* ... */ }
    void importFromCSV() { /* ... */ }
    // ... 수십 개의 메서드
};

// 좋은 예: 책임 분리
class Product {
    // 제품 데이터
};

class ProductRepository {
public:
    void add(const Product& product) { /* ... */ }
    void remove(int id) { /* ... */ }
    void update(const Product& product) { /* ... */ }
};

class PriceCalculator {
public:
    double calculateDiscount(const Product& product) { /* ... */ return 0.0; }
};

class ProductNotifier {
public:
    void sendEmail(const Product& product) { /* ... */ }
};

class ProductReporter {
public:
    void generateReport() { /* ... */ }
};

class ProductImportExport {
public:
    void exportToCSV() { /* ... */ }
    void importFromCSV() { /* ... */ }
};

// 4. 불필요한 복잡성 (Speculative Generality)
// 나쁜 예: 필요하지 않은 추상화
template<typename T, typename Allocator = std::allocator<T>>
class FlexibleContainer {
    // 실제로는 vector만 필요한데 과도하게 일반화
};

// 좋은 예: 필요한 만큼만 구현
class SimpleContainer {
    std::vector<int> data_;
public:
    void add(int value) { data_.push_back(value); }
    int get(size_t index) const { return data_[index]; }
};

// 5. 긴 메서드 (Long Method)
// 나쁜 예
void processOrderBad(int orderId) {
    // 100줄 이상의 코드
    // 주문 검증
    // 재고 확인
    // 결제 처리
    // 배송 준비
    // 이메일 전송
    // 로그 기록
}

// 좋은 예: 작은 메서드로 분리
class OrderProcessor {
private:
    bool validateOrder(int orderId) { 
        std::cout << "Validating order" << std::endl;
        return true; 
    }
    
    bool checkInventory(int orderId) { 
        std::cout << "Checking inventory" << std::endl;
        return true; 
    }
    
    bool processPayment(int orderId) { 
        std::cout << "Processing payment" << std::endl;
        return true; 
    }
    
    void prepareShipping(int orderId) { 
        std::cout << "Preparing shipping" << std::endl;
    }
    
    void sendConfirmationEmail(int orderId) { 
        std::cout << "Sending email" << std::endl;
    }
    
    void logOrder(int orderId) { 
        std::cout << "Logging order" << std::endl;
    }
    
public:
    void processOrder(int orderId) {
        if (!validateOrder(orderId)) {
            std::cout << "Invalid order" << std::endl;
            return;
        }
        
        if (!checkInventory(orderId)) {
            std::cout << "Out of stock" << std::endl;
            return;
        }
        
        if (!processPayment(orderId)) {
            std::cout << "Payment failed" << std::endl;
            return;
        }
        
        prepareShipping(orderId);
        sendConfirmationEmail(orderId);
        logOrder(orderId);
    }
};
```

## 27.4 단위 테스트 기초

### 27.4.1 테스트의 중요성

단위 테스트는 코드의 작은 단위(함수, 메서드)가 예상대로 동작하는지 검증한다. 버그를 조기에 발견하고 리팩토링을 안전하게 수행할 수 있게 해준다.

```cpp
#include <iostream>
#include <cassert>
#include <cmath>
#include <stdexcept>
#include <sstream>

// 테스트할 간단한 계산기 클래스
class Calculator {
public:
    static int add(int a, int b) {
        return a + b;
    }
    
    static int subtract(int a, int b) {
        return a - b;
    }
    
    static int multiply(int a, int b) {
        return a * b;
    }
    
    static double divide(int a, int b) {
        if (b == 0) {
            throw std::invalid_argument("Division by zero");
        }
        return static_cast<double>(a) / b;
    }
    
    static double squareRoot(double x) {
        if (x < 0) {
            throw std::invalid_argument("Negative number");
        }
        return std::sqrt(x);
    }
};

// 간단한 테스트 프레임워크
class TestFramework {
private:
    static inline int totalTests_ = 0;
    static inline int passedTests_ = 0;
    static inline int failedTests_ = 0;
    
public:
    static void assertEqual(int expected, int actual, const std::string& testName) {
        totalTests_++;
        if (expected == actual) {
            passedTests_++;
            std::cout << "[PASS] " << testName << std::endl;
        } else {
            failedTests_++;
            std::cout << "[FAIL] " << testName 
                     << " - Expected: " << expected 
                     << ", Got: " << actual << std::endl;
        }
    }
    
    static void assertEqual(double expected, double actual, 
                           const std::string& testName, double epsilon = 0.0001) {
        totalTests_++;
        if (std::abs(expected - actual) < epsilon) {
            passedTests_++;
            std::cout << "[PASS] " << testName << std::endl;
        } else {
            failedTests_++;
            std::cout << "[FAIL] " << testName 
                     << " - Expected: " << expected 
                     << ", Got: " << actual << std::endl;
        }
    }
    
    static void assertTrue(bool condition, const std::string& testName) {
        totalTests_++;
        if (condition) {
            passedTests_++;
            std::cout << "[PASS] " << testName << std::endl;
        } else {
            failedTests_++;
            std::cout << "[FAIL] " << testName << std::endl;
        }
    }
    
    template<typename ExceptionType, typename Func>
    static void assertThrows(Func func, const std::string& testName) {
        totalTests_++;
        try {
            func();
            failedTests_++;
            std::cout << "[FAIL] " << testName 
                     << " - Expected exception not thrown" << std::endl;
        } catch (const ExceptionType& e) {
            passedTests_++;
            std::cout << "[PASS] " << testName << std::endl;
        } catch (...) {
            failedTests_++;
            std::cout << "[FAIL] " << testName 
                     << " - Wrong exception type" << std::endl;
        }
    }
    
    static void printSummary() {
        std::cout << "\n=== Test Summary ===" << std::endl;
        std::cout << "Total: " << totalTests_ << std::endl;
        std::cout << "Passed: " << passedTests_ << std::endl;
        std::cout << "Failed: " << failedTests_ << std::endl;
        std::cout << "Success rate: " 
                 << (totalTests_ > 0 ? (passedTests_ * 100.0 / totalTests_) : 0) 
                 << "%" << std::endl;
    }
    
    static void reset() {
        totalTests_ = 0;
        passedTests_ = 0;
        failedTests_ = 0;
    }
};

// 테스트 케이스 작성
void testCalculator() {
    std::cout << "=== Calculator Tests ===" << std::endl;
    
    // 덧셈 테스트
    TestFramework::assertEqual(5, Calculator::add(2, 3), "Add positive numbers");
    TestFramework::assertEqual(-1, Calculator::add(-3, 2), "Add negative and positive");
    TestFramework::assertEqual(0, Calculator::add(0, 0), "Add zeros");
    
    // 뺄셈 테스트
    TestFramework::assertEqual(3, Calculator::subtract(5, 2), "Subtract positive numbers");
    TestFramework::assertEqual(-5, Calculator::subtract(-3, 2), "Subtract with negative");
    
    // 곱셈 테스트
    TestFramework::assertEqual(6, Calculator::multiply(2, 3), "Multiply positive numbers");
    TestFramework::assertEqual(-6, Calculator::multiply(-2, 3), "Multiply negative and positive");
    TestFramework::assertEqual(0, Calculator::multiply(0, 5), "Multiply by zero");
    
    // 나눗셈 테스트
    TestFramework::assertEqual(2.0, Calculator::divide(6, 3), "Divide evenly");
    TestFramework::assertEqual(2.5, Calculator::divide(5, 2), "Divide with remainder");
    
    // 0으로 나누기 예외 테스트
    TestFramework::assertThrows<std::invalid_argument>(
        []() { Calculator::divide(5, 0); },
        "Divide by zero throws exception"
    );
    
    // 제곱근 테스트
    TestFramework::assertEqual(3.0, Calculator::squareRoot(9), "Square root of positive");
    TestFramework::assertEqual(0.0, Calculator::squareRoot(0), "Square root of zero");
    
    // 음수 제곱근 예외 테스트
    TestFramework::assertThrows<std::invalid_argument>(
        []() { Calculator::squareRoot(-1); },
        "Square root of negative throws exception"
    );
}
```

### 27.4.2 테스트 주도 개발 (TDD)

테스트 주도 개발은 테스트를 먼저 작성하고, 그 테스트를 통과하는 코드를 작성하는 방법론이다.

```cpp
// 1단계: 테스트 작성 (실패하는 테스트)
void testStringProcessor() {
    std::cout << "\n=== StringProcessor Tests ===" << std::endl;
    
    // 아직 구현되지 않은 기능에 대한 테스트
    // TestFramework::assertEqual("hello", StringProcessor::toLowerCase("HELLO"), 
    //                           "Convert to lowercase");
}

// 2단계: 최소한의 코드 작성 (테스트 통과)
class StringProcessor {
public:
    static std::string toLowerCase(const std::string& str) {
        std::string result = str;
        for (char& c : result) {
            if (c >= 'A' && c <= 'Z') {
                c = c - 'A' + 'a';
            }
        }
        return result;
    }
    
    static std::string toUpperCase(const std::string& str) {
        std::string result = str;
        for (char& c : result) {
            if (c >= 'a' && c <= 'z') {
                c = c - 'a' + 'A';
            }
        }
        return result;
    }
    
    static std::string reverse(const std::string& str) {
        std::string result = str;
        std::reverse(result.begin(), result.end());
        return result;
    }
    
    static bool isPalindrome(const std::string& str) {
        size_t left = 0;
        size_t right = str.length() - 1;
        
        while (left < right) {
            if (str[left] != str[right]) {
                return false;
            }
            ++left;
            --right;
        }
        return true;
    }
};

// 3단계: 테스트 실행 및 리팩토링
void testStringProcessorComplete() {
    std::cout << "\n=== StringProcessor Tests ===" << std::endl;
    
    // toLowerCase 테스트
    TestFramework::assertEqual(
        std::string("hello"), 
        StringProcessor::toLowerCase("HELLO"), 
        "Convert to lowercase"
    );
    
    TestFramework::assertEqual(
        std::string("hello world"), 
        StringProcessor::toLowerCase("HeLLo WoRLd"), 
        "Convert mixed case to lowercase"
    );
    
    // toUpperCase 테스트
    TestFramework::assertEqual(
        std::string("HELLO"), 
        StringProcessor::toUpperCase("hello"), 
        "Convert to uppercase"
    );
    
    // reverse 테스트
    TestFramework::assertEqual(
        std::string("olleh"), 
        StringProcessor::reverse("hello"), 
        "Reverse string"
    );
    
    TestFramework::assertEqual(
        std::string(""), 
        StringProcessor::reverse(""), 
        "Reverse empty string"
    );
    
    // isPalindrome 테스트
    TestFramework::assertTrue(
        StringProcessor::isPalindrome("radar"), 
        "Check palindrome - radar"
    );
    
    TestFramework::assertTrue(
        StringProcessor::isPalindrome(""), 
        "Check palindrome - empty string"
    );
    
    TestFramework::assertTrue(
        !StringProcessor::isPalindrome("hello"), 
        "Check non-palindrome"
    );
}
```

### 27.4.3 Siv3D 프로젝트 테스트하기

Siv3D를 사용하는 프로젝트에서도 로직 부분은 단위 테스트할 수 있다.

```cpp
#include <Siv3D.hpp>

// 게임 로직 클래스 (Siv3D와 독립적)
class GameScore {
private:
    int score_;
    int multiplier_;
    
public:
    GameScore() : score_(0), multiplier_(1) {}
    
    void addPoints(int points) {
        if (points > 0) {
            score_ += points * multiplier_;
        }
    }
    
    void increaseMultiplier() {
        if (multiplier_ < 10) {
            multiplier_++;
        }
    }
    
    void resetMultiplier() {
        multiplier_ = 1;
    }
    
    int getScore() const { return score_; }
    int getMultiplier() const { return multiplier_; }
    
    void reset() {
        score_ = 0;
        multiplier_ = 1;
    }
};

// 충돌 감지 로직 (Siv3D와 독립적)
class CollisionDetector {
public:
    struct Rect {
        double x, y, width, height;
        
        bool intersects(const Rect& other) const {
            return !(x + width < other.x || 
                    other.x + other.width < x ||
                    y + height < other.y || 
                    other.y + other.height < y);
        }
    };
    
    struct Circle {
        double x, y, radius;
        
        bool intersects(const Circle& other) const {
            double dx = x - other.x;
            double dy = y - other.y;
            double distance = std::sqrt(dx * dx + dy * dy);
            return distance < (radius + other.radius);
        }
    };
};

// 게임 로직 테스트
void testGameLogic() {
    std::cout << "\n=== Game Logic Tests ===" << std::endl;
    
    // GameScore 테스트
    GameScore score;
    
    TestFramework::assertEqual(0, score.getScore(), "Initial score is zero");
    TestFramework::assertEqual(1, score.getMultiplier(), "Initial multiplier is 1");
    
    score.addPoints(10);
    TestFramework::assertEqual(10, score.getScore(), "Add points without multiplier");
    
    score.increaseMultiplier();
    score.addPoints(10);
    TestFramework::assertEqual(30, score.getScore(), "Add points with multiplier");
    
    score.resetMultiplier();
    TestFramework::assertEqual(1, score.getMultiplier(), "Reset multiplier");
    
    score.reset();
    TestFramework::assertEqual(0, score.getScore(), "Reset score");
    
    // CollisionDetector 테스트
    CollisionDetector::Rect rect1{0, 0, 10, 10};
    CollisionDetector::Rect rect2{5, 5, 10, 10};
    CollisionDetector::Rect rect3{20, 20, 10, 10};
    
    TestFramework::assertTrue(
        rect1.intersects(rect2), 
        "Overlapping rectangles collide"
    );
    
    TestFramework::assertTrue(
        !rect1.intersects(rect3), 
        "Separated rectangles don't collide"
    );
    
    CollisionDetector::Circle circle1{0, 0, 5};
    CollisionDetector::Circle circle2{8, 0, 5};
    CollisionDetector::Circle circle3{20, 0, 5};
    
    TestFramework::assertTrue(
        circle1.intersects(circle2), 
        "Overlapping circles collide"
    );
    
    TestFramework::assertTrue(
        !circle1.intersects(circle3), 
        "Separated circles don't collide"
    );
}
```

### 27.4.4 통합 테스트 예제

```cpp
// 통합 테스트: 여러 컴포넌트가 함께 동작하는지 확인
class ShoppingCart {
private:
    std::vector<std::pair<std::string, double>> items_;
    double discountRate_;
    
public:
    ShoppingCart() : discountRate_(0.0) {}
    
    void addItem(const std::string& name, double price) {
        if (price > 0) {
            items_.push_back({name, price});
        }
    }
    
    void setDiscount(double rate) {
        if (rate >= 0 && rate <= 1.0) {
            discountRate_ = rate;
        }
    }
    
    double getSubtotal() const {
        double sum = 0.0;
        for (const auto& [name, price] : items_) {
            sum += price;
        }
        return sum;
    }
    
    double getDiscount() const {
        return getSubtotal() * discountRate_;
    }
    
    double getTotal() const {
        return getSubtotal() - getDiscount();
    }
    
    size_t getItemCount() const {
        return items_.size();
    }
    
    void clear() {
        items_.clear();
        discountRate_ = 0.0;
    }
};

void testShoppingCart() {
    std::cout << "\n=== Shopping Cart Integration Tests ===" << std::endl;
    
    ShoppingCart cart;
    
    // 빈 카트 테스트
    TestFramework::assertEqual(0, static_cast<int>(cart.getItemCount()), 
                              "Empty cart has no items");
    TestFramework::assertEqual(0.0, cart.getTotal(), 
                              "Empty cart total is zero");
    
    // 아이템 추가
    cart.addItem("Apple", 1.50);
    cart.addItem("Banana", 0.75);
    cart.addItem("Orange", 2.00);
    
    TestFramework::assertEqual(3, static_cast<int>(cart.getItemCount()), 
                              "Cart has 3 items");
    TestFramework::assertEqual(4.25, cart.getSubtotal(), 
                              "Subtotal calculated correctly");
    
    // 할인 적용
    cart.setDiscount(0.1);  // 10% 할인
    
    TestFramework::assertEqual(0.425, cart.getDiscount(), 
                              "Discount calculated correctly", 0.01);
    TestFramework::assertEqual(3.825, cart.getTotal(), 
                              "Total with discount calculated correctly", 0.01);
    
    // 카트 비우기
    cart.clear();
    TestFramework::assertEqual(0, static_cast<int>(cart.getItemCount()), 
                              "Cleared cart has no items");
}
```

## 27.5 종합 실습

### 27.5.1 최적화된 데이터 처리 시스템 만들기

지금까지 배운 내용을 종합하여 효율적인 데이터 처리 시스템을 만든다.

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <memory>
#include <chrono>

// 데이터 항목
struct DataItem {
    int id;
    std::string name;
    double value;
    
    DataItem(int i, const std::string& n, double v)
        : id(i), name(n), value(v) {}
};

// 효율적인 데이터 컨테이너
class DataContainer {
private:
    std::vector<DataItem> items_;
    
public:
    DataContainer() {
        items_.reserve(1000);  // 미리 공간 확보
    }
    
    void addItem(int id, const std::string& name, double value) {
        items_.emplace_back(id, name, value);  // 복사 대신 직접 생성
    }
    
    // const 참조로 반환 (복사 방지)
    const std::vector<DataItem>& getItems() const {
        return items_;
    }
    
    // 조건에 맞는 항목 필터링 (람다 사용)
    std::vector<DataItem> filter(std::function<bool(const DataItem&)> predicate) const {
        std::vector<DataItem> result;
        result.reserve(items_.size() / 2);  // 대략적인 예상 크기
        
        std::copy_if(items_.begin(), items_.end(), std::back_inserter(result), predicate);
        
        result.shrink_to_fit();  // 불필요한 메모리 해제
        return result;
    }
    
    // 정렬 (이동 의미론 활용)
    void sort(std::function<bool(const DataItem&, const DataItem&)> comparator) {
        std::sort(items_.begin(), items_.end(), comparator);
    }
    
    size_t size() const { return items_.size(); }
    void clear() { items_.clear(); }
};

// 데이터 프로세서
class DataProcessor {
public:
    static double calculateAverage(const DataContainer& container) {
        PROFILE_SCOPE("CalculateAverage");
        
        if (container.size() == 0) return 0.0;
        
        double sum = 0.0;
        for (const auto& item : container.getItems()) {
            sum += item.value;
        }
        
        return sum / container.size();
    }
    
    static DataItem findMax(const DataContainer& container) {
        PROFILE_SCOPE("FindMax");
        
        if (container.size() == 0) {
            throw std::runtime_error("Empty container");
        }
        
        return *std::max_element(
            container.getItems().begin(), 
            container.getItems().end(),
            [](const DataItem& a, const DataItem& b) { 
                return a.value < b.value; 
            }
        );
    }
};

// 테스트 함수
void testDataSystem() {
    std::cout << "\n=== Data System Tests ===" << std::endl;
    
    DataContainer container;
    
    // 데이터 추가
    container.addItem(1, "Item1", 10.5);
    container.addItem(2, "Item2", 20.3);
    container.addItem(3, "Item3", 15.7);
    container.addItem(4, "Item4", 8.2);
    
    TestFramework::assertEqual(4, static_cast<int>(container.size()), 
                              "Container has 4 items");
    
    // 평균 계산
    double avg = DataProcessor::calculateAverage(container);
    TestFramework::assertEqual(13.675, avg, "Average calculated correctly", 0.01);
    
    // 최대값 찾기
    DataItem max = DataProcessor::findMax(container);
    TestFramework::assertEqual(2, max.id, "Max item found correctly");
    TestFramework::assertEqual(20.3, max.value, "Max value is correct", 0.01);
    
    // 필터링
    auto filtered = container.filter([](const DataItem& item) { 
        return item.value > 15.0; 
    });
    
    TestFramework::assertEqual(2, static_cast<int>(filtered.size()), 
                              "Filtered 2 items");
}

void demonstrateOptimization() {
    Profiler::reset();
    
    DataContainer container;
    
    // 대량의 데이터 추가
    for (int i = 0; i < 10000; ++i) {
        container.addItem(i, "Item" + std::to_string(i), i * 1.5);
    }
    
    // 성능 측정
    for (int i = 0; i < 100; ++i) {
        DataProcessor::calculateAverage(container);
        DataProcessor::findMax(container);
    }
    
    Profiler::printReport();
}
```

## 27.6 실습 문제

**문제 1**: 메모리 풀을 사용하는 입자 시스템을 구현하라. 1000개 이상의 입자가 생성/소멸을 반복할 때의 성능을 측정하라.

**문제 2**: 긴 메서드를 찾아서 작은 함수들로 리팩토링하라. 리팩토링 전후의 가독성을 비교하라.

**문제 3**: 간단한 게임 로직(점수 계산, 충돌 감지 등)에 대한 단위 테스트를 작성하라. 최소 10개 이상의 테스트 케이스를 포함하라.

**문제 4**: Visual Studio의 프로파일러를 사용하여 이전 프로젝트의 성능 병목을 찾고 최적화하라.

**문제 5**: SOLID 원칙을 위반하는 코드를 찾아 리팩토링하라. 각 원칙별로 최소 1개씩의 예제를 만들라.

## 27.7 마치며

이번 장에서는 효율적이고 유지보수하기 쉬운 코드를 작성하는 고급 기법들을 배웠다. 메모리 관리, 성능 최적화, 코드 리팩토링, 단위 테스트는 전문 개발자가 되기 위해 반드시 익혀야 할 필수 기술이다.

**핵심 포인트:**

1. **메모리 효율성**: 불필요한 복사를 피하고, 적절한 메모리 관리 기법을 사용한다
2. **프로파일링**: 추측이 아닌 측정을 통해 최적화한다
3. **리팩토링**: 작동하는 코드를 더 좋은 코드로 지속적으로 개선한다
4. **테스트**: 버그를 조기에 발견하고 코드 품질을 보장한다

"동작하는 코드를 작성하는 것은 시작일 뿐이다. 좋은 코드는 읽기 쉽고, 유지보수하기 쉬우며, 효율적이어야 한다."

다음 장에서는 이 책의 마지막 장으로, C++23의 고급 기능들과 앞으로의 학습 방향을 다룬다.

   
 