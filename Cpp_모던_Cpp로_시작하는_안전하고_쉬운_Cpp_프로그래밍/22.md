# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 22: 사운드와 음악

게임이나 멀티미디어 애플리케이션에서 사운드는 사용자 경험을 크게 향상시키는 중요한 요소다. 버튼을 클릭할 때 들리는 작은 효과음부터 게임의 분위기를 결정하는 배경 음악까지, 오디오는 프로그램에 생명력을 불어넣는다. 이번 장에서는 Siv3D를 사용하여 사운드 파일을 로드하고 재생하며, 음악과 효과음을 효과적으로 관리하는 방법을 배운다.

## 22.1 사운드 시스템 개요

Siv3D는 다양한 오디오 파일 형식을 지원하며, 간단한 인터페이스로 사운드를 제어할 수 있다. 주로 사용하는 오디오 파일 형식은 다음과 같다.

**지원하는 오디오 형식:**
- WAV: 무손실 압축 형식으로 효과음에 적합하다
- MP3: 압축 형식으로 배경 음악에 적합하다
- OGG: 오픈 소스 압축 형식으로 용량과 품질의 균형이 좋다
- AAC/M4A: 고품질 압축 형식이다
- FLAC: 무손실 압축 형식으로 고음질이 필요할 때 사용한다

Siv3D에서는 크게 두 가지 클래스를 사용하여 오디오를 처리한다. `Audio` 클래스는 효과음과 배경 음악 모두에 사용할 수 있으며, 메모리에 전체 오디오 데이터를 로드한다. 반면 `AudioStream` 클래스는 큰 파일을 스트리밍 방식으로 재생하여 메모리를 절약한다.

일반적으로 짧은 효과음은 `Audio`를, 긴 배경 음악은 메모리 효율을 고려하여 `Audio` 또는 상황에 따라 선택한다. Siv3D v0.6.16에서는 대부분의 경우 `Audio` 클래스만으로도 충분하다.

## 22.2 사운드 파일 로드와 재생

가장 기본적인 사운드 재생부터 시작한다. 먼저 프로젝트의 적절한 위치에 오디오 파일을 배치해야 한다. Visual Studio 2022에서 Siv3D 프로젝트를 만들면 기본적으로 `App` 폴더가 생성되는데, 이곳에 오디오 파일을 저장한다.

### 22.2.1 기본적인 사운드 재생

다음은 클릭 효과음을 재생하는 간단한 예제다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 배경 색상 설정
    Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });

    // 효과음 로드
    const Audio clickSound{ U"example/sound/button.mp3" };

    // 로드 실패 확인
    if (not clickSound)
    {
        throw Error{ U"Failed to load audio file" };
    }

    // 재생 버튼 영역
    const Rect playButton{ 300, 250, 200, 60 };

    while (System::Update())
    {
        // 버튼 그리기
        if (playButton.mouseOver())
        {
            playButton.draw(ColorF{ 0.7, 0.8, 1.0 });
        }
        else
        {
            playButton.draw(ColorF{ 0.5, 0.6, 0.8 });
        }

        playButton.drawFrame(2, ColorF{ 0.2, 0.3, 0.5 });
        
        FontAsset(U"Regular")(U"효과음 재생").drawAt(
            playButton.center(), ColorF{ 0.1 });

        // 버튼 클릭 시 사운드 재생
        if (playButton.leftClicked())
        {
            clickSound.play();
        }

        // 현재 재생 중인지 표시
        if (clickSound.isPlaying())
        {
            Circle{ playButton.center().movedBy(0, 50), 10 }
                .draw(ColorF{ 1.0, 0.3, 0.3 });
        }
    }
}
```

이 코드에서 `Audio` 객체를 생성할 때 파일 경로를 전달한다. Siv3D에서는 문자열 리터럴 앞에 `U`를 붙여 UTF-32 문자열을 나타낸다. `play()` 메서드를 호출하면 사운드가 재생되며, 이미 재생 중이면 처음부터 다시 시작한다. `isPlaying()` 메서드는 현재 재생 중인지 확인한다.

### 22.2.2 사운드 재생 제어

사운드를 더 세밀하게 제어할 수 있다. 일시 정지, 재개, 정지 등의 기능을 사용하는 예제를 살펴본다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });

    // 긴 효과음 또는 짧은 음악 로드
    const Audio audio{ U"example/sound/sound.mp3" };

    if (not audio)
    {
        throw Error{ U"Failed to load audio file" };
    }

    // 버튼들 정의
    const Rect playButton{ 250, 200, 120, 50 };
    const Rect pauseButton{ 380, 200, 120, 50 };
    const Rect stopButton{ 510, 200, 120, 50 };

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    while (System::Update())
    {
        // 재생 버튼
        if (playButton.mouseOver())
        {
            playButton.draw(ColorF{ 0.6, 0.8, 0.6 });
        }
        else
        {
            playButton.draw(ColorF{ 0.4, 0.6, 0.4 });
        }
        playButton.drawFrame(2, ColorF{ 0.2 });
        font(U"▶").drawAt(30, playButton.center(), ColorF{ 0.1 });

        if (playButton.leftClicked())
        {
            // 일시정지 상태면 재개, 아니면 처음부터 재생
            if (audio.isPaused())
            {
                audio.play();
            }
            else
            {
                audio.play();
            }
        }

        // 일시정지 버튼
        if (pauseButton.mouseOver())
        {
            pauseButton.draw(ColorF{ 0.8, 0.8, 0.6 });
        }
        else
        {
            pauseButton.draw(ColorF{ 0.6, 0.6, 0.4 });
        }
        pauseButton.drawFrame(2, ColorF{ 0.2 });
        font(U"‖").drawAt(30, pauseButton.center(), ColorF{ 0.1 });

        if (pauseButton.leftClicked())
        {
            audio.pause();
        }

        // 정지 버튼
        if (stopButton.mouseOver())
        {
            stopButton.draw(ColorF{ 0.8, 0.6, 0.6 });
        }
        else
        {
            stopButton.draw(ColorF{ 0.6, 0.4, 0.4 });
        }
        stopButton.drawFrame(2, ColorF{ 0.2 });
        font(U"■").drawAt(30, stopButton.center(), ColorF{ 0.1 });

        if (stopButton.leftClicked())
        {
            audio.stop();
        }

        // 재생 상태 표시
        String status = U"정지";
        if (audio.isPlaying())
        {
            status = U"재생 중";
        }
        else if (audio.isPaused())
        {
            status = U"일시정지";
        }

        font(status).drawAt(20, Vec2{ 400, 300 }, ColorF{ 0.2 });

        // 재생 위치 표시 (초 단위)
        const double currentTime = audio.posSec();
        const double totalTime = audio.lengthSec();
        
        font(U"{:.1f} / {:.1f} 초"_fmt(currentTime, totalTime))
            .drawAt(18, Vec2{ 400, 340 }, ColorF{ 0.4 });
    }
}
```

이 예제에서는 세 개의 버튼으로 재생, 일시정지, 정지 기능을 구현했다. `pause()` 메서드는 현재 위치에서 재생을 일시정지하고, 다시 `play()`를 호출하면 일시정지한 위치부터 재생을 재개한다. `stop()` 메서드는 재생을 중단하고 재생 위치를 처음으로 되돌린다.

`posSec()` 메서드는 현재 재생 위치를 초 단위로 반환하고, `lengthSec()` 메서드는 전체 길이를 초 단위로 반환한다. 이를 활용하면 진행 상황을 사용자에게 보여줄 수 있다.

## 22.3 배경 음악 관리

게임이나 애플리케이션에서 배경 음악은 분위기를 조성하는 중요한 역할을 한다. 배경 음악은 보통 반복 재생되며, 장면 전환 시 부드럽게 페이드 인/아웃 효과를 적용하는 것이 좋다.

### 22.3.1 반복 재생과 페이드 효과

배경 음악을 무한 반복하며 페이드 효과를 적용하는 예제다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.2, 0.3, 0.4 });

    // 배경 음악 로드
    const Audio bgm{ Audio::Stream, U"example/sound/music.mp3" };

    if (not bgm)
    {
        throw Error{ U"Failed to load BGM" };
    }

    // 무한 반복 설정
    bgm.setLoop(true);

    // 초기 볼륨을 0으로 설정
    bgm.setVolume(0.0);

    // 배경 음악 시작
    bgm.play();

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };
    
    // 페이드 인/아웃 제어
    bool isFadingIn = true;
    double targetVolume = 0.5;  // 목표 볼륨
    double fadeSpeed = 0.3;      // 페이드 속도 (초당 볼륨 변화량)

    const Rect fadeInButton{ 250, 250, 150, 60 };
    const Rect fadeOutButton{ 450, 250, 150, 60 };

    while (System::Update())
    {
        // 현재 볼륨 가져오기
        double currentVolume = bgm.getVolume();

        // 페이드 인 처리
        if (isFadingIn && currentVolume < targetVolume)
        {
            currentVolume = Min(currentVolume + fadeSpeed * Scene::DeltaTime(), 
                              targetVolume);
            bgm.setVolume(currentVolume);
        }
        // 페이드 아웃 처리
        else if (not isFadingIn && currentVolume > 0.0)
        {
            currentVolume = Max(currentVolume - fadeSpeed * Scene::DeltaTime(), 
                              0.0);
            bgm.setVolume(currentVolume);
        }

        // Fade In 버튼
        if (fadeInButton.mouseOver())
        {
            fadeInButton.draw(ColorF{ 0.4, 0.6, 0.8 });
        }
        else
        {
            fadeInButton.draw(ColorF{ 0.3, 0.5, 0.7 });
        }
        fadeInButton.drawFrame(2, ColorF{ 0.9 });
        font(U"Fade In").drawAt(20, fadeInButton.center(), ColorF{ 0.9 });

        if (fadeInButton.leftClicked())
        {
            isFadingIn = true;
        }

        // Fade Out 버튼
        if (fadeOutButton.mouseOver())
        {
            fadeOutButton.draw(ColorF{ 0.8, 0.4, 0.4 });
        }
        else
        {
            fadeOutButton.draw(ColorF{ 0.7, 0.3, 0.3 });
        }
        fadeOutButton.drawFrame(2, ColorF{ 0.9 });
        font(U"Fade Out").drawAt(20, fadeOutButton.center(), ColorF{ 0.9 });

        if (fadeOutButton.leftClicked())
        {
            isFadingIn = false;
        }

        // 현재 볼륨 표시
        const double barWidth = 400.0;
        const Rect volumeBar{ 200, 350, static_cast<int32>(barWidth), 30 };
        volumeBar.draw(ColorF{ 0.3 });
        
        Rect{ volumeBar.pos, 
              static_cast<int32>(barWidth * currentVolume), 
              volumeBar.h }
            .draw(ColorF{ 0.3, 0.8, 0.3 });
        
        volumeBar.drawFrame(2, ColorF{ 0.9 });

        font(U"볼륨: {:.0f}%"_fmt(currentVolume * 100))
            .drawAt(20, Vec2{ 400, 400 }, ColorF{ 0.9 });
    }
}
```

이 예제에서는 `Audio::Stream`을 생성자에 전달하여 스트리밍 방식으로 오디오를 로드했다. 이는 큰 음악 파일의 메모리 사용량을 줄여준다. `setLoop(true)`를 호출하면 음악이 끝나면 자동으로 처음부터 다시 재생된다.

페이드 효과는 매 프레임마다 볼륨을 조금씩 증가시키거나 감소시켜 구현한다. `Scene::DeltaTime()`은 이전 프레임과 현재 프레임 사이의 경과 시간(초)을 반환하므로, 이를 곱하면 프레임률과 무관하게 일정한 속도로 페이드 효과를 적용할 수 있다.

### 22.3.2 여러 배경 음악 관리

게임에서는 상황에 따라 다른 배경 음악을 재생해야 할 때가 많다. 메뉴 화면, 게임 플레이, 보스전 등 각 상황에 맞는 음악을 부드럽게 전환하는 방법을 살펴본다.

```cpp
#include <Siv3D.hpp>

// 배경 음악 관리 클래스
class BGMManager
{
private:
    std::unordered_map<String, Audio> bgmMap;
    String currentBGM;
    String nextBGM;
    
    double fadeOutSpeed = 1.0;
    double fadeInSpeed = 1.0;
    double targetVolume = 0.5;
    
    bool isTransitioning = false;

public:
    // 배경 음악 등록
    void registerBGM(const String& name, const FilePath& path)
    {
        Audio audio{ Audio::Stream, path };
        if (audio)
        {
            audio.setLoop(true);
            audio.setVolume(0.0);
            bgmMap[name] = std::move(audio);
        }
    }

    // 배경 음악 전환 시작
    void transitionTo(const String& name, double fadeOutSec = 1.0, 
                     double fadeInSec = 1.0)
    {
        if (not bgmMap.contains(name))
        {
            return;
        }

        nextBGM = name;
        fadeOutSpeed = targetVolume / fadeOutSec;
        fadeInSpeed = targetVolume / fadeInSec;
        isTransitioning = true;
    }

    // 즉시 재생 (페이드 없이)
    void play(const String& name, double volume = 0.5)
    {
        if (not bgmMap.contains(name))
        {
            return;
        }

        stopAll();
        currentBGM = name;
        targetVolume = volume;
        bgmMap[currentBGM].setVolume(volume);
        bgmMap[currentBGM].play();
        isTransitioning = false;
    }

    // 모든 배경 음악 정지
    void stopAll()
    {
        for (auto& [name, audio] : bgmMap)
        {
            audio.stop();
            audio.setVolume(0.0);
        }
        currentBGM.clear();
    }

    // 매 프레임 업데이트
    void update()
    {
        if (not isTransitioning)
        {
            return;
        }

        // 현재 BGM 페이드 아웃
        if (not currentBGM.isEmpty() && bgmMap.contains(currentBGM))
        {
            Audio& current = bgmMap[currentBGM];
            double volume = current.getVolume();
            
            if (volume > 0.0)
            {
                volume = Max(volume - fadeOutSpeed * Scene::DeltaTime(), 0.0);
                current.setVolume(volume);
                return;  // 페이드 아웃이 끝날 때까지 대기
            }
            else
            {
                current.stop();
            }
        }

        // 다음 BGM 페이드 인
        if (not nextBGM.isEmpty() && bgmMap.contains(nextBGM))
        {
            Audio& next = bgmMap[nextBGM];
            
            if (not next.isPlaying())
            {
                next.setVolume(0.0);
                next.play();
                currentBGM = nextBGM;
            }

            double volume = next.getVolume();
            if (volume < targetVolume)
            {
                volume = Min(volume + fadeInSpeed * Scene::DeltaTime(), 
                           targetVolume);
                next.setVolume(volume);
            }
            else
            {
                isTransitioning = false;
                nextBGM.clear();
            }
        }
    }

    // 현재 재생 중인 BGM 이름
    String getCurrentBGM() const
    {
        return currentBGM;
    }

    // 전환 중인지 확인
    bool isInTransition() const
    {
        return isTransitioning;
    }

    // 현재 볼륨 가져오기
    double getCurrentVolume() const
    {
        if (currentBGM.isEmpty() || not bgmMap.contains(currentBGM))
        {
            return 0.0;
        }
        return bgmMap.at(currentBGM).getVolume();
    }
};

void Main()
{
    Scene::SetBackground(ColorF{ 0.2, 0.3, 0.4 });

    BGMManager bgmManager;
    
    // 여러 배경 음악 등록
    bgmManager.registerBGM(U"Menu", U"example/sound/music.mp3");
    bgmManager.registerBGM(U"Game", U"example/sound/music.mp3");  
    bgmManager.registerBGM(U"Boss", U"example/sound/music.mp3");
    
    // 메뉴 음악으로 시작
    bgmManager.play(U"Menu", 0.4);

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };
    
    const Rect menuButton{ 200, 200, 140, 50 };
    const Rect gameButton{ 200, 270, 140, 50 };
    const Rect bossButton{ 200, 340, 140, 50 };

    while (System::Update())
    {
        // BGM 관리자 업데이트
        bgmManager.update();

        // 메뉴 버튼
        if (menuButton.mouseOver())
        {
            menuButton.draw(ColorF{ 0.4, 0.5, 0.7 });
        }
        else
        {
            menuButton.draw(ColorF{ 0.3, 0.4, 0.6 });
        }
        menuButton.drawFrame(2, ColorF{ 0.9 });
        font(U"메뉴").drawAt(20, menuButton.center(), ColorF{ 0.9 });

        if (menuButton.leftClicked())
        {
            bgmManager.transitionTo(U"Menu", 1.5, 2.0);
        }

        // 게임 버튼
        if (gameButton.mouseOver())
        {
            gameButton.draw(ColorF{ 0.4, 0.7, 0.4 });
        }
        else
        {
            gameButton.draw(ColorF{ 0.3, 0.6, 0.3 });
        }
        gameButton.drawFrame(2, ColorF{ 0.9 });
        font(U"게임").drawAt(20, gameButton.center(), ColorF{ 0.9 });

        if (gameButton.leftClicked())
        {
            bgmManager.transitionTo(U"Game", 1.0, 1.0);
        }

        // 보스 버튼
        if (bossButton.mouseOver())
        {
            bossButton.draw(ColorF{ 0.8, 0.3, 0.3 });
        }
        else
        {
            bossButton.draw(ColorF{ 0.7, 0.2, 0.2 });
        }
        bossButton.drawFrame(2, ColorF{ 0.9 });
        font(U"보스").drawAt(20, bossButton.center(), ColorF{ 0.9 });

        if (bossButton.leftClicked())
        {
            bgmManager.transitionTo(U"Boss", 0.5, 0.5);
        }

        // 현재 상태 표시
        font(U"현재: {}"_fmt(bgmManager.getCurrentBGM()))
            .draw(20, Vec2{ 380, 220 }, ColorF{ 0.9 });

        if (bgmManager.isInTransition())
        {
            font(U"전환 중...").draw(18, Vec2{ 380, 250 }, 
                                    ColorF{ 1.0, 0.8, 0.3 });
        }

        // 볼륨 표시
        const double volume = bgmManager.getCurrentVolume();
        font(U"볼륨: {:.0f}%"_fmt(volume * 100))
            .draw(18, Vec2{ 380, 280 }, ColorF{ 0.7 });
    }
}
```

`BGMManager` 클래스는 여러 배경 음악을 관리하고 부드럽게 전환하는 기능을 제공한다. `std::unordered_map`을 사용하여 이름으로 오디오 객체를 관리하며, 현재 재생 중인 음악과 다음에 재생할 음악을 추적한다.

`transitionTo()` 메서드는 두 단계로 전환을 수행한다. 먼저 현재 음악을 페이드 아웃하고, 완전히 사라지면 다음 음악을 페이드 인한다. 각 단계의 속도를 개별적으로 조절할 수 있어 상황에 맞는 자연스러운 전환이 가능하다.

## 22.4 효과음 처리

효과음은 사용자의 행동에 즉각적인 피드백을 제공하여 상호작용을 더욱 생생하게 만든다. 효과음은 배경 음악과 달리 짧고 동시에 여러 개가 재생될 수 있어야 한다.

### 22.4.1 효과음 풀(Pool) 시스템

같은 효과음을 빠르게 연속으로 재생해야 할 때가 있다. 예를 들어 총알이 여러 발 발사되거나, 여러 적이 동시에 피격당하는 경우다. 이런 상황을 위해 효과음 풀 시스템을 구현한다.

```cpp
#include <Siv3D.hpp>

// 효과음 풀 클래스
class SoundEffectPool
{
private:
    Array<Audio> audioPool;
    size_t currentIndex = 0;
    String soundPath;

public:
    // 생성자: 지정된 개수만큼 같은 사운드를 미리 로드
    SoundEffectPool(const FilePath& path, size_t poolSize = 5)
        : soundPath(path)
    {
        for (size_t i = 0; i < poolSize; ++i)
        {
            Audio audio{ path };
            if (audio)
            {
                audioPool.push_back(std::move(audio));
            }
        }
    }

    // 효과음 재생
    void play(double volume = 1.0)
    {
        if (audioPool.isEmpty())
        {
            return;
        }

        // 현재 인덱스의 오디오 재생
        audioPool[currentIndex].stop();  // 이전 재생 중단
        audioPool[currentIndex].setVolume(volume);
        audioPool[currentIndex].play();

        // 다음 인덱스로 이동 (순환)
        currentIndex = (currentIndex + 1) % audioPool.size();
    }

    // 모든 인스턴스 정지
    void stopAll()
    {
        for (auto& audio : audioPool)
        {
            audio.stop();
        }
    }

    // 풀 크기 확인
    size_t size() const
    {
        return audioPool.size();
    }
};

void Main()
{
    Scene::SetBackground(ColorF{ 0.1, 0.1, 0.2 });

    // 효과음 풀 생성 (동시에 최대 8개까지 재생 가능)
    SoundEffectPool shootSound{ U"example/sound/button.mp3", 8 };
    SoundEffectPool hitSound{ U"example/sound/button.mp3", 5 };

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // 파티클 효과를 위한 구조체
    struct Particle
    {
        Vec2 pos;
        Vec2 velocity;
        double life;
        ColorF color;
    };

    Array<Particle> particles;

    while (System::Update())
    {
        // 마우스 왼쪽 클릭으로 총알 발사 효과
        if (MouseL.pressed())
        {
            shootSound.play(0.3);
            
            // 파티클 생성
            for (int32 i = 0; i < 3; ++i)
            {
                Particle p;
                p.pos = Cursor::Pos();
                p.velocity = RandomVec2(Circle{ 0, 0, 150 });
                p.life = 1.0;
                p.color = ColorF{ 1.0, 0.8, 0.2 };
                particles.push_back(p);
            }
        }

        // 마우스 오른쪽 클릭으로 적중 효과
        if (MouseR.down())
        {
            hitSound.play(0.5);
            
            // 적중 파티클
            for (int32 i = 0; i < 10; ++i)
            {
                Particle p;
                p.pos = Cursor::Pos();
                p.velocity = RandomVec2(Circle{ 0, 0, 200 });
                p.life = 1.5;
                p.color = ColorF{ 1.0, 0.2, 0.2 };
                particles.push_back(p);
            }
        }

        // 파티클 업데이트 및 그리기
        for (auto& p : particles)
        {
            p.pos += p.velocity * Scene::DeltaTime();
            p.velocity *= 0.95;  // 감속
            p.life -= Scene::DeltaTime();

            if (p.life > 0)
            {
                Circle{ p.pos, 5 }.draw(
                    ColorF{ p.color, p.life / 1.5 });
            }
        }

        // 수명이 다한 파티클 제거
        particles.remove_if([](const Particle& p) { return p.life <= 0; });

        // 안내 문구
        font(U"좌클릭: 발사").draw(20, Vec2{ 20, 20 }, ColorF{ 0.8 });
        font(U"우클릭: 적중").draw(20, Vec2{ 20, 50 }, ColorF{ 0.8 });
        font(U"활성 파티클: {}"_fmt(particles.size()))
            .draw(18, Vec2{ 20, 90 }, ColorF{ 0.6 });
    }
}
```

`SoundEffectPool` 클래스는 같은 오디오 파일을 여러 개 미리 로드하여 배열에 저장한다. 재생 요청이 오면 현재 인덱스의 오디오를 재생하고 다음 인덱스로 이동한다. 이렇게 하면 이전 효과음이 끝나지 않았어도 새로운 효과음을 재생할 수 있다.

풀의 크기는 동시에 재생될 수 있는 최대 개수를 결정한다. 크기가 클수록 더 많은 메모리를 사용하지만 빠른 연속 재생에 유리하다. 일반적으로 5~10개 정도면 충분하다.

### 22.4.2 효과음 관리자

프로젝트가 커지면 효과음도 많아진다. 이를 체계적으로 관리하기 위한 효과음 관리자를 구현한다.

```cpp
#include <Siv3D.hpp>

// 효과음 관리자 클래스
class SoundEffectManager
{
private:
    struct SoundEffect
    {
        Array<Audio> pool;
        size_t currentIndex = 0;
        double defaultVolume = 1.0;
    };

    std::unordered_map<String, SoundEffect> effects;
    double masterVolume = 1.0;

public:
    // 효과음 등록
    void registerEffect(const String& name, const FilePath& path,
                       size_t poolSize = 3, double defaultVolume = 1.0)
    {
        SoundEffect effect;
        effect.defaultVolume = defaultVolume;

        for (size_t i = 0; i < poolSize; ++i)
        {
            Audio audio{ path };
            if (audio)
            {
                effect.pool.push_back(std::move(audio));
            }
        }

        if (not effect.pool.isEmpty())
        {
            effects[name] = std::move(effect);
        }
    }

    // 효과음 재생
    void play(const String& name, double volumeMultiplier = 1.0)
    {
        if (not effects.contains(name))
        {
            return;
        }

        auto& effect = effects[name];
        if (effect.pool.isEmpty())
        {
            return;
        }

        Audio& audio = effect.pool[effect.currentIndex];
        audio.stop();
        audio.setVolume(effect.defaultVolume * volumeMultiplier * masterVolume);
        audio.play();

        effect.currentIndex = (effect.currentIndex + 1) % effect.pool.size();
    }

    // 마스터 볼륨 설정 (모든 효과음에 영향)
    void setMasterVolume(double volume)
    {
        masterVolume = Clamp(volume, 0.0, 1.0);
    }

    // 마스터 볼륨 가져오기
    double getMasterVolume() const
    {
        return masterVolume;
    }

    // 특정 효과음의 기본 볼륨 설정
    void setEffectVolume(const String& name, double volume)
    {
        if (effects.contains(name))
        {
            effects[name].defaultVolume = Clamp(volume, 0.0, 1.0);
        }
    }

    // 모든 효과음 정지
    void stopAll()
    {
        for (auto& [name, effect] : effects)
        {
            for (auto& audio : effect.pool)
            {
                audio.stop();
            }
        }
    }
};

void Main()
{
    Scene::SetBackground(ColorF{ 0.15, 0.2, 0.25 });

    SoundEffectManager sfxManager;

    // 다양한 효과음 등록
    sfxManager.registerEffect(U"Click", U"example/sound/button.mp3", 3, 0.4);
    sfxManager.registerEffect(U"Hover", U"example/sound/button.mp3", 2, 0.2);
    sfxManager.registerEffect(U"Success", U"example/sound/button.mp3", 2, 0.6);
    sfxManager.registerEffect(U"Error", U"example/sound/button.mp3", 2, 0.5);

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // 버튼들
    const Rect clickButton{ 100, 150, 180, 60 };
    const Rect hoverButton{ 300, 150, 180, 60 };
    const Rect successButton{ 500, 150, 180, 60 };
    const Rect errorButton{ 300, 250, 180, 60 };

    // 볼륨 슬라이더
    const Rect volumeSlider{ 150, 350, 500, 20 };
    bool isDraggingSlider = false;
    double sliderValue = sfxManager.getMasterVolume();

    while (System::Update())
    {
        // 클릭 버튼
        const bool clickHover = clickButton.mouseOver();
        clickButton.draw(clickHover ? ColorF{ 0.5, 0.6, 0.8 } 
                                   : ColorF{ 0.3, 0.4, 0.6 });
        clickButton.drawFrame(2, ColorF{ 0.9 });
        font(U"클릭").drawAt(20, clickButton.center(), ColorF{ 0.9 });

        if (clickButton.leftClicked())
        {
            sfxManager.play(U"Click");
        }

        // 호버 버튼
        const bool hoverHover = hoverButton.mouseOver();
        hoverButton.draw(hoverHover ? ColorF{ 0.6, 0.8, 0.5 } 
                                   : ColorF{ 0.4, 0.6, 0.3 });
        hoverButton.drawFrame(2, ColorF{ 0.9 });
        font(U"호버").drawAt(20, hoverButton.center(), ColorF{ 0.9 });

        if (hoverButton.leftClicked())
        {
            sfxManager.play(U"Hover");
        }

        // 성공 버튼
        const bool successHover = successButton.mouseOver();
        successButton.draw(successHover ? ColorF{ 0.3, 0.8, 0.8 } 
                                       : ColorF{ 0.2, 0.6, 0.6 });
        successButton.drawFrame(2, ColorF{ 0.9 });
        font(U"성공").drawAt(20, successButton.center(), ColorF{ 0.9 });

        if (successButton.leftClicked())
        {
            sfxManager.play(U"Success");
        }

        // 에러 버튼
        const bool errorHover = errorButton.mouseOver();
        errorButton.draw(errorHover ? ColorF{ 0.9, 0.4, 0.4 } 
                                   : ColorF{ 0.7, 0.2, 0.2 });
        errorButton.drawFrame(2, ColorF{ 0.9 });
        font(U"에러").drawAt(20, errorButton.center(), ColorF{ 0.9 });

        if (errorButton.leftClicked())
        {
            sfxManager.play(U"Error");
        }

        // 볼륨 슬라이더
        volumeSlider.draw(ColorF{ 0.3 });
        
        // 슬라이더 핸들 위치 계산
        const double handleX = volumeSlider.x + 
                              volumeSlider.w * sliderValue;
        const Circle handle{ handleX, volumeSlider.y + volumeSlider.h / 2.0, 15 };

        // 슬라이더 드래그 처리
        if (handle.leftPressed() || 
            (isDraggingSlider && MouseL.pressed()))
        {
            isDraggingSlider = true;
            sliderValue = Clamp(
                (Cursor::Pos().x - volumeSlider.x) / volumeSlider.w,
                0.0, 1.0);
            sfxManager.setMasterVolume(sliderValue);
        }
        else if (MouseL.up())
        {
            isDraggingSlider = false;
        }

        // 슬라이더 채워진 부분
        Rect{ volumeSlider.pos, 
              static_cast<int32>(volumeSlider.w * sliderValue), 
              volumeSlider.h }
            .draw(ColorF{ 0.4, 0.7, 0.4 });

        // 슬라이더 테두리와 핸들
        volumeSlider.drawFrame(2, ColorF{ 0.7 });
        handle.draw(ColorF{ 0.9 });
        handle.drawFrame(2, ColorF{ 0.3 });

        // 볼륨 표시
        font(U"마스터 볼륨: {:.0f}%"_fmt(sliderValue * 100))
            .drawAt(20, Vec2{ 400, 400 }, ColorF{ 0.9 });
    }
}
```

`SoundEffectManager` 클래스는 여러 효과음을 중앙에서 관리한다. 각 효과음은 자체 풀과 기본 볼륨을 가지며, 마스터 볼륨으로 모든 효과음의 볼륨을 한 번에 조절할 수 있다.

`play()` 메서드에 `volumeMultiplier` 매개변수를 전달하면 특정 상황에서 효과음의 볼륨을 임시로 조절할 수 있다. 예를 들어 크리티컬 히트 시 일반 히트 사운드를 더 크게 재생하는 식이다.

## 22.5 볼륨 조절과 사운드 이펙트

오디오의 볼륨을 조절하고 다양한 이펙트를 적용하여 게임의 몰입감을 높일 수 있다. Siv3D는 몇 가지 유용한 오디오 조작 기능을 제공한다.

### 22.5.1 동적 볼륨 조절

게임 상황에 따라 볼륨을 동적으로 조절하는 예제다. 플레이어가 위험한 상황에 처하면 배경 음악 볼륨을 낮추고 긴장감 있는 효과음을 강조하는 방식이다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.2, 0.25, 0.3 });

    // 배경 음악과 효과음
    const Audio bgm{ Audio::Stream, U"example/sound/music.mp3" };
    const Audio alarmSound{ U"example/sound/button.mp3" };

    bgm.setLoop(true);
    bgm.setVolume(0.5);
    bgm.play();

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // 게임 상태 시뮬레이션
    double dangerLevel = 0.0;  // 0.0 (안전) ~ 1.0 (위험)
    const double dangerIncreaseRate = 0.15;
    const double dangerDecreaseRate = 0.1;

    // 알람 타이머
    double alarmTimer = 0.0;
    const double alarmInterval = 1.0;  // 1초마다 알람

    const Rect increaseButton{ 250, 250, 150, 60 };
    const Rect decreaseButton{ 450, 250, 150, 60 };

    while (System::Update())
    {
        // 위험도 증가 버튼
        if (increaseButton.mouseOver())
        {
            increaseButton.draw(ColorF{ 0.9, 0.5, 0.5 });
        }
        else
        {
            increaseButton.draw(ColorF{ 0.7, 0.3, 0.3 });
        }
        increaseButton.drawFrame(2, ColorF{ 0.9 });
        font(U"위험 증가").drawAt(18, increaseButton.center(), ColorF{ 0.9 });

        if (increaseButton.leftPressed())
        {
            dangerLevel = Min(dangerLevel + 
                             dangerIncreaseRate * Scene::DeltaTime(), 1.0);
        }

        // 위험도 감소 버튼
        if (decreaseButton.mouseOver())
        {
            decreaseButton.draw(ColorF{ 0.5, 0.8, 0.5 });
        }
        else
        {
            decreaseButton.draw(ColorF{ 0.3, 0.6, 0.3 });
        }
        decreaseButton.drawFrame(2, ColorF{ 0.9 });
        font(U"위험 감소").drawAt(18, decreaseButton.center(), ColorF{ 0.9 });

        if (decreaseButton.leftPressed())
        {
            dangerLevel = Max(dangerLevel - 
                             dangerDecreaseRate * Scene::DeltaTime(), 0.0);
        }

        // 자연 감소
        if (not increaseButton.leftPressed() && 
            not decreaseButton.leftPressed())
        {
            dangerLevel = Max(dangerLevel - 
                             0.05 * Scene::DeltaTime(), 0.0);
        }

        // BGM 볼륨을 위험도에 반비례하게 조절
        const double bgmVolume = 0.5 * (1.0 - dangerLevel * 0.7);
        bgm.setVolume(bgmVolume);

        // 위험도가 높으면 알람 재생
        if (dangerLevel > 0.5)
        {
            alarmTimer += Scene::DeltaTime();
            
            if (alarmTimer >= alarmInterval)
            {
                // 위험도에 비례하여 알람 볼륨 증가
                const double alarmVolume = 0.3 + dangerLevel * 0.5;
                alarmSound.stop();
                alarmSound.setVolume(alarmVolume);
                alarmSound.play();
                
                alarmTimer = 0.0;
            }
        }
        else
        {
            alarmTimer = 0.0;
        }

        // 위험도 시각화
        const Rect dangerBar{ 200, 150, 400, 40 };
        dangerBar.draw(ColorF{ 0.2 });
        
        Rect{ dangerBar.pos, 
              static_cast<int32>(dangerBar.w * dangerLevel), 
              dangerBar.h }
            .draw(ColorF{ 1.0 - dangerLevel, dangerLevel, 0.2 });
        
        dangerBar.drawFrame(3, ColorF{ 0.9 });

        // 정보 표시
        font(U"위험도: {:.0f}%"_fmt(dangerLevel * 100))
            .drawAt(22, Vec2{ 400, 350 }, ColorF{ 0.9 });
        
        font(U"BGM 볼륨: {:.0f}%"_fmt(bgmVolume * 100))
            .draw(18, Vec2{ 250, 390 }, ColorF{ 0.7 });

        // 위험 경고
        if (dangerLevel > 0.7)
        {
            const double pulse = 0.5 + 0.5 * Math::Sin(Scene::Time() * 4.0);
            font(U"⚠ 위험!").drawAt(24, Vec2{ 400, 430 }, 
                                    ColorF{ 1.0, 0.3, 0.3, pulse });
        }
    }
}
```

이 예제는 게임의 위험 상황을 시뮬레이션한다. 위험도가 증가하면 배경 음악의 볼륨이 자동으로 감소하고, 일정 수준을 넘으면 경고음이 재생된다. 이런 방식으로 오디오를 통해 게임 상태를 직관적으로 전달할 수 있다.

### 22.5.2 3D 사운드와 패닝

Siv3D는 스테레오 패닝을 지원하여 소리의 방향성을 표현할 수 있다. 왼쪽에서 오른쪽으로 이동하는 객체의 소리를 구현하는 예제다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.1, 0.15, 0.2 });

    const Audio moveSound{ U"example/sound/button.mp3" };
    moveSound.setLoop(true);

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // 이동하는 객체
    Vec2 objectPos{ 100, 300 };
    Vec2 objectVelocity{ 200, 0 };

    // 리스너(플레이어) 위치
    const Vec2 listenerPos{ 400, 300 };

    bool isSoundPlaying = false;

    while (System::Update())
    {
        // 객체 이동
        objectPos += objectVelocity * Scene::DeltaTime();

        // 화면 경계에서 반사
        if (objectPos.x < 50 || objectPos.x > Scene::Width() - 50)
        {
            objectVelocity.x *= -1;
            objectPos.x = Clamp(objectPos.x, 50.0, 
                               static_cast<double>(Scene::Width() - 50));
        }

        // 리스너로부터의 거리 계산
        const double distance = objectPos.distanceFrom(listenerPos);
        const double maxDistance = 400.0;

        // 거리 기반 볼륨 계산 (역제곱 법칙 근사)
        const double volumeByDistance = 
            Clamp(1.0 - (distance / maxDistance), 0.0, 1.0);

        // 좌우 패닝 계산 (-1.0: 왼쪽, 0.0: 중앙, 1.0: 오른쪽)
        const double pan = Clamp(
            (objectPos.x - listenerPos.x) / 300.0, -1.0, 1.0);

        // 사운드가 재생 중이 아니면 시작
        if (not isSoundPlaying)
        {
            moveSound.play();
            isSoundPlaying = true;
        }

        // 볼륨과 패닝 적용
        moveSound.setVolume(volumeByDistance * 0.6);
        moveSound.setPan(pan);

        // 시각화
        // 리스너 그리기
        Circle{ listenerPos, 30 }.draw(ColorF{ 0.3, 0.6, 0.8 });
        Circle{ listenerPos, 30 }.drawFrame(3, ColorF{ 0.5, 0.8, 1.0 });
        font(U"👂").drawAt(24, listenerPos, ColorF{ 0.9 });

        // 최대 청취 범위
        Circle{ listenerPos, maxDistance }
            .drawFrame(2, ColorF{ 0.3, 0.3, 0.3 });

        // 이동하는 객체
        const double objectSize = 20 + volumeByDistance * 20;
        Circle{ objectPos, objectSize }.draw(ColorF{ 1.0, 0.5, 0.3 });
        Circle{ objectPos, objectSize }.drawFrame(2, ColorF{ 1.0, 0.7, 0.5 });

        // 연결선
        Line{ listenerPos, objectPos }.draw(2, 
            ColorF{ 0.5, 0.5, 0.5, 0.3 });

        // 정보 표시
        font(U"3D 사운드 데모").draw(24, Vec2{ 20, 20 }, ColorF{ 0.9 });
        font(U"거리: {:.0f}"_fmt(distance))
            .draw(18, Vec2{ 20, 60 }, ColorF{ 0.7 });
        font(U"볼륨: {:.0f}%"_fmt(volumeByDistance * 100))
            .draw(18, Vec2{ 20, 85 }, ColorF{ 0.7 });
        font(U"패닝: {:.2f}"_fmt(pan))
            .draw(18, Vec2{ 20, 110 }, ColorF{ 0.7 });

        // 패닝 시각화 (스테레오 미터)
        const Rect leftMeter{ 20, 140, 80, 20 };
        const Rect rightMeter{ 110, 140, 80, 20 };

        leftMeter.draw(ColorF{ 0.3 });
        rightMeter.draw(ColorF{ 0.3 });

        const double leftVolume = volumeByDistance * Max(1.0 - pan, 0.0);
        const double rightVolume = volumeByDistance * Max(1.0 + pan, 0.0);

        Rect{ leftMeter.pos, static_cast<int32>(leftMeter.w * leftVolume), 
              leftMeter.h }
            .draw(ColorF{ 0.3, 0.8, 0.3 });
        
        Rect{ rightMeter.pos, static_cast<int32>(rightMeter.w * rightVolume), 
              rightMeter.h }
            .draw(ColorF{ 0.3, 0.8, 0.3 });

        leftMeter.drawFrame(2, ColorF{ 0.7 });
        rightMeter.drawFrame(2, ColorF{ 0.7 });

        font(U"L").draw(16, leftMeter.pos.movedBy(-18, 2), ColorF{ 0.7 });
        font(U"R").draw(16, rightMeter.pos.movedBy(-18, 2), ColorF{ 0.7 });
    }
}
```

`setPan()` 메서드는 -1.0(완전히 왼쪽)에서 1.0(완전히 오른쪽) 사이의 값을 받는다. 0.0은 중앙을 의미한다. 이를 객체의 위치에 따라 동적으로 조절하면 소리가 어디서 나는지 직관적으로 알 수 있다.

거리에 따른 볼륨 감쇠도 함께 적용하면 더욱 현실적인 사운드를 구현할 수 있다. 실제 게임에서는 장애물이나 환경에 따라 소리가 감쇠하는 정도를 다르게 적용할 수도 있다.

### 22.5.3 재생 속도 조절

Siv3D는 오디오의 재생 속도를 조절할 수 있다. 속도를 변경하면 피치(음높이)도 함께 변한다. 이를 활용하여 특수 효과를 만들 수 있다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.15, 0.2, 0.25 });

    const Audio voice{ U"example/sound/button.mp3" };

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    double playbackSpeed = 1.0;  // 기본 속도
    const Rect speedSlider{ 200, 250, 400, 20 };
    bool isDragging = false;

    const Rect playButton{ 320, 320, 160, 60 };

    // 프리셋 버튼들
    const Rect slowButton{ 200, 400, 100, 50 };
    const Rect normalButton{ 320, 400, 100, 50 };
    const Rect fastButton{ 440, 400, 100, 50 };
    const Rect veryFastButton{ 560, 400, 100, 50 };

    while (System::Update())
    {
        // 재생 버튼
        if (playButton.mouseOver())
        {
            playButton.draw(ColorF{ 0.5, 0.7, 0.9 });
        }
        else
        {
            playButton.draw(ColorF{ 0.3, 0.5, 0.7 });
        }
        playButton.drawFrame(2, ColorF{ 0.9 });
        font(U"재생").drawAt(22, playButton.center(), ColorF{ 0.9 });

        if (playButton.leftClicked())
        {
            voice.stop();
            voice.setSpeed(playbackSpeed);
            voice.play();
        }

        // 속도 슬라이더
        speedSlider.draw(ColorF{ 0.3 });

        // 슬라이더 값 범위: 0.5 ~ 2.0
        const double minSpeed = 0.5;
        const double maxSpeed = 2.0;
        const double normalizedSpeed = 
            (playbackSpeed - minSpeed) / (maxSpeed - minSpeed);

        const double handleX = speedSlider.x + 
                              speedSlider.w * normalizedSpeed;
        const Circle handle{ handleX, 
                           speedSlider.y + speedSlider.h / 2.0, 15 };

        // 드래그 처리
        if (handle.leftPressed() || (isDragging && MouseL.pressed()))
        {
            isDragging = true;
            const double normalized = Clamp(
                (Cursor::Pos().x - speedSlider.x) / speedSlider.w,
                0.0, 1.0);
            playbackSpeed = minSpeed + normalized * (maxSpeed - minSpeed);
        }
        else if (MouseL.up())
        {
            isDragging = false;
        }

        // 슬라이더 채워진 부분
        Rect{ speedSlider.pos, 
              static_cast<int32>(speedSlider.w * normalizedSpeed), 
              speedSlider.h }
            .draw(ColorF{ 0.4, 0.6, 0.8 });

        speedSlider.drawFrame(2, ColorF{ 0.7 });
        handle.draw(ColorF{ 0.9 });
        handle.drawFrame(2, ColorF{ 0.3 });

        // 프리셋 버튼들
        // 느림 (0.5x)
        if (slowButton.mouseOver())
        {
            slowButton.draw(ColorF{ 0.6, 0.7, 0.8 });
        }
        else
        {
            slowButton.draw(ColorF{ 0.4, 0.5, 0.6 });
        }
        slowButton.drawFrame(2, ColorF{ 0.8 });
        font(U"0.5x").drawAt(18, slowButton.center(), ColorF{ 0.9 });

        if (slowButton.leftClicked())
        {
            playbackSpeed = 0.5;
        }

        // 보통 (1.0x)
        if (normalButton.mouseOver())
        {
            normalButton.draw(ColorF{ 0.5, 0.8, 0.5 });
        }
        else
        {
            normalButton.draw(ColorF{ 0.3, 0.6, 0.3 });
        }
        normalButton.drawFrame(2, ColorF{ 0.8 });
        font(U"1.0x").drawAt(18, normalButton.center(), ColorF{ 0.9 });

        if (normalButton.leftClicked())
        {
            playbackSpeed = 1.0;
        }

        // 빠름 (1.5x)
        if (fastButton.mouseOver())
        {
            fastButton.draw(ColorF{ 0.9, 0.7, 0.4 });
        }
        else
        {
            fastButton.draw(ColorF{ 0.7, 0.5, 0.2 });
        }
        fastButton.drawFrame(2, ColorF{ 0.8 });
        font(U"1.5x").drawAt(18, fastButton.center(), ColorF{ 0.9 });

        if (fastButton.leftClicked())
        {
            playbackSpeed = 1.5;
        }

        // 매우 빠름 (2.0x)
        if (veryFastButton.mouseOver())
        {
            veryFastButton.draw(ColorF{ 0.9, 0.4, 0.4 });
        }
        else
        {
            veryFastButton.draw(ColorF{ 0.7, 0.2, 0.2 });
        }
        veryFastButton.drawFrame(2, ColorF{ 0.8 });
        font(U"2.0x").drawAt(18, veryFastButton.center(), ColorF{ 0.9 });

        if (veryFastButton.leftClicked())
        {
            playbackSpeed = 2.0;
        }

        // 정보 표시
        font(U"재생 속도 조절").draw(24, Vec2{ 250, 180 }, ColorF{ 0.9 });
        font(U"속도: {:.2f}x"_fmt(playbackSpeed))
            .drawAt(20, Vec2{ 400, 480 }, ColorF{ 0.8 });

        // 현재 재생 중이면 표시
        if (voice.isPlaying())
        {
            const double progress = voice.posSec() / voice.lengthSec();
            const Rect progressBar{ 200, 520, 400, 10 };
            progressBar.draw(ColorF{ 0.3 });
            Rect{ progressBar.pos, 
                  static_cast<int32>(progressBar.w * progress), 
                  progressBar.h }
                .draw(ColorF{ 0.3, 0.8, 0.3 });
            progressBar.drawFrame(1, ColorF{ 0.7 });
        }
    }
}
```

`setSpeed()` 메서드로 재생 속도를 조절한다. 0.5는 절반 속도(한 옥타브 낮은 음), 2.0은 두 배 속도(한 옥타브 높은 음)를 의미한다. 게임에서 슬로우 모션 효과나 특수 능력 사용 시 시간 왜곡 효과를 표현할 때 유용하다.

주의할 점은 재생 속도를 변경하면 음높이도 함께 변한다는 것이다. 음높이는 그대로 두고 속도만 변경하려면 별도의 오디오 처리 라이브러리가 필요하다.

## 22.6 실습 문제

이번 장에서 배운 내용을 바탕으로 다음 문제들을 해결한다.

**문제 1: 리듬 게임 기초**

간단한 리듬 게임을 만든다. 화면 위에서 노트가 내려오고, 타이밍에 맞춰 키를 누르면 효과음이 재생되며 점수가 증가한다. 배경 음악도 재생되어야 한다.

요구사항은 다음과 같다. 배경 음악이 반복 재생되어야 하고, 노트가 일정한 간격으로 위에서 아래로 내려와야 한다. 타이밍 라인에 노트가 닿았을 때 스페이스바를 누르면 성공 효과음이 재생되며, 타이밍이 맞지 않으면 실패 효과음이 재생된다. 점수 시스템을 구현하고 완벽한 타이밍, 좋은 타이밍, 실패를 구분한다.

**문제 2: 사운드 믹서**

여러 사운드 트랙을 동시에 재생하고 각각의 볼륨을 독립적으로 조절할 수 있는 사운드 믹서를 만든다.

요구사항은 다음과 같다. 최소 3개의 다른 사운드 트랙을 로드하고, 각 트랙마다 개별 볼륨 슬라이더를 제공한다. 마스터 볼륨 슬라이더로 전체 볼륨을 조절할 수 있어야 하며, 각 트랙의 재생/일시정지/정지 버튼을 구현한다. 현재 재생 위치를 시각적으로 표시한다.

**문제 3: 위치 기반 사운드 시뮬레이션**

플레이어가 이동할 수 있고, 맵에 배치된 사운드 소스에서 나는 소리가 거리와 방향에 따라 다르게 들리는 시뮬레이션을 만든다.

요구사항은 다음과 같다. 화살표 키로 플레이어를 이동시킬 수 있어야 하고, 맵에 여러 개의 사운드 소스를 배치한다. 각 사운드 소스까지의 거리에 따라 볼륨이 감쇠되며, 좌우 방향에 따라 스테레오 패닝이 적용된다. 가장 가까운 사운드 소스를 시각적으로 강조 표시한다.

## 22.7 심화 내용

### 22.7.1 오디오 파형 시각화

재생 중인 오디오의 파형이나 스펙트럼을 시각화하면 더욱 풍부한 사용자 경험을 제공할 수 있다. Siv3D의 FFT 기능을 활용한 예제다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.05, 0.05, 0.1 });

    const Audio audio{ Audio::Stream, U"example/sound/music.mp3" };
    audio.setLoop(true);
    audio.play();

    // FFT 결과를 저장할 배열
    FFTResult fft;

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    while (System::Update())
    {
        // FFT 계산 (주파수 분석)
        FFT::Analyze(fft, audio);

        // 스펙트럼 그리기 (저주파부터 고주파까지)
        const int32 barCount = 60;
        const double barWidth = Scene::Width() / static_cast<double>(barCount);

        for (int32 i = 0; i < barCount; ++i)
        {
            // FFT 결과에서 해당 주파수 대역의 값 가져오기
            const double value = fft.buffer[i] * 4.0;  // 증폭
            const double height = Min(value * Scene::Height(), 
                                     static_cast<double>(Scene::Height()));

            // 주파수에 따라 색상 변화
            const double hue = i / static_cast<double>(barCount) * 240.0;
            const ColorF color = HSV{ hue, 0.8, 0.9 };

            // 막대 그리기
            const RectF bar{ i * barWidth, 
                           Scene::Height() - height, 
                           barWidth - 2, 
                           height };
            bar.draw(color);
        }

        // 파형 그리기 (시간 영역)
        const size_t waveformSize = 
            Min<size_t>(fft.buffer.size(), 800);
        for (size_t i = 1; i < waveformSize; ++i)
        {
            const double x1 = (i - 1) * Scene::Width() / 
                             static_cast<double>(waveformSize);
            const double x2 = i * Scene::Width() / 
                             static_cast<double>(waveformSize);
            
            const double y1 = Scene::Height() / 2.0 + 
                             fft.buffer[i - 1] * 200;
            const double y2 = Scene::Height() / 2.0 + 
                             fft.buffer[i] * 200;

            Line{ x1, y1, x2, y2 }.draw(2, ColorF{ 0.3, 0.8, 1.0, 0.5 });
        }

        // 중앙선
        Line{ 0, Scene::Height() / 2.0, 
              Scene::Width(), Scene::Height() / 2.0 }
            .draw(1, ColorF{ 0.5, 0.5, 0.5, 0.3 });

        // 정보 표시
        font(U"오디오 시각화").draw(20, Vec2{ 20, 20 }, 
                                    ColorF{ 0.9, 0.9, 0.9, 0.8 });
        font(U"{:.1f} / {:.1f} 초"_fmt(audio.posSec(), audio.lengthSec()))
            .draw(16, Vec2{ 20, 50 }, ColorF{ 0.7, 0.7, 0.7, 0.8 });
    }
}
```

FFT(고속 푸리에 변환)는 시간 영역의 신호를 주파수 영역으로 변환한다. 이를 통해 현재 재생 중인 오디오에 어떤 주파수 성분이 얼마나 포함되어 있는지 알 수 있다. 낮은 인덱스는 저음, 높은 인덱스는 고음을 나타낸다.

이런 시각화는 음악 플레이어나 오디오 편집 프로그램에서 흔히 볼 수 있으며, 사용자에게 시각적 피드백을 제공한다.

### 22.7.2 다중 채널 오디오와 믹싱

복잡한 게임에서는 여러 오디오 소스를 동시에 관리해야 한다. 배경 음악, 환경 소리, 효과음, 음성 등이 모두 독립적으로 재생되면서도 조화롭게 들려야 한다.

```cpp
#include <Siv3D.hpp>

// 오디오 채널 믹서
class AudioMixer
{
private:
    struct Channel
    {
        String name;
        Array<Audio> sounds;
        double volume = 1.0;
        bool muted = false;
    };

    std::unordered_map<String, Channel> channels;
    double masterVolume = 1.0;

public:
    // 채널 추가
    void addChannel(const String& channelName, double defaultVolume = 1.0)
    {
        Channel channel;
        channel.name = channelName;
        channel.volume = defaultVolume;
        channels[channelName] = channel;
    }

    // 채널에 오디오 추가
    void addAudioToChannel(const String& channelName, const Audio& audio)
    {
        if (channels.contains(channelName))
        {
            channels[channelName].sounds.push_back(audio);
        }
    }

    // 채널의 모든 오디오 재생
    void playChannel(const String& channelName)
    {
        if (not channels.contains(channelName))
        {
            return;
        }

        auto& channel = channels[channelName];
        const double effectiveVolume = 
            channel.muted ? 0.0 : channel.volume * masterVolume;

        for (auto& audio : channel.sounds)
        {
            audio.setVolume(effectiveVolume);
            if (not audio.isPlaying())
            {
                audio.play();
            }
        }
    }

    // 채널 볼륨 설정
    void setChannelVolume(const String& channelName, double volume)
    {
        if (not channels.contains(channelName))
        {
            return;
        }

        auto& channel = channels[channelName];
        channel.volume = Clamp(volume, 0.0, 1.0);

        const double effectiveVolume = 
            channel.muted ? 0.0 : channel.volume * masterVolume;

        for (auto& audio : channel.sounds)
        {
            audio.setVolume(effectiveVolume);
        }
    }

    // 채널 음소거 토글
    void toggleMute(const String& channelName)
    {
        if (not channels.contains(channelName))
        {
            return;
        }

        auto& channel = channels[channelName];
        channel.muted = not channel.muted;

        const double effectiveVolume = 
            channel.muted ? 0.0 : channel.volume * masterVolume;

        for (auto& audio : channel.sounds)
        {
            audio.setVolume(effectiveVolume);
        }
    }

    // 마스터 볼륨 설정
    void setMasterVolume(double volume)
    {
        masterVolume = Clamp(volume, 0.0, 1.0);

        for (auto& [name, channel] : channels)
        {
            const double effectiveVolume = 
                channel.muted ? 0.0 : channel.volume * masterVolume;

            for (auto& audio : channel.sounds)
            {
                audio.setVolume(effectiveVolume);
            }
        }
    }

    // 채널 정보 가져오기
    double getChannelVolume(const String& channelName) const
    {
        if (channels.contains(channelName))
        {
            return channels.at(channelName).volume;
        }
        return 0.0;
    }

    bool isChannelMuted(const String& channelName) const
    {
        if (channels.contains(channelName))
        {
            return channels.at(channelName).muted;
        }
        return false;
    }

    double getMasterVolume() const
    {
        return masterVolume;
    }

    // 모든 채널 정지
    void stopAll()
    {
        for (auto& [name, channel] : channels)
        {
            for (auto& audio : channel.sounds)
            {
                audio.stop();
            }
        }
    }
};

void Main()
{
    Scene::SetBackground(ColorF{ 0.15, 0.18, 0.22 });

    AudioMixer mixer;

    // 채널 설정
    mixer.addChannel(U"Music", 0.5);
    mixer.addChannel(U"Ambience", 0.3);
    mixer.addChannel(U"SFX", 0.7);

    // 오디오 로드 및 채널에 추가
    Audio music{ Audio::Stream, U"example/sound/music.mp3" };
    music.setLoop(true);
    mixer.addAudioToChannel(U"Music", music);

    Audio ambience{ Audio::Stream, U"example/sound/music.mp3" };
    ambience.setLoop(true);
    mixer.addAudioToChannel(U"Ambience", ambience);

    Audio sfx{ U"example/sound/button.mp3" };
    mixer.addAudioToChannel(U"SFX", sfx);

    // 모든 채널 재생 시작
    mixer.playChannel(U"Music");
    mixer.playChannel(U"Ambience");

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // UI 요소들
    const Array<String> channelNames = { U"Music", U"Ambience", U"SFX" };
    const int32 startY = 100;
    const int32 spacing = 100;

    std::unordered_map<String, bool> sliderDragging;
    for (const auto& name : channelNames)
    {
        sliderDragging[name] = false;
    }

    bool masterSliderDragging = false;

    while (System::Update())
    {
        font(U"오디오 믹서").draw(26, Vec2{ 30, 30 }, ColorF{ 0.9 });

        // 각 채널별 컨트롤
        for (size_t i = 0; i < channelNames.size(); ++i)
        {
            const String& channelName = channelNames[i];
            const int32 y = startY + static_cast<int32>(i) * spacing;

            // 채널 이름
            font(channelName).draw(20, Vec2{ 30, y }, ColorF{ 0.8 });

            // 볼륨 슬라이더
            const Rect slider{ 200, y + 10, 300, 15 };
            slider.draw(ColorF{ 0.3 });

            const double volume = mixer.getChannelVolume(channelName);
            const double handleX = slider.x + slider.w * volume;
            const Circle handle{ handleX, slider.y + slider.h / 2.0, 12 };

            // 슬라이더 드래그
            if (handle.leftPressed() || 
                (sliderDragging[channelName] && MouseL.pressed()))
            {
                sliderDragging[channelName] = true;
                const double newVolume = Clamp(
                    (Cursor::Pos().x - slider.x) / slider.w, 0.0, 1.0);
                mixer.setChannelVolume(channelName, newVolume);
            }
            else if (MouseL.up())
            {
                sliderDragging[channelName] = false;
            }

            Rect{ slider.pos, static_cast<int32>(slider.w * volume), slider.h }
                .draw(ColorF{ 0.4, 0.7, 0.5 });

            slider.drawFrame(1, ColorF{ 0.6 });
            handle.draw(ColorF{ 0.9 });
            handle.drawFrame(2, ColorF{ 0.5 });

            // 볼륨 표시
            font(U"{:.0f}%"_fmt(volume * 100))
                .draw(16, Vec2{ 520, y + 8 }, ColorF{ 0.7 });

            // 음소거 버튼
            const Rect muteButton{ 600, y + 5, 80, 30 };
            const bool isMuted = mixer.isChannelMuted(channelName);

            if (muteButton.mouseOver())
            {
                muteButton.draw(isMuted ? ColorF{ 0.8, 0.4, 0.4 } 
                                       : ColorF{ 0.6, 0.7, 0.6 });
            }
            else
            {
                muteButton.draw(isMuted ? ColorF{ 0.6, 0.2, 0.2 } 
                                       : ColorF{ 0.4, 0.5, 0.4 });
            }
            muteButton.drawFrame(2, ColorF{ 0.8 });
            font(isMuted ? U"🔇" : U"🔊")
                .drawAt(18, muteButton.center(), ColorF{ 0.9 });

            if (muteButton.leftClicked())
            {
                mixer.toggleMute(channelName);
            }
        }

        // SFX 테스트 버튼
        const Rect sfxButton{ 200, startY + 2 * spacing + 50, 120, 40 };
        if (sfxButton.mouseOver())
        {
            sfxButton.draw(ColorF{ 0.6, 0.6, 0.8 });
        }
        else
        {
            sfxButton.draw(ColorF{ 0.4, 0.4, 0.6 });
        }
        sfxButton.drawFrame(2, ColorF{ 0.8 });
        font(U"SFX 재생").drawAt(16, sfxButton.center(), ColorF{ 0.9 });

        if (sfxButton.leftClicked())
        {
            sfx.playOneShot();
        }

        // 마스터 볼륨
        const int32 masterY = startY + 3 * spacing + 20;
        Line{ 30, masterY, Scene::Width() - 30, masterY }
            .draw(2, ColorF{ 0.5 });

        font(U"마스터 볼륨").draw(22, Vec2{ 30, masterY + 20 }, ColorF{ 0.9 });

        const Rect masterSlider{ 200, masterY + 30, 400, 20 };
        masterSlider.draw(ColorF{ 0.3 });

        const double masterVolume = mixer.getMasterVolume();
        const double masterHandleX = masterSlider.x + masterSlider.w * masterVolume;
        const Circle masterHandle{ masterHandleX, 
                                  masterSlider.y + masterSlider.h / 2.0, 15 };

        if (masterHandle.leftPressed() || 
            (masterSliderDragging && MouseL.pressed()))
        {
            masterSliderDragging = true;
            const double newVolume = Clamp(
                (Cursor::Pos().x - masterSlider.x) / masterSlider.w, 0.0, 1.0);
            mixer.setMasterVolume(newVolume);
        }
        else if (MouseL.up())
        {
            masterSliderDragging = false;
        }

        Rect{ masterSlider.pos, 
              static_cast<int32>(masterSlider.w * masterVolume), 
              masterSlider.h }
            .draw(ColorF{ 0.5, 0.7, 0.9 });

        masterSlider.drawFrame(2, ColorF{ 0.7 });
        masterHandle.draw(ColorF{ 1.0 });
        masterHandle.drawFrame(3, ColorF{ 0.5 });

        font(U"{:.0f}%"_fmt(masterVolume * 100))
            .draw(18, Vec2{ 620, masterY + 26 }, ColorF{ 0.8 });
    }
}
```

`AudioMixer` 클래스는 여러 오디오 채널을 계층적으로 관리한다. 각 채널은 독립적인 볼륨과 음소거 상태를 가지며, 마스터 볼륨은 모든 채널에 공통으로 적용된다. 실제 게임에서는 설정 메뉴에서 음악, 효과음, 음성 등을 개별적으로 조절할 수 있게 하는 것이 일반적이다.

### 22.7.3 오디오 스트리밍과 메모리 관리

큰 음악 파일을 다룰 때는 메모리 사용량을 고려해야 한다. 전체 파일을 메모리에 로드하는 것과 스트리밍 방식의 차이를 이해하고 적절히 선택해야 한다.

일반적인 가이드라인은 다음과 같다. 짧은 효과음(1~2초)은 일반 `Audio`로 로드하여 빠른 재생 반응 속도를 얻는다. 긴 배경 음악(1분 이상)은 `Audio::Stream`으로 로드하여 메모리를 절약한다. 자주 반복 재생되는 중간 길이 사운드(5~30초)는 상황에 따라 선택한다.

예를 들어 CD 품질의 스테레오 음악(44.1kHz, 16bit)은 1분당 약 10MB의 메모리를 사용한다. 5분짜리 배경 음악을 일반 방식으로 로드하면 50MB를 차지하지만, 스트리밍 방식은 수 MB만 사용한다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.1, 0.1, 0.15 });

    // 일반 로드 방식
    const Audio normalAudio{ U"example/sound/music.mp3" };
    
    // 스트리밍 방식
    const Audio streamAudio{ Audio::Stream, U"example/sound/music.mp3" };

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    const Rect normalButton{ 200, 200, 200, 60 };
    const Rect streamButton{ 450, 200, 200, 60 };

    while (System::Update())
    {
        font(U"메모리 사용 비교").draw(24, Vec2{ 250, 100 }, ColorF{ 0.9 });

        // 일반 로드 버튼
        if (normalButton.mouseOver())
        {
            normalButton.draw(ColorF{ 0.5, 0.6, 0.8 });
        }
        else
        {
            normalButton.draw(ColorF{ 0.3, 0.4, 0.6 });
        }
        normalButton.drawFrame(2, ColorF{ 0.8 });
        font(U"일반 로드").drawAt(18, normalButton.center(), ColorF{ 0.9 });

        if (normalButton.leftClicked())
        {
            streamAudio.stop();
            normalAudio.play();
        }

        // 스트리밍 버튼
        if (streamButton.mouseOver())
        {
            streamButton.draw(ColorF{ 0.6, 0.8, 0.5 });
        }
        else
        {
            streamButton.draw(ColorF{ 0.4, 0.6, 0.3 });
        }
        streamButton.drawFrame(2, ColorF{ 0.8 });
        font(U"스트리밍").drawAt(18, streamButton.center(), ColorF{ 0.9 });

        if (streamButton.leftClicked())
        {
            normalAudio.stop();
            streamAudio.play();
        }

        // 정보 표시
        int32 infoY = 300;
        font(U"일반 로드:").draw(18, Vec2{ 200, infoY }, ColorF{ 0.8 });
        font(U"• 전체 파일을 메모리에 로드")
            .draw(16, Vec2{ 220, infoY + 30 }, ColorF{ 0.7 });
        font(U"• 빠른 재생 시작")
            .draw(16, Vec2{ 220, infoY + 55 }, ColorF{ 0.7 });
        font(U"• 메모리 사용량 높음")
            .draw(16, Vec2{ 220, infoY + 80 }, ColorF{ 0.7 });
        font(U"• 짧은 효과음에 적합")
            .draw(16, Vec2{ 220, infoY + 105 }, ColorF{ 0.7 });

        infoY = 450;
        font(U"스트리밍:").draw(18, Vec2{ 200, infoY }, ColorF{ 0.8 });
        font(U"• 필요한 부분만 메모리에 로드")
            .draw(16, Vec2{ 220, infoY + 30 }, ColorF{ 0.7 });
        font(U"• 약간의 초기화 시간 필요")
            .draw(16, Vec2{ 220, infoY + 55 }, ColorF{ 0.7 });
        font(U"• 메모리 사용량 낮음")
            .draw(16, Vec2{ 220, infoY + 80 }, ColorF{ 0.7 });
        font(U"• 긴 배경 음악에 적합")
            .draw(16, Vec2{ 220, infoY + 105 }, ColorF{ 0.7 });

        // 재생 상태 표시
        String playingInfo = U"";
        if (normalAudio.isPlaying())
        {
            playingInfo = U"재생 중: 일반 로드";
        }
        else if (streamAudio.isPlaying())
        {
            playingInfo = U"재생 중: 스트리밍";
        }
        else
        {
            playingInfo = U"정지";
        }

        font(playingInfo).drawAt(20, Vec2{ 400, 600 }, ColorF{ 0.3, 0.8, 0.8 });
    }
}
```

프로젝트의 요구사항에 따라 적절한 방식을 선택하면 메모리 효율과 성능을 모두 만족시킬 수 있다.

## 22.8 정리

이번 장에서는 Siv3D를 사용한 사운드와 음악 처리 방법을 배웠다. 기본적인 사운드 재생부터 시작하여 배경 음악 관리, 효과음 풀 시스템, 볼륨 조절, 3D 사운드, 그리고 고급 오디오 처리 기법까지 다루었다.

핵심 내용을 정리하면 다음과 같다. `Audio` 클래스로 다양한 형식의 오디오 파일을 로드하고 재생한다. `play()`, `pause()`, `stop()` 메서드로 재생을 제어하며, `setLoop()`로 반복 재생을 설정한다. `setVolume()`과 `setPan()`으로 볼륨과 스테레오 패닝을 조절하고, 페이드 효과로 자연스러운 전환을 구현한다. 효과음 풀 시스템으로 동시 다발적인 효과음 재생을 처리하며, 거리 기반 볼륨 감쇠와 방향성 오디오로 몰입감을 높인다. FFT를 사용한 오디오 시각화로 사용자 경험을 향상시키고, 스트리밍 방식으로 메모리를 효율적으로 관리한다.

사운드는 게임과 애플리케이션의 중요한 구성 요소다. 적절한 배경 음악과 효과음은 사용자의 몰입도를 크게 높이며, 시각적 피드백만으로는 전달하기 어려운 감정과 분위기를 표현할 수 있다. 다음 장에서는 파일 시스템과 데이터 관리를 배워 프로그램의 상태를 저장하고 불러오는 방법을 알아본다.


 