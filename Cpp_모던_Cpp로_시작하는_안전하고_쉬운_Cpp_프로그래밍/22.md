# ëª¨ë˜ C++ë¡œ ì‹œì‘í•˜ëŠ” ì•ˆì „í•˜ê³  ì‰¬ìš´ C++ í”„ë¡œê·¸ë˜ë° 

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  
  
# Chapter 22: ì‚¬ìš´ë“œì™€ ìŒì•…

ê²Œì„ì´ë‚˜ ë©€í‹°ë¯¸ë””ì–´ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‚¬ìš´ë“œëŠ” ì‚¬ìš©ì ê²½í—˜ì„ í¬ê²Œ í–¥ìƒì‹œí‚¤ëŠ” ì¤‘ìš”í•œ ìš”ì†Œë‹¤. ë²„íŠ¼ì„ í´ë¦­í•  ë•Œ ë“¤ë¦¬ëŠ” ì‘ì€ íš¨ê³¼ìŒë¶€í„° ê²Œì„ì˜ ë¶„ìœ„ê¸°ë¥¼ ê²°ì •í•˜ëŠ” ë°°ê²½ ìŒì•…ê¹Œì§€, ì˜¤ë””ì˜¤ëŠ” í”„ë¡œê·¸ë¨ì— ìƒëª…ë ¥ì„ ë¶ˆì–´ë„£ëŠ”ë‹¤. ì´ë²ˆ ì¥ì—ì„œëŠ” Siv3Dë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš´ë“œ íŒŒì¼ì„ ë¡œë“œí•˜ê³  ì¬ìƒí•˜ë©°, ìŒì•…ê³¼ íš¨ê³¼ìŒì„ íš¨ê³¼ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë°°ìš´ë‹¤.

## 22.1 ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ ê°œìš”

Siv3DëŠ” ë‹¤ì–‘í•œ ì˜¤ë””ì˜¤ íŒŒì¼ í˜•ì‹ì„ ì§€ì›í•˜ë©°, ê°„ë‹¨í•œ ì¸í„°í˜ì´ìŠ¤ë¡œ ì‚¬ìš´ë“œë¥¼ ì œì–´í•  ìˆ˜ ìˆë‹¤. ì£¼ë¡œ ì‚¬ìš©í•˜ëŠ” ì˜¤ë””ì˜¤ íŒŒì¼ í˜•ì‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

**ì§€ì›í•˜ëŠ” ì˜¤ë””ì˜¤ í˜•ì‹:**
- WAV: ë¬´ì†ì‹¤ ì••ì¶• í˜•ì‹ìœ¼ë¡œ íš¨ê³¼ìŒì— ì í•©í•˜ë‹¤
- MP3: ì••ì¶• í˜•ì‹ìœ¼ë¡œ ë°°ê²½ ìŒì•…ì— ì í•©í•˜ë‹¤
- OGG: ì˜¤í”ˆ ì†ŒìŠ¤ ì••ì¶• í˜•ì‹ìœ¼ë¡œ ìš©ëŸ‰ê³¼ í’ˆì§ˆì˜ ê· í˜•ì´ ì¢‹ë‹¤
- AAC/M4A: ê³ í’ˆì§ˆ ì••ì¶• í˜•ì‹ì´ë‹¤
- FLAC: ë¬´ì†ì‹¤ ì••ì¶• í˜•ì‹ìœ¼ë¡œ ê³ ìŒì§ˆì´ í•„ìš”í•  ë•Œ ì‚¬ìš©í•œë‹¤

Siv3Dì—ì„œëŠ” í¬ê²Œ ë‘ ê°€ì§€ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜¤ë””ì˜¤ë¥¼ ì²˜ë¦¬í•œë‹¤. `Audio` í´ë˜ìŠ¤ëŠ” íš¨ê³¼ìŒê³¼ ë°°ê²½ ìŒì•… ëª¨ë‘ì— ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, ë©”ëª¨ë¦¬ì— ì „ì²´ ì˜¤ë””ì˜¤ ë°ì´í„°ë¥¼ ë¡œë“œí•œë‹¤. ë°˜ë©´ `AudioStream` í´ë˜ìŠ¤ëŠ” í° íŒŒì¼ì„ ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ìœ¼ë¡œ ì¬ìƒí•˜ì—¬ ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•œë‹¤.

ì¼ë°˜ì ìœ¼ë¡œ ì§§ì€ íš¨ê³¼ìŒì€ `Audio`ë¥¼, ê¸´ ë°°ê²½ ìŒì•…ì€ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„ ê³ ë ¤í•˜ì—¬ `Audio` ë˜ëŠ” ìƒí™©ì— ë”°ë¼ ì„ íƒí•œë‹¤. Siv3D v0.6.16ì—ì„œëŠ” ëŒ€ë¶€ë¶„ì˜ ê²½ìš° `Audio` í´ë˜ìŠ¤ë§Œìœ¼ë¡œë„ ì¶©ë¶„í•˜ë‹¤.

## 22.2 ì‚¬ìš´ë“œ íŒŒì¼ ë¡œë“œì™€ ì¬ìƒ

ê°€ì¥ ê¸°ë³¸ì ì¸ ì‚¬ìš´ë“œ ì¬ìƒë¶€í„° ì‹œì‘í•œë‹¤. ë¨¼ì € í”„ë¡œì íŠ¸ì˜ ì ì ˆí•œ ìœ„ì¹˜ì— ì˜¤ë””ì˜¤ íŒŒì¼ì„ ë°°ì¹˜í•´ì•¼ í•œë‹¤. Visual Studio 2022ì—ì„œ Siv3D í”„ë¡œì íŠ¸ë¥¼ ë§Œë“¤ë©´ ê¸°ë³¸ì ìœ¼ë¡œ `App` í´ë”ê°€ ìƒì„±ë˜ëŠ”ë°, ì´ê³³ì— ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì €ì¥í•œë‹¤.

### 22.2.1 ê¸°ë³¸ì ì¸ ì‚¬ìš´ë“œ ì¬ìƒ

ë‹¤ìŒì€ í´ë¦­ íš¨ê³¼ìŒì„ ì¬ìƒí•˜ëŠ” ê°„ë‹¨í•œ ì˜ˆì œë‹¤.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // ë°°ê²½ ìƒ‰ìƒ ì„¤ì •
    Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });

    // íš¨ê³¼ìŒ ë¡œë“œ
    const Audio clickSound{ U"example/sound/button.mp3" };

    // ë¡œë“œ ì‹¤íŒ¨ í™•ì¸
    if (not clickSound)
    {
        throw Error{ U"Failed to load audio file" };
    }

    // ì¬ìƒ ë²„íŠ¼ ì˜ì—­
    const Rect playButton{ 300, 250, 200, 60 };

    while (System::Update())
    {
        // ë²„íŠ¼ ê·¸ë¦¬ê¸°
        if (playButton.mouseOver())
        {
            playButton.draw(ColorF{ 0.7, 0.8, 1.0 });
        }
        else
        {
            playButton.draw(ColorF{ 0.5, 0.6, 0.8 });
        }

        playButton.drawFrame(2, ColorF{ 0.2, 0.3, 0.5 });
        
        FontAsset(U"Regular")(U"íš¨ê³¼ìŒ ì¬ìƒ").drawAt(
            playButton.center(), ColorF{ 0.1 });

        // ë²„íŠ¼ í´ë¦­ ì‹œ ì‚¬ìš´ë“œ ì¬ìƒ
        if (playButton.leftClicked())
        {
            clickSound.play();
        }

        // í˜„ì¬ ì¬ìƒ ì¤‘ì¸ì§€ í‘œì‹œ
        if (clickSound.isPlaying())
        {
            Circle{ playButton.center().movedBy(0, 50), 10 }
                .draw(ColorF{ 1.0, 0.3, 0.3 });
        }
    }
}
```

ì´ ì½”ë“œì—ì„œ `Audio` ê°ì²´ë¥¼ ìƒì„±í•  ë•Œ íŒŒì¼ ê²½ë¡œë¥¼ ì „ë‹¬í•œë‹¤. Siv3Dì—ì„œëŠ” ë¬¸ìì—´ ë¦¬í„°ëŸ´ ì•ì— `U`ë¥¼ ë¶™ì—¬ UTF-32 ë¬¸ìì—´ì„ ë‚˜íƒ€ë‚¸ë‹¤. `play()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ ì‚¬ìš´ë“œê°€ ì¬ìƒë˜ë©°, ì´ë¯¸ ì¬ìƒ ì¤‘ì´ë©´ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•œë‹¤. `isPlaying()` ë©”ì„œë“œëŠ” í˜„ì¬ ì¬ìƒ ì¤‘ì¸ì§€ í™•ì¸í•œë‹¤.

### 22.2.2 ì‚¬ìš´ë“œ ì¬ìƒ ì œì–´

ì‚¬ìš´ë“œë¥¼ ë” ì„¸ë°€í•˜ê²Œ ì œì–´í•  ìˆ˜ ìˆë‹¤. ì¼ì‹œ ì •ì§€, ì¬ê°œ, ì •ì§€ ë“±ì˜ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ëŠ” ì˜ˆì œë¥¼ ì‚´í´ë³¸ë‹¤.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });

    // ê¸´ íš¨ê³¼ìŒ ë˜ëŠ” ì§§ì€ ìŒì•… ë¡œë“œ
    const Audio audio{ U"example/sound/sound.mp3" };

    if (not audio)
    {
        throw Error{ U"Failed to load audio file" };
    }

    // ë²„íŠ¼ë“¤ ì •ì˜
    const Rect playButton{ 250, 200, 120, 50 };
    const Rect pauseButton{ 380, 200, 120, 50 };
    const Rect stopButton{ 510, 200, 120, 50 };

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    while (System::Update())
    {
        // ì¬ìƒ ë²„íŠ¼
        if (playButton.mouseOver())
        {
            playButton.draw(ColorF{ 0.6, 0.8, 0.6 });
        }
        else
        {
            playButton.draw(ColorF{ 0.4, 0.6, 0.4 });
        }
        playButton.drawFrame(2, ColorF{ 0.2 });
        font(U"â–¶").drawAt(30, playButton.center(), ColorF{ 0.1 });

        if (playButton.leftClicked())
        {
            // ì¼ì‹œì •ì§€ ìƒíƒœë©´ ì¬ê°œ, ì•„ë‹ˆë©´ ì²˜ìŒë¶€í„° ì¬ìƒ
            if (audio.isPaused())
            {
                audio.play();
            }
            else
            {
                audio.play();
            }
        }

        // ì¼ì‹œì •ì§€ ë²„íŠ¼
        if (pauseButton.mouseOver())
        {
            pauseButton.draw(ColorF{ 0.8, 0.8, 0.6 });
        }
        else
        {
            pauseButton.draw(ColorF{ 0.6, 0.6, 0.4 });
        }
        pauseButton.drawFrame(2, ColorF{ 0.2 });
        font(U"â€–").drawAt(30, pauseButton.center(), ColorF{ 0.1 });

        if (pauseButton.leftClicked())
        {
            audio.pause();
        }

        // ì •ì§€ ë²„íŠ¼
        if (stopButton.mouseOver())
        {
            stopButton.draw(ColorF{ 0.8, 0.6, 0.6 });
        }
        else
        {
            stopButton.draw(ColorF{ 0.6, 0.4, 0.4 });
        }
        stopButton.drawFrame(2, ColorF{ 0.2 });
        font(U"â– ").drawAt(30, stopButton.center(), ColorF{ 0.1 });

        if (stopButton.leftClicked())
        {
            audio.stop();
        }

        // ì¬ìƒ ìƒíƒœ í‘œì‹œ
        String status = U"ì •ì§€";
        if (audio.isPlaying())
        {
            status = U"ì¬ìƒ ì¤‘";
        }
        else if (audio.isPaused())
        {
            status = U"ì¼ì‹œì •ì§€";
        }

        font(status).drawAt(20, Vec2{ 400, 300 }, ColorF{ 0.2 });

        // ì¬ìƒ ìœ„ì¹˜ í‘œì‹œ (ì´ˆ ë‹¨ìœ„)
        const double currentTime = audio.posSec();
        const double totalTime = audio.lengthSec();
        
        font(U"{:.1f} / {:.1f} ì´ˆ"_fmt(currentTime, totalTime))
            .drawAt(18, Vec2{ 400, 340 }, ColorF{ 0.4 });
    }
}
```

ì´ ì˜ˆì œì—ì„œëŠ” ì„¸ ê°œì˜ ë²„íŠ¼ìœ¼ë¡œ ì¬ìƒ, ì¼ì‹œì •ì§€, ì •ì§€ ê¸°ëŠ¥ì„ êµ¬í˜„í–ˆë‹¤. `pause()` ë©”ì„œë“œëŠ” í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì¬ìƒì„ ì¼ì‹œì •ì§€í•˜ê³ , ë‹¤ì‹œ `play()`ë¥¼ í˜¸ì¶œí•˜ë©´ ì¼ì‹œì •ì§€í•œ ìœ„ì¹˜ë¶€í„° ì¬ìƒì„ ì¬ê°œí•œë‹¤. `stop()` ë©”ì„œë“œëŠ” ì¬ìƒì„ ì¤‘ë‹¨í•˜ê³  ì¬ìƒ ìœ„ì¹˜ë¥¼ ì²˜ìŒìœ¼ë¡œ ë˜ëŒë¦°ë‹¤.

`posSec()` ë©”ì„œë“œëŠ” í˜„ì¬ ì¬ìƒ ìœ„ì¹˜ë¥¼ ì´ˆ ë‹¨ìœ„ë¡œ ë°˜í™˜í•˜ê³ , `lengthSec()` ë©”ì„œë“œëŠ” ì „ì²´ ê¸¸ì´ë¥¼ ì´ˆ ë‹¨ìœ„ë¡œ ë°˜í™˜í•œë‹¤. ì´ë¥¼ í™œìš©í•˜ë©´ ì§„í–‰ ìƒí™©ì„ ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ìˆ˜ ìˆë‹¤.

## 22.3 ë°°ê²½ ìŒì•… ê´€ë¦¬

ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë°°ê²½ ìŒì•…ì€ ë¶„ìœ„ê¸°ë¥¼ ì¡°ì„±í•˜ëŠ” ì¤‘ìš”í•œ ì—­í• ì„ í•œë‹¤. ë°°ê²½ ìŒì•…ì€ ë³´í†µ ë°˜ë³µ ì¬ìƒë˜ë©°, ì¥ë©´ ì „í™˜ ì‹œ ë¶€ë“œëŸ½ê²Œ í˜ì´ë“œ ì¸/ì•„ì›ƒ íš¨ê³¼ë¥¼ ì ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

### 22.3.1 ë°˜ë³µ ì¬ìƒê³¼ í˜ì´ë“œ íš¨ê³¼

ë°°ê²½ ìŒì•…ì„ ë¬´í•œ ë°˜ë³µí•˜ë©° í˜ì´ë“œ íš¨ê³¼ë¥¼ ì ìš©í•˜ëŠ” ì˜ˆì œë‹¤.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.2, 0.3, 0.4 });

    // ë°°ê²½ ìŒì•… ë¡œë“œ
    const Audio bgm{ Audio::Stream, U"example/sound/music.mp3" };

    if (not bgm)
    {
        throw Error{ U"Failed to load BGM" };
    }

    // ë¬´í•œ ë°˜ë³µ ì„¤ì •
    bgm.setLoop(true);

    // ì´ˆê¸° ë³¼ë¥¨ì„ 0ìœ¼ë¡œ ì„¤ì •
    bgm.setVolume(0.0);

    // ë°°ê²½ ìŒì•… ì‹œì‘
    bgm.play();

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };
    
    // í˜ì´ë“œ ì¸/ì•„ì›ƒ ì œì–´
    bool isFadingIn = true;
    double targetVolume = 0.5;  // ëª©í‘œ ë³¼ë¥¨
    double fadeSpeed = 0.3;      // í˜ì´ë“œ ì†ë„ (ì´ˆë‹¹ ë³¼ë¥¨ ë³€í™”ëŸ‰)

    const Rect fadeInButton{ 250, 250, 150, 60 };
    const Rect fadeOutButton{ 450, 250, 150, 60 };

    while (System::Update())
    {
        // í˜„ì¬ ë³¼ë¥¨ ê°€ì ¸ì˜¤ê¸°
        double currentVolume = bgm.getVolume();

        // í˜ì´ë“œ ì¸ ì²˜ë¦¬
        if (isFadingIn && currentVolume < targetVolume)
        {
            currentVolume = Min(currentVolume + fadeSpeed * Scene::DeltaTime(), 
                              targetVolume);
            bgm.setVolume(currentVolume);
        }
        // í˜ì´ë“œ ì•„ì›ƒ ì²˜ë¦¬
        else if (not isFadingIn && currentVolume > 0.0)
        {
            currentVolume = Max(currentVolume - fadeSpeed * Scene::DeltaTime(), 
                              0.0);
            bgm.setVolume(currentVolume);
        }

        // Fade In ë²„íŠ¼
        if (fadeInButton.mouseOver())
        {
            fadeInButton.draw(ColorF{ 0.4, 0.6, 0.8 });
        }
        else
        {
            fadeInButton.draw(ColorF{ 0.3, 0.5, 0.7 });
        }
        fadeInButton.drawFrame(2, ColorF{ 0.9 });
        font(U"Fade In").drawAt(20, fadeInButton.center(), ColorF{ 0.9 });

        if (fadeInButton.leftClicked())
        {
            isFadingIn = true;
        }

        // Fade Out ë²„íŠ¼
        if (fadeOutButton.mouseOver())
        {
            fadeOutButton.draw(ColorF{ 0.8, 0.4, 0.4 });
        }
        else
        {
            fadeOutButton.draw(ColorF{ 0.7, 0.3, 0.3 });
        }
        fadeOutButton.drawFrame(2, ColorF{ 0.9 });
        font(U"Fade Out").drawAt(20, fadeOutButton.center(), ColorF{ 0.9 });

        if (fadeOutButton.leftClicked())
        {
            isFadingIn = false;
        }

        // í˜„ì¬ ë³¼ë¥¨ í‘œì‹œ
        const double barWidth = 400.0;
        const Rect volumeBar{ 200, 350, static_cast<int32>(barWidth), 30 };
        volumeBar.draw(ColorF{ 0.3 });
        
        Rect{ volumeBar.pos, 
              static_cast<int32>(barWidth * currentVolume), 
              volumeBar.h }
            .draw(ColorF{ 0.3, 0.8, 0.3 });
        
        volumeBar.drawFrame(2, ColorF{ 0.9 });

        font(U"ë³¼ë¥¨: {:.0f}%"_fmt(currentVolume * 100))
            .drawAt(20, Vec2{ 400, 400 }, ColorF{ 0.9 });
    }
}
```

ì´ ì˜ˆì œì—ì„œëŠ” `Audio::Stream`ì„ ìƒì„±ìì— ì „ë‹¬í•˜ì—¬ ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ìœ¼ë¡œ ì˜¤ë””ì˜¤ë¥¼ ë¡œë“œí–ˆë‹¤. ì´ëŠ” í° ìŒì•… íŒŒì¼ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì—¬ì¤€ë‹¤. `setLoop(true)`ë¥¼ í˜¸ì¶œí•˜ë©´ ìŒì•…ì´ ëë‚˜ë©´ ìë™ìœ¼ë¡œ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì¬ìƒëœë‹¤.

í˜ì´ë“œ íš¨ê³¼ëŠ” ë§¤ í”„ë ˆì„ë§ˆë‹¤ ë³¼ë¥¨ì„ ì¡°ê¸ˆì”© ì¦ê°€ì‹œí‚¤ê±°ë‚˜ ê°ì†Œì‹œì¼œ êµ¬í˜„í•œë‹¤. `Scene::DeltaTime()`ì€ ì´ì „ í”„ë ˆì„ê³¼ í˜„ì¬ í”„ë ˆì„ ì‚¬ì´ì˜ ê²½ê³¼ ì‹œê°„(ì´ˆ)ì„ ë°˜í™˜í•˜ë¯€ë¡œ, ì´ë¥¼ ê³±í•˜ë©´ í”„ë ˆì„ë¥ ê³¼ ë¬´ê´€í•˜ê²Œ ì¼ì •í•œ ì†ë„ë¡œ í˜ì´ë“œ íš¨ê³¼ë¥¼ ì ìš©í•  ìˆ˜ ìˆë‹¤.

### 22.3.2 ì—¬ëŸ¬ ë°°ê²½ ìŒì•… ê´€ë¦¬

ê²Œì„ì—ì„œëŠ” ìƒí™©ì— ë”°ë¼ ë‹¤ë¥¸ ë°°ê²½ ìŒì•…ì„ ì¬ìƒí•´ì•¼ í•  ë•Œê°€ ë§ë‹¤. ë©”ë‰´ í™”ë©´, ê²Œì„ í”Œë ˆì´, ë³´ìŠ¤ì „ ë“± ê° ìƒí™©ì— ë§ëŠ” ìŒì•…ì„ ë¶€ë“œëŸ½ê²Œ ì „í™˜í•˜ëŠ” ë°©ë²•ì„ ì‚´í´ë³¸ë‹¤.

```cpp
#include <Siv3D.hpp>

// ë°°ê²½ ìŒì•… ê´€ë¦¬ í´ë˜ìŠ¤
class BGMManager
{
private:
    std::unordered_map<String, Audio> bgmMap;
    String currentBGM;
    String nextBGM;
    
    double fadeOutSpeed = 1.0;
    double fadeInSpeed = 1.0;
    double targetVolume = 0.5;
    
    bool isTransitioning = false;

public:
    // ë°°ê²½ ìŒì•… ë“±ë¡
    void registerBGM(const String& name, const FilePath& path)
    {
        Audio audio{ Audio::Stream, path };
        if (audio)
        {
            audio.setLoop(true);
            audio.setVolume(0.0);
            bgmMap[name] = std::move(audio);
        }
    }

    // ë°°ê²½ ìŒì•… ì „í™˜ ì‹œì‘
    void transitionTo(const String& name, double fadeOutSec = 1.0, 
                     double fadeInSec = 1.0)
    {
        if (not bgmMap.contains(name))
        {
            return;
        }

        nextBGM = name;
        fadeOutSpeed = targetVolume / fadeOutSec;
        fadeInSpeed = targetVolume / fadeInSec;
        isTransitioning = true;
    }

    // ì¦‰ì‹œ ì¬ìƒ (í˜ì´ë“œ ì—†ì´)
    void play(const String& name, double volume = 0.5)
    {
        if (not bgmMap.contains(name))
        {
            return;
        }

        stopAll();
        currentBGM = name;
        targetVolume = volume;
        bgmMap[currentBGM].setVolume(volume);
        bgmMap[currentBGM].play();
        isTransitioning = false;
    }

    // ëª¨ë“  ë°°ê²½ ìŒì•… ì •ì§€
    void stopAll()
    {
        for (auto& [name, audio] : bgmMap)
        {
            audio.stop();
            audio.setVolume(0.0);
        }
        currentBGM.clear();
    }

    // ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸
    void update()
    {
        if (not isTransitioning)
        {
            return;
        }

        // í˜„ì¬ BGM í˜ì´ë“œ ì•„ì›ƒ
        if (not currentBGM.isEmpty() && bgmMap.contains(currentBGM))
        {
            Audio& current = bgmMap[currentBGM];
            double volume = current.getVolume();
            
            if (volume > 0.0)
            {
                volume = Max(volume - fadeOutSpeed * Scene::DeltaTime(), 0.0);
                current.setVolume(volume);
                return;  // í˜ì´ë“œ ì•„ì›ƒì´ ëë‚  ë•Œê¹Œì§€ ëŒ€ê¸°
            }
            else
            {
                current.stop();
            }
        }

        // ë‹¤ìŒ BGM í˜ì´ë“œ ì¸
        if (not nextBGM.isEmpty() && bgmMap.contains(nextBGM))
        {
            Audio& next = bgmMap[nextBGM];
            
            if (not next.isPlaying())
            {
                next.setVolume(0.0);
                next.play();
                currentBGM = nextBGM;
            }

            double volume = next.getVolume();
            if (volume < targetVolume)
            {
                volume = Min(volume + fadeInSpeed * Scene::DeltaTime(), 
                           targetVolume);
                next.setVolume(volume);
            }
            else
            {
                isTransitioning = false;
                nextBGM.clear();
            }
        }
    }

    // í˜„ì¬ ì¬ìƒ ì¤‘ì¸ BGM ì´ë¦„
    String getCurrentBGM() const
    {
        return currentBGM;
    }

    // ì „í™˜ ì¤‘ì¸ì§€ í™•ì¸
    bool isInTransition() const
    {
        return isTransitioning;
    }

    // í˜„ì¬ ë³¼ë¥¨ ê°€ì ¸ì˜¤ê¸°
    double getCurrentVolume() const
    {
        if (currentBGM.isEmpty() || not bgmMap.contains(currentBGM))
        {
            return 0.0;
        }
        return bgmMap.at(currentBGM).getVolume();
    }
};

void Main()
{
    Scene::SetBackground(ColorF{ 0.2, 0.3, 0.4 });

    BGMManager bgmManager;
    
    // ì—¬ëŸ¬ ë°°ê²½ ìŒì•… ë“±ë¡
    bgmManager.registerBGM(U"Menu", U"example/sound/music.mp3");
    bgmManager.registerBGM(U"Game", U"example/sound/music.mp3");  
    bgmManager.registerBGM(U"Boss", U"example/sound/music.mp3");
    
    // ë©”ë‰´ ìŒì•…ìœ¼ë¡œ ì‹œì‘
    bgmManager.play(U"Menu", 0.4);

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };
    
    const Rect menuButton{ 200, 200, 140, 50 };
    const Rect gameButton{ 200, 270, 140, 50 };
    const Rect bossButton{ 200, 340, 140, 50 };

    while (System::Update())
    {
        // BGM ê´€ë¦¬ì ì—…ë°ì´íŠ¸
        bgmManager.update();

        // ë©”ë‰´ ë²„íŠ¼
        if (menuButton.mouseOver())
        {
            menuButton.draw(ColorF{ 0.4, 0.5, 0.7 });
        }
        else
        {
            menuButton.draw(ColorF{ 0.3, 0.4, 0.6 });
        }
        menuButton.drawFrame(2, ColorF{ 0.9 });
        font(U"ë©”ë‰´").drawAt(20, menuButton.center(), ColorF{ 0.9 });

        if (menuButton.leftClicked())
        {
            bgmManager.transitionTo(U"Menu", 1.5, 2.0);
        }

        // ê²Œì„ ë²„íŠ¼
        if (gameButton.mouseOver())
        {
            gameButton.draw(ColorF{ 0.4, 0.7, 0.4 });
        }
        else
        {
            gameButton.draw(ColorF{ 0.3, 0.6, 0.3 });
        }
        gameButton.drawFrame(2, ColorF{ 0.9 });
        font(U"ê²Œì„").drawAt(20, gameButton.center(), ColorF{ 0.9 });

        if (gameButton.leftClicked())
        {
            bgmManager.transitionTo(U"Game", 1.0, 1.0);
        }

        // ë³´ìŠ¤ ë²„íŠ¼
        if (bossButton.mouseOver())
        {
            bossButton.draw(ColorF{ 0.8, 0.3, 0.3 });
        }
        else
        {
            bossButton.draw(ColorF{ 0.7, 0.2, 0.2 });
        }
        bossButton.drawFrame(2, ColorF{ 0.9 });
        font(U"ë³´ìŠ¤").drawAt(20, bossButton.center(), ColorF{ 0.9 });

        if (bossButton.leftClicked())
        {
            bgmManager.transitionTo(U"Boss", 0.5, 0.5);
        }

        // í˜„ì¬ ìƒíƒœ í‘œì‹œ
        font(U"í˜„ì¬: {}"_fmt(bgmManager.getCurrentBGM()))
            .draw(20, Vec2{ 380, 220 }, ColorF{ 0.9 });

        if (bgmManager.isInTransition())
        {
            font(U"ì „í™˜ ì¤‘...").draw(18, Vec2{ 380, 250 }, 
                                    ColorF{ 1.0, 0.8, 0.3 });
        }

        // ë³¼ë¥¨ í‘œì‹œ
        const double volume = bgmManager.getCurrentVolume();
        font(U"ë³¼ë¥¨: {:.0f}%"_fmt(volume * 100))
            .draw(18, Vec2{ 380, 280 }, ColorF{ 0.7 });
    }
}
```

`BGMManager` í´ë˜ìŠ¤ëŠ” ì—¬ëŸ¬ ë°°ê²½ ìŒì•…ì„ ê´€ë¦¬í•˜ê³  ë¶€ë“œëŸ½ê²Œ ì „í™˜í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤. `std::unordered_map`ì„ ì‚¬ìš©í•˜ì—¬ ì´ë¦„ìœ¼ë¡œ ì˜¤ë””ì˜¤ ê°ì²´ë¥¼ ê´€ë¦¬í•˜ë©°, í˜„ì¬ ì¬ìƒ ì¤‘ì¸ ìŒì•…ê³¼ ë‹¤ìŒì— ì¬ìƒí•  ìŒì•…ì„ ì¶”ì í•œë‹¤.

`transitionTo()` ë©”ì„œë“œëŠ” ë‘ ë‹¨ê³„ë¡œ ì „í™˜ì„ ìˆ˜í–‰í•œë‹¤. ë¨¼ì € í˜„ì¬ ìŒì•…ì„ í˜ì´ë“œ ì•„ì›ƒí•˜ê³ , ì™„ì „íˆ ì‚¬ë¼ì§€ë©´ ë‹¤ìŒ ìŒì•…ì„ í˜ì´ë“œ ì¸í•œë‹¤. ê° ë‹¨ê³„ì˜ ì†ë„ë¥¼ ê°œë³„ì ìœ¼ë¡œ ì¡°ì ˆí•  ìˆ˜ ìˆì–´ ìƒí™©ì— ë§ëŠ” ìì—°ìŠ¤ëŸ¬ìš´ ì „í™˜ì´ ê°€ëŠ¥í•˜ë‹¤.

## 22.4 íš¨ê³¼ìŒ ì²˜ë¦¬

íš¨ê³¼ìŒì€ ì‚¬ìš©ìì˜ í–‰ë™ì— ì¦‰ê°ì ì¸ í”¼ë“œë°±ì„ ì œê³µí•˜ì—¬ ìƒí˜¸ì‘ìš©ì„ ë”ìš± ìƒìƒí•˜ê²Œ ë§Œë“ ë‹¤. íš¨ê³¼ìŒì€ ë°°ê²½ ìŒì•…ê³¼ ë‹¬ë¦¬ ì§§ê³  ë™ì‹œì— ì—¬ëŸ¬ ê°œê°€ ì¬ìƒë  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.

### 22.4.1 íš¨ê³¼ìŒ í’€(Pool) ì‹œìŠ¤í…œ

ê°™ì€ íš¨ê³¼ìŒì„ ë¹ ë¥´ê²Œ ì—°ì†ìœ¼ë¡œ ì¬ìƒí•´ì•¼ í•  ë•Œê°€ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì´ì•Œì´ ì—¬ëŸ¬ ë°œ ë°œì‚¬ë˜ê±°ë‚˜, ì—¬ëŸ¬ ì ì´ ë™ì‹œì— í”¼ê²©ë‹¹í•˜ëŠ” ê²½ìš°ë‹¤. ì´ëŸ° ìƒí™©ì„ ìœ„í•´ íš¨ê³¼ìŒ í’€ ì‹œìŠ¤í…œì„ êµ¬í˜„í•œë‹¤.

```cpp
#include <Siv3D.hpp>

// íš¨ê³¼ìŒ í’€ í´ë˜ìŠ¤
class SoundEffectPool
{
private:
    Array<Audio> audioPool;
    size_t currentIndex = 0;
    String soundPath;

public:
    // ìƒì„±ì: ì§€ì •ëœ ê°œìˆ˜ë§Œí¼ ê°™ì€ ì‚¬ìš´ë“œë¥¼ ë¯¸ë¦¬ ë¡œë“œ
    SoundEffectPool(const FilePath& path, size_t poolSize = 5)
        : soundPath(path)
    {
        for (size_t i = 0; i < poolSize; ++i)
        {
            Audio audio{ path };
            if (audio)
            {
                audioPool.push_back(std::move(audio));
            }
        }
    }

    // íš¨ê³¼ìŒ ì¬ìƒ
    void play(double volume = 1.0)
    {
        if (audioPool.isEmpty())
        {
            return;
        }

        // í˜„ì¬ ì¸ë±ìŠ¤ì˜ ì˜¤ë””ì˜¤ ì¬ìƒ
        audioPool[currentIndex].stop();  // ì´ì „ ì¬ìƒ ì¤‘ë‹¨
        audioPool[currentIndex].setVolume(volume);
        audioPool[currentIndex].play();

        // ë‹¤ìŒ ì¸ë±ìŠ¤ë¡œ ì´ë™ (ìˆœí™˜)
        currentIndex = (currentIndex + 1) % audioPool.size();
    }

    // ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ ì •ì§€
    void stopAll()
    {
        for (auto& audio : audioPool)
        {
            audio.stop();
        }
    }

    // í’€ í¬ê¸° í™•ì¸
    size_t size() const
    {
        return audioPool.size();
    }
};

void Main()
{
    Scene::SetBackground(ColorF{ 0.1, 0.1, 0.2 });

    // íš¨ê³¼ìŒ í’€ ìƒì„± (ë™ì‹œì— ìµœëŒ€ 8ê°œê¹Œì§€ ì¬ìƒ ê°€ëŠ¥)
    SoundEffectPool shootSound{ U"example/sound/button.mp3", 8 };
    SoundEffectPool hitSound{ U"example/sound/button.mp3", 5 };

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // íŒŒí‹°í´ íš¨ê³¼ë¥¼ ìœ„í•œ êµ¬ì¡°ì²´
    struct Particle
    {
        Vec2 pos;
        Vec2 velocity;
        double life;
        ColorF color;
    };

    Array<Particle> particles;

    while (System::Update())
    {
        // ë§ˆìš°ìŠ¤ ì™¼ìª½ í´ë¦­ìœ¼ë¡œ ì´ì•Œ ë°œì‚¬ íš¨ê³¼
        if (MouseL.pressed())
        {
            shootSound.play(0.3);
            
            // íŒŒí‹°í´ ìƒì„±
            for (int32 i = 0; i < 3; ++i)
            {
                Particle p;
                p.pos = Cursor::Pos();
                p.velocity = RandomVec2(Circle{ 0, 0, 150 });
                p.life = 1.0;
                p.color = ColorF{ 1.0, 0.8, 0.2 };
                particles.push_back(p);
            }
        }

        // ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½ í´ë¦­ìœ¼ë¡œ ì ì¤‘ íš¨ê³¼
        if (MouseR.down())
        {
            hitSound.play(0.5);
            
            // ì ì¤‘ íŒŒí‹°í´
            for (int32 i = 0; i < 10; ++i)
            {
                Particle p;
                p.pos = Cursor::Pos();
                p.velocity = RandomVec2(Circle{ 0, 0, 200 });
                p.life = 1.5;
                p.color = ColorF{ 1.0, 0.2, 0.2 };
                particles.push_back(p);
            }
        }

        // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
        for (auto& p : particles)
        {
            p.pos += p.velocity * Scene::DeltaTime();
            p.velocity *= 0.95;  // ê°ì†
            p.life -= Scene::DeltaTime();

            if (p.life > 0)
            {
                Circle{ p.pos, 5 }.draw(
                    ColorF{ p.color, p.life / 1.5 });
            }
        }

        // ìˆ˜ëª…ì´ ë‹¤í•œ íŒŒí‹°í´ ì œê±°
        particles.remove_if([](const Particle& p) { return p.life <= 0; });

        // ì•ˆë‚´ ë¬¸êµ¬
        font(U"ì¢Œí´ë¦­: ë°œì‚¬").draw(20, Vec2{ 20, 20 }, ColorF{ 0.8 });
        font(U"ìš°í´ë¦­: ì ì¤‘").draw(20, Vec2{ 20, 50 }, ColorF{ 0.8 });
        font(U"í™œì„± íŒŒí‹°í´: {}"_fmt(particles.size()))
            .draw(18, Vec2{ 20, 90 }, ColorF{ 0.6 });
    }
}
```

`SoundEffectPool` í´ë˜ìŠ¤ëŠ” ê°™ì€ ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—¬ëŸ¬ ê°œ ë¯¸ë¦¬ ë¡œë“œí•˜ì—¬ ë°°ì—´ì— ì €ì¥í•œë‹¤. ì¬ìƒ ìš”ì²­ì´ ì˜¤ë©´ í˜„ì¬ ì¸ë±ìŠ¤ì˜ ì˜¤ë””ì˜¤ë¥¼ ì¬ìƒí•˜ê³  ë‹¤ìŒ ì¸ë±ìŠ¤ë¡œ ì´ë™í•œë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì´ì „ íš¨ê³¼ìŒì´ ëë‚˜ì§€ ì•Šì•˜ì–´ë„ ìƒˆë¡œìš´ íš¨ê³¼ìŒì„ ì¬ìƒí•  ìˆ˜ ìˆë‹¤.

í’€ì˜ í¬ê¸°ëŠ” ë™ì‹œì— ì¬ìƒë  ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°œìˆ˜ë¥¼ ê²°ì •í•œë‹¤. í¬ê¸°ê°€ í´ìˆ˜ë¡ ë” ë§ì€ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ ë¹ ë¥¸ ì—°ì† ì¬ìƒì— ìœ ë¦¬í•˜ë‹¤. ì¼ë°˜ì ìœ¼ë¡œ 5~10ê°œ ì •ë„ë©´ ì¶©ë¶„í•˜ë‹¤.

### 22.4.2 íš¨ê³¼ìŒ ê´€ë¦¬ì

í”„ë¡œì íŠ¸ê°€ ì»¤ì§€ë©´ íš¨ê³¼ìŒë„ ë§ì•„ì§„ë‹¤. ì´ë¥¼ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê¸° ìœ„í•œ íš¨ê³¼ìŒ ê´€ë¦¬ìë¥¼ êµ¬í˜„í•œë‹¤.

```cpp
#include <Siv3D.hpp>

// íš¨ê³¼ìŒ ê´€ë¦¬ì í´ë˜ìŠ¤
class SoundEffectManager
{
private:
    struct SoundEffect
    {
        Array<Audio> pool;
        size_t currentIndex = 0;
        double defaultVolume = 1.0;
    };

    std::unordered_map<String, SoundEffect> effects;
    double masterVolume = 1.0;

public:
    // íš¨ê³¼ìŒ ë“±ë¡
    void registerEffect(const String& name, const FilePath& path,
                       size_t poolSize = 3, double defaultVolume = 1.0)
    {
        SoundEffect effect;
        effect.defaultVolume = defaultVolume;

        for (size_t i = 0; i < poolSize; ++i)
        {
            Audio audio{ path };
            if (audio)
            {
                effect.pool.push_back(std::move(audio));
            }
        }

        if (not effect.pool.isEmpty())
        {
            effects[name] = std::move(effect);
        }
    }

    // íš¨ê³¼ìŒ ì¬ìƒ
    void play(const String& name, double volumeMultiplier = 1.0)
    {
        if (not effects.contains(name))
        {
            return;
        }

        auto& effect = effects[name];
        if (effect.pool.isEmpty())
        {
            return;
        }

        Audio& audio = effect.pool[effect.currentIndex];
        audio.stop();
        audio.setVolume(effect.defaultVolume * volumeMultiplier * masterVolume);
        audio.play();

        effect.currentIndex = (effect.currentIndex + 1) % effect.pool.size();
    }

    // ë§ˆìŠ¤í„° ë³¼ë¥¨ ì„¤ì • (ëª¨ë“  íš¨ê³¼ìŒì— ì˜í–¥)
    void setMasterVolume(double volume)
    {
        masterVolume = Clamp(volume, 0.0, 1.0);
    }

    // ë§ˆìŠ¤í„° ë³¼ë¥¨ ê°€ì ¸ì˜¤ê¸°
    double getMasterVolume() const
    {
        return masterVolume;
    }

    // íŠ¹ì • íš¨ê³¼ìŒì˜ ê¸°ë³¸ ë³¼ë¥¨ ì„¤ì •
    void setEffectVolume(const String& name, double volume)
    {
        if (effects.contains(name))
        {
            effects[name].defaultVolume = Clamp(volume, 0.0, 1.0);
        }
    }

    // ëª¨ë“  íš¨ê³¼ìŒ ì •ì§€
    void stopAll()
    {
        for (auto& [name, effect] : effects)
        {
            for (auto& audio : effect.pool)
            {
                audio.stop();
            }
        }
    }
};

void Main()
{
    Scene::SetBackground(ColorF{ 0.15, 0.2, 0.25 });

    SoundEffectManager sfxManager;

    // ë‹¤ì–‘í•œ íš¨ê³¼ìŒ ë“±ë¡
    sfxManager.registerEffect(U"Click", U"example/sound/button.mp3", 3, 0.4);
    sfxManager.registerEffect(U"Hover", U"example/sound/button.mp3", 2, 0.2);
    sfxManager.registerEffect(U"Success", U"example/sound/button.mp3", 2, 0.6);
    sfxManager.registerEffect(U"Error", U"example/sound/button.mp3", 2, 0.5);

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // ë²„íŠ¼ë“¤
    const Rect clickButton{ 100, 150, 180, 60 };
    const Rect hoverButton{ 300, 150, 180, 60 };
    const Rect successButton{ 500, 150, 180, 60 };
    const Rect errorButton{ 300, 250, 180, 60 };

    // ë³¼ë¥¨ ìŠ¬ë¼ì´ë”
    const Rect volumeSlider{ 150, 350, 500, 20 };
    bool isDraggingSlider = false;
    double sliderValue = sfxManager.getMasterVolume();

    while (System::Update())
    {
        // í´ë¦­ ë²„íŠ¼
        const bool clickHover = clickButton.mouseOver();
        clickButton.draw(clickHover ? ColorF{ 0.5, 0.6, 0.8 } 
                                   : ColorF{ 0.3, 0.4, 0.6 });
        clickButton.drawFrame(2, ColorF{ 0.9 });
        font(U"í´ë¦­").drawAt(20, clickButton.center(), ColorF{ 0.9 });

        if (clickButton.leftClicked())
        {
            sfxManager.play(U"Click");
        }

        // í˜¸ë²„ ë²„íŠ¼
        const bool hoverHover = hoverButton.mouseOver();
        hoverButton.draw(hoverHover ? ColorF{ 0.6, 0.8, 0.5 } 
                                   : ColorF{ 0.4, 0.6, 0.3 });
        hoverButton.drawFrame(2, ColorF{ 0.9 });
        font(U"í˜¸ë²„").drawAt(20, hoverButton.center(), ColorF{ 0.9 });

        if (hoverButton.leftClicked())
        {
            sfxManager.play(U"Hover");
        }

        // ì„±ê³µ ë²„íŠ¼
        const bool successHover = successButton.mouseOver();
        successButton.draw(successHover ? ColorF{ 0.3, 0.8, 0.8 } 
                                       : ColorF{ 0.2, 0.6, 0.6 });
        successButton.drawFrame(2, ColorF{ 0.9 });
        font(U"ì„±ê³µ").drawAt(20, successButton.center(), ColorF{ 0.9 });

        if (successButton.leftClicked())
        {
            sfxManager.play(U"Success");
        }

        // ì—ëŸ¬ ë²„íŠ¼
        const bool errorHover = errorButton.mouseOver();
        errorButton.draw(errorHover ? ColorF{ 0.9, 0.4, 0.4 } 
                                   : ColorF{ 0.7, 0.2, 0.2 });
        errorButton.drawFrame(2, ColorF{ 0.9 });
        font(U"ì—ëŸ¬").drawAt(20, errorButton.center(), ColorF{ 0.9 });

        if (errorButton.leftClicked())
        {
            sfxManager.play(U"Error");
        }

        // ë³¼ë¥¨ ìŠ¬ë¼ì´ë”
        volumeSlider.draw(ColorF{ 0.3 });
        
        // ìŠ¬ë¼ì´ë” í•¸ë“¤ ìœ„ì¹˜ ê³„ì‚°
        const double handleX = volumeSlider.x + 
                              volumeSlider.w * sliderValue;
        const Circle handle{ handleX, volumeSlider.y + volumeSlider.h / 2.0, 15 };

        // ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ ì²˜ë¦¬
        if (handle.leftPressed() || 
            (isDraggingSlider && MouseL.pressed()))
        {
            isDraggingSlider = true;
            sliderValue = Clamp(
                (Cursor::Pos().x - volumeSlider.x) / volumeSlider.w,
                0.0, 1.0);
            sfxManager.setMasterVolume(sliderValue);
        }
        else if (MouseL.up())
        {
            isDraggingSlider = false;
        }

        // ìŠ¬ë¼ì´ë” ì±„ì›Œì§„ ë¶€ë¶„
        Rect{ volumeSlider.pos, 
              static_cast<int32>(volumeSlider.w * sliderValue), 
              volumeSlider.h }
            .draw(ColorF{ 0.4, 0.7, 0.4 });

        // ìŠ¬ë¼ì´ë” í…Œë‘ë¦¬ì™€ í•¸ë“¤
        volumeSlider.drawFrame(2, ColorF{ 0.7 });
        handle.draw(ColorF{ 0.9 });
        handle.drawFrame(2, ColorF{ 0.3 });

        // ë³¼ë¥¨ í‘œì‹œ
        font(U"ë§ˆìŠ¤í„° ë³¼ë¥¨: {:.0f}%"_fmt(sliderValue * 100))
            .drawAt(20, Vec2{ 400, 400 }, ColorF{ 0.9 });
    }
}
```

`SoundEffectManager` í´ë˜ìŠ¤ëŠ” ì—¬ëŸ¬ íš¨ê³¼ìŒì„ ì¤‘ì•™ì—ì„œ ê´€ë¦¬í•œë‹¤. ê° íš¨ê³¼ìŒì€ ìì²´ í’€ê³¼ ê¸°ë³¸ ë³¼ë¥¨ì„ ê°€ì§€ë©°, ë§ˆìŠ¤í„° ë³¼ë¥¨ìœ¼ë¡œ ëª¨ë“  íš¨ê³¼ìŒì˜ ë³¼ë¥¨ì„ í•œ ë²ˆì— ì¡°ì ˆí•  ìˆ˜ ìˆë‹¤.

`play()` ë©”ì„œë“œì— `volumeMultiplier` ë§¤ê°œë³€ìˆ˜ë¥¼ ì „ë‹¬í•˜ë©´ íŠ¹ì • ìƒí™©ì—ì„œ íš¨ê³¼ìŒì˜ ë³¼ë¥¨ì„ ì„ì‹œë¡œ ì¡°ì ˆí•  ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í¬ë¦¬í‹°ì»¬ íˆíŠ¸ ì‹œ ì¼ë°˜ íˆíŠ¸ ì‚¬ìš´ë“œë¥¼ ë” í¬ê²Œ ì¬ìƒí•˜ëŠ” ì‹ì´ë‹¤.

## 22.5 ë³¼ë¥¨ ì¡°ì ˆê³¼ ì‚¬ìš´ë“œ ì´í™íŠ¸

ì˜¤ë””ì˜¤ì˜ ë³¼ë¥¨ì„ ì¡°ì ˆí•˜ê³  ë‹¤ì–‘í•œ ì´í™íŠ¸ë¥¼ ì ìš©í•˜ì—¬ ê²Œì„ì˜ ëª°ì…ê°ì„ ë†’ì¼ ìˆ˜ ìˆë‹¤. Siv3DëŠ” ëª‡ ê°€ì§€ ìœ ìš©í•œ ì˜¤ë””ì˜¤ ì¡°ì‘ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

### 22.5.1 ë™ì  ë³¼ë¥¨ ì¡°ì ˆ

ê²Œì„ ìƒí™©ì— ë”°ë¼ ë³¼ë¥¨ì„ ë™ì ìœ¼ë¡œ ì¡°ì ˆí•˜ëŠ” ì˜ˆì œë‹¤. í”Œë ˆì´ì–´ê°€ ìœ„í—˜í•œ ìƒí™©ì— ì²˜í•˜ë©´ ë°°ê²½ ìŒì•… ë³¼ë¥¨ì„ ë‚®ì¶”ê³  ê¸´ì¥ê° ìˆëŠ” íš¨ê³¼ìŒì„ ê°•ì¡°í•˜ëŠ” ë°©ì‹ì´ë‹¤.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.2, 0.25, 0.3 });

    // ë°°ê²½ ìŒì•…ê³¼ íš¨ê³¼ìŒ
    const Audio bgm{ Audio::Stream, U"example/sound/music.mp3" };
    const Audio alarmSound{ U"example/sound/button.mp3" };

    bgm.setLoop(true);
    bgm.setVolume(0.5);
    bgm.play();

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // ê²Œì„ ìƒíƒœ ì‹œë®¬ë ˆì´ì…˜
    double dangerLevel = 0.0;  // 0.0 (ì•ˆì „) ~ 1.0 (ìœ„í—˜)
    const double dangerIncreaseRate = 0.15;
    const double dangerDecreaseRate = 0.1;

    // ì•ŒëŒ íƒ€ì´ë¨¸
    double alarmTimer = 0.0;
    const double alarmInterval = 1.0;  // 1ì´ˆë§ˆë‹¤ ì•ŒëŒ

    const Rect increaseButton{ 250, 250, 150, 60 };
    const Rect decreaseButton{ 450, 250, 150, 60 };

    while (System::Update())
    {
        // ìœ„í—˜ë„ ì¦ê°€ ë²„íŠ¼
        if (increaseButton.mouseOver())
        {
            increaseButton.draw(ColorF{ 0.9, 0.5, 0.5 });
        }
        else
        {
            increaseButton.draw(ColorF{ 0.7, 0.3, 0.3 });
        }
        increaseButton.drawFrame(2, ColorF{ 0.9 });
        font(U"ìœ„í—˜ ì¦ê°€").drawAt(18, increaseButton.center(), ColorF{ 0.9 });

        if (increaseButton.leftPressed())
        {
            dangerLevel = Min(dangerLevel + 
                             dangerIncreaseRate * Scene::DeltaTime(), 1.0);
        }

        // ìœ„í—˜ë„ ê°ì†Œ ë²„íŠ¼
        if (decreaseButton.mouseOver())
        {
            decreaseButton.draw(ColorF{ 0.5, 0.8, 0.5 });
        }
        else
        {
            decreaseButton.draw(ColorF{ 0.3, 0.6, 0.3 });
        }
        decreaseButton.drawFrame(2, ColorF{ 0.9 });
        font(U"ìœ„í—˜ ê°ì†Œ").drawAt(18, decreaseButton.center(), ColorF{ 0.9 });

        if (decreaseButton.leftPressed())
        {
            dangerLevel = Max(dangerLevel - 
                             dangerDecreaseRate * Scene::DeltaTime(), 0.0);
        }

        // ìì—° ê°ì†Œ
        if (not increaseButton.leftPressed() && 
            not decreaseButton.leftPressed())
        {
            dangerLevel = Max(dangerLevel - 
                             0.05 * Scene::DeltaTime(), 0.0);
        }

        // BGM ë³¼ë¥¨ì„ ìœ„í—˜ë„ì— ë°˜ë¹„ë¡€í•˜ê²Œ ì¡°ì ˆ
        const double bgmVolume = 0.5 * (1.0 - dangerLevel * 0.7);
        bgm.setVolume(bgmVolume);

        // ìœ„í—˜ë„ê°€ ë†’ìœ¼ë©´ ì•ŒëŒ ì¬ìƒ
        if (dangerLevel > 0.5)
        {
            alarmTimer += Scene::DeltaTime();
            
            if (alarmTimer >= alarmInterval)
            {
                // ìœ„í—˜ë„ì— ë¹„ë¡€í•˜ì—¬ ì•ŒëŒ ë³¼ë¥¨ ì¦ê°€
                const double alarmVolume = 0.3 + dangerLevel * 0.5;
                alarmSound.stop();
                alarmSound.setVolume(alarmVolume);
                alarmSound.play();
                
                alarmTimer = 0.0;
            }
        }
        else
        {
            alarmTimer = 0.0;
        }

        // ìœ„í—˜ë„ ì‹œê°í™”
        const Rect dangerBar{ 200, 150, 400, 40 };
        dangerBar.draw(ColorF{ 0.2 });
        
        Rect{ dangerBar.pos, 
              static_cast<int32>(dangerBar.w * dangerLevel), 
              dangerBar.h }
            .draw(ColorF{ 1.0 - dangerLevel, dangerLevel, 0.2 });
        
        dangerBar.drawFrame(3, ColorF{ 0.9 });

        // ì •ë³´ í‘œì‹œ
        font(U"ìœ„í—˜ë„: {:.0f}%"_fmt(dangerLevel * 100))
            .drawAt(22, Vec2{ 400, 350 }, ColorF{ 0.9 });
        
        font(U"BGM ë³¼ë¥¨: {:.0f}%"_fmt(bgmVolume * 100))
            .draw(18, Vec2{ 250, 390 }, ColorF{ 0.7 });

        // ìœ„í—˜ ê²½ê³ 
        if (dangerLevel > 0.7)
        {
            const double pulse = 0.5 + 0.5 * Math::Sin(Scene::Time() * 4.0);
            font(U"âš  ìœ„í—˜!").drawAt(24, Vec2{ 400, 430 }, 
                                    ColorF{ 1.0, 0.3, 0.3, pulse });
        }
    }
}
```

ì´ ì˜ˆì œëŠ” ê²Œì„ì˜ ìœ„í—˜ ìƒí™©ì„ ì‹œë®¬ë ˆì´ì…˜í•œë‹¤. ìœ„í—˜ë„ê°€ ì¦ê°€í•˜ë©´ ë°°ê²½ ìŒì•…ì˜ ë³¼ë¥¨ì´ ìë™ìœ¼ë¡œ ê°ì†Œí•˜ê³ , ì¼ì • ìˆ˜ì¤€ì„ ë„˜ìœ¼ë©´ ê²½ê³ ìŒì´ ì¬ìƒëœë‹¤. ì´ëŸ° ë°©ì‹ìœ¼ë¡œ ì˜¤ë””ì˜¤ë¥¼ í†µí•´ ê²Œì„ ìƒíƒœë¥¼ ì§ê´€ì ìœ¼ë¡œ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.

### 22.5.2 3D ì‚¬ìš´ë“œì™€ íŒ¨ë‹

Siv3DëŠ” ìŠ¤í…Œë ˆì˜¤ íŒ¨ë‹ì„ ì§€ì›í•˜ì—¬ ì†Œë¦¬ì˜ ë°©í–¥ì„±ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê°ì²´ì˜ ì†Œë¦¬ë¥¼ êµ¬í˜„í•˜ëŠ” ì˜ˆì œë‹¤.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.1, 0.15, 0.2 });

    const Audio moveSound{ U"example/sound/button.mp3" };
    moveSound.setLoop(true);

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // ì´ë™í•˜ëŠ” ê°ì²´
    Vec2 objectPos{ 100, 300 };
    Vec2 objectVelocity{ 200, 0 };

    // ë¦¬ìŠ¤ë„ˆ(í”Œë ˆì´ì–´) ìœ„ì¹˜
    const Vec2 listenerPos{ 400, 300 };

    bool isSoundPlaying = false;

    while (System::Update())
    {
        // ê°ì²´ ì´ë™
        objectPos += objectVelocity * Scene::DeltaTime();

        // í™”ë©´ ê²½ê³„ì—ì„œ ë°˜ì‚¬
        if (objectPos.x < 50 || objectPos.x > Scene::Width() - 50)
        {
            objectVelocity.x *= -1;
            objectPos.x = Clamp(objectPos.x, 50.0, 
                               static_cast<double>(Scene::Width() - 50));
        }

        // ë¦¬ìŠ¤ë„ˆë¡œë¶€í„°ì˜ ê±°ë¦¬ ê³„ì‚°
        const double distance = objectPos.distanceFrom(listenerPos);
        const double maxDistance = 400.0;

        // ê±°ë¦¬ ê¸°ë°˜ ë³¼ë¥¨ ê³„ì‚° (ì—­ì œê³± ë²•ì¹™ ê·¼ì‚¬)
        const double volumeByDistance = 
            Clamp(1.0 - (distance / maxDistance), 0.0, 1.0);

        // ì¢Œìš° íŒ¨ë‹ ê³„ì‚° (-1.0: ì™¼ìª½, 0.0: ì¤‘ì•™, 1.0: ì˜¤ë¥¸ìª½)
        const double pan = Clamp(
            (objectPos.x - listenerPos.x) / 300.0, -1.0, 1.0);

        // ì‚¬ìš´ë“œê°€ ì¬ìƒ ì¤‘ì´ ì•„ë‹ˆë©´ ì‹œì‘
        if (not isSoundPlaying)
        {
            moveSound.play();
            isSoundPlaying = true;
        }

        // ë³¼ë¥¨ê³¼ íŒ¨ë‹ ì ìš©
        moveSound.setVolume(volumeByDistance * 0.6);
        moveSound.setPan(pan);

        // ì‹œê°í™”
        // ë¦¬ìŠ¤ë„ˆ ê·¸ë¦¬ê¸°
        Circle{ listenerPos, 30 }.draw(ColorF{ 0.3, 0.6, 0.8 });
        Circle{ listenerPos, 30 }.drawFrame(3, ColorF{ 0.5, 0.8, 1.0 });
        font(U"ğŸ‘‚").drawAt(24, listenerPos, ColorF{ 0.9 });

        // ìµœëŒ€ ì²­ì·¨ ë²”ìœ„
        Circle{ listenerPos, maxDistance }
            .drawFrame(2, ColorF{ 0.3, 0.3, 0.3 });

        // ì´ë™í•˜ëŠ” ê°ì²´
        const double objectSize = 20 + volumeByDistance * 20;
        Circle{ objectPos, objectSize }.draw(ColorF{ 1.0, 0.5, 0.3 });
        Circle{ objectPos, objectSize }.drawFrame(2, ColorF{ 1.0, 0.7, 0.5 });

        // ì—°ê²°ì„ 
        Line{ listenerPos, objectPos }.draw(2, 
            ColorF{ 0.5, 0.5, 0.5, 0.3 });

        // ì •ë³´ í‘œì‹œ
        font(U"3D ì‚¬ìš´ë“œ ë°ëª¨").draw(24, Vec2{ 20, 20 }, ColorF{ 0.9 });
        font(U"ê±°ë¦¬: {:.0f}"_fmt(distance))
            .draw(18, Vec2{ 20, 60 }, ColorF{ 0.7 });
        font(U"ë³¼ë¥¨: {:.0f}%"_fmt(volumeByDistance * 100))
            .draw(18, Vec2{ 20, 85 }, ColorF{ 0.7 });
        font(U"íŒ¨ë‹: {:.2f}"_fmt(pan))
            .draw(18, Vec2{ 20, 110 }, ColorF{ 0.7 });

        // íŒ¨ë‹ ì‹œê°í™” (ìŠ¤í…Œë ˆì˜¤ ë¯¸í„°)
        const Rect leftMeter{ 20, 140, 80, 20 };
        const Rect rightMeter{ 110, 140, 80, 20 };

        leftMeter.draw(ColorF{ 0.3 });
        rightMeter.draw(ColorF{ 0.3 });

        const double leftVolume = volumeByDistance * Max(1.0 - pan, 0.0);
        const double rightVolume = volumeByDistance * Max(1.0 + pan, 0.0);

        Rect{ leftMeter.pos, static_cast<int32>(leftMeter.w * leftVolume), 
              leftMeter.h }
            .draw(ColorF{ 0.3, 0.8, 0.3 });
        
        Rect{ rightMeter.pos, static_cast<int32>(rightMeter.w * rightVolume), 
              rightMeter.h }
            .draw(ColorF{ 0.3, 0.8, 0.3 });

        leftMeter.drawFrame(2, ColorF{ 0.7 });
        rightMeter.drawFrame(2, ColorF{ 0.7 });

        font(U"L").draw(16, leftMeter.pos.movedBy(-18, 2), ColorF{ 0.7 });
        font(U"R").draw(16, rightMeter.pos.movedBy(-18, 2), ColorF{ 0.7 });
    }
}
```

`setPan()` ë©”ì„œë“œëŠ” -1.0(ì™„ì „íˆ ì™¼ìª½)ì—ì„œ 1.0(ì™„ì „íˆ ì˜¤ë¥¸ìª½) ì‚¬ì´ì˜ ê°’ì„ ë°›ëŠ”ë‹¤. 0.0ì€ ì¤‘ì•™ì„ ì˜ë¯¸í•œë‹¤. ì´ë¥¼ ê°ì²´ì˜ ìœ„ì¹˜ì— ë”°ë¼ ë™ì ìœ¼ë¡œ ì¡°ì ˆí•˜ë©´ ì†Œë¦¬ê°€ ì–´ë””ì„œ ë‚˜ëŠ”ì§€ ì§ê´€ì ìœ¼ë¡œ ì•Œ ìˆ˜ ìˆë‹¤.

ê±°ë¦¬ì— ë”°ë¥¸ ë³¼ë¥¨ ê°ì‡ ë„ í•¨ê»˜ ì ìš©í•˜ë©´ ë”ìš± í˜„ì‹¤ì ì¸ ì‚¬ìš´ë“œë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤. ì‹¤ì œ ê²Œì„ì—ì„œëŠ” ì¥ì• ë¬¼ì´ë‚˜ í™˜ê²½ì— ë”°ë¼ ì†Œë¦¬ê°€ ê°ì‡ í•˜ëŠ” ì •ë„ë¥¼ ë‹¤ë¥´ê²Œ ì ìš©í•  ìˆ˜ë„ ìˆë‹¤.

### 22.5.3 ì¬ìƒ ì†ë„ ì¡°ì ˆ

Siv3DëŠ” ì˜¤ë””ì˜¤ì˜ ì¬ìƒ ì†ë„ë¥¼ ì¡°ì ˆí•  ìˆ˜ ìˆë‹¤. ì†ë„ë¥¼ ë³€ê²½í•˜ë©´ í”¼ì¹˜(ìŒë†’ì´)ë„ í•¨ê»˜ ë³€í•œë‹¤. ì´ë¥¼ í™œìš©í•˜ì—¬ íŠ¹ìˆ˜ íš¨ê³¼ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.15, 0.2, 0.25 });

    const Audio voice{ U"example/sound/button.mp3" };

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    double playbackSpeed = 1.0;  // ê¸°ë³¸ ì†ë„
    const Rect speedSlider{ 200, 250, 400, 20 };
    bool isDragging = false;

    const Rect playButton{ 320, 320, 160, 60 };

    // í”„ë¦¬ì…‹ ë²„íŠ¼ë“¤
    const Rect slowButton{ 200, 400, 100, 50 };
    const Rect normalButton{ 320, 400, 100, 50 };
    const Rect fastButton{ 440, 400, 100, 50 };
    const Rect veryFastButton{ 560, 400, 100, 50 };

    while (System::Update())
    {
        // ì¬ìƒ ë²„íŠ¼
        if (playButton.mouseOver())
        {
            playButton.draw(ColorF{ 0.5, 0.7, 0.9 });
        }
        else
        {
            playButton.draw(ColorF{ 0.3, 0.5, 0.7 });
        }
        playButton.drawFrame(2, ColorF{ 0.9 });
        font(U"ì¬ìƒ").drawAt(22, playButton.center(), ColorF{ 0.9 });

        if (playButton.leftClicked())
        {
            voice.stop();
            voice.setSpeed(playbackSpeed);
            voice.play();
        }

        // ì†ë„ ìŠ¬ë¼ì´ë”
        speedSlider.draw(ColorF{ 0.3 });

        // ìŠ¬ë¼ì´ë” ê°’ ë²”ìœ„: 0.5 ~ 2.0
        const double minSpeed = 0.5;
        const double maxSpeed = 2.0;
        const double normalizedSpeed = 
            (playbackSpeed - minSpeed) / (maxSpeed - minSpeed);

        const double handleX = speedSlider.x + 
                              speedSlider.w * normalizedSpeed;
        const Circle handle{ handleX, 
                           speedSlider.y + speedSlider.h / 2.0, 15 };

        // ë“œë˜ê·¸ ì²˜ë¦¬
        if (handle.leftPressed() || (isDragging && MouseL.pressed()))
        {
            isDragging = true;
            const double normalized = Clamp(
                (Cursor::Pos().x - speedSlider.x) / speedSlider.w,
                0.0, 1.0);
            playbackSpeed = minSpeed + normalized * (maxSpeed - minSpeed);
        }
        else if (MouseL.up())
        {
            isDragging = false;
        }

        // ìŠ¬ë¼ì´ë” ì±„ì›Œì§„ ë¶€ë¶„
        Rect{ speedSlider.pos, 
              static_cast<int32>(speedSlider.w * normalizedSpeed), 
              speedSlider.h }
            .draw(ColorF{ 0.4, 0.6, 0.8 });

        speedSlider.drawFrame(2, ColorF{ 0.7 });
        handle.draw(ColorF{ 0.9 });
        handle.drawFrame(2, ColorF{ 0.3 });

        // í”„ë¦¬ì…‹ ë²„íŠ¼ë“¤
        // ëŠë¦¼ (0.5x)
        if (slowButton.mouseOver())
        {
            slowButton.draw(ColorF{ 0.6, 0.7, 0.8 });
        }
        else
        {
            slowButton.draw(ColorF{ 0.4, 0.5, 0.6 });
        }
        slowButton.drawFrame(2, ColorF{ 0.8 });
        font(U"0.5x").drawAt(18, slowButton.center(), ColorF{ 0.9 });

        if (slowButton.leftClicked())
        {
            playbackSpeed = 0.5;
        }

        // ë³´í†µ (1.0x)
        if (normalButton.mouseOver())
        {
            normalButton.draw(ColorF{ 0.5, 0.8, 0.5 });
        }
        else
        {
            normalButton.draw(ColorF{ 0.3, 0.6, 0.3 });
        }
        normalButton.drawFrame(2, ColorF{ 0.8 });
        font(U"1.0x").drawAt(18, normalButton.center(), ColorF{ 0.9 });

        if (normalButton.leftClicked())
        {
            playbackSpeed = 1.0;
        }

        // ë¹ ë¦„ (1.5x)
        if (fastButton.mouseOver())
        {
            fastButton.draw(ColorF{ 0.9, 0.7, 0.4 });
        }
        else
        {
            fastButton.draw(ColorF{ 0.7, 0.5, 0.2 });
        }
        fastButton.drawFrame(2, ColorF{ 0.8 });
        font(U"1.5x").drawAt(18, fastButton.center(), ColorF{ 0.9 });

        if (fastButton.leftClicked())
        {
            playbackSpeed = 1.5;
        }

        // ë§¤ìš° ë¹ ë¦„ (2.0x)
        if (veryFastButton.mouseOver())
        {
            veryFastButton.draw(ColorF{ 0.9, 0.4, 0.4 });
        }
        else
        {
            veryFastButton.draw(ColorF{ 0.7, 0.2, 0.2 });
        }
        veryFastButton.drawFrame(2, ColorF{ 0.8 });
        font(U"2.0x").drawAt(18, veryFastButton.center(), ColorF{ 0.9 });

        if (veryFastButton.leftClicked())
        {
            playbackSpeed = 2.0;
        }

        // ì •ë³´ í‘œì‹œ
        font(U"ì¬ìƒ ì†ë„ ì¡°ì ˆ").draw(24, Vec2{ 250, 180 }, ColorF{ 0.9 });
        font(U"ì†ë„: {:.2f}x"_fmt(playbackSpeed))
            .drawAt(20, Vec2{ 400, 480 }, ColorF{ 0.8 });

        // í˜„ì¬ ì¬ìƒ ì¤‘ì´ë©´ í‘œì‹œ
        if (voice.isPlaying())
        {
            const double progress = voice.posSec() / voice.lengthSec();
            const Rect progressBar{ 200, 520, 400, 10 };
            progressBar.draw(ColorF{ 0.3 });
            Rect{ progressBar.pos, 
                  static_cast<int32>(progressBar.w * progress), 
                  progressBar.h }
                .draw(ColorF{ 0.3, 0.8, 0.3 });
            progressBar.drawFrame(1, ColorF{ 0.7 });
        }
    }
}
```

`setSpeed()` ë©”ì„œë“œë¡œ ì¬ìƒ ì†ë„ë¥¼ ì¡°ì ˆí•œë‹¤. 0.5ëŠ” ì ˆë°˜ ì†ë„(í•œ ì˜¥íƒ€ë¸Œ ë‚®ì€ ìŒ), 2.0ì€ ë‘ ë°° ì†ë„(í•œ ì˜¥íƒ€ë¸Œ ë†’ì€ ìŒ)ë¥¼ ì˜ë¯¸í•œë‹¤. ê²Œì„ì—ì„œ ìŠ¬ë¡œìš° ëª¨ì…˜ íš¨ê³¼ë‚˜ íŠ¹ìˆ˜ ëŠ¥ë ¥ ì‚¬ìš© ì‹œ ì‹œê°„ ì™œê³¡ íš¨ê³¼ë¥¼ í‘œí˜„í•  ë•Œ ìœ ìš©í•˜ë‹¤.

ì£¼ì˜í•  ì ì€ ì¬ìƒ ì†ë„ë¥¼ ë³€ê²½í•˜ë©´ ìŒë†’ì´ë„ í•¨ê»˜ ë³€í•œë‹¤ëŠ” ê²ƒì´ë‹¤. ìŒë†’ì´ëŠ” ê·¸ëŒ€ë¡œ ë‘ê³  ì†ë„ë§Œ ë³€ê²½í•˜ë ¤ë©´ ë³„ë„ì˜ ì˜¤ë””ì˜¤ ì²˜ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í•„ìš”í•˜ë‹¤.

## 22.6 ì‹¤ìŠµ ë¬¸ì œ

ì´ë²ˆ ì¥ì—ì„œ ë°°ìš´ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ë‹¤ìŒ ë¬¸ì œë“¤ì„ í•´ê²°í•œë‹¤.

**ë¬¸ì œ 1: ë¦¬ë“¬ ê²Œì„ ê¸°ì´ˆ**

ê°„ë‹¨í•œ ë¦¬ë“¬ ê²Œì„ì„ ë§Œë“ ë‹¤. í™”ë©´ ìœ„ì—ì„œ ë…¸íŠ¸ê°€ ë‚´ë ¤ì˜¤ê³ , íƒ€ì´ë°ì— ë§ì¶° í‚¤ë¥¼ ëˆ„ë¥´ë©´ íš¨ê³¼ìŒì´ ì¬ìƒë˜ë©° ì ìˆ˜ê°€ ì¦ê°€í•œë‹¤. ë°°ê²½ ìŒì•…ë„ ì¬ìƒë˜ì–´ì•¼ í•œë‹¤.

ìš”êµ¬ì‚¬í•­ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. ë°°ê²½ ìŒì•…ì´ ë°˜ë³µ ì¬ìƒë˜ì–´ì•¼ í•˜ê³ , ë…¸íŠ¸ê°€ ì¼ì •í•œ ê°„ê²©ìœ¼ë¡œ ìœ„ì—ì„œ ì•„ë˜ë¡œ ë‚´ë ¤ì™€ì•¼ í•œë‹¤. íƒ€ì´ë° ë¼ì¸ì— ë…¸íŠ¸ê°€ ë‹¿ì•˜ì„ ë•Œ ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆ„ë¥´ë©´ ì„±ê³µ íš¨ê³¼ìŒì´ ì¬ìƒë˜ë©°, íƒ€ì´ë°ì´ ë§ì§€ ì•Šìœ¼ë©´ ì‹¤íŒ¨ íš¨ê³¼ìŒì´ ì¬ìƒëœë‹¤. ì ìˆ˜ ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ê³  ì™„ë²½í•œ íƒ€ì´ë°, ì¢‹ì€ íƒ€ì´ë°, ì‹¤íŒ¨ë¥¼ êµ¬ë¶„í•œë‹¤.

**ë¬¸ì œ 2: ì‚¬ìš´ë“œ ë¯¹ì„œ**

ì—¬ëŸ¬ ì‚¬ìš´ë“œ íŠ¸ë™ì„ ë™ì‹œì— ì¬ìƒí•˜ê³  ê°ê°ì˜ ë³¼ë¥¨ì„ ë…ë¦½ì ìœ¼ë¡œ ì¡°ì ˆí•  ìˆ˜ ìˆëŠ” ì‚¬ìš´ë“œ ë¯¹ì„œë¥¼ ë§Œë“ ë‹¤.

ìš”êµ¬ì‚¬í•­ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. ìµœì†Œ 3ê°œì˜ ë‹¤ë¥¸ ì‚¬ìš´ë“œ íŠ¸ë™ì„ ë¡œë“œí•˜ê³ , ê° íŠ¸ë™ë§ˆë‹¤ ê°œë³„ ë³¼ë¥¨ ìŠ¬ë¼ì´ë”ë¥¼ ì œê³µí•œë‹¤. ë§ˆìŠ¤í„° ë³¼ë¥¨ ìŠ¬ë¼ì´ë”ë¡œ ì „ì²´ ë³¼ë¥¨ì„ ì¡°ì ˆí•  ìˆ˜ ìˆì–´ì•¼ í•˜ë©°, ê° íŠ¸ë™ì˜ ì¬ìƒ/ì¼ì‹œì •ì§€/ì •ì§€ ë²„íŠ¼ì„ êµ¬í˜„í•œë‹¤. í˜„ì¬ ì¬ìƒ ìœ„ì¹˜ë¥¼ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•œë‹¤.

**ë¬¸ì œ 3: ìœ„ì¹˜ ê¸°ë°˜ ì‚¬ìš´ë“œ ì‹œë®¬ë ˆì´ì…˜**

í”Œë ˆì´ì–´ê°€ ì´ë™í•  ìˆ˜ ìˆê³ , ë§µì— ë°°ì¹˜ëœ ì‚¬ìš´ë“œ ì†ŒìŠ¤ì—ì„œ ë‚˜ëŠ” ì†Œë¦¬ê°€ ê±°ë¦¬ì™€ ë°©í–¥ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ë“¤ë¦¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ì„ ë§Œë“ ë‹¤.

ìš”êµ¬ì‚¬í•­ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. í™”ì‚´í‘œ í‚¤ë¡œ í”Œë ˆì´ì–´ë¥¼ ì´ë™ì‹œí‚¬ ìˆ˜ ìˆì–´ì•¼ í•˜ê³ , ë§µì— ì—¬ëŸ¬ ê°œì˜ ì‚¬ìš´ë“œ ì†ŒìŠ¤ë¥¼ ë°°ì¹˜í•œë‹¤. ê° ì‚¬ìš´ë“œ ì†ŒìŠ¤ê¹Œì§€ì˜ ê±°ë¦¬ì— ë”°ë¼ ë³¼ë¥¨ì´ ê°ì‡ ë˜ë©°, ì¢Œìš° ë°©í–¥ì— ë”°ë¼ ìŠ¤í…Œë ˆì˜¤ íŒ¨ë‹ì´ ì ìš©ëœë‹¤. ê°€ì¥ ê°€ê¹Œìš´ ì‚¬ìš´ë“œ ì†ŒìŠ¤ë¥¼ ì‹œê°ì ìœ¼ë¡œ ê°•ì¡° í‘œì‹œí•œë‹¤.

## 22.7 ì‹¬í™” ë‚´ìš©

### 22.7.1 ì˜¤ë””ì˜¤ íŒŒí˜• ì‹œê°í™”

ì¬ìƒ ì¤‘ì¸ ì˜¤ë””ì˜¤ì˜ íŒŒí˜•ì´ë‚˜ ìŠ¤í™íŠ¸ëŸ¼ì„ ì‹œê°í™”í•˜ë©´ ë”ìš± í’ë¶€í•œ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•  ìˆ˜ ìˆë‹¤. Siv3Dì˜ FFT ê¸°ëŠ¥ì„ í™œìš©í•œ ì˜ˆì œë‹¤.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.05, 0.05, 0.1 });

    const Audio audio{ Audio::Stream, U"example/sound/music.mp3" };
    audio.setLoop(true);
    audio.play();

    // FFT ê²°ê³¼ë¥¼ ì €ì¥í•  ë°°ì—´
    FFTResult fft;

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    while (System::Update())
    {
        // FFT ê³„ì‚° (ì£¼íŒŒìˆ˜ ë¶„ì„)
        FFT::Analyze(fft, audio);

        // ìŠ¤í™íŠ¸ëŸ¼ ê·¸ë¦¬ê¸° (ì €ì£¼íŒŒë¶€í„° ê³ ì£¼íŒŒê¹Œì§€)
        const int32 barCount = 60;
        const double barWidth = Scene::Width() / static_cast<double>(barCount);

        for (int32 i = 0; i < barCount; ++i)
        {
            // FFT ê²°ê³¼ì—ì„œ í•´ë‹¹ ì£¼íŒŒìˆ˜ ëŒ€ì—­ì˜ ê°’ ê°€ì ¸ì˜¤ê¸°
            const double value = fft.buffer[i] * 4.0;  // ì¦í­
            const double height = Min(value * Scene::Height(), 
                                     static_cast<double>(Scene::Height()));

            // ì£¼íŒŒìˆ˜ì— ë”°ë¼ ìƒ‰ìƒ ë³€í™”
            const double hue = i / static_cast<double>(barCount) * 240.0;
            const ColorF color = HSV{ hue, 0.8, 0.9 };

            // ë§‰ëŒ€ ê·¸ë¦¬ê¸°
            const RectF bar{ i * barWidth, 
                           Scene::Height() - height, 
                           barWidth - 2, 
                           height };
            bar.draw(color);
        }

        // íŒŒí˜• ê·¸ë¦¬ê¸° (ì‹œê°„ ì˜ì—­)
        const size_t waveformSize = 
            Min<size_t>(fft.buffer.size(), 800);
        for (size_t i = 1; i < waveformSize; ++i)
        {
            const double x1 = (i - 1) * Scene::Width() / 
                             static_cast<double>(waveformSize);
            const double x2 = i * Scene::Width() / 
                             static_cast<double>(waveformSize);
            
            const double y1 = Scene::Height() / 2.0 + 
                             fft.buffer[i - 1] * 200;
            const double y2 = Scene::Height() / 2.0 + 
                             fft.buffer[i] * 200;

            Line{ x1, y1, x2, y2 }.draw(2, ColorF{ 0.3, 0.8, 1.0, 0.5 });
        }

        // ì¤‘ì•™ì„ 
        Line{ 0, Scene::Height() / 2.0, 
              Scene::Width(), Scene::Height() / 2.0 }
            .draw(1, ColorF{ 0.5, 0.5, 0.5, 0.3 });

        // ì •ë³´ í‘œì‹œ
        font(U"ì˜¤ë””ì˜¤ ì‹œê°í™”").draw(20, Vec2{ 20, 20 }, 
                                    ColorF{ 0.9, 0.9, 0.9, 0.8 });
        font(U"{:.1f} / {:.1f} ì´ˆ"_fmt(audio.posSec(), audio.lengthSec()))
            .draw(16, Vec2{ 20, 50 }, ColorF{ 0.7, 0.7, 0.7, 0.8 });
    }
}
```

FFT(ê³ ì† í‘¸ë¦¬ì— ë³€í™˜)ëŠ” ì‹œê°„ ì˜ì—­ì˜ ì‹ í˜¸ë¥¼ ì£¼íŒŒìˆ˜ ì˜ì—­ìœ¼ë¡œ ë³€í™˜í•œë‹¤. ì´ë¥¼ í†µí•´ í˜„ì¬ ì¬ìƒ ì¤‘ì¸ ì˜¤ë””ì˜¤ì— ì–´ë–¤ ì£¼íŒŒìˆ˜ ì„±ë¶„ì´ ì–¼ë§ˆë‚˜ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆë‹¤. ë‚®ì€ ì¸ë±ìŠ¤ëŠ” ì €ìŒ, ë†’ì€ ì¸ë±ìŠ¤ëŠ” ê³ ìŒì„ ë‚˜íƒ€ë‚¸ë‹¤.

ì´ëŸ° ì‹œê°í™”ëŠ” ìŒì•… í”Œë ˆì´ì–´ë‚˜ ì˜¤ë””ì˜¤ í¸ì§‘ í”„ë¡œê·¸ë¨ì—ì„œ í”íˆ ë³¼ ìˆ˜ ìˆìœ¼ë©°, ì‚¬ìš©ìì—ê²Œ ì‹œê°ì  í”¼ë“œë°±ì„ ì œê³µí•œë‹¤.

### 22.7.2 ë‹¤ì¤‘ ì±„ë„ ì˜¤ë””ì˜¤ì™€ ë¯¹ì‹±

ë³µì¡í•œ ê²Œì„ì—ì„œëŠ” ì—¬ëŸ¬ ì˜¤ë””ì˜¤ ì†ŒìŠ¤ë¥¼ ë™ì‹œì— ê´€ë¦¬í•´ì•¼ í•œë‹¤. ë°°ê²½ ìŒì•…, í™˜ê²½ ì†Œë¦¬, íš¨ê³¼ìŒ, ìŒì„± ë“±ì´ ëª¨ë‘ ë…ë¦½ì ìœ¼ë¡œ ì¬ìƒë˜ë©´ì„œë„ ì¡°í™”ë¡­ê²Œ ë“¤ë ¤ì•¼ í•œë‹¤.

```cpp
#include <Siv3D.hpp>

// ì˜¤ë””ì˜¤ ì±„ë„ ë¯¹ì„œ
class AudioMixer
{
private:
    struct Channel
    {
        String name;
        Array<Audio> sounds;
        double volume = 1.0;
        bool muted = false;
    };

    std::unordered_map<String, Channel> channels;
    double masterVolume = 1.0;

public:
    // ì±„ë„ ì¶”ê°€
    void addChannel(const String& channelName, double defaultVolume = 1.0)
    {
        Channel channel;
        channel.name = channelName;
        channel.volume = defaultVolume;
        channels[channelName] = channel;
    }

    // ì±„ë„ì— ì˜¤ë””ì˜¤ ì¶”ê°€
    void addAudioToChannel(const String& channelName, const Audio& audio)
    {
        if (channels.contains(channelName))
        {
            channels[channelName].sounds.push_back(audio);
        }
    }

    // ì±„ë„ì˜ ëª¨ë“  ì˜¤ë””ì˜¤ ì¬ìƒ
    void playChannel(const String& channelName)
    {
        if (not channels.contains(channelName))
        {
            return;
        }

        auto& channel = channels[channelName];
        const double effectiveVolume = 
            channel.muted ? 0.0 : channel.volume * masterVolume;

        for (auto& audio : channel.sounds)
        {
            audio.setVolume(effectiveVolume);
            if (not audio.isPlaying())
            {
                audio.play();
            }
        }
    }

    // ì±„ë„ ë³¼ë¥¨ ì„¤ì •
    void setChannelVolume(const String& channelName, double volume)
    {
        if (not channels.contains(channelName))
        {
            return;
        }

        auto& channel = channels[channelName];
        channel.volume = Clamp(volume, 0.0, 1.0);

        const double effectiveVolume = 
            channel.muted ? 0.0 : channel.volume * masterVolume;

        for (auto& audio : channel.sounds)
        {
            audio.setVolume(effectiveVolume);
        }
    }

    // ì±„ë„ ìŒì†Œê±° í† ê¸€
    void toggleMute(const String& channelName)
    {
        if (not channels.contains(channelName))
        {
            return;
        }

        auto& channel = channels[channelName];
        channel.muted = not channel.muted;

        const double effectiveVolume = 
            channel.muted ? 0.0 : channel.volume * masterVolume;

        for (auto& audio : channel.sounds)
        {
            audio.setVolume(effectiveVolume);
        }
    }

    // ë§ˆìŠ¤í„° ë³¼ë¥¨ ì„¤ì •
    void setMasterVolume(double volume)
    {
        masterVolume = Clamp(volume, 0.0, 1.0);

        for (auto& [name, channel] : channels)
        {
            const double effectiveVolume = 
                channel.muted ? 0.0 : channel.volume * masterVolume;

            for (auto& audio : channel.sounds)
            {
                audio.setVolume(effectiveVolume);
            }
        }
    }

    // ì±„ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    double getChannelVolume(const String& channelName) const
    {
        if (channels.contains(channelName))
        {
            return channels.at(channelName).volume;
        }
        return 0.0;
    }

    bool isChannelMuted(const String& channelName) const
    {
        if (channels.contains(channelName))
        {
            return channels.at(channelName).muted;
        }
        return false;
    }

    double getMasterVolume() const
    {
        return masterVolume;
    }

    // ëª¨ë“  ì±„ë„ ì •ì§€
    void stopAll()
    {
        for (auto& [name, channel] : channels)
        {
            for (auto& audio : channel.sounds)
            {
                audio.stop();
            }
        }
    }
};

void Main()
{
    Scene::SetBackground(ColorF{ 0.15, 0.18, 0.22 });

    AudioMixer mixer;

    // ì±„ë„ ì„¤ì •
    mixer.addChannel(U"Music", 0.5);
    mixer.addChannel(U"Ambience", 0.3);
    mixer.addChannel(U"SFX", 0.7);

    // ì˜¤ë””ì˜¤ ë¡œë“œ ë° ì±„ë„ì— ì¶”ê°€
    Audio music{ Audio::Stream, U"example/sound/music.mp3" };
    music.setLoop(true);
    mixer.addAudioToChannel(U"Music", music);

    Audio ambience{ Audio::Stream, U"example/sound/music.mp3" };
    ambience.setLoop(true);
    mixer.addAudioToChannel(U"Ambience", ambience);

    Audio sfx{ U"example/sound/button.mp3" };
    mixer.addAudioToChannel(U"SFX", sfx);

    // ëª¨ë“  ì±„ë„ ì¬ìƒ ì‹œì‘
    mixer.playChannel(U"Music");
    mixer.playChannel(U"Ambience");

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // UI ìš”ì†Œë“¤
    const Array<String> channelNames = { U"Music", U"Ambience", U"SFX" };
    const int32 startY = 100;
    const int32 spacing = 100;

    std::unordered_map<String, bool> sliderDragging;
    for (const auto& name : channelNames)
    {
        sliderDragging[name] = false;
    }

    bool masterSliderDragging = false;

    while (System::Update())
    {
        font(U"ì˜¤ë””ì˜¤ ë¯¹ì„œ").draw(26, Vec2{ 30, 30 }, ColorF{ 0.9 });

        // ê° ì±„ë„ë³„ ì»¨íŠ¸ë¡¤
        for (size_t i = 0; i < channelNames.size(); ++i)
        {
            const String& channelName = channelNames[i];
            const int32 y = startY + static_cast<int32>(i) * spacing;

            // ì±„ë„ ì´ë¦„
            font(channelName).draw(20, Vec2{ 30, y }, ColorF{ 0.8 });

            // ë³¼ë¥¨ ìŠ¬ë¼ì´ë”
            const Rect slider{ 200, y + 10, 300, 15 };
            slider.draw(ColorF{ 0.3 });

            const double volume = mixer.getChannelVolume(channelName);
            const double handleX = slider.x + slider.w * volume;
            const Circle handle{ handleX, slider.y + slider.h / 2.0, 12 };

            // ìŠ¬ë¼ì´ë” ë“œë˜ê·¸
            if (handle.leftPressed() || 
                (sliderDragging[channelName] && MouseL.pressed()))
            {
                sliderDragging[channelName] = true;
                const double newVolume = Clamp(
                    (Cursor::Pos().x - slider.x) / slider.w, 0.0, 1.0);
                mixer.setChannelVolume(channelName, newVolume);
            }
            else if (MouseL.up())
            {
                sliderDragging[channelName] = false;
            }

            Rect{ slider.pos, static_cast<int32>(slider.w * volume), slider.h }
                .draw(ColorF{ 0.4, 0.7, 0.5 });

            slider.drawFrame(1, ColorF{ 0.6 });
            handle.draw(ColorF{ 0.9 });
            handle.drawFrame(2, ColorF{ 0.5 });

            // ë³¼ë¥¨ í‘œì‹œ
            font(U"{:.0f}%"_fmt(volume * 100))
                .draw(16, Vec2{ 520, y + 8 }, ColorF{ 0.7 });

            // ìŒì†Œê±° ë²„íŠ¼
            const Rect muteButton{ 600, y + 5, 80, 30 };
            const bool isMuted = mixer.isChannelMuted(channelName);

            if (muteButton.mouseOver())
            {
                muteButton.draw(isMuted ? ColorF{ 0.8, 0.4, 0.4 } 
                                       : ColorF{ 0.6, 0.7, 0.6 });
            }
            else
            {
                muteButton.draw(isMuted ? ColorF{ 0.6, 0.2, 0.2 } 
                                       : ColorF{ 0.4, 0.5, 0.4 });
            }
            muteButton.drawFrame(2, ColorF{ 0.8 });
            font(isMuted ? U"ğŸ”‡" : U"ğŸ”Š")
                .drawAt(18, muteButton.center(), ColorF{ 0.9 });

            if (muteButton.leftClicked())
            {
                mixer.toggleMute(channelName);
            }
        }

        // SFX í…ŒìŠ¤íŠ¸ ë²„íŠ¼
        const Rect sfxButton{ 200, startY + 2 * spacing + 50, 120, 40 };
        if (sfxButton.mouseOver())
        {
            sfxButton.draw(ColorF{ 0.6, 0.6, 0.8 });
        }
        else
        {
            sfxButton.draw(ColorF{ 0.4, 0.4, 0.6 });
        }
        sfxButton.drawFrame(2, ColorF{ 0.8 });
        font(U"SFX ì¬ìƒ").drawAt(16, sfxButton.center(), ColorF{ 0.9 });

        if (sfxButton.leftClicked())
        {
            sfx.playOneShot();
        }

        // ë§ˆìŠ¤í„° ë³¼ë¥¨
        const int32 masterY = startY + 3 * spacing + 20;
        Line{ 30, masterY, Scene::Width() - 30, masterY }
            .draw(2, ColorF{ 0.5 });

        font(U"ë§ˆìŠ¤í„° ë³¼ë¥¨").draw(22, Vec2{ 30, masterY + 20 }, ColorF{ 0.9 });

        const Rect masterSlider{ 200, masterY + 30, 400, 20 };
        masterSlider.draw(ColorF{ 0.3 });

        const double masterVolume = mixer.getMasterVolume();
        const double masterHandleX = masterSlider.x + masterSlider.w * masterVolume;
        const Circle masterHandle{ masterHandleX, 
                                  masterSlider.y + masterSlider.h / 2.0, 15 };

        if (masterHandle.leftPressed() || 
            (masterSliderDragging && MouseL.pressed()))
        {
            masterSliderDragging = true;
            const double newVolume = Clamp(
                (Cursor::Pos().x - masterSlider.x) / masterSlider.w, 0.0, 1.0);
            mixer.setMasterVolume(newVolume);
        }
        else if (MouseL.up())
        {
            masterSliderDragging = false;
        }

        Rect{ masterSlider.pos, 
              static_cast<int32>(masterSlider.w * masterVolume), 
              masterSlider.h }
            .draw(ColorF{ 0.5, 0.7, 0.9 });

        masterSlider.drawFrame(2, ColorF{ 0.7 });
        masterHandle.draw(ColorF{ 1.0 });
        masterHandle.drawFrame(3, ColorF{ 0.5 });

        font(U"{:.0f}%"_fmt(masterVolume * 100))
            .draw(18, Vec2{ 620, masterY + 26 }, ColorF{ 0.8 });
    }
}
```

`AudioMixer` í´ë˜ìŠ¤ëŠ” ì—¬ëŸ¬ ì˜¤ë””ì˜¤ ì±„ë„ì„ ê³„ì¸µì ìœ¼ë¡œ ê´€ë¦¬í•œë‹¤. ê° ì±„ë„ì€ ë…ë¦½ì ì¸ ë³¼ë¥¨ê³¼ ìŒì†Œê±° ìƒíƒœë¥¼ ê°€ì§€ë©°, ë§ˆìŠ¤í„° ë³¼ë¥¨ì€ ëª¨ë“  ì±„ë„ì— ê³µí†µìœ¼ë¡œ ì ìš©ëœë‹¤. ì‹¤ì œ ê²Œì„ì—ì„œëŠ” ì„¤ì • ë©”ë‰´ì—ì„œ ìŒì•…, íš¨ê³¼ìŒ, ìŒì„± ë“±ì„ ê°œë³„ì ìœ¼ë¡œ ì¡°ì ˆí•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë‹¤.

### 22.7.3 ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¬ë°ê³¼ ë©”ëª¨ë¦¬ ê´€ë¦¬

í° ìŒì•… íŒŒì¼ì„ ë‹¤ë£° ë•ŒëŠ” ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ê³ ë ¤í•´ì•¼ í•œë‹¤. ì „ì²´ íŒŒì¼ì„ ë©”ëª¨ë¦¬ì— ë¡œë“œí•˜ëŠ” ê²ƒê³¼ ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ì˜ ì°¨ì´ë¥¼ ì´í•´í•˜ê³  ì ì ˆíˆ ì„ íƒí•´ì•¼ í•œë‹¤.

ì¼ë°˜ì ì¸ ê°€ì´ë“œë¼ì¸ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. ì§§ì€ íš¨ê³¼ìŒ(1~2ì´ˆ)ì€ ì¼ë°˜ `Audio`ë¡œ ë¡œë“œí•˜ì—¬ ë¹ ë¥¸ ì¬ìƒ ë°˜ì‘ ì†ë„ë¥¼ ì–»ëŠ”ë‹¤. ê¸´ ë°°ê²½ ìŒì•…(1ë¶„ ì´ìƒ)ì€ `Audio::Stream`ìœ¼ë¡œ ë¡œë“œí•˜ì—¬ ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•œë‹¤. ìì£¼ ë°˜ë³µ ì¬ìƒë˜ëŠ” ì¤‘ê°„ ê¸¸ì´ ì‚¬ìš´ë“œ(5~30ì´ˆ)ëŠ” ìƒí™©ì— ë”°ë¼ ì„ íƒí•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ CD í’ˆì§ˆì˜ ìŠ¤í…Œë ˆì˜¤ ìŒì•…(44.1kHz, 16bit)ì€ 1ë¶„ë‹¹ ì•½ 10MBì˜ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•œë‹¤. 5ë¶„ì§œë¦¬ ë°°ê²½ ìŒì•…ì„ ì¼ë°˜ ë°©ì‹ìœ¼ë¡œ ë¡œë“œí•˜ë©´ 50MBë¥¼ ì°¨ì§€í•˜ì§€ë§Œ, ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ì€ ìˆ˜ MBë§Œ ì‚¬ìš©í•œë‹¤.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.1, 0.1, 0.15 });

    // ì¼ë°˜ ë¡œë“œ ë°©ì‹
    const Audio normalAudio{ U"example/sound/music.mp3" };
    
    // ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹
    const Audio streamAudio{ Audio::Stream, U"example/sound/music.mp3" };

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    const Rect normalButton{ 200, 200, 200, 60 };
    const Rect streamButton{ 450, 200, 200, 60 };

    while (System::Update())
    {
        font(U"ë©”ëª¨ë¦¬ ì‚¬ìš© ë¹„êµ").draw(24, Vec2{ 250, 100 }, ColorF{ 0.9 });

        // ì¼ë°˜ ë¡œë“œ ë²„íŠ¼
        if (normalButton.mouseOver())
        {
            normalButton.draw(ColorF{ 0.5, 0.6, 0.8 });
        }
        else
        {
            normalButton.draw(ColorF{ 0.3, 0.4, 0.6 });
        }
        normalButton.drawFrame(2, ColorF{ 0.8 });
        font(U"ì¼ë°˜ ë¡œë“œ").drawAt(18, normalButton.center(), ColorF{ 0.9 });

        if (normalButton.leftClicked())
        {
            streamAudio.stop();
            normalAudio.play();
        }

        // ìŠ¤íŠ¸ë¦¬ë° ë²„íŠ¼
        if (streamButton.mouseOver())
        {
            streamButton.draw(ColorF{ 0.6, 0.8, 0.5 });
        }
        else
        {
            streamButton.draw(ColorF{ 0.4, 0.6, 0.3 });
        }
        streamButton.drawFrame(2, ColorF{ 0.8 });
        font(U"ìŠ¤íŠ¸ë¦¬ë°").drawAt(18, streamButton.center(), ColorF{ 0.9 });

        if (streamButton.leftClicked())
        {
            normalAudio.stop();
            streamAudio.play();
        }

        // ì •ë³´ í‘œì‹œ
        int32 infoY = 300;
        font(U"ì¼ë°˜ ë¡œë“œ:").draw(18, Vec2{ 200, infoY }, ColorF{ 0.8 });
        font(U"â€¢ ì „ì²´ íŒŒì¼ì„ ë©”ëª¨ë¦¬ì— ë¡œë“œ")
            .draw(16, Vec2{ 220, infoY + 30 }, ColorF{ 0.7 });
        font(U"â€¢ ë¹ ë¥¸ ì¬ìƒ ì‹œì‘")
            .draw(16, Vec2{ 220, infoY + 55 }, ColorF{ 0.7 });
        font(U"â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ìŒ")
            .draw(16, Vec2{ 220, infoY + 80 }, ColorF{ 0.7 });
        font(U"â€¢ ì§§ì€ íš¨ê³¼ìŒì— ì í•©")
            .draw(16, Vec2{ 220, infoY + 105 }, ColorF{ 0.7 });

        infoY = 450;
        font(U"ìŠ¤íŠ¸ë¦¬ë°:").draw(18, Vec2{ 200, infoY }, ColorF{ 0.8 });
        font(U"â€¢ í•„ìš”í•œ ë¶€ë¶„ë§Œ ë©”ëª¨ë¦¬ì— ë¡œë“œ")
            .draw(16, Vec2{ 220, infoY + 30 }, ColorF{ 0.7 });
        font(U"â€¢ ì•½ê°„ì˜ ì´ˆê¸°í™” ì‹œê°„ í•„ìš”")
            .draw(16, Vec2{ 220, infoY + 55 }, ColorF{ 0.7 });
        font(U"â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë‚®ìŒ")
            .draw(16, Vec2{ 220, infoY + 80 }, ColorF{ 0.7 });
        font(U"â€¢ ê¸´ ë°°ê²½ ìŒì•…ì— ì í•©")
            .draw(16, Vec2{ 220, infoY + 105 }, ColorF{ 0.7 });

        // ì¬ìƒ ìƒíƒœ í‘œì‹œ
        String playingInfo = U"";
        if (normalAudio.isPlaying())
        {
            playingInfo = U"ì¬ìƒ ì¤‘: ì¼ë°˜ ë¡œë“œ";
        }
        else if (streamAudio.isPlaying())
        {
            playingInfo = U"ì¬ìƒ ì¤‘: ìŠ¤íŠ¸ë¦¬ë°";
        }
        else
        {
            playingInfo = U"ì •ì§€";
        }

        font(playingInfo).drawAt(20, Vec2{ 400, 600 }, ColorF{ 0.3, 0.8, 0.8 });
    }
}
```

í”„ë¡œì íŠ¸ì˜ ìš”êµ¬ì‚¬í•­ì— ë”°ë¼ ì ì ˆí•œ ë°©ì‹ì„ ì„ íƒí•˜ë©´ ë©”ëª¨ë¦¬ íš¨ìœ¨ê³¼ ì„±ëŠ¥ì„ ëª¨ë‘ ë§Œì¡±ì‹œí‚¬ ìˆ˜ ìˆë‹¤.

## 22.8 ì •ë¦¬

ì´ë²ˆ ì¥ì—ì„œëŠ” Siv3Dë¥¼ ì‚¬ìš©í•œ ì‚¬ìš´ë“œì™€ ìŒì•… ì²˜ë¦¬ ë°©ë²•ì„ ë°°ì› ë‹¤. ê¸°ë³¸ì ì¸ ì‚¬ìš´ë“œ ì¬ìƒë¶€í„° ì‹œì‘í•˜ì—¬ ë°°ê²½ ìŒì•… ê´€ë¦¬, íš¨ê³¼ìŒ í’€ ì‹œìŠ¤í…œ, ë³¼ë¥¨ ì¡°ì ˆ, 3D ì‚¬ìš´ë“œ, ê·¸ë¦¬ê³  ê³ ê¸‰ ì˜¤ë””ì˜¤ ì²˜ë¦¬ ê¸°ë²•ê¹Œì§€ ë‹¤ë£¨ì—ˆë‹¤.

í•µì‹¬ ë‚´ìš©ì„ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. `Audio` í´ë˜ìŠ¤ë¡œ ë‹¤ì–‘í•œ í˜•ì‹ì˜ ì˜¤ë””ì˜¤ íŒŒì¼ì„ ë¡œë“œí•˜ê³  ì¬ìƒí•œë‹¤. `play()`, `pause()`, `stop()` ë©”ì„œë“œë¡œ ì¬ìƒì„ ì œì–´í•˜ë©°, `setLoop()`ë¡œ ë°˜ë³µ ì¬ìƒì„ ì„¤ì •í•œë‹¤. `setVolume()`ê³¼ `setPan()`ìœ¼ë¡œ ë³¼ë¥¨ê³¼ ìŠ¤í…Œë ˆì˜¤ íŒ¨ë‹ì„ ì¡°ì ˆí•˜ê³ , í˜ì´ë“œ íš¨ê³¼ë¡œ ìì—°ìŠ¤ëŸ¬ìš´ ì „í™˜ì„ êµ¬í˜„í•œë‹¤. íš¨ê³¼ìŒ í’€ ì‹œìŠ¤í…œìœ¼ë¡œ ë™ì‹œ ë‹¤ë°œì ì¸ íš¨ê³¼ìŒ ì¬ìƒì„ ì²˜ë¦¬í•˜ë©°, ê±°ë¦¬ ê¸°ë°˜ ë³¼ë¥¨ ê°ì‡ ì™€ ë°©í–¥ì„± ì˜¤ë””ì˜¤ë¡œ ëª°ì…ê°ì„ ë†’ì¸ë‹¤. FFTë¥¼ ì‚¬ìš©í•œ ì˜¤ë””ì˜¤ ì‹œê°í™”ë¡œ ì‚¬ìš©ì ê²½í—˜ì„ í–¥ìƒì‹œí‚¤ê³ , ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ìœ¼ë¡œ ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•œë‹¤.

ì‚¬ìš´ë“œëŠ” ê²Œì„ê³¼ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì¤‘ìš”í•œ êµ¬ì„± ìš”ì†Œë‹¤. ì ì ˆí•œ ë°°ê²½ ìŒì•…ê³¼ íš¨ê³¼ìŒì€ ì‚¬ìš©ìì˜ ëª°ì…ë„ë¥¼ í¬ê²Œ ë†’ì´ë©°, ì‹œê°ì  í”¼ë“œë°±ë§Œìœ¼ë¡œëŠ” ì „ë‹¬í•˜ê¸° ì–´ë ¤ìš´ ê°ì •ê³¼ ë¶„ìœ„ê¸°ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. ë‹¤ìŒ ì¥ì—ì„œëŠ” íŒŒì¼ ì‹œìŠ¤í…œê³¼ ë°ì´í„° ê´€ë¦¬ë¥¼ ë°°ì›Œ í”„ë¡œê·¸ë¨ì˜ ìƒíƒœë¥¼ ì €ì¥í•˜ê³  ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ë²•ì„ ì•Œì•„ë³¸ë‹¤.


 