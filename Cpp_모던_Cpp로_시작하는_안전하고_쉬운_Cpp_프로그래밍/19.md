# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 19: 입력 처리와 상호작용

## 19.1 들어가며
이제 Siv3D의 기본 구조를 이해했으니, 사용자와의 상호작용을 다루어 보자. 프로그램이 사용자의 입력에 반응하지 않는다면 진정한 의미의 애플리케이션이라 할 수 없다. 이 장에서는 마우스, 키보드, 터치 입력을 처리하는 방법을 배우고, 입력 상태를 효과적으로 관리하는 기법을 익힌다.

Modern C++의 강력한 타입 시스템과 Siv3D의 직관적인 API가 결합되면, 복잡한 입력 처리도 안전하고 읽기 쉬운 코드로 작성할 수 있다.

## 19.2 마우스 입력 처리

### 19.2.1 마우스 좌표 얻기
마우스의 현재 위치를 얻는 것은 Siv3D에서 매우 간단하다. `Cursor::Pos()`는 현재 마우스 커서의 화면 좌표를 반환한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 마우스 위치를 Point 타입으로 받는다
        const Point mousePos = Cursor::Pos();
        
        // 마우스 위치에 원을 그린다
        Circle{ mousePos, 20 }.draw(Palette::Skyblue);
        
        // 좌표를 텍스트로 출력한다
        font(U"마우스 위치: ({}, {})"_fmt(mousePos.x, mousePos.y)).draw(10, 10, Palette::White);
    }
}
```

`Cursor::Pos()`는 정수 좌표를 담은 `Point` 타입을 반환한다. 더 정밀한 좌표가 필요하다면 `Cursor::PosF()`를 사용하여 `Vec2` 타입(실수 좌표)을 얻을 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
	Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

	while (System::Update())
	{
		// 실수 좌표로 마우스 위치를 얻는다
		const Vec2 mousePos = Cursor::PosF();

		Circle{ mousePos, 20 }.draw(Palette::Skyblue);

		font(U"마우스 위치: ({:.2f}, {:.2f})"_fmt(mousePos.x, mousePos.y)).draw(10, 10, Palette::White);
	}
}
```

### 19.2.2 마우스 버튼 클릭 감지
Siv3D는 마우스 버튼의 상태를 확인하는 다양한 함수를 제공한다. `MouseL`, `MouseR`, `MouseM`은 각각 왼쪽, 오른쪽, 가운데 버튼을 나타낸다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    int clickCount = 0;
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 마우스 왼쪽 버튼이 눌렸는지 확인
        if (MouseL.down())
        {
            ++clickCount;
        }
        
        // 마우스 오른쪽 버튼이 눌려있는지 확인
        if (MouseR.pressed())
        {
            Circle{ Cursor::Pos(), 30 }.draw(ColorF{ 1.0, 0.0, 0.0, 0.3 });
        }
        
        font(U"클릭 횟수: {}"_fmt(clickCount))
            .draw(20, 20, Palette::White);
        
        font(U"왼쪽 클릭: 카운트 증가")
            .draw(20, 60, Palette::Yellow);
        
        font(U"오른쪽 클릭: 반투명 원 표시")
            .draw(20, 90, Palette::Yellow);
    }
}
```

마우스 입력에는 세 가지 주요 상태가 있다:

- `down()`: 버튼이 막 눌린 순간 (한 프레임 동안만 `true`)
- `pressed()`: 버튼이 눌려있는 동안 계속 (눌려있는 모든 프레임에서 `true`)
- `up()`: 버튼이 막 떼어진 순간 (한 프레임 동안만 `true`)

```cpp
# include <Siv3D.hpp>

void Main()
{
    Vec2 dragStart{ 0, 0 };
    bool isDragging = false;
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 드래그 시작
        if (MouseL.down())
        {
            dragStart = Cursor::PosF();
            isDragging = true;
        }
        
        // 드래그 중
        if (isDragging && MouseL.pressed())
        {
            const Vec2 dragEnd = Cursor::PosF();
            Line{ dragStart, dragEnd }.draw(5, Palette::Orange);
            Circle{ dragEnd, 10 }.draw(Palette::Red);
        }
        
        // 드래그 종료
        if (MouseL.up())
        {
            isDragging = false;
        }
        
        font(U"마우스를 드래그하여 선을 그려보세요")
            .draw(20, 20, Palette::White);
    }
}
```

### 19.2.3 특정 영역 클릭 감지
도형 객체는 마우스 입력을 직접 처리하는 멤버 함수를 제공한다. 이를 활용하면 버튼이나 인터랙티브한 UI 요소를 쉽게 만들 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 버튼 영역 정의
    const Rect button1{ 100, 100, 200, 60 };
    const Rect button2{ 100, 180, 200, 60 };
    const Circle circleButton{ 400, 200, 50 };
    
    String message = U"버튼을 클릭하세요";
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 사각형 버튼 1
        if (button1.leftClicked())
        {
            message = U"버튼 1이 클릭되었습니다";
        }
        
        // 마우스가 올라가 있으면 색상 변경
        button1.draw(button1.mouseOver() ? Palette::Lightblue : Palette::Gray);
        font(U"버튼 1").drawAt(button1.center(), Palette::Black);
        
        // 사각형 버튼 2
        if (button2.leftClicked())
        {
            message = U"버튼 2가 클릭되었습니다";
        }
        
        button2.draw(button2.mouseOver() ? Palette::Lightgreen : Palette::Gray);
        font(U"버튼 2").drawAt(button2.center(), Palette::Black);
        
        // 원형 버튼
        if (circleButton.leftClicked())
        {
            message = U"원형 버튼이 클릭되었습니다";
        }
        
        circleButton.draw(circleButton.mouseOver() ? Palette::Orange : Palette::Gray);
        font(U"클릭").drawAt(circleButton.center, Palette::White);
        
        // 메시지 출력
        font(message).draw(50, 350, Palette::Yellow);
    }
}
```

도형의 `leftClicked()`, `rightClicked()` 함수는 해당 영역이 클릭되었는지 확인한다. `mouseOver()` 함수는 마우스 커서가 도형 위에 있는지 확인한다. 이러한 함수들은 내부적으로 마우스 좌표와 도형의 충돌을 계산해주므로, 직접 좌표 비교를 할 필요가 없다.

### 19.2.4 마우스 휠 입력
마우스 휠의 회전을 감지하여 확대/축소나 스크롤 기능을 구현할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    double scale = 1.0;
    const double minScale = 0.5;
    const double maxScale = 3.0;
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 마우스 휠 입력 받기
        const double wheelDelta = Mouse::Wheel();
        
        if (wheelDelta != 0.0)
        {
            scale += wheelDelta * 0.1;
            scale = Clamp(scale, minScale, maxScale);
        }
        
        // 스케일에 따라 원의 크기 변경
        const double radius = 100 * scale;
        Circle{ Scene::Center(), radius }.draw(Palette::Skyblue);
        
        font(U"마우스 휠로 크기 조절")
            .drawAt(Scene::Center().x, 50, Palette::White);
        
        font(U"스케일: {:.2f}"_fmt(scale))
            .draw(20, 20, Palette::Yellow);
    }
}
```

`Mouse::Wheel()`은 마우스 휠이 회전된 정도를 반환한다. 위로 스크롤하면 양수, 아래로 스크롤하면 음수를 반환한다. `Clamp()` 함수는 값을 특정 범위 내로 제한하는 유틸리티 함수다.
  

</br>  
  
  
## 19.3 키보드 입력 처리

### 19.3.1 키 입력 기본
키보드 입력은 `Key` 네임스페이스 아래의 상수를 통해 처리한다. 마우스와 마찬가지로 `down()`, `pressed()`, `up()` 함수를 사용한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
	Vec2 playerPos = Scene::Center();
	const double moveSpeed = 200.0; // 픽셀/초

	Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

	while (System::Update())
	{
		// 델타 타임 계산 (이전 프레임과의 시간 차이)
		const double deltaTime = Scene::DeltaTime();

		// 방향키로 이동
		if (KeyLeft.pressed())
		{
			playerPos.x -= moveSpeed * deltaTime;
		}
		if (KeyRight.pressed())
		{
			playerPos.x += moveSpeed * deltaTime;
		}
		if (KeyUp.pressed())
		{
			playerPos.y -= moveSpeed * deltaTime;
		}
		if (KeyDown.pressed())
		{
			playerPos.y += moveSpeed * deltaTime;
		}

		// 화면 경계 체크
		playerPos.x = std::clamp(playerPos.x, 0.0, static_cast<double>(Scene::Width()));
		playerPos.y = std::clamp(playerPos.y, 0.0, static_cast<double>(Scene::Height()));

		// 플레이어 그리기
		Circle{ playerPos, 20 }.draw(Palette::Green);

		font(U"방향키로 이동하세요")
			.draw(20, 20, Palette::White);
	}
}
```

`Scene::DeltaTime()`은 이전 프레임과의 시간 차이를 초 단위로 반환한다. 이를 이용하면 프레임레이트에 관계없이 일정한 속도로 움직이는 오브젝트를 만들 수 있다.

### 19.3.2 문자 키와 수정자 키
알파벳, 숫자, 특수 문자 키도 동일한 방식으로 처리한다. 수정자 키(Shift, Ctrl, Alt)와의 조합도 쉽게 감지할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    String inputText = U"";
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // Space 키로 텍스트 초기화
        if (KeySpace.down())
        {
            inputText = U"";
        }
        
        // Ctrl+S로 저장 시뮬레이션
        if ((KeyControl + KeyS).down())
        {
            Print << U"저장되었습니다!";
        }
        
        // Shift+A로 모두 선택 시뮬레이션
        if ((KeyShift + KeyA).down())
        {
            Print << U"모두 선택되었습니다!";
        }
        
        // A-Z 키 입력
        for (auto i : step(26))
        {
            const auto key = Input{ InputDeviceType::Keyboard, 
                                   static_cast<uint8>('A' + i) };
            if (key.down())
            {
                inputText += static_cast<char32>(U'A' + i);
            }
        }
        
        // 백스페이스
        if (KeyBackspace.down() && !inputText.empty())
        {
            inputText.pop_back();
        }
        
        // UI 그리기
        Rect{ 50, 50, 700, 60 }.draw(Palette::White);
        font(inputText).draw(60, 60, Palette::Black);
        
        font(U"A-Z 키를 눌러 입력하세요")
            .draw(50, 130, Palette::Yellow);
        font(U"Space: 초기화, Ctrl+S: 저장, Shift+A: 모두 선택")
            .draw(50, 160, Palette::Yellow);
    }
}
```

키 조합은 `+` 연산자로 표현한다. `(KeyControl + KeyS).down()`은 Ctrl 키와 S 키가 동시에 눌렸을 때 `true`를 반환한다.

### 19.3.3 텍스트 입력 처리
간단한 키 입력보다 복잡한 텍스트 입력(한글, 일본어 등의 IME 입력 포함)을 처리하려면 `TextInput` 클래스를 사용한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // 텍스트 입력 객체 생성
    TextEditState textEdit;
    Font font{ FontMethod::MSDF, 25, Typeface::CJK_Regular_KR };
    
    while (System::Update())
    {
        // 텍스트 입력 업데이트
        SimpleGUI::TextBox(textEdit, Vec2{ 100, 100 }, 600);
        
        // Enter 키로 입력 확정
        if (KeyEnter.down() && !textEdit.text.empty())
        {
            Print << U"입력된 텍스트: " << textEdit.text;
            textEdit.clear();
        }
        
        font(U"텍스트를 입력하고 Enter를 누르세요")
            .draw(100, 50, Palette::White);
        
        // 현재 입력된 텍스트 길이 표시
        font(U"길이: {}"_fmt(textEdit.text.size()))
            .draw(100, 150, Palette::Yellow);
    }
}
```

`SimpleGUI::TextBox()`는 Siv3D가 제공하는 간편한 텍스트 입력 위젯이다. `TextEditState` 객체가 입력 상태를 관리하며, 커서 위치, 선택 영역 등의 정보를 자동으로 처리한다.

### 19.3.4 키 상태의 지속 시간
키가 얼마나 오래 눌려 있었는지 확인할 수 있다. 이를 활용하면 차지 공격이나 장기 입력 효과를 구현할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    double chargeLevel = 0.0;
    const double maxChargeTime = 2.0; // 2초
    bool charged = false;
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // Space 키를 누르고 있는 시간
        const double pressedDuration = KeySpace.pressedDuration();
        
        if (KeySpace.pressed())
        {
            // 충전 레벨 계산 (0.0 ~ 1.0)
            chargeLevel = Min(pressedDuration / maxChargeTime, 1.0);
            charged = false;
        }
        
        // Space 키를 뗐을 때
        if (KeySpace.up() && chargeLevel > 0.0)
        {
            Print << U"발사! 파워: {:.0f}%"_fmt(chargeLevel * 100);
            charged = true;
        }
        
        // 충전 바 그리기
        const Rect chargeBarBg{ 100, 200, 600, 40 };
        const Rect chargeBarFg{ 100, 200, static_cast<int>(600 * chargeLevel), 40 };
        
        chargeBarBg.draw(Palette::Gray);
        chargeBarFg.draw(ColorF{ chargeLevel, 1.0 - chargeLevel, 0.0 });
        
        // 안내 텍스트
        font(U"Space 키를 눌러 충전하세요")
            .draw(100, 150, Palette::White);
        
        font(U"충전: {:.0f}%"_fmt(chargeLevel * 100))
            .draw(100, 250, Palette::Yellow);
    }
}
```

`pressedDuration()` 함수는 키가 눌려있는 시간을 초 단위로 반환한다. 이를 최대 충전 시간으로 나누면 0.0에서 1.0 사이의 정규화된 값을 얻을 수 있다.
  

</br>  
  
  
## 19.4 터치 입력 기초

### 19.4.1 터치 입력과 마우스 입력의 통합
Siv3D는 터치 입력을 마우스 입력처럼 처리할 수 있게 해준다. 터치 스크린이 없는 환경에서도 마우스로 동일하게 테스트할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    // 터치/클릭한 위치를 저장하는 배열
    Array<Vec2> touchPoints;
    
    while (System::Update())
    {
        // 터치/클릭 시 위치 기록
        if (MouseL.down())
        {
            touchPoints.push_back(Cursor::PosF());
            
            // 최대 100개까지만 저장
            if (touchPoints.size() > 100)
            {
                touchPoints.pop_front();
            }
        }
        
        // Space 키로 초기화
        if (KeySpace.down())
        {
            touchPoints.clear();
        }
        
        // 모든 터치 포인트 그리기
        for (const auto& point : touchPoints)
        {
            Circle{ point, 15 }.draw(ColorF{ 1.0, 0.5, 0.0, 0.5 });
        }
        
        font(U"화면을 터치/클릭하세요")
            .draw(20, 20, Palette::White);
        
        font(U"포인트 수: {}"_fmt(touchPoints.size()))
            .draw(20, 50, Palette::Yellow);
        
        font(U"Space: 초기화")
            .draw(20, 80, Palette::Yellow);
    }
}
```

### 19.4.2 멀티터치 처리
멀티터치를 지원하는 디바이스에서는 여러 개의 터치 포인트를 동시에 처리할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 모든 터치 포인트 가져오기
        const auto touches = System::GetTouches();
        
        // 각 터치 포인트 처리
        for (const auto& touch : touches)
        {
            // 터치 ID에 따라 다른 색상 사용
            const ColorF color = HSV{ touch.id * 60.0, 0.8, 1.0 };
            
            Circle{ touch.pos, 40 }.draw(color.withAlpha(0.5));
            
            font(U"ID: {}"_fmt(touch.id))
                .drawAt(touch.pos, Palette::White);
        }
        
        // 터치 개수 표시
        font(U"터치 개수: {}"_fmt(touches.size()))
            .draw(20, 20, Palette::White);
        
        if (touches.isEmpty())
        {
            font(U"화면을 여러 손가락으로 터치해보세요")
                .draw(20, 60, Palette::Yellow);
        }
    }
}
```

`System::GetTouches()`는 현재 활성화된 모든 터치 포인트의 배열을 반환한다. 각 터치 포인트는 고유한 ID와 위치 정보를 가진다.

### 19.4.3 제스처 감지
간단한 제스처를 감지하여 스와이프, 핀치 등의 동작을 구현할 수 있다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font1{ FontMethod::MSDF, 40, Typeface::CJK_Regular_KR };
    Font font2{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    Vec2 previousPos{ 0, 0 };
    bool wasPressed = false;
    String gesture = U"대기 중";
    
    while (System::Update())
    {
        const Vec2 currentPos = Cursor::PosF();
        
        if (MouseL.down())
        {
            previousPos = currentPos;
            wasPressed = true;
            gesture = U"터치 시작";
        }
        
        if (MouseL.pressed() && wasPressed)
        {
            const Vec2 delta = currentPos - previousPos;
            const double distance = delta.length();
            
            // 일정 거리 이상 이동 시 스와이프로 판정
            if (distance > 10.0)
            {
                const double angle = Math::ToDegrees(std::atan2(delta.y, delta.x));
                
                // 각도에 따라 방향 판단
                if (angle >= -45 && angle < 45)
                    gesture = U"→ 오른쪽 스와이프";
                else if (angle >= 45 && angle < 135)
                    gesture = U"↓ 아래쪽 스와이프";
                else if (angle >= -135 && angle < -45)
                    gesture = U"↑ 위쪽 스와이프";
                else
                    gesture = U"← 왼쪽 스와이프";
                
                previousPos = currentPos;
            }
        }
        
        if (MouseL.up())
        {
            wasPressed = false;
            gesture = U"터치 종료";
        }
        
        // 제스처 표시
        font1(gesture)
            .drawAt(Scene::Center(), Palette::Yellow);
        
        font2(U"화면을 드래그하여 스와이프 방향을 확인하세요")
            .draw(20, 20, Palette::White);
    }
}
```

이 예제는 터치 시작점과 현재 위치의 차이를 계산하여 스와이프 방향을 감지한다. `std::atan2()`를 사용하여 벡터의 각도를 구하고, 이를 바탕으로 네 방향 중 하나로 판정한다.
  
  
</br>  
  
  
## 19.5 입력 상태 관리와 이벤트 처리

### 19.5.1 입력 상태 클래스 설계
복잡한 게임이나 애플리케이션에서는 입력 상태를 체계적으로 관리해야 한다. `enum class`와 `std::optional`을 활용하여 안전한 입력 상태 관리 클래스를 만들어보자.

```cpp
# include <Siv3D.hpp>

// 입력 액션 정의
enum class InputAction
{
    MoveLeft,
    MoveRight,
    MoveUp,
    MoveDown,
    Jump,
    Attack,
    Menu
};

// 입력 매니저 클래스
class InputManager
{
public:
    // 키 바인딩 설정
    void setKeyBinding(InputAction action, const Input& key)
    {
        keyBindings[action] = key;
    }
    
    // 액션이 막 시작되었는지 확인
    bool isActionTriggered(InputAction action) const
    {
        auto it = keyBindings.find(action);
        if (it == keyBindings.end())
            return false;
        
        return it->second.down();
    }
    
    // 액션이 지속되고 있는지 확인
    bool isActionActive(InputAction action) const
    {
        auto it = keyBindings.find(action);
        if (it == keyBindings.end())
            return false;
        
        return it->second.pressed();
    }
    
    // 액션이 막 종료되었는지 확인
    bool isActionReleased(InputAction action) const
    {
        auto it = keyBindings.find(action);
        if (it == keyBindings.end())
            return false;
        
        return it->second.up();
    }
    
private:
    std::map<InputAction, Input> keyBindings;
};

void Main()
{
    Font font{ FontMethod::MSDF, 20 Typeface::CJK_Regular_KR };

    InputManager inputMgr;
    
    // 키 바인딩 설정
    inputMgr.setKeyBinding(InputAction::MoveLeft, KeyLeft);
    inputMgr.setKeyBinding(InputAction::MoveRight, KeyRight);
    inputMgr.setKeyBinding(InputAction::MoveUp, KeyUp);
    inputMgr.setKeyBinding(InputAction::MoveDown, KeyDown);
    inputMgr.setKeyBinding(InputAction::Jump, KeySpace);
    inputMgr.setKeyBinding(InputAction::Attack, KeyZ);
    inputMgr.setKeyBinding(InputAction::Menu, KeyEscape);
    
    Vec2 playerPos = Scene::Center();
    const double moveSpeed = 200.0;
    
    while (System::Update())
    {
        const double deltaTime = Scene::DeltaTime();
        
        // 입력 처리
        if (inputMgr.isActionActive(InputAction::MoveLeft))
        {
            playerPos.x -= moveSpeed * deltaTime;
        }
        if (inputMgr.isActionActive(InputAction::MoveRight))
        {
            playerPos.x += moveSpeed * deltaTime;
        }
        if (inputMgr.isActionActive(InputAction::MoveUp))
        {
            playerPos.y -= moveSpeed * deltaTime;
        }
        if (inputMgr.isActionActive(InputAction::MoveDown))
        {
            playerPos.y += moveSpeed * deltaTime;
        }
        
        if (inputMgr.isActionTriggered(InputAction::Jump))
        {
            Print << U"점프!";
        }
        
        if (inputMgr.isActionTriggered(InputAction::Attack))
        {
            Print << U"공격!";
        }
        
        if (inputMgr.isActionTriggered(InputAction::Menu))
        {
            Print << U"메뉴 열기";
        }
        
        // 플레이어 그리기
        Circle{ playerPos, 25 }.draw(Palette::Green);
        
        // 조작 안내
        font(U"방향키: 이동")
            .draw(20, 20, Palette::White);
        font(U"Space: 점프, Z: 공격, Esc: 메뉴")
            .draw(20, 50, Palette::White);
    }
}
```

이 설계의 장점은 다음과 같다:

1. **추상화**: 게임 로직은 구체적인 키가 아닌 추상적인 액션으로 작성된다.
2. **유연성**: 키 바인딩을 런타임에 변경할 수 있다.
3. **타입 안전성**: `enum class`를 사용하여 잘못된 액션 이름을 방지한다.
4. **확장성**: 새로운 액션을 쉽게 추가할 수 있다.

### 19.5.2 입력 버퍼링과 커맨드 패턴
격투 게임이나 복잡한 조작이 필요한 게임에서는 연속된 입력을 버퍼링하여 콤보나 특수 기술을 구현한다.

```cpp
# include <Siv3D.hpp>

// 입력 이벤트 구조체
struct InputEvent
{
    char32 key;
    double timestamp;
};

// 커맨드 패턴을 위한 추상 클래스
class Command
{
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual String getName() const = 0;
};

// 구체적인 커맨드들
class FireballCommand : public Command
{
public:
    void execute() override
    {
        Print << U"🔥 파이어볼 발사!";
    }
    
    String getName() const override
    {
        return U"파이어볼";
    }
};

class UppercutCommand : public Command
{
public:
    void execute() override
    {
        Print << U"👊 어퍼컷!";
    }
    
    String getName() const override
    {
        return U"어퍼컷";
    }
};

// 입력 버퍼 클래스
class InputBuffer
{
public:
    InputBuffer(double timeWindow = 1.0)
        : m_timeWindow(timeWindow) {}
    
    void addInput(char32 key)
    {
        const double currentTime = Scene::Time();
        
        // 오래된 입력 제거
        m_buffer.remove_if([&](const InputEvent& evt) {
            return (currentTime - evt.timestamp) > m_timeWindow;
        });
        
        // 새 입력 추가
        m_buffer.push_back(InputEvent{ key, currentTime });
    }
    
    std::optional<std::unique_ptr<Command>> checkCommands() const
    {
        // 최근 입력을 문자열로 변환
        String inputSequence;
        for (const auto& evt : m_buffer)
        {
            inputSequence += evt.key;
        }
        
        // 파이어볼: ↓↘→ + A (DSA)
        if (inputSequence.ends_with(U"DSA"))
        {
            return std::make_unique<FireballCommand>();
        }
        
        // 어퍼컷: →↓↘ + A (SDSA)
        if (inputSequence.ends_with(U"SDSA"))
        {
            return std::make_unique<UppercutCommand>();
        }
        
        return std::nullopt;
    }
    
    void clear()
    {
        m_buffer.clear();
    }
    
    String getSequence() const
    {
        String result;
        for (const auto& evt : m_buffer)
        {
            result += evt.key;
        }
        return result;
    }
    
private:
    Array<InputEvent> m_buffer;
    double m_timeWindow;
};

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    InputBuffer inputBuffer{ 1.0 }; // 1초 윈도우
    
    while (System::Update())
    {
        // 방향키 입력
        if (KeyDown.down())
        {
            inputBuffer.addInput(U'D');
        }
        if (KeyRight.down())
        {
            inputBuffer.addInput(U'S');
        }
        if (KeyA.down())
        {
            inputBuffer.addInput(U'A');
        }
        
        // Space로 버퍼 초기화
        if (KeySpace.down())
        {
            inputBuffer.clear();
        }
        
        // 커맨드 체크
        if (auto command = inputBuffer.checkCommands())
        {
            (*command)->execute();
            inputBuffer.clear();
        }
        
        // UI
        font(U"입력 시퀀스: {}"_fmt(inputBuffer.getSequence()))
            .draw(20, 20, Palette::White);
        
        font(U"↓ = D키, → = S키, 공격 = A키")
            .draw(20, 60, Palette::Yellow);
        
        font(U"파이어볼: D → S → A")
            .draw(20, 90, Palette::Skyblue);
        
        font(U"어퍼컷: S → D → S → A")
            .draw(20, 120, Palette::Skyblue);
        
        font(U"Space: 입력 초기화")
            .draw(20, 150, Palette::Orange);
    }
}
```

이 구조는 다음과 같은 특징을 가진다:

1. **시간 기반 버퍼링**: 일정 시간 내의 입력만 유효하게 처리한다.
2. **커맨드 패턴**: 각 특수 기술을 독립적인 커맨드 객체로 캡슐화한다.
3. **확장 가능성**: 새로운 커맨드를 쉽게 추가할 수 있다.
4. **유연한 매칭**: 문자열 패턴 매칭으로 복잡한 입력 조합을 인식한다.

### 19.5.3 입력 우선순위와 컨텍스트
게임의 상태에 따라 같은 입력이 다르게 처리되어야 할 때가 있다. 이를 위해 입력 컨텍스트 시스템을 구현할 수 있다.

```cpp
# include <Siv3D.hpp>

// 게임 상태
enum class GameState
{
    Playing,
    Paused,
    Menu
};

// 입력 컨텍스트 인터페이스
class InputContext
{
public:
    virtual ~InputContext() = default;
    virtual void handleInput() = 0;
    virtual String getName() const = 0;
};

// 플레이 중 입력 처리
class PlayingContext : public InputContext
{
public:
    void handleInput() override
    {
        if (KeySpace.down())
        {
            Print << U"게임 중: 점프!";
        }
        
        if (KeyZ.down())
        {
            Print << U"게임 중: 공격!";
        }
    }
    
    String getName() const override
    {
        return U"플레이 중";
    }
};

// 일시정지 중 입력 처리
class PausedContext : public InputContext
{
public:
    void handleInput() override
    {
        if (KeySpace.down())
        {
            Print << U"일시정지: 메뉴 선택";
        }
        
        if (KeyZ.down())
        {
            Print << U"일시정지: 취소";
        }
    }
    
    String getName() const override
    {
        return U"일시정지";
    }
};

// 메뉴 입력 처리
class MenuContext : public InputContext
{
public:
    void handleInput() override
    {
        if (KeyUp.down())
        {
            Print << U"메뉴: 위로 이동";
        }
        
        if (KeyDown.down())
        {
            Print << U"메뉴: 아래로 이동";
        }
        
        if (KeySpace.down())
        {
            Print << U"메뉴: 선택";
        }
    }
    
    String getName() const override
    {
        return U"메뉴";
    }
};

void Main()
{
    Font font1{ FontMethod::MSDF, 30, Typeface::CJK_Regular_KR };
    Font font2{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    GameState currentState = GameState::Playing;
    
    // 각 상태별 입력 컨텍스트
    std::map<GameState, std::unique_ptr<InputContext>> contexts;
    contexts[GameState::Playing] = std::make_unique<PlayingContext>();
    contexts[GameState::Paused] = std::make_unique<PausedContext>();
    contexts[GameState::Menu] = std::make_unique<MenuContext>();
    
    while (System::Update())
    {
        // 상태 전환 (숫자 키로 테스트)
        if (Key1.down())
        {
            currentState = GameState::Playing;
        }
        if (Key2.down())
        {
            currentState = GameState::Paused;
        }
        if (Key3.down())
        {
            currentState = GameState::Menu;
        }
        
        // 현재 상태의 입력 처리
        contexts[currentState]->handleInput();
        
        // UI
        font1(U"현재 상태: {}"_fmt(contexts[currentState]->getName()))
            .draw(20, 20, Palette::Yellow);
        
        font2(U"1: 플레이 중, 2: 일시정지, 3: 메뉴")
            .draw(20, 70, Palette::White);
        
        font2(U"Space, Z, 방향키를 눌러보세요")
            .draw(20, 100, Palette::White);
        
        // 상태별 안내
        if (currentState == GameState::Playing)
        {
            font2(U"Space: 점프, Z: 공격")
                .draw(20, 140, Palette::Skyblue);
        }
        else if (currentState == GameState::Paused)
        {
            font2(U"Space: 선택, Z: 취소")
                .draw(20, 140, Palette::Skyblue);
        }
        else if (currentState == GameState::Menu)
        {
            font2(U"↑↓: 메뉴 이동, Space: 선택")
                .draw(20, 140, Palette::Skyblue);
        }
    }
}
```

이 패턴의 장점은 다음과 같다:

1. **명확한 분리**: 각 게임 상태의 입력 처리 로직이 독립적이다.
2. **유지보수성**: 특정 상태의 입력 로직을 수정할 때 다른 상태에 영향을 주지 않는다.
3. **확장성**: 새로운 게임 상태와 입력 컨텍스트를 쉽게 추가할 수 있다.
  

</br>  
  

## 19.6 실습 문제

### 문제 1: 드로잉 애플리케이션
마우스로 자유롭게 그림을 그릴 수 있는 간단한 드로잉 애플리케이션을 만들어보자.

**요구사항:**
1. 마우스 왼쪽 버튼을 누르고 드래그하면 선이 그려진다
2. 마우스 오른쪽 버튼을 누르고 드래그하면 지우개 역할을 한다
3. 숫자 키 1-5로 브러시 크기를 변경할 수 있다
4. R, G, B 키로 색상을 변경할 수 있다
5. Space 키로 캔버스를 모두 지운다

**힌트:**
```cpp
// 드로잉 포인트를 저장할 구조체
struct DrawPoint
{
    Vec2 pos;
    ColorF color;
    double size;
    bool isEraser;
};
```

### 문제 2: 반응 속도 테스트 게임
사용자의 반응 속도를 측정하는 게임을 만들어보자.

**요구사항:**
1. Space 키를 누르면 게임이 시작된다
2. 랜덤한 시간(1-3초) 후 화면이 특정 색으로 변한다
3. 색이 변하는 순간부터 사용자가 Space를 누를 때까지의 시간을 측정한다
4. 5회 측정 후 평균 반응 속도를 표시한다
5. 너무 빨리 누르면 "부정행위!" 메시지를 표시한다

**힌트:**
```cpp
// std::chrono를 활용한 시간 측정
#include <chrono>

auto startTime = std::chrono::high_resolution_clock::now();
auto endTime = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
    endTime - startTime
).count();
```

### 문제 3: 간단한 피아노 애플리케이션
키보드로 연주할 수 있는 간단한 피아노를 만들어보자.

**요구사항:**
1. A-K 키를 도레미파솔라시도 음계로 매핑한다
2. 키를 누르면 해당하는 음이 재생된다 (Siv3D의 Wave와 Audio 사용)
3. 눌려진 건반이 시각적으로 표시된다
4. 여러 키를 동시에 누를 수 있다 (화음)
5. 숫자 키로 옥타브를 변경할 수 있다

**힌트:**
```cpp
// 간단한 사인파 생성
Wave wave = Wave::Generate(1s, [&](double t) {
    return 0.5 * std::sin(2_pi * 440.0 * t); // 440Hz = A4(라)
});

Audio audio(wave);
audio.play();
```
  

</br>  
  

## 19.7 심화 내용

### 19.7.1 게임패드 입력 처리
Siv3D는 Xbox 컨트롤러 등의 게임패드 입력도 지원한다.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 연결된 게임패드 확인
        for (auto i : step(Gamepad.MaxPlayerCount))
        {
            if (const auto gamepad = Gamepad(i))
            {
                // 버튼 입력
                if (gamepad.buttons[0].down()) // A 버튼
                {
                    Print << U"플레이어 {} A 버튼 누름"_fmt(i);
                }
                
                // 아날로그 스틱
                const Vec2 leftStick = gamepad.axes[0]; // 왼쪽 스틱
                
                if (leftStick.length() > 0.1) // 데드존 처리
                {
                    Circle{ Scene::Center() + leftStick * 100, 20 }
                        .draw(Palette::Green);
                }
                
                // 트리거
                const double leftTrigger = gamepad.axes[4];
                
                font(U"왼쪽 트리거: {:.2f}"_fmt(leftTrigger))
                    .draw(20, 20 + i * 30, Palette::White);
            }
        }
    }
}
```

### 19.7.2 입력 리플레이 시스템
게임의 리플레이 기능을 구현하기 위한 입력 기록 시스템을 만들어보자.

```cpp
# include <Siv3D.hpp>

// 프레임별 입력 기록
struct FrameInput
{
    int32 frame;
    Array<Input> pressedKeys;
    Vec2 mousePos;
};

class InputRecorder
{
public:
    void startRecording()
    {
        m_recording = true;
        m_playback = false;
        m_recordedInputs.clear();
        m_currentFrame = 0;
    }
    
    void stopRecording()
    {
        m_recording = false;
    }
    
    void record()
    {
        if (!m_recording)
            return;
        
        FrameInput frameInput;
        frameInput.frame = m_currentFrame;
        frameInput.mousePos = Cursor::PosF();
        
        // 눌려진 모든 키 기록
        for (int32 i = 0; i < 256; ++i)
        {
            Input key{ InputDeviceType::Keyboard, static_cast<uint8>(i) };
            if (key.pressed())
            {
                frameInput.pressedKeys.push_back(key);
            }
        }
        
        m_recordedInputs.push_back(frameInput);
        ++m_currentFrame;
    }
    
    void startPlayback()
    {
        m_playback = true;
        m_recording = false;
        m_playbackIndex = 0;
        m_currentFrame = 0;
    }
    
    std::optional<FrameInput> getPlaybackInput()
    {
        if (!m_playback || m_playbackIndex >= m_recordedInputs.size())
            return std::nullopt;
        
        if (m_recordedInputs[m_playbackIndex].frame == m_currentFrame)
        {
            return m_recordedInputs[m_playbackIndex++];
        }
        
        ++m_currentFrame;
        return std::nullopt;
    }
    
    bool isPlaybackFinished() const
    {
        return m_playback && m_playbackIndex >= m_recordedInputs.size();
    }
    
    void saveToFile(const FilePath& path) const
    {
        // JSON으로 저장 (실제 구현에서는 직렬화 필요)
        JSONWriter json{ path };
        
        json.startArray();
        for (const auto& input : m_recordedInputs)
        {
            json.startObject();
            json.key(U"frame").write(input.frame);
            json.key(U"mouseX").write(input.mousePos.x);
            json.key(U"mouseY").write(input.mousePos.y);
            // 키 정보도 저장...
            json.endObject();
        }
        json.endArray();
    }
    
private:
    bool m_recording = false;
    bool m_playback = false;
    Array<FrameInput> m_recordedInputs;
    size_t m_playbackIndex = 0;
    int32 m_currentFrame = 0;
};
```

### 19.7.3 접근성을 고려한 입력 처리
장애가 있는 사용자도 사용할 수 있도록 다양한 입력 방식을 지원하는 것이 중요하다.

```cpp
# include <Siv3D.hpp>

class AccessibleInputManager
{
public:
    // 키 리피트 설정 (키를 누르고 있을 때 반복 입력)
    void setKeyRepeat(double initialDelay, double repeatInterval)
    {
        m_initialDelay = initialDelay;
        m_repeatInterval = repeatInterval;
    }
    
    bool checkKeyWithRepeat(const Input& key)
    {
        if (key.down())
        {
            m_lastKeyTime = Scene::Time();
            m_repeatStarted = false;
            return true;
        }
        
        if (key.pressed())
        {
            const double elapsed = Scene::Time() - m_lastKeyTime;
            
            if (!m_repeatStarted && elapsed > m_initialDelay)
            {
                m_repeatStarted = true;
                m_lastKeyTime = Scene::Time();
                return true;
            }
            
            if (m_repeatStarted && elapsed > m_repeatInterval)
            {
                m_lastKeyTime = Scene::Time();
                return true;
            }
        }
        
        return false;
    }
    
    // 클릭 홀드 시간 (실수로 클릭하는 것 방지)
    bool checkClickWithDelay(const Input& input, double holdTime = 0.3)
    {
        if (input.down())
        {
            m_clickStartTime = Scene::Time();
            return false;
        }
        
        if (input.up())
        {
            const double held = Scene::Time() - m_clickStartTime;
            return held >= holdTime;
        }
        
        return false;
    }
    
private:
    double m_initialDelay = 0.5;
    double m_repeatInterval = 0.1;
    double m_lastKeyTime = 0.0;
    bool m_repeatStarted = false;
    double m_clickStartTime = 0.0;
};
```
   

</br>


## 19.8 정리
이번 장에서는 Siv3D에서 다양한 입력을 처리하는 방법을 배웠다. 마우스, 키보드, 터치 입력의 기본부터 복잡한 입력 상태 관리, 커맨드 패턴, 입력 컨텍스트까지 다루었다.

**핵심 요점:**

1. Siv3D의 입력 API는 직관적이고 사용하기 쉽다. `down()`, `pressed()`, `up()` 세 가지 상태로 대부분의 입력을 처리할 수 있다.

2. 도형 객체는 자체적으로 마우스 충돌을 감지하는 함수를 제공하여, 버튼이나 UI 요소를 쉽게 만들 수 있다.

3. `enum class`와 매핑을 활용하면 입력을 추상화하여 유지보수성과 확장성을 높일 수 있다.

4. 입력 버퍼링과 커맨드 패턴을 조합하면 복잡한 입력 조합을 체계적으로 처리할 수 있다.

5. 게임 상태에 따라 입력 컨텍스트를 전환하면, 같은 키가 상황에 맞게 다르게 동작하도록 만들 수 있다.

Modern C++의 타입 시스템, `std::optional`, `std::unique_ptr` 등을 활용하면 안전하고 명확한 입력 처리 시스템을 구축할 수 있다. 다음 장에서는 그래픽과 텍스트를 다루어 더욱 풍부한 시각적 표현을 만들어본다.   