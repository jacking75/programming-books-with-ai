# ëª¨ë˜ C++ë¡œ ì‹œì‘í•˜ëŠ” ì•ˆì „í•˜ê³  ì‰¬ìš´ C++ í”„ë¡œê·¸ë˜ë° 

ì €ì: ìµœí¥ë°°, Claude AI   
    
ê¶Œì¥ ê°œë°œ í™˜ê²½
- **IDE**: Visual Studio 2022 (Community ì´ìƒ)
- **ì»´íŒŒì¼ëŸ¬**: MSVC v143 (C++20 ì§€ì›)
- **OS**: Windows 10 ì´ìƒ

-----  
  
# Chapter 19: ì…ë ¥ ì²˜ë¦¬ì™€ ìƒí˜¸ì‘ìš©

## 19.1 ë“¤ì–´ê°€ë©°
ì´ì œ Siv3Dì˜ ê¸°ë³¸ êµ¬ì¡°ë¥¼ ì´í•´í–ˆìœ¼ë‹ˆ, ì‚¬ìš©ìì™€ì˜ ìƒí˜¸ì‘ìš©ì„ ë‹¤ë£¨ì–´ ë³´ì. í”„ë¡œê·¸ë¨ì´ ì‚¬ìš©ìì˜ ì…ë ¥ì— ë°˜ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì§„ì •í•œ ì˜ë¯¸ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ë¼ í•  ìˆ˜ ì—†ë‹¤. ì´ ì¥ì—ì„œëŠ” ë§ˆìš°ìŠ¤, í‚¤ë³´ë“œ, í„°ì¹˜ ì…ë ¥ì„ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë°°ìš°ê³ , ì…ë ¥ ìƒíƒœë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ê¸°ë²•ì„ ìµíŒë‹¤.

Modern C++ì˜ ê°•ë ¥í•œ íƒ€ì… ì‹œìŠ¤í…œê³¼ Siv3Dì˜ ì§ê´€ì ì¸ APIê°€ ê²°í•©ë˜ë©´, ë³µì¡í•œ ì…ë ¥ ì²˜ë¦¬ë„ ì•ˆì „í•˜ê³  ì½ê¸° ì‰¬ìš´ ì½”ë“œë¡œ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

## 19.2 ë§ˆìš°ìŠ¤ ì…ë ¥ ì²˜ë¦¬

### 19.2.1 ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì–»ê¸°
ë§ˆìš°ìŠ¤ì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ ì–»ëŠ” ê²ƒì€ Siv3Dì—ì„œ ë§¤ìš° ê°„ë‹¨í•˜ë‹¤. `Cursor::Pos()`ëŠ” í˜„ì¬ ë§ˆìš°ìŠ¤ ì»¤ì„œì˜ í™”ë©´ ì¢Œí‘œë¥¼ ë°˜í™˜í•œë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ Point íƒ€ì…ìœ¼ë¡œ ë°›ëŠ”ë‹¤
        const Point mousePos = Cursor::Pos();
        
        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ì›ì„ ê·¸ë¦°ë‹¤
        Circle{ mousePos, 20 }.draw(Palette::Skyblue);
        
        // ì¢Œí‘œë¥¼ í…ìŠ¤íŠ¸ë¡œ ì¶œë ¥í•œë‹¤
        font(U"ë§ˆìš°ìŠ¤ ìœ„ì¹˜: ({}, {})"_fmt(mousePos.x, mousePos.y)).draw(10, 10, Palette::White);
    }
}
```

`Cursor::Pos()`ëŠ” ì •ìˆ˜ ì¢Œí‘œë¥¼ ë‹´ì€ `Point` íƒ€ì…ì„ ë°˜í™˜í•œë‹¤. ë” ì •ë°€í•œ ì¢Œí‘œê°€ í•„ìš”í•˜ë‹¤ë©´ `Cursor::PosF()`ë¥¼ ì‚¬ìš©í•˜ì—¬ `Vec2` íƒ€ì…(ì‹¤ìˆ˜ ì¢Œí‘œ)ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
	Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

	while (System::Update())
	{
		// ì‹¤ìˆ˜ ì¢Œí‘œë¡œ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ì–»ëŠ”ë‹¤
		const Vec2 mousePos = Cursor::PosF();

		Circle{ mousePos, 20 }.draw(Palette::Skyblue);

		font(U"ë§ˆìš°ìŠ¤ ìœ„ì¹˜: ({:.2f}, {:.2f})"_fmt(mousePos.x, mousePos.y)).draw(10, 10, Palette::White);
	}
}
```

### 19.2.2 ë§ˆìš°ìŠ¤ ë²„íŠ¼ í´ë¦­ ê°ì§€
Siv3DëŠ” ë§ˆìš°ìŠ¤ ë²„íŠ¼ì˜ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ë‹¤ì–‘í•œ í•¨ìˆ˜ë¥¼ ì œê³µí•œë‹¤. `MouseL`, `MouseR`, `MouseM`ì€ ê°ê° ì™¼ìª½, ì˜¤ë¥¸ìª½, ê°€ìš´ë° ë²„íŠ¼ì„ ë‚˜íƒ€ë‚¸ë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    int clickCount = 0;
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // ë§ˆìš°ìŠ¤ ì™¼ìª½ ë²„íŠ¼ì´ ëˆŒë ¸ëŠ”ì§€ í™•ì¸
        if (MouseL.down())
        {
            ++clickCount;
        }
        
        // ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½ ë²„íŠ¼ì´ ëˆŒë ¤ìˆëŠ”ì§€ í™•ì¸
        if (MouseR.pressed())
        {
            Circle{ Cursor::Pos(), 30 }.draw(ColorF{ 1.0, 0.0, 0.0, 0.3 });
        }
        
        font(U"í´ë¦­ íšŸìˆ˜: {}"_fmt(clickCount))
            .draw(20, 20, Palette::White);
        
        font(U"ì™¼ìª½ í´ë¦­: ì¹´ìš´íŠ¸ ì¦ê°€")
            .draw(20, 60, Palette::Yellow);
        
        font(U"ì˜¤ë¥¸ìª½ í´ë¦­: ë°˜íˆ¬ëª… ì› í‘œì‹œ")
            .draw(20, 90, Palette::Yellow);
    }
}
```

ë§ˆìš°ìŠ¤ ì…ë ¥ì—ëŠ” ì„¸ ê°€ì§€ ì£¼ìš” ìƒíƒœê°€ ìˆë‹¤:

- `down()`: ë²„íŠ¼ì´ ë§‰ ëˆŒë¦° ìˆœê°„ (í•œ í”„ë ˆì„ ë™ì•ˆë§Œ `true`)
- `pressed()`: ë²„íŠ¼ì´ ëˆŒë ¤ìˆëŠ” ë™ì•ˆ ê³„ì† (ëˆŒë ¤ìˆëŠ” ëª¨ë“  í”„ë ˆì„ì—ì„œ `true`)
- `up()`: ë²„íŠ¼ì´ ë§‰ ë–¼ì–´ì§„ ìˆœê°„ (í•œ í”„ë ˆì„ ë™ì•ˆë§Œ `true`)

```cpp
# include <Siv3D.hpp>

void Main()
{
    Vec2 dragStart{ 0, 0 };
    bool isDragging = false;
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // ë“œë˜ê·¸ ì‹œì‘
        if (MouseL.down())
        {
            dragStart = Cursor::PosF();
            isDragging = true;
        }
        
        // ë“œë˜ê·¸ ì¤‘
        if (isDragging && MouseL.pressed())
        {
            const Vec2 dragEnd = Cursor::PosF();
            Line{ dragStart, dragEnd }.draw(5, Palette::Orange);
            Circle{ dragEnd, 10 }.draw(Palette::Red);
        }
        
        // ë“œë˜ê·¸ ì¢…ë£Œ
        if (MouseL.up())
        {
            isDragging = false;
        }
        
        font(U"ë§ˆìš°ìŠ¤ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì„ ì„ ê·¸ë ¤ë³´ì„¸ìš”")
            .draw(20, 20, Palette::White);
    }
}
```

### 19.2.3 íŠ¹ì • ì˜ì—­ í´ë¦­ ê°ì§€
ë„í˜• ê°ì²´ëŠ” ë§ˆìš°ìŠ¤ ì…ë ¥ì„ ì§ì ‘ ì²˜ë¦¬í•˜ëŠ” ë©¤ë²„ í•¨ìˆ˜ë¥¼ ì œê³µí•œë‹¤. ì´ë¥¼ í™œìš©í•˜ë©´ ë²„íŠ¼ì´ë‚˜ ì¸í„°ë™í‹°ë¸Œí•œ UI ìš”ì†Œë¥¼ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // ë²„íŠ¼ ì˜ì—­ ì •ì˜
    const Rect button1{ 100, 100, 200, 60 };
    const Rect button2{ 100, 180, 200, 60 };
    const Circle circleButton{ 400, 200, 50 };
    
    String message = U"ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”";
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // ì‚¬ê°í˜• ë²„íŠ¼ 1
        if (button1.leftClicked())
        {
            message = U"ë²„íŠ¼ 1ì´ í´ë¦­ë˜ì—ˆìŠµë‹ˆë‹¤";
        }
        
        // ë§ˆìš°ìŠ¤ê°€ ì˜¬ë¼ê°€ ìˆìœ¼ë©´ ìƒ‰ìƒ ë³€ê²½
        button1.draw(button1.mouseOver() ? Palette::Lightblue : Palette::Gray);
        font(U"ë²„íŠ¼ 1").drawAt(button1.center(), Palette::Black);
        
        // ì‚¬ê°í˜• ë²„íŠ¼ 2
        if (button2.leftClicked())
        {
            message = U"ë²„íŠ¼ 2ê°€ í´ë¦­ë˜ì—ˆìŠµë‹ˆë‹¤";
        }
        
        button2.draw(button2.mouseOver() ? Palette::Lightgreen : Palette::Gray);
        font(U"ë²„íŠ¼ 2").drawAt(button2.center(), Palette::Black);
        
        // ì›í˜• ë²„íŠ¼
        if (circleButton.leftClicked())
        {
            message = U"ì›í˜• ë²„íŠ¼ì´ í´ë¦­ë˜ì—ˆìŠµë‹ˆë‹¤";
        }
        
        circleButton.draw(circleButton.mouseOver() ? Palette::Orange : Palette::Gray);
        font(U"í´ë¦­").drawAt(circleButton.center, Palette::White);
        
        // ë©”ì‹œì§€ ì¶œë ¥
        font(message).draw(50, 350, Palette::Yellow);
    }
}
```

ë„í˜•ì˜ `leftClicked()`, `rightClicked()` í•¨ìˆ˜ëŠ” í•´ë‹¹ ì˜ì—­ì´ í´ë¦­ë˜ì—ˆëŠ”ì§€ í™•ì¸í•œë‹¤. `mouseOver()` í•¨ìˆ˜ëŠ” ë§ˆìš°ìŠ¤ ì»¤ì„œê°€ ë„í˜• ìœ„ì— ìˆëŠ”ì§€ í™•ì¸í•œë‹¤. ì´ëŸ¬í•œ í•¨ìˆ˜ë“¤ì€ ë‚´ë¶€ì ìœ¼ë¡œ ë§ˆìš°ìŠ¤ ì¢Œí‘œì™€ ë„í˜•ì˜ ì¶©ëŒì„ ê³„ì‚°í•´ì£¼ë¯€ë¡œ, ì§ì ‘ ì¢Œí‘œ ë¹„êµë¥¼ í•  í•„ìš”ê°€ ì—†ë‹¤.

### 19.2.4 ë§ˆìš°ìŠ¤ íœ  ì…ë ¥
ë§ˆìš°ìŠ¤ íœ ì˜ íšŒì „ì„ ê°ì§€í•˜ì—¬ í™•ëŒ€/ì¶•ì†Œë‚˜ ìŠ¤í¬ë¡¤ ê¸°ëŠ¥ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    double scale = 1.0;
    const double minScale = 0.5;
    const double maxScale = 3.0;
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // ë§ˆìš°ìŠ¤ íœ  ì…ë ¥ ë°›ê¸°
        const double wheelDelta = Mouse::Wheel();
        
        if (wheelDelta != 0.0)
        {
            scale += wheelDelta * 0.1;
            scale = Clamp(scale, minScale, maxScale);
        }
        
        // ìŠ¤ì¼€ì¼ì— ë”°ë¼ ì›ì˜ í¬ê¸° ë³€ê²½
        const double radius = 100 * scale;
        Circle{ Scene::Center(), radius }.draw(Palette::Skyblue);
        
        font(U"ë§ˆìš°ìŠ¤ íœ ë¡œ í¬ê¸° ì¡°ì ˆ")
            .drawAt(Scene::Center().x, 50, Palette::White);
        
        font(U"ìŠ¤ì¼€ì¼: {:.2f}"_fmt(scale))
            .draw(20, 20, Palette::Yellow);
    }
}
```

`Mouse::Wheel()`ì€ ë§ˆìš°ìŠ¤ íœ ì´ íšŒì „ëœ ì •ë„ë¥¼ ë°˜í™˜í•œë‹¤. ìœ„ë¡œ ìŠ¤í¬ë¡¤í•˜ë©´ ì–‘ìˆ˜, ì•„ë˜ë¡œ ìŠ¤í¬ë¡¤í•˜ë©´ ìŒìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤. `Clamp()` í•¨ìˆ˜ëŠ” ê°’ì„ íŠ¹ì • ë²”ìœ„ ë‚´ë¡œ ì œí•œí•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë‹¤.
  

</br>  
  
  
## 19.3 í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬

### 19.3.1 í‚¤ ì…ë ¥ ê¸°ë³¸
í‚¤ë³´ë“œ ì…ë ¥ì€ `Key` ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì•„ë˜ì˜ ìƒìˆ˜ë¥¼ í†µí•´ ì²˜ë¦¬í•œë‹¤. ë§ˆìš°ìŠ¤ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `down()`, `pressed()`, `up()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
	Vec2 playerPos = Scene::Center();
	const double moveSpeed = 200.0; // í”½ì…€/ì´ˆ

	Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

	while (System::Update())
	{
		// ë¸íƒ€ íƒ€ì„ ê³„ì‚° (ì´ì „ í”„ë ˆì„ê³¼ì˜ ì‹œê°„ ì°¨ì´)
		const double deltaTime = Scene::DeltaTime();

		// ë°©í–¥í‚¤ë¡œ ì´ë™
		if (KeyLeft.pressed())
		{
			playerPos.x -= moveSpeed * deltaTime;
		}
		if (KeyRight.pressed())
		{
			playerPos.x += moveSpeed * deltaTime;
		}
		if (KeyUp.pressed())
		{
			playerPos.y -= moveSpeed * deltaTime;
		}
		if (KeyDown.pressed())
		{
			playerPos.y += moveSpeed * deltaTime;
		}

		// í™”ë©´ ê²½ê³„ ì²´í¬
		playerPos.x = std::clamp(playerPos.x, 0.0, static_cast<double>(Scene::Width()));
		playerPos.y = std::clamp(playerPos.y, 0.0, static_cast<double>(Scene::Height()));

		// í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
		Circle{ playerPos, 20 }.draw(Palette::Green);

		font(U"ë°©í–¥í‚¤ë¡œ ì´ë™í•˜ì„¸ìš”")
			.draw(20, 20, Palette::White);
	}
}
```

`Scene::DeltaTime()`ì€ ì´ì „ í”„ë ˆì„ê³¼ì˜ ì‹œê°„ ì°¨ì´ë¥¼ ì´ˆ ë‹¨ìœ„ë¡œ ë°˜í™˜í•œë‹¤. ì´ë¥¼ ì´ìš©í•˜ë©´ í”„ë ˆì„ë ˆì´íŠ¸ì— ê´€ê³„ì—†ì´ ì¼ì •í•œ ì†ë„ë¡œ ì›€ì§ì´ëŠ” ì˜¤ë¸Œì íŠ¸ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

### 19.3.2 ë¬¸ì í‚¤ì™€ ìˆ˜ì •ì í‚¤
ì•ŒíŒŒë²³, ìˆ«ì, íŠ¹ìˆ˜ ë¬¸ì í‚¤ë„ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤. ìˆ˜ì •ì í‚¤(Shift, Ctrl, Alt)ì™€ì˜ ì¡°í•©ë„ ì‰½ê²Œ ê°ì§€í•  ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    String inputText = U"";
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // Space í‚¤ë¡œ í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
        if (KeySpace.down())
        {
            inputText = U"";
        }
        
        // Ctrl+Së¡œ ì €ì¥ ì‹œë®¬ë ˆì´ì…˜
        if ((KeyControl + KeyS).down())
        {
            Print << U"ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!";
        }
        
        // Shift+Aë¡œ ëª¨ë‘ ì„ íƒ ì‹œë®¬ë ˆì´ì…˜
        if ((KeyShift + KeyA).down())
        {
            Print << U"ëª¨ë‘ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤!";
        }
        
        // A-Z í‚¤ ì…ë ¥
        for (auto i : step(26))
        {
            const auto key = Input{ InputDeviceType::Keyboard, 
                                   static_cast<uint8>('A' + i) };
            if (key.down())
            {
                inputText += static_cast<char32>(U'A' + i);
            }
        }
        
        // ë°±ìŠ¤í˜ì´ìŠ¤
        if (KeyBackspace.down() && !inputText.empty())
        {
            inputText.pop_back();
        }
        
        // UI ê·¸ë¦¬ê¸°
        Rect{ 50, 50, 700, 60 }.draw(Palette::White);
        font(inputText).draw(60, 60, Palette::Black);
        
        font(U"A-Z í‚¤ë¥¼ ëˆŒëŸ¬ ì…ë ¥í•˜ì„¸ìš”")
            .draw(50, 130, Palette::Yellow);
        font(U"Space: ì´ˆê¸°í™”, Ctrl+S: ì €ì¥, Shift+A: ëª¨ë‘ ì„ íƒ")
            .draw(50, 160, Palette::Yellow);
    }
}
```

í‚¤ ì¡°í•©ì€ `+` ì—°ì‚°ìë¡œ í‘œí˜„í•œë‹¤. `(KeyControl + KeyS).down()`ì€ Ctrl í‚¤ì™€ S í‚¤ê°€ ë™ì‹œì— ëˆŒë ¸ì„ ë•Œ `true`ë¥¼ ë°˜í™˜í•œë‹¤.

### 19.3.3 í…ìŠ¤íŠ¸ ì…ë ¥ ì²˜ë¦¬
ê°„ë‹¨í•œ í‚¤ ì…ë ¥ë³´ë‹¤ ë³µì¡í•œ í…ìŠ¤íŠ¸ ì…ë ¥(í•œê¸€, ì¼ë³¸ì–´ ë“±ì˜ IME ì…ë ¥ í¬í•¨)ì„ ì²˜ë¦¬í•˜ë ¤ë©´ `TextInput` í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•œë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    // í…ìŠ¤íŠ¸ ì…ë ¥ ê°ì²´ ìƒì„±
    TextEditState textEdit;
    Font font{ FontMethod::MSDF, 25, Typeface::CJK_Regular_KR };
    
    while (System::Update())
    {
        // í…ìŠ¤íŠ¸ ì…ë ¥ ì—…ë°ì´íŠ¸
        SimpleGUI::TextBox(textEdit, Vec2{ 100, 100 }, 600);
        
        // Enter í‚¤ë¡œ ì…ë ¥ í™•ì •
        if (KeyEnter.down() && !textEdit.text.empty())
        {
            Print << U"ì…ë ¥ëœ í…ìŠ¤íŠ¸: " << textEdit.text;
            textEdit.clear();
        }
        
        font(U"í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ê³  Enterë¥¼ ëˆ„ë¥´ì„¸ìš”")
            .draw(100, 50, Palette::White);
        
        // í˜„ì¬ ì…ë ¥ëœ í…ìŠ¤íŠ¸ ê¸¸ì´ í‘œì‹œ
        font(U"ê¸¸ì´: {}"_fmt(textEdit.text.size()))
            .draw(100, 150, Palette::Yellow);
    }
}
```

`SimpleGUI::TextBox()`ëŠ” Siv3Dê°€ ì œê³µí•˜ëŠ” ê°„í¸í•œ í…ìŠ¤íŠ¸ ì…ë ¥ ìœ„ì ¯ì´ë‹¤. `TextEditState` ê°ì²´ê°€ ì…ë ¥ ìƒíƒœë¥¼ ê´€ë¦¬í•˜ë©°, ì»¤ì„œ ìœ„ì¹˜, ì„ íƒ ì˜ì—­ ë“±ì˜ ì •ë³´ë¥¼ ìë™ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤.

### 19.3.4 í‚¤ ìƒíƒœì˜ ì§€ì† ì‹œê°„
í‚¤ê°€ ì–¼ë§ˆë‚˜ ì˜¤ë˜ ëˆŒë ¤ ìˆì—ˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ì´ë¥¼ í™œìš©í•˜ë©´ ì°¨ì§€ ê³µê²©ì´ë‚˜ ì¥ê¸° ì…ë ¥ íš¨ê³¼ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    double chargeLevel = 0.0;
    const double maxChargeTime = 2.0; // 2ì´ˆ
    bool charged = false;
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // Space í‚¤ë¥¼ ëˆ„ë¥´ê³  ìˆëŠ” ì‹œê°„
        const double pressedDuration = KeySpace.pressedDuration();
        
        if (KeySpace.pressed())
        {
            // ì¶©ì „ ë ˆë²¨ ê³„ì‚° (0.0 ~ 1.0)
            chargeLevel = Min(pressedDuration / maxChargeTime, 1.0);
            charged = false;
        }
        
        // Space í‚¤ë¥¼ ë—ì„ ë•Œ
        if (KeySpace.up() && chargeLevel > 0.0)
        {
            Print << U"ë°œì‚¬! íŒŒì›Œ: {:.0f}%"_fmt(chargeLevel * 100);
            charged = true;
        }
        
        // ì¶©ì „ ë°” ê·¸ë¦¬ê¸°
        const Rect chargeBarBg{ 100, 200, 600, 40 };
        const Rect chargeBarFg{ 100, 200, static_cast<int>(600 * chargeLevel), 40 };
        
        chargeBarBg.draw(Palette::Gray);
        chargeBarFg.draw(ColorF{ chargeLevel, 1.0 - chargeLevel, 0.0 });
        
        // ì•ˆë‚´ í…ìŠ¤íŠ¸
        font(U"Space í‚¤ë¥¼ ëˆŒëŸ¬ ì¶©ì „í•˜ì„¸ìš”")
            .draw(100, 150, Palette::White);
        
        font(U"ì¶©ì „: {:.0f}%"_fmt(chargeLevel * 100))
            .draw(100, 250, Palette::Yellow);
    }
}
```

`pressedDuration()` í•¨ìˆ˜ëŠ” í‚¤ê°€ ëˆŒë ¤ìˆëŠ” ì‹œê°„ì„ ì´ˆ ë‹¨ìœ„ë¡œ ë°˜í™˜í•œë‹¤. ì´ë¥¼ ìµœëŒ€ ì¶©ì „ ì‹œê°„ìœ¼ë¡œ ë‚˜ëˆ„ë©´ 0.0ì—ì„œ 1.0 ì‚¬ì´ì˜ ì •ê·œí™”ëœ ê°’ì„ ì–»ì„ ìˆ˜ ìˆë‹¤.
  

</br>  
  
  
## 19.4 í„°ì¹˜ ì…ë ¥ ê¸°ì´ˆ

### 19.4.1 í„°ì¹˜ ì…ë ¥ê³¼ ë§ˆìš°ìŠ¤ ì…ë ¥ì˜ í†µí•©
Siv3DëŠ” í„°ì¹˜ ì…ë ¥ì„ ë§ˆìš°ìŠ¤ ì…ë ¥ì²˜ëŸ¼ ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤. í„°ì¹˜ ìŠ¤í¬ë¦°ì´ ì—†ëŠ” í™˜ê²½ì—ì„œë„ ë§ˆìš°ìŠ¤ë¡œ ë™ì¼í•˜ê²Œ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    // í„°ì¹˜/í´ë¦­í•œ ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
    Array<Vec2> touchPoints;
    
    while (System::Update())
    {
        // í„°ì¹˜/í´ë¦­ ì‹œ ìœ„ì¹˜ ê¸°ë¡
        if (MouseL.down())
        {
            touchPoints.push_back(Cursor::PosF());
            
            // ìµœëŒ€ 100ê°œê¹Œì§€ë§Œ ì €ì¥
            if (touchPoints.size() > 100)
            {
                touchPoints.pop_front();
            }
        }
        
        // Space í‚¤ë¡œ ì´ˆê¸°í™”
        if (KeySpace.down())
        {
            touchPoints.clear();
        }
        
        // ëª¨ë“  í„°ì¹˜ í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
        for (const auto& point : touchPoints)
        {
            Circle{ point, 15 }.draw(ColorF{ 1.0, 0.5, 0.0, 0.5 });
        }
        
        font(U"í™”ë©´ì„ í„°ì¹˜/í´ë¦­í•˜ì„¸ìš”")
            .draw(20, 20, Palette::White);
        
        font(U"í¬ì¸íŠ¸ ìˆ˜: {}"_fmt(touchPoints.size()))
            .draw(20, 50, Palette::Yellow);
        
        font(U"Space: ì´ˆê¸°í™”")
            .draw(20, 80, Palette::Yellow);
    }
}
```

### 19.4.2 ë©€í‹°í„°ì¹˜ ì²˜ë¦¬
ë©€í‹°í„°ì¹˜ë¥¼ ì§€ì›í•˜ëŠ” ë””ë°”ì´ìŠ¤ì—ì„œëŠ” ì—¬ëŸ¬ ê°œì˜ í„°ì¹˜ í¬ì¸íŠ¸ë¥¼ ë™ì‹œì— ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // ëª¨ë“  í„°ì¹˜ í¬ì¸íŠ¸ ê°€ì ¸ì˜¤ê¸°
        const auto touches = System::GetTouches();
        
        // ê° í„°ì¹˜ í¬ì¸íŠ¸ ì²˜ë¦¬
        for (const auto& touch : touches)
        {
            // í„°ì¹˜ IDì— ë”°ë¼ ë‹¤ë¥¸ ìƒ‰ìƒ ì‚¬ìš©
            const ColorF color = HSV{ touch.id * 60.0, 0.8, 1.0 };
            
            Circle{ touch.pos, 40 }.draw(color.withAlpha(0.5));
            
            font(U"ID: {}"_fmt(touch.id))
                .drawAt(touch.pos, Palette::White);
        }
        
        // í„°ì¹˜ ê°œìˆ˜ í‘œì‹œ
        font(U"í„°ì¹˜ ê°œìˆ˜: {}"_fmt(touches.size()))
            .draw(20, 20, Palette::White);
        
        if (touches.isEmpty())
        {
            font(U"í™”ë©´ì„ ì—¬ëŸ¬ ì†ê°€ë½ìœ¼ë¡œ í„°ì¹˜í•´ë³´ì„¸ìš”")
                .draw(20, 60, Palette::Yellow);
        }
    }
}
```

`System::GetTouches()`ëŠ” í˜„ì¬ í™œì„±í™”ëœ ëª¨ë“  í„°ì¹˜ í¬ì¸íŠ¸ì˜ ë°°ì—´ì„ ë°˜í™˜í•œë‹¤. ê° í„°ì¹˜ í¬ì¸íŠ¸ëŠ” ê³ ìœ í•œ IDì™€ ìœ„ì¹˜ ì •ë³´ë¥¼ ê°€ì§„ë‹¤.

### 19.4.3 ì œìŠ¤ì²˜ ê°ì§€
ê°„ë‹¨í•œ ì œìŠ¤ì²˜ë¥¼ ê°ì§€í•˜ì—¬ ìŠ¤ì™€ì´í”„, í•€ì¹˜ ë“±ì˜ ë™ì‘ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font1{ FontMethod::MSDF, 40, Typeface::CJK_Regular_KR };
    Font font2{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    Vec2 previousPos{ 0, 0 };
    bool wasPressed = false;
    String gesture = U"ëŒ€ê¸° ì¤‘";
    
    while (System::Update())
    {
        const Vec2 currentPos = Cursor::PosF();
        
        if (MouseL.down())
        {
            previousPos = currentPos;
            wasPressed = true;
            gesture = U"í„°ì¹˜ ì‹œì‘";
        }
        
        if (MouseL.pressed() && wasPressed)
        {
            const Vec2 delta = currentPos - previousPos;
            const double distance = delta.length();
            
            // ì¼ì • ê±°ë¦¬ ì´ìƒ ì´ë™ ì‹œ ìŠ¤ì™€ì´í”„ë¡œ íŒì •
            if (distance > 10.0)
            {
                const double angle = Math::ToDegrees(std::atan2(delta.y, delta.x));
                
                // ê°ë„ì— ë”°ë¼ ë°©í–¥ íŒë‹¨
                if (angle >= -45 && angle < 45)
                    gesture = U"â†’ ì˜¤ë¥¸ìª½ ìŠ¤ì™€ì´í”„";
                else if (angle >= 45 && angle < 135)
                    gesture = U"â†“ ì•„ë˜ìª½ ìŠ¤ì™€ì´í”„";
                else if (angle >= -135 && angle < -45)
                    gesture = U"â†‘ ìœ„ìª½ ìŠ¤ì™€ì´í”„";
                else
                    gesture = U"â† ì™¼ìª½ ìŠ¤ì™€ì´í”„";
                
                previousPos = currentPos;
            }
        }
        
        if (MouseL.up())
        {
            wasPressed = false;
            gesture = U"í„°ì¹˜ ì¢…ë£Œ";
        }
        
        // ì œìŠ¤ì²˜ í‘œì‹œ
        font1(gesture)
            .drawAt(Scene::Center(), Palette::Yellow);
        
        font2(U"í™”ë©´ì„ ë“œë˜ê·¸í•˜ì—¬ ìŠ¤ì™€ì´í”„ ë°©í–¥ì„ í™•ì¸í•˜ì„¸ìš”")
            .draw(20, 20, Palette::White);
    }
}
```

ì´ ì˜ˆì œëŠ” í„°ì¹˜ ì‹œì‘ì ê³¼ í˜„ì¬ ìœ„ì¹˜ì˜ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ì—¬ ìŠ¤ì™€ì´í”„ ë°©í–¥ì„ ê°ì§€í•œë‹¤. `std::atan2()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë²¡í„°ì˜ ê°ë„ë¥¼ êµ¬í•˜ê³ , ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë„¤ ë°©í–¥ ì¤‘ í•˜ë‚˜ë¡œ íŒì •í•œë‹¤.
  
  
</br>  
  
  
## 19.5 ì…ë ¥ ìƒíƒœ ê´€ë¦¬ì™€ ì´ë²¤íŠ¸ ì²˜ë¦¬

### 19.5.1 ì…ë ¥ ìƒíƒœ í´ë˜ìŠ¤ ì„¤ê³„
ë³µì¡í•œ ê²Œì„ì´ë‚˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œëŠ” ì…ë ¥ ìƒíƒœë¥¼ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•´ì•¼ í•œë‹¤. `enum class`ì™€ `std::optional`ì„ í™œìš©í•˜ì—¬ ì•ˆì „í•œ ì…ë ¥ ìƒíƒœ ê´€ë¦¬ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ë³´ì.

```cpp
# include <Siv3D.hpp>

// ì…ë ¥ ì•¡ì…˜ ì •ì˜
enum class InputAction
{
    MoveLeft,
    MoveRight,
    MoveUp,
    MoveDown,
    Jump,
    Attack,
    Menu
};

// ì…ë ¥ ë§¤ë‹ˆì € í´ë˜ìŠ¤
class InputManager
{
public:
    // í‚¤ ë°”ì¸ë”© ì„¤ì •
    void setKeyBinding(InputAction action, const Input& key)
    {
        keyBindings[action] = key;
    }
    
    // ì•¡ì…˜ì´ ë§‰ ì‹œì‘ë˜ì—ˆëŠ”ì§€ í™•ì¸
    bool isActionTriggered(InputAction action) const
    {
        auto it = keyBindings.find(action);
        if (it == keyBindings.end())
            return false;
        
        return it->second.down();
    }
    
    // ì•¡ì…˜ì´ ì§€ì†ë˜ê³  ìˆëŠ”ì§€ í™•ì¸
    bool isActionActive(InputAction action) const
    {
        auto it = keyBindings.find(action);
        if (it == keyBindings.end())
            return false;
        
        return it->second.pressed();
    }
    
    // ì•¡ì…˜ì´ ë§‰ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
    bool isActionReleased(InputAction action) const
    {
        auto it = keyBindings.find(action);
        if (it == keyBindings.end())
            return false;
        
        return it->second.up();
    }
    
private:
    std::map<InputAction, Input> keyBindings;
};

void Main()
{
    Font font{ FontMethod::MSDF, 20 Typeface::CJK_Regular_KR };

    InputManager inputMgr;
    
    // í‚¤ ë°”ì¸ë”© ì„¤ì •
    inputMgr.setKeyBinding(InputAction::MoveLeft, KeyLeft);
    inputMgr.setKeyBinding(InputAction::MoveRight, KeyRight);
    inputMgr.setKeyBinding(InputAction::MoveUp, KeyUp);
    inputMgr.setKeyBinding(InputAction::MoveDown, KeyDown);
    inputMgr.setKeyBinding(InputAction::Jump, KeySpace);
    inputMgr.setKeyBinding(InputAction::Attack, KeyZ);
    inputMgr.setKeyBinding(InputAction::Menu, KeyEscape);
    
    Vec2 playerPos = Scene::Center();
    const double moveSpeed = 200.0;
    
    while (System::Update())
    {
        const double deltaTime = Scene::DeltaTime();
        
        // ì…ë ¥ ì²˜ë¦¬
        if (inputMgr.isActionActive(InputAction::MoveLeft))
        {
            playerPos.x -= moveSpeed * deltaTime;
        }
        if (inputMgr.isActionActive(InputAction::MoveRight))
        {
            playerPos.x += moveSpeed * deltaTime;
        }
        if (inputMgr.isActionActive(InputAction::MoveUp))
        {
            playerPos.y -= moveSpeed * deltaTime;
        }
        if (inputMgr.isActionActive(InputAction::MoveDown))
        {
            playerPos.y += moveSpeed * deltaTime;
        }
        
        if (inputMgr.isActionTriggered(InputAction::Jump))
        {
            Print << U"ì í”„!";
        }
        
        if (inputMgr.isActionTriggered(InputAction::Attack))
        {
            Print << U"ê³µê²©!";
        }
        
        if (inputMgr.isActionTriggered(InputAction::Menu))
        {
            Print << U"ë©”ë‰´ ì—´ê¸°";
        }
        
        // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        Circle{ playerPos, 25 }.draw(Palette::Green);
        
        // ì¡°ì‘ ì•ˆë‚´
        font(U"ë°©í–¥í‚¤: ì´ë™")
            .draw(20, 20, Palette::White);
        font(U"Space: ì í”„, Z: ê³µê²©, Esc: ë©”ë‰´")
            .draw(20, 50, Palette::White);
    }
}
```

ì´ ì„¤ê³„ì˜ ì¥ì ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

1. **ì¶”ìƒí™”**: ê²Œì„ ë¡œì§ì€ êµ¬ì²´ì ì¸ í‚¤ê°€ ì•„ë‹Œ ì¶”ìƒì ì¸ ì•¡ì…˜ìœ¼ë¡œ ì‘ì„±ëœë‹¤.
2. **ìœ ì—°ì„±**: í‚¤ ë°”ì¸ë”©ì„ ëŸ°íƒ€ì„ì— ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
3. **íƒ€ì… ì•ˆì „ì„±**: `enum class`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ëª»ëœ ì•¡ì…˜ ì´ë¦„ì„ ë°©ì§€í•œë‹¤.
4. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ì•¡ì…˜ì„ ì‰½ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

### 19.5.2 ì…ë ¥ ë²„í¼ë§ê³¼ ì»¤ë§¨ë“œ íŒ¨í„´
ê²©íˆ¬ ê²Œì„ì´ë‚˜ ë³µì¡í•œ ì¡°ì‘ì´ í•„ìš”í•œ ê²Œì„ì—ì„œëŠ” ì—°ì†ëœ ì…ë ¥ì„ ë²„í¼ë§í•˜ì—¬ ì½¤ë³´ë‚˜ íŠ¹ìˆ˜ ê¸°ìˆ ì„ êµ¬í˜„í•œë‹¤.

```cpp
# include <Siv3D.hpp>

// ì…ë ¥ ì´ë²¤íŠ¸ êµ¬ì¡°ì²´
struct InputEvent
{
    char32 key;
    double timestamp;
};

// ì»¤ë§¨ë“œ íŒ¨í„´ì„ ìœ„í•œ ì¶”ìƒ í´ë˜ìŠ¤
class Command
{
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual String getName() const = 0;
};

// êµ¬ì²´ì ì¸ ì»¤ë§¨ë“œë“¤
class FireballCommand : public Command
{
public:
    void execute() override
    {
        Print << U"ğŸ”¥ íŒŒì´ì–´ë³¼ ë°œì‚¬!";
    }
    
    String getName() const override
    {
        return U"íŒŒì´ì–´ë³¼";
    }
};

class UppercutCommand : public Command
{
public:
    void execute() override
    {
        Print << U"ğŸ‘Š ì–´í¼ì»·!";
    }
    
    String getName() const override
    {
        return U"ì–´í¼ì»·";
    }
};

// ì…ë ¥ ë²„í¼ í´ë˜ìŠ¤
class InputBuffer
{
public:
    InputBuffer(double timeWindow = 1.0)
        : m_timeWindow(timeWindow) {}
    
    void addInput(char32 key)
    {
        const double currentTime = Scene::Time();
        
        // ì˜¤ë˜ëœ ì…ë ¥ ì œê±°
        m_buffer.remove_if([&](const InputEvent& evt) {
            return (currentTime - evt.timestamp) > m_timeWindow;
        });
        
        // ìƒˆ ì…ë ¥ ì¶”ê°€
        m_buffer.push_back(InputEvent{ key, currentTime });
    }
    
    std::optional<std::unique_ptr<Command>> checkCommands() const
    {
        // ìµœê·¼ ì…ë ¥ì„ ë¬¸ìì—´ë¡œ ë³€í™˜
        String inputSequence;
        for (const auto& evt : m_buffer)
        {
            inputSequence += evt.key;
        }
        
        // íŒŒì´ì–´ë³¼: â†“â†˜â†’ + A (DSA)
        if (inputSequence.ends_with(U"DSA"))
        {
            return std::make_unique<FireballCommand>();
        }
        
        // ì–´í¼ì»·: â†’â†“â†˜ + A (SDSA)
        if (inputSequence.ends_with(U"SDSA"))
        {
            return std::make_unique<UppercutCommand>();
        }
        
        return std::nullopt;
    }
    
    void clear()
    {
        m_buffer.clear();
    }
    
    String getSequence() const
    {
        String result;
        for (const auto& evt : m_buffer)
        {
            result += evt.key;
        }
        return result;
    }
    
private:
    Array<InputEvent> m_buffer;
    double m_timeWindow;
};

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    InputBuffer inputBuffer{ 1.0 }; // 1ì´ˆ ìœˆë„ìš°
    
    while (System::Update())
    {
        // ë°©í–¥í‚¤ ì…ë ¥
        if (KeyDown.down())
        {
            inputBuffer.addInput(U'D');
        }
        if (KeyRight.down())
        {
            inputBuffer.addInput(U'S');
        }
        if (KeyA.down())
        {
            inputBuffer.addInput(U'A');
        }
        
        // Spaceë¡œ ë²„í¼ ì´ˆê¸°í™”
        if (KeySpace.down())
        {
            inputBuffer.clear();
        }
        
        // ì»¤ë§¨ë“œ ì²´í¬
        if (auto command = inputBuffer.checkCommands())
        {
            (*command)->execute();
            inputBuffer.clear();
        }
        
        // UI
        font(U"ì…ë ¥ ì‹œí€€ìŠ¤: {}"_fmt(inputBuffer.getSequence()))
            .draw(20, 20, Palette::White);
        
        font(U"â†“ = Dí‚¤, â†’ = Sí‚¤, ê³µê²© = Aí‚¤")
            .draw(20, 60, Palette::Yellow);
        
        font(U"íŒŒì´ì–´ë³¼: D â†’ S â†’ A")
            .draw(20, 90, Palette::Skyblue);
        
        font(U"ì–´í¼ì»·: S â†’ D â†’ S â†’ A")
            .draw(20, 120, Palette::Skyblue);
        
        font(U"Space: ì…ë ¥ ì´ˆê¸°í™”")
            .draw(20, 150, Palette::Orange);
    }
}
```

ì´ êµ¬ì¡°ëŠ” ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì§•ì„ ê°€ì§„ë‹¤:

1. **ì‹œê°„ ê¸°ë°˜ ë²„í¼ë§**: ì¼ì • ì‹œê°„ ë‚´ì˜ ì…ë ¥ë§Œ ìœ íš¨í•˜ê²Œ ì²˜ë¦¬í•œë‹¤.
2. **ì»¤ë§¨ë“œ íŒ¨í„´**: ê° íŠ¹ìˆ˜ ê¸°ìˆ ì„ ë…ë¦½ì ì¸ ì»¤ë§¨ë“œ ê°ì²´ë¡œ ìº¡ìŠí™”í•œë‹¤.
3. **í™•ì¥ ê°€ëŠ¥ì„±**: ìƒˆë¡œìš´ ì»¤ë§¨ë“œë¥¼ ì‰½ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
4. **ìœ ì—°í•œ ë§¤ì¹­**: ë¬¸ìì—´ íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ë³µì¡í•œ ì…ë ¥ ì¡°í•©ì„ ì¸ì‹í•œë‹¤.

### 19.5.3 ì…ë ¥ ìš°ì„ ìˆœìœ„ì™€ ì»¨í…ìŠ¤íŠ¸
ê²Œì„ì˜ ìƒíƒœì— ë”°ë¼ ê°™ì€ ì…ë ¥ì´ ë‹¤ë¥´ê²Œ ì²˜ë¦¬ë˜ì–´ì•¼ í•  ë•Œê°€ ìˆë‹¤. ì´ë¥¼ ìœ„í•´ ì…ë ¥ ì»¨í…ìŠ¤íŠ¸ ì‹œìŠ¤í…œì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```cpp
# include <Siv3D.hpp>

// ê²Œì„ ìƒíƒœ
enum class GameState
{
    Playing,
    Paused,
    Menu
};

// ì…ë ¥ ì»¨í…ìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
class InputContext
{
public:
    virtual ~InputContext() = default;
    virtual void handleInput() = 0;
    virtual String getName() const = 0;
};

// í”Œë ˆì´ ì¤‘ ì…ë ¥ ì²˜ë¦¬
class PlayingContext : public InputContext
{
public:
    void handleInput() override
    {
        if (KeySpace.down())
        {
            Print << U"ê²Œì„ ì¤‘: ì í”„!";
        }
        
        if (KeyZ.down())
        {
            Print << U"ê²Œì„ ì¤‘: ê³µê²©!";
        }
    }
    
    String getName() const override
    {
        return U"í”Œë ˆì´ ì¤‘";
    }
};

// ì¼ì‹œì •ì§€ ì¤‘ ì…ë ¥ ì²˜ë¦¬
class PausedContext : public InputContext
{
public:
    void handleInput() override
    {
        if (KeySpace.down())
        {
            Print << U"ì¼ì‹œì •ì§€: ë©”ë‰´ ì„ íƒ";
        }
        
        if (KeyZ.down())
        {
            Print << U"ì¼ì‹œì •ì§€: ì·¨ì†Œ";
        }
    }
    
    String getName() const override
    {
        return U"ì¼ì‹œì •ì§€";
    }
};

// ë©”ë‰´ ì…ë ¥ ì²˜ë¦¬
class MenuContext : public InputContext
{
public:
    void handleInput() override
    {
        if (KeyUp.down())
        {
            Print << U"ë©”ë‰´: ìœ„ë¡œ ì´ë™";
        }
        
        if (KeyDown.down())
        {
            Print << U"ë©”ë‰´: ì•„ë˜ë¡œ ì´ë™";
        }
        
        if (KeySpace.down())
        {
            Print << U"ë©”ë‰´: ì„ íƒ";
        }
    }
    
    String getName() const override
    {
        return U"ë©”ë‰´";
    }
};

void Main()
{
    Font font1{ FontMethod::MSDF, 30, Typeface::CJK_Regular_KR };
    Font font2{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    GameState currentState = GameState::Playing;
    
    // ê° ìƒíƒœë³„ ì…ë ¥ ì»¨í…ìŠ¤íŠ¸
    std::map<GameState, std::unique_ptr<InputContext>> contexts;
    contexts[GameState::Playing] = std::make_unique<PlayingContext>();
    contexts[GameState::Paused] = std::make_unique<PausedContext>();
    contexts[GameState::Menu] = std::make_unique<MenuContext>();
    
    while (System::Update())
    {
        // ìƒíƒœ ì „í™˜ (ìˆ«ì í‚¤ë¡œ í…ŒìŠ¤íŠ¸)
        if (Key1.down())
        {
            currentState = GameState::Playing;
        }
        if (Key2.down())
        {
            currentState = GameState::Paused;
        }
        if (Key3.down())
        {
            currentState = GameState::Menu;
        }
        
        // í˜„ì¬ ìƒíƒœì˜ ì…ë ¥ ì²˜ë¦¬
        contexts[currentState]->handleInput();
        
        // UI
        font1(U"í˜„ì¬ ìƒíƒœ: {}"_fmt(contexts[currentState]->getName()))
            .draw(20, 20, Palette::Yellow);
        
        font2(U"1: í”Œë ˆì´ ì¤‘, 2: ì¼ì‹œì •ì§€, 3: ë©”ë‰´")
            .draw(20, 70, Palette::White);
        
        font2(U"Space, Z, ë°©í–¥í‚¤ë¥¼ ëˆŒëŸ¬ë³´ì„¸ìš”")
            .draw(20, 100, Palette::White);
        
        // ìƒíƒœë³„ ì•ˆë‚´
        if (currentState == GameState::Playing)
        {
            font2(U"Space: ì í”„, Z: ê³µê²©")
                .draw(20, 140, Palette::Skyblue);
        }
        else if (currentState == GameState::Paused)
        {
            font2(U"Space: ì„ íƒ, Z: ì·¨ì†Œ")
                .draw(20, 140, Palette::Skyblue);
        }
        else if (currentState == GameState::Menu)
        {
            font2(U"â†‘â†“: ë©”ë‰´ ì´ë™, Space: ì„ íƒ")
                .draw(20, 140, Palette::Skyblue);
        }
    }
}
```

ì´ íŒ¨í„´ì˜ ì¥ì ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

1. **ëª…í™•í•œ ë¶„ë¦¬**: ê° ê²Œì„ ìƒíƒœì˜ ì…ë ¥ ì²˜ë¦¬ ë¡œì§ì´ ë…ë¦½ì ì´ë‹¤.
2. **ìœ ì§€ë³´ìˆ˜ì„±**: íŠ¹ì • ìƒíƒœì˜ ì…ë ¥ ë¡œì§ì„ ìˆ˜ì •í•  ë•Œ ë‹¤ë¥¸ ìƒíƒœì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ”ë‹¤.
3. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ê²Œì„ ìƒíƒœì™€ ì…ë ¥ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì‰½ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
  

</br>  
  

## 19.6 ì‹¤ìŠµ ë¬¸ì œ

### ë¬¸ì œ 1: ë“œë¡œì‰ ì• í”Œë¦¬ì¼€ì´ì…˜
ë§ˆìš°ìŠ¤ë¡œ ììœ ë¡­ê²Œ ê·¸ë¦¼ì„ ê·¸ë¦´ ìˆ˜ ìˆëŠ” ê°„ë‹¨í•œ ë“œë¡œì‰ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“¤ì–´ë³´ì.

**ìš”êµ¬ì‚¬í•­:**
1. ë§ˆìš°ìŠ¤ ì™¼ìª½ ë²„íŠ¼ì„ ëˆ„ë¥´ê³  ë“œë˜ê·¸í•˜ë©´ ì„ ì´ ê·¸ë ¤ì§„ë‹¤
2. ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½ ë²„íŠ¼ì„ ëˆ„ë¥´ê³  ë“œë˜ê·¸í•˜ë©´ ì§€ìš°ê°œ ì—­í• ì„ í•œë‹¤
3. ìˆ«ì í‚¤ 1-5ë¡œ ë¸ŒëŸ¬ì‹œ í¬ê¸°ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆë‹¤
4. R, G, B í‚¤ë¡œ ìƒ‰ìƒì„ ë³€ê²½í•  ìˆ˜ ìˆë‹¤
5. Space í‚¤ë¡œ ìº”ë²„ìŠ¤ë¥¼ ëª¨ë‘ ì§€ìš´ë‹¤

**íŒíŠ¸:**
```cpp
// ë“œë¡œì‰ í¬ì¸íŠ¸ë¥¼ ì €ì¥í•  êµ¬ì¡°ì²´
struct DrawPoint
{
    Vec2 pos;
    ColorF color;
    double size;
    bool isEraser;
};
```

### ë¬¸ì œ 2: ë°˜ì‘ ì†ë„ í…ŒìŠ¤íŠ¸ ê²Œì„
ì‚¬ìš©ìì˜ ë°˜ì‘ ì†ë„ë¥¼ ì¸¡ì •í•˜ëŠ” ê²Œì„ì„ ë§Œë“¤ì–´ë³´ì.

**ìš”êµ¬ì‚¬í•­:**
1. Space í‚¤ë¥¼ ëˆ„ë¥´ë©´ ê²Œì„ì´ ì‹œì‘ëœë‹¤
2. ëœë¤í•œ ì‹œê°„(1-3ì´ˆ) í›„ í™”ë©´ì´ íŠ¹ì • ìƒ‰ìœ¼ë¡œ ë³€í•œë‹¤
3. ìƒ‰ì´ ë³€í•˜ëŠ” ìˆœê°„ë¶€í„° ì‚¬ìš©ìê°€ Spaceë¥¼ ëˆ„ë¥¼ ë•Œê¹Œì§€ì˜ ì‹œê°„ì„ ì¸¡ì •í•œë‹¤
4. 5íšŒ ì¸¡ì • í›„ í‰ê·  ë°˜ì‘ ì†ë„ë¥¼ í‘œì‹œí•œë‹¤
5. ë„ˆë¬´ ë¹¨ë¦¬ ëˆ„ë¥´ë©´ "ë¶€ì •í–‰ìœ„!" ë©”ì‹œì§€ë¥¼ í‘œì‹œí•œë‹¤

**íŒíŠ¸:**
```cpp
// std::chronoë¥¼ í™œìš©í•œ ì‹œê°„ ì¸¡ì •
#include <chrono>

auto startTime = std::chrono::high_resolution_clock::now();
auto endTime = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
    endTime - startTime
).count();
```

### ë¬¸ì œ 3: ê°„ë‹¨í•œ í”¼ì•„ë…¸ ì• í”Œë¦¬ì¼€ì´ì…˜
í‚¤ë³´ë“œë¡œ ì—°ì£¼í•  ìˆ˜ ìˆëŠ” ê°„ë‹¨í•œ í”¼ì•„ë…¸ë¥¼ ë§Œë“¤ì–´ë³´ì.

**ìš”êµ¬ì‚¬í•­:**
1. A-K í‚¤ë¥¼ ë„ë ˆë¯¸íŒŒì†”ë¼ì‹œë„ ìŒê³„ë¡œ ë§¤í•‘í•œë‹¤
2. í‚¤ë¥¼ ëˆ„ë¥´ë©´ í•´ë‹¹í•˜ëŠ” ìŒì´ ì¬ìƒëœë‹¤ (Siv3Dì˜ Waveì™€ Audio ì‚¬ìš©)
3. ëˆŒë ¤ì§„ ê±´ë°˜ì´ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œëœë‹¤
4. ì—¬ëŸ¬ í‚¤ë¥¼ ë™ì‹œì— ëˆ„ë¥¼ ìˆ˜ ìˆë‹¤ (í™”ìŒ)
5. ìˆ«ì í‚¤ë¡œ ì˜¥íƒ€ë¸Œë¥¼ ë³€ê²½í•  ìˆ˜ ìˆë‹¤

**íŒíŠ¸:**
```cpp
// ê°„ë‹¨í•œ ì‚¬ì¸íŒŒ ìƒì„±
Wave wave = Wave::Generate(1s, [&](double t) {
    return 0.5 * std::sin(2_pi * 440.0 * t); // 440Hz = A4(ë¼)
});

Audio audio(wave);
audio.play();
```
  

</br>  
  

## 19.7 ì‹¬í™” ë‚´ìš©

### 19.7.1 ê²Œì„íŒ¨ë“œ ì…ë ¥ ì²˜ë¦¬
Siv3DëŠ” Xbox ì»¨íŠ¸ë¡¤ëŸ¬ ë“±ì˜ ê²Œì„íŒ¨ë“œ ì…ë ¥ë„ ì§€ì›í•œë‹¤.

```cpp
# include <Siv3D.hpp>

void Main()
{
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // ì—°ê²°ëœ ê²Œì„íŒ¨ë“œ í™•ì¸
        for (auto i : step(Gamepad.MaxPlayerCount))
        {
            if (const auto gamepad = Gamepad(i))
            {
                // ë²„íŠ¼ ì…ë ¥
                if (gamepad.buttons[0].down()) // A ë²„íŠ¼
                {
                    Print << U"í”Œë ˆì´ì–´ {} A ë²„íŠ¼ ëˆ„ë¦„"_fmt(i);
                }
                
                // ì•„ë‚ ë¡œê·¸ ìŠ¤í‹±
                const Vec2 leftStick = gamepad.axes[0]; // ì™¼ìª½ ìŠ¤í‹±
                
                if (leftStick.length() > 0.1) // ë°ë“œì¡´ ì²˜ë¦¬
                {
                    Circle{ Scene::Center() + leftStick * 100, 20 }
                        .draw(Palette::Green);
                }
                
                // íŠ¸ë¦¬ê±°
                const double leftTrigger = gamepad.axes[4];
                
                font(U"ì™¼ìª½ íŠ¸ë¦¬ê±°: {:.2f}"_fmt(leftTrigger))
                    .draw(20, 20 + i * 30, Palette::White);
            }
        }
    }
}
```

### 19.7.2 ì…ë ¥ ë¦¬í”Œë ˆì´ ì‹œìŠ¤í…œ
ê²Œì„ì˜ ë¦¬í”Œë ˆì´ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê¸° ìœ„í•œ ì…ë ¥ ê¸°ë¡ ì‹œìŠ¤í…œì„ ë§Œë“¤ì–´ë³´ì.

```cpp
# include <Siv3D.hpp>

// í”„ë ˆì„ë³„ ì…ë ¥ ê¸°ë¡
struct FrameInput
{
    int32 frame;
    Array<Input> pressedKeys;
    Vec2 mousePos;
};

class InputRecorder
{
public:
    void startRecording()
    {
        m_recording = true;
        m_playback = false;
        m_recordedInputs.clear();
        m_currentFrame = 0;
    }
    
    void stopRecording()
    {
        m_recording = false;
    }
    
    void record()
    {
        if (!m_recording)
            return;
        
        FrameInput frameInput;
        frameInput.frame = m_currentFrame;
        frameInput.mousePos = Cursor::PosF();
        
        // ëˆŒë ¤ì§„ ëª¨ë“  í‚¤ ê¸°ë¡
        for (int32 i = 0; i < 256; ++i)
        {
            Input key{ InputDeviceType::Keyboard, static_cast<uint8>(i) };
            if (key.pressed())
            {
                frameInput.pressedKeys.push_back(key);
            }
        }
        
        m_recordedInputs.push_back(frameInput);
        ++m_currentFrame;
    }
    
    void startPlayback()
    {
        m_playback = true;
        m_recording = false;
        m_playbackIndex = 0;
        m_currentFrame = 0;
    }
    
    std::optional<FrameInput> getPlaybackInput()
    {
        if (!m_playback || m_playbackIndex >= m_recordedInputs.size())
            return std::nullopt;
        
        if (m_recordedInputs[m_playbackIndex].frame == m_currentFrame)
        {
            return m_recordedInputs[m_playbackIndex++];
        }
        
        ++m_currentFrame;
        return std::nullopt;
    }
    
    bool isPlaybackFinished() const
    {
        return m_playback && m_playbackIndex >= m_recordedInputs.size();
    }
    
    void saveToFile(const FilePath& path) const
    {
        // JSONìœ¼ë¡œ ì €ì¥ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì§ë ¬í™” í•„ìš”)
        JSONWriter json{ path };
        
        json.startArray();
        for (const auto& input : m_recordedInputs)
        {
            json.startObject();
            json.key(U"frame").write(input.frame);
            json.key(U"mouseX").write(input.mousePos.x);
            json.key(U"mouseY").write(input.mousePos.y);
            // í‚¤ ì •ë³´ë„ ì €ì¥...
            json.endObject();
        }
        json.endArray();
    }
    
private:
    bool m_recording = false;
    bool m_playback = false;
    Array<FrameInput> m_recordedInputs;
    size_t m_playbackIndex = 0;
    int32 m_currentFrame = 0;
};
```

### 19.7.3 ì ‘ê·¼ì„±ì„ ê³ ë ¤í•œ ì…ë ¥ ì²˜ë¦¬
ì¥ì• ê°€ ìˆëŠ” ì‚¬ìš©ìë„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë‹¤ì–‘í•œ ì…ë ¥ ë°©ì‹ì„ ì§€ì›í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.

```cpp
# include <Siv3D.hpp>

class AccessibleInputManager
{
public:
    // í‚¤ ë¦¬í”¼íŠ¸ ì„¤ì • (í‚¤ë¥¼ ëˆ„ë¥´ê³  ìˆì„ ë•Œ ë°˜ë³µ ì…ë ¥)
    void setKeyRepeat(double initialDelay, double repeatInterval)
    {
        m_initialDelay = initialDelay;
        m_repeatInterval = repeatInterval;
    }
    
    bool checkKeyWithRepeat(const Input& key)
    {
        if (key.down())
        {
            m_lastKeyTime = Scene::Time();
            m_repeatStarted = false;
            return true;
        }
        
        if (key.pressed())
        {
            const double elapsed = Scene::Time() - m_lastKeyTime;
            
            if (!m_repeatStarted && elapsed > m_initialDelay)
            {
                m_repeatStarted = true;
                m_lastKeyTime = Scene::Time();
                return true;
            }
            
            if (m_repeatStarted && elapsed > m_repeatInterval)
            {
                m_lastKeyTime = Scene::Time();
                return true;
            }
        }
        
        return false;
    }
    
    // í´ë¦­ í™€ë“œ ì‹œê°„ (ì‹¤ìˆ˜ë¡œ í´ë¦­í•˜ëŠ” ê²ƒ ë°©ì§€)
    bool checkClickWithDelay(const Input& input, double holdTime = 0.3)
    {
        if (input.down())
        {
            m_clickStartTime = Scene::Time();
            return false;
        }
        
        if (input.up())
        {
            const double held = Scene::Time() - m_clickStartTime;
            return held >= holdTime;
        }
        
        return false;
    }
    
private:
    double m_initialDelay = 0.5;
    double m_repeatInterval = 0.1;
    double m_lastKeyTime = 0.0;
    bool m_repeatStarted = false;
    double m_clickStartTime = 0.0;
};
```
   

</br>


## 19.8 ì •ë¦¬
ì´ë²ˆ ì¥ì—ì„œëŠ” Siv3Dì—ì„œ ë‹¤ì–‘í•œ ì…ë ¥ì„ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë°°ì› ë‹¤. ë§ˆìš°ìŠ¤, í‚¤ë³´ë“œ, í„°ì¹˜ ì…ë ¥ì˜ ê¸°ë³¸ë¶€í„° ë³µì¡í•œ ì…ë ¥ ìƒíƒœ ê´€ë¦¬, ì»¤ë§¨ë“œ íŒ¨í„´, ì…ë ¥ ì»¨í…ìŠ¤íŠ¸ê¹Œì§€ ë‹¤ë£¨ì—ˆë‹¤.

**í•µì‹¬ ìš”ì :**

1. Siv3Dì˜ ì…ë ¥ APIëŠ” ì§ê´€ì ì´ê³  ì‚¬ìš©í•˜ê¸° ì‰½ë‹¤. `down()`, `pressed()`, `up()` ì„¸ ê°€ì§€ ìƒíƒœë¡œ ëŒ€ë¶€ë¶„ì˜ ì…ë ¥ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

2. ë„í˜• ê°ì²´ëŠ” ìì²´ì ìœ¼ë¡œ ë§ˆìš°ìŠ¤ ì¶©ëŒì„ ê°ì§€í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì œê³µí•˜ì—¬, ë²„íŠ¼ì´ë‚˜ UI ìš”ì†Œë¥¼ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

3. `enum class`ì™€ ë§¤í•‘ì„ í™œìš©í•˜ë©´ ì…ë ¥ì„ ì¶”ìƒí™”í•˜ì—¬ ìœ ì§€ë³´ìˆ˜ì„±ê³¼ í™•ì¥ì„±ì„ ë†’ì¼ ìˆ˜ ìˆë‹¤.

4. ì…ë ¥ ë²„í¼ë§ê³¼ ì»¤ë§¨ë“œ íŒ¨í„´ì„ ì¡°í•©í•˜ë©´ ë³µì¡í•œ ì…ë ¥ ì¡°í•©ì„ ì²´ê³„ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

5. ê²Œì„ ìƒíƒœì— ë”°ë¼ ì…ë ¥ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì „í™˜í•˜ë©´, ê°™ì€ í‚¤ê°€ ìƒí™©ì— ë§ê²Œ ë‹¤ë¥´ê²Œ ë™ì‘í•˜ë„ë¡ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

Modern C++ì˜ íƒ€ì… ì‹œìŠ¤í…œ, `std::optional`, `std::unique_ptr` ë“±ì„ í™œìš©í•˜ë©´ ì•ˆì „í•˜ê³  ëª…í™•í•œ ì…ë ¥ ì²˜ë¦¬ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆë‹¤. ë‹¤ìŒ ì¥ì—ì„œëŠ” ê·¸ë˜í”½ê³¼ í…ìŠ¤íŠ¸ë¥¼ ë‹¤ë£¨ì–´ ë”ìš± í’ë¶€í•œ ì‹œê°ì  í‘œí˜„ì„ ë§Œë“¤ì–´ë³¸ë‹¤.   