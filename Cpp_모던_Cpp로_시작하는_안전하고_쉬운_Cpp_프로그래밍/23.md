# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 23: 파일 시스템과 데이터 관리

게임이나 애플리케이션은 사용자의 설정, 게임 진행 상황, 최고 점수 등 다양한 데이터를 저장하고 불러와야 한다. 프로그램을 종료한 후에도 데이터가 유지되려면 파일 시스템을 활용해야 한다. C++17부터 표준 라이브러리에 포함된 `std::filesystem`은 파일과 디렉토리를 안전하고 편리하게 다룰 수 있는 강력한 도구다. 이번 장에서는 Modern C++의 파일 시스템 기능을 배우고, 실제 게임 데이터를 저장하고 불러오는 방법을 익힌다.

## 23.1 std::filesystem으로 파일 처리

C++17 이전에는 파일 시스템 작업이 플랫폼마다 다른 API를 사용해야 했고, 코드가 복잡했다. `std::filesystem`은 이를 표준화하여 Windows, Linux, macOS에서 동일한 코드로 파일을 다룰 수 있게 해준다.

### 23.1.1 파일 시스템 기초

`std::filesystem` 네임스페이스는 파일과 디렉토리를 다루는 다양한 함수와 클래스를 제공한다. 가장 기본이 되는 `path` 클래스부터 시작한다.

```cpp
#include <iostream>
#include <filesystem>
#include <string>

namespace fs = std::filesystem;

void Main()
{
    // 경로 생성
    fs::path appPath = fs::current_path();
    fs::path savePath = appPath / "SaveData";
    fs::path configFile = savePath / "config.txt";

    // 경로 정보 출력
    std::cout << "현재 작업 디렉토리: " << appPath << "\n";
    std::cout << "저장 디렉토리: " << savePath << "\n";
    std::cout << "설정 파일: " << configFile << "\n\n";

    // 경로 분해
    std::cout << "파일명: " << configFile.filename() << "\n";
    std::cout << "확장자: " << configFile.extension() << "\n";
    std::cout << "부모 디렉토리: " << configFile.parent_path() << "\n";
    std::cout << "파일명(확장자 제외): " << configFile.stem() << "\n\n";

    // 경로 존재 여부 확인
    if (fs::exists(savePath))
    {
        std::cout << "저장 디렉토리가 존재한다.\n";
    }
    else
    {
        std::cout << "저장 디렉토리가 존재하지 않는다.\n";
    }

    // 파일인지 디렉토리인지 확인
    if (fs::exists(appPath))
    {
        if (fs::is_directory(appPath))
        {
            std::cout << "현재 경로는 디렉토리다.\n";
        }
        else if (fs::is_regular_file(appPath))
        {
            std::cout << "현재 경로는 파일이다.\n";
        }
    }
}
```

`fs::path` 클래스는 파일 경로를 나타낸다. `/` 연산자를 오버로딩하여 경로를 자연스럽게 결합할 수 있다. `current_path()`는 현재 작업 디렉토리를 반환하며, 이는 실행 파일이 있는 위치가 아닐 수 있다는 점에 주의한다.

`exists()` 함수는 경로가 존재하는지 확인하고, `is_directory()`와 `is_regular_file()`로 디렉토리인지 파일인지 구분할 수 있다. 경로 객체에서 `filename()`, `extension()`, `parent_path()`, `stem()` 등의 메서드로 경로의 각 부분을 추출할 수 있다.

### 23.1.2 디렉토리 생성과 삭제

게임 데이터를 저장하려면 먼저 저장용 디렉토리를 만들어야 한다. `std::filesystem`은 디렉토리 생성과 삭제를 쉽게 할 수 있는 함수를 제공한다.

```cpp
#include <iostream>
#include <filesystem>

namespace fs = std::filesystem;

void Main()
{
    // 저장 디렉토리 경로
    fs::path saveDir = "GameData";
    fs::path saveSubDir = saveDir / "Saves";

    try
    {
        // 디렉토리 생성
        if (not fs::exists(saveDir))
        {
            if (fs::create_directory(saveDir))
            {
                std::cout << "디렉토리 생성 성공: " << saveDir << "\n";
            }
        }
        else
        {
            std::cout << "디렉토리가 이미 존재한다: " << saveDir << "\n";
        }

        // 중간 디렉토리까지 자동으로 생성
        if (not fs::exists(saveSubDir))
        {
            if (fs::create_directories(saveSubDir))
            {
                std::cout << "하위 디렉토리 생성 성공: " << saveSubDir << "\n";
            }
        }

        // 디렉토리 내용 나열
        std::cout << "\n디렉토리 내용:\n";
        for (const auto& entry : fs::directory_iterator(saveDir))
        {
            std::cout << "  ";
            if (entry.is_directory())
            {
                std::cout << "[DIR]  ";
            }
            else
            {
                std::cout << "[FILE] ";
            }
            std::cout << entry.path().filename() << "\n";
        }

        // 빈 디렉토리 삭제
        if (fs::is_empty(saveSubDir))
        {
            fs::remove(saveSubDir);
            std::cout << "\n빈 디렉토리 삭제: " << saveSubDir << "\n";
        }

        // 디렉토리와 모든 내용 삭제 (주의!)
        // fs::remove_all(saveDir);
    }
    catch (const fs::filesystem_error& e)
    {
        std::cerr << "파일 시스템 오류: " << e.what() << "\n";
    }
}
```

`create_directory()`는 단일 디렉토리를 생성하고, `create_directories()`는 경로의 중간 디렉토리가 없으면 모두 생성한다. 예를 들어 `A/B/C`를 만들 때 `A`와 `B`가 없어도 자동으로 생성된다.

`directory_iterator`를 사용하면 디렉토리의 내용을 순회할 수 있다. 범위 기반 for 루프와 함께 사용하면 간결하게 모든 항목을 처리할 수 있다.

`remove()`는 빈 디렉토리나 파일을 삭제하고, `remove_all()`은 디렉토리와 그 안의 모든 내용을 재귀적으로 삭제한다. `remove_all()`은 복구할 수 없으므로 사용에 주의해야 한다.

파일 시스템 작업은 실패할 수 있으므로 항상 예외 처리를 해야 한다. `filesystem_error` 예외를 처리하면 오류 상황에 적절히 대응할 수 있다.

### 23.1.3 파일 복사와 이동

게임에서 세이브 파일을 백업하거나, 리소스 파일을 다른 위치로 옮기는 작업이 필요할 때가 있다.

```cpp
#include <iostream>
#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;

void Main()
{
    try
    {
        // 테스트용 디렉토리와 파일 생성
        fs::create_directories("Original");
        fs::create_directories("Backup");

        // 원본 파일 생성
        std::ofstream original("Original/savefile.dat");
        original << "Player Level: 42\n";
        original << "Gold: 1000\n";
        original.close();

        std::cout << "원본 파일 생성 완료\n\n";

        // 파일 복사
        fs::path sourceFile = "Original/savefile.dat";
        fs::path destFile = "Backup/savefile.dat";

        if (fs::exists(sourceFile))
        {
            // 덮어쓰기 옵션
            fs::copy_options options = fs::copy_options::overwrite_existing;
            fs::copy_file(sourceFile, destFile, options);
            std::cout << "파일 복사 완료: " << destFile << "\n";

            // 파일 크기 비교
            auto sourceSize = fs::file_size(sourceFile);
            auto destSize = fs::file_size(destFile);
            std::cout << "원본 크기: " << sourceSize << " 바이트\n";
            std::cout << "복사본 크기: " << destSize << " 바이트\n\n";
        }

        // 디렉토리 전체 복사
        fs::path backupDir = "FullBackup";
        if (fs::exists(backupDir))
        {
            fs::remove_all(backupDir);
        }

        fs::copy("Original", backupDir,
                fs::copy_options::recursive);
        std::cout << "디렉토리 복사 완료: " << backupDir << "\n\n";

        // 파일 이름 변경 (이동)
        fs::path newName = "Original/savefile_backup.dat";
        if (not fs::exists(newName))
        {
            fs::rename(sourceFile, newName);
            std::cout << "파일 이름 변경: " << sourceFile 
                     << " -> " << newName << "\n";
        }

        // 파일을 다른 디렉토리로 이동
        fs::path movedFile = "Backup/moved_savefile.dat";
        if (fs::exists(newName))
        {
            fs::rename(newName, movedFile);
            std::cout << "파일 이동: " << newName 
                     << " -> " << movedFile << "\n";
        }
    }
    catch (const fs::filesystem_error& e)
    {
        std::cerr << "파일 시스템 오류: " << e.what() << "\n";
        std::cerr << "경로1: " << e.path1() << "\n";
        std::cerr << "경로2: " << e.path2() << "\n";
    }
}
```

`copy_file()`은 단일 파일을 복사한다. `copy_options`로 동작을 제어할 수 있는데, `overwrite_existing`은 대상 파일이 이미 있으면 덮어쓴다. `skip_existing`을 사용하면 이미 있는 파일은 건너뛴다.

`copy()`는 디렉토리 전체를 복사할 수 있다. `copy_options::recursive`를 지정하면 하위 디렉토리까지 재귀적으로 복사한다.

`rename()`은 파일 이름을 변경하거나 다른 위치로 이동할 때 사용한다. 같은 디렉토리 내에서 이름만 바꾸거나, 다른 디렉토리로 이동하는 것 모두 가능하다.

`file_size()`는 파일의 크기를 바이트 단위로 반환한다. 이를 활용하면 복사가 제대로 되었는지 확인할 수 있다.

## 23.2 설정 파일 읽기와 쓰기

게임의 설정(볼륨, 해상도, 키 바인딩 등)을 저장하고 불러오는 것은 기본적인 기능이다. 간단한 텍스트 형식으로 설정 파일을 관리하는 방법을 알아본다.

### 23.2.1 간단한 키-값 형식의 설정 파일

가장 간단한 형태는 `키=값` 형식의 텍스트 파일이다.

```cpp
#include <iostream>
#include <fstream>
#include <filesystem>
#include <map>
#include <string>
#include <sstream>

namespace fs = std::filesystem;

class SimpleConfig
{
private:
    std::map<std::string, std::string> settings;
    fs::path configPath;

    // 문자열 앞뒤 공백 제거
    std::string trim(const std::string& str)
    {
        size_t first = str.find_first_not_of(" \t\r\n");
        if (first == std::string::npos)
        {
            return "";
        }
        size_t last = str.find_last_not_of(" \t\r\n");
        return str.substr(first, last - first + 1);
    }

public:
    SimpleConfig(const fs::path& path) : configPath(path) {}

    // 설정 파일 로드
    bool load()
    {
        if (not fs::exists(configPath))
        {
            std::cout << "설정 파일이 없다. 기본값을 사용한다.\n";
            return false;
        }

        std::ifstream file(configPath);
        if (not file.is_open())
        {
            std::cerr << "설정 파일을 열 수 없다.\n";
            return false;
        }

        settings.clear();
        std::string line;
        int lineNumber = 0;

        while (std::getline(file, line))
        {
            ++lineNumber;
            line = trim(line);

            // 빈 줄이나 주석 무시
            if (line.empty() || line[0] == '#')
            {
                continue;
            }

            // '=' 기준으로 분리
            size_t pos = line.find('=');
            if (pos == std::string::npos)
            {
                std::cerr << "잘못된 형식 (줄 " << lineNumber << "): " 
                         << line << "\n";
                continue;
            }

            std::string key = trim(line.substr(0, pos));
            std::string value = trim(line.substr(pos + 1));

            if (not key.empty())
            {
                settings[key] = value;
            }
        }

        std::cout << settings.size() << "개의 설정을 로드했다.\n";
        return true;
    }

    // 설정 파일 저장
    bool save()
    {
        // 디렉토리가 없으면 생성
        fs::path dir = configPath.parent_path();
        if (not dir.empty() && not fs::exists(dir))
        {
            fs::create_directories(dir);
        }

        std::ofstream file(configPath);
        if (not file.is_open())
        {
            std::cerr << "설정 파일을 쓸 수 없다.\n";
            return false;
        }

        file << "# 게임 설정 파일\n";
        file << "# 이 파일은 자동으로 생성된다.\n\n";

        for (const auto& [key, value] : settings)
        {
            file << key << " = " << value << "\n";
        }

        std::cout << "설정을 저장했다: " << configPath << "\n";
        return true;
    }

    // 문자열 값 가져오기
    std::string getString(const std::string& key, 
                         const std::string& defaultValue = "")
    {
        auto it = settings.find(key);
        return (it != settings.end()) ? it->second : defaultValue;
    }

    // 정수 값 가져오기
    int getInt(const std::string& key, int defaultValue = 0)
    {
        auto it = settings.find(key);
        if (it != settings.end())
        {
            try
            {
                return std::stoi(it->second);
            }
            catch (...)
            {
                return defaultValue;
            }
        }
        return defaultValue;
    }

    // 실수 값 가져오기
    double getDouble(const std::string& key, double defaultValue = 0.0)
    {
        auto it = settings.find(key);
        if (it != settings.end())
        {
            try
            {
                return std::stod(it->second);
            }
            catch (...)
            {
                return defaultValue;
            }
        }
        return defaultValue;
    }

    // 불리언 값 가져오기
    bool getBool(const std::string& key, bool defaultValue = false)
    {
        auto it = settings.find(key);
        if (it != settings.end())
        {
            std::string value = it->second;
            return (value == "true" || value == "1" || 
                   value == "yes" || value == "on");
        }
        return defaultValue;
    }

    // 값 설정
    void set(const std::string& key, const std::string& value)
    {
        settings[key] = value;
    }

    void set(const std::string& key, int value)
    {
        settings[key] = std::to_string(value);
    }

    void set(const std::string& key, double value)
    {
        settings[key] = std::to_string(value);
    }

    void set(const std::string& key, bool value)
    {
        settings[key] = value ? "true" : "false";
    }

    // 모든 설정 출력
    void print() const
    {
        std::cout << "\n=== 현재 설정 ===\n";
        for (const auto& [key, value] : settings)
        {
            std::cout << key << " = " << value << "\n";
        }
        std::cout << "==================\n\n";
    }
};

void Main()
{
    SimpleConfig config("config/game.cfg");

    // 설정 로드 시도
    config.load();

    // 기본값 설정
    if (config.getString("PlayerName").empty())
    {
        config.set("PlayerName", "Player1");
    }
    if (config.getInt("MasterVolume", -1) == -1)
    {
        config.set("MasterVolume", 80);
    }
    if (config.getInt("MusicVolume", -1) == -1)
    {
        config.set("MusicVolume", 70);
    }
    if (config.getInt("SFXVolume", -1) == -1)
    {
        config.set("SFXVolume", 90);
    }
    if (config.getString("Resolution").empty())
    {
        config.set("Resolution", "1920x1080");
    }
    config.set("Fullscreen", config.getBool("Fullscreen", false));

    // 설정 출력
    config.print();

    // 설정 수정
    std::cout << "설정을 수정한다...\n";
    config.set("PlayerName", "Hero123");
    config.set("MasterVolume", 75);
    config.set("Fullscreen", true);

    // 수정된 설정 저장
    config.save();

    // 다시 로드하여 확인
    std::cout << "\n설정을 다시 로드한다...\n";
    SimpleConfig newConfig("config/game.cfg");
    newConfig.load();
    newConfig.print();
}
```

`SimpleConfig` 클래스는 키-값 쌍의 설정을 관리한다. `std::map`을 사용하여 설정을 메모리에 저장하고, 파일로 저장하거나 로드할 수 있다.

`load()` 메서드는 텍스트 파일을 한 줄씩 읽어 `=`를 기준으로 키와 값을 분리한다. `#`로 시작하는 줄은 주석으로 처리하여 무시한다. `trim()` 함수로 불필요한 공백을 제거하여 사용자가 공백을 자유롭게 사용할 수 있게 한다.

`save()` 메서드는 현재 설정을 파일에 기록한다. 파일 상단에 주석을 추가하여 사용자가 파일의 용도를 쉽게 알 수 있게 한다.

타입별 getter 메서드(`getInt`, `getDouble`, `getBool`)는 문자열을 적절한 타입으로 변환한다. 변환에 실패하면 기본값을 반환하여 프로그램이 중단되지 않게 한다.

### 23.2.2 Siv3D를 활용한 설정 관리

Siv3D에서 설정을 관리하고 UI로 변경할 수 있는 예제를 만든다.

```cpp
#include <Siv3D.hpp>
#include <map>

class GameSettings
{
private:
    std::map<String, String> settings;
    FilePath configPath;

public:
    GameSettings(const FilePath& path) : configPath(path) {}

    bool load()
    {
        TextReader reader(configPath);
        if (not reader)
        {
            Console << U"설정 파일이 없다.";
            return false;
        }

        settings.clear();
        String line;

        while (reader.readLine(line))
        {
            line = line.trim();
            if (line.isEmpty() || line.starts_with(U'#'))
            {
                continue;
            }

            size_t pos = line.indexOf(U'=');
            if (pos == String::npos)
            {
                continue;
            }

            String key = line.substr(0, pos).trim();
            String value = line.substr(pos + 1).trim();

            if (not key.isEmpty())
            {
                settings[key] = value;
            }
        }

        Console << U"{} 개의 설정을 로드했다."_fmt(settings.size());
        return true;
    }

    bool save()
    {
        TextWriter writer(configPath);
        if (not writer)
        {
            Console << U"설정 파일을 쓸 수 없다.";
            return false;
        }

        writer.writeln(U"# 게임 설정");
        writer.writeln(U"");

        for (const auto& [key, value] : settings)
        {
            writer.writeln(U"{} = {}"_fmt(key, value));
        }

        Console << U"설정을 저장했다.";
        return true;
    }

    String getString(const String& key, const String& defaultValue = U"")
    {
        if (settings.contains(key))
        {
            return settings[key];
        }
        return defaultValue;
    }

    int32 getInt(const String& key, int32 defaultValue = 0)
    {
        if (settings.contains(key))
        {
            return ParseOr<int32>(settings[key], defaultValue);
        }
        return defaultValue;
    }

    double getDouble(const String& key, double defaultValue = 0.0)
    {
        if (settings.contains(key))
        {
            return ParseOr<double>(settings[key], defaultValue);
        }
        return defaultValue;
    }

    bool getBool(const String& key, bool defaultValue = false)
    {
        if (settings.contains(key))
        {
            String value = settings[key];
            return (value == U"true" || value == U"1");
        }
        return defaultValue;
    }

    void set(const String& key, const String& value)
    {
        settings[key] = value;
    }

    void set(const String& key, int32 value)
    {
        settings[key] = Format(value);
    }

    void set(const String& key, double value)
    {
        settings[key] = Format(value);
    }

    void set(const String& key, bool value)
    {
        settings[key] = value ? U"true" : U"false";
    }
};

void Main()
{
    Window::Resize(800, 600);
    Scene::SetBackground(ColorF{ 0.2, 0.3, 0.4 });

    GameSettings settings(U"config.txt");
    settings.load();

    // 기본값 설정
    double masterVolume = settings.getDouble(U"MasterVolume", 0.8);
    double musicVolume = settings.getDouble(U"MusicVolume", 0.7);
    double sfxVolume = settings.getDouble(U"SFXVolume", 0.9);
    bool fullscreen = settings.getBool(U"Fullscreen", false);

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // 슬라이더 상태
    std::map<String, bool> sliderDragging;
    sliderDragging[U"Master"] = false;
    sliderDragging[U"Music"] = false;
    sliderDragging[U"SFX"] = false;

    const Rect saveButton{ 300, 500, 200, 50 };

    while (System::Update())
    {
        font(U"게임 설정").draw(28, Vec2{ 280, 30 }, ColorF{ 0.9 });

        // 마스터 볼륨
        int32 y = 120;
        font(U"마스터 볼륨").draw(20, Vec2{ 100, y }, ColorF{ 0.8 });

        Rect masterSlider{ 100, y + 40, 500, 20 };
        masterSlider.draw(ColorF{ 0.3 });

        double handleX = masterSlider.x + masterSlider.w * masterVolume;
        Circle handle{ handleX, masterSlider.y + masterSlider.h / 2.0, 15 };

        if (handle.leftPressed() || 
            (sliderDragging[U"Master"] && MouseL.pressed()))
        {
            sliderDragging[U"Master"] = true;
            masterVolume = Clamp(
                (Cursor::Pos().x - masterSlider.x) / masterSlider.w,
                0.0, 1.0);
        }
        else if (MouseL.up())
        {
            sliderDragging[U"Master"] = false;
        }

        Rect{ masterSlider.pos, 
              static_cast<int32>(masterSlider.w * masterVolume),
              masterSlider.h }.draw(ColorF{ 0.4, 0.7, 0.5 });
        masterSlider.drawFrame(2, ColorF{ 0.7 });
        handle.draw(ColorF{ 0.9 });
        handle.drawFrame(2, ColorF{ 0.5 });

        font(U"{:.0f}%"_fmt(masterVolume * 100))
            .draw(18, Vec2{ 620, y + 36 }, ColorF{ 0.7 });

        // 음악 볼륨
        y = 220;
        font(U"음악 볼륨").draw(20, Vec2{ 100, y }, ColorF{ 0.8 });

        Rect musicSlider{ 100, y + 40, 500, 20 };
        musicSlider.draw(ColorF{ 0.3 });

        handleX = musicSlider.x + musicSlider.w * musicVolume;
        Circle musicHandle{ handleX, musicSlider.y + musicSlider.h / 2.0, 15 };

        if (musicHandle.leftPressed() || 
            (sliderDragging[U"Music"] && MouseL.pressed()))
        {
            sliderDragging[U"Music"] = true;
            musicVolume = Clamp(
                (Cursor::Pos().x - musicSlider.x) / musicSlider.w,
                0.0, 1.0);
        }
        else if (MouseL.up())
        {
            sliderDragging[U"Music"] = false;
        }

        Rect{ musicSlider.pos,
              static_cast<int32>(musicSlider.w * musicVolume),
              musicSlider.h }.draw(ColorF{ 0.5, 0.6, 0.8 });
        musicSlider.drawFrame(2, ColorF{ 0.7 });
        musicHandle.draw(ColorF{ 0.9 });
        musicHandle.drawFrame(2, ColorF{ 0.5 });

        font(U"{:.0f}%"_fmt(musicVolume * 100))
            .draw(18, Vec2{ 620, y + 36 }, ColorF{ 0.7 });

        // 효과음 볼륨
        y = 320;
        font(U"효과음 볼륨").draw(20, Vec2{ 100, y }, ColorF{ 0.8 });

        Rect sfxSlider{ 100, y + 40, 500, 20 };
        sfxSlider.draw(ColorF{ 0.3 });

        handleX = sfxSlider.x + sfxSlider.w * sfxVolume;
        Circle sfxHandle{ handleX, sfxSlider.y + sfxSlider.h / 2.0, 15 };

        if (sfxHandle.leftPressed() || 
            (sliderDragging[U"SFX"] && MouseL.pressed()))
        {
            sliderDragging[U"SFX"] = true;
            sfxVolume = Clamp(
                (Cursor::Pos().x - sfxSlider.x) / sfxSlider.w,
                0.0, 1.0);
        }
        else if (MouseL.up())
        {
            sliderDragging[U"SFX"] = false;
        }

        Rect{ sfxSlider.pos,
              static_cast<int32>(sfxSlider.w * sfxVolume),
              sfxSlider.h }.draw(ColorF{ 0.8, 0.6, 0.4 });
        sfxSlider.drawFrame(2, ColorF{ 0.7 });
        sfxHandle.draw(ColorF{ 0.9 });
        sfxHandle.drawFrame(2, ColorF{ 0.5 });

        font(U"{:.0f}%"_fmt(sfxVolume * 100))
            .draw(18, Vec2{ 620, y + 36 }, ColorF{ 0.7 });

        // 전체화면 체크박스
        y = 420;
        Rect checkbox{ 100, y, 30, 30 };
        checkbox.draw(ColorF{ 0.3 });
        if (fullscreen)
        {
            checkbox.stretched(-5).draw(ColorF{ 0.4, 0.8, 0.4 });
        }
        checkbox.drawFrame(2, ColorF{ 0.7 });

        font(U"전체화면").draw(20, Vec2{ 140, y }, ColorF{ 0.8 });

        if (checkbox.leftClicked())
        {
            fullscreen = not fullscreen;
        }

        // 저장 버튼
        if (saveButton.mouseOver())
        {
            saveButton.draw(ColorF{ 0.5, 0.7, 0.9 });
        }
        else
        {
            saveButton.draw(ColorF{ 0.3, 0.5, 0.7 });
        }
        saveButton.drawFrame(2, ColorF{ 0.8 });
        font(U"저장").drawAt(22, saveButton.center(), ColorF{ 0.9 });

        if (saveButton.leftClicked())
        {
            settings.set(U"MasterVolume", masterVolume);
            settings.set(U"MusicVolume", musicVolume);
            settings.set(U"SFXVolume", sfxVolume);
            settings.set(U"Fullscreen", fullscreen);
            settings.save();

            Console << U"설정이 저장되었다.";
        }
    }
}
```

Siv3D의 `TextReader`와 `TextWriter`를 사용하면 유니코드 문자열을 안전하게 읽고 쓸 수 있다. `String` 클래스의 `trim()`, `starts_with()`, `indexOf()` 등의 메서드로 문자열을 편리하게 처리한다.

사용자가 슬라이더와 체크박스로 설정을 변경하고, 저장 버튼을 클릭하면 파일에 기록된다. 프로그램을 다시 실행하면 저장된 설정이 자동으로 로드되어 이전 상태가 복원된다.

## 23.3 JSON 데이터 처리

JSON(JavaScript Object Notation)은 데이터를 구조화하여 저장하는 표준 형식이다. 계층적 데이터, 배열, 다양한 타입을 표현할 수 있어 게임 데이터 저장에 매우 유용하다. Siv3D는 JSON을 쉽게 다룰 수 있는 기능을 내장하고 있다.

### 23.3.1 JSON 기초

JSON의 기본 구조와 Siv3D에서 JSON을 다루는 방법을 배운다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Window::Resize(800, 600);
    Scene::SetBackground(ColorF{ 0.15, 0.2, 0.25 });

    // JSON 객체 생성
    JSON json;

    // 기본 타입 저장
    json[U"PlayerName"] = U"Hero";
    json[U"Level"] = 42;
    json[U"Experience"] = 15750;
    json[U"Health"] = 87.5;
    json[U"IsAlive"] = true;

    // 배열 저장
    json[U"Inventory"] = JSON::Array();
    json[U"Inventory"].push_back(U"Sword");
    json[U"Inventory"].push_back(U"Shield");
    json[U"Inventory"].push_back(U"Potion");

    // 중첩 객체
    json[U"Position"] = JSON::Object();
    json[U"Position"][U"X"] = 100.5;
    json[U"Position"][U"Y"] = 200.3;

    json[U"Stats"] = JSON::Object();
    json[U"Stats"][U"Strength"] = 15;
    json[U"Stats"][U"Agility"] = 12;
    json[U"Stats"][U"Intelligence"] = 18;

    // JSON 파일로 저장 (보기 좋게 포맷팅)
    json.save(U"player_data.json");

    Console << U"JSON 파일 저장 완료";

    // JSON 파일 로드
    JSON loadedJson = JSON::Load(U"player_data.json");

    if (loadedJson)
    {
        Console << U"JSON 파일 로드 완료\n";

        // 데이터 읽기
        String name = loadedJson[U"PlayerName"].get<String>();
        int32 level = loadedJson[U"Level"].get<int32>();
        double health = loadedJson[U"Health"].get<double>();
        bool isAlive = loadedJson[U"IsAlive"].get<bool>();

        Console << U"이름: " << name;
        Console << U"레벨: " << level;
        Console << U"체력: " << health;
        Console << U"생존: " << isAlive;

        // 배열 읽기
        Console << U"\n인벤토리:";
        for (const auto& item : loadedJson[U"Inventory"].arrayView())
        {
            Console << U"  - " << item.get<String>();
        }

        // 중첩 객체 읽기
        Console << U"\n위치:";
        double x = loadedJson[U"Position"][U"X"].get<double>();
        double y = loadedJson[U"Position"][U"Y"].get<double>();
        Console << U"  X: " << x << U", Y: " << y;

        Console << U"\n능력치:";
        int32 str = loadedJson[U"Stats"][U"Strength"].get<int32>();
        int32 agi = loadedJson[U"Stats"][U"Agility"].get<int32>();
        int32 intel = loadedJson[U"Stats"][U"Intelligence"].get<int32>();
        Console << U"  힘: " << str;
        Console << U"  민첩: " << agi;
        Console << U"  지능: " << intel;
    }

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    while (System::Update())
    {
        font(U"JSON 데이터 처리").draw(22, Vec2{ 250, 50 }, ColorF{ 0.9 });
        font(U"콘솔 창을 확인하세요").draw(18, Vec2{ 220, 100 }, 
                                            ColorF{ 0.7 });
    }
}
```

Siv3D의 `JSON` 클래스는 JSON 데이터를 쉽게 다룰 수 있게 해준다. `[]` 연산자로 키에 접근하고 값을 할당할 수 있다. 기본 타입(문자열, 숫자, 불리언)뿐만 아니라 배열과 객체도 저장할 수 있다.

`JSON::Array()`는 빈 배열을 생성하고, `push_back()`으로 요소를 추가한다. `JSON::Object()`는 빈 객체를 생성하여 중첩된 구조를 만들 수 있다.

`save()` 메서드는 JSON 데이터를 파일로 저장한다. 자동으로 들여쓰기를 적용하여 사람이 읽기 쉬운 형식으로 저장된다. `JSON::Load()`는 파일에서 JSON을 로드하며, 로드에 실패하면 불리언 변환 시 `false`를 반환한다.

`get<T>()`로 특정 타입의 값을 추출한다. 배열은 `arrayView()`로 순회할 수 있고, 각 요소에서 값을 추출한다.

### 23.3.2 복잡한 게임 데이터 저장

실제 게임에서 사용할 수 있는 더 복잡한 데이터 구조를 JSON으로 저장하고 로드하는 예제다.

```cpp
#include <Siv3D.hpp>

// 아이템 구조체
struct Item
{
    String name;
    String type;
    int32 quantity;
    double value;

    JSON toJSON() const
    {
        JSON json;
        json[U"Name"] = name;
        json[U"Type"] = type;
        json[U"Quantity"] = quantity;
        json[U"Value"] = value;
        return json;
    }

    static Item fromJSON(const JSON& json)
    {
        Item item;
        item.name = json[U"Name"].get<String>();
        item.type = json[U"Type"].get<String>();
        item.quantity = json[U"Quantity"].get<int32>();
        item.value = json[U"Value"].get<double>();
        return item;
    }
};

// 퀘스트 구조체
struct Quest
{
    String id;
    String title;
    String description;
    bool completed;
    int32 progress;
    int32 goal;

    JSON toJSON() const
    {
        JSON json;
        json[U"ID"] = id;
        json[U"Title"] = title;
        json[U"Description"] = description;
        json[U"Completed"] = completed;
        json[U"Progress"] = progress;
        json[U"Goal"] = goal;
        return json;
    }

    static Quest fromJSON(const JSON& json)
    {
        Quest quest;
        quest.id = json[U"ID"].get<String>();
        quest.title = json[U"Title"].get<String>();
        quest.description = json[U"Description"].get<String>();
        quest.completed = json[U"Completed"].get<bool>();
        quest.progress = json[U"Progress"].get<int32>();
        quest.goal = json[U"Goal"].get<int32>();
        return quest;
    }
};

// 게임 세이브 데이터
class GameSave
{
public:
    String playerName;
    int32 level;
    int32 experience;
    Vec2 position;
    Array<Item> inventory;
    Array<Quest> quests;

    JSON toJSON() const
    {
        JSON json;

        // 기본 정보
        json[U"PlayerName"] = playerName;
        json[U"Level"] = level;
        json[U"Experience"] = experience;

        // 위치
        json[U"Position"] = JSON::Object();
        json[U"Position"][U"X"] = position.x;
        json[U"Position"][U"Y"] = position.y;

        // 인벤토리
        json[U"Inventory"] = JSON::Array();
        for (const auto& item : inventory)
        {
            json[U"Inventory"].push_back(item.toJSON());
        }

        // 퀘스트
        json[U"Quests"] = JSON::Array();
        for (const auto& quest : quests)
        {
            json[U"Quests"].push_back(quest.toJSON());
        }

        // 저장 시간
        json[U"SaveTime"] = Format(DateTime::Now());

        return json;
    }

    static GameSave fromJSON(const JSON& json)
    {
        GameSave save;

        save.playerName = json[U"PlayerName"].get<String>();
        save.level = json[U"Level"].get<int32>();
        save.experience = json[U"Experience"].get<int32>();

        save.position.x = json[U"Position"][U"X"].get<double>();
        save.position.y = json[U"Position"][U"Y"].get<double>();

        for (const auto& itemJson : json[U"Inventory"].arrayView())
        {
            save.inventory.push_back(Item::fromJSON(itemJson));
        }

        for (const auto& questJson : json[U"Quests"].arrayView())
        {
            save.quests.push_back(Quest::fromJSON(questJson));
        }

        return save;
    }

    bool save(const FilePath& path) const
    {
        return toJSON().save(path);
    }

    static GameSave load(const FilePath& path)
    {
        JSON json = JSON::Load(path);
        if (not json)
        {
            throw Error{ U"세이브 파일을 로드할 수 없다." };
        }
        return fromJSON(json);
    }
};

void Main()
{
    Window::Resize(800, 600);
    Scene::SetBackground(ColorF{ 0.1, 0.15, 0.2 });

    // 게임 데이터 생성
    GameSave gameSave;
    gameSave.playerName = U"용사";
    gameSave.level = 25;
    gameSave.experience = 12500;
    gameSave.position = Vec2{ 150.5, 220.8 };

    // 인벤토리 추가
    gameSave.inventory.push_back(Item{ U"철검", U"무기", 1, 500.0 });
    gameSave.inventory.push_back(Item{ U"체력 물약", U"소모품", 5, 50.0 });
    gameSave.inventory.push_back(Item{ U"마나 물약", U"소모품", 3, 75.0 });
    gameSave.inventory.push_back(Item{ U"철 갑옷", U"방어구", 1, 800.0 });

    // 퀘스트 추가
    gameSave.quests.push_back(Quest{
        U"quest_001",
        U"슬라임 토벌",
        U"슬라임 10마리를 처치하라",
        true,
        10,
        10
    });

    gameSave.quests.push_back(Quest{
        U"quest_002",
        U"약초 수집",
        U"빨간 약초를 5개 모아라",
        false,
        3,
        5
    });

    gameSave.quests.push_back(Quest{
        U"quest_003",
        U"마을 방어",
        U"마을을 공격하는 몬스터를 막아라",
        false,
        0,
        1
    });

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    const Rect saveButton{ 250, 250, 150, 60 };
    const Rect loadButton{ 420, 250, 150, 60 };

    Optional<GameSave> loadedSave;

    while (System::Update())
    {
        font(U"게임 세이브 시스템").draw(22, Vec2{ 230, 50 }, ColorF{ 0.9 });

        // 현재 데이터 표시
        font(U"현재 데이터:").draw(18, Vec2{ 100, 120 }, ColorF{ 0.8 });
        font(U"플레이어: {}"_fmt(gameSave.playerName))
            .draw(16, Vec2{ 120, 150 }, ColorF{ 0.7 });
        font(U"레벨: {}"_fmt(gameSave.level))
            .draw(16, Vec2{ 120, 175 }, ColorF{ 0.7 });
        font(U"아이템: {}개"_fmt(gameSave.inventory.size()))
            .draw(16, Vec2{ 120, 200 }, ColorF{ 0.7 });

        // 저장 버튼
        if (saveButton.mouseOver())
        {
            saveButton.draw(ColorF{ 0.5, 0.7, 0.9 });
        }
        else
        {
            saveButton.draw(ColorF{ 0.3, 0.5, 0.7 });
        }
        saveButton.drawFrame(2, ColorF{ 0.8 });
        font(U"저장").drawAt(20, saveButton.center(), ColorF{ 0.9 });

        if (saveButton.leftClicked())
        {
            if (gameSave.save(U"savefile.json"))
            {
                Console << U"게임을 저장했다.";
            }
        }

        // 로드 버튼
        if (loadButton.mouseOver())
        {
            loadButton.draw(ColorF{ 0.7, 0.9, 0.5 });
        }
        else
        {
            loadButton.draw(ColorF{ 0.5, 0.7, 0.3 });
        }
        loadButton.drawFrame(2, ColorF{ 0.8 });
        font(U"로드").drawAt(20, loadButton.center(), ColorF{ 0.9 });

        if (loadButton.leftClicked())
        {
            try
            {
                loadedSave = GameSave::load(U"savefile.json");
                Console << U"게임을 로드했다.";
            }
            catch (const Error& e)
            {
                Console << U"로드 실패: " << e.what();
            }
        }

        // 로드된 데이터 표시
        if (loadedSave)
        {
            font(U"로드된 데이터:").draw(18, Vec2{ 100, 350 }, ColorF{ 0.8 });
            font(U"플레이어: {}"_fmt(loadedSave->playerName))
                .draw(16, Vec2{ 120, 380 }, ColorF{ 0.7 });
            font(U"레벨: {}"_fmt(loadedSave->level))
                .draw(16, Vec2{ 120, 405 }, ColorF{ 0.7 });
            font(U"경험치: {}"_fmt(loadedSave->experience))
                .draw(16, Vec2{ 120, 430 }, ColorF{ 0.7 });
            font(U"위치: ({:.1f}, {:.1f})"_fmt(
                    loadedSave->position.x, loadedSave->position.y))
                .draw(16, Vec2{ 120, 455 }, ColorF{ 0.7 });
            font(U"퀘스트: {}개"_fmt(loadedSave->quests.size()))
                .draw(16, Vec2{ 120, 480 }, ColorF{ 0.7 });
        }
    }
}
```

이 예제는 게임의 전체 상태를 JSON으로 저장하고 불러오는 시스템을 보여준다. 각 구조체에 `toJSON()`과 `fromJSON()` 메서드를 만들어 직렬화와 역직렬화를 처리한다.

`GameSave` 클래스는 플레이어 정보, 인벤토리, 퀘스트 등 복잡한 데이터를 관리한다. 모든 데이터를 JSON으로 변환하여 한 번에 저장하고, 로드할 때는 JSON에서 다시 객체로 변환한다.

저장 시간을 함께 기록하면 여러 세이브 파일 중에서 어느 것이 가장 최근인지 알 수 있다. `DateTime::Now()`는 현재 시간을 반환하며, `Format()`으로 문자열로 변환하여 저장한다.

## 23.4 게임 데이터 저장과 로드

실제 게임에서 사용할 수 있는 세이브/로드 시스템을 완성한다. 여러 슬롯을 지원하고, 세이브 파일 목록을 보여주며, 삭제 기능도 제공한다.

### 23.4.1 다중 슬롯 세이브 시스템

```cpp
#include <Siv3D.hpp>

struct SaveSlot
{
    int32 slotNumber;
    String playerName;
    int32 level;
    String saveTime;
    bool exists;

    JSON toJSON() const
    {
        JSON json;
        json[U"SlotNumber"] = slotNumber;
        json[U"PlayerName"] = playerName;
        json[U"Level"] = level;
        json[U"SaveTime"] = saveTime;
        return json;
    }

    static SaveSlot fromJSON(const JSON& json, int32 slot)
    {
        SaveSlot save;
        save.slotNumber = slot;
        save.playerName = json[U"PlayerName"].get<String>();
        save.level = json[U"Level"].get<int32>();
        save.saveTime = json[U"SaveTime"].get<String>();
        save.exists = true;
        return save;
    }
};

class SaveManager
{
private:
    FilePath saveDirectory;
    static constexpr int32 MaxSlots = 5;

    FilePath getSlotPath(int32 slot) const
    {
        return saveDirectory + U"/save_slot_{}.json"_fmt(slot);
    }

public:
    SaveManager(const FilePath& dir) : saveDirectory(dir)
    {
        // 저장 디렉토리 생성
        if (not FileSystem::Exists(saveDirectory))
        {
            FileSystem::CreateDirectories(saveDirectory);
        }
    }

    Array<SaveSlot> getSaveSlots() const
    {
        Array<SaveSlot> slots;

        for (int32 i = 0; i < MaxSlots; ++i)
        {
            FilePath path = getSlotPath(i);
            SaveSlot slot;
            slot.slotNumber = i;
            slot.exists = false;

            if (FileSystem::Exists(path))
            {
                JSON json = JSON::Load(path);
                if (json)
                {
                    slot = SaveSlot::fromJSON(json, i);
                }
            }

            slots.push_back(slot);
        }

        return slots;
    }

    bool saveToSlot(int32 slot, const String& playerName, int32 level)
    {
        if (slot < 0 || slot >= MaxSlots)
        {
            return false;
        }

        JSON json;
        json[U"PlayerName"] = playerName;
        json[U"Level"] = level;
        json[U"SaveTime"] = Format(DateTime::Now());
        json[U"GameData"] = JSON::Object();
        json[U"GameData"][U"Position"] = JSON::Array();
        json[U"GameData"][U"Position"].push_back(100.0);
        json[U"GameData"][U"Position"].push_back(200.0);

        return json.save(getSlotPath(slot));
    }

    Optional<JSON> loadFromSlot(int32 slot) const
    {
        if (slot < 0 || slot >= MaxSlots)
        {
            return none;
        }

        FilePath path = getSlotPath(slot);
        if (not FileSystem::Exists(path))
        {
            return none;
        }

        JSON json = JSON::Load(path);
        if (json)
        {
            return json;
        }

        return none;
    }

    bool deleteSlot(int32 slot)
    {
        if (slot < 0 || slot >= MaxSlots)
        {
            return false;
        }

        FilePath path = getSlotPath(slot);
        if (FileSystem::Exists(path))
        {
            return FileSystem::Remove(path);
        }

        return false;
    }

    int32 getMaxSlots() const
    {
        return MaxSlots;
    }
};

void Main()
{
    Window::Resize(800, 600);
    Scene::SetBackground(ColorF{ 0.1, 0.12, 0.15 });

    SaveManager saveManager(U"SaveData");

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };
    const Font smallFont{ FontMethod::MSDF, 40 };

    // 테스트용 플레이어 데이터
    String currentPlayer = U"영웅";
    int32 currentLevel = 1;

    // 선택된 슬롯
    Optional<int32> selectedSlot;

    while (System::Update())
    {
        font(U"세이브/로드").draw(26, Vec2{ 300, 30 }, ColorF{ 0.9 });

        // 현재 게임 상태
        RectF infoBox{ 50, 80, 700, 80 };
        infoBox.draw(ColorF{ 0.2, 0.25, 0.3 });
        infoBox.drawFrame(2, ColorF{ 0.4, 0.5, 0.6 });

        smallFont(U"현재 플레이어: {}"_fmt(currentPlayer))
            .draw(18, infoBox.pos.movedBy(20, 15), ColorF{ 0.9 });
        smallFont(U"레벨: {}"_fmt(currentLevel))
            .draw(18, infoBox.pos.movedBy(20, 45), ColorF{ 0.9 });

        // 세이브 슬롯 목록
        Array<SaveSlot> slots = saveManager.getSaveSlots();

        int32 y = 190;
        for (int32 i = 0; i < saveManager.getMaxSlots(); ++i)
        {
            const SaveSlot& slot = slots[i];
            RectF slotBox{ 50, y, 500, 70 };

            // 슬롯 박스
            bool isHovered = slotBox.mouseOver();
            bool isSelected = (selectedSlot && *selectedSlot == i);

            if (isSelected)
            {
                slotBox.draw(ColorF{ 0.3, 0.4, 0.6 });
            }
            else if (isHovered)
            {
                slotBox.draw(ColorF{ 0.25, 0.3, 0.4 });
            }
            else
            {
                slotBox.draw(ColorF{ 0.15, 0.2, 0.25 });
            }

            slotBox.drawFrame(2, ColorF{ 0.5, 0.6, 0.7 });

            if (slotBox.leftClicked())
            {
                selectedSlot = i;
            }

            // 슬롯 내용
            if (slot.exists)
            {
                smallFont(U"슬롯 {}: {}"_fmt(i + 1, slot.playerName))
                    .draw(18, slotBox.pos.movedBy(15, 10), ColorF{ 0.9 });
                smallFont(U"레벨: {} | {}"_fmt(slot.level, slot.saveTime))
                    .draw(14, slotBox.pos.movedBy(15, 38), ColorF{ 0.6 });
            }
            else
            {
                smallFont(U"슬롯 {} - 비어있음"_fmt(i + 1))
                    .draw(18, slotBox.pos.movedBy(15, 22), ColorF{ 0.5 });
            }

            // 삭제 버튼
            if (slot.exists)
            {
                RectF deleteBtn{ 560, y + 20, 80, 30 };

                if (deleteBtn.mouseOver())
                {
                    deleteBtn.draw(ColorF{ 0.9, 0.3, 0.3 });
                }
                else
                {
                    deleteBtn.draw(ColorF{ 0.7, 0.2, 0.2 });
                }

                deleteBtn.drawFrame(1, ColorF{ 0.8 });
                smallFont(U"삭제").drawAt(14, deleteBtn.center(), ColorF{ 0.9 });

                if (deleteBtn.leftClicked())
                {
                    if (saveManager.deleteSlot(i))
                    {
                        Console << U"슬롯 {}를 삭제했다."_fmt(i + 1);
                        if (selectedSlot && *selectedSlot == i)
                        {
                            selectedSlot = none;
                        }
                    }
                }
            }

            // 로드 버튼
            if (slot.exists)
            {
                RectF loadBtn{ 650, y + 20, 80, 30 };

                if (loadBtn.mouseOver())
                {
                    loadBtn.draw(ColorF{ 0.3, 0.7, 0.9 });
                }
                else
                {
                    loadBtn.draw(ColorF{ 0.2, 0.5, 0.7 });
                }

                loadBtn.drawFrame(1, ColorF{ 0.8 });
                smallFont(U"로드").drawAt(14, loadBtn.center(), ColorF{ 0.9 });

                if (loadBtn.leftClicked())
                {
                    auto data = saveManager.loadFromSlot(i);
                    if (data)
                    {
                        currentPlayer = (*data)[U"PlayerName"].get<String>();
                        currentLevel = (*data)[U"Level"].get<int32>();
                        Console << U"슬롯 {}에서 로드했다."_fmt(i + 1);
                    }
                }
            }

            y += 80;
        }

        // 저장 버튼
        RectF saveBtn{ 300, 520, 200, 50 };

        bool canSave = selectedSlot.has_value();
        if (canSave && saveBtn.mouseOver())
        {
            saveBtn.draw(ColorF{ 0.5, 0.8, 0.5 });
        }
        else if (canSave)
        {
            saveBtn.draw(ColorF{ 0.3, 0.6, 0.3 });
        }
        else
        {
            saveBtn.draw(ColorF{ 0.2, 0.2, 0.2 });
        }

        saveBtn.drawFrame(2, ColorF{ 0.7 });
        font(U"선택한 슬롯에 저장").drawAt(18, saveBtn.center(),
                                          canSave ? ColorF{ 0.9 } : ColorF{ 0.4 });

        if (canSave && saveBtn.leftClicked())
        {
            // 레벨 증가 (테스트용)
            currentLevel++;

            if (saveManager.saveToSlot(*selectedSlot, currentPlayer, currentLevel))
            {
                Console << U"슬롯 {}에 저장했다."_fmt(*selectedSlot + 1);
            }
        }
    }
}
```

`SaveManager` 클래스는 여러 세이브 슬롯을 관리한다. 각 슬롯은 별도의 JSON 파일로 저장되며, 슬롯 번호를 파일 이름에 포함시켜 구분한다.

`getSaveSlots()` 메서드는 모든 슬롯의 정보를 읽어 배열로 반환한다. 빈 슬롯은 `exists` 필드가 `false`로 설정된다. 이를 통해 UI에서 빈 슬롯과 사용 중인 슬롯을 다르게 표시할 수 있다.

사용자는 슬롯을 클릭하여 선택하고, 저장 버튼을 누르면 현재 게임 상태가 선택된 슬롯에 저장된다. 각 슬롯 옆에는 로드 버튼과 삭제 버튼이 있어 직접 해당 슬롯의 데이터를 불러오거나 삭제할 수 있다.

### 23.4.2 자동 저장 시스템

게임이 일정 시간마다 자동으로 저장되는 시스템을 구현한다.

```cpp
#include <Siv3D.hpp>

class AutoSaveSystem
{
private:
    double autoSaveInterval;  // 초 단위
    double lastSaveTime;
    bool enabled;

public:
    AutoSaveSystem(double intervalSec = 60.0)
        : autoSaveInterval(intervalSec)
        , lastSaveTime(0.0)
        , enabled(true)
    {}

    void setEnabled(bool enable)
    {
        enabled = enable;
    }

    bool isEnabled() const
    {
        return enabled;
    }

    void setInterval(double intervalSec)
    {
        autoSaveInterval = intervalSec;
    }

    double getInterval() const
    {
        return autoSaveInterval;
    }

    bool shouldSave(double currentTime)
    {
        if (not enabled)
        {
            return false;
        }

        if (currentTime - lastSaveTime >= autoSaveInterval)
        {
            lastSaveTime = currentTime;
            return true;
        }

        return false;
    }

    double getTimeSinceLastSave(double currentTime) const
    {
        return currentTime - lastSaveTime;
    }

    double getTimeUntilNextSave(double currentTime) const
    {
        double elapsed = currentTime - lastSaveTime;
        return Max(0.0, autoSaveInterval - elapsed);
    }

    void resetTimer(double currentTime)
    {
        lastSaveTime = currentTime;
    }
};

void Main()
{
    Window::Resize(800, 600);
    Scene::SetBackground(ColorF{ 0.12, 0.15, 0.18 });

    AutoSaveSystem autoSave(10.0);  // 10초마다 자동 저장

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    int32 gameState = 0;  // 간단한 게임 상태
    bool lastSaveSuccessful = false;

    const Rect toggleButton{ 250, 200, 300, 60 };
    const Rect manualSaveButton{ 250, 280, 300, 60 };
    const Rect intervalMinusButton{ 200, 380, 50, 40 };
    const Rect intervalPlusButton{ 550, 380, 50, 40 };

    while (System::Update())
    {
        gameState++;  // 게임 상태 변화 시뮬레이션

        font(U"자동 저장 시스템").draw(24, Vec2{ 250, 50 }, ColorF{ 0.9 });

        // 자동 저장 확인
        if (autoSave.shouldSave(Scene::Time()))
        {
            // 자동 저장 실행
            JSON saveData;
            saveData[U"GameState"] = gameState;
            saveData[U"SaveTime"] = Format(DateTime::Now());
            saveData[U"AutoSave"] = true;

            if (saveData.save(U"autosave.json"))
            {
                Console << U"자동 저장 완료 (게임 상태: {})"_fmt(gameState);
                lastSaveSuccessful = true;
            }
        }

        // 자동 저장 토글 버튼
        if (toggleButton.mouseOver())
        {
            toggleButton.draw(autoSave.isEnabled() ? ColorF{ 0.3, 0.7, 0.3 }
                                                   : ColorF{ 0.7, 0.3, 0.3 });
        }
        else
        {
            toggleButton.draw(autoSave.isEnabled() ? ColorF{ 0.2, 0.5, 0.2 }
                                                   : ColorF{ 0.5, 0.2, 0.2 });
        }

        toggleButton.drawFrame(2, ColorF{ 0.8 });
        font(autoSave.isEnabled() ? U"자동 저장: 켜짐" : U"자동 저장: 꺼짐")
            .drawAt(20, toggleButton.center(), ColorF{ 0.9 });

        if (toggleButton.leftClicked())
        {
            autoSave.setEnabled(not autoSave.isEnabled());
        }

        // 수동 저장 버튼
        if (manualSaveButton.mouseOver())
        {
            manualSaveButton.draw(ColorF{ 0.5, 0.6, 0.8 });
        }
        else
        {
            manualSaveButton.draw(ColorF{ 0.3, 0.4, 0.6 });
        }

        manualSaveButton.drawFrame(2, ColorF{ 0.8 });
        font(U"수동 저장").drawAt(20, manualSaveButton.center(), ColorF{ 0.9 });

        if (manualSaveButton.leftClicked())
        {
            JSON saveData;
            saveData[U"GameState"] = gameState;
            saveData[U"SaveTime"] = Format(DateTime::Now());
            saveData[U"AutoSave"] = false;

            if (saveData.save(U"manualsave.json"))
            {
                Console << U"수동 저장 완료";
                autoSave.resetTimer(Scene::Time());
            }
        }

        // 자동 저장 간격 조절
        font(U"자동 저장 간격").draw(20, Vec2{ 250, 350 }, ColorF{ 0.8 });

        if (intervalMinusButton.mouseOver())
        {
            intervalMinusButton.draw(ColorF{ 0.6, 0.5, 0.4 });
        }
        else
        {
            intervalMinusButton.draw(ColorF{ 0.4, 0.3, 0.2 });
        }

        intervalMinusButton.drawFrame(2, ColorF{ 0.7 });
        font(U"-").drawAt(24, intervalMinusButton.center(), ColorF{ 0.9 });

        if (intervalMinusButton.leftClicked())
        {
            double newInterval = Max(5.0, autoSave.getInterval() - 5.0);
            autoSave.setInterval(newInterval);
        }

        Rect intervalDisplay{ 260, 380, 280, 40 };
        intervalDisplay.draw(ColorF{ 0.2, 0.25, 0.3 });
        intervalDisplay.drawFrame(2, ColorF{ 0.5 });
        font(U"{:.0f}초"_fmt(autoSave.getInterval()))
            .drawAt(20, intervalDisplay.center(), ColorF{ 0.9 });

        if (intervalPlusButton.mouseOver())
        {
            intervalPlusButton.draw(ColorF{ 0.6, 0.5, 0.4 });
        }
        else
        {
            intervalPlusButton.draw(ColorF{ 0.4, 0.3, 0.2 });
        }

        intervalPlusButton.drawFrame(2, ColorF{ 0.7 });
        font(U"+").drawAt(24, intervalPlusButton.center(), ColorF{ 0.9 });

        if (intervalPlusButton.leftClicked())
        {
            double newInterval = Min(300.0, autoSave.getInterval() + 5.0);
            autoSave.setInterval(newInterval);
        }

        // 다음 저장까지 남은 시간
        if (autoSave.isEnabled())
        {
            double timeUntil = autoSave.getTimeUntilNextSave(Scene::Time());
            font(U"다음 저장: {:.1f}초 후"_fmt(timeUntil))
                .draw(18, Vec2{ 250, 450 }, ColorF{ 0.7 });

            // 진행 바
            Rect progressBar{ 250, 480, 300, 20 };
            progressBar.draw(ColorF{ 0.2 });

            double progress = 1.0 - (timeUntil / autoSave.getInterval());
            Rect{ progressBar.pos,
                  static_cast<int32>(progressBar.w * progress),
                  progressBar.h }
                .draw(ColorF{ 0.3, 0.7, 0.3 });

            progressBar.drawFrame(2, ColorF{ 0.6 });
        }

        // 게임 상태 표시
        font(U"게임 상태: {}"_fmt(gameState))
            .draw(18, Vec2{ 250, 120 }, ColorF{ 0.6 });

        // 마지막 저장 성공 표시
        if (lastSaveSuccessful && Scene::Time() < autoSave.getTimeSinceLastSave(Scene::Time()) + 2.0)
        {
            font(U"✓ 저장됨")
                .draw(18, Vec2{ 250, 150 },
                      ColorF{ 0.3, 0.9, 0.3, 1.0 - (Scene::Time() - autoSave.getTimeSinceLastSave(Scene::Time())) / 2.0 });
        }
    }
}
```

`AutoSaveSystem` 클래스는 자동 저장 로직을 캡슐화한다. `shouldSave()` 메서드를 매 프레임 호출하면 설정된 간격이 지났을 때 `true`를 반환한다.

사용자는 자동 저장을 끄거나 켤 수 있고, 저장 간격도 조절할 수 있다. 수동 저장을 하면 자동 저장 타이머가 리셋되어 바로 다시 자동 저장되는 것을 방지한다.

진행 바로 다음 자동 저장까지 남은 시간을 시각적으로 보여주면 사용자가 언제 저장될지 예측할 수 있다. 저장이 완료되면 짧은 시간 동안 피드백 메시지를 표시하여 저장이 성공했음을 알린다.

## 23.5 실습 문제

이번 장에서 배운 내용을 바탕으로 다음 문제들을 해결한다.

**문제 1: 환경 설정 편집기**

사용자가 다양한 설정을 GUI로 편집하고 저장할 수 있는 편집기를 만든다.

요구사항은 다음과 같다. 최소 5개의 다른 타입 설정(문자열, 정수, 실수, 불리언)을 관리한다. 설정 값을 UI로 편집할 수 있어야 하며, 저장 및 로드 버튼을 구현한다. 설정 파일이 없으면 기본값을 사용하고, 잘못된 값이 입력되면 기본값으로 복원한다.

**문제 2: 게임 진행 상황 관리**

레벨, 점수, 획득한 아이템, 완료한 스테이지 등의 정보를 저장하고 불러오는 시스템을 만든다.

요구사항은 다음과 같다. JSON 형식으로 게임 진행 상황을 저장하고, 플레이어가 게임을 재시작해도 이전 상태가 유지된다. 세이브 파일 목록을 보여주고 선택하여 로드할 수 있으며, 세이브 파일을 백업하거나 삭제하는 기능을 제공한다.

**문제 3: 리소스 관리자**

게임에서 사용하는 리소스 파일(이미지, 사운드 등)의 목록을 파일로 관리하는 시스템을 만든다.

요구사항은 다음과 같다. 디렉토리 내의 모든 리소스 파일을 검색하여 목록을 만들고, 파일 이름, 크기, 타입 등의 정보를 JSON으로 저장한다. 리소스 파일이 변경되면 자동으로 감지하여 목록을 업데이트하며, 특정 리소스를 빠르게 검색할 수 있는 기능을 제공한다.

## 23.6 심화 내용

### 23.6.1 암호화된 세이브 파일

게임의 세이브 파일을 사용자가 직접 수정하는 것을 방지하기 위해 암호화할 수 있다. 간단한 XOR 암호화를 사용하는 예제다.

```cpp
#include <Siv3D.hpp>

class EncryptedSave
{
private:
    static constexpr uint8 XOR_KEY = 0xA5;  // 암호화 키

    static void encryptData(Blob& data)
    {
        for (auto& byte : data)
        {
            byte ^= XOR_KEY;
        }
    }

public:
    static bool save(const FilePath& path, const JSON& data)
    {
        // JSON을 문자열로 변환
        String jsonString = data.formatUTF8();

        // UTF-8 바이트로 변환
        std::string utf8Str = jsonString.toUTF8();

        // Blob 생성 및 암호화
        Blob blob(utf8Str.size());
        std::memcpy(blob.data(), utf8Str.data(), utf8Str.size());

        encryptData(blob);

        // 파일로 저장
        BinaryWriter writer(path);
        if (not writer)
        {
            return false;
        }

        writer.write(blob.data(), blob.size());
        return true;
    }

    static Optional<JSON> load(const FilePath& path)
    {
        // 파일 읽기
        BinaryReader reader(path);
        if (not reader)
        {
            return none;
        }

        // 전체 데이터 읽기
        Blob blob = reader.readAll();

        // 복호화
        encryptData(blob);

        // JSON 파싱
        std::string utf8Str(reinterpret_cast<const char*>(blob.data()),
                           blob.size());

        JSON json = JSON::Parse(Unicode::FromUTF8(utf8Str));

        if (json)
        {
            return json;
        }

        return none;
    }
};

void Main()
{
    Window::Resize(800, 600);
    Scene::SetBackground(ColorF{ 0.1, 0.15, 0.2 });

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // 게임 데이터
    JSON gameData;
    gameData[U"PlayerName"] = U"Hero";
    gameData[U"Level"] = 50;
    gameData[U"Score"] = 123456;
    gameData[U"SecretValue"] = U"ThisShouldBeHidden";

    bool savedEncrypted = false;
    bool loadedSuccess = false;
    String loadedName;
    int32 loadedLevel = 0;

    const Rect saveButton{ 250, 200, 300, 60 };
    const Rect loadButton{ 250, 280, 300, 60 };
    const Rect viewFileButton{ 250, 360, 300, 60 };

    while (System::Update())
    {
        font(U"암호화된 세이브").draw(24, Vec2{ 250, 50 }, ColorF{ 0.9 });

        // 원본 데이터 표시
        font(U"원본 데이터:").draw(18, Vec2{ 100, 120 }, ColorF{ 0.8 });
        font(U"이름: {}"_fmt(gameData[U"PlayerName"].get<String>()))
            .draw(16, Vec2{ 120, 150 }, ColorF{ 0.7 });
        font(U"레벨: {}"_fmt(gameData[U"Level"].get<int32>()))
            .draw(16, Vec2{ 120, 175 }, ColorF{ 0.7 });

        // 암호화하여 저장
        if (saveButton.mouseOver())
        {
            saveButton.draw(ColorF{ 0.5, 0.7, 0.5 });
        }
        else
        {
            saveButton.draw(ColorF{ 0.3, 0.5, 0.3 });
        }

        saveButton.drawFrame(2, ColorF{ 0.8 });
        font(U"암호화하여 저장").drawAt(20, saveButton.center(), ColorF{ 0.9 });

        if (saveButton.leftClicked())
        {
            if (EncryptedSave::save(U"encrypted_save.dat", gameData))
            {
                Console << U"암호화된 파일로 저장됨";
                savedEncrypted = true;
            }
        }

        // 복호화하여 로드
        if (loadButton.mouseOver())
        {
            loadButton.draw(ColorF{ 0.5, 0.6, 0.8 });
        }
        else
        {
            loadButton.draw(ColorF{ 0.3, 0.4, 0.6 });
        }

        loadButton.drawFrame(2, ColorF{ 0.8 });
        font(U"복호화하여 로드").drawAt(20, loadButton.center(), ColorF{ 0.9 });

        if (loadButton.leftClicked())
        {
            auto loaded = EncryptedSave::load(U"encrypted_save.dat");
            if (loaded)
            {
                loadedName = (*loaded)[U"PlayerName"].get<String>();
                loadedLevel = (*loaded)[U"Level"].get<int32>();
                loadedSuccess = true;
                Console << U"암호화된 파일에서 로드됨";
            }
        }

        // 파일 내용 보기 (텍스트 에디터로)
        if (viewFileButton.mouseOver())
        {
            viewFileButton.draw(ColorF{ 0.7, 0.5, 0.3 });
        }
        else
        {
            viewFileButton.draw(ColorF{ 0.5, 0.3, 0.1 });
        }

        viewFileButton.drawFrame(2, ColorF{ 0.8 });
        font(U"파일 열기").drawAt(20, viewFileButton.center(), ColorF{ 0.9 });

        if (viewFileButton.leftClicked())
        {
            System::LaunchFile(U"encrypted_save.dat");
        }

        // 로드된 데이터 표시
        if (loadedSuccess)
        {
            font(U"로드된 데이터:").draw(18, Vec2{ 100, 450 }, ColorF{ 0.8 });
            font(U"이름: {}"_fmt(loadedName))
                .draw(16, Vec2{ 120, 480 }, ColorF{ 0.7 });
            font(U"레벨: {}"_fmt(loadedLevel))
                .draw(16, Vec2{ 120, 505 }, ColorF{ 0.7 });
        }

        // 안내 메시지
        if (savedEncrypted)
        {
            font(U"암호화된 파일을 열어보세요.")
                .draw(14, Vec2{ 200, 550 }, ColorF{ 0.6 });
            font(U"내용을 직접 읽을 수 없습니다.")
                .draw(14, Vec2{ 200, 570 }, ColorF{ 0.6 });
        }
    }
}
```

이 예제는 XOR 암호화를 사용하여 세이브 파일을 암호화한다. XOR 암호화는 간단하지만 같은 키로 암호화와 복호화를 모두 수행할 수 있는 대칭 암호화 방식이다.

실제 게임에서는 더 강력한 암호화 알고리즘(AES 등)을 사용해야 하지만, 기본 원리는 동일하다. 중요한 점은 암호화 키를 코드에 하드코딩하면 역공학으로 쉽게 찾을 수 있다는 것이다. 더 안전한 방법은 키를 난독화하거나, 서버 측 검증을 함께 사용하는 것이다.

### 23.6.2 데이터 압축

큰 세이브 파일을 압축하여 디스크 공간을 절약하고 로드 시간을 단축할 수 있다.

```cpp
#include <Siv3D.hpp>

class CompressedSave
{
public:
    static bool save(const FilePath& path, const JSON& data)
    {
        // JSON을 문자열로 변환
        String jsonString = data.formatUTF8();
        std::string utf8Str = jsonString.toUTF8();

        // 원본 크기
        size_t originalSize = utf8Str.size();

        // 압축
        Blob compressed = Compression::Compress(utf8Str.data(), utf8Str.size());

        if (compressed.isEmpty())
        {
            return false;
        }

        // 압축된 크기
        size_t compressedSize = compressed.size();

        Console << U"원본 크기: {} 바이트"_fmt(originalSize);
        Console << U"압축된 크기: {} 바이트"_fmt(compressedSize);
        Console << U"압축률: {:.1f}%"_fmt(
            100.0 * compressedSize / originalSize);

        // 파일로 저장
        BinaryWriter writer(path);
        if (not writer)
        {
            return false;
        }

        // 원본 크기를 먼저 저장 (압축 해제 시 필요)
        writer.write(originalSize);
        writer.write(compressed.data(), compressed.size());

        return true;
    }

    static Optional<JSON> load(const FilePath& path)
    {
        BinaryReader reader(path);
        if (not reader)
        {
            return none;
        }

        // 원본 크기 읽기
        size_t originalSize;
        reader.read(originalSize);

        // 압축된 데이터 읽기
        Blob compressed = reader.readAll();

        // 압축 해제
        Blob decompressed = Compression::Decompress(
            compressed.data(), compressed.size(), originalSize);

        if (decompressed.isEmpty())
        {
            return none;
        }

        // JSON 파싱
        std::string utf8Str(
            reinterpret_cast<const char*>(decompressed.data()),
            decompressed.size());

        JSON json = JSON::Parse(Unicode::FromUTF8(utf8Str));

        if (json)
        {
            return json;
        }

        return none;
    }
};

void Main()
{
    Window::Resize(800, 600);
    Scene::SetBackground(ColorF{ 0.1, 0.15, 0.2 });

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // 큰 게임 데이터 생성
    JSON gameData;
    gameData[U"PlayerName"] = U"Hero";
    gameData[U"Level"] = 100;

    // 많은 데이터 추가 (압축 효과를 보기 위해)
    gameData[U"Inventory"] = JSON::Array();
    for (int32 i = 0; i < 100; ++i)
    {
        JSON item;
        item[U"ID"] = i;
        item[U"Name"] = U"Item_{}"_fmt(i);
        item[U"Type"] = U"Equipment";
        item[U"Level"] = Random(1, 50);
        item[U"Stats"] = JSON::Object();
        item[U"Stats"][U"Attack"] = Random(10, 100);
        item[U"Stats"][U"Defense"] = Random(5, 50);
        gameData[U"Inventory"].push_back(item);
    }

    const Rect saveNormalButton{ 200, 200, 180, 60 };
    const Rect saveCompressedButton{ 400, 200, 200, 60 };
    const Rect loadButton{ 300, 280, 200, 60 };

    bool normalSaved = false;
    bool compressedSaved = false;
    int64 normalSize = 0;
    int64 compressedSize = 0;

    while (System::Update())
    {
        font(U"데이터 압축").draw(24, Vec2{ 300, 50 }, ColorF{ 0.9 });

        // 일반 저장
        if (saveNormalButton.mouseOver())
        {
            saveNormalButton.draw(ColorF{ 0.5, 0.6, 0.7 });
        }
        else
        {
            saveNormalButton.draw(ColorF{ 0.3, 0.4, 0.5 });
        }

        saveNormalButton.drawFrame(2, ColorF{ 0.8 });
        font(U"일반 저장").drawAt(18, saveNormalButton.center(), ColorF{ 0.9 });

        if (saveNormalButton.leftClicked())
        {
            if (gameData.save(U"normal_save.json"))
            {
                normalSaved = true;
                normalSize = FileSystem::FileSize(U"normal_save.json");
                Console << U"일반 저장 완료";
            }
        }

        // 압축 저장
        if (saveCompressedButton.mouseOver())
        {
            saveCompressedButton.draw(ColorF{ 0.5, 0.7, 0.5 });
        }
        else
        {
            saveCompressedButton.draw(ColorF{ 0.3, 0.5, 0.3 });
        }

        saveCompressedButton.drawFrame(2, ColorF{ 0.8 });
        font(U"압축 저장").drawAt(18, saveCompressedButton.center(), 
                                  ColorF{ 0.9 });

        if (saveCompressedButton.leftClicked())
        {
            if (CompressedSave::save(U"compressed_save.dat", gameData))
            {
                compressedSaved = true;
                compressedSize = FileSystem::FileSize(U"compressed_save.dat");
                Console << U"압축 저장 완료";
            }
        }

        // 압축 파일 로드
        if (loadButton.mouseOver())
        {
            loadButton.draw(ColorF{ 0.5, 0.6, 0.8 });
        }
        else
        {
            loadButton.draw(ColorF{ 0.3, 0.4, 0.6 });
        }

        loadButton.drawFrame(2, ColorF{ 0.8 });
        font(U"압축 파일 로드").drawAt(18, loadButton.center(), ColorF{ 0.9 });

        if (loadButton.leftClicked())
        {
            auto loaded = CompressedSave::load(U"compressed_save.dat");
            if (loaded)
            {
                Console << U"압축 파일 로드 성공";
                Console << U"아이템 개수: {}"_fmt(
                    (*loaded)[U"Inventory"].size());
            }
        }

        // 파일 크기 비교
        if (normalSaved && compressedSaved)
        {
            int32 y = 380;
            font(U"파일 크기 비교:").draw(20, Vec2{ 200, y }, ColorF{ 0.8 });

            y += 40;
            font(U"일반: {} 바이트"_fmt(normalSize))
                .draw(18, Vec2{ 220, y }, ColorF{ 0.7 });

            y += 35;
            font(U"압축: {} 바이트"_fmt(compressedSize))
                .draw(18, Vec2{ 220, y }, ColorF{ 0.7 });

            y += 35;
            double ratio = 100.0 * compressedSize / normalSize;
            font(U"압축률: {:.1f}%"_fmt(ratio))
                .draw(18, Vec2{ 220, y }, ColorF{ 0.3, 0.9, 0.3 });

            y += 35;
            int64 saved = normalSize - compressedSize;
            font(U"절약: {} 바이트"_fmt(saved))
                .draw(18, Vec2{ 220, y }, ColorF{ 0.7 });
        }
    }
}
```

`Compression::Compress()`는 데이터를 압축하고, `Compression::Decompress()`는 압축을 해제한다. JSON 데이터는 텍스트 형식이라 압축률이 매우 높다. 특히 반복되는 패턴이 많은 데이터는 압축 효과가 크다.

압축을 사용하면 파일 크기를 크게 줄일 수 있지만, 압축과 압축 해제에 CPU 시간이 필요하다. 작은 파일은 압축 오버헤드가 이득보다 클 수 있으므로, 일정 크기 이상의 파일만 압축하는 것이 좋다.

### 23.6.3 클라우드 저장소 연동

최신 게임은 클라우드에 세이브 데이터를 저장하여 여러 기기에서 동기화한다. Siv3D는 직접적인 클라우드 API를 제공하지 않지만, HTTP 요청으로 서버와 통신할 수 있다.

```cpp
#include <Siv3D.hpp>

class CloudSaveSystem
{
private:
    String serverURL;
    String userID;

public:
    CloudSaveSystem(const String& url, const String& user)
        : serverURL(url), userID(user)
    {}

    // 클라우드에 저장 (시뮬레이션)
    bool upload(const JSON& data)
    {
        // 실제로는 HTTP POST 요청을 보낸다
        // 여기서는 로컬 파일로 시뮬레이션
        FilePath cloudPath = U"cloud_{}.json"_fmt(userID);

        Console << U"클라우드 업로드 시작...";
        Console << U"사용자: {}"_fmt(userID);
        Console << U"서버: {}"_fmt(serverURL);

        // 타임스탬프 추가
        JSON uploadData = data;
        uploadData[U"UploadTime"] = Format(DateTime::Now());
        uploadData[U"UserID"] = userID;

        if (uploadData.save(cloudPath))
        {
            Console << U"클라우드 업로드 성공";
            return true;
        }

        return false;
    }

    // 클라우드에서 다운로드 (시뮬레이션)
    Optional<JSON> download()
    {
        FilePath cloudPath = U"cloud_{}.json"_fmt(userID);

        Console << U"클라우드 다운로드 시작...";

        if (not FileSystem::Exists(cloudPath))
        {
            Console << U"클라우드에 데이터가 없다.";
            return none;
        }

        JSON data = JSON::Load(cloudPath);
        if (data)
        {
            Console << U"클라우드 다운로드 성공";
            return data;
        }

        return none;
    }

    // 로컬과 클라우드 동기화
    bool sync(JSON& localData)
    {
        auto cloudData = download();

        if (not cloudData)
        {
            // 클라우드에 데이터가 없으면 로컬 데이터를 업로드
            Console << U"클라우드 데이터가 없어 로컬 데이터를 업로드한다.";
            return upload(localData);
        }

        // 타임스탬프 비교
        String localTime = localData[U"SaveTime"].getString();
        String cloudTime = (*cloudData)[U"UploadTime"].getString();

        Console << U"로컬 저장 시간: {}"_fmt(localTime);
        Console << U"클라우드 업로드 시간: {}"_fmt(cloudTime);

        // 여기서는 단순 비교, 실제로는 DateTime 파싱 필요
        if (cloudTime > localTime)
        {
            Console << U"클라우드 데이터가 더 최신이다.";
            localData = *cloudData;
            return true;
        }
        else
        {
            Console << U"로컬 데이터가 더 최신이다.";
            return upload(localData);
        }
    }
};

void Main()
{
    Window::Resize(800, 600);
    Scene::SetBackground(ColorF{ 0.12, 0.15, 0.2 });

    CloudSaveSystem cloudSave(U"https://example.com/api", U"player123");

    const Font font{ FontMethod::MSDF, 48, Typeface::Bold };

    // 로컬 게임 데이터
    JSON localData;
    localData[U"PlayerName"] = U"CloudGamer";
    localData[U"Level"] = 35;
    localData[U"Score"] = 98765;
    localData[U"SaveTime"] = Format(DateTime::Now());

    const Rect uploadButton{ 250, 200, 300, 60 };
    const Rect downloadButton{ 250, 280, 300, 60 };
    const Rect syncButton{ 250, 360, 300, 60 };

    Optional<JSON> downloadedData;

    while (System::Update())
    {
        font(U"클라우드 저장소").draw(24, Vec2{ 260, 50 }, ColorF{ 0.9 });

        // 로컬 데이터 표시
        font(U"로컬 데이터:").draw(18, Vec2{ 100, 120 }, ColorF{ 0.8 });
        font(U"이름: {}"_fmt(localData[U"PlayerName"].get<String>()))
            .draw(16, Vec2{ 120, 150 }, ColorF{ 0.7 });
        font(U"레벨: {}"_fmt(localData[U"Level"].get<int32>()))
            .draw(16, Vec2{ 120, 175 }, ColorF{ 0.7 });

        // 업로드 버튼
        if (uploadButton.mouseOver())
        {
            uploadButton.draw(ColorF{ 0.5, 0.7, 0.9 });
        }
        else
        {
            uploadButton.draw(ColorF{ 0.3, 0.5, 0.7 });
        }

        uploadButton.drawFrame(2, ColorF{ 0.8 });
        font(U"클라우드에 업로드").drawAt(20, uploadButton.center(), 
                                          ColorF{ 0.9 });

        if (uploadButton.leftClicked())
        {
            // 레벨 증가 (변경 사항 시뮬레이션)
            localData[U"Level"] = localData[U"Level"].get<int32>() + 1;
            localData[U"SaveTime"] = Format(DateTime::Now());

            cloudSave.upload(localData);
        }

        // 다운로드 버튼
        if (downloadButton.mouseOver())
        {
            downloadButton.draw(ColorF{ 0.7, 0.9, 0.5 });
        }
        else
        {
            downloadButton.draw(ColorF{ 0.5, 0.7, 0.3 });
        }

        downloadButton.drawFrame(2, ColorF{ 0.8 });
        font(U"클라우드에서 다운로드").drawAt(20, downloadButton.center(),
                                              ColorF{ 0.9 });

        if (downloadButton.leftClicked())
        {
            downloadedData = cloudSave.download();
        }

        // 동기화 버튼
        if (syncButton.mouseOver())
        {
            syncButton.draw(ColorF{ 0.9, 0.7, 0.5 });
        }
        else
        {
            syncButton.draw(ColorF{ 0.7, 0.5, 0.3 });
        }

        syncButton.drawFrame(2, ColorF{ 0.8 });
        font(U"동기화").drawAt(20, syncButton.center(), ColorF{ 0.9 });

        if (syncButton.leftClicked())
        {
            cloudSave.sync(localData);
        }

        // 다운로드된 데이터 표시
        if (downloadedData)
        {
            font(U"클라우드 데이터:").draw(18, Vec2{ 100, 460 }, ColorF{ 0.8 });
            font(U"이름: {}"_fmt((*downloadedData)[U"PlayerName"].get<String>()))
                .draw(16, Vec2{ 120, 490 }, ColorF{ 0.7 });
            font(U"레벨: {}"_fmt((*downloadedData)[U"Level"].get<int32>()))
                .draw(16, Vec2{ 120, 515 }, ColorF{ 0.7 });
        }
    }
}
```

이 예제는 클라우드 저장소 연동을 시뮬레이션한다. 실제 구현에서는 HTTP 라이브러리를 사용하여 REST API와 통신하거나, 게임 플랫폼(Steam, Epic Games 등)의 클라우드 저장 API를 사용한다.

동기화는 로컬과 클라우드의 데이터를 비교하여 최신 버전을 유지한다. 타임스탬프를 비교하는 것이 가장 간단한 방법이지만, 충돌 해결 전략을 고려해야 한다. 두 데이터가 모두 변경되었을 때 어떻게 처리할지 정책을 정해야 한다.

## 23.7 정리

이번 장에서는 파일 시스템과 데이터 관리에 대해 배웠다. C++17의 `std::filesystem`을 사용하여 파일과 디렉토리를 안전하게 다루는 방법, 설정 파일을 읽고 쓰는 방법, JSON으로 복잡한 데이터를 저장하는 방법, 그리고 실용적인 세이브/로드 시스템 구현까지 다루었다.

핵심 내용을 정리하면 다음과 같다. `std::filesystem`으로 파일과 디렉토리를 플랫폼 독립적으로 다룬다. 키-값 형식의 설정 파일로 간단한 설정을 관리하고, JSON으로 계층적이고 복잡한 데이터를 구조화하여 저장한다. 다중 슬롯 세이브 시스템으로 사용자에게 유연성을 제공하며, 자동 저장 시스템으로 사용자의 진행 상황을 보호한다. 암호화와 압축으로 세이브 파일을 보호하고 최적화하며, 클라우드 저장소 연동으로 여러 기기 간 데이터를 동기화한다.

데이터 관리는 게임 개발에서 빠질 수 없는 부분이다. 사용자의 진행 상황을 안전하게 보존하고, 설정을 유지하며, 게임 콘텐츠를 효율적으로 로드하는 것은 좋은 사용자 경험의 기본이다. 다음 장부터는 지금까지 배운 모든 기술을 활용하여 실전 프로젝트를 만들어본다.



