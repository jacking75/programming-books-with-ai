# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 26: 프로젝트 3 - 데이터 시각화 도구

이번 장에서는 실시간으로 데이터를 처리하고 시각화하는 도구를 만들어본다. 데이터 시각화는 복잡한 정보를 이해하기 쉬운 그래픽 형태로 변환하는 중요한 기술이다. 이 프로젝트를 통해 멀티스레딩, 실시간 데이터 처리, 그래프 렌더링 등 실무에서 자주 사용되는 기술들을 배울 수 있다.

## 26.1 프로젝트 개요

### 26.1.1 무엇을 만들 것인가

우리가 만들 데이터 시각화 도구는 다음과 같은 기능을 제공한다:

- **실시간 데이터 모니터링**: CPU 사용률, 메모리 사용량 등 시스템 정보를 실시간으로 수집한다
- **다양한 차트 타입**: 선 그래프, 막대 그래프, 원 그래프 등 여러 시각화 방식을 지원한다
- **데이터 저장 및 불러오기**: CSV 파일로 데이터를 내보내고 가져올 수 있다
- **인터랙티브 UI**: 마우스로 데이터 포인트를 확인하고 확대/축소할 수 있다

### 26.1.2 프로젝트 구조 설계

프로젝트를 시작하기 전에 전체 구조를 설계한다. 객체지향 원칙에 따라 각 기능을 담당하는 클래스를 분리한다.

```cpp
// DataVisualizer.h
#pragma once
#include <Siv3D.hpp>
#include <vector>
#include <memory>
#include <thread>
#include <mutex>
#include <atomic>

// 데이터 포인트 구조체
struct DataPoint {
    double timestamp;  // 시간 (초 단위)
    double value;      // 값
    
    DataPoint(double t, double v) : timestamp(t), value(v) {}
};

// 데이터 시리즈 클래스
class DataSeries {
private:
    String name_;
    std::vector<DataPoint> data_;
    ColorF color_;
    size_t maxDataPoints_;
    mutable std::mutex dataMutex_;  // 스레드 안전성을 위한 뮤텍스
    
public:
    DataSeries(const String& name, const ColorF& color, size_t maxPoints = 1000);
    
    void addDataPoint(double timestamp, double value);
    void clear();
    
    const String& getName() const { return name_; }
    const ColorF& getColor() const { return color_; }
    std::vector<DataPoint> getDataCopy() const;
    
    DataPoint getLatest() const;
    size_t getSize() const;
};

// 차트 렌더러 기본 클래스
class ChartRenderer {
protected:
    RectF bounds_;
    String title_;
    
public:
    ChartRenderer(const RectF& bounds, const String& title)
        : bounds_(bounds), title_(title) {}
    
    virtual ~ChartRenderer() = default;
    virtual void render(const std::vector<std::shared_ptr<DataSeries>>& series) = 0;
    
    void setBounds(const RectF& bounds) { bounds_ = bounds; }
    const RectF& getBounds() const { return bounds_; }
};

// 선 그래프 렌더러
class LineChartRenderer : public ChartRenderer {
private:
    double minValue_;
    double maxValue_;
    double timeWindow_;  // 표시할 시간 범위 (초)
    
    void calculateBounds(const std::vector<std::shared_ptr<DataSeries>>& series);
    Vec2 dataToScreen(double timestamp, double value, double minTime, double maxTime) const;
    
public:
    LineChartRenderer(const RectF& bounds, const String& title, double timeWindow = 60.0);
    
    void render(const std::vector<std::shared_ptr<DataSeries>>& series) override;
    void setTimeWindow(double seconds) { timeWindow_ = seconds; }
};

// 막대 그래프 렌더러
class BarChartRenderer : public ChartRenderer {
private:
    bool showValues_;
    
public:
    BarChartRenderer(const RectF& bounds, const String& title, bool showValues = true);
    
    void render(const std::vector<std::shared_ptr<DataSeries>>& series) override;
};

// 원 그래프 렌더러
class PieChartRenderer : public ChartRenderer {
private:
    Vec2 center_;
    double radius_;
    
public:
    PieChartRenderer(const RectF& bounds, const String& title);
    
    void render(const std::vector<std::shared_ptr<DataSeries>>& series) override;
};
```

## 26.2 데이터 시리즈 구현

### 26.2.1 스레드 안전한 데이터 관리

데이터 시각화 도구에서는 여러 스레드가 동시에 데이터를 읽고 쓸 수 있다. 이를 안전하게 처리하기 위해 뮤텍스를 사용한다.

```cpp
// DataVisualizer.cpp
#include "DataVisualizer.h"

DataSeries::DataSeries(const String& name, const ColorF& color, size_t maxPoints)
    : name_(name), color_(color), maxDataPoints_(maxPoints) {
    data_.reserve(maxPoints);
}

void DataSeries::addDataPoint(double timestamp, double value) {
    std::lock_guard<std::mutex> lock(dataMutex_);
    
    data_.emplace_back(timestamp, value);
    
    // 최대 개수를 초과하면 오래된 데이터 삭제
    if (data_.size() > maxDataPoints_) {
        data_.erase(data_.begin());
    }
}

void DataSeries::clear() {
    std::lock_guard<std::mutex> lock(dataMutex_);
    data_.clear();
}

std::vector<DataPoint> DataSeries::getDataCopy() const {
    std::lock_guard<std::mutex> lock(dataMutex_);
    return data_;  // 복사본 반환
}

DataPoint DataSeries::getLatest() const {
    std::lock_guard<std::mutex> lock(dataMutex_);
    if (data_.empty()) {
        return DataPoint(0.0, 0.0);
    }
    return data_.back();
}

size_t DataSeries::getSize() const {
    std::lock_guard<std::mutex> lock(dataMutex_);
    return data_.size();
}
```

**핵심 개념: 뮤텍스와 lock_guard**

`std::mutex`는 여러 스레드가 동시에 같은 데이터에 접근하는 것을 방지한다. `std::lock_guard`는 RAII 패턴을 사용하여 함수가 끝날 때 자동으로 뮤텍스를 해제한다. 이는 예외가 발생해도 안전하다.

### 26.2.2 실습: 기본 데이터 시리즈 테스트

```cpp
// Main.cpp
#include <Siv3D.hpp>
#include "DataVisualizer.h"

void Main() {
    Window::Resize(1280, 720);
    Scene::SetBackground(ColorF(0.95));
    
    // 데이터 시리즈 생성
    auto cpuSeries = std::make_shared<DataSeries>(U"CPU Usage", ColorF(0.2, 0.6, 1.0));
    auto memorySeries = std::make_shared<DataSeries>(U"Memory Usage", ColorF(1.0, 0.4, 0.4));
    
    Stopwatch stopwatch(StartImmediately::Yes);
    
    while (System::Update()) {
        double time = stopwatch.sF();
        
        // 임의의 데이터 추가 (실제로는 시스템 정보를 수집)
        double cpuValue = 50.0 + 30.0 * Sin(time * 2.0);
        double memoryValue = 60.0 + 20.0 * Cos(time * 1.5);
        
        cpuSeries->addDataPoint(time, cpuValue);
        memorySeries->addDataPoint(time, memoryValue);
        
        // 최신 값 표시
        auto cpuLatest = cpuSeries->getLatest();
        auto memoryLatest = memorySeries->getLatest();
        
        Font font(30);
        font(U"CPU: {:.1f}%"_fmt(cpuLatest.value))
            .draw(20, 20, cpuSeries->getColor());
        font(U"Memory: {:.1f}%"_fmt(memoryLatest.value))
            .draw(20, 60, memorySeries->getColor());
        
        font(U"Data Points: {}"_fmt(cpuSeries->getSize()))
            .draw(20, 100, ColorF(0.3));
    }
}
```

## 26.3 선 그래프 구현

### 26.3.1 화면 좌표 변환

데이터 값을 화면 좌표로 변환하는 것이 차트 렌더링의 핵심이다.

```cpp
LineChartRenderer::LineChartRenderer(const RectF& bounds, const String& title, double timeWindow)
    : ChartRenderer(bounds, title)
    , minValue_(0.0)
    , maxValue_(100.0)
    , timeWindow_(timeWindow) {
}

void LineChartRenderer::calculateBounds(const std::vector<std::shared_ptr<DataSeries>>& series) {
    if (series.empty()) return;
    
    minValue_ = std::numeric_limits<double>::max();
    maxValue_ = std::numeric_limits<double>::lowest();
    
    for (const auto& s : series) {
        auto data = s->getDataCopy();
        for (const auto& point : data) {
            minValue_ = Min(minValue_, point.value);
            maxValue_ = Max(maxValue_, point.value);
        }
    }
    
    // 여유 공간 추가 (10%)
    double range = maxValue_ - minValue_;
    minValue_ -= range * 0.1;
    maxValue_ += range * 0.1;
    
    // 최소 범위 보장
    if (maxValue_ - minValue_ < 1.0) {
        minValue_ -= 0.5;
        maxValue_ += 0.5;
    }
}

Vec2 LineChartRenderer::dataToScreen(double timestamp, double value, 
                                     double minTime, double maxTime) const {
    // 차트 영역 (여백 제외)
    const double padding = 60.0;
    RectF chartArea = bounds_.stretched(-padding);
    
    // X 좌표: 시간을 화면 X 위치로 변환
    double normalizedX = (timestamp - minTime) / (maxTime - minTime);
    double screenX = chartArea.x + normalizedX * chartArea.w;
    
    // Y 좌표: 값을 화면 Y 위치로 변환 (Y축은 아래가 큰 값)
    double normalizedY = (value - minValue_) / (maxValue_ - minValue_);
    double screenY = chartArea.y + chartArea.h - normalizedY * chartArea.h;
    
    return Vec2(screenX, screenY);
}

void LineChartRenderer::render(const std::vector<std::shared_ptr<DataSeries>>& series) {
    if (series.empty()) return;
    
    // 배경
    bounds_.draw(ColorF(1.0));
    bounds_.drawFrame(2.0, ColorF(0.7));
    
    // 제목
    Font titleFont(24, Typeface::Bold);
    titleFont(title_).drawAt(bounds_.center().x, bounds_.y + 30, ColorF(0.2));
    
    // 범위 계산
    calculateBounds(series);
    
    // 시간 범위 계산
    double currentTime = Scene::Time();
    double minTime = currentTime - timeWindow_;
    double maxTime = currentTime;
    
    // 차트 영역
    const double padding = 60.0;
    RectF chartArea = bounds_.stretched(-padding);
    
    // 그리드 그리기
    const int gridLines = 5;
    for (int i = 0; i <= gridLines; ++i) {
        double y = chartArea.y + (chartArea.h * i / gridLines);
        Line(chartArea.x, y, chartArea.x + chartArea.w, y)
            .draw(1.0, ColorF(0.9));
        
        // Y축 레이블
        double value = maxValue_ - (maxValue_ - minValue_) * i / gridLines;
        Font labelFont(16);
        labelFont(U"{:.1f}"_fmt(value))
            .draw(Arg::rightCenter(chartArea.x - 10, y), ColorF(0.4));
    }
    
    // X축 시간 레이블
    Font timeFont(16);
    for (int i = 0; i <= 4; ++i) {
        double x = chartArea.x + (chartArea.w * i / 4);
        double time = minTime + (maxTime - minTime) * i / 4;
        timeFont(U"{:.0f}s"_fmt(time))
            .draw(Arg::topCenter(x, chartArea.y + chartArea.h + 10), ColorF(0.4));
    }
    
    // 데이터 시리즈 그리기
    for (const auto& s : series) {
        auto data = s->getDataCopy();
        if (data.size() < 2) continue;
        
        // 현재 시간 윈도우 내의 데이터만 표시
        std::vector<Vec2> points;
        for (const auto& point : data) {
            if (point.timestamp >= minTime && point.timestamp <= maxTime) {
                points.push_back(dataToScreen(point.timestamp, point.value, 
                                             minTime, maxTime));
            }
        }
        
        // 선 그리기
        for (size_t i = 1; i < points.size(); ++i) {
            Line(points[i - 1], points[i]).draw(3.0, s->getColor());
        }
        
        // 데이터 포인트 표시
        for (const auto& point : points) {
            Circle(point, 4).draw(s->getColor());
        }
    }
    
    // 범례
    double legendY = bounds_.y + 60;
    for (const auto& s : series) {
        Circle(bounds_.x + padding + 10, legendY, 6).draw(s->getColor());
        Font legendFont(18);
        legendFont(s->getName()).draw(bounds_.x + padding + 25, legendY - 10, ColorF(0.3));
        
        auto latest = s->getLatest();
        legendFont(U": {:.1f}"_fmt(latest.value))
            .draw(bounds_.x + padding + 25 + legendFont(s->getName()).region().w, 
                  legendY - 10, s->getColor());
        
        legendY += 30;
    }
}
```

### 26.3.2 실습: 선 그래프 테스트

```cpp
void Main() {
    Window::Resize(1280, 720);
    Scene::SetBackground(ColorF(0.95));
    
    // 데이터 시리즈
    auto cpuSeries = std::make_shared<DataSeries>(U"CPU", ColorF(0.2, 0.6, 1.0));
    auto memorySeries = std::make_shared<DataSeries>(U"Memory", ColorF(1.0, 0.4, 0.4));
    auto diskSeries = std::make_shared<DataSeries>(U"Disk", ColorF(0.4, 0.8, 0.4));
    
    std::vector<std::shared_ptr<DataSeries>> series = {
        cpuSeries, memorySeries, diskSeries
    };
    
    // 차트 렌더러
    LineChartRenderer lineChart(
        RectF(50, 50, 1180, 500),
        U"System Resource Monitor",
        30.0  // 30초 윈도우
    );
    
    Stopwatch stopwatch(StartImmediately::Yes);
    
    while (System::Update()) {
        double time = stopwatch.sF();
        
        // 시뮬레이션 데이터 생성
        double cpu = 50.0 + 30.0 * Sin(time * 2.0) + Random(-5.0, 5.0);
        double memory = 60.0 + 20.0 * Cos(time * 1.5) + Random(-3.0, 3.0);
        double disk = 40.0 + 15.0 * Sin(time * 0.8) + Random(-2.0, 2.0);
        
        cpuSeries->addDataPoint(time, cpu);
        memorySeries->addDataPoint(time, memory);
        diskSeries->addDataPoint(time, disk);
        
        // 차트 렌더링
        lineChart.render(series);
        
        // 컨트롤 패널
        Font font(20);
        font(U"Press [Space] to clear data").draw(50, 580, ColorF(0.4));
        
        if (KeySpace.down()) {
            for (auto& s : series) {
                s->clear();
            }
        }
    }
}
```

## 26.4 막대 그래프와 원 그래프

### 26.4.1 막대 그래프 구현

막대 그래프는 카테고리별 비교에 유용하다.

```cpp
BarChartRenderer::BarChartRenderer(const RectF& bounds, const String& title, bool showValues)
    : ChartRenderer(bounds, title), showValues_(showValues) {
}

void BarChartRenderer::render(const std::vector<std::shared_ptr<DataSeries>>& series) {
    if (series.empty()) return;
    
    // 배경
    bounds_.draw(ColorF(1.0));
    bounds_.drawFrame(2.0, ColorF(0.7));
    
    // 제목
    Font titleFont(24, Typeface::Bold);
    titleFont(title_).drawAt(bounds_.center().x, bounds_.y + 30, ColorF(0.2));
    
    const double padding = 60.0;
    RectF chartArea = bounds_.stretched(-padding);
    
    // 최대값 찾기
    double maxValue = 0.0;
    for (const auto& s : series) {
        auto latest = s->getLatest();
        maxValue = Max(maxValue, latest.value);
    }
    maxValue *= 1.1;  // 10% 여유
    
    // 막대 그리기
    double barWidth = chartArea.w / (series.size() * 1.5);
    double spacing = barWidth * 0.5;
    double currentX = chartArea.x + spacing;
    
    Font valueFont(18);
    Font labelFont(16);
    
    for (const auto& s : series) {
        auto latest = s->getLatest();
        double barHeight = (latest.value / maxValue) * chartArea.h;
        
        RectF bar(currentX, chartArea.y + chartArea.h - barHeight, barWidth, barHeight);
        
        // 막대 그리기 (그라디언트 효과)
        for (int i = 0; i < barHeight; i += 2) {
            double alpha = 0.7 + 0.3 * (1.0 - i / barHeight);
            RectF segment(currentX, bar.y + i, barWidth, 2);
            segment.draw(ColorF(s->getColor(), alpha));
        }
        
        bar.drawFrame(2.0, s->getColor());
        
        // 값 표시
        if (showValues_) {
            valueFont(U"{:.1f}"_fmt(latest.value))
                .drawAt(bar.center().x, bar.y - 20, ColorF(0.2));
        }
        
        // 레이블
        labelFont(s->getName())
            .drawAt(bar.center().x, chartArea.y + chartArea.h + 25, ColorF(0.4));
        
        currentX += barWidth + spacing;
    }
    
    // Y축 눈금
    const int gridLines = 5;
    for (int i = 0; i <= gridLines; ++i) {
        double y = chartArea.y + (chartArea.h * i / gridLines);
        Line(chartArea.x, y, chartArea.x + chartArea.w, y)
            .draw(1.0, ColorF(0.9));
        
        double value = maxValue * (1.0 - static_cast<double>(i) / gridLines);
        Font gridFont(14);
        gridFont(U"{:.0f}"_fmt(value))
            .draw(Arg::rightCenter(chartArea.x - 10, y), ColorF(0.4));
    }
}
```

### 26.4.2 원 그래프 구현

```cpp
PieChartRenderer::PieChartRenderer(const RectF& bounds, const String& title)
    : ChartRenderer(bounds, title) {
    center_ = bounds.center();
    radius_ = Min(bounds.w, bounds.h) * 0.35;
}

void PieChartRenderer::render(const std::vector<std::shared_ptr<DataSeries>>& series) {
    if (series.empty()) return;
    
    // 배경
    bounds_.draw(ColorF(1.0));
    bounds_.drawFrame(2.0, ColorF(0.7));
    
    // 제목
    Font titleFont(24, Typeface::Bold);
    titleFont(title_).drawAt(bounds_.center().x, bounds_.y + 30, ColorF(0.2));
    
    // 전체 합계 계산
    double total = 0.0;
    for (const auto& s : series) {
        total += s->getLatest().value;
    }
    
    if (total <= 0.0) return;
    
    // 원 그래프 그리기
    double currentAngle = -90_deg;  // 12시 방향부터 시작
    
    Font labelFont(18);
    
    for (const auto& s : series) {
        double value = s->getLatest().value;
        double percentage = value / total;
        double arcAngle = 360_deg * percentage;
        
        // 부채꼴 그리기
        Circle(center_, radius_)
            .drawPie(currentAngle, arcAngle, s->getColor());
        
        // 테두리
        Circle(center_, radius_)
            .drawArc(currentAngle, arcAngle, 0, 2.0, ColorF(1.0));
        
        // 레이블 위치 계산
        double labelAngle = currentAngle + arcAngle / 2.0;
        Vec2 labelPos = center_ + Circular(radius_ * 0.7, labelAngle);
        
        // 퍼센트 표시
        String percentText = U"{:.1f}%"_fmt(percentage * 100.0);
        labelFont(percentText).drawAt(labelPos, ColorF(1.0));
        
        currentAngle += arcAngle;
    }
    
    // 중앙 원 (도넛 차트 효과)
    Circle(center_, radius_ * 0.4).draw(ColorF(1.0));
    
    // 범례
    double legendX = bounds_.x + bounds_.w - 200;
    double legendY = bounds_.y + 80;
    
    Font legendFont(16);
    for (const auto& s : series) {
        Circle(legendX, legendY, 8).draw(s->getColor());
        
        double value = s->getLatest().value;
        double percentage = (value / total) * 100.0;
        
        String legendText = U"{}: {:.1f} ({:.1f}%)"_fmt(
            s->getName(), value, percentage);
        
        legendFont(legendText).draw(legendX + 20, legendY - 8, ColorF(0.3));
        legendY += 30;
    }
}
```

### 26.4.3 실습: 여러 차트 타입 전환

```cpp
enum class ChartType {
    Line,
    Bar,
    Pie
};

void Main() {
    Window::Resize(1280, 720);
    Scene::SetBackground(ColorF(0.95));
    
    auto cpuSeries = std::make_shared<DataSeries>(U"CPU", ColorF(0.2, 0.6, 1.0));
    auto memorySeries = std::make_shared<DataSeries>(U"Memory", ColorF(1.0, 0.4, 0.4));
    auto diskSeries = std::make_shared<DataSeries>(U"Disk", ColorF(0.4, 0.8, 0.4));
    
    std::vector<std::shared_ptr<DataSeries>> series = {
        cpuSeries, memorySeries, diskSeries
    };
    
    RectF chartBounds(50, 50, 1180, 550);
    
    auto lineChart = std::make_unique<LineChartRenderer>(
        chartBounds, U"Resource Monitor - Line Chart", 30.0);
    auto barChart = std::make_unique<BarChartRenderer>(
        chartBounds, U"Resource Monitor - Bar Chart");
    auto pieChart = std::make_unique<PieChartRenderer>(
        chartBounds, U"Resource Monitor - Pie Chart");
    
    ChartType currentChart = ChartType::Line;
    Stopwatch stopwatch(StartImmediately::Yes);
    
    while (System::Update()) {
        double time = stopwatch.sF();
        
        // 데이터 업데이트
        cpuSeries->addDataPoint(time, 50.0 + 30.0 * Sin(time * 2.0) + Random(-5.0, 5.0));
        memorySeries->addDataPoint(time, 60.0 + 20.0 * Cos(time * 1.5) + Random(-3.0, 3.0));
        diskSeries->addDataPoint(time, 40.0 + 15.0 * Sin(time * 0.8) + Random(-2.0, 2.0));
        
        // 차트 렌더링
        switch (currentChart) {
            case ChartType::Line:
                lineChart->render(series);
                break;
            case ChartType::Bar:
                barChart->render(series);
                break;
            case ChartType::Pie:
                pieChart->render(series);
                break;
        }
        
        // 컨트롤 UI
        Font font(20);
        double buttonY = 630;
        
        if (SimpleGUI::Button(U"Line Chart", Vec2(50, buttonY), 150, 
                             currentChart == ChartType::Line)) {
            currentChart = ChartType::Line;
        }
        
        if (SimpleGUI::Button(U"Bar Chart", Vec2(220, buttonY), 150, 
                             currentChart == ChartType::Bar)) {
            currentChart = ChartType::Bar;
        }
        
        if (SimpleGUI::Button(U"Pie Chart", Vec2(390, buttonY), 150, 
                             currentChart == ChartType::Pie)) {
            currentChart = ChartType::Pie;
        }
        
        if (SimpleGUI::Button(U"Clear Data", Vec2(560, buttonY), 150)) {
            for (auto& s : series) {
                s->clear();
            }
        }
    }
}
```

## 26.5 실시간 시스템 모니터링

### 26.5.1 시스템 정보 수집

Windows에서 실제 시스템 정보를 수집하는 방법을 구현한다.

```cpp
// SystemMonitor.h
#pragma once
#include <Siv3D.hpp>
#include <thread>
#include <atomic>
#include <memory>

#ifdef SIV3D_PLATFORM_WINDOWS
#include <Windows.h>
#include <Psapi.h>
#pragma comment(lib, "psapi.lib")
#endif

class SystemMonitor {
private:
    std::atomic<double> cpuUsage_;
    std::atomic<double> memoryUsage_;
    std::atomic<double> diskUsage_;
    std::atomic<bool> running_;
    std::unique_ptr<std::thread> monitorThread_;
    
    void monitorLoop();
    double getCPUUsage();
    double getMemoryUsage();
    double getDiskUsage();
    
public:
    SystemMonitor();
    ~SystemMonitor();
    
    void start();
    void stop();
    
    double getCPU() const { return cpuUsage_.load(); }
    double getMemory() const { return memoryUsage_.load(); }
    double getDisk() const { return diskUsage_.load(); }
};
```

```cpp
// SystemMonitor.cpp
#include "SystemMonitor.h"

SystemMonitor::SystemMonitor()
    : cpuUsage_(0.0)
    , memoryUsage_(0.0)
    , diskUsage_(0.0)
    , running_(false) {
}

SystemMonitor::~SystemMonitor() {
    stop();
}

void SystemMonitor::start() {
    if (running_.load()) return;
    
    running_ = true;
    monitorThread_ = std::make_unique<std::thread>(&SystemMonitor::monitorLoop, this);
}

void SystemMonitor::stop() {
    if (!running_.load()) return;
    
    running_ = false;
    if (monitorThread_ && monitorThread_->joinable()) {
        monitorThread_->join();
    }
}

void SystemMonitor::monitorLoop() {
    while (running_.load()) {
        cpuUsage_ = getCPUUsage();
        memoryUsage_ = getMemoryUsage();
        diskUsage_ = getDiskUsage();
        
        // 1초마다 업데이트
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

#ifdef SIV3D_PLATFORM_WINDOWS

double SystemMonitor::getCPUUsage() {
    static ULARGE_INTEGER lastCPU, lastSysCPU, lastUserCPU;
    static int numProcessors = 0;
    static HANDLE self = GetCurrentProcess();
    static bool initialized = false;
    
    if (!initialized) {
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo);
        numProcessors = sysInfo.dwNumberOfProcessors;
        
        FILETIME ftime, fsys, fuser;
        GetSystemTimeAsFileTime(&ftime);
        memcpy(&lastCPU, &ftime, sizeof(FILETIME));
        
        GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
        memcpy(&lastSysCPU, &fsys, sizeof(FILETIME));
        memcpy(&lastUserCPU, &fuser, sizeof(FILETIME));
        
        initialized = true;
        return 0.0;
    }
    
    FILETIME ftime, fsys, fuser;
    ULARGE_INTEGER now, sys, user;
    
    GetSystemTimeAsFileTime(&ftime);
    memcpy(&now, &ftime, sizeof(FILETIME));
    
    GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
    memcpy(&sys, &fsys, sizeof(FILETIME));
    memcpy(&user, &fuser, sizeof(FILETIME));
    
    double percent = (sys.QuadPart - lastSysCPU.QuadPart) +
                    (user.QuadPart - lastUserCPU.QuadPart);
    percent /= (now.QuadPart - lastCPU.QuadPart);
    percent /= numProcessors;
    
    lastCPU = now;
    lastUserCPU = user;
    lastSysCPU = sys;
    
    return percent * 100.0;
}

double SystemMonitor::getMemoryUsage() {
    PROCESS_MEMORY_COUNTERS_EX pmc;
    GetProcessMemoryInfo(GetCurrentProcess(), 
                        (PROCESS_MEMORY_COUNTERS*)&pmc, sizeof(pmc));
    
    MEMORYSTATUSEX memInfo;
    memInfo.dwLength = sizeof(MEMORYSTATUSEX);
    GlobalMemoryStatusEx(&memInfo);
    
    return (double)pmc.WorkingSetSize / memInfo.ullTotalPhys * 100.0;
}

double SystemMonitor::getDiskUsage() {
    // 간단한 구현: 현재 드라이브의 사용률
    ULARGE_INTEGER freeBytesAvailable, totalBytes, totalFreeBytes;
    
    if (GetDiskFreeSpaceExW(L"C:\\", &freeBytesAvailable, 
                           &totalBytes, &totalFreeBytes)) {
        double usedBytes = totalBytes.QuadPart - totalFreeBytes.QuadPart;
        return (usedBytes / totalBytes.QuadPart) * 100.0;
    }
    
    return 0.0;
}

#else

// 다른 플랫폼에서는 시뮬레이션 데이터 사용
double SystemMonitor::getCPUUsage() {
    return 50.0 + Random(-10.0, 10.0);
}

double SystemMonitor::getMemoryUsage() {
    return 60.0 + Random(-5.0, 5.0);
}

double SystemMonitor::getDiskUsage() {
    return 40.0 + Random(-3.0, 3.0);
}

#endif
```

### 26.5.2 멀티스레딩 적용

```cpp
void Main() {
    Window::Resize(1280, 720);
    Scene::SetBackground(ColorF(0.95));
    
    // 시스템 모니터 시작
    SystemMonitor monitor;
    monitor.start();
    
    // 데이터 시리즈
    auto cpuSeries = std::make_shared<DataSeries>(U"CPU", ColorF(0.2, 0.6, 1.0));
    auto memorySeries = std::make_shared<DataSeries>(U"Memory", ColorF(1.0, 0.4, 0.4));
    auto diskSeries = std::make_shared<DataSeries>(U"Disk", ColorF(0.4, 0.8, 0.4));
    
    std::vector<std::shared_ptr<DataSeries>> series = {
        cpuSeries, memorySeries, diskSeries
    };
    
    LineChartRenderer lineChart(RectF(50, 50, 1180, 550), 
                               U"Real-time System Monitor", 60.0);
    
    Stopwatch stopwatch(StartImmediately::Yes);
    double lastUpdate = 0.0;
    
    while (System::Update()) {
        double time = stopwatch.sF();
        
        // 1초마다 데이터 업데이트
        if (time - lastUpdate >= 1.0) {
            cpuSeries->addDataPoint(time, monitor.getCPU());
            memorySeries->addDataPoint(time, monitor.getMemory());
            diskSeries->addDataPoint(time, monitor.getDisk());
            lastUpdate = time;
        }
        
        lineChart.render(series);
        
        // 현재 값 표시
        Font font(22);
        double infoY = 620;
        font(U"CPU: {:.1f}% | Memory: {:.1f}% | Disk: {:.1f}%"_fmt(
            monitor.getCPU(), monitor.getMemory(), monitor.getDisk()))
            .draw(50, infoY, ColorF(0.3));
    }
    
    monitor.stop();
}
```

**핵심 개념: std::thread와 std::atomic**

`std::thread`는 별도의 실행 스레드를 생성한다. `std::atomic`은 스레드 간 안전한 데이터 교환을 보장한다. 이 조합으로 백그라운드에서 시스템 정보를 수집하면서 메인 스레드는 UI 렌더링에 집중할 수 있다.

## 26.6 비동기 작업과 std::async

### 26.6.1 std::async 소개

`std::async`는 비동기 작업을 더 간단하게 처리할 수 있게 해준다.

```cpp
#include <future>

// 데이터 파일 로더
class DataFileLoader {
public:
    struct LoadResult {
        bool success;
        std::vector<DataPoint> data;
        String errorMessage;
    };
    
    // 비동기로 파일 로드
    static std::future<LoadResult> loadAsync(const FilePath& path) {
        return std::async(std::launch::async, [path]() {
            return loadFile(path);
        });
    }
    
private:
    static LoadResult loadFile(const FilePath& path) {
        LoadResult result;
        result.success = false;
        
        TextReader reader(path);
        if (!reader) {
            result.errorMessage = U"Failed to open file";
            return result;
        }
        
        String line;
        bool firstLine = true;
        
        while (reader.readLine(line)) {
            // 헤더 라인 스킵
            if (firstLine) {
                firstLine = false;
                continue;
            }
            
            // CSV 파싱: timestamp,value
            auto parts = line.split(U',');
            if (parts.size() != 2) continue;
            
            try {
                double timestamp = ParseFloat<double>(parts[0]);
                double value = ParseFloat<double>(parts[1]);
                result.data.emplace_back(timestamp, value);
            }
            catch (...) {
                // 파싱 오류 무시
                continue;
            }
        }
        
        result.success = true;
        return result;
    }
};

// 데이터 파일 세이버
class DataFileSaver {
public:
    static std::future<bool> saveAsync(const FilePath& path, 
                                      const std::vector<DataPoint>& data) {
        return std::async(std::launch::async, [path, data]() {
            return saveFile(path, data);
        });
    }
    
private:
    static bool saveFile(const FilePath& path, const std::vector<DataPoint>& data) {
        TextWriter writer(path);
        if (!writer) return false;
        
        // 헤더 작성
        writer.writeln(U"timestamp,value");
        
        // 데이터 작성
        for (const auto& point : data) {
            writer.writeln(U"{},{}"_fmt(point.timestamp, point.value));
        }
        
        return true;
    }
};
```

### 26.6.2 실습: 파일 입출력과 비동기 처리

```cpp
void Main() {
    Window::Resize(1280, 720);
    Scene::SetBackground(ColorF(0.95));
    
    auto dataSeries = std::make_shared<DataSeries>(U"Data", ColorF(0.2, 0.6, 1.0));
    std::vector<std::shared_ptr<DataSeries>> series = { dataSeries };
    
    LineChartRenderer lineChart(RectF(50, 50, 1180, 500), U"Data Visualization");
    
    // 비동기 작업 상태
    std::optional<std::future<DataFileLoader::LoadResult>> loadFuture;
    std::optional<std::future<bool>> saveFuture;
    bool isLoading = false;
    bool isSaving = false;
    String statusMessage;
    
    Stopwatch stopwatch(StartImmediately::Yes);
    
    while (System::Update()) {
        // 로딩 완료 체크
        if (loadFuture && loadFuture->wait_for(std::chrono::seconds(0)) == 
            std::future_status::ready) {
            auto result = loadFuture->get();
            
            if (result.success) {
                dataSeries->clear();
                for (const auto& point : result.data) {
                    dataSeries->addDataPoint(point.timestamp, point.value);
                }
                statusMessage = U"Loaded {} data points"_fmt(result.data.size());
            } else {
                statusMessage = U"Load failed: " + result.errorMessage;
            }
            
            loadFuture.reset();
            isLoading = false;
        }
        
        // 저장 완료 체크
        if (saveFuture && saveFuture->wait_for(std::chrono::seconds(0)) == 
            std::future_status::ready) {
            bool success = saveFuture->get();
            statusMessage = success ? U"Save successful" : U"Save failed";
            saveFuture.reset();
            isSaving = false;
        }
        
        // 데이터 생성 (데모용)
        if (!isLoading) {
            double time = stopwatch.sF();
            dataSeries->addDataPoint(time, 
                50.0 + 30.0 * Sin(time) + Random(-5.0, 5.0));
        }
        
        // 차트 렌더링
        lineChart.render(series);
        
        // UI 컨트롤
        double buttonY = 570;
        Font font(20);
        
        if (SimpleGUI::Button(U"Load CSV", Vec2(50, buttonY), 150, !isLoading && !isSaving)) {
            if (auto path = Dialog::OpenFile({ FileFilter::CSV() })) {
                loadFuture = DataFileLoader::loadAsync(*path);
                isLoading = true;
                statusMessage = U"Loading...";
            }
        }
        
        if (SimpleGUI::Button(U"Save CSV", Vec2(220, buttonY), 150, !isLoading && !isSaving)) {
            if (auto path = Dialog::SaveFile({ FileFilter::CSV() })) {
                auto data = dataSeries->getDataCopy();
                saveFuture = DataFileSaver::saveAsync(*path, data);
                isSaving = true;
                statusMessage = U"Saving...";
            }
        }
        
        if (SimpleGUI::Button(U"Clear", Vec2(390, buttonY), 150, !isLoading && !isSaving)) {
            dataSeries->clear();
            statusMessage = U"Cleared";
        }
        
        // 상태 메시지
        font(statusMessage).draw(50, 630, ColorF(0.3));
        
        // 로딩 인디케이터
        if (isLoading || isSaving) {
            Circle(1200, 600, 15).drawFrame(3, ColorF(0.3));
            Circle(1200, 600, 10)
                .drawArc(0_deg, Scene::Time() * 360_deg, 0, 3, ColorF(0.2, 0.6, 1.0));
        }
    }
}
```

## 26.7 성능 최적화

### 26.7.1 데이터 샘플링

많은 데이터 포인트를 렌더링할 때는 성능이 저하될 수 있다. 샘플링을 통해 최적화한다.

```cpp
class DataSampler {
public:
    // LTTB (Largest Triangle Three Buckets) 알고리즘
    static std::vector<DataPoint> downsample(
        const std::vector<DataPoint>& data, size_t targetSize) {
        
        if (data.size() <= targetSize) {
            return data;
        }
        
        std::vector<DataPoint> sampled;
        sampled.reserve(targetSize);
        
        // 첫 번째와 마지막 포인트는 항상 포함
        sampled.push_back(data.front());
        
        double bucketSize = static_cast<double>(data.size() - 2) / (targetSize - 2);
        
        size_t pointIndex = 0;
        
        for (size_t i = 0; i < targetSize - 2; ++i) {
            // 현재 버킷의 범위
            size_t bucketStart = static_cast<size_t>(i * bucketSize) + 1;
            size_t bucketEnd = static_cast<size_t>((i + 1) * bucketSize) + 1;
            
            // 다음 버킷의 평균 포인트
            double nextAvgTime = 0;
            double nextAvgValue = 0;
            size_t nextBucketStart = bucketEnd;
            size_t nextBucketEnd = Min(nextBucketStart + 
                                      static_cast<size_t>(bucketSize), data.size());
            
            if (nextBucketEnd > nextBucketStart) {
                for (size_t j = nextBucketStart; j < nextBucketEnd; ++j) {
                    nextAvgTime += data[j].timestamp;
                    nextAvgValue += data[j].value;
                }
                size_t count = nextBucketEnd - nextBucketStart;
                nextAvgTime /= count;
                nextAvgValue /= count;
            }
            
            // 현재 버킷에서 가장 큰 삼각형을 만드는 포인트 선택
            double maxArea = -1;
            size_t maxAreaIndex = bucketStart;
            
            const DataPoint& lastPoint = sampled.back();
            
            for (size_t j = bucketStart; j < bucketEnd; ++j) {
                double area = Abs(
                    (lastPoint.timestamp - nextAvgTime) * (data[j].value - lastPoint.value) -
                    (lastPoint.timestamp - data[j].timestamp) * (nextAvgValue - lastPoint.value)
                ) * 0.5;
                
                if (area > maxArea) {
                    maxArea = area;
                    maxAreaIndex = j;
                }
            }
            
            sampled.push_back(data[maxAreaIndex]);
            pointIndex = maxAreaIndex;
        }
        
        sampled.push_back(data.back());
        
        return sampled;
    }
};
```

### 26.7.2 렌더링 최적화

```cpp
class OptimizedLineChartRenderer : public LineChartRenderer {
private:
    static constexpr size_t MAX_RENDER_POINTS = 500;
    
public:
    using LineChartRenderer::LineChartRenderer;
    
    void render(const std::vector<std::shared_ptr<DataSeries>>& series) override {
        if (series.empty()) return;
        
        // 기본 렌더링 코드...
        bounds_.draw(ColorF(1.0));
        bounds_.drawFrame(2.0, ColorF(0.7));
        
        Font titleFont(24, Typeface::Bold);
        titleFont(title_).drawAt(bounds_.center().x, bounds_.y + 30, ColorF(0.2));
        
        calculateBounds(series);
        
        double currentTime = Scene::Time();
        double minTime = currentTime - timeWindow_;
        double maxTime = currentTime;
        
        const double padding = 60.0;
        RectF chartArea = bounds_.stretched(-padding);
        
        // 그리드와 레이블은 그대로...
        
        // 최적화된 데이터 렌더링
        for (const auto& s : series) {
            auto data = s->getDataCopy();
            
            // 시간 윈도우 필터링
            std::vector<DataPoint> filtered;
            for (const auto& point : data) {
                if (point.timestamp >= minTime && point.timestamp <= maxTime) {
                    filtered.push_back(point);
                }
            }
            
            if (filtered.size() < 2) continue;
            
            // 다운샘플링
            auto sampledData = DataSampler::downsample(filtered, MAX_RENDER_POINTS);
            
            // 화면 좌표 변환
            std::vector<Vec2> points;
            points.reserve(sampledData.size());
            
            for (const auto& point : sampledData) {
                points.push_back(dataToScreen(point.timestamp, point.value, 
                                             minTime, maxTime));
            }
            
            // 선 그리기 (한 번에)
            if (points.size() >= 2) {
                // LineString으로 한 번에 그리기 (더 빠름)
                LineString ls(points);
                ls.draw(3.0, s->getColor());
            }
            
            // 포인트는 일부만 표시
            size_t step = Max<size_t>(1, points.size() / 50);
            for (size_t i = 0; i < points.size(); i += step) {
                Circle(points[i], 4).draw(s->getColor());
            }
        }
        
        // 범례 렌더링...
    }
};
```

### 26.7.3 메모리 최적화

```cpp
// 링 버퍼를 사용한 메모리 효율적인 데이터 시리즈
class RingBufferDataSeries {
private:
    String name_;
    ColorF color_;
    std::vector<DataPoint> buffer_;
    size_t head_;
    size_t size_;
    size_t capacity_;
    mutable std::mutex mutex_;
    
public:
    RingBufferDataSeries(const String& name, const ColorF& color, size_t capacity)
        : name_(name)
        , color_(color)
        , head_(0)
        , size_(0)
        , capacity_(capacity) {
        buffer_.resize(capacity);
    }
    
    void addDataPoint(double timestamp, double value) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        buffer_[head_] = DataPoint(timestamp, value);
        head_ = (head_ + 1) % capacity_;
        
        if (size_ < capacity_) {
            ++size_;
        }
    }
    
    std::vector<DataPoint> getDataCopy() const {
        std::lock_guard<std::mutex> lock(mutex_);
        
        std::vector<DataPoint> result;
        result.reserve(size_);
        
        if (size_ == 0) return result;
        
        // 링 버퍼에서 올바른 순서로 데이터 추출
        size_t start = (head_ + capacity_ - size_) % capacity_;
        
        for (size_t i = 0; i < size_; ++i) {
            result.push_back(buffer_[(start + i) % capacity_]);
        }
        
        return result;
    }
    
    const String& getName() const { return name_; }
    const ColorF& getColor() const { return color_; }
    
    DataPoint getLatest() const {
        std::lock_guard<std::mutex> lock(mutex_);
        if (size_ == 0) return DataPoint(0, 0);
        
        size_t lastIndex = (head_ + capacity_ - 1) % capacity_;
        return buffer_[lastIndex];
    }
};
```

## 26.8 인터랙티브 기능

### 26.8.1 마우스 상호작용

```cpp
class InteractiveLineChart : public OptimizedLineChartRenderer {
private:
    Optional<Vec2> hoveredPoint_;
    Optional<DataPoint> hoveredData_;
    String hoveredSeriesName_;
    
    bool findNearestPoint(Vec2 mousePos, const std::vector<std::shared_ptr<DataSeries>>& series) {
        const double padding = 60.0;
        RectF chartArea = bounds_.stretched(-padding);
        
        if (!chartArea.contains(mousePos)) {
            hoveredPoint_.reset();
            return false;
        }
        
        double currentTime = Scene::Time();
        double minTime = currentTime - timeWindow_;
        double maxTime = currentTime;
        
        double minDistance = 20.0;  // 최대 거리 (픽셀)
        bool found = false;
        
        for (const auto& s : series) {
            auto data = s->getDataCopy();
            
            for (const auto& point : data) {
                if (point.timestamp < minTime || point.timestamp > maxTime) continue;
                
                Vec2 screenPos = dataToScreen(point.timestamp, point.value, 
                                             minTime, maxTime);
                double dist = mousePos.distanceFrom(screenPos);
                
                if (dist < minDistance) {
                    minDistance = dist;
                    hoveredPoint_ = screenPos;
                    hoveredData_ = point;
                    hoveredSeriesName_ = s->getName();
                    found = true;
                }
            }
        }
        
        if (!found) {
            hoveredPoint_.reset();
        }
        
        return found;
    }
    
public:
    using OptimizedLineChartRenderer::OptimizedLineChartRenderer;
    
    void render(const std::vector<std::shared_ptr<DataSeries>>& series) override {
        // 기본 렌더링
        OptimizedLineChartRenderer::render(series);
        
        // 마우스 위치 확인
        Vec2 mousePos = Cursor::Pos();
        findNearestPoint(mousePos, series);
        
        // 호버된 포인트 표시
        if (hoveredPoint_) {
            // 강조 표시
            Circle(*hoveredPoint_, 8).draw(ColorF(1.0, 0.8));
            Circle(*hoveredPoint_, 6).draw(ColorF(1.0));
            Circle(*hoveredPoint_, 5).drawFrame(2, ColorF(0.2));
            
            // 툴팁
            if (hoveredData_) {
                String tooltip = U"{}\nTime: {:.1f}s\nValue: {:.2f}"_fmt(
                    hoveredSeriesName_,
                    hoveredData_->timestamp,
                    hoveredData_->value
                );
                
                Font tooltipFont(16);
                auto region = tooltipFont(tooltip).region();
                
                Vec2 tooltipPos = *hoveredPoint_ + Vec2(15, -region.h - 10);
                
                // 화면 밖으로 나가지 않도록
                if (tooltipPos.x + region.w > bounds_.x + bounds_.w) {
                    tooltipPos.x = hoveredPoint_->x - region.w - 15;
                }
                if (tooltipPos.y < bounds_.y) {
                    tooltipPos.y = hoveredPoint_->y + 15;
                }
                
                RectF tooltipBg(tooltipPos, region.size.x + 20, region.size.y + 10);
                tooltipBg.draw(ColorF(0.2, 0.9));
                tooltipBg.drawFrame(1, ColorF(0.7));
                
                tooltipFont(tooltip).draw(tooltipPos + Vec2(10, 5), ColorF(1.0));
            }
        }
    }
};
```

### 26.8.2 줌과 패닝

```cpp
class ZoomableLineChart : public InteractiveLineChart {
private:
    double zoomLevel_;
    double panOffset_;
    Vec2 lastDragPos_;
    bool isDragging_;
    
public:
    ZoomableLineChart(const RectF& bounds, const String& title, double timeWindow = 60.0)
        : InteractiveLineChart(bounds, title, timeWindow)
        , zoomLevel_(1.0)
        , panOffset_(0.0)
        , isDragging_(false) {
    }
    
    void handleInput() {
        Vec2 mousePos = Cursor::Pos();
        
        if (!bounds_.contains(mousePos)) {
            isDragging_ = false;
            return;
        }
        
        // 마우스 휠로 줌
        double wheel = Mouse::Wheel();
        if (wheel != 0) {
            zoomLevel_ = Clamp(zoomLevel_ + wheel * 0.1, 0.5, 5.0);
        }
        
        // 드래그로 패닝
        if (MouseL.down()) {
            isDragging_ = true;
            lastDragPos_ = mousePos;
        }
        
        if (MouseL.up()) {
            isDragging_ = false;
        }
        
        if (isDragging_ && MouseL.pressed()) {
            Vec2 delta = mousePos - lastDragPos_;
            panOffset_ += delta.x * (timeWindow_ / bounds_.w) / zoomLevel_;
            lastDragPos_ = mousePos;
        }
        
        // 더블클릭으로 리셋
        if (MouseL.down() && mousePos.distanceFrom(lastDragPos_) < 5) {
            static Stopwatch clickTimer;
            if (clickTimer.isRunning() && clickTimer.ms() < 300) {
                zoomLevel_ = 1.0;
                panOffset_ = 0.0;
                clickTimer.reset();
            } else {
                clickTimer.restart();
            }
        }
    }
    
    void render(const std::vector<std::shared_ptr<DataSeries>>& series) override {
        handleInput();
        
        // 줌과 패닝을 적용한 시간 윈도우 계산
        double adjustedTimeWindow = timeWindow_ / zoomLevel_;
        double currentTime = Scene::Time() + panOffset_;
        
        // 원래 timeWindow_를 임시로 조정
        double originalTimeWindow = timeWindow_;
        timeWindow_ = adjustedTimeWindow;
        
        // 기본 렌더링
        InteractiveLineChart::render(series);
        
        // 복원
        timeWindow_ = originalTimeWindow;
        
        // 줌 레벨 표시
        Font font(16);
        font(U"Zoom: {:.1f}x"_fmt(zoomLevel_))
            .draw(bounds_.x + 10, bounds_.y + bounds_.h - 30, ColorF(0.5));
    }
};
```

## 26.9 종합 실습 프로젝트

### 26.9.1 완성된 데이터 시각화 도구

이제 모든 기능을 통합한 완전한 데이터 시각화 도구를 만들어본다.

```cpp
// Main.cpp - 완성된 데이터 시각화 도구
void Main() {
    Window::Resize(1400, 800);
    Window::SetTitle(U"Advanced Data Visualization Tool");
    Scene::SetBackground(ColorF(0.95));
    
    // 시스템 모니터
    SystemMonitor monitor;
    monitor.start();
    
    // 데이터 시리즈
    auto cpuSeries = std::make_shared<RingBufferDataSeries>(
        U"CPU", ColorF(0.2, 0.6, 1.0), 1000);
    auto memorySeries = std::make_shared<RingBufferDataSeries>(
        U"Memory", ColorF(1.0, 0.4, 0.4), 1000);
    auto diskSeries = std::make_shared<RingBufferDataSeries>(
        U"Disk", ColorF(0.4, 0.8, 0.4), 1000);
    
    std::vector<std::shared_ptr<DataSeries>> allSeries;
    
    // RingBufferDataSeries를 DataSeries로 변환하는 어댑터
    auto createAdapter = [](std::shared_ptr<RingBufferDataSeries> ring) {
        struct Adapter : DataSeries {
            std::shared_ptr<RingBufferDataSeries> ring_;
            
            Adapter(std::shared_ptr<RingBufferDataSeries> r)
                : DataSeries(r->getName(), r->getColor()), ring_(r) {}
            
            std::vector<DataPoint> getDataCopy() const override {
                return ring_->getDataCopy();
            }
            
            DataPoint getLatest() const override {
                return ring_->getLatest();
            }
        };
        return std::make_shared<Adapter>(ring);
    };
    
    allSeries.push_back(createAdapter(cpuSeries));
    allSeries.push_back(createAdapter(memorySeries));
    allSeries.push_back(createAdapter(diskSeries));
    
    // 차트들
    ZoomableLineChart mainChart(RectF(20, 20, 1000, 500), 
                               U"System Resource Monitor", 60.0);
    BarChartRenderer barChart(RectF(1040, 20, 340, 240), 
                             U"Current Usage");
    PieChartRenderer pieChart(RectF(1040, 280, 340, 240), 
                             U"Distribution");
    
    // UI 상태
    bool isPaused = false;
    double updateInterval = 1.0;
    Stopwatch stopwatch(StartImmediately::Yes);
    double lastUpdate = 0.0;
    
    // 파일 작업
    std::optional<std::future<DataFileLoader::LoadResult>> loadFuture;
    std::optional<std::future<bool>> saveFuture;
    String statusMessage = U"Ready";
    
    // FPS 카운터
    Array<double> fpsHistory;
    
    while (System::Update()) {
        double currentTime = stopwatch.sF();
        
        // FPS 기록
        fpsHistory.push_back(Scene::DeltaTime());
        if (fpsHistory.size() > 60) {
            fpsHistory.pop_front();
        }
        
        // 데이터 업데이트
        if (!isPaused && currentTime - lastUpdate >= updateInterval) {
            cpuSeries->addDataPoint(currentTime, monitor.getCPU());
            memorySeries->addDataPoint(currentTime, monitor.getMemory());
            diskSeries->addDataPoint(currentTime, monitor.getDisk());
            lastUpdate = currentTime;
        }
        
        // 비동기 작업 체크
        if (loadFuture && loadFuture->wait_for(std::chrono::seconds(0)) == 
            std::future_status::ready) {
            auto result = loadFuture->get();
            statusMessage = result.success ? 
                U"Loaded {} points"_fmt(result.data.size()) : 
                U"Load failed: " + result.errorMessage;
            loadFuture.reset();
        }
        
        if (saveFuture && saveFuture->wait_for(std::chrono::seconds(0)) == 
            std::future_status::ready) {
            bool success = saveFuture->get();
            statusMessage = success ? U"Saved successfully" : U"Save failed";
            saveFuture.reset();
        }
        
        // 차트 렌더링
        mainChart.render(allSeries);
        barChart.render(allSeries);
        pieChart.render(allSeries);
        
        // 컨트롤 패널
        RectF controlPanel(20, 540, 1000, 240);
        controlPanel.draw(ColorF(1.0));
        controlPanel.drawFrame(2, ColorF(0.7));
        
        Font titleFont(20, Typeface::Bold);
        titleFont(U"Control Panel").draw(40, 555, ColorF(0.2));
        
        // 버튼들
        double buttonX = 40;
        double buttonY = 590;
        
        if (SimpleGUI::Button(isPaused ? U"▶ Resume" : U"⏸ Pause", 
                             Vec2(buttonX, buttonY), 120)) {
            isPaused = !isPaused;
        }
        
        buttonX += 140;
        if (SimpleGUI::Button(U"🗑 Clear", Vec2(buttonX, buttonY), 120)) {
            // 데이터 클리어 구현 필요
            statusMessage = U"Data cleared";
        }
        
        buttonX += 140;
        if (SimpleGUI::Button(U"📁 Load", Vec2(buttonX, buttonY), 120)) {
            if (auto path = Dialog::OpenFile({ FileFilter::CSV() })) {
                loadFuture = DataFileLoader::loadAsync(*path);
                statusMessage = U"Loading...";
            }
        }
        
        buttonX += 140;
        if (SimpleGUI::Button(U"💾 Save", Vec2(buttonX, buttonY), 120)) {
            if (auto path = Dialog::SaveFile({ FileFilter::CSV() })) {
                auto data = cpuSeries->getDataCopy();
                saveFuture = DataFileSaver::saveAsync(*path, data);
                statusMessage = U"Saving...";
            }
        }
        
        // 설정
        buttonY += 50;
        Font labelFont(16);
        labelFont(U"Update Interval:").draw(40, buttonY + 5, ColorF(0.4));
        
        SimpleGUI::Slider(U"{:.1f}s"_fmt(updateInterval), updateInterval, 
                         0.1, 5.0, Vec2(200, buttonY), 150);
        
        // 통계 정보
        buttonY += 50;
        RectF statsBox(40, buttonY, 940, 80);
        statsBox.draw(ColorF(0.98));
        statsBox.drawFrame(1, ColorF(0.85));
        
        double avgFPS = fpsHistory.isEmpty() ? 60.0 : 
            1.0 / (fpsHistory.sum() / fpsHistory.size());
        
        Font statsFont(16);
        statsFont(U"📊 Statistics").draw(50, buttonY + 10, ColorF(0.3));
        statsFont(U"FPS: {:.1f}"_fmt(avgFPS)).draw(50, buttonY + 35, ColorF(0.4));
        statsFont(U"Data Points: {}"_fmt(cpuSeries->getDataCopy().size()))
            .draw(200, buttonY + 35, ColorF(0.4));
        statsFont(U"Time: {:.1f}s"_fmt(currentTime))
            .draw(400, buttonY + 35, ColorF(0.4));
        statsFont(statusMessage).draw(600, buttonY + 35, ColorF(0.2, 0.6, 1.0));
        
        // 정보 패널
        RectF infoPanel(1040, 540, 340, 240);
        infoPanel.draw(ColorF(1.0));
        infoPanel.drawFrame(2, ColorF(0.7));
        
        titleFont(U"Information").draw(1060, 555, ColorF(0.2));
        
        Font infoFont(14);
        double infoY = 590;
        
        infoFont(U"💻 CPU Usage: {:.1f}%"_fmt(monitor.getCPU()))
            .draw(1060, infoY, cpuSeries->getColor());
        infoY += 25;
        
        infoFont(U"💾 Memory: {:.1f}%"_fmt(monitor.getMemory()))
            .draw(1060, infoY, memorySeries->getColor());
        infoY += 25;
        
        infoFont(U"💿 Disk: {:.1f}%"_fmt(monitor.getDisk()))
            .draw(1060, infoY, diskSeries->getColor());
        infoY += 35;
        
        infoFont(U"🔍 Zoom: {:.1f}x (Mouse Wheel)"_fmt(1.0))
            .draw(1060, infoY, ColorF(0.5));
        infoY += 20;
        
        infoFont(U"👆 Pan: Drag chart")
            .draw(1060, infoY, ColorF(0.5));
        infoY += 20;
        
        infoFont(U"🖱 Hover: Show values")
            .draw(1060, infoY, ColorF(0.5));
    }
    
    monitor.stop();
}
```

## 26.10 심화 학습

### 26.10.1 성능 프로파일링

코드의 성능을 측정하고 최적화하는 방법을 배운다.

```cpp
// 간단한 프로파일러
class SimpleProfiler {
private:
    struct ProfileData {
        String name;
        Duration totalTime;
        size_t callCount;
        
        ProfileData() : totalTime(0), callCount(0) {}
    };
    
    static inline std::unordered_map<String, ProfileData> data_;
    static inline std::mutex mutex_;
    
public:
    class ScopedTimer {
    private:
        String name_;
        Stopwatch timer_;
        
    public:
        ScopedTimer(const String& name) 
            : name_(name), timer_(StartImmediately::Yes) {}
        
        ~ScopedTimer() {
            std::lock_guard<std::mutex> lock(SimpleProfiler::mutex_);
            auto& profile = SimpleProfiler::data_[name_];
            profile.name = name_;
            profile.totalTime += timer_.elapsed();
            profile.callCount++;
        }
    };
    
    static void reset() {
        std::lock_guard<std::mutex> lock(mutex_);
        data_.clear();
    }
    
    static void printResults() {
        std::lock_guard<std::mutex> lock(mutex_);
        
        Console << U"=== Performance Profile ===" << U"\n";
        
        for (const auto& [name, profile] : data_) {
            double avgMs = profile.totalTime.count() / 1000000.0 / profile.callCount;
            Console << U"{}: {} calls, {:.3f}ms avg"_fmt(
                name, profile.callCount, avgMs) << U"\n";
        }
    }
};

// 사용 예
void optimizedFunction() {
    SimpleProfiler::ScopedTimer timer(U"OptimizedFunction");
    
    // 작업 수행
    for (int i = 0; i < 1000; ++i) {
        // ...
    }
}
```

### 26.10.2 메모리 사용량 모니터링

```cpp
class MemoryMonitor {
public:
    static size_t getCurrentUsage() {
#ifdef SIV3D_PLATFORM_WINDOWS
        PROCESS_MEMORY_COUNTERS_EX pmc;
        GetProcessMemoryInfo(GetCurrentProcess(), 
                           (PROCESS_MEMORY_COUNTERS*)&pmc, sizeof(pmc));
        return pmc.WorkingSetSize;
#else
        return 0;
#endif
    }
    
    static String formatBytes(size_t bytes) {
        if (bytes < 1024) {
            return U"{} B"_fmt(bytes);
        } else if (bytes < 1024 * 1024) {
            return U"{:.2f} KB"_fmt(bytes / 1024.0);
        } else if (bytes < 1024 * 1024 * 1024) {
            return U"{:.2f} MB"_fmt(bytes / (1024.0 * 1024.0));
        } else {
            return U"{:.2f} GB"_fmt(bytes / (1024.0 * 1024.0 * 1024.0));
        }
    }
};
```

### 26.10.3 연습 문제

**문제 1**: 데이터 시각화 도구에 히스토그램(분포도) 차트를 추가하라.

**문제 2**: 여러 데이터 파일을 동시에 로드하고 비교하는 기능을 구현하라.

**문제 3**: 실시간으로 데이터의 통계(평균, 최대, 최소, 표준편차)를 계산하고 표시하라.

**문제 4**: 차트의 색상 테마를 변경할 수 있는 기능을 추가하라(다크 모드, 라이트 모드 등).

**문제 5**: 특정 시간 범위를 선택하여 확대해서 볼 수 있는 기능을 구현하라.

## 26.11 마치며

이번 장에서는 실시간 데이터 처리와 시각화를 위한 포괄적인 도구를 만들어보았다. 멀티스레딩(`std::thread`, `std::async`)을 사용한 비동기 처리, 다양한 차트 타입 구현, 성능 최적화 기법, 인터랙티브 UI 등 실무에서 중요한 여러 기술을 배웠다.

데이터 시각화는 단순히 그래프를 그리는 것이 아니라, 사용자가 데이터를 이해하고 인사이트를 얻을 수 있도록 돕는 도구를 만드는 것이다. 성능과 사용성, 시각적 표현의 균형을 맞추는 것이 중요하다.

이제 여러분은 Modern C++의 강력한 기능들을 활용하여 실용적이고 효율적인 애플리케이션을 만들 수 있는 능력을 갖추었다. 다음 장에서는 더 고급 주제들과 최적화 기법을 다룰 것이다.


   