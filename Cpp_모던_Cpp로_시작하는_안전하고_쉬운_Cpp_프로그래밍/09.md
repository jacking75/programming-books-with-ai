# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 9: 함수와 매개변수
프로그램이 커지면서 같은 코드를 여러 번 작성하는 것은 비효율적이고 유지보수하기 어렵다. 함수는 특정 작업을 수행하는 코드를 하나의 이름 있는 블록으로 묶어, 필요할 때마다 호출할 수 있게 해준다. 함수를 잘 활용하면 코드의 재사용성이 높아지고, 가독성이 좋아지며, 버그를 찾고 수정하기도 쉬워진다.

Modern C++는 함수를 더 안전하고 편리하게 사용할 수 있는 여러 기능을 제공한다. 이번 장에서는 함수의 기본 개념부터 매개변수 전달 방식, 오버로딩, `auto` 반환 타입 등 Modern C++의 핵심 기능들을 배운다.

## 9.1 함수 정의와 호출
함수는 특정 작업을 수행하고 결과를 반환하는 코드 블록이다. 함수를 사용하면 복잡한 프로그램을 작은 단위로 나누어 관리할 수 있다.

### 9.1.1 함수의 기본 구조
함수는 다음과 같은 구조를 가진다.

```cpp
반환_타입 함수_이름(매개변수_목록) {
    // 함수 본문
    return 반환_값;
}
```

각 부분의 의미는 다음과 같다.

- **반환 타입**: 함수가 반환하는 값의 데이터 타입
- **함수 이름**: 함수를 호출할 때 사용하는 식별자
- **매개변수 목록**: 함수에 전달되는 입력 값들
- **함수 본문**: 실제로 실행되는 코드
- **return 문**: 함수의 결과를 반환

**간단한 예제:**

```cpp
#include <iostream>

// 두 정수를 더하는 함수
int add(int a, int b) {
    int result = a + b;
    return result;
}

int main() {
    int x = 10;
    int y = 20;
    
    // 함수 호출
    int sum = add(x, y);
    
    std::cout << x << " + " << y << " = " << sum << "\n";
    
    return 0;
}
```

**출력 결과:**
```
10 + 20 = 30
```

함수를 호출하면 실행 흐름이 함수로 이동하고, 함수가 종료되면 호출한 위치로 돌아온다.

### 9.1.2 반환 값이 없는 함수
함수가 값을 반환하지 않을 때는 `void`를 반환 타입으로 사용한다.

```cpp
#include <iostream>

void print_greeting(std::string name) {
    std::cout << "안녕하세요, " << name << "님!\n";
    // return 문 생략 가능 (또는 return;만 작성)
}

int main() {
    print_greeting("철수");
    print_greeting("영희");
    
    return 0;
}
```

**출력 결과:**
```
안녕하세요, 철수님!
안녕하세요, 영희님!
```

`void` 함수에서는 `return;`을 사용하여 함수를 중간에 종료할 수 있다.

```cpp
#include <iostream>

void print_positive(int num) {
    if (num <= 0) {
        std::cout << "양수가 아닙니다.\n";
        return;  // 여기서 함수 종료
    }
    
    std::cout << "양수입니다: " << num << "\n";
}

int main() {
    print_positive(10);
    print_positive(-5);
    print_positive(0);
    
    return 0;
}
```

**출력 결과:**
```
양수입니다: 10
양수가 아닙니다.
양수가 아닙니다.
```

### 9.1.3 함수 선언과 정의 분리
큰 프로그램에서는 함수 선언(프로토타입)과 정의를 분리하는 것이 일반적이다. 이렇게 하면 함수를 정의하기 전에 호출할 수 있다.

```cpp
#include <iostream>

// 함수 선언 (프로토타입)
int multiply(int a, int b);
void print_result(int value);

int main() {
    int result = multiply(5, 7);
    print_result(result);
    
    return 0;
}

// 함수 정의
int multiply(int a, int b) {
    return a * b;
}

void print_result(int value) {
    std::cout << "결과: " << value << "\n";
}
```

**출력 결과:**
```
결과: 35
```

함수 선언에서는 매개변수 이름을 생략할 수 있다.

```cpp
// 둘 다 유효한 선언
int multiply(int a, int b);
int multiply(int, int);
```

하지만 가독성을 위해 매개변수 이름을 포함하는 것을 권장한다.

### 9.1.4 여러 값을 반환하는 방법
C++에서 함수는 하나의 값만 직접 반환할 수 있다. 여러 값을 반환하려면 몇 가지 방법이 있다.

**방법 1: 구조체 사용**

```cpp
#include <iostream>

struct DivisionResult {
    int quotient;   // 몫
    int remainder;  // 나머지
};

DivisionResult divide(int dividend, int divisor) {
    DivisionResult result;
    result.quotient = dividend / divisor;
    result.remainder = dividend % divisor;
    return result;
}

int main() {
    auto result = divide(17, 5);
    
    std::cout << "17 ÷ 5 = " << result.quotient 
              << " ... " << result.remainder << "\n";
    
    return 0;
}
```

**출력 결과:**
```
17 ÷ 5 = 3 ... 2
```

**방법 2: std::pair 또는 std::tuple 사용**

```cpp
#include <iostream>
#include <utility>  // std::pair

std::pair<int, int> divide(int dividend, int divisor) {
    return {dividend / divisor, dividend % divisor};
}

int main() {
    auto [quotient, remainder] = divide(17, 5);  // 구조적 바인딩 (C++17)
    
    std::cout << "17 ÷ 5 = " << quotient 
              << " ... " << remainder << "\n";
    
    return 0;
}
```

구조적 바인딩을 사용하면 반환된 값들을 개별 변수로 직접 받을 수 있다.

**방법 3: 참조 매개변수 사용 (다음 섹션에서 자세히 다룸)**

```cpp
#include <iostream>

void divide(int dividend, int divisor, int& quotient, int& remainder) {
    quotient = dividend / divisor;
    remainder = dividend % divisor;
}

int main() {
    int q, r;
    divide(17, 5, q, r);
    
    std::cout << "17 ÷ 5 = " << q << " ... " << r << "\n";
    
    return 0;
}
```

### 9.1.5 재귀 함수
함수가 자기 자신을 호출하는 것을 재귀라고 한다. 재귀는 특정 문제를 간결하게 해결할 수 있지만, 잘못 사용하면 무한 루프에 빠질 수 있다.

**팩토리얼 계산**

```cpp
#include <iostream>

int factorial(int n) {
    // 기저 사례 (재귀 종료 조건)
    if (n <= 1) {
        return 1;
    }
    
    // 재귀 호출
    return n * factorial(n - 1);
}

int main() {
    std::cout << "5! = " << factorial(5) << "\n";
    std::cout << "7! = " << factorial(7) << "\n";
    
    return 0;
}
```

**출력 결과:**
```
5! = 120
7! = 5040
```

재귀 함수는 반드시 종료 조건(기저 사례)을 가져야 한다.

**피보나치 수열**

```cpp
#include <iostream>

int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    std::cout << "피보나치 수열 (처음 10개):\n";
    for (int i = 0; i < 10; ++i) {
        std::cout << fibonacci(i) << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

**출력 결과:**
```
피보나치 수열 (처음 10개):
0 1 1 2 3 5 8 13 21 34
```

재귀는 우아하지만 성능이 좋지 않을 수 있다. 위 피보나치 함수는 같은 값을 여러 번 계산한다. 실무에서는 반복문이나 메모이제이션을 사용하는 것이 더 효율적이다.
   

</br>  
</br>  
  
  
## 9.2 매개변수 전달 방식
함수에 값을 전달하는 방법은 크게 세 가지가 있다. 값 전달, 참조 전달, 포인터 전달이다. 각각의 특징과 사용 시기를 이해하는 것이 중요하다.

### 9.2.1 값 전달 (Pass by Value)
값 전달은 가장 기본적인 방법으로, 인자의 복사본이 함수에 전달된다. 함수 내에서 매개변수를 변경해도 원본에는 영향을 주지 않는다.

```cpp
#include <iostream>

void double_value(int num) {
    num = num * 2;
    std::cout << "함수 내부: " << num << "\n";
}

int main() {
    int value = 10;
    
    std::cout << "호출 전: " << value << "\n";
    double_value(value);
    std::cout << "호출 후: " << value << "\n";
    
    return 0;
}
```

**출력 결과:**
```
호출 전: 10
함수 내부: 20
호출 후: 10
```

함수 내부에서 `num`을 변경했지만 `value`는 변하지 않았다. 이는 `num`이 `value`의 복사본이기 때문이다.

**장점:**
- 안전하다. 함수가 원본 데이터를 변경할 수 없다.
- 의도가 명확하다.

**단점:**
- 큰 객체를 복사하면 성능이 떨어진다.
- 함수에서 계산한 결과를 반환 값으로만 전달할 수 있다.

### 9.2.2 참조 전달 (Pass by Reference)
참조 전달은 원본 변수의 별칭을 전달한다. 함수 내에서 매개변수를 변경하면 원본도 변경된다.

```cpp
#include <iostream>

void double_value(int& num) {  // & 기호로 참조 표시
    num = num * 2;
    std::cout << "함수 내부: " << num << "\n";
}

int main() {
    int value = 10;
    
    std::cout << "호출 전: " << value << "\n";
    double_value(value);
    std::cout << "호출 후: " << value << "\n";
    
    return 0;
}
```

**출력 결과:**
```
호출 전: 10
함수 내부: 20
호출 후: 20
```

이번에는 원본 `value`가 변경되었다. `num`은 `value`의 별칭이기 때문이다.

**const 참조**

함수에서 값을 변경하지 않으면서도 복사 비용을 피하려면 `const` 참조를 사용한다.

```cpp
#include <iostream>
#include <string>

void print_string(const std::string& str) {  // const 참조
    std::cout << "문자열: " << str << "\n";
    // str = "변경";  // 컴파일 오류! const이므로 변경 불가
}

int main() {
    std::string message = "Hello, World!";
    print_string(message);
    
    return 0;
}
```

**출력 결과:**
```
문자열: Hello, World!
```

`const` 참조는 Modern C++에서 매우 중요한 패턴이다. 특히 큰 객체를 함수에 전달할 때 자주 사용된다.

**실용적 예제: 벡터 전달**

```cpp
#include <iostream>
#include <vector>

// 값 전달 - 벡터 전체를 복사 (비효율적)
void print_vector_bad(std::vector<int> vec) {
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << "\n";
}

// const 참조 - 복사 없이 읽기만 (효율적)
void print_vector_good(const std::vector<int>& vec) {
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << "\n";
}

// 참조 - 원본 수정 가능
void double_vector(std::vector<int>& vec) {
    for (int& num : vec) {
        num *= 2;
    }
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    print_vector_good(numbers);
    double_vector(numbers);
    print_vector_good(numbers);
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 4 5
2 4 6 8 10
```

**참조 전달 사용 지침:**

- **읽기만 할 때**: `const T&` 사용
- **수정이 필요할 때**: `T&` 사용
- **작은 타입** (int, double 등): 값 전달도 괜찮음

### 9.2.3 포인터 전달 (Pass by Pointer)
포인터 전달은 변수의 메모리 주소를 전달한다. 참조와 비슷하지만 `nullptr`을 전달할 수 있고, 명시적으로 역참조(`*`)를 사용해야 한다.

```cpp
#include <iostream>

void double_value(int* num) {  // 포인터 매개변수
    if (num != nullptr) {  // nullptr 검사
        *num = *num * 2;  // 역참조하여 값 변경
    }
}

int main() {
    int value = 10;
    
    std::cout << "호출 전: " << value << "\n";
    double_value(&value);  // 주소 전달
    std::cout << "호출 후: " << value << "\n";
    
    return 0;
}
```

**출력 결과:**
```
호출 전: 10
호출 후: 20
```

**포인터 vs 참조**

```cpp
#include <iostream>

void modify_by_reference(int& num) {
    num = 100;
}

void modify_by_pointer(int* num) {
    if (num != nullptr) {
        *num = 200;
    }
}

int main() {
    int a = 10;
    int b = 20;
    
    // 참조 - 간결하고 안전
    modify_by_reference(a);
    std::cout << "a = " << a << "\n";
    
    // 포인터 - nullptr 가능, 명시적
    modify_by_pointer(&b);
    std::cout << "b = " << b << "\n";
    
    // 포인터는 nullptr을 전달할 수 있음
    modify_by_pointer(nullptr);  // 안전하게 처리됨
    
    return 0;
}
```

**출력 결과:**
```
a = 100
b = 200
```

**Modern C++에서의 권장사항:**

- 가능하면 **참조**를 사용한다. 더 안전하고 간결하다.
- 포인터는 다음 경우에만 사용한다:
  - `nullptr`이 의미 있는 값일 때
  - C 라이브러리와 상호작용할 때
  - 동적 메모리를 다룰 때 (하지만 스마트 포인터 사용 권장)

### 9.2.4 배열 전달
배열을 함수에 전달하면 포인터로 변환된다. 따라서 크기 정보가 손실된다.

```cpp
#include <iostream>

// C 스타일 배열 - 크기 정보 손실
void print_array_c_style(int arr[], int size) {
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
}

// std::array - 크기 정보 유지 (권장)
void print_array_modern(const std::array<int, 5>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << "\n";
}

// std::vector - 동적 크기 (권장)
void print_vector(const std::vector<int>& vec) {
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << "\n";
}

int main() {
    int c_array[5] = {1, 2, 3, 4, 5};
    std::array<int, 5> std_array = {1, 2, 3, 4, 5};
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    print_array_c_style(c_array, 5);  // 크기를 별도로 전달해야 함
    print_array_modern(std_array);     // 크기 정보 포함
    print_vector(vec);                 // 크기 정보 포함
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
```

Modern C++에서는 C 스타일 배열 대신 `std::array`나 `std::vector`를 사용하고, `const` 참조로 전달하는 것이 권장된다.
  

</br>  
</br>  
  

## 9.3 기본 매개변수와 오버로딩
함수의 유연성을 높이는 두 가지 기능이 기본 매개변수와 함수 오버로딩이다.

### 9.3.1 기본 매개변수
기본 매개변수는 함수 호출 시 인자를 생략하면 사용되는 기본값이다.

```cpp
#include <iostream>
#include <string>

void greet(std::string name, std::string greeting = "안녕하세요") {
    std::cout << greeting << ", " << name << "님!\n";
}

int main() {
    greet("철수");                    // 기본 인사말 사용
    greet("영희", "반갑습니다");       // 사용자 지정 인사말
    
    return 0;
}
```

**출력 결과:**
```
안녕하세요, 철수님!
반갑습니다, 영희님!
```

**기본 매개변수 규칙:**

1. 기본값은 함수 선언이나 정의에서 한 번만 지정한다.
2. 기본 매개변수는 오른쪽부터 순서대로 지정해야 한다.
3. 기본값이 없는 매개변수는 기본값이 있는 매개변수보다 앞에 와야 한다.

```cpp
// 올바른 예
void func1(int a, int b = 10, int c = 20);
void func2(int a = 1, int b = 2, int c = 3);

// 잘못된 예
// void func3(int a = 1, int b, int c = 3);  // 오류! b에 기본값 없음
```

**실용적 예제: 그리기 함수**

```cpp
#include <iostream>
#include <string>

void draw_rectangle(int width, int height, char symbol = '*', bool filled = true) {
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            if (filled || i == 0 || i == height - 1 || j == 0 || j == width - 1) {
                std::cout << symbol;
            } else {
                std::cout << ' ';
            }
        }
        std::cout << "\n";
    }
}

int main() {
    std::cout << "기본 사각형:\n";
    draw_rectangle(5, 3);
    
    std::cout << "\n사용자 지정 기호:\n";
    draw_rectangle(5, 3, '#');
    
    std::cout << "\n테두리만:\n";
    draw_rectangle(5, 3, '@', false);
    
    return 0;
}
```

**출력 결과:**
```
기본 사각형:
*****
*****
*****

사용자 지정 기호:
#####
#####
#####

테두리만:
@@@@@
@   @
@@@@@
```

### 9.3.2 함수 오버로딩
함수 오버로딩은 같은 이름의 함수를 여러 개 정의하는 것이다. 매개변수의 개수나 타입이 다르면 컴파일러가 자동으로 올바른 함수를 선택한다.

```cpp
#include <iostream>
#include <string>

// 정수 더하기
int add(int a, int b) {
    std::cout << "int 버전 호출\n";
    return a + b;
}

// 실수 더하기
double add(double a, double b) {
    std::cout << "double 버전 호출\n";
    return a + b;
}

// 세 정수 더하기
int add(int a, int b, int c) {
    std::cout << "int 세 개 버전 호출\n";
    return a + b + c;
}

// 문자열 연결
std::string add(const std::string& a, const std::string& b) {
    std::cout << "string 버전 호출\n";
    return a + b;
}

int main() {
    std::cout << "결과: " << add(10, 20) << "\n\n";
    std::cout << "결과: " << add(3.14, 2.86) << "\n\n";
    std::cout << "결과: " << add(1, 2, 3) << "\n\n";
    std::cout << "결과: " << add(std::string("Hello, "), std::string("World!")) << "\n";
    
    return 0;
}
```

**출력 결과:**
```
int 버전 호출
결과: 30

double 버전 호출
결과: 6

int 세 개 버전 호출
결과: 6

string 버전 호출
결과: Hello, World!
```

**오버로딩 규칙:**

1. 매개변수의 개수가 다르거나
2. 매개변수의 타입이 다르거나
3. 매개변수의 순서가 다르면 오버로딩 가능

반환 타입만 다른 것은 오버로딩이 아니다.

```cpp
// 오류! 반환 타입만 다름
// int func();
// double func();
```

**const 오버로딩**

`const` 유무에 따라서도 오버로딩할 수 있다.

```cpp
#include <iostream>

void process(int& value) {
    std::cout << "비const 참조 버전\n";
    value *= 2;
}

void process(const int& value) {
    std::cout << "const 참조 버전\n";
    std::cout << "값: " << value << "\n";
}

int main() {
    int a = 10;
    const int b = 20;
    
    process(a);  // 비const 버전 호출
    process(b);  // const 버전 호출
    process(30); // const 버전 호출 (임시 객체)
    
    return 0;
}
```

**출력 결과:**
```
비const 참조 버전
const 참조 버전
값: 20
const 참조 버전
값: 30
```

### 9.3.3 기본 매개변수 vs 오버로딩
같은 기능을 기본 매개변수나 오버로딩으로 구현할 수 있다. 어떤 것을 선택할지는 상황에 따라 다르다.

**기본 매개변수 방식:**

```cpp
void print(int value, bool newline = true) {
    std::cout << value;
    if (newline) {
        std::cout << "\n";
    }
}
```

**오버로딩 방식:**

```cpp
void print(int value) {
    std::cout << value << "\n";
}

void print(int value, bool newline) {
    std::cout << value;
    if (newline) {
        std::cout << "\n";
    }
}
```

**선택 기준:**

- **기본 매개변수**: 대부분의 호출에서 같은 기본값을 사용할 때
- **오버로딩**: 각 버전이 다른 로직을 가질 때
   

</br>  
</br>  


## 9.4 `auto` 반환 타입과 후행 반환 타입
Modern C++는 함수의 반환 타입을 더 유연하게 지정할 수 있는 기능을 제공한다.

### 9.4.1 `auto` 반환 타입
C++14부터 함수의 반환 타입을 `auto`로 지정하면 컴파일러가 `return` 문을 분석하여 자동으로 타입을 추론한다.

```cpp
#include <iostream>

auto add(int a, int b) {
    return a + b;  // 컴파일러가 int로 추론
}

auto get_greeting() {
    return "Hello, World!";  // const char*로 추론
}

auto multiply(double a, double b) {
    return a * b;  // double로 추론
}

int main() {
    std::cout << add(10, 20) << "\n";
    std::cout << get_greeting() << "\n";
    std::cout << multiply(3.5, 2.0) << "\n";
    
    return 0;
}
```

**출력 결과:**
```
30
Hello, World!
7
```

**장점:**
- 타입 변경이 쉽다
- 복잡한 타입 이름을 쓰지 않아도 된다

**주의사항:**
- 모든 `return` 문이 같은 타입을 반환해야 한다
- 재귀 함수에서는 사용하기 어렵다
- 명시적인 타입이 가독성에 좋을 때도 있다

```cpp
// 오류 예제
auto bad_function(bool flag) {
    if (flag) {
        return 42;      // int
    } else {
        return 3.14;    // double - 오류!
    }
}
```

### 9.4.2 후행 반환 타입
후행 반환 타입(trailing return type)은 반환 타입을 함수 선언의 끝에 작성하는 문법이다.

```cpp
#include <iostream>

// 전통적 방식
int add_traditional(int a, int b) {
    return a + b;
}

// 후행 반환 타입
auto add_trailing(int a, int b) -> int {
    return a + b;
}

int main() {
    std::cout << add_traditional(10, 20) << "\n";
    std::cout << add_trailing(30, 40) << "\n";
    
    return 0;
}
```

**출력 결과:**
```
30
70
```

간단한 경우에는 별 차이가 없지만, 복잡한 타입이나 템플릿에서 유용하다.

**템플릿에서의 활용:**

```cpp
#include <iostream>
#include <vector>

// 후행 반환 타입으로 복잡한 타입 표현
template<typename Container>
auto get_first(Container& cont) -> decltype(cont[0]) {
    return cont[0];
}

int main() {
    std::vector<int> numbers = {10, 20, 30};
    std::cout << get_first(numbers) << "\n";
    
    return 0;
}
```

Modern C++에서는 `auto`와 후행 반환 타입을 조합하여 더 간결한 코드를 작성할 수 있다. 특히 템플릿 함수에서 강력하다.

### 9.4.3 `decltype`과 함께 사용
`decltype`은 표현식의 타입을 추론한다. 후행 반환 타입과 함께 사용하면 강력하다.

```cpp
#include <iostream>

template<typename T1, typename T2>
auto multiply(T1 a, T2 b) -> decltype(a * b) {
    return a * b;
}

int main() {
    std::cout << multiply(10, 20) << "\n";        // int * int = int
    std::cout << multiply(3.5, 2) << "\n";        // double * int = double
    std::cout << multiply(2, 3.14) << "\n";       // int * double = double
    
    return 0;
}
```

**출력 결과:**
```
200
7
6.28
```

C++14부터는 `decltype(auto)`를 사용하여 더 간결하게 작성할 수 있다.

```cpp
template<typename T1, typename T2>
decltype(auto) multiply(T1 a, T2 b) {
    return a * b;
}
```
   

</br>  
</br>  

  
## 9.5 지역 변수와 전역 변수
변수의 범위(scope)와 수명(lifetime)을 이해하는 것은 매우 중요하다.

### 9.5.1 지역 변수
함수 내부에서 선언된 변수는 지역 변수다. 함수가 호출될 때 생성되고, 함수가 종료되면 소멸된다.

```cpp
#include <iostream>

void func() {
    int local_var = 100;  // 지역 변수
    std::cout << "함수 내부: " << local_var << "\n";
}

int main() {
    func();
    // std::cout << local_var << "\n";  // 오류! local_var는 여기서 사용 불가
    
    return 0;
}
```

**블록 범위**

중괄호 `{}` 내에서 선언된 변수는 그 블록 내에서만 유효하다.

```cpp
#include <iostream>

int main() {
    int x = 10;
    
    {
        int y = 20;
        std::cout << "블록 내부: x = " << x << ", y = " << y << "\n";
    }
    
    std::cout << "블록 외부: x = " << x << "\n";
    // std::cout << y << "\n";  // 오류! y는 여기서 사용 불가
    
    return 0;
}
```

**출력 결과:**
```
블록 내부: x = 10, y = 20
블록 외부: x = 10
```

**변수 가리기 (Variable Shadowing)**

같은 이름의 변수가 다른 범위에 있으면 안쪽 범위의 변수가 바깥쪽 변수를 가린다.

```cpp
#include <iostream>

int main() {
    int x = 10;
    
    {
        int x = 20;  // 바깥쪽 x를 가림
        std::cout << "안쪽 x: " << x << "\n";
    }
    
    std::cout << "바깥쪽 x: " << x << "\n";
    
    return 0;
}
```

**출력 결과:**
```
안쪽 x: 20
바깥쪽 x: 10
```

이런 상황은 혼란을 일으킬 수 있으므로 피하는 것이 좋다.

### 9.5.2 전역 변수
함수 밖에서 선언된 변수는 전역 변수다. 프로그램 전체에서 접근할 수 있다.

```cpp
#include <iostream>

int global_var = 100;  // 전역 변수

void func1() {
    std::cout << "func1: " << global_var << "\n";
    global_var = 200;
}

void func2() {
    std::cout << "func2: " << global_var << "\n";
}

int main() {
    std::cout << "main 시작: " << global_var << "\n";
    func1();
    func2();
    
    return 0;
}
```

**출력 결과:**
```
main 시작: 100
func1: 100
func2: 200
```

**전역 변수의 문제점:**

1. **예측 불가능**: 어디서든 값을 변경할 수 있어 디버깅이 어렵다.
2. **의존성**: 함수들이 전역 변수에 의존하면 재사용하기 어렵다.
3. **테스트 어려움**: 전역 상태는 테스트를 복잡하게 만든다.
4. **멀티스레딩 문제**: 여러 스레드에서 동시에 접근하면 문제가 발생한다.

**Modern C++에서의 권장사항:**

전역 변수는 가능한 한 피하고, 다음과 같은 대안을 사용한다.

- 함수 매개변수로 전달
- 클래스 멤버 변수 사용
- `const` 전역 상수는 허용
- `namespace`로 캡슐화

```cpp
#include <iostream>

// 전역 상수는 괜찮음
const double PI = 3.14159;

// namespace로 캡슐화
namespace Config {
    int max_users = 100;
    std::string app_name = "MyApp";
}

int main() {
    std::cout << "PI: " << PI << "\n";
    std::cout << "최대 사용자: " << Config::max_users << "\n";
    
    return 0;
}
```

### 9.5.3 정적 변수
`static` 키워드를 사용하면 변수의 수명을 연장할 수 있다.

**정적 지역 변수**

함수 내부의 정적 변수는 프로그램이 시작될 때 한 번만 초기화되고, 함수가 종료되어도 값이 유지된다.

```cpp
#include <iostream>

void count_calls() {
    static int count = 0;  // 정적 지역 변수
    ++count;
    std::cout << "호출 횟수: " << count << "\n";
}

int main() {
    count_calls();
    count_calls();
    count_calls();
    
    return 0;
}
```

**출력 결과:**
```
호출 횟수: 1
호출 횟수: 2
호출 횟수: 3
```

정적 지역 변수는 함수 호출 간에 상태를 유지해야 할 때 유용하다. 하지만 역시 전역 상태와 비슷한 문제를 일으킬 수 있으므로 신중하게 사용해야 한다.

**실용적 예제: ID 생성기**

```cpp
#include <iostream>

int generate_id() {
    static int next_id = 1000;
    return next_id++;
}

int main() {
    std::cout << "ID 1: " << generate_id() << "\n";
    std::cout << "ID 2: " << generate_id() << "\n";
    std::cout << "ID 3: " << generate_id() << "\n";
    
    return 0;
}
```

**출력 결과:**
```
ID 1: 1000
ID 2: 1001
ID 3: 1002
```

### 9.5.4 constexpr 함수
`constexpr` 함수는 컴파일 타임에 평가될 수 있는 함수다. 상수 표현식이 필요한 곳에서 사용할 수 있다.

```cpp
#include <iostream>
#include <array>

constexpr int square(int n) {
    return n * n;
}

constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

int main() {
    // 컴파일 타임에 계산
    constexpr int result1 = square(5);
    constexpr int result2 = factorial(5);
    
    // 배열 크기로 사용 가능
    std::array<int, square(3)> arr;  // 크기 9인 배열
    
    std::cout << "5의 제곱: " << result1 << "\n";
    std::cout << "5!: " << result2 << "\n";
    std::cout << "배열 크기: " << arr.size() << "\n";
    
    // 런타임 값으로도 사용 가능
    int x = 7;
    std::cout << "7의 제곱: " << square(x) << "\n";
    
    return 0;
}
```

**출력 결과:**
```
5의 제곱: 25
5!: 120
배열 크기: 9
7의 제곱: 49
```

`constexpr` 함수는 성능 향상과 타입 안전성에 도움이 된다.
   

</br>  
</br>  
  
  
## 9.6 실습 문제

### 문제 1: 온도 변환기
섭씨와 화씨를 서로 변환하는 함수들을 작성하라.

**요구사항:**
- `double celsius_to_fahrenheit(double celsius)`
- `double fahrenheit_to_celsius(double fahrenheit)`
- 공식: F = C × 9/5 + 32

**예상 출력:**
```
섭씨 0도 = 화씨 32도
화씨 100도 = 섭씨 37.7778도
```

### 문제 2: 소수 판별 함수
정수가 소수인지 판별하는 함수를 작성하라.

**요구사항:**
- `bool is_prime(int n)`
- 2부터 √n까지만 검사하여 최적화
- 1과 음수는 소수가 아님

**예상 출력:**
```
17은 소수입니다.
24는 소수가 아닙니다.
```

### 문제 3: 문자열 처리 함수
다음 함수들을 작성하라.

**요구사항:**
- `int count_vowels(const std::string& str)` - 모음 개수 세기
- `std::string reverse_string(std::string str)` - 문자열 뒤집기
- `bool is_palindrome(const std::string& str)` - 회문 판별

**예상 출력:**
```
"Hello World"의 모음 개수: 3
"Hello"를 뒤집으면: "olleH"
"level"은 회문입니다.
```

### 문제 4: 벡터 연산 함수
벡터를 다루는 다음 함수들을 작성하라.

**요구사항:**
- `double get_average(const std::vector<int>& vec)` - 평균 계산
- `int get_max(const std::vector<int>& vec)` - 최댓값 찾기
- `void remove_negatives(std::vector<int>& vec)` - 음수 제거

### 문제 5: 계산기 함수
사칙연산 계산기를 함수 오버로딩으로 구현하라.

**요구사항:**
- 정수와 실수 모두 지원
- `calculate(int a, int b, char op)` - 정수 연산
- `calculate(double a, double b, char op)` - 실수 연산
- 연산자: '+', '-', '*', '/'
   

</br>  
</br>  
  
  
## 9.7 심화 내용

### 9.7.1 인라인 함수
`inline` 키워드는 컴파일러에게 함수 호출 대신 함수 본문을 직접 삽입하도록 힌트를 준다.

```cpp
#include <iostream>

inline int max(int a, int b) {
    return (a > b) ? a : b;
}

int main() {
    int result = max(10, 20);  // 함수 호출 오버헤드 없이 직접 코드 삽입
    std::cout << result << "\n";
    
    return 0;
}
```

**Modern C++에서의 인라인:**

- 짧고 자주 호출되는 함수에 유용
- 컴파일러가 자동으로 최적화하므로 명시적 `inline`은 덜 중요
- 헤더 파일에서 함수를 정의할 때 중요 (중복 정의 방지)

### 9.7.2 함수 템플릿 미리보기
템플릿을 사용하면 타입에 무관한 범용 함수를 만들 수 있다.

```cpp
#include <iostream>

template<typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << max(10, 20) << "\n";          // int
    std::cout << max(3.14, 2.71) << "\n";      // double
    std::cout << max('a', 'z') << "\n";        // char
    
    return 0;
}
```

**출력 결과:**
```
20
3.14
z
```

템플릿은 Chapter 16에서 자세히 다룬다.

### 9.7.3 [[nodiscard]] 속성 (C++17)
`[[nodiscard]]` 속성은 함수의 반환 값을 무시하면 경고를 발생시킨다.

```cpp
#include <iostream>

[[nodiscard]] int calculate_important_value() {
    return 42;
}

int main() {
    // 경고 발생: 반환 값을 사용하지 않음
    calculate_important_value();
    
    // 올바른 사용
    int result = calculate_important_value();
    std::cout << result << "\n";
    
    return 0;
}
```

이 속성은 오류를 방지하는 데 도움이 된다. 특히 리소스 할당이나 오류 코드를 반환하는 함수에 유용하다.

### 9.7.4 함수 포인터와 std::function
함수를 변수에 저장하고 전달할 수 있다. `std::function`은 Modern C++에서 권장되는 방식이다.

```cpp
#include <iostream>
#include <functional>

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

void apply_operation(int x, int y, std::function<int(int, int)> op) {
    std::cout << "결과: " << op(x, y) << "\n";
}

int main() {
    apply_operation(10, 5, add);
    apply_operation(10, 5, multiply);
    
    // 람다도 사용 가능 (Chapter 10에서 자세히)
    apply_operation(10, 5, [](int a, int b) { return a - b; });
    
    return 0;
}
```

**출력 결과:**
```
결과: 15
결과: 50
결과: 5
```

### 9.7.5 가변 인자 템플릿 (Variadic Templates)
C++11부터 임의 개수의 인자를 받는 함수를 만들 수 있다.

```cpp
#include <iostream>

// 재귀 종료 조건
void print() {
    std::cout << "\n";
}

// 가변 인자 템플릿
template<typename T, typename... Args>
void print(T first, Args... args) {
    std::cout << first << " ";
    print(args...);  // 재귀 호출
}

int main() {
    print(1, 2, 3, 4, 5);
    print("Hello", "World", 2023);
    print(3.14, "pi", 'π');
    
    return 0;
}
```

**출력 결과:**
```
1 2 3 4 5
Hello World 2023
3.14 pi π
```

### 9.7.6 consteval 함수 (C++20)
`consteval`은 함수가 반드시 컴파일 타임에 평가되도록 강제한다.

```cpp
#include <iostream>

consteval int square(int n) {
    return n * n;
}

int main() {
    constexpr int result = square(5);  // OK: 컴파일 타임 상수
    std::cout << result << "\n";
    
    // int x = 5;
    // int result2 = square(x);  // 오류! 런타임 값 사용 불가
    
    return 0;
}
```

`consteval`은 `constexpr`보다 엄격하며, 컴파일 타임 계산을 보장해야 할 때 사용한다.
   

</br>  
</br>  
  

## 정리
이번 장에서는 함수의 기본 개념부터 Modern C++의 고급 기능까지 배웠다.

- **함수 기본**: 함수는 코드를 재사용 가능한 블록으로 만들어 프로그램을 구조화한다.

- **매개변수 전달**: 값 전달, 참조 전달, 포인터 전달 각각의 특징을 이해하고 적절히 사용해야 한다. Modern C++에서는 `const` 참조를 많이 사용한다.

- **기본 매개변수와 오버로딩**: 함수를 더 유연하게 만들어 다양한 상황에 대응할 수 있다.

- **`auto` 반환 타입**: 컴파일러의 타입 추론을 활용하여 코드를 간결하게 만들 수 있다.

- **변수 범위**: 지역 변수를 선호하고 전역 변수는 피해야 한다. 필요하다면 `const` 전역 상수나 `namespace`를 사용한다.

함수를 잘 설계하면 코드의 재사용성, 가독성, 유지보수성이 크게 향상된다. Modern C++의 기능들을 활용하면 더 안전하고 표현력 있는 함수를 작성할 수 있다.

다음 장에서는 함수를 더욱 강력하게 만드는 람다 표현식을 배운다. 람다는 익명 함수를 간결하게 작성할 수 있게 해주며, 특히 알고리즘이나 이벤트 처리에서 매우 유용하다.


 