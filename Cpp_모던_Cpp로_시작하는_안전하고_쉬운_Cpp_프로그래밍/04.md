# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 4: 연산자와 표현식
프로그래밍에서 연산자(operator)는 데이터를 처리하고 조작하는 핵심 도구다. 변수에 저장된 값들을 더하고, 비교하고, 논리적으로 판단하는 모든 작업이 연산자를 통해 이루어진다. 이번 챕터에서는 C++의 다양한 연산자들을 학습하고, 이들을 조합하여 의미 있는 표현식(expression)을 만드는 방법을 배운다.

## 4.1 산술 연산자
산술 연산자는 수학적 계산을 수행하는 가장 기본적인 연산자다. C++은 다섯 가지 기본 산술 연산자를 제공한다.

### 기본 산술 연산자

```cpp
#include <iostream>
#include <format>

int main()
{
    int a = 10;
    int b = 3;

    // 덧셈
    int sum = a + b;
    std::cout << std::format("{} + {} = {}\n", a, b, sum);

    // 뺄셈
    int difference = a - b;
    std::cout << std::format("{} - {} = {}\n", a, b, difference);

    // 곱셈
    int product = a * b;
    std::cout << std::format("{} * {} = {}\n", a, b, product);

    // 나눗셈
    int quotient = a / b;
    std::cout << std::format("{} / {} = {}\n", a, b, quotient);

    // 나머지
    int remainder = a % b;
    std::cout << std::format("{} % {} = {}\n", a, b, remainder);
}
```

**출력:**
```
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3
10 % 3 = 1
```

위 예제에서 주목할 점은 정수 나눗셈의 결과다. `10 / 3`의 결과가 `3.333...`이 아닌 `3`으로 나온다. 이는 정수끼리의 나눗셈은 항상 정수 결과를 반환하며, 소수점 이하는 버려지기 때문이다.

### 실수 연산과 정밀도
실수 계산이 필요할 때는 `double` 또는 `float` 타입을 사용한다.

```cpp
#include <iostream>
#include <format>

int main()
{
    double x = 10.0;
    double y = 3.0;

    double result = x / y;
    std::cout << std::format("{} / {} = {:.6f}\n", x, y, result);

    // 정수를 실수로 변환하여 계산
    int a = 10;
    int b = 3;
    double precise_result = static_cast<double>(a) / b;
    std::cout << std::format("{} / {} = {:.6f}\n", a, b, precise_result);
}
```

**출력:**
```
10.000000 / 3.000000 = 3.333333
10 / 3 = 3.333333
```

`static_cast<double>()`을 사용하여 정수를 실수로 명시적으로 변환하면 정밀한 계산이 가능하다.

### 나머지 연산자의 활용
나머지 연산자(`%`)는 정수에만 사용할 수 있으며, 다양한 프로그래밍 패턴에서 유용하게 활용된다.

```cpp
#include <iostream>
#include <format>

int main()
{
    // 짝수/홀수 판별
    int number = 42;
    if (number % 2 == 0)
    {
        std::cout << std::format("{}는 짝수다\n", number);
    }

    // 순환 인덱스 (배열의 끝에서 다시 처음으로)
    int index = 0;
    for (int i = 0; i < 10; ++i)
    {
        std::cout << std::format("현재 인덱스: {}\n", index);
        index = (index + 1) % 5;  // 0, 1, 2, 3, 4, 0, 1, ...
    }

    // 특정 배수 확인
    int value = 15;
    if (value % 5 == 0)
    {
        std::cout << std::format("{}는 5의 배수다\n", value);
    }
}
```

### 증감 연산자
증감 연산자는 변수의 값을 1씩 증가시키거나 감소시키는 특수한 연산자다.

```cpp
#include <iostream>
#include <format>

int main()
{
    int x = 5;

    // 후위 증가: 현재 값을 먼저 사용한 후 증가
    int y = x++;
    std::cout << std::format("x++: x = {}, y = {}\n", x, y);

    x = 5;  // 초기화

    // 전위 증가: 먼저 증가한 후 값을 사용
    y = ++x;
    std::cout << std::format("++x: x = {}, y = {}\n", x, y);

    // 감소 연산자도 동일한 원리
    int a = 10;
    int b = a--;
    std::cout << std::format("a--: a = {}, b = {}\n", a, b);

    a = 10;
    b = --a;
    std::cout << std::format("--a: a = {}, b = {}\n", a, b);
}
```

**출력:**
```
x++: x = 6, y = 5
++x: x = 6, y = 6
a--: a = 9, b = 10
--a: a = 9, b = 9
```

Modern C++에서는 가독성을 위해 증감 연산자를 별도의 문장으로 분리하는 것을 권장한다.

```cpp
// 권장하지 않는 방식
int result = ++x * 2;

// 권장하는 방식
++x;
int result = x * 2;
```
  

</br>  
</br>  


## 4.2 비교 연산자
비교 연산자는 두 값을 비교하여 `true` 또는 `false`를 반환한다. 조건문과 반복문에서 핵심적인 역할을 한다.

### 기본 비교 연산자

```cpp
#include <iostream>
#include <format>

int main()
{
    int a = 10;
    int b = 20;

    // 동등 비교
    bool is_equal = (a == b);
    std::cout << std::format("{} == {}: {}\n", a, b, is_equal);

    // 부등 비교
    bool is_not_equal = (a != b);
    std::cout << std::format("{} != {}: {}\n", a, b, is_not_equal);

    // 크기 비교
    bool is_less = (a < b);
    std::cout << std::format("{} < {}: {}\n", a, b, is_less);

    bool is_greater = (a > b);
    std::cout << std::format("{} > {}: {}\n", a, b, is_greater);

    // 이상/이하 비교
    bool is_less_equal = (a <= b);
    std::cout << std::format("{} <= {}: {}\n", a, b, is_less_equal);

    bool is_greater_equal = (a >= b);
    std::cout << std::format("{} >= {}: {}\n", a, b, is_greater_equal);
}
```

**출력:**
```
10 == 20: false
10 != 20: true
10 < 20: true
10 > 20: false
10 <= 20: true
10 >= 20: false
```

### 실수 비교의 주의사항
실수를 비교할 때는 부동소수점 연산의 특성상 직접 `==` 연산자를 사용하는 것이 위험하다.

```cpp
#include <iostream>
#include <format>
#include <cmath>

int main()
{
    double a = 0.1 + 0.2;
    double b = 0.3;

    // 위험한 비교
    if (a == b)
    {
        std::cout << "같다\n";
    }
    else
    {
        std::cout << std::format("다르다: a = {:.20f}, b = {:.20f}\n", a, b);
    }

    // 안전한 비교: 오차 범위 내에서 비교
    double epsilon = 1e-9;
    if (std::abs(a - b) < epsilon)
    {
        std::cout << "충분히 가깝다 (같다고 볼 수 있다)\n";
    }
}
```

**출력:**
```
다르다: a = 0.30000000000000004441, b = 0.29999999999999998890
충분히 가깝다 (같다고 볼 수 있다)
```

### 문자열 비교
`std::string`은 비교 연산자를 지원하며, 사전식 순서로 비교한다.

```cpp
#include <iostream>
#include <format>
#include <string>

int main()
{
    std::string str1 = "apple";
    std::string str2 = "banana";

    if (str1 < str2)
    {
        std::cout << std::format("\"{}\"가 \"{}\"보다 사전순으로 앞선다\n", str1, str2);
    }

    std::string name1 = "Alice";
    std::string name2 = "alice";

    if (name1 == name2)
    {
        std::cout << "같은 이름\n";
    }
    else
    {
        std::cout << std::format("다른 이름 (대소문자 구분)\n");
    }
}
```

**출력:**
```
"apple"가 "banana"보다 사전순으로 앞선다
다른 이름 (대소문자 구분)
```
   

</br>  
</br>  


## 4.3 논리 연산자
논리 연산자는 불린 값들을 조합하여 복잡한 조건을 표현한다.

### 기본 논리 연산자

```cpp
#include <iostream>
#include <format>

int main()
{
    bool sunny = true;
    bool warm = true;
    bool have_time = false;

    // AND 연산자 (&&): 모두 true일 때만 true
    bool can_go_picnic = sunny && warm && have_time;
    std::cout << std::format("소풍 갈 수 있나? {}\n", can_go_picnic);

    // OR 연산자 (||): 하나라도 true면 true
    bool need_umbrella = !sunny || !warm;
    std::cout << std::format("우산이 필요한가? {}\n", need_umbrella);

    // NOT 연산자 (!): 불린 값을 반대로
    bool stay_home = !have_time;
    std::cout << std::format("집에 있어야 하나? {}\n", stay_home);
}
```

**출력:**
```
소풍 갈 수 있나? false
우산이 필요한가? false
집에 있어야 하나? true
```

### 단락 평가 (Short-circuit Evaluation)
C++의 논리 연산자는 단락 평가를 수행한다. 즉, 결과가 확정되면 나머지 조건을 평가하지 않는다.

```cpp
#include <iostream>
#include <format>

bool check_positive(int value)
{
    std::cout << std::format("check_positive({}) 호출\n", value);
    return value > 0;
}

bool check_even(int value)
{
    std::cout << std::format("check_even({}) 호출\n", value);
    return value % 2 == 0;
}

int main()
{
    int number = -5;

    std::cout << "=== AND 연산 ===\n";
    if (check_positive(number) && check_even(number))
    {
        std::cout << "양수이면서 짝수\n";
    }
    // check_positive가 false이므로 check_even은 호출되지 않음

    std::cout << "\n=== OR 연산 ===\n";
    number = 10;
    if (check_positive(number) || check_even(number))
    {
        std::cout << "양수이거나 짝수\n";
    }
    // check_positive가 true이므로 check_even은 호출되지 않음
}
```

**출력:**
```
=== AND 연산 ===
check_positive(-5) 호출

=== OR 연산 ===
check_positive(10) 호출
양수이거나 짝수
```

단락 평가는 성능 최적화뿐만 아니라 안전한 코드 작성에도 유용하다.

```cpp
#include <iostream>
#include <vector>
#include <format>

int main()
{
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    int index = 10;

    // 안전한 접근: index가 범위 내에 있을 때만 값을 확인
    if (index >= 0 && index < numbers.size() && numbers[index] > 3)
    {
        std::cout << "조건 만족\n";
    }
    else
    {
        std::cout << "조건 불만족 또는 범위 초과\n";
    }
    // index < numbers.size()가 false이므로 numbers[index]는 평가되지 않아 안전
}
```

### 복잡한 조건 표현
여러 논리 연산자를 조합할 때는 괄호를 사용하여 명확하게 표현하는 것이 좋다.

```cpp
#include <iostream>
#include <format>

int main()
{
    int age = 25;
    bool has_license = true;
    bool has_car = false;
    int years_experience = 3;

    // 괄호로 조건을 명확하게 그룹화
    bool can_drive = (age >= 18 && has_license) && 
                     (has_car || years_experience >= 2);

    std::cout << std::format("운전 가능: {}\n", can_drive);

    // 복잡한 조건은 변수로 분리하여 가독성 향상
    bool is_eligible_age = (age >= 18);
    bool has_driving_right = (has_license);
    bool has_vehicle_access = (has_car || years_experience >= 2);

    can_drive = is_eligible_age && has_driving_right && has_vehicle_access;
    std::cout << std::format("운전 가능 (개선): {}\n", can_drive);
}
```
   

</br>  
</br>  
  

## 4.4 대입 연산자와 복합 대입 연산자
대입 연산자는 변수에 값을 저장하는 기본 연산자다. C++은 산술 연산과 대입을 결합한 복합 대입 연산자도 제공한다.

### 기본 대입 연산자

```cpp
#include <iostream>
#include <format>

int main()
{
    int x = 10;  // 초기화
    int y;

    y = x;  // 대입
    std::cout << std::format("y = {}\n", y);

    // 대입 연산자는 값을 반환하므로 연쇄 대입 가능
    int a, b, c;
    a = b = c = 100;
    std::cout << std::format("a = {}, b = {}, c = {}\n", a, b, c);
}
```

### 복합 대입 연산자
복합 대입 연산자는 코드를 간결하게 만들고 의도를 명확히 전달한다.

```cpp
#include <iostream>
#include <format>

int main()
{
    int score = 100;

    // 덧셈 후 대입
    score += 50;  // score = score + 50과 동일
    std::cout << std::format("점수: {}\n", score);

    // 뺄셈 후 대입
    score -= 30;  // score = score - 30과 동일
    std::cout << std::format("점수: {}\n", score);

    // 곱셈 후 대입
    score *= 2;  // score = score * 2와 동일
    std::cout << std::format("점수: {}\n", score);

    // 나눗셈 후 대입
    score /= 4;  // score = score / 4와 동일
    std::cout << std::format("점수: {}\n", score);

    // 나머지 후 대입
    score %= 50;  // score = score % 50과 동일
    std::cout << std::format("점수: {}\n", score);
}
```

**출력:**
```
점수: 150
점수: 120
점수: 240
점수: 60
점수: 10
```

### 실용적인 활용 예제

```cpp
#include <iostream>
#include <format>
#include <vector>

int main()
{
    // 게임 스코어 계산
    int player_score = 0;
    
    player_score += 100;  // 적 처치
    std::cout << std::format("적 처치! 점수: {}\n", player_score);
    
    player_score += 50;   // 아이템 획득
    std::cout << std::format("아이템 획득! 점수: {}\n", player_score);
    
    player_score *= 2;    // 보너스 타임
    std::cout << std::format("보너스 타임! 점수: {}\n", player_score);

    // 벡터의 크기 조정
    std::vector<int> inventory;
    inventory.reserve(10);  // 초기 용량
    
    int items_to_add = 5;
    for (int i = 0; i < items_to_add; ++i)
    {
        inventory.push_back(i);
    }

    // 카운터 증가
    int enemy_count = 10;
    enemy_count -= 3;  // 3마리 처치
    std::cout << std::format("남은 적: {}\n", enemy_count);
}
```
  

</br>  
</br>  
  

## 4.5 연산자 우선순위와 괄호 사용
연산자는 각각 우선순위가 정해져 있으며, 이를 이해하는 것이 올바른 표현식 작성의 핵심이다.

### 기본 우선순위

```cpp
#include <iostream>
#include <format>

int main()
{
    // 곱셈이 덧셈보다 우선
    int result1 = 2 + 3 * 4;
    std::cout << std::format("2 + 3 * 4 = {}\n", result1);  // 14

    // 괄호로 우선순위 변경
    int result2 = (2 + 3) * 4;
    std::cout << std::format("(2 + 3) * 4 = {}\n", result2);  // 20

    // 나눗셈과 나머지 연산
    int result3 = 10 + 20 / 5 - 2;
    std::cout << std::format("10 + 20 / 5 - 2 = {}\n", result3);  // 12

    // 비교 연산자와 논리 연산자
    bool result4 = 5 > 3 && 10 < 20;
    std::cout << std::format("5 > 3 && 10 < 20 = {}\n", result4);  // true
}
```

**출력:**
```
2 + 3 * 4 = 14
(2 + 3) * 4 = 20
10 + 20 / 5 - 2 = 12
5 > 3 && 10 < 20 = true
```

### 주요 연산자 우선순위 표
연산자를 우선순위가 높은 순서대로 정리하면 다음과 같다.

1. **괄호**: `()`
2. **단항 연산자**: `++`, `--`, `!`, `-` (부호)
3. **산술 연산자**: `*`, `/`, `%` → `+`, `-`
4. **비교 연산자**: `<`, `<=`, `>`, `>=` → `==`, `!=`
5. **논리 연산자**: `&&` → `||`
6. **대입 연산자**: `=`, `+=`, `-=`, `*=`, `/=`, `%=`

### 명확한 코드를 위한 괄호 사용
우선순위를 외우는 것보다 괄호를 적극 활용하여 의도를 명확히 하는 것이 좋다.

```cpp
#include <iostream>
#include <format>

int main()
{
    int a = 10, b = 5, c = 2;

    // 우선순위에 의존 (권장하지 않음)
    int result1 = a + b * c - a / c;
    std::cout << std::format("결과1: {}\n", result1);

    // 괄호로 명확하게 표현 (권장)
    int result2 = a + (b * c) - (a / c);
    std::cout << std::format("결과2: {}\n", result2);

    // 복잡한 조건문
    bool x = true, y = false, z = true;

    // 헷갈리기 쉬운 표현
    bool condition1 = x || y && z;

    // 명확한 표현
    bool condition2 = x || (y && z);
    bool condition3 = (x || y) && z;

    std::cout << std::format("condition1: {}\n", condition1);  // true
    std::cout << std::format("condition2: {}\n", condition2);  // true
    std::cout << std::format("condition3: {}\n", condition3);  // true
}
```

### 실용적인 예제: 할인 계산기

```cpp
#include <iostream>
#include <format>

int main()
{
    double price = 50000.0;
    double discount_rate = 0.2;  // 20% 할인
    int quantity = 3;
    bool is_member = true;
    double member_extra_discount = 0.05;  // 회원 추가 5% 할인

    // 괄호를 사용한 명확한 계산
    double base_price = price * quantity;
    double discounted_price = base_price * (1.0 - discount_rate);
    
    double final_price;
    if (is_member)
    {
        final_price = discounted_price * (1.0 - member_extra_discount);
    }
    else
    {
        final_price = discounted_price;
    }

    std::cout << std::format("기본 가격: {:.0f}원\n", base_price);
    std::cout << std::format("할인 후 가격: {:.0f}원\n", discounted_price);
    std::cout << std::format("최종 가격: {:.0f}원\n", final_price);

    // 한 줄로 표현 (복잡하지만 가능)
    double final_price_oneline = price * quantity * (1.0 - discount_rate) * 
                                 (is_member ? (1.0 - member_extra_discount) : 1.0);
    std::cout << std::format("최종 가격 (한 줄): {:.0f}원\n", final_price_oneline);
}
```

**출력:**
```
기본 가격: 150000원
할인 후 가격: 120000원
최종 가격: 114000원
최종 가격 (한 줄): 114000원
```
   

</br>  
</br>  
  

## 4.6 실습 예제: 계산기 프로그램
지금까지 배운 연산자들을 활용하여 간단한 계산기를 만들어보자.

```cpp
#include <iostream>
#include <format>
#include <string>

int main()
{
    std::cout << "=== 간단한 계산기 ===\n\n";

    double num1, num2;
    char operation;

    std::cout << "첫 번째 숫자를 입력하세요: ";
    std::cin >> num1;

    std::cout << "연산자를 입력하세요 (+, -, *, /, %): ";
    std::cin >> operation;

    std::cout << "두 번째 숫자를 입력하세요: ";
    std::cin >> num2;

    double result = 0.0;
    bool valid_operation = true;

    if (operation == '+')
    {
        result = num1 + num2;
    }
    else if (operation == '-')
    {
        result = num1 - num2;
    }
    else if (operation == '*')
    {
        result = num1 * num2;
    }
    else if (operation == '/')
    {
        if (num2 != 0.0)
        {
            result = num1 / num2;
        }
        else
        {
            std::cout << "오류: 0으로 나눌 수 없다\n";
            valid_operation = false;
        }
    }
    else if (operation == '%')
    {
        // 나머지 연산은 정수만 가능
        if (static_cast<int>(num2) != 0)
        {
            result = static_cast<int>(num1) % static_cast<int>(num2);
        }
        else
        {
            std::cout << "오류: 0으로 나눌 수 없다\n";
            valid_operation = false;
        }
    }
    else
    {
        std::cout << "오류: 지원하지 않는 연산자다\n";
        valid_operation = false;
    }

    if (valid_operation)
    {
        std::cout << std::format("\n결과: {} {} {} = {}\n", 
                                num1, operation, num2, result);
    }
}
```
   

</br>  
</br>  
  
  
## 4.7 실습 문제

### 문제 1: 온도 변환기
섭씨 온도를 화씨로, 화씨를 섭씨로 변환하는 프로그램을 작성하라.
- 화씨 = 섭씨 × 9/5 + 32
- 섭씨 = (화씨 - 32) × 5/9

```cpp
#include <iostream>
#include <format>

int main()
{
    // 여기에 코드를 작성하라
    
    return 0;
}
```

**힌트**: 사용자에게 변환 방향을 선택하게 하고, 적절한 공식을 적용하라.

### 문제 2: BMI 계산기
키(cm)와 몸무게(kg)를 입력받아 BMI를 계산하고, 판정 결과를 출력하라.
- BMI = 몸무게(kg) / (키(m))²
- 18.5 미만: 저체중
- 18.5 ~ 23: 정상
- 23 ~ 25: 과체중
- 25 이상: 비만

```cpp
#include <iostream>
#include <format>

int main()
{
    // 여기에 코드를 작성하라
    
    return 0;
}
```

### 문제 3: 윤년 판정
연도를 입력받아 윤년인지 판정하는 프로그램을 작성하라.
- 4로 나누어떨어지면 윤년
- 단, 100으로 나누어떨어지면 평년
- 단, 400으로 나누어떨어지면 윤년

```cpp
#include <iostream>
#include <format>

int main()
{
    int year;
    std::cout << "연도를 입력하세요: ";
    std::cin >> year;

    // 여기에 윤년 판정 로직을 작성하라
    
    return 0;
}
```

**힌트**: 논리 연산자와 나머지 연산자를 조합하여 조건을 표현하라.

### 문제 4: 시간 계산기
두 시각을 입력받아 시간 차이를 계산하라. (시, 분, 초 단위로 입력)

```cpp
#include <iostream>
#include <format>

int main()
{
    int hour1, minute1, second1;
    int hour2, minute2, second2;

    std::cout << "첫 번째 시각 (시 분 초): ";
    std::cin >> hour1 >> minute1 >> second1;

    std::cout << "두 번째 시각 (시 분 초): ";
    std::cin >> hour2 >> minute2 >> second2;

    // 여기에 시간 차이 계산 로직을 작성하라
    // 힌트: 모든 시간을 초로 변환한 후 계산
    
    return 0;
}
```
  

</br>  
</br>  


## 4.8 심화 내용

### 비트 연산자
비트 연산자는 정수의 개별 비트를 조작한다. 저수준 프로그래밍이나 성능 최적화에 유용하다.

```cpp
#include <iostream>
#include <format>
#include <bitset>

int main()
{
    unsigned int a = 60;  // 0011 1100
    unsigned int b = 13;  // 0000 1101

    std::cout << std::format("a = {} ({})\n", a, std::bitset<8>(a).to_string());
    std::cout << std::format("b = {} ({})\n", b, std::bitset<8>(b).to_string());

    // AND 연산
    unsigned int and_result = a & b;  // 0000 1100 = 12
    std::cout << std::format("a & b = {} ({})\n", 
                            and_result, std::bitset<8>(and_result).to_string());

    // OR 연산
    unsigned int or_result = a | b;  // 0011 1101 = 61
    std::cout << std::format("a | b = {} ({})\n", 
                            or_result, std::bitset<8>(or_result).to_string());

    // XOR 연산
    unsigned int xor_result = a ^ b;  // 0011 0001 = 49
    std::cout << std::format("a ^ b = {} ({})\n", 
                            xor_result, std::bitset<8>(xor_result).to_string());

    // NOT 연산
    unsigned int not_result = ~a;
    std::cout << std::format("~a = {} ({})\n", 
                            not_result, std::bitset<8>(not_result).to_string());

    // 시프트 연산
    unsigned int left_shift = a << 2;  // 1111 0000 = 240
    std::cout << std::format("a << 2 = {} ({})\n", 
                            left_shift, std::bitset<8>(left_shift).to_string());

    unsigned int right_shift = a >> 2;  // 0000 1111 = 15
    std::cout << std::format("a >> 2 = {} ({})\n", 
                            right_shift, std::bitset<8>(right_shift).to_string());
}
```

### 비트 연산자의 실용적 활용

```cpp
#include <iostream>
#include <format>

// 플래그를 사용한 권한 관리
enum Permission : unsigned int
{
    NONE = 0,
    READ = 1 << 0,    // 0001
    WRITE = 1 << 1,   // 0010
    EXECUTE = 1 << 2, // 0100
    DELETE = 1 << 3   // 1000
};

int main()
{
    // 권한 부여
    unsigned int user_permission = READ | WRITE;
    std::cout << std::format("사용자 권한: {:04b}\n", user_permission);

    // 권한 확인
    if (user_permission & READ)
    {
        std::cout << "읽기 권한이 있다\n";
    }

    if (user_permission & EXECUTE)
    {
        std::cout << "실행 권한이 있다\n";
    }
    else
    {
        std::cout << "실행 권한이 없다\n";
    }

    // 권한 추가
    user_permission |= EXECUTE;
    std::cout << std::format("실행 권한 추가 후: {:04b}\n", user_permission);

    // 권한 제거
    user_permission &= ~WRITE;
    std::cout << std::format("쓰기 권한 제거 후: {:04b}\n", user_permission);

    // 빠른 2의 거듭제곱 곱셈/나눗셈
    int number = 10;
    int multiplied = number << 3;  // number * 8
    int divided = number >> 1;     // number / 2

    std::cout << std::format("{} * 8 = {}\n", number, multiplied);
    std::cout << std::format("{} / 2 = {}\n", number, divided);
}
```

### 삼항 연산자
삼항 연산자(`? :`)는 간단한 조건식을 한 줄로 표현할 때 유용하다.

```cpp
#include <iostream>
#include <format>

int main()
{
    int score = 85;

    // if-else 문
    std::string result1;
    if (score >= 60)
    {
        result1 = "합격";
    }
    else
    {
        result1 = "불합격";
    }

    // 삼항 연산자
    std::string result2 = (score >= 60) ? "합격" : "불합격";

    std::cout << std::format("결과: {}\n", result2);

    // 중첩된 삼항 연산자 (권장하지 않음)
    std::string grade = (score >= 90) ? "A" :
                       (score >= 80) ? "B" :
                       (score >= 70) ? "C" :
                       (score >= 60) ? "D" : "F";

    std::cout << std::format("학점: {}\n", grade);

    // 값 선택
    int a = 10, b = 20;
    int max_value = (a > b) ? a : b;
    std::cout << std::format("최댓값: {}\n", max_value);

    // 함수 호출 선택
    int age = 15;
    std::string message = (age >= 18) ? "성인입니다" : "미성년자입니다";
    std::cout << message << "\n";
}
```

### comma 연산자
comma 연산자(`,`)는 여러 표현식을 순차적으로 평가하고 마지막 표현식의 값을 반환한다. 실무에서는 거의 사용하지 않지만, for 문에서 가끔 활용된다.

```cpp
#include <iostream>
#include <format>

int main()
{
    int a = 1, b = 2, c = 3;

    // comma 연산자: 왼쪽부터 오른쪽으로 평가하고 마지막 값 반환
    int result = (a++, b++, c++);
    std::cout << std::format("a={}, b={}, c={}, result={}\n", a, b, c, result);

    // for 문에서의 활용
    for (int i = 0, j = 10; i < j; ++i, --j)
    {
        std::cout << std::format("i={}, j={}\n", i, j);
        if (i >= 3) break;
    }
}
```

**출력:**
```
a=2, b=3, c=4, result=4
i=0, j=10
i=1, j=9
i=2, j=8
i=3, j=7
```

### sizeof 연산자
`sizeof` 연산자는 타입이나 변수의 크기를 바이트 단위로 반환한다.

```cpp
#include <iostream>
#include <format>
#include <vector>

int main()
{
    std::cout << std::format("int 크기: {} bytes\n", sizeof(int));
    std::cout << std::format("double 크기: {} bytes\n", sizeof(double));
    std::cout << std::format("char 크기: {} bytes\n", sizeof(char));
    std::cout << std::format("bool 크기: {} bytes\n", sizeof(bool));

    int array[10];
    std::cout << std::format("배열 크기: {} bytes\n", sizeof(array));
    std::cout << std::format("배열 원소 개수: {}\n", 
                            sizeof(array) / sizeof(array[0]));

    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::cout << std::format("vector 객체 크기: {} bytes\n", sizeof(vec));
    std::cout << std::format("vector 원소 개수: {}\n", vec.size());
}
```
   

</br>  
</br>  
  

## 정리
이번 챕터에서는 C++의 다양한 연산자들을 학습했다. 산술 연산자로 기본 계산을 수행하고, 비교 연산자로 값을 비교하며, 논리 연산자로 복잡한 조건을 표현하는 방법을 배웠다. 복합 대입 연산자는 코드를 간결하게 만들어주고, 연산자 우선순위를 이해하면 올바른 표현식을 작성할 수 있다.

Modern C++에서는 이러한 기본 연산자들을 타입 안전하게 사용하는 것이 중요하다. `static_cast`를 통한 명시적 타입 변환, `std::format`을 통한 안전한 출력, 그리고 괄호를 활용한 명확한 표현식 작성이 핵심이다.

다음 챕터에서는 이러한 연산자들을 활용하여 사용자로부터 데이터를 입력받고 출력하는 방법을 자세히 배운다. 특히 C++20/C++23의 `std::format`을 중심으로 현대적인 입출력 방식을 익힐 것이다.   