# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 18: Siv3D 환경 구축과 첫 GUI
지금까지 콘솔 프로그램으로 C++의 핵심 기능들을 배웠다. 이제부터는 Siv3D 라이브러리를 사용하여 시각적이고 실용적인 프로그램을 만들어본다. Siv3D는 2D/3D 그래픽, 사운드, 입력 처리 등을 쉽게 다룰 수 있게 해주는 C++ 라이브러리다. Modern C++의 기능을 최대한 활용하여 설계되었으며, 초보자도 쉽게 멋진 프로그램을 만들 수 있다.

## 18.1 Siv3D 라이브러리 소개 및 설치

### 18.1.1 Siv3D란?
Siv3D(OpenSiv3D)는 일본에서 개발된 오픈소스 C++ 프레임워크로, 다음과 같은 특징을 가지고 있다.

- **Modern C++ 기반**: C++20 이상의 최신 기능을 적극 활용한다
- **크로스 플랫폼**: Windows, macOS, Linux, Web을 지원한다
- **풍부한 기능**: 그래픽, 사운드, 네트워킹, 이미지 처리 등을 제공한다
- **직관적인 API**: 간결하고 읽기 쉬운 코드로 복잡한 기능을 구현할 수 있다
- **무료 및 오픈소스**: MIT 라이선스로 자유롭게 사용할 수 있다

Siv3D는 게임, 시각화 도구, 교육용 프로그램, 인터랙티브 아트 등 다양한 분야에서 활용된다.

### 18.1.2 Visual Studio 2022에 Siv3D 설치하기
Siv3D v0.6.16을 Visual Studio 2022에 설치하는 과정을 단계별로 설명한다.

**1단계: Visual Studio 2022 준비**

Visual Studio 2022가 설치되어 있고, "C++를 사용한 데스크톱 개발" 워크로드가 설치되어 있는지 확인한다. Chapter 2에서 이미 설정했다면 이 단계는 건너뛴다.

**2단계: Siv3D 프로젝트 템플릿 다운로드**

1. 웹 브라우저에서 OpenSiv3D 공식 웹사이트(https://siv3d.github.io)를 방문한다
2. "Downloads" 섹션에서 "OpenSiv3D v0.6.16 for Windows"를 찾는다
3. "Visual Studio 2022용 프로젝트 템플릿"을 다운로드한다

**3단계: 프로젝트 템플릿 설치**

1. 다운로드한 ZIP 파일의 압축을 푼다
2. `OpenSiv3D_0.6.16` 폴더가 생성된다
3. 이 폴더를 원하는 위치에 보관한다 (예: `C:\Dev\Siv3D\`)

**4단계: 첫 Siv3D 프로젝트 생성**

1. Visual Studio 2022를 실행한다
2. "새 프로젝트 만들기"를 선택한다
3. 검색창에 "Empty Project"를 입력하고 "빈 프로젝트"를 선택한다
4. 프로젝트 이름을 입력한다 (예: `FirstSiv3DApp`)
5. 위치를 `OpenSiv3D_0.6.16` 폴더 안으로 지정한다
6. "만들기"를 클릭한다

**5단계: Siv3D 설정 적용**

1. 솔루션 탐색기에서 프로젝트를 마우스 오른쪽 버튼으로 클릭한다
2. "속성"을 선택한다
3. 구성을 "모든 구성"으로 변경한다
4. 다음 설정을 적용한다:

**C/C++ → 일반**
- 추가 포함 디렉터리: `$(SolutionDir)Siv3D\include`

**링커 → 일반**
- 추가 라이브러리 디렉터리: `$(SolutionDir)Siv3D\lib\Windows\$(Platform)\$(Configuration)`

**링커 → 입력**
- Debug 구성: `Siv3D_d.lib` 추가
- Release 구성: `Siv3D.lib` 추가

**6단계: 간편 설정 스크립트 사용 (권장)**

OpenSiv3D는 설정을 자동화하는 방법을 제공한다. 프로젝트 템플릿을 사용하면 이러한 설정이 자동으로 적용되므로, 실제로는 다음과 같이 진행한다:

1. `OpenSiv3D_0.6.16` 폴더 안의 `WindowsDesktop` 폴더를 연다
2. `App` 폴더를 복사하여 원하는 위치에 붙여넣는다
3. 복사한 폴더의 이름을 프로젝트 이름으로 변경한다 (예: `FirstSiv3DApp`)
4. `App.sln` 파일을 Visual Studio 2022로 연다
5. `Main.cpp`를 확인한다

### 18.1.3 설치 확인
설치가 제대로 되었는지 확인하기 위해 간단한 프로그램을 실행해본다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 윈도우 제목 설정
    Window::SetTitle(U"Siv3D 설치 확인");
    
    // 메인 루프
    while (System::Update())
    {
        // 화면을 하늘색으로 채운다
        Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });
        
        // 텍스트 출력
        Font font{ FontMethod::MSDF, 48, Typeface::CJK_Regular_KR };
        font(U"Siv3D가 정상적으로 작동합니다!").drawAt(Scene::Center(), Palette::Black);
    }
}
```

이 코드를 `Main.cpp`에 입력하고 F5를 눌러 실행한다. 윈도우가 열리고 텍스트가 표시되면 설치가 성공한 것이다.

**문제 해결:**

만약 컴파일 오류가 발생한다면:
1. Visual Studio의 플랫폼이 x64로 설정되어 있는지 확인한다
2. C++ 언어 표준이 C++20 이상으로 설정되어 있는지 확인한다
3. 프로젝트 속성에서 Siv3D 경로가 올바르게 설정되어 있는지 확인한다

  
</br>  
  

## 18.2 기본 윈도우 생성과 그래픽 출력

### 18.2.1 Siv3D 프로그램의 기본 구조
Siv3D 프로그램은 `Main()` 함수에서 시작한다. 일반 C++ 프로그램의 `main()` 함수와 달리 반환 타입이 `void`다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 초기화 코드
    
    // 메인 루프
    while (System::Update())
    {
        // 매 프레임마다 실행되는 코드
    }
    
    // 종료 처리 (필요시)
}
```

`System::Update()`는 윈도우 이벤트를 처리하고 화면을 갱신한다. 사용자가 윈도우를 닫거나 ESC 키를 누르면 `false`를 반환하여 루프가 종료된다.

### 18.2.2 윈도우 설정
윈도우의 크기, 제목, 스타일 등을 설정할 수 있다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 윈도우 제목 설정
    Window::SetTitle(U"나의 첫 Siv3D 앱");
    
    // 윈도우 크기 설정 (800x600)
    Window::Resize(800, 600);
    
    // 윈도우를 항상 맨 위에 표시
    // Window::SetStyle(WindowStyle::Sizable);
    
    while (System::Update())
    {
        // 아무것도 그리지 않아도 검은 화면이 표시된다
    }
}
```

**주요 윈도우 관련 함수:**

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 윈도우 크기 변경
    Window::Resize(1024, 768);
    
    // 윈도우 크기 가져오기
    Size windowSize = Window::GetState().virtualSize;
    Print << U"윈도우 크기: " << windowSize;
    
    // 전체화면 설정
    // Window::SetFullscreen(true);
    
    // 윈도우 스타일 설정
    Window::SetStyle(WindowStyle::Sizable);  // 크기 조절 가능
    
    while (System::Update())
    {
    }
}
```

Siv3D의 문자열은 `U"..."` 형식의 UTF-32 문자열을 사용한다. 이를 통해 한글을 포함한 모든 유니코드 문자를 자연스럽게 사용할 수 있다.

### 18.2.3 장면(Scene) 이해하기
Siv3D에서 "장면(Scene)"은 그래픽이 그려지는 가상의 캔버스다. 윈도우 크기와 독립적으로 설정할 수 있다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 장면 크기를 800x600으로 설정
    Scene::Resize(800, 600);
    
    // 장면 배경색 설정
    Scene::SetBackground(ColorF{ 0.6, 0.8, 0.7 });
    
    while (System::Update())
    {
        // 장면의 중심 좌표 가져오기
        Vec2 center = Scene::Center();
        
        // 장면 크기 가져오기
        Size sceneSize = Scene::Size();
        
        // 디버깅용 출력
        Print << U"장면 중심: " << center;
        Print << U"장면 크기: " << sceneSize;
    }
}
```

### 18.2.4 좌표계 이해하기
Siv3D는 왼쪽 위가 원점(0, 0)이고, 오른쪽으로 갈수록 x가 증가하고, 아래로 갈수록 y가 증가하는 좌표계를 사용한다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.9, 0.9, 0.9 });
    
    while (System::Update())
    {
        // 좌표계 설명을 위한 점들
        Circle{ 0, 0, 10 }.draw(Palette::Red);           // 왼쪽 위 (원점)
        Circle{ 800, 0, 10 }.draw(Palette::Green);       // 오른쪽 위
        Circle{ 0, 600, 10 }.draw(Palette::Blue);        // 왼쪽 아래
        Circle{ 800, 600, 10 }.draw(Palette::Yellow);    // 오른쪽 아래
        Circle{ 400, 300, 10 }.draw(Palette::Orange);    // 중앙
        
        // 현재 마우스 위치
        Vec2 mousePos = Cursor::Pos();
        Circle{ mousePos, 20 }.draw(ColorF{ 1.0, 0.0, 0.0, 0.5 });
        
        // 마우스 좌표 표시
        Font font{ FontMethod::MSDF, 20 };
        font(U"마우스 위치: ({:.0f}, {:.0f})"_fmt(mousePos.x, mousePos.y))
            .draw(20, 20, Palette::Black);
    }
}
```
  

</br>  
  

## 18.3 기본 도형 그리기와 색상 처리

### 18.3.1 원(Circle) 그리기

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });
    
    while (System::Update())
    {
        // 중심 (400, 300), 반지름 50인 원
        Circle{ 400, 300, 50 }.draw();
        
        // Vec2를 사용한 원
        Circle{ Vec2{ 200, 200 }, 30 }.draw(Palette::Red);
        
        // 테두리만 그리기
        Circle{ 600, 200, 40 }.drawFrame(5, Palette::Blue);
        
        // 반투명 원
        Circle{ 300, 450, 60 }.draw(ColorF{ 0.0, 1.0, 0.0, 0.5 });
        
        // 마우스를 따라다니는 원
        Circle{ Cursor::Pos(), 25 }.draw(Palette::Orange);
    }
}
```

**Circle의 주요 메서드:**
- `draw()`: 채워진 원을 그린다
- `drawFrame(thickness, color)`: 테두리만 그린다
- `drawPie(startAngle, angle, color)`: 부채꼴을 그린다
- `drawArc(startAngle, angle, innerThickness, outerThickness, color)`: 호를 그린다

### 18.3.2 사각형(Rect) 그리기

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.9, 0.9, 0.9 });
    
    while (System::Update())
    {
        // 왼쪽 위 (100, 100), 크기 200x150인 사각형
        Rect{ 100, 100, 200, 150 }.draw(Palette::Skyblue);
        
        // 중심 좌표와 크기로 생성
        Rect{ Arg::center(400, 300), 100, 80 }.draw(Palette::Orange);
        
        // 테두리만 그리기
        Rect{ 500, 400, 150, 100 }.drawFrame(3, Palette::Red);
        
        // 둥근 사각형
        RoundRect{ 100, 350, 180, 120, 20 }.draw(Palette::Green);
        
        // 마우스 위치에 사각형 (중심이 마우스 위치)
        Rect{ Arg::center(Cursor::Pos()), 60, 60 }
            .draw(ColorF{ 1.0, 0.0, 1.0, 0.3 });
    }
}
```

### 18.3.3 선(Line)과 다각형 그리기

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(Palette::White);
    
    while (System::Update())
    {
        // 두 점을 잇는 선
        Line{ 100, 100, 300, 200 }.draw(3, Palette::Black);
        
        // 화살표
        Line{ 400, 150, 600, 150 }.drawArrow(5, Vec2{ 20, 20 }, Palette::Red);
        
        // 삼각형
        Triangle{ 200, 350, 100 }.draw(Palette::Yellow);
        
        // 사각형 (4개의 점으로 정의)
        Quad{ Vec2{400, 350}, Vec2{500, 320}, Vec2{520, 420}, Vec2{380, 440} }
            .draw(Palette::Cyan);
        
        // 다각형 (여러 점들)
        Polygon{ {
            Vec2{600, 300},
            Vec2{650, 280},
            Vec2{700, 300},
            Vec2{680, 350},
            Vec2{620, 350}
        }}.draw(Palette::Orange);
    }
}
```

### 18.3.4 색상 다루기
Siv3D는 다양한 방법으로 색상을 표현할 수 있다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.1, 0.1, 0.1 });
    
    while (System::Update())
    {
        // Palette에서 미리 정의된 색상 사용
        Circle{ 100, 100, 40 }.draw(Palette::Red);
        Circle{ 200, 100, 40 }.draw(Palette::Green);
        Circle{ 300, 100, 40 }.draw(Palette::Blue);
        
        // RGB 값으로 색상 생성 (0~255)
        Circle{ 100, 200, 40 }.draw(Color{ 255, 128, 0 });
        
        // RGB 값으로 색상 생성 (0.0~1.0)
        Circle{ 200, 200, 40 }.draw(ColorF{ 1.0, 0.5, 0.0 });
        
        // RGBA (알파값 포함, 투명도)
        Circle{ 300, 200, 40 }.draw(ColorF{ 0.0, 1.0, 1.0, 0.5 });
        
        // HSV 색상 (색조, 채도, 명도)
        Circle{ 100, 300, 40 }.draw(HSV{ 0, 1.0, 1.0 });    // 빨강
        Circle{ 200, 300, 40 }.draw(HSV{ 120, 1.0, 1.0 });  // 초록
        Circle{ 300, 300, 40 }.draw(HSV{ 240, 1.0, 1.0 });  // 파랑
        
        // 시간에 따라 변하는 색상
        double time = Scene::Time();
        double hue = Math::Fmod(time * 60, 360);
        Circle{ Scene::Center(), 80 }.draw(HSV{ hue, 0.8, 1.0 });
        
        // 그라데이션
        Rect{ 400, 100, 300, 80 }
            .draw(Arg::top = Palette::Red, Arg::bottom = Palette::Blue);
    }
}
```

**색상 관련 주요 타입:**
- `Color`: RGB 각 성분이 0~255 범위의 정수
- `ColorF`: RGB 각 성분이 0.0~1.0 범위의 실수
- `HSV`: 색조(Hue), 채도(Saturation), 명도(Value)로 색상 표현
- `Palette`: 미리 정의된 색상 상수 (Red, Green, Blue, White, Black 등)

### 18.3.5 다양한 도형 조합하기

```cpp
#include <Siv3D.hpp>

void Main()
{
	Scene::SetBackground(ColorF{ 0.9, 0.95, 1.0 });

	while (System::Update())
	{
		// 간단한 얼굴 그리기
		Vec2 faceCenter{ 300, 250 };

		// 얼굴
		Circle{ faceCenter, 100 }.draw(Palette::Yellow);

		// 눈
		Circle{ faceCenter + Vec2{-30, -20}, 10 }.draw(Palette::Black);
		Circle{ faceCenter + Vec2{30, -20}, 10 }.draw(Palette::Black);

		// 입 (호)
		Circle{ faceCenter + Vec2{0, 20}, 50 }
		.drawArc(0_deg, 180_deg, 5, 0, Palette::Black);

		// 간단한 집 그리기
		Vec2 housePos{ 550, 300 };

		// 벽
		Rect{ Arg::bottomCenter(550, 300), 120, 100 }.draw(Palette::Brown);

		// 지붕
		Triangle{ housePos.x, housePos.y - 100, 80 }
		.draw(Palette::Red);

		// 문
		Rect{ Arg::bottomCenter(550, 300), 30, 50 }.draw(Palette::Saddlebrown);

		// 창문
		Rect{ 550 - 40, 300 - 60, 25, 25 }.draw(Palette::Skyblue);
	}
}
```

## 18.4 게임 루프와 프레임 관리

### 18.4.1 게임 루프의 이해

게임이나 인터랙티브 프로그램은 다음과 같은 루프 구조를 가진다:

1. **입력 처리**: 사용자 입력(마우스, 키보드 등)을 받는다
2. **상태 업데이트**: 게임 로직을 실행하고 상태를 갱신한다
3. **렌더링**: 화면에 그래픽을 그린다

Siv3D의 `System::Update()`는 이 과정을 자동으로 처리한다.

```cpp
#include <Siv3D.hpp>

void Main()
{
	// 초기화
	Vec2 circlePos{ 400, 300 };
	double circleSpeed = 200.0;  // 초당 이동 픽셀

	// 디버깅 정보 출력
	Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

	while (System::Update())
	{
		// 1. 입력 처리 및 상태 업데이트
		double deltaTime = Scene::DeltaTime();  // 이전 프레임으로부터 경과 시간 (초)

		if (KeyLeft.pressed()) {
			circlePos.x -= circleSpeed * deltaTime;
		}
		if (KeyRight.pressed()) {
			circlePos.x += circleSpeed * deltaTime;
		}
		if (KeyUp.pressed()) {
			circlePos.y -= circleSpeed * deltaTime;
		}
		if (KeyDown.pressed()) {
			circlePos.y += circleSpeed * deltaTime;
		}

		// 2. 렌더링
		Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });
		Circle{ circlePos, 30 }.draw(Palette::Orange);
				
		font(U"화살표 키로 원을 움직여보세요").draw(20, 20, Palette::Black);
		font(U"위치: ({:.1f}, {:.1f})"_fmt(circlePos.x, circlePos.y))
			.draw(20, 50, Palette::Black);
	}
}
```

### 18.4.2 DeltaTime을 활용한 프레임 독립적 움직임
게임 루프는 초당 실행되는 횟수(FPS, Frames Per Second)가 컴퓨터 성능에 따라 달라질 수 있다. `DeltaTime`을 사용하면 FPS에 관계없이 일정한 속도로 움직이게 할 수 있다.

```cpp
#include <Siv3D.hpp>

void Main()
{
	Vec2 position{ 100, 300 };
	Vec2 velocity{ 150, 0 };  // 초당 150픽셀 오른쪽으로 이동

	Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

	while (System::Update())
	{
		// DeltaTime: 이전 프레임과의 시간 간격 (초 단위)
		double dt = Scene::DeltaTime();

		// 위치 업데이트 (속도 * 시간)
		position += velocity * dt;

		// 화면 밖으로 나가면 반대편에서 나타남
		if (position.x > Scene::Width()) {
			position.x = 0;
		}

		// 렌더링
		Scene::SetBackground(Palette::White);
		Circle{ position, 25 }.draw(Palette::Red);

		// FPS 표시
		const double fps = (dt > 0.0) ? (1.0 / dt) : 0.0;
		font(U"FPS: {:.1f}"_fmt(fps)).draw(20, 20, Palette::Black);
		font(U"DeltaTime: {:.4f}초"_fmt(dt)).draw(20, 50, Palette::Black);
	}
}
```

### 18.4.3 시간 기반 애니메이션

```cpp
#include <Siv3D.hpp>

void Main()
{
    Scene::SetBackground(ColorF{ 0.2, 0.3, 0.4 });
    
    Font font{ FontMethod::MSDF, 24, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 경과 시간 (초)
        double time = Scene::Time();
        
        // 진동하는 원
        double y1 = 200 + Math::Sin(time * 2.0) * 50;
        Circle{ 200, y1, 30 }.draw(Palette::Yellow);
        
        // 회전하는 사각형
        double angle = time * 90_deg;  // 초당 90도 회전
        RectF{ Arg::center(400, 300), 80, 80 }
            .rotated(angle)
            .draw(Palette::Cyan);
        
        // 크기가 변하는 원
        double radius = 20 + Math::Sin(time * 3.0) * 15;
        Circle{ 600, 300, radius }.draw(Palette::Orange);
        
        // 색상이 변하는 원 (HSV 색상환)
        double hue = Math::Fmod(time * 60, 360);
        Circle{ Scene::Center(), 50 }.draw(HSV{ hue, 0.8, 1.0 });
        
        // 시간 표시        
        font(U"경과 시간: {:.2f}초"_fmt(time)).draw(20, 20, Palette::White);
    }
}
```

### 18.4.4 프레임 레이트 제한
Siv3D는 기본적으로 모니터의 주사율에 맞춰 동작한다(V-Sync). 특정 FPS로 제한하고 싶다면 다음과 같이 설정할 수 있다.

```cpp
#include <Siv3D.hpp>

void Main()
{
	// 60 FPS로 제한
	constexpr double targetFPS = 60.0;
	constexpr double targetDelta = 1.0 / targetFPS;

	// 또는 V-Sync 활성화 (모니터 주사율에 맞춤)
	// Graphics::SetVSyncEnabled(true);
	Graphics::SetVSyncEnabled(false);
	Stopwatch frame;

	int frameCount = 0;

	Font font{ FontMethod::MSDF, 24, Typeface::CJK_Regular_KR };
	
	while (System::Update())
	{
		double dt = Scene::DeltaTime();

		++frameCount;

		Scene::SetBackground(Palette::White);

		const double fps = (dt > 0.0) ? (1.0 / dt) : 0.0;

		font(U"FPS: {:.1f}"_fmt(fps)).draw(20, 20, Palette::Black);
		font(U"프레임 수: {}"_fmt(frameCount)).draw(20, 50, Palette::Black);

		// 간단한 애니메이션
		double angle = frameCount * 3_deg;
		Circle{ Scene::Center(), 50 }.draw(HSV{ angle });


		const double elapsed = frame.sF();
		const double remain = targetDelta - elapsed;
		if (remain > 0.0)
		{
			std::this_thread::sleep_for(std::chrono::duration<double>(remain));
		}
		frame.restart();
	}
}
```

### 18.4.5 Print을 이용한 디버깅
Siv3D는 `Print`를 통해 화면에 디버깅 정보를 쉽게 출력할 수 있다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    Vec2 mousePos{ 0, 0 };
    int clickCount = 0;
    
    while (System::Update())
    {
        // 마우스 위치 업데이트
        mousePos = Cursor::Pos();
        
        // 마우스 클릭 감지
        if (MouseL.down()) {
            ++clickCount;
        }
        
        Scene::SetBackground(ColorF{ 0.8, 0.9, 1.0 });
        
        // Print로 디버깅 정보 출력 (화면 왼쪽 위에 표시됨)
        Print << U"마우스 위치: " << mousePos;
        Print << U"클릭 횟수: " << clickCount;
        Print << U"경과 시간: " << Scene::Time();
        
        // Print는 여러 값을 이어서 출력할 수 있다
        Print << U"X=" << mousePos.x << U", Y=" << mousePos.y;
        
        // 마우스 위치에 원 그리기
        Circle{ mousePos, 20 }.draw(Palette::Orange);
    }
}
```

`Print`는 개발 중 빠른 디버깅에 유용하지만, 최종 제품에서는 제거하거나 적절한 UI로 교체해야 한다.
  

</br>  
  
  
## 18.5 실습 예제: 간단한 인터랙티브 프로그램
배운 내용을 종합하여 마우스를 따라 움직이는 여러 개의 원을 그리는 프로그램을 만들어보자.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 윈도우 설정
    Window::SetTitle(U"마우스 트레일");
    Scene::SetBackground(ColorF{ 0.1, 0.1, 0.15 });
    
    // 원들의 위치를 저장할 배열
    Array<Vec2> trail;
    const size_t maxTrailLength = 30;
    
    Font font{ FontMethod::MSDF, 24, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        // 현재 마우스 위치를 배열에 추가
        trail.push_back(Cursor::Pos());
        
        // 최대 길이를 넘으면 가장 오래된 것 제거
        if (trail.size() > maxTrailLength) {
            trail.pop_front();
        }
        
        // 트레일 그리기
        for (size_t i = 0; i < trail.size(); ++i) {
            // 인덱스에 따라 크기와 투명도 조절
            double ratio = static_cast<double>(i) / trail.size();
            double radius = 5 + ratio * 20;
            double alpha = ratio;
            
            // 색상도 변화
            double hue = Math::Fmod(Scene::Time() * 60 + i * 10, 360);
            
            Circle{ trail[i], radius }.draw(HSV{ hue, 0.8, 1.0, alpha });
        }
        
        // 안내 텍스트
        font(U"마우스를 움직여보세요!").draw(20, 20, Palette::White);
        font(U"트레일 길이: {}"_fmt(trail.size())).draw(20, 50, Palette::White);
    }
}
```
  

</br>  
  

## 18.6 실습 문제

### 문제 1: 바운싱 볼
화면 안에서 튕기는 공을 만들어라.

**요구사항:**
- 공은 일정한 속도로 움직인다
- 화면 가장자리에 닿으면 반대 방향으로 튕긴다
- 공의 색상은 벽에 부딪힐 때마다 변한다
- 현재 속도와 위치를 화면에 표시한다

```cpp
// 힌트:
// - Vec2로 위치와 속도를 표현한다
// - if문으로 경계 충돌을 감지한다
// - 속도의 x 또는 y 성분을 반전시켜 반사를 구현한다
```

### 문제 2: 클릭 이펙트
마우스를 클릭한 위치에서 원이 커지다가 사라지는 효과를 만들어라.

**요구사항:**
- 마우스 클릭 시 해당 위치에 작은 원이 생성된다
- 원은 시간이 지남에 따라 커지고 투명해진다
- 완전히 투명해지면 사라진다
- 여러 개의 원이 동시에 표시될 수 있다

```cpp
// 힌트:
// - 구조체로 각 원의 정보(위치, 생성 시간)를 저장한다
// - Array로 활성화된 모든 원을 관리한다
// - Scene::Time()과 생성 시간의 차이로 애니메이션을 제어한다
```

### 문제 3: 색상 팔레트
HSV 색상환을 이용한 간단한 색상 선택기를 만들어라.

**요구사항:**
- 화면에 여러 개의 원을 원형으로 배치한다
- 각 원은 서로 다른 색상을 가진다 (HSV 색상환 활용)
- 마우스로 원을 클릭하면 해당 색상으로 배경색이 변한다
- 선택된 색상의 RGB 값을 화면에 표시한다

```cpp
// 힌트:
// - Math::Cos()와 Math::Sin()으로 원형 배치를 계산한다
// - Circle의 leftClicked()로 클릭 감지를 한다
// - 각도에 따라 HSV 색상을 생성한다
```
  

</br>  
  

## 18.7 심화 내용

### 18.7.1 Scene과 Window의 차이
Scene과 Window는 서로 다른 개념이다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // Window: 실제 OS 윈도우의 크기
    Window::Resize(1280, 720);
    
    // Scene: 논리적인 캔버스 크기
    Scene::Resize(800, 600);
    
    // Scene이 Window보다 작으면 자동으로 확대되어 표시된다
    // 이를 통해 해상도에 독립적인 프로그램을 만들 수 있다
    
    Font font{ FontMethod::MSDF, 20, Typeface::CJK_Regular_KR };

    while (System::Update())
    {
        Scene::SetBackground(Palette::Skyblue);
        
        // Scene 좌표계로 작업
        Circle{ Scene::Center(), 100 }.draw(Palette::Orange);
                
        font(U"Window 크기: {}"_fmt(Window::GetState().virtualSize))
            .draw(20, 20, Palette::Black);
        font(U"Scene 크기: {}"_fmt(Scene::Size()))
            .draw(20, 50, Palette::Black);
    }
}
```

### 18.7.2 RenderTexture를 이용한 오프스크린 렌더링
화면에 직접 그리지 않고 텍스처에 먼저 그린 후 나중에 화면에 표시할 수 있다.

```cpp
#include <Siv3D.hpp>

void Main()
{
    // 오프스크린 렌더링을 위한 RenderTexture 생성
    RenderTexture renderTexture{ 400, 400, Palette::White };
    
    while (System::Update())
    {
        // RenderTexture에 그리기
        {
            ScopedRenderTarget2D target{ renderTexture };
            
            // 시간에 따라 변하는 패턴
            double time = Scene::Time();
            
            for (int y = 0; y < 10; ++y) {
                for (int x = 0; x < 10; ++x) {
                    double hue = Math::Fmod((x + y) * 36 + time * 60, 360);
                    Rect{ x * 40, y * 40, 40, 40 }.draw(HSV{ hue, 0.6, 0.9 });
                }
            }
        }
        
        // 메인 화면에 그리기
        Scene::SetBackground(ColorF{ 0.2, 0.2, 0.2 });
        
        // RenderTexture를 화면에 표시
        renderTexture.draw(200, 100);
        
        // 회전된 버전도 표시
        renderTexture.rotated(Scene::Time() * 30_deg).draw(650, 300);
    }
}
```

### 18.7.3 Transformer2D를 이용한 좌표 변환

```cpp
#include <Siv3D.hpp>

void Main()
{
    while (System::Update())
    {
        Scene::SetBackground(Palette::White);
        
        // 일반적인 그리기
        Circle{ 100, 300, 50 }.draw(Palette::Red);
        
        // 좌표계를 이동
        {
            Transformer2D transform{ Mat3x2::Translate(300, 0) };
            Circle{ 100, 300, 50 }.draw(Palette::Green);
        }
        
        // 좌표계를 회전
        {
            Transformer2D transform{ Mat3x2::Rotate(45_deg, Scene::Center()) };
            Rect{ Arg::center(Scene::Center()), 100, 100 }.draw(Palette::Blue);
        }
        
        // 좌표계를 확대
        {
            Transformer2D transform{ Mat3x2::Scale(2.0, Vec2{ 600, 300 }) };
            Circle{ 600, 300, 30 }.draw(Palette::Orange);
        }
    }
}
```

  
</br>  


## 18.8 정리
이 장에서는 Siv3D 환경을 구축하고 기본적인 그래픽 프로그래밍을 배웠다. Visual Studio 2022에 Siv3D를 설치하고, 윈도우를 생성하고, 다양한 도형을 그리고, 게임 루프를 이해했다.

**핵심 내용:**
- Siv3D는 Modern C++ 기반의 멀티미디어 프레임워크다
- `Main()` 함수와 `System::Update()` 루프가 프로그램의 핵심이다
- Scene은 논리적 캔버스, Window는 실제 OS 윈도우다
- Circle, Rect 등 다양한 도형을 간단하게 그릴 수 있다
- ColorF, HSV 등으로 색상을 표현한다
- DeltaTime을 사용하여 프레임 독립적인 움직임을 구현한다
- Print로 간편하게 디버깅 정보를 출력할 수 있다

다음 장부터는 마우스와 키보드 입력을 처리하여 더욱 인터랙티브한 프로그램을 만들어본다. Siv3D의 강력한 기능들을 하나씩 배워가면서 점점 더 복잡하고 흥미로운 프로그램을 만들 수 있게 될 것이다.   