# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# 부록

---

## 부록 A: C++ 키워드 완전 정리

C++23 표준까지의 모든 키워드를 카테고리별로 정리했다. 각 키워드의 용도와 간단한 예제를 함께 제시한다.

### A.1 기본 타입 관련 키워드

**정수형 타입**
- `int`: 기본 정수형 타입
- `short`: 작은 범위의 정수
- `long`: 긴 범위의 정수
- `long long`: 매우 긴 범위의 정수 (C++11)
- `signed`: 부호 있는 정수 (기본값)
- `unsigned`: 부호 없는 정수

**문자형 타입**
- `char`: 기본 문자형 (1바이트)
- `char8_t`: UTF-8 문자 (C++20)
- `char16_t`: UTF-16 문자 (C++11)
- `char32_t`: UTF-32 문자 (C++11)
- `wchar_t`: 와이드 문자

**부동소수점 타입**
- `float`: 단정밀도 실수
- `double`: 배정밀도 실수
- `long double`: 확장 배정밀도 실수

**기타 기본 타입**
- `bool`: 불리언 타입 (true/false)
- `void`: 값이 없음을 나타냄
- `auto`: 타입 자동 추론 (C++11)
- `decltype`: 표현식의 타입 추론 (C++11)

```cpp
// auto와 decltype 사용 예
auto value = 42;              // int로 추론
auto name = "Modern C++"s;    // std::string으로 추론
decltype(value) another = 10; // value와 같은 타입
```

### A.2 저장 클래스 지정자

- `const`: 상수 값 선언
- `constexpr`: 컴파일 타임 상수 (C++11)
- `consteval`: 즉시 함수 (C++20)
- `constinit`: 정적 초기화 보장 (C++20)
- `static`: 정적 저장 기간
- `extern`: 외부 링크 선언
- `thread_local`: 스레드별 저장 기간 (C++11)
- `mutable`: const 멤버 함수에서 수정 가능
- `volatile`: 최적화 방지
- `register`: 레지스터 저장 제안 (C++17에서 사용 중단)

```cpp
constexpr int square(int n) {
    return n * n;
}

consteval int cube(int n) {
    return n * n * n;  // 반드시 컴파일 타임에 평가
}

constinit static int globalValue = 100;
```

### A.3 제어 흐름 키워드

**조건문**
- `if`: 조건 분기
- `else`: if의 반대 조건
- `switch`: 다중 분기
- `case`: switch의 각 경우
- `default`: switch의 기본 경우

**반복문**
- `for`: 반복 구조
- `while`: 조건 반복
- `do`: do-while 반복문의 시작

**제어 흐름 변경**
- `break`: 루프나 switch 탈출
- `continue`: 다음 반복으로 건너뛰기
- `return`: 함수에서 반환
- `goto`: 레이블로 점프 (권장하지 않음)

```cpp
// 범위 기반 for문 (C++11)
std::vector<int> numbers{1, 2, 3, 4, 5};
for (const auto& num : numbers) {
    if (num == 3) continue;
    std::cout << num << '\n';
}
```

### A.4 클래스와 구조체 관련 키워드

**클래스 정의**
- `class`: 클래스 선언
- `struct`: 구조체 선언 (기본 public)
- `union`: 공용체 선언
- `enum`: 열거형 선언
- `enum class`: 범위 있는 열거형 (C++11)

**접근 지정자**
- `public`: 공개 멤버
- `private`: 비공개 멤버
- `protected`: 보호된 멤버
- `friend`: 친구 선언

**멤버 함수 지정자**
- `virtual`: 가상 함수
- `override`: 가상 함수 재정의 (C++11)
- `final`: 재정의 금지 (C++11)
- `explicit`: 암시적 변환 금지
- `inline`: 인라인 함수 제안
- `noexcept`: 예외를 던지지 않음 (C++11)

```cpp
class Base {
public:
    virtual void work() {}
    virtual void task() final {}
};

class Derived final : public Base {
public:
    void work() override {}
    // void task() override {} // 오류: final 함수 재정의 불가
};
```

### A.5 템플릿 관련 키워드

- `template`: 템플릿 선언
- `typename`: 타입 매개변수 선언
- `concept`: 제약 조건 정의 (C++20)
- `requires`: 제약 조건 명시 (C++20)
- `export`: 템플릿 내보내기 (C++11에서 제거)

```cpp
// 개념(Concept) 사용 예
template<typename T>
concept Numeric = std::is_arithmetic_v<T>;

template<Numeric T>
T add(T a, T b) {
    return a + b;
}

// requires 절 사용
template<typename T>
requires std::integral<T>
T multiply(T a, T b) {
    return a * b;
}
```

### A.6 네임스페이스 관련 키워드

- `namespace`: 네임스페이스 선언
- `using`: 네임스페이스 사용 선언

```cpp
namespace MyLib {
    inline namespace v2 {  // 인라인 네임스페이스 (C++11)
        void process() {}
    }
}

using namespace MyLib;  // 전체 네임스페이스 사용
using MyLib::process;   // 특정 이름만 사용
```

### A.7 예외 처리 키워드

- `try`: 예외 처리 블록 시작
- `catch`: 예외 잡기
- `throw`: 예외 던지기
- `noexcept`: 예외를 던지지 않음 명시 (C++11)

```cpp
void safeFunction() noexcept {
    // 예외를 던지지 않음을 보장
}

void riskyFunction() {
    try {
        throw std::runtime_error("오류 발생");
    }
    catch (const std::exception& e) {
        std::cerr << e.what() << '\n';
    }
}
```

### A.8 메모리 관리 키워드

- `new`: 동적 메모리 할당
- `delete`: 동적 메모리 해제
- `sizeof`: 타입이나 객체의 크기
- `alignof`: 정렬 요구사항 (C++11)
- `alignas`: 정렬 지정 (C++11)

```cpp
// Modern C++에서는 new/delete 대신 스마트 포인터 사용 권장
auto ptr = std::make_unique<int>(42);

// 정렬 지정
alignas(16) int alignedArray[4];
static_assert(alignof(decltype(alignedArray)) == 16);
```

### A.9 캐스팅 키워드

- `static_cast`: 정적 타입 변환
- `dynamic_cast`: 동적 타입 변환
- `const_cast`: const 제거/추가
- `reinterpret_cast`: 비트 단위 재해석

```cpp
// 안전한 타입 변환
double value = 3.14;
int intValue = static_cast<int>(value);

// 다형성 타입 변환
class Base { virtual ~Base() = default; };
class Derived : public Base {};

Base* basePtr = new Derived();
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
```

### A.10 특수 키워드

**타입 특성**
- `typedef`: 타입 별칭
- `using`: 타입 별칭 (C++11, 권장)

**연산자 관련**
- `operator`: 연산자 오버로딩
- `sizeof...`: 가변 인자 개수 (C++11)
- `typeid`: 런타임 타입 정보
- `this`: 현재 객체 포인터

**기타**
- `nullptr`: 널 포인터 상수 (C++11)
- `static_assert`: 컴파일 타임 검증 (C++11)
- `asm`: 어셈블리 코드 삽입
- `true`, `false`: 불리언 리터럴

```cpp
// using을 이용한 타입 별칭 (권장)
using IntVector = std::vector<int>;
using ProcessFunc = std::function<void(int)>;

// static_assert로 컴파일 타임 검증
static_assert(sizeof(int) == 4, "int는 4바이트여야 함");
```

### A.11 C++11 이후 추가된 주요 키워드 요약

**C++11**
- `auto`, `decltype`, `nullptr`
- `constexpr`, `noexcept`
- `static_assert`
- `thread_local`
- `override`, `final`
- `char16_t`, `char32_t`
- `alignas`, `alignof`

**C++20**
- `concept`, `requires`
- `consteval`, `constinit`
- `char8_t`
- `co_await`, `co_return`, `co_yield` (코루틴)

**C++23**
- `if consteval` (조건부 consteval)

```cpp
// C++20 코루틴 키워드 (고급 주제)
generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        auto next = a + b;
        a = b;
        b = next;
    }
}
```

### A.12 문맥 의존 키워드

다음은 특정 문맥에서만 키워드로 동작하는 식별자다.

- `import`, `module`: 모듈 시스템 (C++20)
- `final`: 클래스나 함수를 final로 지정
- `override`: 가상 함수 재정의 표시
- `transaction_safe`, `transaction_safe_dynamic`: 트랜잭션 메모리 (미래 표준)

```cpp
// 모듈 사용 예 (C++20)
export module MyModule;

export int getValue() {
    return 42;
}

// 다른 파일에서
import MyModule;
int value = getValue();
```

---

## 부록 B: Visual Studio 2022 단축키 모음

효율적인 코딩을 위한 Visual Studio 2022의 필수 단축키를 카테고리별로 정리했다.

### B.1 편집 및 탐색

**기본 편집**
- `Ctrl + C`: 복사
- `Ctrl + X`: 잘라내기
- `Ctrl + V`: 붙여넣기
- `Ctrl + Z`: 실행 취소
- `Ctrl + Y`: 다시 실행
- `Ctrl + D`: 현재 줄 복제
- `Ctrl + L`: 현재 줄 삭제
- `Ctrl + K, Ctrl + C`: 주석 처리
- `Ctrl + K, Ctrl + U`: 주석 해제
- `Ctrl + K, Ctrl + D`: 문서 서식 지정
- `Ctrl + K, Ctrl + F`: 선택 영역 서식 지정

**텍스트 선택**
- `Shift + 방향키`: 텍스트 선택
- `Ctrl + A`: 전체 선택
- `Alt + Shift + 방향키`: 박스 선택
- `Ctrl + W`: 단어 선택 확장

**커서 이동**
- `Ctrl + 방향키`: 단어 단위 이동
- `Home`: 줄 시작으로 이동
- `End`: 줄 끝으로 이동
- `Ctrl + Home`: 문서 시작으로 이동
- `Ctrl + End`: 문서 끝으로 이동
- `Ctrl + G`: 줄 번호로 이동

### B.2 코드 탐색 및 검색

**검색 및 바꾸기**
- `Ctrl + F`: 찾기
- `Ctrl + H`: 바꾸기
- `Ctrl + Shift + F`: 폴더에서 찾기
- `Ctrl + Shift + H`: 폴더에서 바꾸기
- `F3`: 다음 찾기
- `Shift + F3`: 이전 찾기

**코드 탐색**
- `F12`: 정의로 이동
- `Alt + F12`: 정의 피킹 (팝업으로 보기)
- `Ctrl + F12`: 구현으로 이동
- `Shift + F12`: 모든 참조 찾기
- `Ctrl + T`: 모든 항목으로 이동
- `Ctrl + ,`: 파일로 이동
- `Ctrl + -`: 이전 위치로 이동
- `Ctrl + Shift + -`: 다음 위치로 이동
- `Ctrl + ]`: 일치하는 괄호로 이동

**클래스 및 멤버 탐색**
- `Ctrl + K, Ctrl + T`: 형식 브라우저
- `Alt + \`: 클래스 뷰로 이동
- `Ctrl + K, Ctrl + R`: 기호에 대한 참조

### B.3 IntelliSense 및 리팩터링

**IntelliSense**
- `Ctrl + Space`: IntelliSense 완성 목록 표시
- `Ctrl + J`: 멤버 목록 표시
- `Ctrl + K, Ctrl + I`: 빠른 정보 표시
- `Ctrl + Shift + Space`: 매개 변수 정보 표시
- `Tab` 또는 `Enter`: IntelliSense 항목 삽입

**리팩터링**
- `Ctrl + R, Ctrl + R`: 이름 바꾸기
- `Ctrl + R, Ctrl + M`: 메서드 추출
- `Ctrl + R, Ctrl + E`: 캡슐화 필드
- `Ctrl + R, Ctrl + I`: 인터페이스 추출
- `Ctrl + .`: 빠른 작업 및 리팩터링

```cpp
// 빠른 작업 (Ctrl + .) 활용 예:
// - #include 문 자동 추가
// - using 선언 추가
// - 함수 구현 생성
// - getter/setter 생성
```

### B.4 빌드 및 디버깅

**빌드**
- `F7` 또는 `Ctrl + Shift + B`: 솔루션 빌드
- `Ctrl + Break`: 빌드 취소
- `Ctrl + F7`: 현재 파일만 컴파일
- `Ctrl + Alt + F7`: 빌드 출력 창 표시

**디버깅 시작 및 제어**
- `F5`: 디버깅 시작
- `Ctrl + F5`: 디버깅하지 않고 시작
- `Shift + F5`: 디버깅 중지
- `Ctrl + Shift + F5`: 디버깅 다시 시작
- `F10`: 프로시저 단위 실행
- `F11`: 한 단계씩 코드 실행
- `Shift + F11`: 프로시저 나가기
- `Ctrl + F10`: 커서까지 실행

**중단점**
- `F9`: 중단점 설정/해제
- `Ctrl + Shift + F9`: 모든 중단점 삭제
- `Ctrl + B`: 새 중단점
- `Alt + F9, C`: 조건부 중단점 설정

**디버깅 창**
- `Ctrl + Alt + V, L`: 지역 변수 창
- `Ctrl + Alt + W, 1`: 조사식 1
- `Ctrl + Alt + C`: 호출 스택
- `Ctrl + Alt + I`: 직접 실행 창
- `Ctrl + Alt + O`: 출력 창
- `Ctrl + Alt + E`: 예외 설정

### B.5 창 및 프로젝트 관리

**창 관리**
- `Alt + F6`: 다음 창으로 이동
- `Alt + Shift + F6`: 이전 창으로 이동
- `Ctrl + F4`: 현재 창 닫기
- `Ctrl + Tab`: 문서 창 전환
- `Shift + Esc`: 도구 창 닫기
- `F11`: 전체 화면 모드 전환

**솔루션 탐색기**
- `Ctrl + Alt + L`: 솔루션 탐색기 표시
- `Ctrl + [, S`: 솔루션 탐색기에서 현재 파일 동기화

**프로젝트 관리**
- `Ctrl + Shift + A`: 새 항목 추가
- `Ctrl + Shift + C`: 새 클래스 추가

### B.6 코드 스니펫

**스니펫 삽입**
- `Ctrl + K, Ctrl + X`: 코드 조각 삽입
- `Ctrl + K, Ctrl + S`: 코드 감싸기

**유용한 스니펫 단축어**
- `class` + `Tab Tab`: 클래스 템플릿
- `for` + `Tab Tab`: for 루프
- `foreach` + `Tab Tab`: 범위 기반 for 루프
- `if` + `Tab Tab`: if 문
- `switch` + `Tab Tab`: switch 문
- `try` + `Tab Tab`: try-catch 블록
- `namespace` + `Tab Tab`: 네임스페이스

```cpp
// 'for' 스니펫 사용 예
for (size_t i = 0; i < length; i++)
{
    // Tab으로 각 필드 이동
}

// 'foreach' 스니펫 사용 예
for (auto&& item : collection)
{
    // 자동으로 생성된 구조
}
```

### B.7 고급 편집 기능

**다중 커서**
- `Ctrl + Alt + 클릭`: 커서 추가
- `Ctrl + Alt + 위/아래 화살표`: 위/아래에 커서 추가
- `Shift + Alt + .`: 다음 일치 항목에 커서 추가
- `Shift + Alt + ;`: 모든 일치 항목에 커서 추가
- `Esc`: 다중 커서 해제

**코드 접기**
- `Ctrl + M, Ctrl + M`: 현재 영역 접기/펼치기
- `Ctrl + M, Ctrl + O`: 모든 개요 접기
- `Ctrl + M, Ctrl + L`: 모든 개요 펼치기
- `Ctrl + M, Ctrl + P`: 개요 표시 중지

**북마크**
- `Ctrl + K, Ctrl + K`: 북마크 설정/해제
- `Ctrl + K, Ctrl + N`: 다음 북마크로 이동
- `Ctrl + K, Ctrl + P`: 이전 북마크로 이동
- `Ctrl + K, Ctrl + L`: 모든 북마크 지우기

### B.8 테스트 관련

**단위 테스트**
- `Ctrl + R, T`: 현재 컨텍스트의 테스트 실행
- `Ctrl + R, A`: 모든 테스트 실행
- `Ctrl + R, Ctrl + T`: 테스트 디버깅
- `Ctrl + E, T`: 테스트 탐색기 표시

### B.9 사용자 정의 단축키 설정

단축키를 사용자 맞춤으로 변경하려면:

1. `도구` → `옵션` → `환경` → `키보드`로 이동
2. "다음 문자열을 포함하는 명령 표시"에 명령 검색
3. "바로 가기 키 누르기"에서 원하는 키 조합 입력
4. "할당" 버튼 클릭

### B.10 자주 사용하는 조합 단축키

**코드 작성 워크플로우**
```
1. Ctrl + T → 파일 빠르게 열기
2. Ctrl + Space → 코드 자동 완성
3. Ctrl + . → 빠른 수정 및 리팩터링
4. Ctrl + K, Ctrl + D → 코드 정리
5. F7 → 빌드
6. F5 → 디버깅 시작
```

**코드 탐색 워크플로우**
```
1. Ctrl + , → 심볼로 이동
2. F12 → 정의로 이동
3. Shift + F12 → 모든 참조 찾기
4. Ctrl + - → 이전 위치로 돌아가기
```

**리팩터링 워크플로우**
```
1. Ctrl + R, Ctrl + R → 이름 바꾸기
2. Ctrl + R, Ctrl + M → 메서드 추출
3. Ctrl + . → 빠른 작업으로 코드 개선
```

---

## 부록 C: C++23 주요 기능 요약

C++23에서 도입된 주요 기능과 개선 사항을 정리했다. 실용적인 예제와 함께 각 기능의 장점을 설명한다.

### C.1 `if consteval` - 컴파일 타임 분기

`if consteval`을 사용하면 코드가 컴파일 타임에 평가되는지 런타임에 평가되는지에 따라 다른 동작을 수행할 수 있다.

```cpp
constexpr int compute(int n) {
    if consteval {
        // 컴파일 타임에 실행되는 코드
        return n * n;
    } else {
        // 런타임에 실행되는 코드
        return n * n * n;
    }
}

int main() {
    constexpr int a = compute(5);  // 컴파일 타임: 25
    int n = 5;
    int b = compute(n);             // 런타임: 125
}
```

**활용 사례**: 컴파일 타임과 런타임에서 서로 다른 최적화 전략을 사용할 때 유용하다.

### C.2 `std::expected` - 오류 처리 개선

예외 대신 오류 값을 반환하는 방식으로, 성능이 중요한 코드에서 유용하다.

```cpp
#include <expected>
#include <string>

std::expected<int, std::string> divide(int a, int b) {
    if (b == 0) {
        return std::unexpected("0으로 나눌 수 없음");
    }
    return a / b;
}

int main() {
    auto result = divide(10, 2);
    
    if (result) {
        std::cout << "결과: " << *result << '\n';
    } else {
        std::cerr << "오류: " << result.error() << '\n';
    }
    
    // transform을 사용한 체이닝
    auto doubled = divide(10, 2)
        .transform([](int x) { return x * 2; });
}
```

**장점**: 예외보다 성능이 좋고, 오류 처리 흐름이 명확하다.

### C.3 `std::mdspan` - 다차원 배열 뷰

다차원 데이터를 효율적으로 다루기 위한 표준 라이브러리 기능이다.

```cpp
#include <mdspan>
#include <vector>

void processMatrix() {
    std::vector<int> data(12);
    
    // 3x4 행렬로 해석
    std::mdspan<int, std::extents<size_t, 3, 4>> matrix(data.data());
    
    // 행렬 초기화
    for (size_t i = 0; i < matrix.extent(0); ++i) {
        for (size_t j = 0; j < matrix.extent(1); ++j) {
            matrix[i, j] = i * 4 + j;
        }
    }
    
    // 서브뷰 생성
    auto subview = std::submdspan(matrix, 
        std::tuple{1, 3}, std::full_extent);
}
```

**활용 사례**: 과학 계산, 이미지 처리, 행렬 연산 등에서 유용하다.

### C.4 범위 어댑터 개선

C++23에서는 더 많은 범위 어댑터가 추가되었다.

```cpp
#include <ranges>
#include <vector>
#include <print>

void rangeExamples() {
    std::vector data{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // to: 범위를 컨테이너로 변환
    auto squares = data 
        | std::views::transform([](int x) { return x * x; })
        | std::ranges::to<std::vector>();
    
    // chunk: 고정 크기 청크로 분할
    for (auto chunk : data | std::views::chunk(3)) {
        std::print("청크: ");
        for (int value : chunk) {
            std::print("{} ", value);
        }
        std::println("");
    }
    
    // slide: 슬라이딩 윈도우
    for (auto window : data | std::views::slide(3)) {
        std::print("윈도우: ");
        for (int value : window) {
            std::print("{} ", value);
        }
        std::println("");
    }
    
    // stride: 일정 간격으로 요소 선택
    auto everyThird = data | std::views::stride(3);
}
```

### C.5 `std::print` 및 `std::println` - 포맷 출력

`std::format`을 기반으로 한 간편한 출력 함수다.

```cpp
#include <print>
#include <vector>

void printExamples() {
    // 기본 출력
    std::println("Hello, C++23!");
    
    // 포맷 출력
    int value = 42;
    std::println("값: {}", value);
    
    // 여러 인자
    std::println("{} + {} = {}", 10, 20, 30);
    
    // 위치 지정자
    std::println("{1} {0}", "World", "Hello");
    
    // 포맷 지정
    double pi = 3.14159265359;
    std::println("π = {:.2f}", pi);
    
    // 컨테이너 출력
    std::vector numbers{1, 2, 3, 4, 5};
    std::println("숫자들: {}", numbers);
}
```

**장점**: `std::cout`보다 간결하고, 타입 안전하며, 성능도 우수하다.

### C.6 `std::stacktrace` - 스택 추적

디버깅과 오류 진단을 위한 표준 스택 추적 기능이다.

```cpp
#include <stacktrace>
#include <print>

void functionC() {
    auto trace = std::stacktrace::current();
    std::println("스택 추적:");
    for (const auto& entry : trace) {
        std::println("  {}", entry);
    }
}

void functionB() {
    functionC();
}

void functionA() {
    functionB();
}

int main() {
    functionA();
}
```

**활용 사례**: 예외 발생 시 호출 스택 저장, 성능 프로파일링, 디버깅 정보 수집 등에 유용하다.

### C.7 명시적 객체 매개변수 (Deducing this)

멤버 함수에서 `this`의 타입을 명시적으로 추론할 수 있다.

```cpp
struct Data {
    std::string value;
    
    // C++23: 명시적 객체 매개변수
    template<typename Self>
    auto&& getValue(this Self&& self) {
        return std::forward<Self>(self).value;
    }
    
    // 기존 방식이라면 4개 함수 필요:
    // const std::string& getValue() const &;
    // std::string& getValue() &;
    // const std::string&& getValue() const &&;
    // std::string&& getValue() &&;
};

void usage() {
    Data d{"test"};
    auto& v1 = d.getValue();          // lvalue reference
    auto&& v2 = Data{"temp"}.getValue(); // rvalue reference
}
```

**장점**: 코드 중복을 줄이고, CRTP 패턴을 단순화한다.

### C.8 `std::flat_map` 및 `std::flat_set`

연속 메모리 기반의 정렬된 연관 컨테이너다.

```cpp
#include <flat_map>
#include <flat_set>

void flatContainerExamples() {
    // 캐시 친화적인 맵
    std::flat_map<int, std::string> ages;
    ages[1] = "Alice";
    ages[2] = "Bob";
    ages[3] = "Charlie";
    
    // 빠른 순회 (메모리 연속성)
    for (const auto& [id, name] : ages) {
        std::println("{}: {}", id, name);
    }
    
    // flat_set
    std::flat_set<int> numbers{5, 2, 8, 1, 9};
    // 내부적으로 정렬된 vector 사용
}
```

**장점**: `std::map`보다 메모리 효율이 좋고, 캐시 성능이 우수하다. 작은 크기의 컨테이너나 읽기 위주 작업에 적합하다.

### C.9 `std::generator` - 코루틴 생성기

값의 시퀀스를 지연 평가하는 생성기를 쉽게 만들 수 있다.

```cpp
#include <generator>

std::generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        auto next = a + b;
        a = b;
        b = next;
    }
}

void generatorExample() {
    int count = 0;
    for (int fib : fibonacci()) {
        std::println("{}", fib);
        if (++count >= 10) break;
    }
}
```

**활용 사례**: 무한 시퀀스, 지연 계산, 파이프라인 처리 등에 유용하다.

### C.10 `constexpr` 개선

C++23에서는 더 많은 표준 라이브러리 함수가 `constexpr`을 지원한다.

```cpp
constexpr auto computeAtCompileTime() {
    // unique_ptr도 constexpr 컨텍스트에서 사용 가능
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    
    // vector 연산도 가능
    std::vector<int> numbers{1, 2, 3, 4, 5};
    int sum = 0;
    for (int n : numbers) {
        sum += n;
    }
    
    return sum;
}

static_assert(computeAtCompileTime() == 15);
```

### C.11 멀티차원 첨자 연산자

배열 접근을 더 자연스럽게 만들어준다.

```cpp
class Matrix {
    std::vector<int> data_;
    size_t rows_, cols_;
    
public:
    Matrix(size_t r, size_t c) 
        : data_(r * c), rows_(r), cols_(c) {}
    
    // C++23: 다차원 첨자 연산자
    int& operator[](size_t r, size_t c) {
        return data_[r * cols_ + c];
    }
    
    const int& operator[](size_t r, size_t c) const {
        return data_[r * cols_ + c];
    }
};

void matrixUsage() {
    Matrix m(3, 4);
    m[1, 2] = 42;  // 자연스러운 문법
    int value = m[1, 2];
}
```

### C.12 `std::move_only_function`

이동만 가능한 타입을 저장할 수 있는 함수 래퍼다.

```cpp
#include <functional>
#include <memory>

void moveOnlyFunctionExample() {
    auto ptr = std::make_unique<int>(42);
    
    // unique_ptr을 캡처 (이동만 가능)
    std::move_only_function<int()> func = 
        [p = std::move(ptr)]() { return *p; };
    
    int result = func();
    
    // std::function으로는 불가능 (복사 불가)
}
```

### C.13 문자열 포맷 개선

```cpp
#include <format>

void formatExamples() {
    // 사용자 정의 타입 포맷팅
    struct Point { int x, y; };
    
    std::println("Point: ({}, {})", 10, 20);
    
    // 정렬과 패딩
    std::println("{:>10}", "right");    // 오른쪽 정렬
    std::println("{:<10}", "left");     // 왼쪽 정렬
    std::println("{:^10}", "center");   // 가운데 정렬
    
    // 숫자 포맷
    std::println("{:#x}", 255);         // 0xff (16진수)
    std::println("{:#b}", 15);          // 0b1111 (2진수)
    std::println("{:+d}", 42);          // +42 (부호 표시)
}
```

### C.14 기타 작은 개선 사항

**`#warning` 전처리기 지시자**
```cpp
#warning "이 코드는 리팩터링이 필요합니다"
```

**`size_t` 리터럴**
```cpp
auto size = 100uz;  // size_t 타입
auto ssize = 100z;  // signed size_t 타입
```

**`std::to_underlying`**
```cpp
enum class Color { Red, Green, Blue };
Color c = Color::Red;
auto value = std::to_underlying(c);  // int로 변환
```

**범위 기반 for의 초기화 구문**
```cpp
for (auto vec = getVector(); auto& item : vec) {
    // vec는 루프 범위에서만 유효
}
```

### C.15 C++23 채택 가이드

**즉시 사용 권장**
- `std::print`, `std::println` - 간편한 출력
- `std::expected` - 오류 처리 개선
- 범위 어댑터 (chunk, slide, stride) - 데이터 처리
- `if consteval` - 컴파일 타임/런타임 분기

**프로젝트 특성에 따라 고려**
- `std::mdspan` - 다차원 데이터 처리가 많은 경우
- `std::flat_map`, `std::flat_set` - 성능이 중요한 경우
- `std::generator` - 코루틴 기반 설계
- `std::stacktrace` - 디버깅 정보가 필요한 경우

**점진적 도입**
- Deducing this - 기존 코드 리팩터링 시
- `std::move_only_function` - 이동 의미론 활용
- 멀티차원 첨자 연산자 - 새로운 클래스 설계 시

---

## 부록 D: 자주 발생하는 오류와 해결책

C++ 초보자가 자주 겪는 오류와 그 해결 방법을 정리했다. 각 오류의 원인과 해결책, 그리고 예방 방법을 제시한다.

### D.1 컴파일 오류

#### D.1.1 식별자를 찾을 수 없습니다

**오류 메시지**
```
error C2065: 'cout': 식별자를 찾을 수 없습니다.
```

**원인**
- `std::` 네임스페이스 접두사 누락
- 필요한 헤더 파일 미포함
- 철자 오류

**해결책**
```cpp
// 잘못된 코드
#include <iostream>
int main() {
    cout << "Hello\n";  // 오류!
}

// 해결책 1: std:: 접두사 사용
#include <iostream>
int main() {
    std::cout << "Hello\n";
}

// 해결책 2: using 선언
#include <iostream>
using std::cout;
int main() {
    cout << "Hello\n";
}
```

**예방 방법**: Modern C++에서는 `std::` 접두사를 명시적으로 사용하는 것을 권장한다.

#### D.1.2 형식 불일치

**오류 메시지**
```
error C2440: '=': 'const char [6]'에서 'int'(으)로 변환할 수 없습니다.
```

**원인**
- 호환되지 않는 타입 간 대입
- 잘못된 타입 추론

**해결책**
```cpp
// 잘못된 코드
int number = "hello";  // 오류!

// 해결책
std::string text = "hello";
// 또는
auto text = "hello"s;  // std::string 리터럴
```

#### D.1.3 함수 오버로드 모호성

**오류 메시지**
```
error C2668: 'function': 오버로드된 함수에 대한 호출이 모호합니다.
```

**원인**
- 여러 오버로드 함수가 같은 우선순위로 매칭됨

**해결책**
```cpp
// 문제 있는 코드
void process(int value) { }
void process(double value) { }

int main() {
    process(3.14f);  // float는 int와 double 모두 변환 가능
}

// 해결책 1: 명시적 캐스팅
process(static_cast<double>(3.14f));

// 해결책 2: float 오버로드 추가
void process(float value) { }

// 해결책 3: 템플릿 사용
template<typename T>
void process(T value) { }
```

#### D.1.4 정의되지 않은 참조

**오류 메시지**
```
error LNK2019: 확인할 수 없는 외부 기호 "void __cdecl function(void)"
```

**원인**
- 선언은 있지만 정의가 없음
- 라이브러리 링크 누락
- 함수 시그니처 불일치

**해결책**
```cpp
// 문제: 선언만 있고 정의가 없음
void calculate();  // 선언
int main() {
    calculate();   // 링크 오류!
}

// 해결책: 정의 추가
void calculate() {
    // 구현
}

// 템플릿 관련 문제
// header.h
template<typename T>
class MyClass {
    void process();  // 선언만
};

// source.cpp (잘못됨)
template<typename T>
void MyClass<T>::process() {
    // 이렇게 하면 링크 오류 발생
}

// 올바른 방법: 헤더에 정의 포함
template<typename T>
class MyClass {
    void process() {
        // 헤더에 정의
    }
};
```

### D.2 런타임 오류

#### D.2.1 접근 위반 (Segmentation Fault)

**원인**
- 널 포인터 역참조
- 범위를 벗어난 배열 접근
- 삭제된 메모리 접근

**해결책**
```cpp
// 문제 1: 널 포인터
int* ptr = nullptr;
*ptr = 10;  // 크래시!

// 해결책: 사용 전 검사
if (ptr != nullptr) {
    *ptr = 10;
}

// 더 나은 방법: 스마트 포인터 사용
auto ptr = std::make_unique<int>(10);
// nullptr 체크 불필요, 자동 메모리 관리

// 문제 2: 범위 벗어난 접근
std::vector<int> numbers{1, 2, 3};
int value = numbers[10];  // 정의되지 않은 동작!

// 해결책 1: at() 사용 (경계 검사)
try {
    int value = numbers.at(10);
} catch (const std::out_of_range& e) {
    std::cerr << "범위 오류: " << e.what() << '\n';
}

// 해결책 2: 범위 기반 for 사용
for (int num : numbers) {
    // 안전한 접근
}
```

#### D.2.2 Use After Free

**원인**
- 삭제된 메모리를 계속 사용

**해결책**
```cpp
// 문제
int* ptr = new int(42);
delete ptr;
*ptr = 10;  // 이미 삭제된 메모리 사용!

// 해결책 1: 삭제 후 nullptr 설정
int* ptr = new int(42);
delete ptr;
ptr = nullptr;
if (ptr) {
    *ptr = 10;  // 실행되지 않음
}

// 해결책 2: 스마트 포인터 사용 (권장)
auto ptr = std::make_unique<int>(42);
// 소멸 시 자동으로 메모리 해제
// ptr = nullptr; 할당 시 자동으로 이전 메모리 해제
```

#### D.2.3 메모리 누수

**원인**
- 할당한 메모리를 해제하지 않음

**해결책**
```cpp
// 문제
void problematicFunction() {
    int* data = new int[1000];
    // delete[] data; 누락!
}  // 메모리 누수

// 해결책 1: RAII 패턴
void betterFunction() {
    std::vector<int> data(1000);
    // 함수 종료 시 자동으로 메모리 해제
}

// 해결책 2: 스마트 포인터
void smartFunction() {
    auto data = std::make_unique<int[]>(1000);
    // 자동 메모리 관리
}

// 복잡한 경우
class Resource {
    int* data;
public:
    Resource() : data(new int[100]) {}
    ~Resource() { delete[] data; }
    
    // Rule of Five 준수
    Resource(const Resource&) = delete;
    Resource& operator=(const Resource&) = delete;
    Resource(Resource&&) noexcept = default;
    Resource& operator=(Resource&&) noexcept = default;
};
```

### D.3 논리 오류

#### D.3.1 정수 나누기 문제

**원인**
- 정수 나눗셈은 소수점 이하를 버림

**해결책**
```cpp
// 문제
int a = 5;
int b = 2;
double result = a / b;  // 2.0 (예상: 2.5)

// 해결책 1: 캐스팅
double result = static_cast<double>(a) / b;  // 2.5

// 해결책 2: 리터럴 사용
double result = 5.0 / 2;  // 2.5

// 해결책 3: 하나를 double로
double a = 5;
int b = 2;
double result = a / b;  // 2.5
```

#### D.3.2 부동소수점 비교

**원인**
- 부동소수점 연산의 정밀도 문제

**해결책**
```cpp
// 문제
double a = 0.1 + 0.2;
if (a == 0.3) {  // false일 수 있음!
    std::cout << "같음\n";
}

// 해결책: epsilon 사용
const double EPSILON = 1e-9;
if (std::abs(a - 0.3) < EPSILON) {
    std::cout << "같음\n";
}

// C++20 이후: std::numeric_limits 사용
#include <limits>
if (std::abs(a - 0.3) < std::numeric_limits<double>::epsilon()) {
    std::cout << "같음\n";
}
```

#### D.3.3 무한 루프

**원인**
- 잘못된 루프 조건
- 루프 변수가 업데이트되지 않음

**해결책**
```cpp
// 문제 1: 부호 없는 정수 루프
for (size_t i = 10; i >= 0; --i) {  // 무한 루프!
    // size_t는 항상 >= 0
}

// 해결책: 부호 있는 정수 사용
for (int i = 10; i >= 0; --i) {
    // 올바른 동작
}

// 또는 역순 반복
for (size_t i = 11; i > 0; --i) {
    size_t index = i - 1;
    // index 사용
}

// 문제 2: 조건 누락
size_t i = 0;
while (i < 10) {
    std::cout << i << '\n';
    // i++; 누락! 무한 루프
}

// 해결책: 범위 기반 for 사용 (가능한 경우)
std::vector<int> numbers{1, 2, 3, 4, 5};
for (int num : numbers) {
    std::cout << num << '\n';
}
```

### D.4 Visual Studio 특정 문제

#### D.4.1 미리 컴파일된 헤더 오류

**오류 메시지**
```
fatal error C1010: 미리 컴파일된 헤더를 찾는 동안 예상치 않은 파일의 끝이 나타났습니다.
```

**해결책**
```cpp
// 각 .cpp 파일 맨 위에 추가
#include "pch.h"  // 또는 프로젝트에서 설정한 이름

// 또는 프로젝트 설정에서 미리 컴파일된 헤더 사용 안 함
// 프로젝트 속성 → C/C++ → 미리 컴파일된 헤더 → '사용 안 함'
```

#### D.4.2 문자 인코딩 문제

**오류 메시지**
```
warning C4819: 현재 코드 페이지에서 표현할 수 없는 문자가 있습니다.
```

**해결책**
```cpp
// 파일을 UTF-8 BOM으로 저장
// Visual Studio: 파일 → 다른 이름으로 저장 → 인코딩하여 저장 → UTF-8 with signature

// 또는 소스 파일 맨 위에 추가
#pragma execution_character_set("utf-8")

// Modern C++ 방식: u8 접두사 사용
auto text = u8"한글 문자열";
```

### D.5 일반적인 실수와 예방법

#### D.5.1 초기화하지 않은 변수

```cpp
// 문제
int value;  // 초기화 안 됨, 쓰레기 값
std::cout << value;  // 정의되지 않은 동작

// 해결책: 항상 초기화
int value = 0;
// 또는
int value{};  // 0으로 초기화 (권장)
// 또는
auto value = 0;
```

#### D.5.2 댕글링 참조

```cpp
// 문제
const std::string& getTemp() {
    std::string temp = "temporary";
    return temp;  // 지역 변수 반환!
}  // temp 소멸

int main() {
    const std::string& ref = getTemp();  // 댕글링 참조!
    std::cout << ref;  // 정의되지 않은 동작
}

// 해결책 1: 값으로 반환
std::string getTemp() {
    std::string temp = "temporary";
    return temp;  // 이동 또는 복사
}

// 해결책 2: string_view 사용 (리터럴인 경우)
std::string_view getTemp() {
    return "temporary";  // 리터럴은 영구적
}
```

#### D.5.3 복사 생성자 누락

```cpp
// 문제
class Resource {
    int* data;
public:
    Resource() : data(new int[100]) {}
    ~Resource() { delete[] data; }
    // 복사 생성자 없음!
};

Resource r1;
Resource r2 = r1;  // 얕은 복사
// r1과 r2가 같은 메모리 가리킴
// 소멸 시 double free!

// 해결책 1: Rule of Five 준수
class Resource {
    int* data;
public:
    Resource() : data(new int[100]) {}
    ~Resource() { delete[] data; }
    
    // 복사 생성자
    Resource(const Resource& other) 
        : data(new int[100]) {
        std::copy(other.data, other.data + 100, data);
    }
    
    // 복사 대입 연산자
    Resource& operator=(const Resource& other) {
        if (this != &other) {
            delete[] data;
            data = new int[100];
            std::copy(other.data, other.data + 100, data);
        }
        return *this;
    }
    
    // 이동 생성자
    Resource(Resource&& other) noexcept 
        : data(other.data) {
        other.data = nullptr;
    }
    
    // 이동 대입 연산자
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};

// 해결책 2: 복사 금지 및 스마트 포인터 사용 (권장)
class Resource {
    std::unique_ptr<int[]> data;
public:
    Resource() : data(std::make_unique<int[]>(100)) {}
    
    // 복사 금지
    Resource(const Resource&) = delete;
    Resource& operator=(const Resource&) = delete;
    
    // 이동은 자동 생성됨
    Resource(Resource&&) = default;
    Resource& operator=(Resource&&) = default;
};
```

### D.6 디버깅 팁

**효과적인 디버깅 방법**

1. **중단점 활용**
```cpp
void complexFunction() {
    int step1 = calculate1();
    // 여기 중단점 설정 (F9)
    int step2 = calculate2(step1);
    // 조사식에서 step1, step2 값 확인
    int result = calculate3(step2);
}
```

2. **조건부 중단점**
```cpp
for (int i = 0; i < 1000; ++i) {
    process(i);
    // 중단점 설정 후 우클릭 → 조건
    // i == 500 설정
}
```

3. **로깅 추가**
```cpp
#include <print>

void debugFunction(int value) {
    std::println("함수 진입: value = {}", value);
    
    auto result = calculate(value);
    std::println("계산 결과: {}", result);
    
    if (result < 0) {
        std::println("경고: 음수 결과");
    }
}
```

4. **assert 사용**
```cpp
#include <cassert>

void processArray(const std::vector<int>& arr) {
    assert(!arr.empty() && "배열이 비어있으면 안 됨");
    assert(arr.size() <= 1000 && "배열이 너무 큼");
    
    // 처리...
}
```

5. **static_assert로 컴파일 타임 검증**
```cpp
template<typename T>
void numericOnly(T value) {
    static_assert(std::is_arithmetic_v<T>, 
                  "숫자 타입만 허용됩니다");
    // ...
}
```

---

## 부록 E: 코딩 스타일 체크리스트

일관성 있고 읽기 쉬운 코드를 작성하기 위한 가이드라인이다. Modern C++ 모범 사례를 따른다.

### E.1 명명 규칙

**변수 및 함수**
```cpp
// ✓ 좋은 예: 명확하고 설명적인 이름
int studentCount = 0;
double calculateAverage(const std::vector<double>& scores);
std::string userName;

// ✗ 나쁜 예: 모호하거나 짧은 이름
int sc = 0;
double calc(const std::vector<double>& s);
std::string un;
```

**클래스 및 타입**
```cpp
// ✓ 좋은 예: PascalCase 사용
class StudentManager {
    // ...
};

struct Point2D {
    double x, y;
};

// ✗ 나쁜 예
class student_manager { };
struct point2d { };
```

**상수**
```cpp
// ✓ 좋은 예: const/constexpr 사용
constexpr int MaxStudents = 100;
const double Pi = 3.14159265359;

// ✗ 나쁜 예: 매직 넘버 직접 사용
for (int i = 0; i < 100; ++i) { }  // 100이 무엇인지 불명확
```

**멤버 변수**
```cpp
class Example {
    // ✓ 좋은 예: 접미사로 구분
    int value_;
    std::string name_;
    
    // 또는 접두사
    int m_value;
    std::string m_name;
    
public:
    // getter/setter
    int getValue() const { return value_; }
    void setValue(int v) { value_ = v; }
};
```

### E.2 코드 구조

**파일 구조**
```cpp
// Example.h
#pragma once  // 또는 include guard

#include <vector>
#include <string>

// 네임스페이스
namespace MyProject {

// 전방 선언
class Helper;

// 클래스 선언
class Example {
public:
    // 생성자
    Example();
    
    // public 메서드
    void process();
    
private:
    // private 멤버
    int data_;
    std::vector<int> items_;
    
    // private 메서드
    void internalProcess();
};

}  // namespace MyProject
```

**함수 크기**
```cpp
// ✓ 좋은 예: 작고 단일 책임을 가진 함수
void validateInput(const std::string& input) {
    if (input.empty()) {
        throw std::invalid_argument("입력이 비어있음");
    }
}

void processInput(const std::string& input) {
    validateInput(input);
    // 처리...
}

// ✗ 나쁜 예: 너무 긴 함수
void doEverything(const std::string& input) {
    // 검증
    if (input.empty()) { /* ... */ }
    // 파싱
    // 변환
    // 저장
    // ... 200줄 이상
}
```

### E.3 Modern C++ 기능 사용

**타입 추론**
```cpp
// ✓ 좋은 예: auto로 명확한 경우
auto numbers = std::vector<int>{1, 2, 3, 4, 5};
auto ptr = std::make_unique<Student>();

for (const auto& item : container) {
    // ...
}

// ✗ 나쁜 예: 타입이 불명확한 auto
auto value = calculate();  // 반환 타입이 무엇인지?
```

**범위 기반 for**
```cpp
// ✓ 좋은 예
std::vector<int> numbers{1, 2, 3, 4, 5};
for (const auto& num : numbers) {
    std::cout << num << '\n';
}

// ✗ 나쁜 예: 인덱스 기반 루프 (불필요한 경우)
for (size_t i = 0; i < numbers.size(); ++i) {
    std::cout << numbers[i] << '\n';
}
```

**스마트 포인터**
```cpp
// ✓ 좋은 예: unique_ptr 사용
auto student = std::make_unique<Student>("Alice");

// 소유권 이전
auto another = std::move(student);

// ✗ 나쁜 예: 원시 포인터와 수동 메모리 관리
Student* student = new Student("Alice");
// ... 사용
delete student;  // 잊기 쉬움
```

**람다 표현식**
```cpp
// ✓ 좋은 예: 짧은 람다
std::vector<int> numbers{1, 2, 3, 4, 5};
auto squared = numbers 
    | std::views::transform([](int x) { return x * x; });

// 복잡한 경우 별도 함수로
int complexCalculation(int x) {
    // 여러 줄의 로직
    return result;
}
auto result = numbers 
    | std::views::transform(complexCalculation);
```

### E.4 오류 처리

**예외 사용**
```cpp
// ✓ 좋은 예: 예외로 오류 처리
std::vector<int> getData(const std::string& filename) {
    std::ifstream file(filename);
    if (!file) {
        throw std::runtime_error("파일을 열 수 없음: " + filename);
    }
    
    // 데이터 읽기
    return data;
}

// 사용
try {
    auto data = getData("config.txt");
    process(data);
} catch (const std::exception& e) {
    std::cerr << "오류: " << e.what() << '\n';
}

// ✗ 나쁜 예: 오류 코드 반환
int getData(const std::string& filename, std::vector<int>& out) {
    // 성공: 0, 실패: -1
    // 오류 정보 손실
}
```

**noexcept 명시**
```cpp
// ✓ 좋은 예: 예외를 던지지 않는 함수 표시
class Resource {
public:
    Resource(Resource&& other) noexcept
        : data_(std::move(other.data_)) {
    }
    
    void swap(Resource& other) noexcept {
        std::swap(data_, other.data_);
    }
    
private:
    std::vector<int> data_;
};
```

### E.5 주석과 문서화

**주석 작성**
```cpp
// ✓ 좋은 예: 왜(why)를 설명
void processData(std::vector<int>& data) {
    // 데이터를 역순으로 정렬해야 최신 항목이 먼저 표시됨
    std::ranges::sort(data, std::greater{});
}

// ✗ 나쁜 예: 무엇(what)을 반복
void processData(std::vector<int>& data) {
    // 데이터를 정렬함
    std::ranges::sort(data, std::greater{});
}
```

**문서화 주석**
```cpp
/// 학생 성적의 평균을 계산한다.
/// @param scores 성적 리스트 (빈 배열이면 안 됨)
/// @return 평균 점수
/// @throws std::invalid_argument scores가 비어있는 경우
double calculateAverage(const std::vector<double>& scores) {
    if (scores.empty()) {
        throw std::invalid_argument("빈 배열");
    }
    
    double sum = std::accumulate(scores.begin(), scores.end(), 0.0);
    return sum / scores.size();
}
```

### E.6 포맷팅

**들여쓰기와 간격**
```cpp
// ✓ 좋은 예: 일관된 들여쓰기 (4칸)
void function() {
    if (condition) {
        process();
    }
}

// 연산자 주변 공백
int result = a + b * c;
auto value = calculate(x, y, z);

// ✗ 나쁜 예: 불일치하는 간격
void function(){
    if(condition){
process();
    }
}
```

**줄 길이**
```cpp
// ✓ 좋은 예: 80-120자 이내
auto result = calculateComplexValue(
    parameter1,
    parameter2,
    parameter3,
    parameter4
);

// ✗ 나쁜 예: 너무 긴 줄
auto result = calculateComplexValue(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);
```

### E.7 성능 고려사항

**불필요한 복사 방지**
```cpp
// ✓ 좋은 예: const 참조로 전달
void process(const std::vector<int>& data) {
    for (const auto& item : data) {
        // ...
    }
}

// ✗ 나쁜 예: 값으로 전달 (큰 객체)
void process(std::vector<int> data) {  // 복사!
    // ...
}
```

**이동 의미론 활용**
```cpp
// ✓ 좋은 예: 이동으로 효율성 향상
std::vector<int> createLargeVector() {
    std::vector<int> result(1000000);
    // 초기화...
    return result;  // 이동됨, 복사 아님
}

auto data = createLargeVector();  // 효율적
```

**reserve 사용**
```cpp
// ✓ 좋은 예: 미리 용량 확보
std::vector<int> numbers;
numbers.reserve(1000);
for (int i = 0; i < 1000; ++i) {
    numbers.push_back(i);
}

// ✗ 나쁜 예: 여러 번 재할당
std::vector<int> numbers;
for (int i = 0; i < 1000; ++i) {
    numbers.push_back(i);  // 재할당 가능
}
```

### E.8 안전성

**범위 검사**
```cpp
// ✓ 좋은 예: at()으로 안전한 접근
try {
    int value = numbers.at(index);
} catch (const std::out_of_range&) {
    // 오류 처리
}

// 또는 검사 후 접근
if (index < numbers.size()) {
    int value = numbers[index];
}

// ✗ 나쁜 예: 검사 없는 접근
int value = numbers[index];  // 범위 초과 시 정의되지 않은 동작
```

**포인터 검증**
```cpp
// ✓ 좋은 예: 사용 전 검증
void process(const Student* student) {
    if (student == nullptr) {
        return;  // 또는 예외 던지기
    }
    
    // 사용
}

// 더 나은 방법: 스마트 포인터와 참조
void process(const Student& student) {
    // nullptr 불가능
}
```

### E.9 체크리스트

**코드 작성 전**
- [ ] 함수/클래스 이름이 명확한가?
- [ ] 적절한 타입을 사용하는가?
- [ ] 필요한 경우 const를 사용하는가?

**코드 작성 중**
- [ ] 스마트 포인터를 사용하는가?
- [ ] 범위 기반 for를 사용하는가?
- [ ] auto를 적절히 사용하는가?
- [ ] 불필요한 복사를 피하는가?

**코드 작성 후**
- [ ] 주석이 "왜"를 설명하는가?
- [ ] 함수가 단일 책임을 가지는가?
- [ ] 오류 처리가 적절한가?
- [ ] 테스트를 작성했는가?
- [ ] 코드 리뷰를 받았는가?

### E.10 추천 도구

**정적 분석**
- Visual Studio Code Analysis (C++ Core Guidelines 검사)
- Clang-Tidy
- Cppcheck

**포맷팅**
- ClangFormat (일관된 코드 스타일)
- Visual Studio의 자동 포맷 기능

**린팅**
```cpp
// .clang-format 파일 예
BasedOnStyle: Google
IndentWidth: 4
ColumnLimit: 100
```

이 체크리스트를 습관화하면 자연스럽게 고품질의 Modern C++ 코드를 작성할 수 있다.
