# 모던 C++로 시작하는 안전하고 쉬운 C++ 프로그래밍 

저자: 최흥배, Claude AI   
    
권장 개발 환경
- **IDE**: Visual Studio 2022 (Community 이상)
- **컴파일러**: MSVC v143 (C++20 지원)
- **OS**: Windows 10 이상

-----  
  
# Chapter 12: 컨테이너와 알고리즘

## 12.1 STL 컨테이너 개요
표준 템플릿 라이브러리(Standard Template Library, STL)는 C++에서 가장 강력하고 유용한 기능 중 하나다. STL은 데이터를 저장하고 관리하는 컨테이너(container)와 이들을 조작하는 알고리즘(algorithm)을 제공한다. Modern C++에서는 이러한 STL 컨테이너를 사용하여 안전하고 효율적으로 데이터를 다룰 수 있다.

### 12.1.1 왜 STL 컨테이너를 사용하는가?
전통적인 C 스타일 배열은 여러 문제점을 가지고 있다.

```cpp
#include <iostream>

void oldStyleArray() {
    // C 스타일 배열의 문제점
    int arr[5] = {1, 2, 3, 4, 5};
    
    // 1. 크기를 직접 추적해야 함
    int size = 5;
    
    // 2. 경계 검사가 없음 - 위험!
    // arr[10] = 100;  // 정의되지 않은 동작
    
    // 3. 동적 크기 조정 불가능
    // 더 많은 원소를 추가하려면 새 배열을 만들어야 함
    
    // 4. 함수에 전달할 때 크기 정보 손실
    // void processArray(int arr[])  // 크기를 알 수 없음
}

int main() {
    oldStyleArray();
    return 0;
}
```

STL 컨테이너는 이러한 문제를 모두 해결한다.

```cpp
#include <iostream>
#include <vector>

int main() {
    // STL 컨테이너의 장점
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 1. 크기를 자동으로 추적
    std::cout << "크기: " << numbers.size() << "\n";
    
    // 2. 안전한 접근 (at() 사용 시)
    try {
        numbers.at(10) = 100;  // 예외 발생
    }
    catch (const std::out_of_range& e) {
        std::cout << "오류: " << e.what() << "\n";
    }
    
    // 3. 동적 크기 조정 가능
    numbers.push_back(6);
    numbers.push_back(7);
    std::cout << "새 크기: " << numbers.size() << "\n";
    
    // 4. 범위 기반 for 루프 지원
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

### 12.1.2 STL 컨테이너의 분류
STL 컨테이너는 크게 세 가지로 분류된다.

**시퀀스 컨테이너 (Sequence Containers)**: 원소들이 선형으로 순서대로 저장된다.   
- `std::vector`: 동적 배열, 끝에서의 삽입/삭제가 빠름
- `std::array`: 고정 크기 배열, 스택에 할당
- `std::deque`: 양쪽 끝에서 삽입/삭제가 빠름
- `std::list`: 이중 연결 리스트, 중간 삽입/삭제가 빠름
- `std::forward_list`: 단일 연결 리스트, 메모리 효율적

**연관 컨테이너 (Associative Containers)**: 키를 기반으로 정렬된 상태로 저장된다.

- `std::set`: 중복 없는 정렬된 집합
- `std::map`: 키-값 쌍의 정렬된 컨테이너
- `std::multiset`: 중복 허용 정렬된 집합
- `std::multimap`: 중복 키 허용 정렬된 맵

**비정렬 연관 컨테이너 (Unordered Associative Containers)**: 해시 테이블 기반, 빠른 검색.

- `std::unordered_set`: 해시 기반 집합
- `std::unordered_map`: 해시 기반 맵

**컨테이너 어댑터 (Container Adapters)**: 다른 컨테이너를 감싸서 특정 인터페이스 제공.

- `std::stack`: LIFO (후입선출) 구조
- `std::queue`: FIFO (선입선출) 구조
- `std::priority_queue`: 우선순위 큐

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <stack>

int main() {
    // 시퀀스 컨테이너
    std::vector<int> vec = {1, 2, 3};
    std::list<std::string> lst = {"apple", "banana", "cherry"};
    
    // 연관 컨테이너
    std::set<int> s = {3, 1, 4, 1, 5};  // 중복 제거, 정렬
    std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}};
    
    // 컨테이너 어댑터
    std::stack<int> stk;
    stk.push(10);
    stk.push(20);
    
    std::cout << "set 내용 (정렬됨): ";
    for (int n : s) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    std::cout << "map 내용:\n";
    for (const auto& [name, age] : ages) {
        std::cout << name << ": " << age << "세\n";
    }
    
    return 0;
}
```
   

</br>  
</br>  
  

## 12.2 std::vector 완전 정복
`std::vector`는 가장 많이 사용되는 컨테이너다. 동적 배열로 구현되어 있으며, 크기를 자동으로 조정한다.

### 12.2.1 vector의 기본 사용법

```cpp
#include <iostream>
#include <vector>
#include <string>

int main() {
    // 1. 다양한 초기화 방법
    std::vector<int> v1;                        // 빈 벡터
    std::vector<int> v2(5);                     // 5개의 0
    std::vector<int> v3(5, 10);                 // 5개의 10
    std::vector<int> v4 = {1, 2, 3, 4, 5};      // 초기화 리스트
    std::vector<int> v5{1, 2, 3, 4, 5};         // 균일 초기화 (권장)
    
    // 2. 원소 추가
    std::vector<std::string> names;
    names.push_back("Alice");           // 복사로 추가
    names.emplace_back("Bob");          // 제자리 생성 (더 효율적)
    
    std::cout << "이름 목록:\n";
    for (const auto& name : names) {
        std::cout << "- " << name << "\n";
    }
    
    // 3. 크기와 용량
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    std::cout << "\n크기: " << numbers.size() << "\n";
    std::cout << "용량: " << numbers.capacity() << "\n";
    std::cout << "비어있음? " << (numbers.empty() ? "예" : "아니오") << "\n";
    
    // 4. 원소 접근
    std::cout << "\n원소 접근:\n";
    std::cout << "첫 번째 원소: " << numbers.front() << "\n";
    std::cout << "마지막 원소: " << numbers.back() << "\n";
    std::cout << "인덱스 2: " << numbers[2] << "\n";
    std::cout << "인덱스 2 (안전): " << numbers.at(2) << "\n";
    
    // 5. 원소 수정
    numbers[0] = 100;
    numbers.at(1) = 200;
    
    std::cout << "\n수정 후: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

### 12.2.2 vector의 메모리 관리
`vector`는 필요에 따라 자동으로 메모리를 재할당한다. 이 과정을 이해하는 것이 중요하다.

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers;
    
    std::cout << "초기 용량: " << numbers.capacity() << "\n\n";
    
    for (int i = 1; i <= 10; ++i) {
        numbers.push_back(i);
        std::cout << "원소 " << i << " 추가 후 - "
                  << "크기: " << numbers.size() 
                  << ", 용량: " << numbers.capacity() << "\n";
    }
    
    // 용량 예약으로 재할당 방지
    std::cout << "\n=== 용량 예약 ===\n";
    std::vector<int> optimized;
    optimized.reserve(10);  // 미리 10개 공간 확보
    
    std::cout << "예약 후 용량: " << optimized.capacity() << "\n";
    
    for (int i = 1; i <= 10; ++i) {
        optimized.push_back(i);
    }
    
    std::cout << "추가 후 용량: " << optimized.capacity() << "\n";
    
    // 불필요한 메모리 해제
    optimized.shrink_to_fit();
    std::cout << "축소 후 용량: " << optimized.capacity() << "\n";
    
    return 0;
}
```

### 12.2.3 vector의 삽입과 삭제

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void printVector(const std::vector<int>& v, const std::string& message) {
    std::cout << message;
    for (int num : v) {
        std::cout << num << " ";
    }
    std::cout << "\n";
}

int main() {
    std::vector<int> numbers = {10, 20, 30, 40, 50};
    
    printVector(numbers, "초기 상태: ");
    
    // 1. 끝에 추가/제거
    numbers.push_back(60);
    printVector(numbers, "push_back(60): ");
    
    numbers.pop_back();
    printVector(numbers, "pop_back(): ");
    
    // 2. 중간에 삽입
    auto it = numbers.begin() + 2;  // 세 번째 위치
    numbers.insert(it, 25);
    printVector(numbers, "insert(2, 25): ");
    
    // 3. 여러 개 삽입
    numbers.insert(numbers.begin(), 3, 5);  // 앞에 5를 3개 삽입
    printVector(numbers, "insert(begin, 3, 5): ");
    
    // 4. 특정 위치 삭제
    numbers.erase(numbers.begin());
    printVector(numbers, "erase(begin): ");
    
    // 5. 범위 삭제
    numbers.erase(numbers.begin(), numbers.begin() + 2);
    printVector(numbers, "erase(begin, begin+2): ");
    
    // 6. 조건에 맞는 원소 제거
    numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    auto removeIt = std::remove_if(numbers.begin(), numbers.end(), 
                                    [](int x) { return x % 2 == 0; });
    numbers.erase(removeIt, numbers.end());
    printVector(numbers, "짝수 제거: ");
    
    // 7. 모두 제거
    numbers.clear();
    std::cout << "clear() 후 크기: " << numbers.size() << "\n";
    
    return 0;
}
```

### 12.2.4 vector의 실전 활용

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

struct Student {
    std::string name;
    int score;
    
    void print() const {
        std::cout << name << " (" << score << "점)\n";
    }
};

int main() {
    std::vector<Student> students = {
        {"김철수", 85},
        {"이영희", 92},
        {"박민수", 78},
        {"정수진", 95},
        {"최동욱", 88}
    };
    
    std::cout << "=== 학생 목록 ===\n";
    for (const auto& student : students) {
        student.print();
    }
    
    // 점수순 정렬
    std::sort(students.begin(), students.end(), 
              [](const Student& a, const Student& b) {
                  return a.score > b.score;
              });
    
    std::cout << "\n=== 점수순 정렬 ===\n";
    for (const auto& student : students) {
        student.print();
    }
    
    // 90점 이상 학생 찾기
    std::cout << "\n=== 90점 이상 학생 ===\n";
    for (const auto& student : students) {
        if (student.score >= 90) {
            student.print();
        }
    }
    
    // 평균 계산
    int total = 0;
    for (const auto& student : students) {
        total += student.score;
    }
    double average = static_cast<double>(total) / students.size();
    std::cout << "\n평균 점수: " << average << "점\n";
    
    // 새 학생 추가
    students.emplace_back("홍길동", 90);
    std::cout << "\n학생 추가 후 총 인원: " << students.size() << "명\n";
    
    return 0;
}
```
   

</br>  
  

## 12.3 std::array - 고정 크기 배열
`std::array`는 C 스타일 배열의 안전한 대안이다. 크기가 컴파일 타임에 고정되며, 스택에 할당된다.

### 12.3.1 array의 기본 사용법

```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    // 1. 초기화
    std::array<int, 5> arr1 = {1, 2, 3, 4, 5};
    std::array<int, 5> arr2{10, 20, 30, 40, 50};
    std::array<std::string, 3> names{"Alice", "Bob", "Charlie"};
    
    // 2. 크기는 컴파일 타임에 결정
    std::cout << "배열 크기: " << arr1.size() << "\n";
    std::cout << "비어있음? " << (arr1.empty() ? "예" : "아니오") << "\n";
    
    // 3. 원소 접근
    std::cout << "\n원소 접근:\n";
    std::cout << "첫 번째: " << arr1.front() << "\n";
    std::cout << "마지막: " << arr1.back() << "\n";
    std::cout << "인덱스 2: " << arr1[2] << "\n";
    
    // 4. 안전한 접근
    try {
        arr1.at(10) = 100;  // 예외 발생
    }
    catch (const std::out_of_range& e) {
        std::cout << "범위 초과 오류: " << e.what() << "\n";
    }
    
    // 5. 범위 기반 for 루프
    std::cout << "\n배열 내용: ";
    for (const auto& value : arr1) {
        std::cout << value << " ";
    }
    std::cout << "\n";
    
    // 6. 정렬
    std::array<int, 6> unsorted{5, 2, 8, 1, 9, 3};
    std::sort(unsorted.begin(), unsorted.end());
    
    std::cout << "\n정렬 후: ";
    for (int num : unsorted) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    // 7. C 스타일 배열로 변환
    int* rawArray = arr1.data();
    std::cout << "\nC 스타일 배열 첫 원소: " << rawArray[0] << "\n";
    
    return 0;
}
```

### 12.3.2 array vs vector

```cpp
#include <iostream>
#include <array>
#include <vector>

int main() {
    std::cout << "=== std::array ===\n";
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    std::cout << "크기: " << arr.size() << "\n";
    std::cout << "메모리 위치: 스택\n";
    std::cout << "크기 변경: 불가능\n";
    std::cout << "성능: 매우 빠름 (오버헤드 없음)\n";
    
    std::cout << "\n=== std::vector ===\n";
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::cout << "크기: " << vec.size() << "\n";
    std::cout << "메모리 위치: 힙\n";
    std::cout << "크기 변경: 가능\n";
    vec.push_back(6);
    std::cout << "새 크기: " << vec.size() << "\n";
    std::cout << "성능: 빠름 (약간의 오버헤드)\n";
    
    std::cout << "\n=== 선택 가이드 ===\n";
    std::cout << "array 사용: 크기가 고정되어 있고 성능이 중요할 때\n";
    std::cout << "vector 사용: 크기가 가변적이거나 큰 데이터를 다룰 때\n";
    
    return 0;
}
```

### 12.3.3 array의 실전 활용

```cpp
#include <iostream>
#include <array>
#include <string>
#include <algorithm>

// 요일을 나타내는 열거형
enum class Weekday {
    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
};

// 요일별 작업 시간 관리
class WorkSchedule {
private:
    std::array<int, 7> hours;
    
public:
    WorkSchedule() : hours{} {}  // 모두 0으로 초기화
    
    void setHours(Weekday day, int h) {
        hours[static_cast<int>(day)] = h;
    }
    
    int getHours(Weekday day) const {
        return hours[static_cast<int>(day)];
    }
    
    int getTotalHours() const {
        int total = 0;
        for (int h : hours) {
            total += h;
        }
        return total;
    }
    
    double getAverageHours() const {
        return static_cast<double>(getTotalHours()) / hours.size();
    }
    
    void printSchedule() const {
        std::array<std::string, 7> dayNames = {
            "월", "화", "수", "목", "금", "토", "일"
        };
        
        std::cout << "=== 주간 근무 시간 ===\n";
        for (size_t i = 0; i < hours.size(); ++i) {
            std::cout << dayNames[i] << "요일: " << hours[i] << "시간\n";
        }
        std::cout << "총 근무 시간: " << getTotalHours() << "시간\n";
        std::cout << "평균 근무 시간: " << getAverageHours() << "시간\n";
    }
};

int main() {
    WorkSchedule schedule;
    
    schedule.setHours(Weekday::Monday, 8);
    schedule.setHours(Weekday::Tuesday, 7);
    schedule.setHours(Weekday::Wednesday, 8);
    schedule.setHours(Weekday::Thursday, 6);
    schedule.setHours(Weekday::Friday, 9);
    schedule.setHours(Weekday::Saturday, 4);
    schedule.setHours(Weekday::Sunday, 0);
    
    schedule.printSchedule();
    
    // 3차원 좌표 배열
    std::cout << "\n=== 3D 좌표 예제 ===\n";
    std::array<std::array<int, 3>, 4> vertices = {{
        {0, 0, 0},
        {1, 0, 0},
        {1, 1, 0},
        {0, 1, 0}
    }};
    
    for (size_t i = 0; i < vertices.size(); ++i) {
        std::cout << "정점 " << i << ": ("
                  << vertices[i][0] << ", "
                  << vertices[i][1] << ", "
                  << vertices[i][2] << ")\n";
    }
    
    return 0;
}
```
  

</br>  
  
  
## 12.4 std::map - 키-값 쌍 컨테이너
`std::map`은 키와 값의 쌍을 저장하는 연관 컨테이너다. 키는 항상 정렬된 상태로 유지되며, 각 키는 고유하다.

### 12.4.1 map의 기본 사용법

```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    // 1. 초기화
    std::map<std::string, int> ages = {
        {"Alice", 25},
        {"Bob", 30},
        {"Charlie", 28}
    };
    
    // 2. 원소 추가
    ages["David"] = 35;           // [] 연산자
    ages.insert({"Eve", 27});     // insert
    ages.emplace("Frank", 32);    // emplace (더 효율적)
    
    // 3. 원소 접근
    std::cout << "Alice의 나이: " << ages["Alice"] << "\n";
    
    // 4. 안전한 접근 (at)
    try {
        std::cout << "Bob의 나이: " << ages.at("Bob") << "\n";
        std::cout << "없는 사람: " << ages.at("Nobody") << "\n";
    }
    catch (const std::out_of_range& e) {
        std::cout << "오류: " << e.what() << "\n";
    }
    
    // 5. 키 존재 확인
    if (ages.count("Charlie") > 0) {
        std::cout << "Charlie가 존재합니다.\n";
    }
    
    // C++20: contains 사용 (더 명확)
    if (ages.contains("David")) {
        std::cout << "David가 존재합니다.\n";
    }
    
    // 6. 모든 원소 출력 (자동으로 키 기준 정렬됨)
    std::cout << "\n모든 사람의 나이:\n";
    for (const auto& [name, age] : ages) {  // 구조화된 바인딩 (C++17)
        std::cout << name << ": " << age << "세\n";
    }
    
    // 7. 원소 삭제
    ages.erase("Eve");
    std::cout << "\nEve 삭제 후 크기: " << ages.size() << "\n";
    
    // 8. 크기와 상태
    std::cout << "비어있음? " << (ages.empty() ? "예" : "아니오") << "\n";
    
    return 0;
}
```

### 12.4.2 map의 고급 기능

```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> scores = {
        {"Alice", 85},
        {"Bob", 92},
        {"Charlie", 78}
    };
    
    // 1. find를 사용한 검색
    auto it = scores.find("Bob");
    if (it != scores.end()) {
        std::cout << it->first << "의 점수: " << it->second << "\n";
        it->second = 95;  // 값 수정
        std::cout << "수정 후: " << it->second << "\n";
    }
    
    // 2. lower_bound와 upper_bound
    scores["David"] = 88;
    scores["Eve"] = 90;
    
    std::cout << "\n점수가 85 이상인 사람:\n";
    for (auto it = scores.lower_bound("Alice"); it != scores.end(); ++it) {
        if (it->second >= 85) {
            std::cout << it->first << ": " << it->second << "\n";
        }
    }
    
    // 3. insert의 반환값 활용
    auto [iter, success] = scores.insert({"Alice", 100});
    if (success) {
        std::cout << "\n새로 추가됨: " << iter->first << "\n";
    }
    else {
        std::cout << "\n이미 존재함: " << iter->first 
                  << " (기존 값: " << iter->second << ")\n";
    }
    
    // 4. insert_or_assign (C++17)
    auto [iter2, inserted] = scores.insert_or_assign("Alice", 100);
    std::cout << (inserted ? "추가됨" : "갱신됨") << ": " 
              << iter2->first << " = " << iter2->second << "\n";
    
    return 0;
}
```

### 12.4.3 map의 실전 활용

```cpp
#include <iostream>
#include <map>
#include <string>
#include <vector>

// 단어 빈도 계산
void wordFrequency() {
    std::string text = "the quick brown fox jumps over the lazy dog "
                       "the dog was really lazy";
    
    std::map<std::string, int> frequency;
    std::string word;
    
    // 단어 추출 및 빈도 계산
    for (char c : text) {
        if (c == ' ') {
            if (!word.empty()) {
                frequency[word]++;
                word.clear();
            }
        }
        else {
            word += c;
        }
    }
    
    if (!word.empty()) {
        frequency[word]++;
    }
    
    std::cout << "=== 단어 빈도 ===\n";
    for (const auto& [word, count] : frequency) {
        std::cout << word << ": " << count << "회\n";
    }
}

// 학생 성적 관리 시스템
class GradeBook {
private:
    std::map<std::string, std::vector<int>> studentGrades;
    
public:
    void addGrade(const std::string& name, int grade) {
        studentGrades[name].push_back(grade);
    }
    
    double getAverage(const std::string& name) const {
        auto it = studentGrades.find(name);
        if (it == studentGrades.end() || it->second.empty()) {
            return 0.0;
        }
        
        int sum = 0;
        for (int grade : it->second) {
            sum += grade;
        }
        
        return static_cast<double>(sum) / it->second.size();
    }
    
    void printReport() const {
        std::cout << "\n=== 성적표 ===\n";
        for (const auto& [name, grades] : studentGrades) {
            std::cout << name << "의 성적: ";
            for (int grade : grades) {
                std::cout << grade << " ";
            }
            std::cout << "(평균: " << getAverage(name) << ")\n";
        }
    }
};

int main() {
    wordFrequency();
    
    std::cout << "\n";
    
    GradeBook book;
    book.addGrade("김철수", 85);
    book.addGrade("김철수", 90);
    book.addGrade("김철수", 88);
    book.addGrade("이영희", 92);
    book.addGrade("이영희", 95);
    book.addGrade("박민수", 78);
    book.addGrade("박민수", 82);
    
    book.printReport();
    
    return 0;
}
```
  

</br>  
</br>  
    

## 12.5 반복자 (Iterator)의 개념과 사용법
반복자는 컨테이너의 원소를 순회하는 일반화된 방법을 제공한다. 포인터와 유사하게 동작하지만 더 안전하고 추상화되어 있다.

### 12.5.1 반복자의 기본

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <map>

int main() {
    // 1. vector의 반복자
    std::vector<int> vec = {10, 20, 30, 40, 50};
    
    std::cout << "=== vector 반복자 ===\n";
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << "\n";
    
    // 2. 역방향 반복자
    std::cout << "\n역방향: ";
    for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << "\n";
    
    // 3. const 반복자
    std::cout << "\nconst 반복자: ";
    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
        // *it = 100;  // 오류! const 반복자로는 수정 불가
    }
    std::cout << "\n";
    
    // 4. list의 반복자 (양방향)
    std::list<std::string> lst = {"apple", "banana", "cherry"};
    
    std::cout << "\n=== list 반복자 ===\n";
    for (auto it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << "\n";
    }
    
    // 5. map의 반복자
    std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}};
    
    std::cout << "\n=== map 반복자 ===\n";
    for (auto it = ages.begin(); it != ages.end(); ++it) {
        std::cout << it->first << ": " << it->second << "\n";
    }
    
    return 0;
}
```

### 12.5.2 반복자의 종류

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <forward_list>
#include <iterator>

int main() {
    // 1. 입력 반복자 (Input Iterator)
    // 읽기만 가능, 한 번만 순회
    
    // 2. 출력 반복자 (Output Iterator)
    // 쓰기만 가능
    std::vector<int> dest;
    std::back_insert_iterator<std::vector<int>> back_it(dest);
    *back_it++ = 10;
    *back_it++ = 20;
    std::cout << "back_insert_iterator: ";
    for (int n : dest) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 3. 순방향 반복자 (Forward Iterator)
    // 여러 번 순회 가능
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    auto fit = flist.begin();
    std::cout << "\nforward_list: ";
    for (; fit != flist.end(); ++fit) {
        std::cout << *fit << " ";
    }
    std::cout << "\n";
    
    // 4. 양방향 반복자 (Bidirectional Iterator)
    // 앞뒤로 이동 가능
    std::list<int> lst = {1, 2, 3, 4, 5};
    auto lit = lst.end();
    --lit;  // 마지막 원소
    std::cout << "\n양방향 (거꾸로): ";
    for (; lit != lst.begin(); --lit) {
        std::cout << *lit << " ";
    }
    std::cout << *lst.begin() << "\n";
    
    // 5. 임의 접근 반복자 (Random Access Iterator)
    // 임의의 위치로 직접 이동 가능
    std::vector<int> vec = {10, 20, 30, 40, 50};
    auto vit = vec.begin();
    
    std::cout << "\n임의 접근:\n";
    std::cout << "begin: " << *vit << "\n";
    std::cout << "begin + 2: " << *(vit + 2) << "\n";
    std::cout << "begin + 4: " << *(vit + 4) << "\n";
    
    // 반복자 산술
    auto vit2 = vit + 3;
    std::cout << "거리: " << (vit2 - vit) << "\n";
    
    return 0;
}
```

### 12.5.3 반복자를 활용한 알고리즘

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // 1. 특정 원소 찾기
    auto it = std::find(numbers.begin(), numbers.end(), 8);
    if (it != numbers.end()) {
        std::cout << "8을 찾음, 위치: " 
                  << std::distance(numbers.begin(), it) << "\n";
    }
    
    // 2. 조건에 맞는 원소 찾기
    auto it2 = std::find_if(numbers.begin(), numbers.end(),
                            [](int x) { return x > 7; });
    if (it2 != numbers.end()) {
        std::cout << "7보다 큰 첫 번째 수: " << *it2 << "\n";
    }
    
    // 3. 범위 복사
    std::vector<int> copy1;
    std::copy(numbers.begin(), numbers.end(), 
              std::back_inserter(copy1));
    
    std::cout << "\n복사된 벡터: ";
    for (int n : copy1) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 4. 조건부 복사
    std::vector<int> evenNumbers;
    std::copy_if(numbers.begin(), numbers.end(),
                 std::back_inserter(evenNumbers),
                 [](int x) { return x % 2 == 0; });
    
    std::cout << "\n짝수만: ";
    for (int n : evenNumbers) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 5. 변환하며 복사
    std::vector<int> doubled;
    std::transform(numbers.begin(), numbers.end(),
                   std::back_inserter(doubled),
                   [](int x) { return x * 2; });
    
    std::cout << "\n2배: ";
    for (int n : doubled) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```
   

</br>  
</br>  
  

## 12.6 std::ranges와 알고리즘 라이브러리 (C++20/C++23)
C++20에서 도입된 Ranges 라이브러리는 더 직관적이고 강력한 방식으로 컨테이너를 다룰 수 있게 해준다.  
  

### `std::ranges`가 도입된 배경과 목표
* **의도**: 기존 반복자 기반 알고리즘은 표현력과 안전성 측면에서 제약이 있었고, 컨테이너·이터레이터·뷰를 일관되게 다룰 수 있는 **범위(range) 추상화**가 필요했기 때문에 `std::ranges`가 도입되었다
* **핵심 목표**

  * **개념(Concepts)**으로 알고리즘의 요구사항을 명시해 컴파일 타임 진단을 개선한다
  * **뷰(View)**라는 지연(lazy)·비소유(non-owning) 변환 레이어를 도입해 데이터 흐름을 선언적으로 조합한다
  * **알고리즘**을 “범위 전체”에 자연스럽게 적용하고, 결과를 구조화된 반환 타입으로 제공한다
  * **투영(Projection)**, **보로잉(Borrowing)**, **센티넬(Sentinel)** 등 현대적 반복 패턴을 반영해 안전성과 유연성을 높인다


### 범위(Range)와 관련 개념
* **Range**: `begin`과 `end`로 순회 가능한 추상 시퀀스를 의미한다
* **View**: 범위를 “지연 평가”로 변형·필터링·슬라이싱하는 **가벼운 어댑터**다. 대부분 **비소유**이며 원본 범위를 참조한다
* **Viewable Range**: 뷰로 감쌀 수 있는 범위를 뜻한다. 컨테이너와 일부 임시 객체가 여기에 해당한다
* **Borrowed Range**: 원본 객체의 생애가 끝난 뒤에도 반복자가 안전하게 사용할 수 있음을 표기하는 특성이다. 보로잉 가능한 범위는 **댕글링 방지**에 유리하다
* **Subrange**: 두 반복자(또는 반복자와 센티넬) 쌍으로 구성된 경량 범위 표현이다. 많은 알고리즘의 반환 타입으로 쓰인다
* **Sentinel**: 끝을 나타내는 값으로, 반복자와 **서로 다른 타입**일 수 있다. 이는 C 스타일 문자열처럼 “끝 값”이 특별하게 표현되는 구조를 효율적으로 다루기 위함이다

  
###  Range 관련 개념(Concepts) 계층
* **`range`**: `begin/end`를 제공하는 모든 시퀀스다
* **입력 계열**: `input_range` → `forward_range` → `bidirectional_range` → `random_access_range` → `contiguous_range`로 점진적으로 강한 요구를 가진다
* **특성 개념**: `sized_range`(크기 산출 가능), `borrowed_range`, `view`, `viewable_range` 등이 있다
* 이들 개념은 알고리즘의 템플릿 인자를 **제약**해, 잘못된 조합을 컴파일 단계에서 명확히 차단한다

  
###  Range 어댑터와 파이프라인
* **Range 어댑터**는 `views::filter`, `views::transform`, `views::take`, `views::drop`, `views::reverse`, **결합 어댑터**(예: join, join_with), **슬라이싱/분할**(chunk, slide, split), **재간격**(stride) 등으로 구성된다
* 어댑터는 **지연 평가**를 통해 실제 요소 접근 시점에 연산을 수행하므로, **불필요한 중간 저장을 줄이고** 복잡한 데이터 흐름을 **선언적으로** 표현할 수 있다
* 파이프라인 조합은 어댑터의 결합 가능한 특성 덕분에 **가독성**과 **서술성**을 높인다
* 많은 뷰는 비소유이므로 **원본 데이터의 생애**가 파이프라인 사용 범위를 **충분히 덮도록** 보장해야 한다

### Ranges 알고리즘의 특징
* **범위 전체를 입력으로 받는 오버로드**를 제공한다. 기존 `std::` 알고리즘의 반복자 쌍 버전과 병존한다
* 결과는 `in_out_result`, `minmax_result`, `fold_left_result` 등 **구조화된 결과 타입**으로 반환되어, 여러 값을 명확하게 전달한다
* **프로젝션(Projection)** 인자를 통해 요소에서 비교 키를 추출하거나 사전 변환을 적용할 수 있다. 이는 보일러플레이트와 임시 객체 생성을 줄인다
* 대부분의 알고리즘은 범위 개념 제약을 엄격히 적용하므로, **요구되는 반복 능력**(예: 정렬에 `random_access_range + sortable`)이 충족되지 않으면 컴파일 타임에 오류가 발생한다
* **복잡도 보존**을 목표로 하며, 기존 알고리즘과 동등한 점근적 비용을 유지한다


### 프로젝션과 비교자
* **비교자(Comparator)**는 정렬·검색·최소/최대 선택 등에서 비교 규칙을 정의한다
* **프로젝션**은 비교 전에 요소에서 **비교 키를 추출**하는 단항 함수 역할을 한다
* 비교자와 프로젝션의 조합은 객체 컬렉션에서 특정 멤버 기준 정렬·검색을 **간결하고 명시적으로** 작성하도록 돕는다


### 이터레이터·센티넬 모델의 실용성
* **이종형 끝점**을 허용하는 센티넬 모델은, 끝판정이 특수한 시퀀스(예: 널로 종료되는 시퀀스)를 **복사 없는** 저비용 접근으로 가능하게 한다
* 이로 인해 일부 범위는 `begin`과 `end`의 타입이 다르며, 알고리즘은 이를 전제로 안전하게 동작한다
* 반복자 요구사항은 `iterator_concept`로 정제되어, 알고리즘이 필요로 하는 **최소 능력**만 요구할 수 있다


### 소유 뷰와 비소유 뷰, 수명 관리
* **대부분의 뷰는 비소유**로, 원본 범위가 유효하지 않으면 반복자·뷰가 **댕글링**될 수 있다
* 이를 보완하기 위해 일부는 **소유 뷰(owning view)** 또는 **컨테이너 어댑터**를 제공하며, 결과를 물질화(materialize)하는 별도 지점이 필요할 수 있다
* API 설계 시, **장기 보관**이 필요한 결과는 컨테이너에 담아 소유권을 명확히 하고, **일시 변환**은 뷰 파이프라인으로 유지하는 전략이 권장된다


### Borrowed Range와 `dangling` 처리
* 알고리즘은 임시 범위를 입력으로 받을 때 반복자를 반환하면 **불안전**할 수 있다
* 이를 막기 위해 `std::ranges::dangling`과 **borrowed range** 개념을 사용해, 반환 타입을 **컴파일 타임**에 안전하게 전환한다
* 이 설계로, 잘못된 생애 가정으로 인한 **런타임 오류**를 줄인다


### 병렬·범위 알고리즘과의 관계
* 병렬 실행 정책은 C++17에서 기존 알고리즘과 함께 도입되었고, 범위 오버로드와는 **별개 축**으로 존재한다
* 일부 구현은 범위 알고리즘과 병렬 정책의 **조합을 지원**하지만, 표준에서의 적합성·가용성은 **구현체와 버전에 따라 다르므로** 사용 시 확인이 필요하다

### 상호 운용성
* 범위 알고리즘은 기존 반복자 기반 알고리즘과 **동일한 의미론**을 가지며, 필요 시 반복자 쌍로 **상호 변환**이 가능하다
* 컨테이너, 배열, 사용자 정의 범위 모두와 통합되며, **컨셉 제약**을 통해 부적합한 타입 조합을 조기에 차단한다

### 성능·예외 안전성 고려사항
* 뷰의 지연성 덕분에 **중간 버퍼링**이나 **불필요한 복사**가 줄어든다
* 단, 파이프라인이 깊어질수록 **중첩된 호출 비용**과 **디버깅 복잡도**가 증가할 수 있어, 성능 임계 경로에서는 물질화를 검토하는 것이 좋다
* 대부분의 뷰·알고리즘은 **강한 예외 보장** 또는 **기본 강도**를 지향하며, 비교자·프로젝션이 던지는 예외는 호출자 책임 범주에 속한다

### 표준의 범위와 확장
* C++20에서 핵심 개념·뷰·알고리즘의 **범위 오버로드**가 도입되었고, C++23에서 **추가 어댑터**(예: join_with, zip, chunk, slide, stride 등)와 다양한 **품질 개선**이 이어졌다
* 구현체별로 지원 범위가 다를 수 있으므로, **사용 중인 표준 모드와 라이브러리 버전**을 확인해 사용하는 것이 바람직하다

### 실무 활용 지침

* **읽기 전용 데이터 흐름**과 **파생 변환**이 많은 구간에 뷰 파이프라인을 우선 고려한다
* **명시적 생애 관리**가 필요한 결과물은 컨테이너로 물질화해 보관한다
* 성능 임계 경로에서는 파이프라인 단계 수, 캐시 지역성, 분기 예측에 미치는 영향을 검토한다
* 팀 컨벤션으로 **프로젝션·비교자·어댑터 사용 규칙**을 정해 가독성과 일관성을 확보한다


### 12.6.1 ranges의 기본 개념

```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 전통적인 방식
    std::cout << "=== 전통적인 방식 ===\n";
    std::vector<int> result1;
    std::copy_if(numbers.begin(), numbers.end(),
                 std::back_inserter(result1),
                 [](int x) { return x % 2 == 0; });
    
    for (int n : result1) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // Ranges 방식 (더 간결하고 읽기 쉬움)
    std::cout << "\n=== Ranges 방식 ===\n";
    auto even = numbers | std::views::filter([](int x) { return x % 2 == 0; });
    
    for (int n : even) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 체이닝
    std::cout << "\n=== 체이닝 ===\n";
    auto result2 = numbers
        | std::views::filter([](int x) { return x % 2 == 0; })  // 짝수
        | std::views::transform([](int x) { return x * x; });    // 제곱
    
    for (int n : result2) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

### 12.6.2 주요 ranges 뷰

```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <string>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 1. filter - 조건에 맞는 원소만
    std::cout << "짝수: ";
    for (int n : numbers | std::views::filter([](int x) { return x % 2 == 0; })) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 2. transform - 원소 변환
    std::cout << "\n제곱: ";
    for (int n : numbers | std::views::transform([](int x) { return x * x; })) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 3. take - 처음 n개만
    std::cout << "\n처음 5개: ";
    for (int n : numbers | std::views::take(5)) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 4. drop - 처음 n개 건너뛰기
    std::cout << "\n5개 건너뛴 후: ";
    for (int n : numbers | std::views::drop(5)) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 5. reverse - 역순
    std::cout << "\n역순: ";
    for (int n : numbers | std::views::reverse) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 6. 복합 체이닝
    std::cout << "\n복합 (짝수의 제곱, 처음 3개): ";
    auto complex = numbers
        | std::views::filter([](int x) { return x % 2 == 0; })
        | std::views::transform([](int x) { return x * x; })
        | std::views::take(3);
    
    for (int n : complex) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

### 12.6.3 ranges 알고리즘

```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>
#include <string>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // 1. ranges::sort
    std::ranges::sort(numbers);
    std::cout << "정렬: ";
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 2. ranges::find
    auto it = std::ranges::find(numbers, 5);
    if (it != numbers.end()) {
        std::cout << "\n5를 찾음, 인덱스: " 
                  << std::ranges::distance(numbers.begin(), it) << "\n";
    }
    
    // 3. ranges::count_if
    int evenCount = std::ranges::count_if(numbers, 
                                          [](int x) { return x % 2 == 0; });
    std::cout << "짝수 개수: " << evenCount << "\n";
    
    // 4. ranges::all_of, any_of, none_of
    bool allPositive = std::ranges::all_of(numbers, 
                                           [](int x) { return x > 0; });
    std::cout << "\n모두 양수? " << (allPositive ? "예" : "아니오") << "\n";
    
    bool hasEven = std::ranges::any_of(numbers, 
                                       [](int x) { return x % 2 == 0; });
    std::cout << "짝수가 있나? " << (hasEven ? "예" : "아니오") << "\n";
    
    // 5. ranges::for_each
    std::cout << "\n각 원소에 10 더하기: ";
    std::ranges::for_each(numbers, [](int& x) { x += 10; });
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    // 6. ranges::copy_if
    std::vector<int> large;
    std::ranges::copy_if(numbers, std::back_inserter(large),
                         [](int x) { return x > 15; });
    
    std::cout << "\n15보다 큰 수: ";
    for (int n : large) {
        std::cout << n << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```
  

</br>    
</br>    
  

## 12.7 주요 알고리즘 활용
STL은 다양한 알고리즘을 제공한다. 가장 자주 사용되는 것들을 살펴보자.

### 12.7.1 정렬 알고리즘

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

struct Person {
    std::string name;
    int age;
    
    void print() const {
        std::cout << name << " (" << age << "세)\n";
    }
};

int main() {
    // 1. 기본 정렬
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3, 7};
    
    std::sort(numbers.begin(), numbers.end());
    std::cout << "오름차순: ";
    for (int n : numbers) std::cout << n << " ";
    std::cout << "\n";
    
    // 2. 내림차순 정렬
    std::sort(numbers.begin(), numbers.end(), std::greater<int>());
    std::cout << "내림차순: ";
    for (int n : numbers) std::cout << n << " ";
    std::cout << "\n";
    
    // 3. 커스텀 비교 함수
    std::vector<Person> people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 30},
        {"David", 25}
    };
    
    // 나이순 정렬
    std::sort(people.begin(), people.end(),
              [](const Person& a, const Person& b) {
                  return a.age < b.age;
              });
    
    std::cout << "\n나이순:\n";
    for (const auto& p : people) p.print();
    
    // 나이순, 같으면 이름순
    std::sort(people.begin(), people.end(),
              [](const Person& a, const Person& b) {
                  if (a.age != b.age) return a.age < b.age;
                  return a.name < b.name;
              });
    
    std::cout << "\n나이순 (같으면 이름순):\n";
    for (const auto& p : people) p.print();
    
    // 4. 부분 정렬
    std::vector<int> nums = {9, 5, 3, 7, 1, 8, 2, 6, 4};
    std::partial_sort(nums.begin(), nums.begin() + 3, nums.end());
    
    std::cout << "\n상위 3개만 정렬: ";
    for (int n : nums) std::cout << n << " ";
    std::cout << "\n";
    
    // 5. 정렬 여부 확인
    std::vector<int> sorted = {1, 2, 3, 4, 5};
    std::cout << "\n정렬되어 있나? " 
              << (std::is_sorted(sorted.begin(), sorted.end()) ? "예" : "아니오") 
              << "\n";
    
    return 0;
}
```

### 12.7.2 검색 알고리즘

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 1. find - 선형 검색
    auto it1 = std::find(numbers.begin(), numbers.end(), 5);
    if (it1 != numbers.end()) {
        std::cout << "5를 찾음, 인덱스: " 
                  << std::distance(numbers.begin(), it1) << "\n";
    }
    
    // 2. find_if - 조건 검색
    auto it2 = std::find_if(numbers.begin(), numbers.end(),
                            [](int x) { return x > 7; });
    if (it2 != numbers.end()) {
        std::cout << "7보다 큰 첫 번째 수: " << *it2 << "\n";
    }
    
    // 3. binary_search - 이진 검색 (정렬된 범위에서)
    bool found = std::binary_search(numbers.begin(), numbers.end(), 6);
    std::cout << "\n6이 있나? " << (found ? "예" : "아니오") << "\n";
    
    // 4. lower_bound - 처음으로 크거나 같은 위치
    auto it3 = std::lower_bound(numbers.begin(), numbers.end(), 5);
    std::cout << "5 이상인 첫 위치의 값: " << *it3 << "\n";
    
    // 5. upper_bound - 처음으로 큰 위치
    auto it4 = std::upper_bound(numbers.begin(), numbers.end(), 5);
    std::cout << "5보다 큰 첫 위치의 값: " << *it4 << "\n";
    
    // 6. count - 개수 세기
    std::vector<int> data = {1, 2, 3, 2, 4, 2, 5};
    int count = std::count(data.begin(), data.end(), 2);
    std::cout << "\n2의 개수: " << count << "\n";
    
    // 7. count_if - 조건에 맞는 개수
    int evenCount = std::count_if(data.begin(), data.end(),
                                   [](int x) { return x % 2 == 0; });
    std::cout << "짝수 개수: " << evenCount << "\n";
    
    // 8. min_element, max_element
    auto minIt = std::min_element(data.begin(), data.end());
    auto maxIt = std::max_element(data.begin(), data.end());
    std::cout << "\n최솟값: " << *minIt << ", 최댓값: " << *maxIt << "\n";
    
    return 0;
}
```

### 12.7.3 변환 알고리즘

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 1. transform - 각 원소 변환
    std::vector<int> squared;
    std::transform(numbers.begin(), numbers.end(),
                   std::back_inserter(squared),
                   [](int x) { return x * x; });
    
    std::cout << "제곱: ";
    for (int n : squared) std::cout << n << " ";
    std::cout << "\n";
    
    // 2. for_each - 각 원소에 함수 적용
    std::cout << "\n각 원소: ";
    std::for_each(numbers.begin(), numbers.end(),
                  [](int x) { std::cout << x << " "; });
    std::cout << "\n";
    
    // 3. accumulate - 누적 계산
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    std::cout << "\n합계: " << sum << "\n";
    
    int product = std::accumulate(numbers.begin(), numbers.end(), 1,
                                  std::multiplies<int>());
    std::cout << "곱: " << product << "\n";
    
    // 4. reduce (C++17) - 병렬 가능한 accumulate
    int sum2 = std::reduce(numbers.begin(), numbers.end());
    std::cout << "합계 (reduce): " << sum2 << "\n";
    
    // 5. partial_sum - 부분 합
    std::vector<int> partialSums;
    std::partial_sum(numbers.begin(), numbers.end(),
                     std::back_inserter(partialSums));
    
    std::cout << "\n부분 합: ";
    for (int n : partialSums) std::cout << n << " ";
    std::cout << "\n";
    
    // 6. adjacent_difference - 인접 차이
    std::vector<int> diffs;
    std::adjacent_difference(numbers.begin(), numbers.end(),
                             std::back_inserter(diffs));
    
    std::cout << "\n인접 차이: ";
    for (int n : diffs) std::cout << n << " ";
    std::cout << "\n";
    
    return 0;
}
```

### 12.7.4 집합 알고리즘

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

int main() {
    std::vector<int> a = {1, 2, 3, 4, 5};
    std::vector<int> b = {3, 4, 5, 6, 7};
    
    // 정렬되어 있어야 함
    std::sort(a.begin(), a.end());
    std::sort(b.begin(), b.end());
    
    // 1. set_union - 합집합
    std::vector<int> unionResult;
    std::set_union(a.begin(), a.end(),
                   b.begin(), b.end(),
                   std::back_inserter(unionResult));
    
    std::cout << "합집합: ";
    for (int n : unionResult) std::cout << n << " ";
    std::cout << "\n";
    
    // 2. set_intersection - 교집합
    std::vector<int> intersectionResult;
    std::set_intersection(a.begin(), a.end(),
                          b.begin(), b.end(),
                          std::back_inserter(intersectionResult));
    
    std::cout << "교집합: ";
    for (int n : intersectionResult) std::cout << n << " ";
    std::cout << "\n";
    
    // 3. set_difference - 차집합
    std::vector<int> diffResult;
    std::set_difference(a.begin(), a.end(),
                        b.begin(), b.end(),
                        std::back_inserter(diffResult));
    
    std::cout << "차집합 (a - b): ";
    for (int n : diffResult) std::cout << n << " ";
    std::cout << "\n";
    
    // 4. set_symmetric_difference - 대칭 차집합
    std::vector<int> symDiffResult;
    std::set_symmetric_difference(a.begin(), a.end(),
                                  b.begin(), b.end(),
                                  std::back_inserter(symDiffResult));
    
    std::cout << "대칭 차집합: ";
    for (int n : symDiffResult) std::cout << n << " ";
    std::cout << "\n";
    
    // 5. includes - 부분집합 확인
    std::vector<int> subset = {2, 3, 4};
    bool isSubset = std::includes(a.begin(), a.end(),
                                  subset.begin(), subset.end());
    
    std::cout << "\nsubset이 a의 부분집합? " 
              << (isSubset ? "예" : "아니오") << "\n";
    
    return 0;
}
```
  

</br>    
</br>    
  

## 12.8 실습 문제

### 실습 12-1: 학생 관리 시스템
다음 요구사항을 만족하는 학생 관리 시스템을 구현하라.

**요구사항:**
1. `Student` 구조체를 만든다 (이름, 학번, 점수).
2. `std::vector`를 사용하여 학생 목록을 관리한다.
3. 학생 추가, 삭제, 검색 기능을 구현한다.
4. 점수순, 이름순 정렬 기능을 구현한다.
5. 평균 점수, 최고/최저 점수를 계산한다.

**예상 출력:**

```
=== 학생 목록 ===
김철수 (20210001): 85점
이영희 (20210002): 92점
박민수 (20210003): 78점

=== 점수순 정렬 ===
이영희 (20210002): 92점
김철수 (20210001): 85점
박민수 (20210003): 78점

평균 점수: 85.0점
최고 점수: 92점 (이영희)
최저 점수: 78점 (박민수)
```

### 실습 12-2: 단어 통계
텍스트에서 단어 빈도를 계산하고 통계를 출력하는 프로그램을 작성하라.

**요구사항:**
1. `std::map`을 사용하여 단어 빈도를 저장한다.
2. 가장 많이 나온 단어를 찾는다.
3. 빈도순으로 정렬하여 출력한다.
4. 전체 단어 수와 고유 단어 수를 출력한다.

### 실습 12-3: ranges를 활용한 데이터 처리
다음 데이터 처리 작업을 ranges를 사용하여 구현하라.

**요구사항:**
1. 1부터 100까지의 숫자 중
2. 3의 배수이면서
3. 5의 배수가 아닌 수들의
4. 제곱의 합을 구하라.
  

</br>    
</br>    


## 12.9 심화 내용

### 12.9.1 커스텀 비교 함수와 함수 객체

```cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <string>

// 함수 객체를 사용한 커스텀 정렬
struct CompareByLength {
    bool operator()(const std::string& a, const std::string& b) const {
        return a.length() < b.length();
    }
};

struct Person {
    std::string name;
    int age;
};

// 다중 기준 정렬
class PersonComparator {
private:
    enum class SortKey { Name, Age };
    SortKey key;
    bool ascending;

public:
    PersonComparator(SortKey k, bool asc = true) 
        : key(k), ascending(asc) {}
    
    bool operator()(const Person& a, const Person& b) const {
        bool result;
        if (key == SortKey::Name) {
            result = a.name < b.name;
        }
        else {
            result = a.age < b.age;
        }
        return ascending ? result : !result;
    }
};

int main() {
    // 1. 길이순 정렬
    std::vector<std::string> words = {"apple", "fig", "banana", "cherry", "date"};
    std::sort(words.begin(), words.end(), CompareByLength());
    
    std::cout << "길이순 정렬:\n";
    for (const auto& word : words) {
        std::cout << word << " (" << word.length() << ")\n";
    }
    
    // 2. set에 커스텀 비교 함수 사용
    std::set<std::string, CompareByLength> orderedByLength = {
        "apple", "fig", "banana", "cherry", "date"
    };
    
    std::cout << "\nset (길이순):\n";
    for (const auto& word : orderedByLength) {
        std::cout << word << "\n";
    }
    
    // 3. 다중 기준 정렬
    std::vector<Person> people = {
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 30},
        {"David", 25}
    };
    
    std::sort(people.begin(), people.end(), 
              PersonComparator(PersonComparator::SortKey::Age, true));
    
    std::cout << "\n나이 오름차순:\n";
    for (const auto& p : people) {
        std::cout << p.name << " (" << p.age << ")\n";
    }
    
    std::sort(people.begin(), people.end(), 
              PersonComparator(PersonComparator::SortKey::Name, false));
    
    std::cout << "\n이름 내림차순:\n";
    for (const auto& p : people) {
        std::cout << p.name << " (" << p.age << ")\n";
    }
    
    return 0;
}
```

### 12.9.2 알고리즘 성능 비교

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <random>

template<typename Func>
void measureTime(const std::string& name, Func func) {
    auto start = std::chrono::high_resolution_clock::now();
    func();
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << name << ": " << duration.count() << " μs\n";
}

int main() {
    const int SIZE = 100000;
    
    // 랜덤 데이터 생성
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 1000000);
    
    std::vector<int> data(SIZE);
    for (int& n : data) {
        n = dis(gen);
    }
    
    std::cout << "=== 정렬 알고리즘 성능 비교 (" << SIZE << " 원소) ===\n\n";
    
    // 1. std::sort
    {
        auto copy = data;
        measureTime("std::sort", [&copy]() {
            std::sort(copy.begin(), copy.end());
        });
    }
    
    // 2. std::stable_sort (안정 정렬)
    {
        auto copy = data;
        measureTime("std::stable_sort", [&copy]() {
            std::stable_sort(copy.begin(), copy.end());
        });
    }
    
    // 3. std::partial_sort (상위 10%만)
    {
        auto copy = data;
        measureTime("std::partial_sort (10%)", [&copy]() {
            std::partial_sort(copy.begin(), copy.begin() + SIZE/10, copy.end());
        });
    }
    
    std::cout << "\n=== 검색 알고리즘 성능 비교 ===\n\n";
    
    std::vector<int> sorted = data;
    std::sort(sorted.begin(), sorted.end());
    
    int target = sorted[SIZE / 2];
    
    // 4. 선형 검색
    measureTime("std::find (선형)", [&sorted, target]() {
        volatile auto it = std::find(sorted.begin(), sorted.end(), target);
    });
    
    // 5. 이진 검색
    measureTime("std::binary_search", [&sorted, target]() {
        volatile bool found = std::binary_search(sorted.begin(), sorted.end(), target);
    });
    
    measureTime("std::lower_bound", [&sorted, target]() {
        volatile auto it = std::lower_bound(sorted.begin(), sorted.end(), target);
    });
    
    return 0;
}
```

### 12.9.3 컨테이너 선택 가이드

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>

void containerGuide() {
    std::cout << "=== 컨테이너 선택 가이드 ===\n\n";
    
    std::cout << "1. 빠른 임의 접근 필요 → vector\n";
    std::cout << "   - arr[i] 같은 접근이 O(1)\n";
    std::cout << "   - 끝에 추가/삭제가 빠름\n\n";
    
    std::cout << "2. 고정 크기, 스택 할당 → array\n";
    std::cout << "   - 컴파일 타임에 크기 결정\n";
    std::cout << "   - 가장 빠른 성능\n\n";
    
    std::cout << "3. 중간 삽입/삭제가 많음 → list\n";
    std::cout << "   - 중간 삽입/삭제가 O(1)\n";
    std::cout << "   - 임의 접근은 느림 O(n)\n\n";
    
    std::cout << "4. 양쪽 끝 삽입/삭제 → deque\n";
    std::cout << "   - 앞뒤 추가/삭제가 모두 빠름\n\n";
    
    std::cout << "5. 정렬된 고유 값 → set\n";
    std::cout << "   - 자동 정렬\n";
    std::cout << "   - 중복 불가\n";
    std::cout << "   - 검색 O(log n)\n\n";
    
    std::cout << "6. 빠른 검색, 순서 무관 → unordered_set\n";
    std::cout << "   - 해시 테이블\n";
    std::cout << "   - 검색 O(1) 평균\n\n";
    
    std::cout << "7. 키-값 쌍, 정렬 필요 → map\n";
    std::cout << "   - 키로 정렬\n";
    std::cout << "   - 검색 O(log n)\n\n";
    
    std::cout << "8. 키-값 쌍, 빠른 검색 → unordered_map\n";
    std::cout << "   - 해시 테이블\n";
    std::cout << "   - 검색 O(1) 평균\n\n";
}

int main() {
    containerGuide();
    return 0;
}
```

### 12.9.4 뷰(View)와 지연 평가

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    std::cout << "=== 뷰의 지연 평가 ===\n\n";
    
    // 뷰는 실제로 데이터를 복사하지 않음
    auto view = numbers 
        | std::views::filter([](int x) { 
            std::cout << "filter(" << x << ") ";
            return x % 2 == 0;
          })
        | std::views::transform([](int x) { 
            std::cout << "transform(" << x << ") ";
            return x * x;
          });
    
    std::cout << "뷰 생성 완료 (아직 평가되지 않음)\n\n";
    
    std::cout << "첫 번째 원소 접근:\n";
    auto it = view.begin();
    std::cout << "\n결과: " << *it << "\n\n";
    
    std::cout << "모든 원소 순회:\n";
    for (int n : view) {
        std::cout << "\n→ " << n << "\n";
    }
    
    // 뷰 체이닝의 메모리 효율성
    std::cout << "\n\n=== 메모리 효율성 비교 ===\n";
    
    // 전통적 방식: 중간 결과를 저장
    std::vector<int> temp1;
    std::copy_if(numbers.begin(), numbers.end(), 
                 std::back_inserter(temp1),
                 [](int x) { return x % 2 == 0; });
    
    std::vector<int> result1;
    std::transform(temp1.begin(), temp1.end(),
                   std::back_inserter(result1),
                   [](int x) { return x * x; });
    
    std::cout << "전통적 방식: 중간 벡터 2개 생성\n";
    
    // 뷰 방식: 중간 결과 없음
    auto result2 = numbers 
        | std::views::filter([](int x) { return x % 2 == 0; })
        | std::views::transform([](int x) { return x * x; });
    
    std::cout << "뷰 방식: 중간 벡터 0개 (지연 평가)\n";
    
    return 0;
}
```

이 장에서는 STL 컨테이너와 알고리즘을 배웠다. `vector`, `array`, `map` 같은 컨테이너를 사용하면 안전하고 효율적으로 데이터를 관리할 수 있다. 반복자를 이해하면 컨테이너와 알고리즘을 유연하게 조합할 수 있다. C++20의 ranges 라이브러리는 더 직관적이고 표현력 있는 코드를 작성할 수 있게 해준다. 다음 장에서는 객체지향 프로그래밍의 기초인 클래스와 객체를 배울 것이다.  